        <!DOCTYPE html>
        <html lang="en">
        <head><title>Bounded loops in BPF for the 5.3 kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/794934/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/794647/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/794934/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Bounded loops in BPF for the 5.3 kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>July 31, 2019</p>
           <p>This article was contributed by Marta Rybczyńska</p>
           </div>
<p>BPF programs have gained significantly in capabilities over the last few
years and can now perform many useful operations.  That said, BPF
developers have had to work around an annoying limitation until 
recently: they could not use loops. This restriction was recently lifted
by a <a href="/ml/netdev/20190615191225.2409862-1-ast@kernel.org/">patch
set</a> from Alexei Starovoitov that was merged for Linux 5.3. In addition to
adding support for loops, it also greatly decreases the load time of
most BPF programs.</p>

<h4>The problem</h4>

<p>Before a BPF program runs, it needs to be checked to ensure that it cannot
cause harm to the system. For example, if it does not complete in a bounded
time, it could be used to carry out a denial-of-service attack on the
system. The task of checking programs is performed by the BPF
verifier. Until recently, the verifier
could not handle loops, meaning that all programs with loops were
rejected.</p>

<p>Since loops are one of the basic ingredients of a computer program, this
limitation was often hit by developers, who worked around it by
unrolling loops (either by hand or using a compiler pragma).  It comes as
no surprise that there have been a number of
attempts to change the situation by allowing loops that provably have a limited
(and reasonable) number of iterations.  Those include a
<a href="/Articles/748032/">proof-of-concept proposal</a> from Edward
Cree. <a href="/ml/netdev/20180601092646.15353.28269.stgit@john-Precision-Tower-5810/">Another
attempt</a> by John Fastabend tried to solve the problem with loop
analysis: identifying each loop's induction variable and verifying its use.
Fastabend covered the theoretical background and the possible solutions in
<a href="/Articles/773605/">a presentation at the 2018 Linux Plumbers
Conference</a>. The kernel developers decided not to take either solution
at that time.</p>

<p>In parallel, important work has been put into optimizing the BPF
verifier, as shown in a set of <a
href="https://docs.google.com/presentation/d/1oaSa_dlInrTKMzP9_fYgLHN_I5j8pDrD0j3Y93inWiQ/edit#slide=id.g58e9ace034_0_0">Linux Storage, Filesystem and Memory
Management Summit slides</a>
by Jakub Kicinski. One important outcome of this work was 
increasing the size limitation for BPF programs in the 5.2 kernel;
instead of 4096 instructions, a program can execute up to one million.
These optimizations allow a more direct — even brute-force — approach to the
bounded-loop-checking problem: instead of adding special handling for loops,
the verifier can simply simulate the iterations of a loop as a collection
of states no different from any others.

<h4>The BPF verifier</h4>

<p>When the BPF verifier analyzes a program, it creates a model in the form of a
state machine. It checks each state for incorrect behavior; while it does
so, it records the states it has already verified. Later on, when it
reaches a state that is equivalent to one that was already verified, it can
conclude 
there is nothing more to do on that path, which can thus be pruned.  This
pruning significantly reduces the amount of work that the verifier must do.

</p>

<p>
State-based pruning is essential for verifier performance, but it imposes
its own cost in the form of comparing states and copying the safe ones.
Recent analysis of a set of networking-related BPF programs showed that
80% of the saved states will never be matched and, thus, will never prune a
future search.  As a result, there may be performance gains to be had by
reducing the number of states and pruning points maintained by the verifier.
<p>

The old optimizer worked by placing pruning points both before and after
each jump instruction, resulting in pruning points being added
approximately every four instructions.  It turns out that simply placing a
pruning point every ten instructions, regardless of the instruction type,
improves performance considerably.  The verifier was also modified to
aggressively drop saved states that do not actually prune paths.  These
changes improve verifier performance by up to 20% and increase the length
of a program that can be verified in a reasonable time by one-third.

<p>
<h4>Adding bounded loops</h4>

<p>Starovoitov's patch set introducing bounded loops builds on that earlier
work. It also includes a number of other improvements. This is partly the
result of a big performance regression introduced by the first patch in the
series that is a necessary building block for the final solution.</p>

<p>That regression takes the form of a performance degradation when adding
variable tracking on the stack. The compiler often puts variables on the
stack (or "spills" them) when it needs to free up some registers. The
verifier should be able to track such variables, since it may need to make
decisions based on their contents.  Until now it did not do so, resulting
in certain programs being incorrectly rejected.  It turns out that loop
induction variables are often spilled, so fixing the tracking of their
contents was necessary to be able to verify loop termination.

<p>

On the other hand, tracking specific variable values (as opposed to ranges
of possible values) creates more states, decreasing the effectiveness of
state pruning; tracking them on the stack makes the problem even worse.
The number of states increases, so the verification time also
increases. When debugging this issue, Starovoitov found another effect; the
performance penalty is aggravated by changes in the Clang compiler. It
turns out that newer Clang versions spill fewer variables onto the stack,
reducing state pruning even in the absence of complete value tracking.
The two problems together caused an important
degradation of verifier performance, with the exact results available in
the <a href="/ml/netdev/20190615191225.2409862-2-ast@kernel.org/">commit
message</a>.</p>

<p>Another feature needed by the bounded-loop support is extending the way
the verifier handles conditional branches. If a comparison takes place
between two constants, the verifier can easily determine which branch will be
taken.  Comparisons involving variable values are clearly harder, which is why,
until now, the verifier supported only comparisons of a register with
a constant.  In this patch set, Starovoitov <a
href="/ml/netdev/20190615191225.2409862-4-ast@kernel.org/">added
support</a> for tests comparing two registers as well.  This enhancement was
necessary to be able to simulate the execution of loop tests.
</p>

<p>The third and final piece consists of adding a parent-child
relationship between the states. When the verifier needs to explore two
branches in the program, it considers them both as child states of the parent
state. It also counts the number of branches to explore so that it knows
how many are left. With those features, and more aggressive heuristics in
the exploration state pruning, the verifier can support bounded
loops. It does it simply by simulating all possible iterations of their
execution.</p> 

<p>With bounded-loop support added, only one item remained: the regression
introduced at the beginning of the series.  The solution comes in the <a
href="/ml/netdev/20190615191225.2409862-10-ast@kernel.org/">last patch of
the series</a>. Based on the improvements added before (especially the
parentage tracking), Starovoitov added tracking of precise scalar
values. Those values are stored in registers and will be modified
during program execution.
The verifier needs to have precise values to analyze branches
correctly, but it need not track the value of <i>every</i> register
precisely; only those that control branching require that precision.
So the verifier does not incur the cost of tracking all registers precisely;
instead, when the need arises, it backtracks through the use of a register in
the code to generate a precise value if possible.
<p>

<h4>Summary</h4>

<p>The BPF verifier has undergone a number of changes in this patch set. The
resulting code not only adds support for bounded loops, but also a number of
important optimizations.  Writing BPF programs for the kernel should be
rather easier in the 5.3 release, though undoubtedly BPF developers will
still have ample opportunity to complain about the remaining hoops they
have to jump through to convince the verifier that their programs are
safe.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF-Loops">BPF/Loops</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Rybczynska_Marta">Rybczynska, Marta</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/794934/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor795033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2019 21:51 UTC (Wed)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/795033/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And now bpf is turing complete. How long will it be until it can read mail?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795034"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2019 22:16 UTC (Wed)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/795034/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It can never be Turing complete (at least not intentionally, given the verifier), see the Halting problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795034/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 15:29 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/795106/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just because a verifier for Turing-complete languages cannot reliably classify *all* arbitrary programs into either "safe" or "unsafe", that does not mean they don't exist or are useless. Verifiers can correctly classify large numbers of useful programs as safe. They can also correctly classify large numbers of unsafe programs as such. Any program that a verifier cannot classify, due to being insufficiently powerful, or due to the Halting problem, can simply be declared as "not verified safe" and rejected.<br>
<p>
Note that this means that some useful, safe programs could be rejected. That is unfortunate, but not an argument that verifiers are impossible, or even useless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 17:27 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/795110/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think there's some ambiguity on what the BPF language is (in the theoretical computer science sense of "language"). Is it all the programs that can be syntactically expressed with BPF bytecode? Or is it all the programs that can be expressed *and* that the verifier accepts? I think johill was using the latter, but the phrase "verifier for Turing-complete languages" seems to imply the former.<br>
<p>
The pre-verification language may be Turing-complete (if it had unbounded loops or equivalent). The post-verification language cannot be, assuming the verifier only accepts programs that it can prove will halt (and rejects ones where it can't decide), because there will always exist a computation that halts but that cannot be implemented in a program that the verifier will accept. The post-verification language may still be useful in practice (as you say), but it's not Turing-complete.<br>
<p>
In practice, Turing-completeness seems a pretty useless concept and a big distraction. Turing machines only care about the boundary between infinite and non-infinite, so a computation that requires more time than exists in the universe is just as good as one that completes almost immediately. A practical software engineer cares about a boundary measured in seconds or milliseconds, and a program that takes years is just as bad as one that never halts, so they need a totally different set of tools to analyse that problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 19:27 UTC (Thu)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/795117/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I was indeed thinking of "the programs that will be accepted by the kernel verifier" - because that's actually what the article discusses (changes/improvements in the verifier).<br>
<p>
The language itself is fairly obviously Turing complete (not that I've written down an emulator), but of course that is a theoretical concept anyway, as you say.<br>
<p>
And in any case, going back to the OP's comment, BPF is almost certainly already reading email somewhere, in the form of DPI :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795118"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 19:48 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/795118/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just because the verifier only outputs programs which are guaranteed to halt, does that mean that the language used to express them is necessarily Turing-incomplete?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795118/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795174"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 13:39 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/795174/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seems like a philisophical question to me. Is this C code? Or is it invalid because a reasonable C implementation could just say "no" rather than outputting any object code for it?<br>
<p>
int* p = NULL;<br>
int i = *p;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795174/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 16:40 UTC (Mon)
                               by <b>shane</b> (subscriber, #3335)
                              [<a href="/Articles/795360/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Hm... turning your code into a C program:
<pre>
#include &lt;stddef.h&gt;

int
main ()
{
    int* p = NULL;
    int i = *p;
    return i;
}
</pre>

We discover that clang doesn't warn or complain in any way:
<pre>
$ clang --version
clang version 8.0.0-3 (tags/RELEASE_800/final)
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
$ clang -Weverything foo.c
$ ./a.out
Segmentation fault (core dumped)
</pre>

Likewise by default GCC doesn't:
<pre>
$ gcc --version
gcc (Ubuntu 8.3.0-6ubuntu1) 8.3.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

$ gcc -Wextra -Wall -Wpedantic foo.c
$ ./a.out
Segmentation fault (core dumped)
</pre>

We can use a feature disabled by default:
<pre>
$ gcc -Werror=null-dereference -O foo.c 
foo.c: In function ‘main’:
foo.c:7:9: error: null pointer dereference [-Werror=null-dereference]
     int i = *p;
         ^
cc1: some warnings being treated as errors
</pre>

Enabling this warning apparently breaks the GCC self-bootstrapping build (as well as things like building the Linux kernel). The ticket which added the warning is here:
<p/>
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=16351">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=16351</a>
      
          <div class="CommentReplyButton">
            <form action="/Articles/795360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 17:09 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/795365/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess that's because it's only undefined behaviour if you actually execute main(), and the compiler doesn't know if you're going to execute main(), so it can't reject the code at compile time. And in practice this pattern probably occurs frequently in dead code, so programmers would get annoyed if it generated a warning.<br>
<p>
GCC still knows that function must never be executed, so it replaces it with the "ud2" instruction (at least with gcc -O2).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2019 9:27 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/795401/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>As an aside, <a href="https://godbolt.org/z/67EEMp">examining the code in Matt Godbolt's Compiler Explorer</a> shows that gcc 9.1 leaves an unnecessary MOV before UD2, while clang goes straight to RET. MSVC compiles to clear RAX, load EAX from *RAX, and return 0, while ICC generates code to set up SSE2 the way it wants it, loads AL from *NULL, and then calls an "abort" subroutine.
      
          <div class="CommentReplyButton">
            <form action="/Articles/795401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor795402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2019 11:39 UTC (Tue)
                               by <b>massimiliano</b> (subscriber, #3048)
                              [<a href="/Articles/795402/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>
The way I see it, the semantics of the BPF is that a program needs to be verified, and then executed. The verification step is an integral part of the execution, because if affects the final result of the high level <i>invocation</i> of a BPF program (the invocation might fail because the verification fails).
</p>

<p>
My take is that the <i>verifier</i>, being implemented in a Turing complete language (C), is subject to the halting problem and in principle could never terminate.
</p>

<p>
It is like if every BPF program had an initial implicit "verify" instruction opcode. A BPF program without verification step is Turing complete (thanks to its loops), and one with the verification step... maybe is not Turing complete by itself (it number of states is bounded so in the end it is a a finite state machine), but it is still subject to the halting problems <i>because</i> of the verifier!
</p>

<p>
Of course, as said in other comments, nothing of this matters in practice. But it is one way of understanding how BPF programs are not violating the "halting problem" principle: it's just that kernel developers are trusting the verifier to always terminate :-)
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2019 7:39 UTC (Wed)
                               by <b>laarmen</b> (subscriber, #63948)
                              [<a href="/Articles/795575/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What the halting problem basically says is that there are some programs for which one cannot tell if they will halt or not. Doesn't mean all programs, nor even most programs, just "some". I'm not aware of any proof that the verifier is one of those programs (nor of a proof that it halts, for that matter), and a quick Google search doesn't turn out any promising link.<br>
<p>
Anyone aware of such work ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2019 19:27 UTC (Thu)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/795774/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The verifier always halts, simply because it gives up after a while. It only processes a maximum of 1e6 instructions (BPF_COMPLEXITY_LIMIT_INSNS) before giving up:

<pre>
                if (++env-&gt;insn_processed &gt; BPF_COMPLEXITY_LIMIT_INSNS) {
                        verbose(env,
                                "BPF program is too large. Processed %d insn\n",
                                env-&gt;insn_processed);
                        return -E2BIG;
                }
</pre>



      
          <div class="CommentReplyButton">
            <form action="/Articles/795774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor795634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2019 15:48 UTC (Wed)
                               by <b>fuhchee</b> (guest, #40059)
                              [<a href="/Articles/795634/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, exactly - construing the language as the sequence of bpf bytecodes that are accepted as inputs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor795053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 10:59 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/795053/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm more worried that, coupled with the kernel's new time travel features and all these new "AI" accelerators, a BPF program could gain sentience, go back in time and try to kill Sarah Conner.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795085"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 13:56 UTC (Thu)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/795085/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm confused now.  So you *don't* want your BPF programs to terminate?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795085/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 14:06 UTC (Sat)
                               by <b>sdalley</b> (subscriber, #18550)
                              [<a href="/Articles/795277/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, that's not the issue. With the back-in-time feature, It can easily arrange to terminate before it begins, so everyone should be happy...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor795087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 14:22 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/795087/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bounded loops are still push-down automata, not Turing machines. You need unbounded loops to be Turing-complete.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor795037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should verification be done in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2019 0:12 UTC (Thu)
                               by <b>anadav</b> (subscriber, #99427)
                              [<a href="/Articles/795037/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The results are quite impressive and loop support is very useful. However, there might be a question of whether the approach of using ad-hoc optimizations for compiled byte code (following verification failures, or llvm version changes) is a viable path, or whether it is a whack-a-mole. In addition, such optimizations have introduced in the past several security bugs.<br>
<p>
Verifying byte code for safety guarantees is a known problem with practical and proven solutions. Since eBPF verification is not usually on the hot-path (or at least it should not be), it raises the question: why does eBPF verification have to be performed in the kernel? Wouldn’t it be better to perform it in userspace using standard tools instead?<br>
<p>
It may be beneficial just to introduce this option to users, by separating the binary rewriting and verification stages and provide hooks for userspace to register an external verifier. IMA and other security measures can then be used to ensure the verifier itself is not compromised. Having such a verifier can also assists in the adoption of eBPF in other environments (e.g., DPDK).<br>
<p>
As a reference [1], my colleagues have developed an eBPF verifier prototype that uses the well-known verification technique called abstract interpretation and shows promising results (good asymptotic scalability, very low rate of false positives).  It verifies loop safety out of the box and can be extended to also check that programs with loops terminate.<br>
<p>
[1] <a href="https://github.com/vbpf/ebpf-verifier">https://github.com/vbpf/ebpf-verifier</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should verification be done in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 17:16 UTC (Mon)
                               by <b>ecree</b> (guest, #95790)
                              [<a href="/Articles/795361/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The eBPF developers are aware of this work, and we looked into whether any of it could be of use.  The following analysis is my own, but I believe the other devs broadly agree with it.<br>
There are some problems which are non-trivial, at least, with trying to extend PREVAIL to cover the full feature set of the existing verifier, including:<br>
* the zone domain can only support relational difference constraints _or_ relational integer congruence constraints (Miné 2004 §5.4.6), not both at once (the paper just states this is 'straightforward' without further explanation) which is needed for alignment checking.<br>
* similarly, the paper doesn't actually explain how abstract interpretation can check loop termination; once you've got a fixed-point state set, how do you determine that the program doesn't go round in circles within that set?  Just stating that it's possible doesn't guide implementors much.<br>
* the verifier today has checks more complicated than simple 'safety of execution', for instance it can detect certain speculative-execution vulnerabilities (don't ask me how this works).  It's not clear that an abstract semantics can be written that deals with this.<br>
* sure your runtime complexity is good, but that memory usage!<br>
Our conclusion was that the best use we could make of PREVAIL was to incorporate some of its detail ideas, while rejecting the overall architecture.  In particular, I was intrigued by the concept (§7.3) of having userspace supply (essentially) a safety proof which the kernel merely validates; the equivalent of this in the existing verifier's architecture would be to specify explored_states at pruning points which are both sufficient to prove safety downstream and provable from the upstream code (which currently are discovered by the verifier and often overly precise, leading to path explosion); this would be particularly useful in the form of loop invariants as the kernel verifier would only need to prove (a) holds at loop entry, (b) maintained by loop and (c) sufficient to prove safety from loop exit.  I haven't had the time to dig into this myself (and expect to be far too busy in the near future).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor795367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF for the 5.3 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 17:21 UTC (Mon)
                               by <b>ecree</b> (guest, #95790)
                              [<a href="/Articles/795367/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>So the verifier does not incur the cost of tracking all registers precisely; instead, when the need arises, it backtracks through the use of a register in the code to generate a precise value if possible.</blockquote>
Alexei can correct me, but I don't think this is quite accurate.
AIUI, the verifier always calculates precise value bounds, but normally that precision is ignored for pruning.  Only if the path from a pruning point to an exit uses the precise value does the precise value need to be checked for pruning safety.  So the backtracking is marking parent states as "needs precision", not actually generating new values.
      
          <div class="CommentReplyButton">
            <form action="/Articles/795367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
