        <!DOCTYPE html>
        <html lang="en">
        <head><title>The perils of pinning [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/907876/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/908081/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/907876/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The perils of pinning</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 15, 2022</br>
           <hr>
<a href="https://lwn.net/Archives/ConferenceByYear/#2022-Kangrejos">Kangrejos</a>
</div>
Parts of the Rust language may look familiar to C programmers, but the two
languages differ in fundamental ways.  One difference that turns out to be
problematic for kernel programming is the stability of data in memory — or
the lack thereof.  A challenging session at the <a
href="https://kangrejos.com">2022 Kangrejos</a> conference wrestled with
ways to deal with objects that should not be moved behind the programmer's
back.
<p>
C programmers take full responsibility for the allocation of memory and the
placement of data structures in that memory.  Rust, instead, takes most of
that work — and the associated control — out of the programmer's hands.
There are a number of interesting behaviors that result from this control,
one of which being that the Rust compiler will happily move objects in
memory whenever that seems like the thing to do.  Since the compiler knows
where the references to an object are, it can move that object safely —
most of the time.
<p>
Things can go badly, though, when dealing with self-referential data
structures.  Consider the humble (C) <tt>list_head</tt> structure that is
heavily used in the kernel:
<p>
<pre>
    struct list_head {
	struct list_head *next, *prev;
    };
</pre>
<p>
It is possible to create a Rust wrapper around a type like this, but there
are complications.  As an example, initializing a <tt>list_head</tt>
structure to indicate an empty list is done by setting both the
<tt>next</tt> and <tt>prev</tt> fields to point to the structure itself.
If, after that happens, the compiler decides to move the structure, those
pointers will now point to the wrong place; the resulting disorder does not
demonstrate the sort of memory safety that Rust hopes to provide.  The
same thing can happen with non-empty lists, of course, and with a number of
other kernel data structures.
<p>
Benno Lossin started his Kangrejos talk by saying that Rust provides a
mechanism to deal with this problem, which <a
href="https://blog.cloudflare.com/pin-and-unpin-in-rust/">can also
arise</a>  in pure Rust code.  That mechanism is the <a
href="https://doc.rust-lang.org/std/pin/index.html"><tt>Pin</tt></a>
wrapper 
type; placing an object of some other type into a <tt>Pin</tt> will nail
down its 
location in memory so that it can no longer be moved.  There are numerous
complications, including the need to use <tt>unsafe</tt> code to access
fields within a pinned structure and to implement "pin projection" to make
those fields available generally.
<p>

<a href="/Articles/907891/"><img
src="https://static.lwn.net/images/conf/2022/kang/BennoLossin-sm.png" alt="[Benno Lossin]"
title="Benno Lossin" class="lthumb"></a>
The really big challenge, though, is in a surprising area: initialization.
Fully understanding the issues involved requires a level of Rust guru status far
beyond anything your editor could hope to attain, but it seems to come down
to a 
couple of aspects of how Rust treats objects.  Rust goes out of its way to
ensure that, if an object exists, it has been properly initialized.  Object
initialization in Rust tends to happen on the stack, but objects that need
to live indefinitely will need to move to the heap before being pinned.
That movement will break a self-referential object, but pinning before
initialization will break Rust's memory-safety rules.
<p>
Solutions exist, but require a lot of <tt>unsafe</tt> code; Lossin has been
working on alternatives.  He initially tried to use const generics to track
initialization, but the solution required the use of <a
href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural
macros</a> and was complex overall.  And, at the end, it was "unsound", a
Rust-community term indicating that it was not able to properly handle all
cases.  So that approach was abandoned.
<p>
Instead, he has come up with a solution that uses (or abuses) struct
initialization and macros.  Your editor will not attempt a full description
of how it works; the whole thing can be seen in <a
href="https://kangrejos.com/Safe%20Pinned%20Initialization%20in%20Rust.pdf">Lossin's
slides</a>.  Among other things, it requires using some complex macros that
implement a not-Rust-like syntax, making the code look foreign even to
those who are accustomed to Rust.
<p>
The response in the room was that, while this work is clearly a clever
hack, it looks like a workaround for a limitation of the
Rust language.  It's the kind of thing that can create resistance within
the kernel community, many members of which already find Rust hard to read
(though it should be said that kernel developers are entirely willing to
merge C preprocessor hackery when it gets the job done).  There was a
strong desire to see a different solution.
<p>
Xuan "Gary" Guo stepped up to show an alternative approach.  In&nbsp;C, he
began, it is easy to 
create an object without initializing it, or to initialize an object twice.
In Rust, anything that circumvents the normal initialization routine requires
<tt>unsafe</tt> code.  Tracking the initialization of such objects can
require maintaining an initial variable to hold the current state, which
would be a good thing to avoid.  Other approaches can require additional
memory allocations, which are also not good for the kernel.
<p>
<a href="/Articles/907893/"><img
src="https://static.lwn.net/images/conf/2022/kang/XuanGuo-sm.png" alt="[Xuan Guo]"
title="Xuan Guo" class="rthumb"></a>

There have been attempts to address the problem with, for example, the <a
href="https://docs.rs/pin-init/latest/pin_init/"><tt>pin_init</tt>
crate</a>.  But 
pin_init still is unable to initialize self-referential structures, and has
to do its own parsing of Rust structures and expressions.  That requires
the <a href="https://docs.rs/syn/latest/syn/"><tt>syn</tt> crate</a>, which is not
really suitable for kernel building.
<p>
A proper solution for the kernel, he said, would have a number of
characteristics.  It should be safe, impose no extra cost, and require no
additional memory allocations.  Aggregation should work; a structure
containing multiple pinned objects should initialize properly.  The
mechanism used should not look much different from normal Rust.  There
should also be no assumptions about whether initialization can fail or not.
<p>
Guo's solution (which can be seen in <a
href="https://kangrejos.com/pin-init%20-%20safe%20initialisation%20of%20pinned%20structs.pdf">his
slides</a>), looks a bit closer to normal Rust than Lossin's, but it still
depends on complex macro trickery and has not managed to avoid using the
<tt>syn</tt> crate.  And it still can't handle self-referential structures
properly.  But it is arguably a step in the right direction.
<p>
Once again, though, the proposed solution looked like an impressive hack,
but the 
response was not entirely favorable.  Kent Overstreet described it as
"really gross", adding that this job should be done by the compiler.
Wedson Almeida Filho responded that the compiler developers would just
suggest using procedural macros instead.  One compiler developer, Josh
Triplett, happened to be in the room; he said that there could be help
provided by the language, but that
requires an RFC describing the desired behavior, and nobody has written it
yet.  The session wound down without any specific conclusions other than,
perhaps, a desire to pursue a better solution within the Rust language
rather than trying to work around it.
<p>
[Thanks to LWN subscribers for supporting my travel to this event.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Kangrejos-2022">Kangrejos/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/907876/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor908149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 14:38 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/908149/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;That requires the syn crate, which is not really suitable for kernel building. </font><br>
<p>
Why?<br>
<p>
<font class="QuotedText">&gt;that the compiler developers would just suggest using procedural macros instead.</font><br>
<p>
What&#x27;s wrong with that? Why not use proc macros?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 2:35 UTC (Fri)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908230/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; That requires the syn crate, which is not really suitable for kernel building.</font><br>
<p>
<font class="QuotedText">&gt;Why?</font><br>
<p>
There are a few reasons a crate might not be suitable for kernel building. The most important that I can think of would be if the crate requires the standard library. Rust for Linux, as far as I am aware, requires a freestanding (no-std) environment. Looking at the pin-init crate, it requires &#x27;syn&#x27; as a runtime dependency (not just a compile-time (&quot;dev&quot;) dependency)[0].<br>
<p>
[0]: <a href="https://github.com/nbdd0121/pin-init/blob/trunk/pin-init-internal/Cargo.toml">https://github.com/nbdd0121/pin-init/blob/trunk/pin-init-...</a><br>
<p>
<font class="QuotedText">&gt; What&#x27;s wrong with that? Why not use proc macros?</font><br>
<p>
As the article notes:<br>
<p>
<font class="QuotedText">&gt;&gt; it requires using some complex macros that implement a not-Rust-like syntax, making the code look foreign even to those who are accustomed to Rust. </font><br>
<p>
and later<br>
<p>
<font class="QuotedText">&gt;&gt; it still depends on complex macro trickery and has not managed to avoid using the syn crate. And it still can&#x27;t handle self-referential structures properly.</font><br>
<p>
So, complexity for one thing. Creating additional sublanguages isn&#x27;t really ideal. Would you need to write code that uses these procedural macros in every structure that includes a list head? In every self-referential structure? In every structure that includes a self-referential structure? In every structure that includes those structures? Etc?<br>
<p>
Procedural macros are also known for slowing down compilation times if used too much. If there is a procedural macro invocation in the definition of every structure that can be part of a linked list, that might significantly slow down compilation times compared to a solution that did not require procedural macros. Rust compile times are already pretty slow, even without procedural macros, compared to C, so making them even worse would not be ideal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 6:54 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/908243/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;The most important that I can think of would be if the crate requires the standard library. Rust for Linux, as far as I am aware, requires a freestanding (no-std) environment. </font><br>
<p>
But not for building.<br>
The part of the article and my question was about building.<br>
<p>
<font class="QuotedText">&gt;Would you need to write code that uses these procedural macros in every structure that includes a list head? In every self-referential structure? In every structure that includes a self-referential structure? In every structure that includes those structures? Etc?</font><br>
<p>
I don&#x27;t see why this would be a blocker. Especially for a thing that could eventually be migrated over to a solution provided by the rust compiler or core.<br>
<p>
And the whole &quot;sublanguage&quot; thing is the whole point of macros. Also in C. Look at what the kernel does with C macros. That&#x27;s a completely separate language.<br>
<p>
Have you looked at the slides for the proposed proc macros? The only non-idiomatic thing is that a dot (.) appears in an unusual place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 12:27 UTC (Fri)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908298/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;But not for building.</font><br>
<p>
<font class="QuotedText">&gt;The part of the article and my question was about building.</font><br>
<p>
pin-init does not require the syn crate just for building. As I said, and as demonstrated in my link, it requires it as a dependency (run-time dependency), not as a dev dependency (Rust lingo for a build-time dependency).<br>
<p>
<font class="QuotedText">&gt;I don&#x27;t see why this would be a blocker. Especially for a thing that could eventually be migrated over to a solution provided by the rust compiler or core.</font><br>
<p>
As noted in the article: &quot;Once again, though, the proposed solution looked like an impressive hack, but the response was not entirely favorable. Kent Overstreet described it as &quot;really gross&quot;, adding that this job should be done by the compiler. Wedson Almeida Filho responded that the compiler developers would just suggest using procedural macros instead. One compiler developer, Josh Triplett, happened to be in the room; he said that there could be help provided by the language, but that requires an RFC describing the desired behavior, and nobody has written it yet.&quot;<br>
<p>
So there is absolutely no guarantee that it would just be a thing that would &quot;eventually&quot; be migrated over - as with most stopgap measures in the world of software, it would probably end up being permanent.<br>
<p>
<font class="QuotedText">&gt; And the whole &quot;sublanguage&quot; thing is the whole point of macros. </font><br>
<p>
The supposed point of using Rust for the Linux kernel as opposed to one of the other millions of memory-safe languages out there (recall that almost all programming languages are memory-safe) is that it is well-suited to interfacing with C and writing low-level code using the &quot;unsafe&quot; escape hatch while allowing those uses to be wrapped in type-safe memory-safe wrappers. If, to accomplish the most basic low-level task (of working with these sorts of structures), it requires the use of procedural macros, it strongly suggests that the language isn&#x27;t actually ready. After all, if the point of Rust is that Rust is well-suited to this, then by definition *Rust* is well-suited to it, not Rust-with-various-extensions. It&#x27;s one thing to write macros to reduce boilerplate, but this is writing macros to cover over a gaping hole in the most basic functionality of the language, at least if the language claims to be designed for efficient interoperability with C code.<br>
<p>
This isn&#x27;t meant to be a criticism of Rust in general. I&#x27;m just explaining why people would balk at the idea of needing to use procedural macros for something so basic - needing to extend the language to deal with this means people will expect that it will need to be extended for lots more things in the future, yknow? Then you aren&#x27;t really using Rust, you&#x27;re using Rust++, so why use Rust in the first place?<br>
<p>
<font class="QuotedText">&gt; Also in C. Look at what the kernel does with C macros. That&#x27;s a completely separate language.</font><br>
<p>
What the kernel does with C macros is certainly not a &quot;completely separate language&quot; - in fact, what the kernel does with macros is done in such a way as to make their use mostly invisible. The vast majority of the time you do not need to know, when you write foo(x), whether foo is a macro or a function. That is why the Linux kernel uses lower case macro names: they&#x27;re designed to blend in, not to stick out like a sore thumb as ALL_UPPER_CASE macros do. <br>
<p>
C macros are also not procedural. They involve simple text substitution. Rust has macro_rules or whatever for that kind of relatively simple macro. This is different: it is significantly more complicated and produces significantly slower compilation times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 14:27 UTC (Fri)
                               by <b>Bigos</b> (subscriber, #96807)
                              [<a href="/Articles/908327/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
pin-init (or more specifically - pin-init-internal crate you have linked) is a proc_macro crate. A runtime dependency of a proc_macro crate is effectively a build-time dependency of the proc_macro users.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 3:22 UTC (Sat)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908421/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, of course. It makes sense when you say it. Mightily confusing though...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor908152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 14:57 UTC (Thu)
                               by <b>0x3333</b> (subscriber, #158599)
                              [<a href="/Articles/908152/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Am I the only one who thinks that Rust is great but unsuitable for Kernel development? Man, I feel that a lot of workarounds have to be made to allow this. What a pity!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 15:05 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/908153/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Am I the only one who thinks that Rust is great but unsuitable for Kernel development</font><br>
<p>
I don&#x27;t know, if you&#x27;re the only one. But Kernels and lots of bare metal code have already been developed in Rust.<br>
<p>
Rust in Linux is merely fighting with the existing C interfaces and C concepts. These have never been developed with Rust in mind and they cannot be changed just to support Rust.<br>
<p>
I also don&#x27;t think that these problems make it unsuitable. It just means that we have to live with a couple more unsafe statements for now.<br>
In C every statement is unsafe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 15:12 UTC (Thu)
                               by <b>0x3333</b> (subscriber, #158599)
                              [<a href="/Articles/908155/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;I don&#x27;t know, if you&#x27;re the only one. But Kernels and lots of bare metal code have already been developed in Rust.</font><br>
<p>
Well, I was referring to Linux Kernel, I used rust for embedded microcontrollers, but for Linux Kernel it looks(from outside) that is too much to fight.<br>
<p>
Anyways, it&#x27;s good to see safety landing on the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 15:13 UTC (Fri)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/908335/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kernel code is not standards-compliant C code.  If you look at a random file in the kernel, it isn&#x27;t recognizable as C code.  The number of macros, specialized functions (no malloc), compiler extensions, inline assembly (usually via a macro, but it&#x27;s there), goto&#x27;s, and memory barriers even in a bog-standard driver is substantial.  If you look at more performance-focused subsystems, you start seeing self-modifying code, overlaying structs on top of each other, and intentionally created and carefully controlled data races.<br>
<p>
Expecting Rust to interface with all that without any nasty hacks is a little unfair.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 3:37 UTC (Sat)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908423/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That you can do all of that is kind of the whole point of C. Those things are necessary, and (to play the devil&#x27;s advocate) the reason that people say that C is better suited to kernel development than other languages is precisely that you can do all those things.<br>
<p>
It&#x27;s not really &quot;unfair&quot; to expect Rust to interface with all that, because Rust people advertise their language as being good at interfacing with C. That surely means something more than &quot;can make ABI calls to C&quot;? Almost every language out there can call functions using the platform C ABI. I would expect &quot;good at interfacing with C&quot; to mean that the language has good support for the same sorts of things people do in C. C is all about communication and openness.[0] If you can&#x27;t do that kind of development, it&#x27;s not really a &quot;C-friendly&quot; language, standards-compliance or no.<br>
<p>
[0]: <a href="https://www.humprog.org/~stephen/research/papers/kell17some-preprint.pdf">https://www.humprog.org/~stephen/research/papers/kell17so...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2022 17:56 UTC (Sun)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/908526/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point is that you _cannot_ do most of the stuff Linux does in C.<br>
<p>
The Linux kernel depends on a great many weird and ill-specified GCC compiler extensions -- some of them explicitly designed for the kernel&#x27;s needs, as well as other long standing special compiler modes that allow you to get away with violating fundamental rules of the language (e.g. that forbid treating the same location in memory as multiple types.) And even with all that, you cannot even build the kernel with optimizations disabled -- it&#x27;s dependent on the whims of the optimizer, too!<br>
<p>
(But, of course, you can certainly have a self-referential struct in C without doing anything strange. So, there is that.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908534"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2022 18:37 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908534/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The point is that you _cannot_ do most of the stuff Linux does in C.</font><br>
<p>
The point is NO formal language will let you do most of the stuff Linux does. (Of course assembler will let you, because assembler has no formal model.)<br>
<p>
Linux is an operating system. It is MEANT to talk to other devices, with other controllers, that do their own thing. NO formal language can cope with other systems doing things behind its back.<br>
<p>
So basically, the less &quot;unsafe&quot; code there is the better, because safe code means the compiler has proven that the code will work as intended (barring programmer &quot;sillies&quot;). But at the end of the day, there will still need to be a lot of &quot;unsafe&quot; code, because ...<br>
<p>
If your code is reading from the receive buffer of a network card, you really do not want a language that assumes memory only changes when you write to it! What was that about GCC assuming reading from uninitialised memory is UB and can be optimised away? Bang goes your networking!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908534/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 9:02 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/908569/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We can&#x27;t ever say the code will work as intended because it&#x27;s easy for a human programmer to write code that&#x27;s simply not what they intended. I wrote a loop the other day which would read the next URL, add what was found there to a list, each time checking if the next URL is empty. Except, I forgot to write the part where it updates that next URL based on what was read, so it&#x27;s actually an infinite loop. My (pair) partner sat with me, wondering what was taking so long for I&#x27;d guess two minutes before we realised what I did wrong.<br>
<p>
Rust actually reflects what your machine code can do for that network card receive buffer. You can say look, just perform actual fetches for all the &quot;memory&quot;.<br>
<p>
 let recvd = std::ptr::read_volatile&lt;NetworkBuffer&gt;(recv_buffer); /* Rust will bit-wise copy the values in the buffer. */<br>
<p>
This function is unsafe, because it fetches some arbitrary memory so clearly you can blow up the world (e.g. unaligned read on an architecture where those are forbidden, or just point it out of bounds), but it&#x27;s very well defined if recv_buffer actually points at a NetworkBuffer size blob of suitably aligned and addressable &quot;memory&quot; we can load values from, it will emit actual loads for those values and not try to cache them or assume it knows their value or whatever.<br>
<p>
That&#x27;s a contrast from C which has us actually pretend recv_buffer is just pointing at an actual NetworkBuffer with a &quot;volatile&quot; qualifier and so then we can go around doing operations to it, even though in practice that&#x27;s a bad idea and the only thing we ought to do is copy it somewhere. On a good day that&#x27;s all the C (or worse C++) does with a volatile, on a bad day you need to guess whether the programmer knew what&#x27;s really going or whether the code you&#x27;re reading is full of unintentional races.<br>
<p>
There was an effort to get C++ to move towards intrinsics for fetch/ store like Rust rather than C&#x27;s volatile qualifier hack. But this got some very angry push back, and I anticipate there will not be any further attempts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 18:16 UTC (Mon)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/908668/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; let recvd = std::ptr::read_volatile&lt;NetworkBuffer&gt;(recv_buffer); /* Rust will bit-wise copy the values in the buffer. */</font><br>
<p>
<font class="QuotedText">&gt; That&#x27;s a contrast from C which has us actually pretend recv_buffer is just pointing</font><br>
<font class="QuotedText">&gt; at an actual NetworkBuffer with a &quot;volatile&quot; qualifier and so then we can go around</font><br>
<font class="QuotedText">&gt; doing operations to it, even though in practice that&#x27;s a bad idea and the only thing</font><br>
<font class="QuotedText">&gt; we ought to do is copy it somewhere. On a good day that&#x27;s all the C (or worse C++)</font><br>
<font class="QuotedText">&gt; does with a volatile, on a bad day you need to guess whether the programmer knew</font><br>
<font class="QuotedText">&gt; what&#x27;s really going or whether the code you&#x27;re reading is full of unintentional races.</font><br>
<p>
I don&#x27;t think to understood your sentence. But my understood is that you can wrote a<br>
function in C<br>
<p>
read_volatile(recv_buffer)<br>
<p>
that copy the data to a &quot;volatile&quot; buffer. IIRC When a pointer is passed to a function<br>
the compiler stops any assumption to the pointed data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2022 8:40 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/908738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I'm going to stick to C syntax throughout, since I think that's easier for kernel programmers to follow than Rust.
<p>In C, you might have code like:
<tt>
<pre>
struct NetworkBuffer {
    struct IpHeader ip_hdr;
    union {
        struct TcpSegment tcp;
        struct UdpSegment udp;
    };
};

volatile * NetworkBuffer buf;
</pre>
</tt>
<p>It's then tempting (but often wrong) to write code that does things like <tt>buf-&gt;ip_hdr.src_addr</tt>, when this isn't actually a good idea because of the <tt>volatile</tt> reads that will be done.
<p>Rust doesn't have a <tt>volatile</tt> qualifier on storage that changes all codegen accessing that storage. Instead it has the equivalent of <tt>void * memcpy_volatile(void * dest, volatile void * src, size_t count);</tt> (but using generics from Rust's type system to replace <tt>void *</tt> and <tt>size_t count</tt>). Because your only dependable operation on the buffer is to copy out of the shared space that can change underneath you at no notice (imagine that, for example, NetworkBuffer actually lives in memory the far side of the PCIe bus, on the NIC itself), that's what you'll do.




      
          <div class="CommentReplyButton">
            <form action="/Articles/908738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 18:11 UTC (Mon)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/908666/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The point is NO formal language will let you do most of the stuff Linux does.</font><br>
<font class="QuotedText">&gt; (Of course assembler will let you, because assembler has no formal model.)</font><br>
<p>
I think that  C++ does...  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 11:24 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/908853/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C++ like C relies on an abstract machine model. The abstract machine doesn&#x27;t have the attributes of the real machines Linux is written for.<br>
<p>
Sometimes the abstract machine&#x27;s differences from a real machine just have performance consequences, for example most doubly linked list operations look really clever in the abstract machine and have reasonable performance, but this has lousy performance on an actual computer you can buy today because of caches.<br>
<p>
But often there are simply practical differences, the abstract model lacks entirely something the real machine has. A higher level C++ application needn&#x27;t care but the Linux kernel does. For some thing Linux relies on inline assembler, the same thing works in Rust, and the same trick kernels written in C++ use. In other places Linux is relying on semantics which are not offered by the formal language and which likewise are not offered in ISO C++ but do happen to work in the chosen compiler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor908150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 15:01 UTC (Thu)
                               by <b>GhePeU</b> (subscriber, #56133)
                              [<a href="/Articles/908150/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Asahi Lina, who&#x27;s writing a Rust kernel driver for the Apple M1/M2 GPU, had some problems when initializing structures that seem related:<br>
<p>
<a href="https://twitter.com/LinaAsahi/status/1567752082060619776">https://twitter.com/LinaAsahi/status/1567752082060619776</a><br>
<p>
<a href="https://twitter.com/LinaAsahi/status/1570119306461204481">https://twitter.com/LinaAsahi/status/1570119306461204481</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 16:15 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/908166/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;ve seen a similar issue when trying to initialise a large statically-allocated object, on a microcontroller with no heap and a small stack. Idiomatic Rust will construct a temporary value then move it into the static object (or heap etc), and usually the compiler will optimise away the copy so it constructs in-place; but beyond a certain size threshold (e.g. a few hundred array elements) it won&#x27;t do that optimisation, it will construct the temporary on the stack then memcpy it into the destination. That&#x27;s unacceptable with large objects and small stacks, and I&#x27;m not sure of a good way to solve it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 3:14 UTC (Fri)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/908235/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
TBH this really sounds like a compiler bug specifically, and the overall problem needs to be fixed in the language itself. There&#x27;s doesn&#x27;t really seem to be a good reason you can&#x27;t do what people want to do, just that the language itself doesn&#x27;t support pinning and init at the same time. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 14:10 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908631/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And if it&#x27;s actually doing a copy, then it&#x27;s also a speed-damaging language misfeature.<br>
<p>
It might not be much, but papercuts add up.<br>
<p>
Dunno how they&#x27;ll fix it but it needs fixing ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 1:25 UTC (Wed)
                               by <b>D1plo1d</b> (guest, #161018)
                              [<a href="/Articles/908828/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s currently some discussion of how to fix this in the Rust language itself both in an older Placement-by-Return RFC and this blog post update from 2 days ago:<br>
<p>
https://y86-dev.github.io/blog/return-value-optimization/placement-by-return.html<br>
<p>
For what it&#x27;s worth as a Rust user, these Rust for Linux issues seem to be becoming a very helpful forcing function to improve Rust itself.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor908157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 15:16 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/908157/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And, at the end, it was &quot;unsound&quot;, a Rust-community term indicating that it was not able to properly handle all cases. So that approach was abandoned. </font><br>
<p>
My understanding is that &quot;unsound&quot; comes from type theory and is basically the equivalent of &quot;if this is true, we can prove 1=2&quot;. Rust might extend that to also involve &quot;you can break invariants without using `unsafe` with this API&quot;, but, AFAIK, the term itself is not a &quot;Rust community&quot; term.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 21:03 UTC (Thu)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/908198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
More specifically, it&#x27;s &quot;you can trigger undefined behavior without using &#x27;unsafe&#x27; with this API&quot;. The undefined behavior can then be leveraged to later prove that 1 = 2.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 22:09 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908204/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; AFAIK, the term itself is not a "Rust community" term.</font>

<p>You are 100% correct. It's not “Rust community” term. It's <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Rust reference</a> term:</p>

<blockquote>It is the programmer's responsibility when writing <code>unsafe</code> code to ensure that any safe code interacting with the <code>unsafe</code> code cannot trigger these behaviors. <code>unsafe</code> code that satisfies this property for any safe client is called <i>sound</i>; if <code>unsafe</code> code can be misused by safe code to exhibit undefined behavior, it is <i>unsound</i>.</blockquote>


      
          <div class="CommentReplyButton">
            <form action="/Articles/908204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 16:00 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/908355/">Link</a>] 
      </p>
      
      </div>
      </summary>
      If it doesn't handle all cases, then I would call it <i>incomplete</i>.  To be <i>unsound</i> would mean it can produce incorrect results.


      
          <div class="CommentReplyButton">
            <form action="/Articles/908355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 15:22 UTC (Thu)
                               by <b>Bigos</b> (subscriber, #96807)
                              [<a href="/Articles/908156/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That mechanism is the Pin wrapper type; placing an object of some other type into a Pin will nail down its location in memory so that it can no longer be moved.</font><br>
<p>
You do not place an object in Pin. Instead, you place a &quot;pointer type&quot; (a shared/exclusive reference, Box, etc.) inside it.<br>
<p>
From what I recall, the contract is that if you create a Pin&lt;P&gt; (where P is a pointer, like &amp;mut T) you promise you will never move the pointed-to object (unless it implements Unpin, which is a trait automatically implemented unless opted-out; self-referential types must not implement it, though).<br>
<p>
If object initialization (like setting self-referent pointer to itself for list_head) requires the object to be Pinned, that indeed is problematic. The common case is to initialize the object without any pinning and when it is placed where it should only Pin it there. This is how Futures work (the first Future::poll() call pins the future, so it can be moved and combined before that happens).<br>
<p>
Could MaybeUninit help represent the uninitialized, not-pinned object state? It indeed requires the use of unsafe, but safe wrappers could Pin the object, initialize it and return a Pin&lt;&amp;mut T&gt;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 16:42 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/908165/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You do not place an object in Pin. Instead, you place a &quot;pointer type&quot; (a shared/exclusive reference, Box, etc.) inside it.</font><br>
<p>
Indeed this is why I think describing pinning in terms of the Rust compiler implicitly moving things around is confusing and unhelpful: C moves things around implicitly just as much as Rust.<br>
<p>
If you take a struct in C and pass it somewhere by value, that struct is now in a new location. If you do that with a self referential struct, it is now invalid in the new location. This applies identically to both languages. However, safe Rust would not let you do that, because self reference requires borrowing, and borrowed values can not be moved/passed by value.<br>
<p>
So where is the problem then? Well, Rust also allows users to *explicitly* do things like use std::mem::swap to swap the contents of two mutable references. This means that if you can get an exclusive reference to something, you can move it. That is why pointer types to location aware things are a problem and need to be wrapped in another type that prevents access, like Pin.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 19:33 UTC (Thu)
                               by <b>fw</b> (subscriber, #26023)
                              [<a href="/Articles/908188/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>If you take a struct in C and pass it somewhere by value, that struct is now in a new location. If you do that with a self referential struct, it is now invalid in the new location.</blockquote>

C only has copies, not moves, so the result is completely valid. It's just that the new object is not self-referential anymore: its pointers refer to the old object instead. But these pointers remain valid while the old object is still around. That's completely different with Rust move semantics.


      
          <div class="CommentReplyButton">
            <form action="/Articles/908188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 20:23 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/908194/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;That&#x27;s completely different with Rust move semantics. </font><br>
<p>
No. Not really.<br>
<p>
The only difference is that in Rust the &quot;the old object is still around&quot; is zero time.<br>
Everything else is the same.<br>
Rust can&#x27;t rip out memory from your machine. Therefore it also technically copies.<br>
<p>
The difference between a copy and a move is that the lifetime of the old object is terminated immediately and not at some later point. And based on that the compiler might be able to apply some optimizations to omit the copy altogether.<br>
<p>
And if you copy a self referential object, it&#x27;s by definition not self referential after copy. It references another object (the original one!). Not self.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 1:59 UTC (Fri)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/908226/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unless the copy operation can somehow update the self-references to reference the copy, so that a potentially circular structure can be cloned. But that could be expensive.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 18:10 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/908372/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust deliberately doesn&#x27;t have constructors, including copy constructors. If the compiler moves your Cheese, it will do so using (something morally equivalent to) memcpy(). It won&#x27;t, and you can&#x27;t, tweak anything, the exact bits are moved, if those bits refer to their location in memory that is probably bad since now they don&#x27;t.<br>
<p>
Rust&#x27;s Clone trait, which is what happens if you clone() something that admits it can be cloned, is a function you can implement. For example my Multiplicity <a href="https://docs.rs/misfortunate/1.0.0/misfortunate/struct.Multiplicity.html">https://docs.rs/misfortunate/1.0.0/misfortunate/struct.Mu...</a> wrapper type claims to be Clone, despite the fact all it asks of your wrapped type T is that it should be Default. Multiplicity&#x27;s clone() implementation just makes a Default::default() of your type, which is type correct but presumably not what you wanted. (The name is a reference to the 1996 Andie MacDowell comedy in which Michael Keaton clones himself repeatedly and gradually the clones deteriorate in quality)<br>
<p>
But you deliberately can&#x27;t intervene in the simple memcpy() behaviour when the compiler decides to move your object in memory. The Rust compiler reserves the rights to do this more often than you expect, or less often, and in different places, as it sees fit. Pinning stops it from doing that, at some potential cost in performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2022 6:44 UTC (Thu)
                               by <b>Homer512</b> (subscriber, #85295)
                              [<a href="/Articles/908966/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Pinning stops it from doing that, at some potential cost in performance.</font><br>
<p>
If the compiler already has facilities to detect when an object should not be moved, why is it so hard to give it facilities to invoke a custom function for the move instead?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2022 9:27 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/909521/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's hard because the consequence of adding a "move fix-up" function is to break the mental model people have of Rust code.
<p>In today's world, the maximum cost of a move in Rust (or a copy for things that <tt>impl Copy</tt>) is a memory copy of the object. The cost of a move is thus predictable.
<p>If Rust adds a "move fix-up" function of some form, that predictability goes away - you now depend on the implementation of the move function being high-quality. C++ goes this route, of having hidden fix-up functions (operator=, move and copy constructors), and thus provides an illustration of the benefits of that approach (where all developers are skilled) and of the costs (where some developers are unskilled and don't realise that they're invoking a lot of code doing a move).
<p>Actually implementing the changed semantics in the compiler would be trivial - it's the human cost of learning how the new semantics work that's non-trivial.


      
          <div class="CommentReplyButton">
            <form action="/Articles/909521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor908478"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 14:01 UTC (Sat)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/908478/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think the semantics of &quot;move&quot; are that it is a physical move. I&#x27;ve always thought that it&#x27;s simply a &quot;logical&quot; move to a new owner. I don&#x27;t really give a damn if it&#x27;s physically moved or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908478/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908523"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2022 14:57 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/908523/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
First of all, it is a logical move. But in many cases it also has to be a physical move:<br>
- the object is moved from the stack to the heap<br>
- the object is moved between different allocations on the heap<br>
- the object is moved to a function parameter (if the function is not inlined, then the object has to be moved to the place where the function expect its input, for inlined funtions, the move will usually be avoided)<br>
<p>
And for correctness of self referential objects, you have to assume that the object might be physically moved if it is logically moved. Also, for unpinned and unaliased objects, the compiler is free to move it around for code optimization, even without a logical move.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908523/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2022 17:40 UTC (Sun)
                               by <b>fw</b> (subscriber, #26023)
                              [<a href="/Articles/908529/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>Rust can't rip out memory from your machine. Therefore it also technically copies.</blockquote>

Aren't Rust semantics such that the moved-from object becomes invalid as part of the move? What happens in a concrete computer implementation does not really matter for correctness if the abstract machine behaves differently. If the object is gone in the abstract machine, compilers can and will eventually optimize based on the assumption that accesses to it will not happen during the execution of the program.


      
          <div class="CommentReplyButton">
            <form action="/Articles/908529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 23:06 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/908207/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are right about it being valid as far as the C spec is concerned, in the same sense that -1 is a valid file descriptor. However you&#x27;ve still violated the assumptions the rest of the code makes about that type, which is likely to be much less happy about that fact :)<br>
<p>
Of course, this is a completely moot point in C because it&#x27;s always possible to get any memory into an arbitrary state anyway. But Rust doesn&#x27;t have the luxury of being able to tell people just not to do things. Hence unlike C, it does not allow you to access the old object after a copy (unless it&#x27;s marked with the special Copy trait). Which is after all the only difference between a copy and a move, it&#x27;s not like the old memory disappears.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 2:15 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/908225/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But Rust doesn&#x27;t have the luxury of being able to tell people just not to do things.</font><br>
<p>
Rather, Rust has the luxury of telling people they *can&#x27;t* do things. Which is critical to and in some cases necessary for Rust being able to provide its safety guarantees. Complex, memory-aware data structures (e.g. cyclical, self-referential, etc) have *always* been a sore point for Rust. Most Rust developers come from the world of scripting languages or similar environments (e.g. Java) where hash tables are the primary, even sometimes exclusive primitive (beyond arrays) for building higher-order data structures, so they don&#x27;t feel any loss. For this group, more complex data structures always come by way of magic libraries with generic interfaces that you glue together; building thin, bespoke data structures for your specific functional problems as a matter of course is a foreign concept.<br>
<p>
Many solutions Linux has adopted for higher performance, lower latency, multi-core scalability, etc simply wouldn&#x27;t have even been considered at all when writing everything in scratch from Rust. It&#x27;s probably the case that equally (or at least sufficiently) performant Rust-consonant alternatives exist for most individual cases. The real question is whether at scale, when you&#x27;re stitching all these solutions together into what is essentially a single, complex data structure, you can end up in the same place in terms of performance; or if the solutions Rust demands intrinsically impose greater costs when composed together.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor908159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 15:38 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/908159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  And, at the end, it was &quot;unsound&quot;, a Rust-community term indicating that it was not able to properly handle all cases. So that approach was abandoned. </font><br>
<p>
To clarify, unsoundness means that an abstraction allows you to subvert the safety guarantees of Rust, violating some contract between the programmer and the compiler. For example, by allowing you to obtain an invalid pointer under some usually contrived circumstance.<br>
<p>
This is different from being unsafe, where an interface has requirements that can not be automatically proven, and a bug or vulnerability, where the interface is still sound but the code is not implemented correctly. Hence the jargon.<br>
<p>
<font class="QuotedText">&gt;  The session wound down without any specific conclusions other than, perhaps, a desire to pursue a better solution within the Rust language rather than trying to work around it. </font><br>
<p>
I&#x27;m personally excited about what the kernel can bring here. The reason Rust doesn&#x27;t really have a nice solution to pinning is that in almost every case, self referential types can be replaced with indexes at no loss (or even a gain) to clarity or performance. In the few exceptions that existed, adding another allocation or some unsafe code was not a big deal.<br>
<p>
I expect that will still be the case most of the time within the kernel, but integrating with a codebase that makes very heavy use of self reference has great potential to increase the motivation to fix some of the papercuts and warts in this area.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 21:45 UTC (Thu)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/908201/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Disclaimer: I never wrote a single line of rust and my knowledge of the language is &quot;I&#x27;ve read few blog posts&quot; level. My knowledge of kernel source code is... superficial at best.<br>
<p>
With that said, I have two questions about this:<br>
<p>
<font class="QuotedText">&gt; As an example, initializing a list_head structure to indicate an empty list is done by setting both the next and prev fields to point to the structure itself.</font><br>
<p>
1) Why thought? Isn&#x27;t the idiomatic C way setting the next and prev to 0? Assuming that is not possible in rust (to prevent null dereference I assume), why not use rust-version of std::optional?<br>
<p>
2) How does this work together with C code? Are the next and prev converted between &amp;self and 0 every time they are passed over the boundary? Or does kernel use &amp;self as well instead of 0?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 22:36 UTC (Thu)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/908209/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends on whether your list is supposed to be circular or not, one would suppose, and whether you have explicit sentinel objects or use NULL to mark end.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 22:43 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908213/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's double-linked list in Linus's <a href="https://github.com/mkirchner/linked-list-good-taste">good taste</a>.</p>

<p>The idea is that there are never any <code>NULL</code> pointers and thus never need to deal with them.</p>

<p>And, of course, when you convert that data structure to Rust you want to keep that property… and you couldn't! Rust doesn't have any constructors and structures are created in one place (on stack) and then are moved into proper position.</p>

<p>This was never a problem for new Rust code, but it's very often quite awkward.</p>

<p>And indeed, language-level solution would be great. But before it can be implemented it first needs to be <b>imagined</b> and it's not that easy here.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/908213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 22:36 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908208/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; 1) Why thought? Isn't the idiomatic C way setting the next and prev to 0? Assuming that is not possible in rust (to prevent null dereference I assume), why not use rust-version of std::optional?</font>

<p>Both are possible. You couldn't use references in these self-referential data structures because mutable references are, but definition, unique. And pointers are <code>unsafe</code> but nullable. Using &lt;Option&gt; would be bad idea, though.</p>

<font class="QuotedText">&gt; 2) How does this work together with C code? Are the next and prev converted between &amp;self and 0 every time they are passed over the boundary? Or does kernel use &amp;self as well instead of 0?</font>

<p>C is not fussy about uninitialized memory. You just create an empty structure and then fill with pointers.</p>

<p>Of course <b>that</b> is possible to do in <code>unsafe</code> Rust, too.</p>

<p>The problem here is not <i>how to do that</i>, but <i>how to do that in a safe way</i>.</p>

<p>Because if you driver have pile of <code>unsafe</code> which you have to carefully review and where compiler doesn't guarantee anything, then what's the point? C already gives you means to do that!</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/908208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 23:24 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/908215/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You couldn&#x27;t use references in these self-referential data structures because mutable references are, but definition, unique.</font><br>
<p>
I think that&#x27;s not right in general. &quot;&amp;mut T&quot; references are unique, but &#x27;mut&#x27; does not mean mutable. Many objects are mutable through a &quot;&amp;T&quot; reference. The difference is that the compiler can&#x27;t statically prove that you&#x27;re only mutating it through a single &quot;&amp;T&quot; at once, so T has to either guarantee that mutations are atomic (std::sync::atomic, Cell) or implement dynamic checks to prevent concurrent mutation (RefCell, Mutex).<br>
<p>
If you can design your self-referential data structure with interior mutability like that, then you can mutate it through non-unique references. There may be practical difficulties with using interior mutability in those specific cases, because it often needs extra memory for the dynamic state and dynamic error handling when you violate the rules, but that&#x27;s a different problem.<br>
<p>
(&quot;&amp;mut T&quot; should really be called an exclusive reference (while &quot;&amp;T&quot; is a shared reference), because &quot;mutable reference&quot; is actively misleading. I think the &quot;mut&quot; keyword is a design flaw in the language, albeit a fairly minor one that could be worked around with better documentation, and it&#x27;s possible all the other proposed solutions were equally flawed. See also <a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html">https://docs.rs/dtolnay/latest/dtolnay/macro._02__referen...</a> which makes the same points.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 2:49 UTC (Fri)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908233/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &quot;&amp;mut T&quot; references are unique, but &#x27;mut&#x27; does not mean mutable. Many objects are mutable through a &quot;&amp;T&quot; reference.</font><br>
<p>
Is that a bit backwards? &quot;mut&quot; doesn&#x27;t mean mutable because some things are mutable without it? Wouldn&#x27;t it be more accurate to say that &quot;&amp;T&quot; doesn&#x27;t mean &quot;immutable&quot;? &quot;&amp;mut T&quot; still does mean mut, and &quot;mut T&quot; definitely does mean it&#x27;s a mutable T.<br>
<p>
<font class="QuotedText">&gt;If you can design your self-referential data structure with interior mutability like that, then you can mutate it through non-unique references.</font><br>
<p>
This sounds very similar to the &quot;const means thread-safe&quot; idea that AFAIK was first introduced into the C++ community by Herb Sutter: essentially (if I am remembering correctly), the point was that if you have a T const&amp; t (equivalent to Rust &amp;T) then it should always be thread-safe to access t, because a strict reading of the language specification essentially requires const member functions on objects to access mutable members (equivalent to Rust interior mutability, I guess?) only in a thread-safe manner. <br>
<p>
<a href="https://isocpp.org/blog/2012/12/you-dont-know-const-and-mutable-herb-sutter">https://isocpp.org/blog/2012/12/you-dont-know-const-and-m...</a> (best link I can find)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 4:08 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/908239/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This sounds very similar to the &quot;const means thread-safe&quot; idea</font><br>
<p>
It&#x27;s quite a bit different. In C++ const functions do not change the &quot;logical&quot; state and can be called through a const pointer/reference. But there&#x27;s nothing preventing you from sharing a mutable reference across threads and changing the object while a `const` function is running.<br>
<p>
Rust goes further. The language guarantees that at any given time there is only one reference through which you can change an object and no other references.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 22:18 UTC (Fri)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/908403/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote> ("&amp;mut T" should really be called an exclusive reference (while "&amp;T" is a shared reference), because "mutable reference" is actively misleading. I think the "mut" keyword is a design flaw in the language, albeit a fairly minor one that could be worked around with better documentation, and it's possible all the other proposed solutions were equally flawed. See also <a rel="nofollow" href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html">https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html</a> which makes the same points.)</blockquote>

There was actually discussion around that (&amp;mut being better as something like &amp;uniq), but it didn't go anywhere.

People who want more information should search "mutpocalypse". (It's been many years but, if my mental timeline is correct, coined as a callback to the "leakpocalypse", when it was discovered that the first attempt at a scoped thread API was unsound in the face of things like memory leaks from Rc/Arc reference cycles.)



      
          <div class="CommentReplyButton">
            <form action="/Articles/908403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 1:32 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/908221/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(You might already know this  but) Rust&#x27;s correct way to potentially unsafely initialize stuff these days is to use core::mem::MaybeUninit&lt;T&gt;<br>
<p>
MaybeUninit is a union (and thus can&#x27;t be accessed by safe code directly) of uninitialized nothingness, with your type T. The compiler can see this may be uninitialized, and therefore no stunts which assume it&#x27;s a T are allowed, and yet it might be a T and so we can (unsafely) write to elements of T.<br>
<p>
While we&#x27;re initializing it, the MaybeUninit&lt;T&gt; type is clearly not a T as far as other code is concerned, there&#x27;s no risk anybody mistakenly thinks this is a T and tries to use it as one. Once we&#x27;re done we can unsafely assume_init() to get a T, and if we&#x27;re right this is fine, if we lied everything might catch fire but that&#x27;s a programming error. If T is some structure that only some people want to perform gradual initialization on, MaybeUninit also has a write() method where we can safely just give it a T, and say look, I don&#x27;t want to manually initialize this, here&#x27;s a perfectly nice T, overwrite the uninitialized memory with that.<br>
<p>
So you could imagine some NetworkThing struct, and Linux has an API which gives you a MaybeUninit&lt;NetworkThing&gt; and maybe the 100Gbps network card which costs more than my laptop really does carefully initialize NetworkThings via the MaybeUninit in order to shave a few CPU cycles off the fast path for a packet send, but chances are my 10Mbps USB 2 dongle can just write() a NetworkThing and it makes no measurable difference to how slow a 10Mbps network connection is.<br>
<p>
The 100Gbps driver does need to write unsafe code to initialize a NetworkThing in its fast path, but the USB ethernet driver does not, in exchange for which it&#x27;s a little slower than it might have been. That feels like a reasonable trade.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 2:27 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908232/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;The 100Gbps driver does need to write unsafe code to initialize a NetworkThing in its fast path, but the USB ethernet driver does not, in exchange for which it's a little slower than it might have been. That feels like a reasonable trade.</font>

<p>Maybe for Rust designers, but I doubt Linux driver writers would agree. Remember: we are talking about guys who often raise a fuss when compiler adds couple of spurious commands.</p>

<p>On the other hand these are the same guys who already know how to make C compiler generate code they want and Rust in not much different. They would try to solve that issue and probably would invent something.</p>

<p>Most likely some <code>unsafe</code> behind pile of macroses.</p>

<p>After all that's how Rust solved these issues for <code>async</code> why not here, too?</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/908232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 7:52 UTC (Fri)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/908246/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>I'm at a similar level of knowledge with rust, and I'm getting stuck on:</p>

<blockquote><p>the Rust compiler will happily move objects in memory whenever that seems like the thing to do. Since the compiler knows where the references to an object are, it can move that object safely — most of the time.</p>

<p>[...]</p>

<p>initializing a list_head structure to indicate an empty list is done by setting both the <tt>next</tt> and <tt>prev</tt> fields to point to the structure itself. If, after that happens, the compiler decides to move the structure, those pointers will now point to the wrong place;</p></blockquote>

<p>If the compiler knows where the references to an object are, and can presumably update them, why doesn't it update <tt>prev</tt> and <tt>next</tt> when it does the move?</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/908246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 8:27 UTC (Fri)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/908251/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      I am guessing it knows where the references to an object are <i>other than self-references.</i><p>
That is, if A refers to B, and you move B, you can update A since you know A refers to it. But if B refers to B and you move B, it doesn't update. 
<p>Why not (ie, why doesn't it recognize that B refers to B and update it) is an interesting question. Maybe it's somewhere deep in the language design: reference-counting doesn't include self-references? And maybe it's hard to fix? 
<p>Actually I have a more basic confusion: how does the <i>compiler</i> move objects in memory? Isn't that a run-time thing? 


      
          <div class="CommentReplyButton">
            <form action="/Articles/908251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 10:33 UTC (Fri)
                               by <b>Bigos</b> (subscriber, #96807)
                              [<a href="/Articles/908259/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compiler is able to generate code that moves an object from one place to another, but allows that only when the object is owned*.<br>
<p>
When the object is owned, the compiler knows there exist no reference to it. It can then just update the internal state to know the location of the moved object without updating anything really. This is basically what happens when Foo::new() returns Foo object and you then Box::new() it to put it on the heap.<br>
<p>
Self-referent types are foreign to the Rust borrow rules. You cannot have a reference to itself (the lifetime cannot be defined), so these are usually raw pointers in disguise. And Rust will happily memcpy raw pointers without any consideration as it is the user&#x27;s responsibility to correctly maintain raw pointers (which is why they are unsafe to dereference).<br>
<p>
So it is not about &quot;A refers to B vs B refers to B&quot; but &quot;A has a reference to B vs B has a raw pointer to B&quot;.<br>
<p>
And you cannot even move B if it is referred by A. If a type is referenced, it means it is borrowed and is no longer owned**.<br>
<p>
Unlike C++, Rust has been designed not to be able to alter how object move is implemented. You thus cannot alter the memcpy behavior. This is why Pin&lt;&gt; is important as it effectively disallows object moves - which is necessary for self-referent types.<br>
<p>
The thing about &quot;compiler moving objects&quot; is obviously a simplification. The object must be moved, i.e. placed in a specific memory location, and the compiler can use various strategies to make that happen. It can perform memcpy at runtime. Or it can make it so that the original object is created in the move destination already (often called &quot;move elision&quot;).<br>
<p>
* There is std::mem::swap() (and its friends) that can move things that are not owned but just referenced by an exclusive reference &amp;mut T. However, we cannot really use these with self-referent types anyway.<br>
<p>
** Again, exclusive references could make that happen. But if B has an exclusive reference to A, it is the only object that knows A&#x27;s address, so only B has to be updated when A is moved. Exclusive references are not how you usually model a linked list as then you cannot even iterate over a list without consuming it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 10:55 UTC (Fri)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/908262/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the detailed explanation. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 14:34 UTC (Fri)
                               by <b>kkdwivedi</b> (subscriber, #130744)
                              [<a href="/Articles/908331/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So if I&#x27;m understanding this correctly, I think what it really needs is something similar to C++&#x27;s placement new? So that it can begin the lifetime of a pinned self referent object by reusing another object&#x27;s storage (or MaybeUninit storage), without having to move objects around?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 15:03 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/908344/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that would work except that there&#x27;s no &quot;constructor&quot; mechanism in Rust. You can have methods that act like constructors by not taking `self` in any way and returning a `Self` (it might be `Option&lt;&gt;` or `Result&lt;&gt;` wrapped), but there&#x27;s no trait tracking such APIs to be able to write a placement new.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 22:34 UTC (Fri)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/908404/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I'm not sure about the details in C++, so I don't know how they differ, but there's been interest and discussion around designing something placement new-like for Rust for a long time.</p>

<p>(The earliest RFC I could find in a quick search was <a rel="nofollow" href="https://github.com/rust-lang/rfcs/pull/1228">#1228</a> from two months after Rust 1.0 in 2015, and it's clearly a continuation of plans for placement new already in progress.</p>

<p>My impression is that it just keeps getting bumped down the priority queue in favour of higher-demand/ROI things like support for C-style untagged <code>union</code>s in the FFI side of things (yes, they weren't present in stable-channel Rust until version 1.19), async/await, GATs, and so on.</p>

<p>(<a rel="nofollow" href="https://caniuse.rs/">caniuse.rs</a> is a good way to quickly get an overview of what got stabilized when and <a rel="nofollow" href="https://doc.rust-lang.org/nightly/unstable-book/the-unstable-book.html">The Unstable Book</a> is a good overview of the compiler features that are currently implemented for some definition of "implemented" but haven't been committed to stable channel and the language stability promise.)</p>







      
          <div class="CommentReplyButton">
            <form action="/Articles/908404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor908216"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 0:34 UTC (Fri)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/908216/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The moving problem in conjunction with the list_head example begs for a C++-style move ctor (either =deleted or user-defined to implement the logic to keep the self-reference even after move). C++ by name may not be loved <a href="http://harmful.cat-v.org/software/c++/linus">http://harmful.cat-v.org/software/c++/linus</a> , but what counts is the idea.<br>
On the other hand, if a language can&#x27;t directly deal with self references (list_head won&#x27;t be last struct of such kind), then maybe it&#x27;s not the right language to start with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908216/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linked list start and end</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 7:49 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/908248/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>As an example, initializing a list_head structure to indicate an empty list is done by setting both the next and prev fields to point to the structure itself.</blockquote>
Why is this done?  Wouldn't it make more sense to set these two fields to null?


      
          <div class="CommentReplyButton">
            <form action="/Articles/908248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linked list start and end</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 9:33 UTC (Fri)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/908255/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The list_head structure implements a circularly linked list, meaning it can be iterated fully starting from any node in the list. That means that if you want to loop over the whole list, you loop until you are back at the node you started. Logically this means a list of size 1 will contain a list_head where both prev and next point to the node itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908263"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linked list start and end</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 11:01 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/908263/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Logically this means a list of size 1 will contain a list_head where both prev and next point to the node itself.</font><br>
<p>
But per the article, that&#x27;s how an *empty* list is indicated. What is the actual encoding for a linked list of length 1?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908263/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linked list start and end</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 11:12 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908264/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An empty list clearly contains ONE null entry.<br>
<p>
So, and I&#x27;m GUESSING, a list with one value contains one entry with the value, and one null entry.<br>
<p>
iiuc, this is how it knows where the head of the list is - it&#x27;s the null entry.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linked list start and end</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 23:14 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/908408/">Link</a>] 
      </p>
      
      </div>
      </summary>
      NULL isn't used as a sentinel for this type of list, the head itself is the sentinel. See, e.g., https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h?h=v6.0-rc5#n290

<pre>
static inline int list_empty(const struct list_head *head)
{
	return READ_ONCE(head-&gt;next) == head;
}
</pre>

and https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h?h=v6.0-rc5#n368

<pre>
static inline int list_is_singular(const struct list_head *head)
{
	return !list_empty(head) &amp;&amp; (head-&gt;next == head-&gt;prev);
}
</pre>



      
          <div class="CommentReplyButton">
            <form action="/Articles/908408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linked list start and end</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 2:46 UTC (Sat)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/908418/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Consider a list with entries being added atomically.  If you start walking from a pointer X and return to the pointer X, you are done walking the entries that existed when you started as well as some of those added before you were finished.<br>
<p>
Removals / deletions remain the pain point.  Hence the RCU mechanisms.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor908247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 8:05 UTC (Fri)
                               by <b>kkdwivedi</b> (subscriber, #130744)
                              [<a href="/Articles/908247/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I can&#x27;t really comment on how it should be implemented in Rust (I have little to no experience with the language), some of us are working on enabling such &#x27;struct list_head&#x27; usage in BPF, and it&#x27;s the same problem there of a self referential type.<br>
<p>
One observation is that it is rare you&#x27;ll be &#x27;moving&#x27; around such a self referential struct, atleast for the list_head case. I can&#x27;t find a lot of examples in the kernel where it can simply assume memcpy is equal to move for such cases. It really cannot. You have to have a &#x27;move constructor&#x27; thing similar to C++ that does the non-trivial stuff for such special fields.<br>
<p>
Even then, it&#x27;s unlikely you&#x27;re going to copy such structures around. Yes, that argument doesn&#x27;t work from a language design standpoint, but at least for the BPF runtime it&#x27;s going to hold. We&#x27;re kind of designing the language and the standard &#x27;BPF library&#x27; together in concert, to give a better analogy. So it&#x27;s also possible to reap the benefits of such an approach.<br>
<p>
Secondly, the core problem here is about initializing on stack and then moving into the Boxed object. Instead of that, as long as the pointer has not really escaped the program, it is technically possible to model the heap precisely, and track the state of fields. It would be the same as tracking the state of memory on the stack as long as it doesn&#x27;t escape the program.<br>
 <br>
This is also possible to do when you receive ownership of an object from an &#x27;external&#x27; source, but then the default state you can assume for the fields is unknown. This can be further refined by ensuring they are only manipulated using some specific functions, and then you can reason more precisely about the state of the fields (either pointing to itself or to some other list_head).<br>
<p>
This initialization on stack and move might be the way Rust does things, and it may be non-trivial to accommodate such idea of direct initialization on heap into the language rules, but that is pretty much how we&#x27;re planning to make it work properly for BPF.<br>
<p>
It will be possible to also have such &#x27;bpf_list_head&#x27; on stack, but then you&#x27;d call an initialization helper that does the right thing, and we already precisely track the state of stack in BPF, so we know its constructed and you cannot reinitialize it.<br>
<p>
Ofcourse, one can argue that Rust&#x27;s approach is much more systematic, applies evenly to more complicated cases, and doesn&#x27;t really hard code semantics of a particular implementation, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 20:30 UTC (Fri)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/908393/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Instead of that, as long as the pointer has not really escaped the program, it is technically possible to model the heap precisely, and track the state of fields. It would be the same as tracking the state of memory on the stack as long as it doesn&#x27;t escape the program.</font><br>
<p>
Rust used to do this! It was called &quot;box syntax&quot;. It&#x27;s been removed on the crusade to make the compiler stop giving Box special permissions that mean you can&#x27;t actually implement MyBox without being the standard library.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908715"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2022 1:34 UTC (Tue)
                               by <b>cplaplante</b> (subscriber, #107196)
                              [<a href="/Articles/908715/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
box_syntax is still available as an unstable feature.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908715/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 21:42 UTC (Fri)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/908394/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; but that requires an RFC describing the desired behavior, and nobody has written it yet.</font><br>
<p>
A prerequisite to supporting structs that require in-place initialization for soundness is supporting in-place initialization in the first place (aka &quot;placement new&quot;).  Rust has had a number of RFCs and other discussions about this, of varying levels of quality, over many years:<br>
<p>
<a href="https://github.com/rust-lang/rfcs/pull/809">https://github.com/rust-lang/rfcs/pull/809</a><br>
<p>
<a href="https://web.archive.org/web/20201109030838/https://github.com/rust-lang/rfcs/pull/2534">https://web.archive.org/web/20201109030838/https://github...</a><br>
<p>
<a href="https://internals.rust-lang.org/t/pre-rfc-move-references/14511">https://internals.rust-lang.org/t/pre-rfc-move-references...</a><br>
<p>
<a href="https://github.com/rust-lang/rfcs/pull/2884">https://github.com/rust-lang/rfcs/pull/2884</a><br>
<p>
<a href="https://github.com/rust-lang/rust/issues/27779#issuecomment-378416911">https://github.com/rust-lang/rust/issues/27779#issuecomme...</a><br>
<p>
But I haven&#x27;t seen a design that&#x27;s truly satisfying.<br>
<p>
One problem is that the most obvious design would be to take the idea of &quot;out pointers&quot; from C and add them to Rust in a compiler-enforced way, but this is impossible.  Why not?  Because Rust code is allowed to unwind on panic, in which case you&#x27;d return to an outer stack frame without actually initializing the pointer.  Rust does support a no-unwinding mode, which is used by Rust for Linux and many other users, but it&#x27;s not the standard mode, and Rust would be unwilling to add major language features that only work in this mode.<br>
<p>
A bigger problem is that the existing ecosystem of Rust code is already used to initializing things out of place.<br>
<p>
In C, if you&#x27;re writing a function that initializes some struct, you&#x27;ll probably have it take a pointer to that struct as an argument, and initialize it in place.  In C++, class constructors always initialize the class in place.  But in Rust, the current idiom is to have functions like `fn new() -&gt; MyStruct`, which construct a local copy of the struct and then return it by value (implicitly memcpying it to the destination).  If some new language construct is added for in-place initialization, it will probably become the preferred way to initialize everything, rendering all existing code unidiomatic and causing a ton of churn.<br>
<p>
The most recent RFC I linked (from 2020) tries to sidestep that problem using the idea of guaranteed move elision of function return values, similar to what C++ added in C++17.  A function like `fn new() -&gt; MyStruct` is *already* transformed by the compiler into something like `fn new(out_ptr: *mut MyStruct)`.  It takes a pointer and initializes it.  So even without changing the source code at all, the compiler could theoretically generate code that initializes the struct in place.  But instead it will usually create one or more temporary copies on the stack (on the caller and/or callee side) and memcpy between them.  The idea here is to fix the compiler to stop making those copies, and then guarantee as a language feature that no copies will be made, under some reasonable conditions.  That way you could get in-place construction everywhere, without having to change the idiom!<br>
<p>
But this approach has serious limitations.  Most importantly, a lot of functions are not `fn new() -&gt; MyStruct` but rather `fn new() -&gt; Result&lt;MyStruct, MyError&gt;`.  In those cases, you might want the compiler to transform it to something like `fn new(out_ptr: *mut MyStruct) -&gt; Option&lt;MyError&gt;` – that is, construct the MyStruct in place while returning the error separately – but currently you get `fn new(out_ptr: *mut Result&lt;MyStruct, MyError&gt;)` – that is, construct the whole Result object contiguously in memory.  It&#x27;s not clear to me if it&#x27;s possible to transform it to the former without breaking language semantics in edge cases.<br>
<p>
Another limitation is that it would still produce some API churn.  Right now, you might write `Box::new(MyStruct::new())` (to put the struct in a new heap allocation) or `vec.push(MyStruct::new())` (to append the struct to a vector, which might require allocation).  Ideally this kind of code would also magically get transformed by the compiler to initialize the struct in place.  But as written, the code calls MyStruct::new() *before* allocating (and then moves the struct to the newly allocated destination), whereas in-place initialization would require allocating first.  That&#x27;s not a semantics-preserving transformation.  So the 2020 RFC adds new functions that take closures: `Box::new_with(|| MyStruct::new())`, `vec.push_with(|| MyStruct::new())`.  The function implementation would first allocate and then call the closure, avoiding the ordering problem.  And since the struct is the closure&#x27;s return value, return value move elision would kick in, rather than needing to create a separate &#x27;function argument move elision&#x27; feature.  Neat trick, but then there would be two different ways to create a Box or append to a Vec (creating churn), and the &quot;best&quot; way would be the uglier of the two.   C++ has a similar problem, having added `emplace_back` to std::vector after previously having `push_back`.<br>
<p>
And finally, if in-place initialization is treated as an optimization (even a guaranteed one), it might be confusing.  It would be hard to tell just by reading some code whether the optimization is kicking in or not.  And if this was extended to support self-referential structs, you&#x27;d end up with code that seems trivially unsound (making a self-referential struct and then moving it), which is only sound due to the &#x27;optimization&#x27;.<br>
<p>
So we&#x27;re kind of stuck.  Apologies for the off-topic rant, but this is one of my most-desired features in Rust, and I&#x27;m afraid the language is going to end up never supporting it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 22:23 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908402/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  But in Rust, the current idiom is to have functions like `fn new() -&gt; MyStruct`, which construct a local copy of the struct and then return it by value (implicitly memcpying it to the destination).</font><br>
<p>
So what&#x27;s wrong/impossible about a &quot;return by reference&quot; version of new? Or does the borrow checker get itself in  a tangle trying to work out who owns what? If return by reference can&#x27;t support a chunk of &quot;new&quot; functionality, then that&#x27;ll discourage people from using it unless they need to.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 22:45 UTC (Fri)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/908405/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>It's fundamental to the Rust semantic model that references don't transfer ownership of what they point to.</p>

<p>Compiler transformations aside, returning a newly constructed object by reference would be like some of the UB cases that trip people up in C or C++ as far as programmer comprehension is concerned, and they're trying <em>very</em> hard not to become C++.</p>

<p>(Discussion in RFCs spends time explicitly focusing on a given new feature's effect on the language's learnability and words like "complexity budget" get thrown around.)</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/908405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 23:36 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908409/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can a pointer be owned by an object? If it&#x27;s self-referential, can&#x27;t it own itself and be returned by reference? Of course, I guess that throws up other problems instead ...<br>
<p>
(All this stuff feels odd to me, because as a FORTRAN and DataBASIC programmer, neither language has pointers, and even as a C programmer I never really used them. I always treated pointers like arrays.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 8:51 UTC (Sat)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/908465/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>A pointer can be owned by an object, but you still have to either own what it's pointing to or use Rust's lifetime system to prove that it won't outlive what it points to.</p>

<p>The former is how <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, etc. are implemented. They use <code>unsafe</code> and Raw/C-style pointers internally, but the part that lives on the stack is still singly-owned... things like Rc and Arc just use internal reference counts and raw heap pointers to implement multiple ownership in a "Compiler, you can't verify this, but I've audited it and it works" way and, instead of the compiler inserting memory-freeing code, their implementation of the <code>Drop</code> trait (effectively, a destructor) decrements the reference counts and/or frees the memory allocated when they were initialized as appropriate.</p>

<p>The latter is how Rust's reference types (<code>&amp;</code> and <code>&amp;mut</code>) work. Any object which contains a reference must expose that reference's lifetime as part of its type signature, and then the compiler solves the resulting system of constraints to prove that dangling pointers are not possible.</p>

Rust references and pointers can't own themselves because they're non-owning by definition. It's like asking for a secure system where every user can perform every operation without the hassle of having to authenticate. It's a self-contradictory definition.

<p>Owning bindings, by contrast, are mutually exclusive by definition. It's a potentially a bit misleading since the defining property of "owner" is "responsible for cleanup", so having two owning bindings to the same thing will result in a double-free.</p>

<p>If it helps, think of Rust as a compiler that enforces compile-time-provable reader-writer locking. (That's what <code>&amp;</code> vs. <code>&amp;mut</code> is, but the analogy can be useful for thinking about owner vs. borrows.) You're essentially asking why you can't force the reader-writer lock to hand out two exclusive/writer handles simultaneously.</p>

<p>There <em>is</em> a way to make a reference that <em>sort of</em> owns itself... but it's using constructs like <code>Box::leak</code>, which are intended for detaching something from the ownership system without freeing them. They're mainly intended for two situations:</p>

<ol>
<li>Stripping the ownership from an object to hand off to C, with the understanding that deallocation will happen by taking the pointer back, calling something like <code>Box::from_raw</code> to reattach it to the ownership system, and then letting it drop to free it with the same allocator that allocated it.</li>
<li>Letting something in a userland program live until the process terminates and the OS cleans it up as an easy way to handle stuff that's going to need to live until the end anyway.</li>
</ol>






      
          <div class="CommentReplyButton">
            <form action="/Articles/908465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908429"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 5:46 UTC (Sat)
                               by <b>notriddle</b> (subscriber, #130608)
                              [<a href="/Articles/908429/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fundamental problem with returning via an out pointer is figuring out what happens if the function never writes to it.<br>
<p>
Naively, it would seem like the solution is to force the function to write to it using the same control flow analysis as used for locals. Unfortunately, because of unwinding, even something as simple as adding two numbers can result in exiting a function without writing to the out pointer, basically making it unusable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908429/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor911025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 11:36 UTC (Thu)
                               by <b>martinling</b> (guest, #71591)
                              [<a href="/Articles/911025/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for this excellent summary, which sent me right down this rabbit hole over the last couple of weeks.<br>
<p>
I have sketched out another possible approach here, and would be interested in your thoughts on it:<br>
<p>
<a href="https://github.com/martinling/rust-inplace-sketch/">https://github.com/martinling/rust-inplace-sketch/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908419"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How much of this is that a new language displays undefined behavior in a preceeding language?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 2:54 UTC (Sat)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/908419/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C has mountains of undefined behavior.  Is Rust defining some of that for more recent architectural views?  Do we now have to consider the semantics we so long have assumed?<br>
<p>
Yeah, I have a formal background.  And I have not learned much of Rust beyond things that could be taken disparagingly.<br>
<p>
And then the next language, and the next...  Rust, TO ME, seems a curly-braced attempt to be a more popular ML derivative.  But I&#x27;m just me.  There is no true language here.  Just the ones we use to express intentions to the machines and each other.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908419/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How much of this is that a new language displays undefined behavior in a preceeding language?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 3:33 UTC (Sat)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908422/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;And then the next language, and the next... Rust, TO ME, seems a curly-braced attempt to be a more popular ML derivative.</font><br>
<p>
Rust is enthusiastically and proudly &quot;ML with Algol syntax&quot; at its core.<br>
<p>
<font class="QuotedText">&gt;C has mountains of undefined behavior. Is Rust defining some of that for more recent architectural views? </font><br>
<p>
LLVM was designed to compile C++. It leaves a lot &quot;undefined&quot; because that behaviour is undefined in C++ anyway. There is no reason it couldn&#x27;t all be defined as &quot;whatever the hardware does&quot; (which is very different from UB), but it just isn&#x27;t. <br>
<p>
Rust compiles to LLVM. That means that &quot;unsafe&quot; code in Rust can exhibit undefined behaviour, because it is implemented in terms of LLVM. There is, however, no reason why that would have to be so. Rust could give well-defined behaviour to every syntactically-valid program if it had its own backend. For portability, some things might behave differently on different platforms - it would still be well-defined, just defined as &quot;depends on the platform, not portable behaviour&quot; rather than &quot;no idea, caveat emptor, if you do the wrong thing the compiler will optimise assuming that doing the wrong thing is IMPOSSIBLE, nasal demons, etc.&quot;.<br>
<p>
Overall, Rust has much less undefined behaviour than C, and I think the goal is that all syntactically-valid programs that do not use &quot;unsafe&quot; will have entirely well-defined behaviour, even though it compiles to LLVM (i.e. the language/type system/borrow checker prevents you from doing things that would compile to LLVM IR that would exhibit UB). For example, signed overflow (and unsigned overflow, if I remember correctly) traps in Rust. If you want wrapping or saturating arithmetic you need to use special types. Those types also have well-defined (but different) behaviour.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How much of this is that a new language displays undefined behavior in a preceeding language?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 11:21 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/908469/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Rust compiles to LLVM. That means that &quot;unsafe&quot; code in Rust can exhibit undefined behaviour, because it is implemented in terms of LLVM. There is, however, no reason why that would have to be so. Rust could give well-defined behaviour to every syntactically-valid program if it had its own backend.</font><br>
<p>
This is exactly what the programming language that is called &quot;safe rust&quot; promises to provide. Every syntactically correct program in safe rust cannot produce undefined behaviour (modulo bugs in the compiler). However this is not what people want, at least not always. Unsafe rust is there to allow programs that do not have undefined behaviour, but still cannot represented in safe rust. E.g. using uninitialized memory. You cannot predict what you get when you just do a read on the memory. Of course you can enforce that all memory is initialized before first use. This is what safe rust does. But sometimes people want the extra performance that you can get by avoiding the initialization step. But then they have to prove that the code is sound, because they explicitly opted out of the compiler heuristics that automatically avoid initialization whenever the compiler can prove that it is safe to do, because the memory is written to before first use. And in the compiler there can only be heuristics, because the problem of computing whether there is some read before the first write is clearly undecidable. So there will always be cases where a human can prove that the program is sound, but the compiler cannot (because the used heuristics is not good enough).<br>
<p>
Another category of clearly undefined behaviour are data races. In many cases not even the hardware defined clearly what can happen. Not only that the concrete behaviour depends on precise timings of events that you have no control over. But also what are the possible outcomes? Which reorderings are possible inside the CPU if you do not enforce memory barriers? Is it possible that you can read some clearly invalid data that results from a partial store? The hardware manufacturers will not provide any specs, because they want to have the freedom to change the inner behaviour of the CPU. Of course, you can enforce that there are always memory barriers in place. This is what safe rust does. Sometimes people want to have more performance by doing crazy optimizations themselves. This is what unsafe rust is. As also the problem of statically verifying whether there can be data races is undecidable, there can be no compiler that allows every program without undefined behaviour while rejecting all programs with undefined behaviour.<br>
<p>
There is a constant development to increase the expressiveness of safe rust, e.g., have a better borrow checker that allows more code, because there are more cases where it can verify that the code is sound. Thus the things that you can provide in safe rust will grow. However there will always be unsafe rust for the cases that the compiler cannot (yet) verify.<br>
<p>
TL;DR You already have the language that forbids undefined behaviour. It is called safe rust. And unsafe rust is especially there to allow programs where the compiler cannot verify that there is no undefined behaviour. As there will always be such programs and people want to have that extra performance gain, there is a place for unsafe rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How much of this is that a new language displays undefined behavior in a preceeding language?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 11:42 UTC (Sat)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908470/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;This is exactly what the programming language that is called &quot;safe rust&quot; promises to provide.</font><br>
<p>
To be nitpicky: no it doesn&#x27;t, because &quot;safe Rust&quot; does not give a meaning to every syntactically valid Rust programs - some of those programs use unsafe.<br>
<p>
<font class="QuotedText">&gt;However this is not what people want, at least not always. Unsafe rust is there to allow programs that do not have undefined behaviour, but still cannot represented in safe rust. E.g. using uninitialized memory. You cannot predict what you get when you just do a read on the memory. Of course you can enforce that all memory is initialized before first use.</font><br>
<p>
&quot;Well-defined&quot; does not mean &quot;predictable&quot;. Reading from uninitialised memory could be given a perfectly well-defined behaviour: you get unspecified results. Saying that uninitialised memory has unspecified contents is different from saying that reading from uninitialised memory is undefined behaviour. In the latter case, modern optimising compilers are designed around the assumption that they only compile code that does not exhibit undefined behaviour, which means that for example they assume that uninitialised memory is never read. That means that if you write a function that looks like this:<br>
<p>
foo(y) {<br>
    int x;<br>
    if (y == 0) {<br>
       x = 0;<br>
    }<br>
    printf(&quot;%d\n&quot;, x);<br>
}<br>
<p>
then the compiler is permitted to assume that foo is only called with the parameter 0. If you call foo with a non-zero parameter, the compiler is entitled to optimise that out, because it is permitted to assume that that code is unreachable, etc. This is very different from saying &quot;uninitialised memory has unspecified contents, may be anything, might be different each time you read it, might give you torn writes, etc.&quot;<br>
<p>
Reading from uninitialised memory is still potentially *unsafe*, because you might get bit patterns that do not correspond to a valid element of the type: an uninitialised pointer of type &#x27;NonNullPtr&lt;T&gt;&#x27; might happen to be 0. So it&#x27;s still unsafe, but it doesn&#x27;t have to be undefined. It could be well-defined but unspecified.<br>
<p>
The same is generally true of all undefined behaviour. They didn&#x27;t have to say &quot;signed overflow is UB, and the compiler is permitted to assume that any branch in which signed overflow occurs is IMPOSSIBLE&quot;, and I don&#x27;t think they even intended to do so. They could have said &quot;signed overflow produces unspecified, potentially nondeterministic, but valid, results.&quot;<br>
<p>
<font class="QuotedText">&gt;Another category of clearly undefined behaviour are data races. In many cases not even the hardware defined clearly what can happen. Not only that the concrete behaviour depends on precise timings of events that you have no control over. But also what are the possible outcomes? Which reorderings are possible inside the CPU if you do not enforce memory barriers? Is it possible that you can read some clearly invalid data that results from a partial store? The hardware manufacturers will not provide any specs, because they want to have the freedom to change the inner behaviour of the CPU. Of course, you can enforce that there are always memory barriers in place. This is what safe rust does. Sometimes people want to have more performance by doing crazy optimizations themselves. This is what unsafe rust is. </font><br>
<p>
The problem is that there is no in-between. There&#x27;s no reason that there cannot be a mode &quot;semisafe&quot; halfway between safe and unsafe where these things have unspecified, platform-dependent, unknowable, possibly nondeterministic behaviour, but they still are always guaranteed to, at the very least, have behaviour of some sort. Compiler developers claim that this would result in huge numbers of lost optimisation opportunities, but I&#x27;m not sure I entirely believe them. As far as I know, the Linux kernel compiles with a few UB-assumption-based optimisations disabled (-fno-delete-null-pointer-checks, for example) and nobody is clamouring to re-enable them for the critical performance improvements that would entail. <br>
<p>
Data races are relatively simple: just say &quot;a read that races with a write may produce a value corresponding to any arbitrary bit pattern - the result will be implementation-dependent&quot;. Then the compiler developers can provide more details than that, they might say &quot;aligned 64-bit values cannot result in tearing&quot;. Or they might not. Portable code could not rely on the behaviour of data races, but could at least rely on the compiler not doing really stupid things like optimising out safety checks that it thinks are unreachable based on some detected UB.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How much of this is that a new language displays undefined behavior in a preceeding language?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 12:44 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/908473/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Reading from uninitialised memory is still potentially *unsafe*, because you might get bit patterns that do not correspond to a valid element of the type: an uninitialised pointer of type &#x27;NonNullPtr&lt;T&gt;&#x27; might happen to be 0. So it&#x27;s still unsafe, but it doesn&#x27;t have to be undefined. It could be well-defined but unspecified.</font><br>
<p>
There is nothing well defined about this. The compiler will (and should) clearly assume that the pointer is non null. However it will be regarded as non-null in some cases (e.g. a test against 0 will be optimized away) but it will be null in other cases (e.g. before a copy there is no test against zero). The result of comparisons against this pointer will be non-deterministic, can be different every time you do a comparison. And this affects all the code dealing with this value transitively. There is no way of giving any sensible semantics to what can happen after reading uninitialized memory.<br>
<p>
<font class="QuotedText">&gt; Data races are relatively simple: just say &quot;a read that races with a write may produce a value corresponding to any arbitrary bit pattern - the result will be implementation-dependent&quot;.</font><br>
<p>
It is much more complicated than that. The problem is that one read in the programming language can lead to multiple reads in machine code. So you do not only get an arbitrary bit pattern, but also a bit pattern that suddenly changes at the moment where the value needs to be read a second time because it was evicted from the register. To guard against this in the presence of data races, every read needs to be changed to a copy. And this will clearly have some performance impact. And again this will effect anything that deals with this data value. If you pass the value to some function, the compiler is free to inline the function and inside this function you have a passed value that changes, just because it was evicted from the register and read a second time.<br>
<p>
<font class="QuotedText">&gt; ... where these things have unspecified, platform-dependent, unknowable, possibly nondeterministic behaviour, but they still are always guaranteed to, at the very least, have behaviour of some sort.</font><br>
<p>
This is exactly what we call undefined behaviour. There clearly is some behaviour, but you cannot say which one it is. What do you want to do with a program that writes garbage to the stack (i.e. overwriting return addresses)? Clearly it will have some behaviour, but it is not defined in any way. You can do this in unsafe rust. If you want to disallow this in unsafe rust, you either have to solve the halting problem or to disallow many programs that do not have undefined behaviour. There is no other choice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor908485"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 18:53 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/908485/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As with many things, the kernel is partly at fault here. The linked list paradigm was nifty for 90s era CPUs, but it&#x27;s absolutely awful for a modern CPU. I have code that demonstrates walking an array of randomised pointers-to-structs is around 11x faster on my laptop than walking the same list of structs in the same order with an embedded list_head.<br>
<p>
11x. Think about that. No, I don&#x27;t do much per entry, just load an int and accumulate it. Still, that&#x27;s a good match for much kernel code.<br>
<p>
Kernel programmers are terrified of allocating memory (because it can fail) and use these ridiculous data structures that avoid memory allocation instead. It&#x27;s time to get over those fears and kill linux/list.h<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908485/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908486"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 19:40 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/908486/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Kernel programmers are terrified of allocating memory (because it can fail) and use these ridiculous data structures that avoid memory allocation instead. It&#x27;s time to get over those fears and kill linux/list.h</font><br>
<p>
The other thing is the lifetime management. With standard growable vectors you need to manage the lifetime of the container and control references to the elements, because they might get invalidated when the container grows. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908486/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908487"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2022 19:51 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/908487/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As someone who&#x27;s written an in-kernel container data structure, this wasn&#x27;t a concern. If the container lost references to the objects it contained, that was simply a bug. Adding an object to the container incremented the refcount and removing it decremented the refcount. There&#x27;s no refcount in the container itself; if all objects in the container are removed, the container shrinks to a NULL pointer (and some small metadata; flags &amp; a spinlock)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908487/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2022 14:26 UTC (Sun)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/908521/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think this comment is kind of interesting because it sort of mirrors what I&#x27;ve saw a while ago regarding locking.<br>
<p>
At the time, I recall there were some discussions around the strong limitations Rust imposes on locking by requiring data to be wrapped in a lock type. There were lots of points about the sort of clever constructions that this would make more difficult. A few months later, there was an unrelated blog post series by Daniel Vetter[1] that heavily urged people to stop being so clever with their locking and design their architectures around simple locking hierarchies and sharing instead. The constraints there, like &quot;Protect Data, not Code&quot;, having a clear relationship between locks and data, keeping the locking rules the same over time etc. heavily reminded me of Rust&#x27;s rules, and the concerns I had seen about them before.<br>
<p>
That is not to say that Rust&#x27;s abstractions are infallible, perfect for the kernel, or always better than what the kernel has. But between locks, complex lifetimes and linked lists, it does create the impression that a lot of the difficulties are really going with the grain of where people have been wanting to move the kernel anyway. I&#x27;m curious if those examples will continue.<br>
<p>
[1] <a href="https://blog.ffwll.ch/2022/07/locking-engineering.html">https://blog.ffwll.ch/2022/07/locking-engineering.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 4:40 UTC (Mon)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/908558/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In general I agree, but for lock waitlists I don&#x27;t think we&#x27;d ever want to switch to a vector.<br>
<p>
Lock waitlists are typically short - expected length of 1! - and we aren&#x27;t ever walking the whole thing, the operations are adding to the end of the list and waking up the waiter at the head of the list, so we actually end up with less pointer chasing with a linked list.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908563"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 7:04 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/908563/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh yes, (sleep) locks shouldn&#x27;t even have a list_head. Instead they should have a pointer to their first waiter. That shrinks the lock by the size of one pointer. How that waiter keeps track of other waiters is debatable; maybe it should be vector, but I suspect a list_head is just fine. Perhaps a vector makes sense to keep track of the readers so they can all be woken up quickly, but I see no advantage to keep writers in anything other than a list.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908563/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor910211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The perils of pinning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2022 20:19 UTC (Mon)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/910211/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thing that makes linked list walking slower compared to walking an array on modern CPUS v.s. older ones is because modern CPUs don&#x27;t do well on long dependency chains (i.e. load list head -&gt; load next -&gt; load next -&gt; ...).  This is also why bignum algorithms (e.g. operations on 2048-bit numbers) avoid using &#x27;add-carry&#x27; instructions and instead accumulate the carries in a tree like fashion.<br>
<p>
With array walking you don&#x27;t have that dependency chain so the processor can load the next pointers out-of-order with whatever processing occurs on the element and operate on a whole slew of elements in parallel.  As soon as the amount of processing on each element exceeds the CPU&#x27;s speculation window (or is barred from doing so, by e.g., a branch miss predict) the array walk won&#x27;t be much faster than the linked list, if at all.<br>
<p>
When benchmarking you really need to know what you are benchmarking.  In this case you are checking your CPU&#x27;s speculation performance, which may not be what you really wanted to measure.  As another random example: a few decades ago the drhystone benchmark was very popular.  These days you don&#x27;t see much of it because it is so short that in effect it is benchmarking the CPU&#x27;s speculation window of how many iterations of the benchmark&#x27;s loop it can execute in parallel and little on how fast the CPU can finish the calculations in it (amongst various other problems).<br>
<p>
A data structure needs to be evaluated by a lot more metrics than a (non-realistic) performance measurement on traversal, for example:<br>
- Cost of insertion/removal (quite high for an array-of-pointers)<br>
- Cost of the operation v.s. the walking<br>
- Operation context considerations (e.g. places you can&#x27;t allocate memory -- free list for an allocator?)<br>
- Limitations on the array size (the kernel doesn&#x27;t like to do high-order allocations)<br>
- The cost of traversal may not matter (think LRU type structures)<br>
<p>
Every data structure has its place, even if you have a serious dislike for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
