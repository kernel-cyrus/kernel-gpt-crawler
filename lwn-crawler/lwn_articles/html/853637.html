        <!DOCTYPE html>
        <html lang="en">
        <head><title>Avoiding unintended connection failures with SO_REUSEPORT [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/853637/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/853955/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/853637/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Avoiding unintended connection failures with SO_REUSEPORT</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 23, 2021</br>
           </div>
Many of us think that we operate busy web servers; LWN's server, for
example, sweats hard when keeping up with the comment stream that
accompanies any article mentioning the Rust programming language.  But some
organizations run truly <i>busy</i> servers and have to take some
extraordinary measures to keep up with levels of traffic that even language
advocates cannot create.  The <tt>SO_REUSEPORT</tt> socket option is one of
many features that have been added to the network stack to help these use
cases.  <tt>SO_REUSEPORT</tt> suffers from an implementation problem that can
cause connections to fail, though.  Kuniyuki Iwashima has posted <a
href="/ml/linux-kernel/20210420154140.80034-1-kuniyu@amazon.co.jp/">a patch
set</a> addressing this problem, but there is some doubt as to whether it
takes the right approach.
<p>
In normal usage, only one process is allowed to bind to any given 
TCP port to accept incoming connections.  On busy systems, that process can
become a bottleneck, even if all it does is pass accepted connections off
to other processes for handling.  The <tt>SO_REUSEPORT</tt> socket option,
which was <a href="/Articles/542629/">added to the 3.9 kernel</a> in 2013,
was meant to address that bottleneck.  This option allows multiple
processes to accept connections on the same port; whenever a connection
request comes in, the kernel will pick one of the listening processes as
the recipient.  Systems using <tt>SO_REUSEPORT</tt> can dispense with the
dispatcher process, improving scalability overall.
<p>
<tt>SO_REUSEPORT</tt> does its work when the initial <tt>SYN</tt> packet
(the connection request) is received; at that time, a provisional new
socket is created and assigned to one of the listening processes.  The new
connection will
first wait for the handshake to complete, after which it will
sit in a queue until the selected process calls <a
href="https://man7.org/linux/man-pages/man2/accept.2.html"><tt>accept()</tt></a>
to accept the connection and begin the session.  On busy servers, there may
be a fair number of connections awaiting acceptance; the maximum length of
that queue is specified with the <a
href="https://man7.org/linux/man-pages/man2/listen.2.html"><tt>listen()</tt></a>
system call.
<p>
<h4>When SO_REUSEPORT misbehaves</h4>
<p>
Most of the time, <tt>SO_REUSEPORT</tt> works just as intended, but that
can change when one of the listening processes exits.  If a process quits
with open network connections, those connections will be closed — not a
surprising result.  But the kernel will also "close" (by resetting) any
incoming connections that are still in the accept queue.  In the absence of
<tt>SO_REUSEPORT</tt> this behavior makes sense; if the (single)
listening process goes away, there is no longer anybody who can accept
those connections.
<p>
If <tt>SO_REUSEPORT</tt> is being used, and if there are multiple listening
processes, incoming connections do not necessarily have to be closed in
this way.  There are, after all, other processes running that would happily
handle those connections.  But once the kernel has committed an incoming
connection to a specific process, it will not change its mind later; either
that connection will be accepted by the chosen process, or it will be
closed.
<p>
There are a number of reasons why a listening process might exit on a busy
system.  Perhaps it simply crashed.  But, more likely, the server is being
restarted to effect a configuration change or to switch to a new
certificate.  Such restarts can be phased across a pool of server processes
so that they don't all exit at once; that should allow incoming connections
to be handled without any apparent interruption of service.  But when the
above-described behavior comes into the picture, users can be turned away,
which tends to have an unpleasant effect on their mood.  The depressive
effect on the operator of the site, who may have just lost the opportunity to
learn that the would-be user is in the market for a new pair of socks, can be
even worse.
<p>
There are ways around this problem, such as using a BPF program to steer
incoming connections away from a server process that is about to exit, then
being sure that it drains any queued connections before it bows out.  But 
Iwashima makes the point that there is a better way: when a process exits,
just take all of the queued incoming connections and reassign them to a
different process for handling.  After all, there is no state yet
associated with an unaccepted request; one process can handle it just as
well as another, and moving it will avoid causing the request to fail.
<p>
<h4>Migrating the accept queue</h4>
<p>
Getting there requires an eleven-part patch set, though.  The first step is
to add a new sysctl knob (<tt>net.ipv4.tcp_migrate_req</tt>; there does not
appear to be an IPv6 version) controlling whether incoming connections
should be moved to a new listener if the one they were assigned to exits.
By default, this new behavior is disabled to avoid interfering with
deployments where other arrangements have been made.
<p>
Actually migrating incoming connections away from an exiting server process
is a bit more complicated than one might think because the "accept queue"
is a bit more complicated than has been discussed so far.  Remember that
TCP connections go through a three-way handshake before being established:
the connection is initiated with a <tt>SYN</tt> packet, the server side
responds with <tt>SYN+ACK</tt>, and the initiator completes the connection
with an <tt>ACK</tt> packet.  That entire process must complete before an
incoming connection can be given to a server process via
<tt>accept()</tt>.
<p>
Fully established connections — those that have completed the three-way
handshake but which have not yet been accepted — are relatively easy to
move to a new server process; they are just shunted from one queue to
another.  Connections that are still in the handshake are more complicated,
though.  They can only be moved at specific points during the sequence;
when the handshake completes being the most obvious such point.  It is also
possible to move a connection when the <tt>SYN+ACK</tt> is retransmitted,
should that be necessary.  Either way, the remains of the old server
process's socket structure must stay around for long enough to finish the
handshake; that adds a certain amount of complexity.
<p>
One remaining question is: how is the new recipient for the connection
chosen?  Normally, the kernel will use the same algorithm it uses to pick a
recipient in the first place, which is essentially a round-robin approach.
But there will surely be users who know better and who want to be able to
redirect these connections more explicitly.  For those users there is,
inevitably, a new BPF program type (<tt>BPF_PROG_TYPE_SK_REUSEPORT</tt>)
that can be used to make decisions on where to reroute these connections.
<p>
<h4>Unacceptable?</h4>
<p>
As of this writing, the only comment on Iwashima's patch set <a
href="/ml/linux-kernel/67fb2df2-3703-4ce9-62d0-ba15435c5a0b@gmail.com/">comes
from Eric Dumazet</a>, who questioned whether it is the right approach.
Since <tt>SO_REUSEPORT</tt> was added, he said, the TCP accept code has
been reworked to run locklessly, which should address much of the
scalability problem that <tt>SO_REUSEPORT</tt> was added to mitigate in the
first place.  Thus, he said, it might be better for applications to go back to a
single-listener mode, perhaps helped by a new form of <tt>accept()</tt>
that would allow incoming connections to be quickly directed to server
processes.
<p>
That, of course, is a rather different development direction than Iwashima
has taken so far and is thus unlikely to be welcome news.  One could
argue that, while a new <tt>accept()</tt> call might be a more pleasing
solution to the overall problem, there should still be a place for a patch
series making an existing kernel feature work without occasionally killing
incoming connections.  So it's not clear how this will play out; stay
tuned.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-SO_REUSEPORT">Networking/SO_REUSEPORT</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/853637/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor854236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 15:35 UTC (Fri)
                               by <b>clugstj</b> (subscriber, #4020)
                              [<a href="/Articles/854236/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So, we are worrying about 1 in a billion connections to a busy web server failing?  I can&#x27;t see this being worth the added complexity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 19:07 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/854282/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not just web sockets this is useful for.<br>
<p>
The connection in question has already been accepted and there&#x27;s a server willing to work with it. Dropping it is just plain rude, esp. as the client has no way to decide whether the server crashed or not. This is bad. You need retry code in the client (which otherwise could just blindly assume that the server crashed). The retry introduces latency you might want to avoid.<br>
<p>
Also the client might be a load balancer which now thinks that your server just crashed. This is a bad idea, esp. if you use a sharded data set because the requests now go to &quot;cold&quot; machines.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 19:10 UTC (Fri)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/854280/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So, we are worrying about 1 in a billion connections to a busy web server failing?</font><br>
Where did you get this number from? Is it stated somewhere in the patch series?<br>
<p>
A TCP connection could fail for many other reasons, too.<br>
We definitely don&#x27;t want to add additional ones, as randomly failing server connections give poor user experience.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854329"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 2:37 UTC (Sat)
                               by <b>clugstj</b> (subscriber, #4020)
                              [<a href="/Articles/854329/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article says &quot;the server is being restarted to effect a configuration change or to switch to a new certificate&quot;.  How often does this happen?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854329/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 2:38 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/854330/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Every couple of weeks with Let&#x27;s Encrypt.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 2:39 UTC (Sat)
                               by <b>clugstj</b> (subscriber, #4020)
                              [<a href="/Articles/854331/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you are using Let&#x27;s Encrypt, you server isn&#x27;t that busy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 2:43 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/854332/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s not necessarily true. For example, we were using plenty of Let&#x27;s Encrypt certs on internal NAS-like servers. We could have used self-signed certs, but maintaining our own CA and installing it on all computers was a bigger hassle.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor854335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 4:45 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/854335/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speaking as a Google SRE, we restart servers &quot;to effect a configuration change&quot; all the damn time. We push new code into production literally every single week[1] unless there&#x27;s a holiday or our error budget is depleted. Every push involves (slowly, carefully[2]) restarting all running instances of the server. Now, in practice, SO_REUSEPORT is probably not the most relevant flag in the world for us, but that&#x27;s mostly just because we&#x27;ve already solved this problem (i.e. &quot;don&#x27;t drop in-flight requests&quot;) at other levels of abstraction, and so asking the kernel for help is less useful. But any shop that&#x27;s less aggressively containerized than us[3] would probably find this sort of thing Nice To Have, if they want to do frequent releases.<br>
<p>
[1]: This is my experience on one team managing a small number of services. It is not necessarily representative; I know for a fact that other teams often have wildly different release cadences.<br>
[2]: <a href="https://sre.google/workbook/canarying-releases/">https://sre.google/workbook/canarying-releases/</a><br>
[3]: <a href="https://sre.google/sre-book/production-environment/">https://sre.google/sre-book/production-environment/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 19:07 UTC (Sat)
                               by <b>ms-tg</b> (subscriber, #89231)
                              [<a href="/Articles/854360/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for posting this, I find a lot of value in the “this is what I’m seeing in my industry” posts that LWN attracts related to specific kernel intricacies.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 23:28 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/854372/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I should probably also emphasize that I deal with things at a much higher level than &quot;the specific flags we pass to individual syscalls when setting up sockets,&quot; so while I believe what I have written is generally correct, my understanding might be incomplete or incorrect with respect to SO_REUSEPORT in particular.<br>
<p>
Nevertheless, there are definitely lots of people who want to push their software frequently, and making that easier in one fashion or another can only be a good thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854540"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 18:37 UTC (Mon)
                               by <b>sodabrew</b> (guest, #95737)
                              [<a href="/Articles/854540/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You may be mistaken on Google&#x27;s lack of use for SO_REUSEPORT, given that SO_REUSEPORT was developed by Tom Herbert at Google and merged for the 3.9 kernel release: <a href="https://lwn.net/Articles/542629/">https://lwn.net/Articles/542629/</a> <br>
<p>
It&#x27;s certainly possible that the original needs have changed and become solved in other ways in the eight years that have passed, or that you&#x27;re working on a different product that doesn&#x27;t have the same requirements as the one for which this feature was developed, but either way, your statement that (paraphrased) &quot;Google doesn&#x27;t use SO_REUSEPORT&quot; ought to have a modifier of either &quot;...anymore because...&quot; or &quot;...in my group that&#x27;s doing something different.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854540/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854551"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 22:04 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/854551/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is fairly likely; I&#x27;m basing my assumptions on the &quot;lame duck state&quot; documented here: <a href="https://sre.google/sre-book/load-balancing-datacenter/">https://sre.google/sre-book/load-balancing-datacenter/</a><br>
<p>
But that probably wouldn&#x27;t work very well for frontends.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854551/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor854369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 23:08 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/854369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not? Linux already has a bunch of similar complexity to prevent timestamp counters wrapping after hundreds of days of uptime, and we all know that would&#x27;ve only happened to evil lazy sysadmins that don&#x27;t apply security updates and totally deserve it. /s<br>
<p>
If this was hardware the maker would&#x27;ve put out a product recall for such a high failure rate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 15:42 UTC (Fri)
                               by <b>Tomasu</b> (guest, #39889)
                              [<a href="/Articles/854237/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder why the queue has to be associated with a process at all till it&#x27;s been &quot;accepted&quot;. Probably just legacy assumptions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 18:29 UTC (Fri)
                               by <b>xi0n</b> (subscriber, #138144)
                              [<a href="/Articles/854270/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AFAIK it’s associated with a particular socket but either way, it does look like legacy assumption. SO_REUSEPORT would likely be simpler in implementation (incl. possibly the patch set discussed here being unnecessary) if those queues were maintained on a per-bindpoint basis instead.<br>
<p>
(This would raise a question what to do with the second argument to listen(). Since the number given there is defined more like a hint than actual limit, it’s probably a minor issue, though).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 16:16 UTC (Fri)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/854241/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if the right thing might be to have SO_REUSEPORT switch to actually dup()ing the single socket to the caller&#x27;s fd. Is there per-socket information that is allowed to be different among the sockets listening on the same port that would cause behavior changes in that situation?<br>
<p>
I assume the now-recommended userspace code would bind the address in a single process and pass the bound socket over a unix domain socket to other processes (or fork after binding it), and it seems like this situation wouldn&#x27;t be too hard to replicate even when userspace didn&#x27;t ask like that, assuming that there aren&#x27;t any visible differences.<br>
<p>
I guess the max queue length may need to be adjusted in order to enqueue the same number of incoming connections total, and that might be noticed by the other local processes?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 20:58 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/854299/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wonder if the right thing might be to have SO_REUSEPORT switch to actually dup()ing the single socket to the caller&#x27;s fd. Is there per-socket information that is allowed to be different among the sockets listening on the same port that would cause behavior changes in that situation?</font><br>
The problem is that you&#x27;ll be funneling all the connections through effectively one thread, because all the file operations take a process-wide lock. This is what SO_REUSEPORT was designed to avoid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 23:29 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/854310/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article mentions that &quot;the TCP accept code has been reworked to run locklessly&quot;. IIRC, the purpose of SO_REUSEPORT wasn&#x27;t to permit multiple threads to dequeue connections; they could already do that, and if there was lock contention this was just a QoI issue. Rather, I think the primary issue was efficient polling and resolving the stampeding herd problem. The reason an incoming connection is immediately assigned to a specific queue is so that only that descriptor (or descriptors if dup&#x27;d) will signal readiness while still avoiding introducing stalling and fair dispatch dilemmas, especially in the context of polling as opposed to threads actually waiting inside accept. The classic way to implement a multi-threaded accept in userspace while avoiding thundering herds was to ensure only a single thread was waiting in accept or polling on the accept descriptor at any one time.  SO_REUSEPORT simply moved assignment earlier in the pipeline while largely preserving semantics.<br>
<p>
BSD supported SO_REUSEPORT long before Linux did, albeit support for TCP seems to be undocumented. Rather than round-robin, though, only the most recent binding is assigned connections. When that goes away the previous one starts to see connections again. However, at least on macOS queued connections are still lost on close. I see FreeBSD added SO_REUSEPORT_LB which does round-robin; not sure if it suffers from the lost connection problem.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 23:39 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/854315/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; IIRC, the purpose of SO_REUSEPORT wasn&#x27;t to permit multiple threads to dequeue connections; they could already do that, and if there was lock contention this was just a QoI issue. </font><br>
SO_REUSEPORT is needed to allow multiple _processes_ to dequeue connections.<br>
<p>
The problem with accepting connections from multiple threads is that they are still effectively serialized, because all file operations take an implicit lock to allocate a file descriptor.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor854286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 19:15 UTC (Fri)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/854286/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do not see how this is useful in practice. nginx has been supporting live updates without dropping any connection for ages with careful protocol to transfer the file descriptors to another process. systemd made that very straightforward to implement as the process can store descriptors before the restart in the pool provided by systemd. Those busy sites surely can implement something like that allowing to preserve not only listening sockets with or without SO_REUSEPORT but also accepted ones. <br>
<p>
As for crashing servers loosing incoming queue is the least of worries as the crash is clear sign that the system misbehaves. And for absolute robustness one can transfer important sockets to another process in the crash handler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 1:07 UTC (Sat)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/854322/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The sockets/connections that the patch set is about have not reached userspace yet when the process is restarted so there is nothing an application can do here. It&#x27;s about connections that have been assigned to a specific process by the kernel but where said process have not yet called accept() to get them when that process was restarted/stopped/crashed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 8:46 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854341/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I tried to do exactly this several times in the past but failed. We had the same problem with haproxy where high traffic users were constantly seeing a few resets being emitted when one queue was unbound. I tried to figure how to detach pending connections from a queue and reinject them into other queues but never managed to, that are was too complex.<br>
<p>
I understand Eric&#x27;s concerns (and he already expressed them to me by then). It is possible that it&#x27;s not the best solution, but it addresses a real issue in field that needs to be addressed.<br>
<p>
We worked around it by passing listening file descriptors between the old and the new process during reloads. All this just to avoid a bind+unbind cycle! It comes with its own set of limitations, of course.<br>
<p>
Also SO_REUSEPORT is not just used for this, the initial purpose was to allow multiple processes to bind to the same port and avoid black out periods. It used to work fine in 2.2 and was removed in 2.4. I had to maintain the patch to reintroduce it till someone else proposed a variant in 3.9 which also implemented the multiqueue balancing. But this is an essential feature in highly available environments.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 10:29 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/854345/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How about this method?<br>
<p>
Have two queues for each listening socket, one normal and one for &quot;extraordinary&quot; requests. In case of a process death during the closure process take the queued connections and redistribute them across extraordinary queues.<br>
<p>
Since these queues are special and are used infrequently, you can use simple locking-based algorithms there.<br>
<p>
Ideally this can be done transparently in kernel, but it can also be done with some userspace assistance. Processes willing to &quot;mop up&quot; connections can open a new listening socket and communicate (via setsockopt/ioctl) that it should be used for connection migration.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854349"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 12:12 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854349/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes that could be an option, I considered it but lost my way by then. The accept queue code became tricky since the reintroduction of SO_REUSEPORT, and I seem to remember that one of the difficulty was to pick pending connections, and another one was to unhash some of the queues while they were in use without losing what was in them. For whatever reason I remember not figuring how to allow a program to still pick what was left in a queue with that queue not being visible to the rx path that distributes incoming requests. But these are old memories, and I remember that Eric was quite concerned about my fiddling there because he was about to finish to kill the SYN queue lock.<br>
<p>
Also it&#x27;s important to keep in mind that we cannot afford to lose even a tenth of a percent of performance there, because such tricks would only be used during process reloads, and the code path they&#x27;re affecting is the one being the most stressed during DDoSes.<br>
<p>
Ideally we should just remove a queue in two steps. First step it should simply be unhashed and second step it should be closed. From what I remember, pending entries were killed inside the unhashing code, but I could be saying crap.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854349/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2021 8:09 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/854388/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Couldn&#x27;t the unhashing be accomplished (with some minimal kernel support of course) by calling listen(fd,0)? Then either process the remaining connections or hand them off to another process. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 16:10 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854530/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, that was among my first attempts. It simply results in the listen queue being zero for that socket and connection requests being dropped. Still I kept that as a work around for the RST for a few days because it managed to cause less RST by rejecting SYNs earlier when detecting the queue was full. But that was not possible after the lockless SYN patches anyway so there was no hope in this direction. Plus this resulted in a huge CPU usage for the user application that had to call accept() in loops and was not able to group the accepts any more.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2021 5:32 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/854694/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You misinderstand (or I miswrote): my intent was to fix the kernel so that &quot;listen(fd,0)&quot; simply closes the queue for new arrivals. Then the process would accept() the remaining open connections (and somehow deal with them), and shut down when that blocks. No new syscall, new common queueing mechanism, or other intrusive shenanigans required.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2021 17:48 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854922/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah OK but the internal problem remains the same: the difficulty of rehashing the queues without losing entries. listen(0), setsockopt(), shutdown(SHUTRD) etc were all among valid candidates for me as soon as I&#x27;d have had a reliable way to move these queues around :-/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2021 5:53 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/854968/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That depends on whether you need kernel support for it. I could get by with an IPC socket to some other server to whom I can send the file descriptors returned from accept()ing these connections.<br>
<p>
Or maybe we want a &quot;sock_inject(listener,conn)&quot; syscall that adds an open socket into a listener&#x27;s queue. You could do to another process, just open /proc/‹serverpid›/fd/‹bound_socket›. In fact something like this is also required for migrating a server to a different host, so it&#x27;d not be a single-use syscall.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor855858"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 9, 2021 6:49 UTC (Sun)
                               by <b>bernat</b> (subscriber, #51658)
                              [<a href="/Articles/855858/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The idea of listen(0) was to then allow you to drain the remaining connections. I remember you proposing this simple solution but your patch was rejected because &quot;this should be done with BPF.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/855858/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor854347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 11:05 UTC (Sat)
                               by <b>gracinet</b> (guest, #89400)
                              [<a href="/Articles/854347/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is interesting to me because SO_REUSEPORT is as far as I know the only way to do prefork multiprocessing in gRPC servers, which is something that&#x27;s typically wanted if implemented in Python, because of the global interpreter lock (GIL).<br>
<p>
In some cases the performance impact of the GIL can be overstated, it really depends on the workload. But then, many Python applications aren&#x27;t designed to be thread-safe anyway because it&#x27;s generally believed that the GIL would make the effort useless.<br>
<p>
A common case for restarting worker processes would be to reach some limitation, such as memory footprint. Lots of applications in the wild have at least minor memory leaks.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2021 21:56 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/854417/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m a bit confused. What good does it do that SYN processing is lockless, if you&#x27;re still going to serialize it into a single listener?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 16:13 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s essential to deal with high the SYN rates that happen during SYN floods (i.e. all the time on high traffic sites). You want that part to be ultra-scalable. The difference can be 1 vs 10 Mpps.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854427"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 4:45 UTC (Mon)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/854427/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not just let a process do something like call listen(fd, 0) to indicate that it doesn&#x27;t want any more connections queued to the socket.  Then it can wait a few seconds for any handshaking to complete and use non-blocking accept() to empty it&#x27;s queue before exiting or reloading config gracefully.<br>
<p>
This doesn&#x27;t handle the crashing process scenario, but that&#x27;s a lost cause anyway - a crash after accept() was called could still result in a dropped connection or invalid or partial response and agrevated users.<br>
<p>
This suggestion is pretty much the same as using a BPF program to steer connections as suggested in the article.  It just makes a simpler API to achieve the same.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854427/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 16:11 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854531/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
doesn&#x27;t work well, see my response above.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding unintended connection failures with SO_REUSEPORT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 22:39 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/854552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; LWN&#x27;s server, for example, sweats hard when keeping up with the comment stream that accompanies any article mentioning the Rust programming language. But some organizations run truly busy servers and have to take some extraordinary measures to keep up with levels of traffic that even language advocates cannot create.</font><br>
<p>
It looks like our editor&#x27;s great mood made him temporarily stray from LWN&#x27;s legendary rigor and thoroughness and drop a piece of critical information highly relevant to this article: in such a difficult server situation, are the Rust, C or C++ advocates causing the most traffic?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
