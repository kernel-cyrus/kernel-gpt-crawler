        <!DOCTYPE html>
        <html lang="en">
        <head><title>Requirements for RCU part 1: the fundamentals [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/652156/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/652147/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/652156/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Requirements for RCU part 1: the fundamentals</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>July 29, 2015</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
Read-copy update (RCU) is a synchronization mechanism that is often
used as a replacement for reader-writer locking.
RCU is unusual in that updaters do not block readers,
which means that RCU's read-side primitives can be exceedingly fast
and scalable.
In addition, updaters can make useful forward progress concurrently
with readers.
However, all this concurrency between RCU readers and updaters does raise
the question of exactly what RCU readers are doing, which in turn
raises the question of exactly what RCU's requirements are.

<p>
This document, to be published in three parts, therefore summarizes RCU's
requirements, and can be thought 
of as an informal, high-level specification for RCU.
It is important to understand that RCU's specification is primarily
empirical in nature;
in fact, I learned about many of these requirements the hard way.
This situation might cause some consternation, however, not only
has this learning process been a lot of fun, but it has also been
a great privilege to work with so many people willing to apply
technologies in interesting new ways.

<p>
All that aside, the following categories of known RCU requirements will be
covered in this article:
</p>

<ol class="spacylist">
<li>	<a href="#Fundamental Requirements">
	Fundamental Requirements</a>
<li>	<a href="#Fundamental Non-Requirements">Fundamental Non-Requirements</a>
</ol>

<p>
This is followed by, of course, the inevitable
<a href="#Answers to Quick Quizzes">answers to the quick quizzes</a>.  The
following articles will continue the exploration of this topic with several
other categories of requirements.

<h4><a name="Fundamental Requirements">Fundamental requirements</a></h4>

<p>
RCU's fundamental requirements are the closest thing RCU has to hard
mathematical requirements.
These are:

<ol class="spacylist">
<li>	<a href="#Grace-Period Guarantee">
	Grace-Period Guarantee</a>
<li>	<a href="#Publish-Subscribe Guarantee">
	Publish-Subscribe Guarantee</a>
<li>	<a href="#RCU Primitives Guaranteed to Execute Unconditionally">
	RCU Primitives Guaranteed to Execute Unconditionally</a>
<li>	<a href="#Guaranteed Read-to-Write Upgrade">
	Guaranteed Read-to-Write Upgrade</a>
</ol>

<h4><a name="Grace-Period Guarantee">Grace-period guarantee</a></h4>

<p>
RCU's grace-period guarantee is unusual in being premeditated:
Jack Slingwine and I had this guarantee firmly in mind when we started
work on RCU (then called &ldquo;rclock&rdquo;) in the early 1990s.
That said, the past two decades of experience with RCU have produced
a much more detailed understanding of this guarantee.

<p>
RCU's grace-period guarantee allows updaters to wait for all
pre-existing RCU read-side critical sections to complete.
An RCU read-side critical section
begins with the marker <tt>rcu_read_lock()</tt> and ends with
the marker <tt>rcu_read_unlock()</tt>.
These markers may be nested, and RCU treats a nested set as one
big RCU read-side critical section.
Production-quality implementations of <tt>rcu_read_lock()</tt> and
<tt>rcu_read_unlock()</tt> are extremely lightweight, and in
fact have exactly zero overhead in Linux kernels built for production
use with <tt>CONFIG_PREEMPT=n</tt>.

<p>
This guarantee allows ordering to be enforced with extremely low
overhead to readers, for example:

<blockquote>
<pre>
 1 int x = 0, y = 0;
 2 
 3 void thread0(void)
 4 {
 5   rcu_read_lock();
 6   r1 = READ_ONCE(x);
 7   r2 = READ_ONCE(y);
 8   rcu_read_unlock();
 9 }
10 
11 void thread1(void)
12 {
13   WRITE_ONCE(x, 1);
14   synchronize_rcu();
15   WRITE_ONCE(y, 1);
16 }
</pre>
</blockquote>

<p>

<div class="tlr">
<a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
Wait a minute!
You said that updaters can make useful forward progress concurrently
with readers, but pre-existing readers will block
<tt>synchronize_rcu()</tt>!!!
Just who are you trying to fool???
<br><a href="#qq1answer">Answer</a>
</div>

Because the <tt>synchronize_rcu()</tt> on line&nbsp;14 waits for
all pre-existing readers, any instance of <tt>thread0()</tt> that
loads a value of zero from <tt>x</tt> must complete before
<tt>thread1()</tt> stores to <tt>y</tt>, so that instance must
also load a value of zero from <tt>y</tt>.
Similarly, any instance of <tt>thread0()</tt> that loads a value of
one from <tt>y</tt> must have started after the
<tt>synchronize_rcu()</tt> started, and must therefore also load
a value of one from <tt>x</tt>.
Therefore, the outcome:
<p>
<pre>
    (r1 == 0 &amp;&amp; r2 == 1)
</pre>
<p>
cannot happen.


<p>
This scenario resembles one of the first uses of RCU in
<a href="http://en.wikipedia.org/wiki/DYNIX">DYNIX/ptx</a>,
which managed a distributed lock manager's transition into
a state suitable for handling recovery from node failure,
more or less as follows:

<blockquote>
<pre>
 1 #define STATE_NORMAL        0
 2 #define STATE_WANT_RECOVERY 1
 3 #define STATE_RECOVERING    2
 4 #define STATE_WANT_NORMAL   3
 5 
 6 int state = STATE_NORMAL;
 7 
 8 void do_something_dlm(void)
 9 {
10   int state_snap;
11 
12   rcu_read_lock();
13   state_snap = READ_ONCE(state);
14   if (state_snap == STATE_NORMAL)
15     do_something();
16   else
17     do_something_carefully();
18   rcu_read_unlock();
19 }
20 
21 void start_recovery(void)
22 {
23   WRITE_ONCE(state, STATE_WANT_RECOVERY);
24   synchronize_rcu();
25   WRITE_ONCE(state, STATE_RECOVERING);
26   recovery();
27   WRITE_ONCE(state, STATE_WANT_NORMAL);
28   synchronize_rcu();
29   WRITE_ONCE(state, STATE_NORMAL);
30 }
</pre>
</blockquote>

<p>

<div class="tlr">
<a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
Why is the <tt>synchronize_rcu()</tt> on line&nbsp;28 needed?
<br><a href="#qq2answer">Answer</a>
</div>

The RCU read-side critical section in <tt>do_something_dlm()</tt>
works with the <tt>synchronize_rcu()</tt> in <tt>start_recovery()</tt>
to guarantee that <tt>do_something()</tt> never runs concurrently
with <tt>recovery()</tt>, but with little or no synchronization
overhead in <tt>do_something_dlm()</tt>.

<p>
In order to avoid fatal problems such as deadlocks,
an RCU read-side critical section must not contain
calls to <tt>synchronize_rcu()</tt>.
Similarly, an RCU read-side critical section must not
contain anything that waits, directly or indirectly, on completion of
an invocation of <tt>synchronize_rcu()</tt>.

<p>
Although RCU's grace-period guarantee is useful in and of itself, with
<a href="https://lwn.net/Articles/573497/">quite a few use cases</a>,
it would be good to be able to use RCU to coordinate read-side
access to linked data structures.
For this, the grace-period guarantee is not sufficient, as can
be seen in function <tt>add_gp_buggy()</tt> below.
We will look at the reader's code later, but in the meantime, just think of
the reader as locklessly picking up the <tt>gp</tt> pointer,
and, if the value loaded is non-<tt>NULL</tt>, locklessly accessing the
<tt>-&gt;a</tt> and <tt>-&gt;b</tt> fields.

<blockquote>
<pre>
 1 bool add_gp_buggy(int a, int b)
 2 {
 3   p = kmalloc(sizeof(*p), GFP_KERNEL);
 4   if (!p)
 5     return -ENOMEM;
 6   spin_lock(&amp;gp_lock);
 7   if (rcu_access_pointer(gp)) {
 8     spin_unlock(&amp;gp_lock);
 9     return false;
10   }
11   p-&gt;a = a;
12   p-&gt;b = a;
13   gp = p; /* ORDERING BUG */
14   spin_unlock(&amp;gp_lock);
15   return true;
16 }
</pre>
</blockquote>

<p>
The problem is that both the compiler and weakly ordered CPUs are within
their rights to reorder this code as follows:

<blockquote>
<pre>
 1 bool add_gp_buggy_optimized(int a, int b)
 2 {
 3   p = kmalloc(sizeof(*p), GFP_KERNEL);
 4   if (!p)
 5     return -ENOMEM;
 6   spin_lock(&amp;gp_lock);
 7   if (rcu_access_pointer(gp)) {
 8     spin_unlock(&amp;gp_lock);
 9     return false;
10   }
<b>11   gp = p; /* ORDERING BUG */
12   p-&gt;a = a;
13   p-&gt;b = a;</b>
14   spin_unlock(&amp;gp_lock);
15   return true;
16 }
</pre>
</blockquote>

<p>
If an RCU reader fetches <tt>gp</tt> just after
<tt>add_gp_buggy_optimized</tt> executes line&nbsp;11,
it will see garbage in the <tt>-&gt;a</tt> and <tt>-&gt;b</tt>
fields.
And this is but one of many ways in which compiler and hardware optimizations
could cause trouble.
Therefore, we clearly need some way to prevent the compiler and the CPU from
reordering in this manner, which brings us to the publish-subscribe
guarantee discussed in the next section.

<h4><a name="Publish-Subscribe Guarantee">Publish-subscribe guarantee</a></h4>

<p>
RCU's publish-subscribe guarantee allows data to be inserted
into a linked data structure without disrupting RCU readers.
The updater uses <tt>rcu_assign_pointer()</tt> to insert the
new data, and readers use <tt>rcu_dereference()</tt> to
access data, whether new or old.
The following shows an example of insertion:

<blockquote>
<pre>
 1 bool add_gp(int a, int b)
 2 {
 3   p = kmalloc(sizeof(*p), GFP_KERNEL);
 4   if (!p)
 5     return -ENOMEM;
 6   spin_lock(&amp;gp_lock);
 7   if (rcu_access_pointer(gp)) {
 8     spin_unlock(&amp;gp_lock);
 9     return false;
10   }
11   p-&gt;a = a;
12   p-&gt;b = a;
13   rcu_assign_pointer(gp, p);
14   spin_unlock(&amp;gp_lock);
15   return true;
16 }
</pre>
</blockquote>

<p>
<div class="tlr">
<a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
But <tt>rcu_assign_pointer()</tt> does nothing to prevent the
two assignments to <tt>p-&gt;a</tt> and <tt>p-&gt;b</tt>
from being reordered.
Can't that also cause problems?
<br><a href="#qq3answer">Answer</a>
</div>

The <tt>rcu_assign_pointer()</tt> on line&nbsp;13 is conceptually
equivalent to a simple assignment statement, but also guarantees
that its assignment will
happen after any prior assignments, including the two in lines&nbsp;11 and&nbsp;12,
similar to the C11 <tt>memory_order_release</tt> store operation.
It also prevents any number of &ldquo;interesting&rdquo; compiler
optimizations, for example, the use of <tt>gp</tt> as a scratch
location immediately preceding the assignment.

<p>
It is tempting to assume that the reader need not do anything special
to control its accesses to the RCU-protected data,
as shown in <tt>do_something_gp_buggy()</tt> below:

<blockquote>
<pre>
 1 bool do_something_gp_buggy(void)
 2 {
 3   rcu_read_lock();
 4   p = gp;  /* OPTIMIZATIONS GALORE!!! */
 5   if (p) {
 6     do_something(p-&gt;a, p-&gt;b);
 7     rcu_read_unlock();
 8     return true;
 9   }
10   rcu_read_unlock();
11   return false;
12 }
</pre>
</blockquote>

<p>
However, this temptation must be resisted because there are a
surprisingly large number of ways that the compiler
(to say nothing of
<a href="http://h71000.www7.hp.com/wizard/wiz_2637.html">DEC Alpha CPUs</a>)
can trip this code up.
For but one example, if the compiler were short of registers, it
might choose to refetch from <tt>gp</tt> rather than keeping
a separate copy in <tt>p</tt> as follows:

<blockquote>
<pre>
 1 bool do_something_gp_buggy_optimized(void)
 2 {
 3   rcu_read_lock();
 4   if (gp) { /* OPTIMIZATIONS GALORE!!! */
 5     do_something(gp-&gt;a, gp-&gt;b);
 6     rcu_read_unlock();
 7     return true;
 8   }
 9   rcu_read_unlock();
10   return false;
11 }
</pre>
</blockquote>

<p>
If this function ran concurrently with a series of updates that
replaced the current structure with a new one,
the fetches of <tt>gp-&gt;a</tt>
and <tt>gp-&gt;b</tt> might well come from two different structures,
which could cause serious confusion.
To prevent this (and much else besides), <tt>do_something_gp()</tt> uses
<tt>rcu_dereference()</tt> to fetch from <tt>gp</tt>:

<blockquote>
<pre>
 1 bool do_something_gp(void)
 2 {
 3   rcu_read_lock();
 4   p = rcu_dereference(gp);
 5   if (p) {
 6     do_something(p-&gt;a, p-&gt;b);
 7     rcu_read_unlock();
 8     return true;
 9   }
10   rcu_read_unlock();
11   return false;
12 }
</pre>
</blockquote>

<p>
The <tt>rcu_dereference()</tt> uses volatile casts and (for DEC Alpha)
memory barriers in the Linux kernel.
Should a
<a
href="http://www.rdrop.com/users/paulmck/RCU/consume.2015.07.13a.pdf">high-quality
implementation of C11 <tt>memory_order_consume</tt> [PDF]</a>
ever appear, then <tt>rcu_dereference()</tt> could be implemented
as a <tt>memory_order_consume</tt> load.
Regardless of the exact implementation, a pointer fetched by
<tt>rcu_dereference()</tt> may not be used outside of the
outermost RCU read-side critical section containing that
<tt>rcu_dereference()</tt>, unless protection of
the corresponding data element has been passed from RCU to some
other synchronization mechanism, most commonly locking or
<a href="https://www.kernel.org/doc/Documentation/RCU/rcuref.txt">reference counting</a>.

<p>
In short, updaters use <tt>rcu_assign_pointer()</tt> and readers
use <tt>rcu_dereference()</tt>, and these two RCU API elements
work together to ensure that readers have a consistent view of
newly added data elements.

<p>
Of course, it is also necessary to remove elements from RCU-protected
data structures, for example, using the following process:

<ol class="spacylist">
<li>	Remove the data element from the enclosing structure.
<li>	Wait for all pre-existing RCU read-side critical sections
	to complete (because only pre-existing readers can possibly have
	a reference to the newly removed data element).
<li>	At this point, only the updater has a reference to the
	newly removed data element, so it can safely reclaim
	the data element, for example, by passing it to <tt>kfree()</tt>.
</ol>

This process is implemented by <tt>remove_gp_synchronous()</tt>:

<blockquote>
<pre>
 1 bool remove_gp_synchronous(void)
 2 {
 3   struct foo *p;
 4 
 5   spin_lock(&amp;gp_lock);
 6   p = rcu_access_pointer(gp);
 7   if (!p) {
 8     spin_unlock(&amp;gp_lock);
 9     return false;
10   }
11   rcu_assign_pointer(gp, NULL);
12   spin_unlock(&amp;gp_lock);
13   synchronize_rcu();
14   kfree(p);
15   return true;
16 }
</pre>
</blockquote>

<p>
This function is straightforward, with line&nbsp;13 waiting for a grace
period before line&nbsp;14 frees the old data element.
This waiting ensures that readers will reach line&nbsp;7 of
<tt>do_something_gp()</tt> before the data element referenced by
<tt>p</tt> is freed.
The <tt>rcu_access_pointer()</tt> on line&nbsp;6 is similar to
<tt>rcu_dereference()</tt>, except that:

<div class="tlr">
<a name="Quick Quiz 4"><b>Quick Quiz 4</b>:</a>
Without the <tt>rcu_dereference()</tt> or the
<tt>rcu_access_pointer()</tt>, what destructive optimizations
might the compiler make use of?
<br><a href="#qq4answer">Answer</a>
</div>
<ol class="spacylist">
<li>	The value returned by <tt>rcu_access_pointer()</tt>
	cannot be dereferenced.
	If you want to access the value pointed to as well as
	the pointer itself, use <tt>rcu_dereference()</tt>
	instead of <tt>rcu_access_pointer()</tt>.
<li>	The call to <tt>rcu_access_pointer()</tt> need not be
	protected.
	In contrast, <tt>rcu_dereference()</tt> must either be
	within an RCU read-side critical section or in a code
	segment where the pointer cannot change, for example, in
	code protected by the corresponding update-side lock.
</ol>

<p>
This simple linked-data-structure scenario clearly demonstrates the need
for RCU's stringent memory-ordering guarantees on systems with more than
one CPU:

<ol class="spacylist">

<li>
<div class="tlr">
<a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Given that multiple CPUs can start RCU read-side critical sections
at any time without any ordering whatsoever, how can RCU possibly tell whether
or not a given RCU read-side critical section starts before a
given instance of <tt>synchronize_rcu()</tt>?
<br><a href="#qq5answer">Answer</a>
</div>

	Each CPU that has an RCU read-side critical section that
	begins before <tt>synchronize_rcu()</tt> starts is
	guaranteed to execute a full memory barrier between the time
	that the RCU read-side critical section ends and the time that
	<tt>synchronize_rcu()</tt> returns.
	Without this guarantee, a pre-existing RCU read-side critical section
	might hold a reference to the newly removed <tt>struct foo</tt>
	after the <tt>kfree()</tt> on line&nbsp;14 of
	<tt>remove_gp_synchronous()</tt>.
<li>	Each CPU that has an RCU read-side critical section that ends
	after <tt>synchronize_rcu()</tt> returns is guaranteed
	to execute a full memory barrier between the time that
	<tt>synchronize_rcu()</tt> begins and the time that the RCU
	read-side critical section begins.
	Without this guarantee, a later RCU read-side critical section
	running after the <tt>kfree()</tt> on line&nbsp;14 of
	<tt>remove_gp_synchronous()</tt> might
	later run <tt>do_something_gp()</tt> and find the
	newly deleted <tt>struct foo</tt>.
<li>
<div class="tlr">
<a name="Quick Quiz 6"><b>Quick Quiz 6</b>:</a>
The first and second guarantees require unbelievably strict ordering!
Are all these memory barriers <i> really</i> required?
<br><a href="#qq6answer">Answer</a>
</div>
	If the task invoking <tt>synchronize_rcu()</tt> remains
	on a given CPU, then that CPU is guaranteed to execute a full
	memory barrier sometime during the execution of
	<tt>synchronize_rcu()</tt>.
	This guarantee ensures that the <tt>kfree()</tt> on
	line&nbsp;14 of <tt>remove_gp_synchronous()</tt> really does
	execute after the removal on line&nbsp;11.
<li>	If the task invoking <tt>synchronize_rcu()</tt> migrates
	among a group of CPUs during that invocation, then each of the
	CPUs in that group is guaranteed to execute a full memory barrier
	sometime during the execution of <tt>synchronize_rcu()</tt>.
	This guarantee also ensures that the <tt>kfree()</tt> on
	line&nbsp;14 of <tt>remove_gp_synchronous()</tt> really does
	execute after the removal on
	line&nbsp;11, but also in the case where the thread executing the
	<tt>synchronize_rcu()</tt> migrates in the meantime.
</ol>

<p>
In short, RCU's publish-subscribe guarantee is provided by the combination
of <tt>rcu_assign_pointer()</tt> and <tt>rcu_dereference()</tt>.
This guarantee allows data elements to be safely added to RCU-protected
linked data structures without disrupting RCU readers.
This guarantee can be used in combination with the grace-period
guarantee to also allow data elements to be removed from RCU-protected
linked data structures, again without disrupting RCU readers.

<p>
This guarantee was only partially premeditated.
DYNIX/ptx used an explicit memory barrier for publication, but had nothing
resembling <tt>rcu_dereference()</tt> for subscription, nor did it
have anything resembling the <tt>smp_read_barrier_depends()</tt>
that was later subsumed into <tt>rcu_dereference()</tt>.
The need for these operations made itself known quite suddenly at a
late-1990s meeting with the DEC Alpha architects, back in the days when
DEC was still a freestanding company.
It took the Alpha architects a good hour to convince me that any sort
of barrier would ever be needed, and it then took me a good <i>two</i> hours
to convince them that their documentation did not make this point clear.
More recent work with the C and C++ standards committees have provided
much education on tricks and traps from the compiler.
In short, compilers were much less tricky in the early 1990s, but in
2015, don't even think about omitting <tt>rcu_dereference()</tt>!

<h4><a name="RCU Primitives Guaranteed to Execute Unconditionally">RCU primitives guaranteed to execute unconditionally</a></h4>

<p>
The common-case RCU primitives are unconditional.
They are invoked, they do their job, and they return, with no possibility
of error and no need to retry.
This is a key RCU design philosophy.

<p>
However, this philosophy is pragmatic rather than pigheaded.
If someone comes up with a good justification for a particular conditional
RCU primitive, it might well be implemented and added.
After all, this guarantee was reverse-engineered, not premeditated.
The unconditional nature of the RCU primitives was initially an
accident of implementation, and later experience with synchronization
primitives with conditional primitives caused me to elevate this
accident to a guarantee.
Therefore, the justification for adding a conditional primitive to
RCU would need to be based on detailed and compelling use cases.

<h4><a name="Guaranteed Read-to-Write Upgrade">Guaranteed read-to-write upgrade</a></h4>

<p>
<div class="tlr">
<a name="Quick Quiz 7"><b>Quick Quiz 7</b>:</a>
But how does the upgrade-to-write operation exclude other readers?
<br><a href="#qq7answer">Answer</a>
</div>
As far as RCU is concerned, it is always possible to carry out an
update within an RCU read-side critical section.
For example, that RCU read-side critical section might search for
a given data element, and then might acquire the update-side
spinlock in order to update that element, all while remaining
in that RCU read-side critical section.
Of course, it is necessary to exit the RCU read-side critical section
before invoking <tt>synchronize_rcu()</tt>, however, this
inconvenience can be avoided through use of the
<tt>call_rcu()</tt> and <tt>kfree_rcu()</tt> API members
described later in this document.

<p>
This guarantee allows lookup code to be shared between read-side
and update-side code, and was premeditated, appearing in the earliest
DYNIX/ptx RCU documentation.

<h4><a name="Fundamental Non-Requirements">Fundamental non-requirements</a></h4>

<p>
RCU provides extremely lightweight readers, and its read-side guarantees,
though quite useful, are correspondingly lightweight.
It is therefore all too easy to assume that RCU is guaranteeing more
than it really is.
Of course, the list of things that RCU does not guarantee is infinitely
long, however, the following sections list a few non-guarantees that
have caused confusion.
Except where otherwise noted, these non-guarantees were premeditated.

<ol class="spacylist">
<li>	<a href="#Readers Impose Minimal Ordering">
	Readers Impose Minimal Ordering</a>
<li>	<a href="#Readers Do Not Exclude Updaters">
	Readers Do Not Exclude Updaters</a>
<li>	<a href="#Updaters Only Wait For Old Readers">
	Updaters Only Wait For Old Readers</a>
<li>	<a href="#Grace Periods Don't Partition Read-Side Critical Sections">
	Grace Periods Don't Partition Read-Side Critical Sections</a>
<li>	<a href="#Read-Side Critical Sections Don't Partition Grace Periods">
	Read-Side Critical Sections Don't Partition Grace Periods</a>
<li>	<a href="#Disabling Preemption Does Not Block Grace Periods">
	Disabling Preemption Does Not Block Grace Periods</a>
</ol>

<h4><a name="Readers Impose Minimal Ordering">Readers impose minimal ordering</a></h4>

<p>
Reader-side markers such as <tt>rcu_read_lock()</tt> and
<tt>rcu_read_unlock()</tt> provide absolutely no ordering guarantees
except through their interaction with the grace-period APIs such as
<tt>synchronize_rcu()</tt>.
To see this, consider the following pair of threads:

<blockquote>
<pre>
 1 void thread0(void)
 2 {
 3   rcu_read_lock();
 4   WRITE_ONCE(x, 1);
 5   rcu_read_unlock();
 6   rcu_read_lock();
 7   WRITE_ONCE(y, 1);
 8   rcu_read_unlock();
 9 }
10 
11 void thread1(void)
12 {
13   rcu_read_lock();
14   r1 = READ_ONCE(y);
15   rcu_read_unlock();
16   rcu_read_lock();
17   r2 = READ_ONCE(x);
18   rcu_read_unlock();
19 }
</pre>
</blockquote>

<p>
After <tt>thread0()</tt> and <tt>thread1()</tt> execute
concurrently, it is quite possible to have:
<p>
<pre>
    (r1 == 1 &amp;&amp; r2 == 0)
</pre>
<p>
<div class="tlr">
<a name="Quick Quiz 8"><b>Quick Quiz 8</b>:</a>
Can't the compiler also reorder this code?
<br><a href="#qq8answer">Answer</a>
</div>
(i.e. <tt>y</tt> appears to have been assigned before <tt>x</tt>)
which would not be possible if <tt>rcu_read_lock()</tt> and
<tt>rcu_read_unlock()</tt> had much in the way of ordering
properties.
But they do not, so the CPU is within its rights
to do significant reordering.
This is by design:  Any significant ordering constraints would slow down
these fast-path APIs.

<h4><a name="Readers Do Not Exclude Updaters">Readers do not exclude updaters</a></h4>

<p>
Neither <tt>rcu_read_lock()</tt> nor <tt>rcu_read_unlock()</tt>
exclude updates.
All they do is to prevent grace periods from ending.
The following example illustrates this:

<blockquote>
<pre>
 1 void thread0(void)
 2 {
 3   rcu_read_lock();
 4   r1 = READ_ONCE(y);
 5   if (r1) {
 6     do_something_with_nonzero_x();
 7     r2 = READ_ONCE(x);
 8     WARN_ON(!r2); /* BUG!!! */
 9   }
10   rcu_read_unlock();
11 }
12 
13 void thread1(void)
14 {
15   spin_lock(&amp;my_lock);
16   WRITE_ONCE(x, 1);
17   WRITE_ONCE(y, 1);
18   spin_unlock(&amp;my_lock);
19 }
</pre>
</blockquote>

<p>
If the <tt>thread0()</tt> function's <tt>rcu_read_lock()</tt>
excluded the <tt>thread1()</tt> function's update,
the <tt>WARN_ON()</tt> could never fire.
But the fact is that <tt>rcu_read_lock()</tt> does not exclude
much of anything aside from subsequent grace periods, of which
<tt>thread1()</tt> has none, so the
<tt>WARN_ON()</tt> can and does fire.

<h4><a name="Updaters Only Wait For Old Readers">Updaters only wait for old readers</a></h4>

<p>
<div class="tlr">
<a name="Quick Quiz 9"><b>Quick Quiz 9</b>:</a>
Suppose that synchronize_rcu() did wait until all readers had completed.
Would the updater be able to rely on this?
<br><a href="#qq9answer">Answer</a>
</div>
It might be tempting to assume that after <tt>synchronize_rcu()</tt>
completes, there are no readers executing.
This temptation must be avoided because
new readers can start immediately after <tt>synchronize_rcu()</tt>
starts, and <tt>synchronize_rcu()</tt> is under no
obligation to wait for these new readers.

<h4><a name="Grace Periods Don't Partition Read-Side Critical Sections">
Grace periods don't partition read-side critical sections</a></h4>

<p>
One might assume that if any part of one RCU read-side critical
section precedes a given grace period, and if any part of another RCU
read-side critical section follows that same grace period, then all of
the first RCU read-side critical section must precede all of the second.
However, this just isn't the case: a single grace period does not
partition the set of RCU read-side critical sections.
An example of this situation can be illustrated as follows, where
<tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are initially all zero:

<blockquote>
<pre>
 1 void thread0(void)
 2 {
 3   rcu_read_lock();
 4   WRITE_ONCE(a, 1);
 5   WRITE_ONCE(b, 1);
 6   rcu_read_unlock();
 7 }
 8 
 9 void thread1(void)
10 {
11   r1 = READ_ONCE(a);
12   synchronize_rcu();
13   WRITE_ONCE(c, 1);
14 }
15 
16 void thread2(void)
17 {
18   rcu_read_lock();
19   r2 = READ_ONCE(b);
20   r3 = READ_ONCE(c);
21   rcu_read_unlock();
22 }
</pre>
</blockquote>

<p>
It turns out that the outcome:
<p>
<pre>
    (r1 == 1 &amp;&amp; r2 == 0 &amp;&amp; r3 == 1)
</pre>
<p>
is entirely possible.
The following figure show how this can happen, with each circled
<tt>QS</tt> indicating the point at which RCU recorded a
<i>quiescent state</i> for each thread, that is, a state in which
RCU knows that the thread cannot be in the midst of an RCU read-side
critical section that started before the current grace period:

<blockquote>
<img src="https://static.lwn.net/images/2015/rcu/GPpartitionReaders1.png"
alt="GPpartitionReaders1.png" class="photo">
</blockquote>

<p>
If it is necessary to partition RCU read-side critical sections in this
manner, it is necessary to use two grace periods, where the first
grace period is known to end before the second grace period starts:

<blockquote>
<pre>
 1 void thread0(void)
 2 {
 3   rcu_read_lock();
 4   WRITE_ONCE(a, 1);
 5   WRITE_ONCE(b, 1);
 6   rcu_read_unlock();
 7 }
 8 
 9 void thread1(void)
10 {
11   r1 = READ_ONCE(a);
12   synchronize_rcu();
13   WRITE_ONCE(c, 1);
14 }
15 
16 void thread2(void)
17 {
18   r2 = READ_ONCE(c);
19   synchronize_rcu();
20   WRITE_ONCE(d, 1);
21 }
22 
23 void thread3(void)
24 {
25   rcu_read_lock();
26   r3 = READ_ONCE(b);
27   r4 = READ_ONCE(d);
28   rcu_read_unlock();
29 }
</pre>
</blockquote>

<p>
Here, if <tt>(r1 == 1)</tt>, then
<tt>thread0()</tt>'s write to <tt>b</tt> must happen
before the end of <tt>thread1()</tt>'s grace period.
If in addition <tt>(r4&nbsp;==&nbsp;1)</tt>, then
<tt>thread3()</tt>'s read from <tt>b</tt> must happen
after the beginning of <tt>thread2()</tt>'s grace period.
If it is also the case that <tt>(r2 == 1)</tt>, then the
end of <tt>thread1()</tt>'s grace period must precede the
beginning of <tt>thread2()</tt>'s grace period.
This means that the two RCU read-side critical sections cannot overlap,
guaranteeing that <tt>(r3 == 1)</tt>.
As a result, the outcome:
<p>
<pre>
    (r1 == 1 &amp;&amp; r2 == 1 &amp;&amp; r3 == 0 &amp;&amp; r4 == 1)
</pre>
<p>
cannot happen.

<p>
This non-requirement was also non-premeditated, but became apparent
when studying RCU's interaction with memory ordering.

<h4><a name="Read-Side Critical Sections Don't Partition Grace Periods">
Read-side critical sections don't partition grace periods</a></h4>

<p>
It is also tempting to assume that if an RCU read-side critical section
happens between a pair of grace periods, then those grace periods cannot
overlap.
However, this temptation leads nowhere good, as can be illustrated by
the following, with all variables initially zero:

<blockquote>
<pre>
 1 void thread0(void)
 2 {
 3   rcu_read_lock();
 4   WRITE_ONCE(a, 1);
 5   WRITE_ONCE(b, 1);
 6   rcu_read_unlock();
 7 }
 8 
 9 void thread1(void)
10 {
11   r1 = READ_ONCE(a);
12   synchronize_rcu();
13   WRITE_ONCE(c, 1);
14 }
15 
16 void thread2(void)
17 {
18   rcu_read_lock();
19   WRITE_ONCE(d, 1);
20   r2 = READ_ONCE(c);
21   rcu_read_unlock();
22 }
23 
24 void thread3(void)
25 {
26   r3 = READ_ONCE(d);
27   synchronize_rcu();
28   WRITE_ONCE(e, 1);
29 }
30 
31 void thread4(void)
32 {
33   rcu_read_lock();
34   r4 = READ_ONCE(b);
35   r5 = READ_ONCE(e);
36   rcu_read_unlock();
37 }
</pre>
</blockquote>

<p>
In this case, the outcome:
<p>
<pre>
    (r1 == 1 &amp;&amp; r2 == 1 &amp;&amp; r3 == 1 &amp;&amp; r4 == 0 &amp;&amp; r5 == 1)
</pre>
<p>
is entirely possible, as illustrated below:

<p>
<blockquote>
<img src="https://static.lwn.net/images/2015/rcu/ReadersPartitionGP1.png" class="photo"
alt="ReadersPartitionGP1.svg"> 
</blockquote>
<p>
<div class="tlrw">
<a name="Quick Quiz 10"><b>Quick Quiz 10</b>:</a>
How long a sequence of grace periods, each separated by an RCU read-side
critical section, would be required to partition the RCU read-side
critical sections at the beginning and end of the chain?
<br><a href="#qq10answer">Answer</a>
</div>
Again, an RCU read-side critical section can overlap almost all of a
given grace period, just so long as it does not overlap the entire
grace period.
As a result, an RCU read-side critical section cannot partition a pair
of RCU grace periods.

<h4><a name="Disabling Preemption Does Not Block Grace Periods">
Disabling preemption does not block grace periods</a></h4>

<p>
There was a time when disabling preemption on any given CPU would block
subsequent grace periods.
However, this was an accident of implementation and is not a requirement.
And in the current Linux-kernel implementation, disabling preemption
on a given CPU in fact does not block grace periods, as Oleg Nesterov
<a href="http://marc.info/?l=linux-kernel&amp;m=143431078202914&amp;w=2">demonstrated</a>.

<p>
If you need a preempt-disable region to block grace periods, you need to add
<tt>rcu_read_lock()</tt> and <tt>rcu_read_unlock()</tt>, for example
as follows:

<blockquote>
<pre>
 1 preempt_disable();
 2 rcu_read_lock();
 3 do_something();
 4 rcu_read_unlock();
 5 preempt_enable();
 6 
 7 /* Spinlocks implicitly disable preemption. */
 8 spin_lock(&amp;mylock);
 9 rcu_read_lock();
10 do_something();
11 rcu_read_unlock();
12 spin_unlock(&amp;mylock);
</pre>
</blockquote>

<p>
In theory, you could enter the RCU read-side critical section first,
but it is more efficient to keep the entire RCU read-side critical
section contained in the preempt-disable region as shown above.
Of course, RCU read-side critical sections that extend outside of
preempt-disable regions will work correctly, but such critical sections
can be preempted, which forces <tt>rcu_read_unlock()</tt> to do
more work.
And no, this is <i>not</i> an invitation to enclose all of your RCU
read-side critical sections within preempt-disable regions, because
doing so would degrade realtime response.

<p>
This non-requirement appeared with preemptible RCU.
If you need a grace period that waits on non-preemptible code regions, use
<a href="#Sched Flavor">RCU-sched</a>.

<p>
Here ends part 1; the remaining two parts will be published in the coming
weeks. 
<p>
<h4><a name="Answers to Quick Quizzes">
Answers to quick quizzes</a></h4>

<a name="qq1answer"></a>
<p><b>Quick Quiz 1</b>:
Wait a minute!
You said that updaters can make useful forward progress concurrently
with readers, but pre-existing readers will block
<tt>synchronize_rcu()</tt>!!!
Just who are you trying to fool???


</p><p><b>Answer</b>:
First, if updaters do not wish to be blocked by readers, they can use
<tt>call_rcu()</tt> or <tt>kfree_rcu()</tt>, which will
be discussed later.
Second, even when using <tt>synchronize_rcu()</tt>, the other
update-side code does run concurrently with readers, whether pre-existing
or not.


</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

<a name="qq2answer"></a>
<p><b>Quick Quiz 2</b>:
Why is the <tt>synchronize_rcu()</tt> on line&nbsp;28 needed?


</p><p><b>Answer</b>:
Without that extra grace period, memory reordering could result in
<tt>do_something_dlm()</tt> executing <tt>do_something()</tt>
concurrently with the last bits of <tt>recovery()</tt>.


</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

<a name="qq3answer"></a>
<p><b>Quick Quiz 3</b>:
But <tt>rcu_assign_pointer()</tt> does nothing to prevent the
two assignments to <tt>p-&gt;a</tt> and <tt>p-&gt;b</tt>
from being reordered.
Can't that also cause problems?


</p><p><b>Answer</b>:
No, it cannot.
The readers cannot see either of these two fields until
the assignment to <tt>gp</tt>, by which time both fields are
fully initialized.
So reordering the assignments
to <tt>p-&gt;a</tt> and <tt>p-&gt;b</tt> cannot possibly
cause any problems.


</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

<a name="qq4answer"></a>
<p><b>Quick Quiz 4</b>:
Without the <tt>rcu_dereference()</tt> or the
<tt>rcu_access_pointer()</tt>, what destructive optimizations
might the compiler make use of?


</p><p><b>Answer</b>:
Let's start with what happens to <tt>do_something_gp()</tt>
if it fails to use <tt>rcu_dereference()</tt>.
It could reuse a value formerly fetched from this same pointer.
It could also fetch the pointer from <tt>gp</tt> in a byte-at-a-time
manner, resulting in <i>load tearing</i>, in turn resulting in a bytewise
mash-up of two distinct pointer values.
It might even use value-speculation optimizations, where it makes a wrong
guess, but by the time it gets around to checking the value, an update
has changed the pointer to match the wrong guess.
Too bad about any dereferences that returned pre-initialization garbage
in the meantime!

<p>
For <tt>remove_gp_synchronous()</tt>, as long as all modifications
to <tt>gp</tt> are carried out while holding <tt>gp_lock</tt>,
the above optimizations are harmless.
However,
with <tt>CONFIG_SPARSE_RCU_POINTER=y</tt>,
<tt>sparse</tt> will complain if you
define <tt>gp</tt> with <tt>__rcu</tt> and then
access it without using
either <tt>rcu_access_pointer()</tt> or <tt>rcu_dereference()</tt>.


</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>

<a name="qq5answer"></a>
<p><b>Quick Quiz 5</b>:
Given that multiple CPUs can start RCU read-side critical sections
at any time without any ordering whatsoever, how can RCU possibly tell whether
or not a given RCU read-side critical section starts before a
given instance of <tt>synchronize_rcu()</tt>?


</p><p><b>Answer</b>:
If RCU cannot tell whether or not a given
RCU read-side critical section starts before a
given instance of <tt>synchronize_rcu()</tt>,
then it must assume that the RCU read-side critical section
started first.
In other words, a given instance of <tt>synchronize_rcu()</tt>
can avoid waiting on a given RCU read-side critical section only
if it can prove that <tt>synchronize_rcu()</tt> started first.


</p><p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a>

<a name="qq6answer"></a>
<p><b>Quick Quiz 6</b>:
The first and second guarantees require unbelievably strict ordering!
Are all these memory barriers <i> really</i> required?


</p><p><b>Answer</b>:
Yes, they really are required.
To see why the first guarantee is required, consider the following
sequence of events:

<ol>
<li>	CPU 1: <tt>rcu_read_lock()</tt>
<li>	CPU 1: <tt>q = rcu_dereference(gp);
	/* Very likely to return p. */</tt>
<li>	CPU 0: <tt>list_del_rcu(p);</tt>
<li>	CPU 0: <tt>synchronize_rcu()</tt> starts.
<li>	CPU 1: <tt>do_something_with(q-&gt;a);
	/* No smp_mb(), so might happen after kfree(). */</tt>
<li>	CPU 1: <tt>rcu_read_unlock()</tt>
<li>	CPU 0: <tt>synchronize_rcu()</tt> returns.
<li>	CPU 0: <tt>kfree(p);</tt>
</ol>

<p>
Therefore, there absolutely must be a full memory barrier between the
end of the RCU read-side critical section and the end of the
grace period.

<p>
The sequence of events demonstrating the necessity of the second rule
is roughly similar:

<ol>
<li>	CPU 0: <tt>list_del_rcu(p);</tt>
<li>	CPU 0: <tt>synchronize_rcu()</tt> starts.
<li>	CPU 1: <tt>rcu_read_lock()</tt>
<li>	CPU 1: <tt>q = rcu_dereference(gp);
	/* Might return p if no memory barrier. */</tt>
<li>	CPU 0: <tt>synchronize_rcu()</tt> returns.
<li>	CPU 0: <tt>kfree(p);</tt>
<li>	CPU 1: <tt>do_something_with(q-&gt;a); /* Boom!!! */</tt>
<li>	CPU 1: <tt>rcu_read_unlock()</tt>
</ol>

<p>
And similarly, without a memory barrier between the beginning of the
grace period and the beginning of the RCU read-side critical section,
CPU&nbsp;1 might end up accessing the freelist.

<p>
The &ldquo;as if&rdquo; rule of course applies, so that any implementation
that acts as if the appropriate memory barriers were in place is a
correct implementation.
That said, it is much easier to fool yourself into believing that you have
adhered to the as-if rule than it is to actually adhere to it!


</p><p><a href="#Quick%20Quiz%206"><b>Back to Quick Quiz 6</b>.</a>

<a name="qq7answer"></a>
<p><b>Quick Quiz 7</b>:
But how does the upgrade-to-write operation exclude other readers?


</p><p><b>Answer</b>:
It doesn't, just like normal RCU updates, which also do not exclude
RCU readers.


</p><p><a href="#Quick%20Quiz%207"><b>Back to Quick Quiz 7</b>.</a>

<a name="qq8answer"></a>
<p><b>Quick Quiz 8</b>:
Can't the compiler also reorder this code?


</p><p><b>Answer</b>:
No, the volatile casts in <tt>READ_ONCE()</tt> and
<tt>WRITE_ONCE()</tt> prevent reordering in this particular case.


</p><p><a href="#Quick%20Quiz%208"><b>Back to Quick Quiz 8</b>.</a>

<a name="qq9answer"></a>
<p><b>Quick Quiz 9</b>:
Suppose that synchronize_rcu() did wait until all readers had completed.
Would the updater be able to rely on this?


</p><p><b>Answer</b>:
No.
Even if <tt>synchronize_rcu()</tt> were to wait until
all readers had completed, a new reader might start immediately after
<tt>synchronize_rcu()</tt> completed.
Therefore, the code following
<tt>synchronize_rcu()</tt> cannot rely on there being no readers
in any case.


</p><p><a href="#Quick%20Quiz%209"><b>Back to Quick Quiz 9</b>.</a>

<a name="qq10answer"></a>
<p><b>Quick Quiz 10</b>:
How long a sequence of grace periods, each separated by an RCU read-side
critical section, would be required to partition the RCU read-side
critical sections at the beginning and end of the chain?


</p><p><b>Answer</b>:
In theory, an infinite number.
In practice, an unknown number that is sensitive to both implementation
details and timing considerations.
Therefore, even in practice, RCU users must abide by the theoretical rather
than the practical answer.


</p><p><a href="#Quick%20Quiz%2010"><b>Back to Quick Quiz 10</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/652156/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor653023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2015 13:00 UTC (Fri)
                               by <b>prauld</b> (subscriber, #39414)
                              [<a href="/Articles/653023/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very nice! Thanks Paul. A little brain exercise for the morning...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/653023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor653068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2015 15:06 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/653068/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Glad you like it.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/653068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor655850"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2015 18:01 UTC (Thu)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/655850/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In QQ2, why is STATE_WANT_NORMAL needed? Is it just something in do_something_carefully() that we don't see, am I missing something? Similarly STATE_RECOVERING actually.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/655850/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor655865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2015 18:58 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/655865/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is indeed quite possible that do_something() and do_something_carefully() could be written so that they didn't need STATE_WANT_NORMAL and STATE_RECOVERING.  If it were me, I would still keep those two states for debugging purposes, though.<br>
<p>
That said, even without those additional states (or better, especially without those additional states), the synchronize_rcu() on line 28 is absolutely essential.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/655865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor656230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2015 18:32 UTC (Mon)
                               by <b>mkatiyar</b> (guest, #75286)
                              [<a href="/Articles/656230/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 Hi Paul,<br>
<p>
Had a question on compiler optimizations. If we ignore 'p' being freed for a moment and assume only additions are happening to the list, is the following code still wrong and compiler can replace 'p' with 'gp' due to registers refetch ?<br>
<p>
 1 bool do_something_gp_buggy(void)<br>
 2 {<br>
 3   rcu_read_lock();<br>
 4   p = gp;  /* OPTIMIZATIONS GALORE!!! */<br>
 5   rcu_read_unlock();<br>
 6   if (p) {<br>
 7     do_something(p-&gt;a, p-&gt;b);<br>
 8     return true;<br>
 9   }<br>
 11   return false;<br>
 12 }<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/656230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor656233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2015 20:19 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/656233/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Yes, even in the absence of freeing, that code is still likely buggy.  The compiler can replace all instances of "p" with "gp", resulting in the following:

<pre>
 1 bool do_something_gp_buggy(void)
 2 {
 3   rcu_read_lock();
 4   /* p = gp; optimized out. */
 5   rcu_read_unlock();
 6   if (gp) {
 7     do_something(gp-&gt;a, gp-&gt;b);
 8     return true;
 9   }
11   return false;
12 }
</pre>

Then we can have the following sequence of events:

<ol>
<li>  Someone inserts a structure with field "a" equal to 1729 and "b" equal to 34.
<li>  The above code executes through line 6, then fetches gp-&gt;a, getting 1729.
<li>  Someone inserts a structure with field "a" equal to 78 and "b" equal to 65535.
<li>  The above code continues executing, invoking do_something(1729, 65535).  But there never was an element with these values of "a" and "b", which might well fatally confuse do_something().
</ol>

This is in addition to the failures that can occur on DEC Alpha.

So you really do need the rcu_dereference() in this case.  And in almost all other cases, as well.
      
          <div class="CommentReplyButton">
            <form action="/Articles/656233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor656327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2015 4:06 UTC (Wed)
                               by <b>mkatiyar</b> (guest, #75286)
                              [<a href="/Articles/656327/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks a lot for your reply ! I was hoping that the rcu_read_unlock() would create some barrier for the compiler to not optimize across it, but good to know that no assumptions can be made.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/656327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor656343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requirements for RCU part 1: the fundamentals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2015 7:12 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/656343/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is an implementation choice.  Some implementations, for example, Linux-kernel SRCU, do have barriers in the read-side markers, but as you say, in general you cannot rely on this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/656343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
