        <!DOCTYPE html>
        <html lang="en">
        <head><title>Uniting the Linux random-number devices [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/884875/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/884383/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/884875/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Uniting the Linux random-number devices</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jake Edge</b><br>February 16, 2022</br>
           </div>
<p>
Blocking in the kernel's random-number generator (RNG)—causing a process to
wait for "enough"
entropy to generate strong random numbers—has always been controversial.  It has also led to
various kinds of problems over the years, from timeouts and delays caused
by misuse in user-space
programs to deadlocks and other problems in the boot
process.  That behavior has undergone a number of changes over the last few
years and it looks possible that the last vestige of the difference between
merely "good" and "cryptographic-strength" random numbers may go away in some
upcoming kernel version.
</p>

<h4>Random history</h4>

<p>
The history of the kernel RNG is long and somewhat twisty; there are two
random-number devices in the kernel, <tt>/dev/random</tt> and 
<tt>/dev/urandom</tt>, that can be read in order to obtain the random
data.  <tt>/dev/urandom</tt> was always meant as the device for nearly
everything to use, as it does not block; it simply provides the best random
numbers that the kernel can provide
at the time it is read.
<tt>/dev/random</tt>, on the other hand, blocks 
whenever it does not have sufficient entropy to provide cryptographic-strength random
numbers.  That entropy comes from
sources like interrupt timing for various kinds of devices (e.g. disk,
keyboard, network) and hardware RNGs if they are available. 
<tt>/dev/urandom</tt> will log a warning message (once) if it is called before its
pool is initialized (from the <tt>random</tt> pool once it has been
initialized using gathered entropy), but it will provide output from its 
pseudorandom-number generator (PRNG) and never block.
</p>

<p>
In 2014, for Linux&nbsp;3.17, the <a
href="https://man7.org/linux/man-pages/man2/getrandom.2.html"><tt>getrandom()</tt></a>
system call was added <a href="/Articles/606141/">to provide a reliable
way</a> for user-space applications to 
request random numbers even in the face of file-descriptor exhaustion or
lack of access to the random devices (as might happen for an application
running in a container).
<tt>getrandom()</tt> was designed to use the <tt>urandom</tt> <i>pool</i>, but
only after it has been fully initialized from the <tt>random</tt> pool.
So, while reads to <tt>/dev/urandom</tt> do not block, calls to
<tt>getrandom()</tt> would until the requisite entropy is gathered.
<tt>getrandom()</tt> callers can choose to use the <tt>random</tt> pool via a flag, which makes
the call subject to the full entropy requirements for data coming from that pool.
</p>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
In 2019, an unrelated change to the ext4 filesystem <a
href="/Articles/800509/">led to systems that would not boot</a> because it
reduced the number of interrupts being generated, so the <tt>urandom</tt>
pool did not get initialized and calls to <tt>getrandom()</tt> blocked.
Since those calls were made early in the boot process, the system never
came up to a point where enough entropy could be gathered, because the boot
process was waiting for <tt>getrandom()</tt> to return—thus a deadlock
resulted. 
The ext4 change was temporarily reverted for the&nbsp;5.3 kernel and a <a
href="/Articles/802360/">more permanent solution</a> was added by Linus
Torvalds for&nbsp;5.4.  It used <a
href="/Articles/642166/">CPU execution time jitter</a> as a source of
entropy to ensure that the <tt>random</tt> pool initialized within a
second or so.  That technique is somewhat controversial, even Torvalds is
somewhat skeptical of it, but it has been in place, and working as far as
anyone can tell, for several years now.
</p>

<p>
In 2020, the blocking nature of <tt>/dev/random</tt>  was <a
href="/Articles/808575/">changed</a> to behave like  <tt>getrandom()</tt>,
in that it would only block until it is initialized, once, and then 
would provide cryptographic-strength random numbers thereafter.  Andy Lutomirski, who
contributed the patches for that change, said: "<q>Linux's CRNG
generates output that is good enough to use even for key generation. The
blocking pool is not stronger in any material way, and keeping it around
requires a lot of infrastructure of dubious value.</q>"  Those patches
also added a <tt>GRND_INSECURE</tt> flag for <tt>getrandom()</tt> that
would return "best effort" random numbers even if the pool was not yet
initialized.
</p>

<p>
As can be seen, the lines between the two devices have become rather
blurrier over time. More of the history of the kernel RNG, going even
further back in time, can be found in
this <a href="/Kernel/Index/#Random_numbers">LWN kernel index
entry</a>.  Given that the two devices have grown together, it is perhaps
no surprise that a new proposal, to effectively eliminate the distinction,
has been raised.
</p>

<h4>No random blocking (for long)</h4>

<p>
Jason A. Donenfeld, who <a
href="/ml/linux-kernel/20211130184315.258150-1-Jason@zx2c4.com/">stepped up
as a co-maintainer</a> of the kernel's RNG subsystem a few months back, has
been rather active in doing cleanups and making other changes to that code
of late.  On February&nbsp;11, he <a
href="/ml/linux-kernel/20220211210757.612595-1-Jason@zx2c4.com/">posted</a>
an RFC—perhaps a "<q>request for
grumbles</q>" in truth—patch proposing the removal of the ability for
<tt>/dev/urandom</tt> to return data before the pool is initialized.  It would mean that
the kernel RNG subsystem would always block waiting to initialize, but always return
cryptographic-strength random numbers thereafter (unless the
<tt>GRND_INSECURE</tt> flag to <tt>getrandom()</tt> is used).  Because of
the changes made by Torvalds 
in&nbsp;5.4, which Donenfeld calls the "<q>Linus Jitter
Dance</q>", the maximum wait for initialization is minimal, so Donenfeld
suggested the change:
<blockquote class="bq">
So, given that the kernel has grown this mechanism for seeding itself
from nothing, and that this procedure happens pretty fast, maybe there's
no point any longer in having /dev/urandom give insecure bytes. In the
past we didn't want the boot process to deadlock, which was
understandable. But now, in the worst case, a second goes by, and the
problem is resolved. It seems like maybe we're finally at a point when
we can get rid of the infamous "urandom read hole".
</blockquote>
</p>

<p>
There are some potential hurdles to doing so, however.  The jitter entropy
technique relies on differences in timing when running the same code, which
requires both a high-resolution CPU cycle counter and a CPU that appears to be
nondeterministic (due to caching, instruction reordering, speculation, and
so on).  There are some architectures that do not provide that, however, so
no entropy can be gathered that way.  Donenfeld noted that non-Amiga m68k
systems, two MIPS models (R6000 and R6000A), and, possibly, RISC-V would be
affected; he wondered if there were other similarly affected architectures out there.
He believes that the RISC-V code is not truly a problem, however, and no one
has yet spoken up to dispute that.
Meanwhile, setting those others aside might be the right approach:
<blockquote class="bq">
If my general analysis is correct, are these ancient platforms really
worth holding this back? I halfway expect to receive a few thrown
tomatoes, an angry fist, and a "get off my lawn!", and if that's _all_ I
hear, I'll take a hint and we can forget I ever proposed this. As
mentioned, I do not intend to merge this unless there's broad consensus
about it. But on the off chance that people feel differently, perhaps
the Linus Jitter Dance is finally the solution to years of /dev/urandom
kvetching.
</blockquote>
</p>

<p>
The proposed patch was fairly small; it simply eliminated the
<tt>file_operations</tt> struct for <tt>/dev/urandom</tt> and reused the
one for <tt>/dev/random</tt> in its place, thus making the two devices
behave identically.  It also shorted out the
behavior of the <tt>GRND_INSECURE</tt> flag, but he later <a
href="/ml/linux-kernel/CAHmME9pkhqjLtwn2kt5SkSWBQ9UW+2WLGL9momZUmY3L2wDryQ@mail.gmail.com/">said</a>
that was something of a distraction.  The main intent of his proposal was
to do the following:
<blockquote class="bq">
Right now, we have:
<pre>
/dev/random = getrandom(0)
/dev/urandom = getrandom(GRND_INSECURE)
</pre>
This proposal is to make that:
<pre>
/dev/random = getrandom(0)
/dev/urandom = getrandom(0)
</pre>
</blockquote>
</p>

<p>
Torvalds had a <a
href="/ml/linux-kernel/CAHk-=wh+2jokbr4tpHA=ExebWKr=qp9RJ_uFrG2gYG4ChAjitg@mail.gmail.com/">positive
response</a>
to the RFC.  He said that the patch makes sense for architectures that have
a cycle counter; the jitter entropy change has been active for
two-and-a-half years without much complaint, so "<q>I think we can call
that thing a success</q>".  There may have been a few complaints about it,
but: "<q>Honestly, I think all the complaints would have been from the
theoretical posers that don't have any practical suggestions
anyway</q>".   Torvalds is known to have little patience for <a
href="/Articles/828705/">theoretical concerns about cryptography</a> (or
theoretical concerns about anything else, in truth). 
</p>

<p>
He did object to removing <tt>GRND_INSECURE</tt> for architectures that
cannot do the jitter dance, since it is a way for user space to work around
the lack of boot-time entropy, even if it is not at all secure:
<blockquote class="bq">
Those systems are arguably broken from a randomness standpoint - what
the h*ll are you supposed to do if there's nothing generating entropy
- but broken or not, I suspect they still exists. Those horrendous
MIPS things were quite common in embedded networking (routers, access
points - places that *should* care)
<p> [...] And almost nobody tests those broken platforms: even people who build
new kernels for those embedded networking things probably end up using
said kernels with an existing user space setup - where people have
some existing saved source of pseudo-entropy. So they might not ever
even trigger the "first boot problem" that tends to be the worst case.
</blockquote>
</p>

<p>
But, he said, he would be willing to apply the patch: "<q>at some point 'worry
about broken platforms' ends up being too weak an excuse not to just
apply it</q>". <a href="/ml/linux-kernel/fcab986b-d0bd-c798-de17-266abcdc7da2@gentoo.org/">According to Joshua Kinard</a>, the two MIPS models in
question were from the 1980s, not ever used in systems, and the kernel test
for them in the random code "<q>was probably added as a mental exercise following a
processor manual or such</q>".  Maciej W. Rozycki <a
href="/ml/linux-kernel/alpine.DEB.2.21.2202122309560.34636@angie.orcam.me.uk/">said</a>
that there may have been a few systems using those models, but no Linux
port was ever made for them.  That might mean that the only problem systems
are "<q>some m68k
museum pieces</q>", Donenfeld <a
href="/ml/linux-kernel/CAHmME9ooEbgiv3DRk87ei+rUoVNMJthY7UuG_xCgm=kfMZAajw@mail.gmail.com/">said</a>. 
</p>

<p>
As Geert Uytterhoeven <a
href="/ml/linux-kernel/CAMuHMdXDj+BVCs4Syg39vjnHGKcwJnCgDxrGoOiEFM_T4ojwPg@mail.gmail.com/">pointed
out</a>, though, the cycle-counter code for the Linux generic architecture,
which is the default and starting point for new architectures, is hardwired
to return zero. "<q>Several architectures do not implement get_cycles(), or implement it
with a variant that's very similar or identical to the generic
version.</q>"  David Laight <a
href="/ml/linux-kernel/63afd299c8df4495b27456a7f92aec75@AcuMS.aculab.com/">added</a>
a few examples (old x86, nios2) of architectures where that is the case. 
</p>

<h4>But what about my NetHack machine?</h4>

<p>
Lutomirski had a more prosaic <a
href="/ml/linux-kernel/fbdd43e1-a305-48d1-8ccb-2deffcb715f7@www.fastmail.com/">complaint</a>:
<blockquote class="bq">
I dislike this patch for a reason that has nothing to do with
security. Somewhere there’s a Linux machine that boots straight to Nethack
in a glorious 50ms.  If Nethack gets 256 bits of amazing entropy from
/dev/urandom, then the machine’s owner has to play for real. If it repeats
the same game on occasion, the owner can be disappointed or amused. If it
gets a weak seed that can be brute forced, then the owner can have fun
brute forcing it.
<p>
If, on the other hand, it waits 750ms for enough jitter entropy to be
perfect, it’s a complete fail.  No one wants to wait 750ms to play
Nethack. 
</blockquote>
</p>

<p>
More seriously, he was concerned about devices like backup cameras or
light bulbs that need to boot "immediately", and where the quality of the
random numbers may not truly be a problem.  The <tt>GRND_INSECURE</tt>
escape hatch is there for just that reason.  In a similar vein, Lennart
Poettering was <a
href="/ml/linux-kernel/YgoYnX97imub7KEB@gardel-login/">worried</a> that
systemd would have to wait one second to get a seed for its hash tables,
when it already has a mechanism to reseed the tables:
<blockquote class="bq">
So, systemd uses (potentially half-initialized) /dev/urandom for
seeding its hash tables. For that its kinda OK if the random values
have low entropy initially, as we'll automatically reseed when too
many hash collisions happen, and then use a newer (and thus hopefully
better) seed, again acquired through /dev/urandom. i.e. if the seeds
are initially not good enough to thwart hash collision attacks, once
the hash table are actually attacked we'll replace the seeds with
[something] better. For that all we need is that the random pool
eventually gets better, that's all.
</blockquote>
</p>

<p>
It turns out that systemd is <a
href="/ml/linux-kernel/Ygps2W6MfxKkP5eD@gardel-login/">already using
<tt>GRND_INSECURE</tt></a> on systems where it is available, so not
changing that behavior, as was originally proposed, would neatly fix Poettering's
concern.  Donenfeld was completely amenable to <a
href="/ml/linux-kernel/YgpjfncV+C9FEZDc@zx2c4.com/">pulling the disabling of
<tt>GRND_INSECURE</tt></a> from his patch; it is not really his
primary focus with the proposal, as noted.
</p>

<p>
Based on Torvalds's response, it would seem there are no huge barriers to
removing the final distinction between <tt>/dev/random</tt> and
<tt>/dev/urandom</tt>—other than the names, of course. If there are more
architectures that cannot use the jitter technique, though, that
distinction may live on, since Torvalds also thought there might be value
in keeping "<q>the stupid stuff around as a 'doesn't hurt good platforms, might
help broken ones'</q>".  The code removal would not be huge, so it does
not really provide much of a code simplification, Donenfeld said; it is
more a matter of being able to eliminate the endless debate about
which source of randomness to use on Linux.  To that end, it seems like a
worthwhile goal.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Random_number_generation">Linux kernel/Random number generation</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/884875/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor885184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the nethack random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2022 16:30 UTC (Thu)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/885184/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The irony is that nethack internal RNG is very weak so is easy to bruteforce even if the kernel RNG was perfect.<br>
&lt;<a href="https://nethackwiki.com/wiki/Random_number_generator">https://nethackwiki.com/wiki/Random_number_generator</a>&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885229"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the nethack random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2022 1:33 UTC (Fri)
                               by <b>qys</b> (guest, #156455)
                              [<a href="/Articles/885229/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Someone actually did a really fast ascension by manipulating its RNG. &lt;<a href="https://pellsson.github.io/">https://pellsson.github.io/</a>&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885229/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor885366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the nethack random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2022 17:45 UTC (Fri)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/885366/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
sssshhhh...  Don&#x27;t spoil assigned homework.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor885666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the nethack random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 14:33 UTC (Mon)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/885666/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I used to use Chrysalis BBS (Dallas TX 1997).  It had a bunch of games but hacking the RNG was always the real game.  Good times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor885185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">v1 posted</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2022 16:33 UTC (Thu)
                               by <b>zx2c4</b> (subscriber, #82519)
                              [<a href="/Articles/885185/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for this summary. Encouraged by your read on the discussion, I wound up submitting a real v1 of the patch: <a href="https://lore.kernel.org/lkml/20220217162848.303601-1-Jason@zx2c4.com/">https://lore.kernel.org/lkml/20220217162848.303601-1-Jaso...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor885235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2022 3:08 UTC (Fri)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/885235/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Let me get this straight:<br>
<p>
At the moment, both /dev/random and /dev/urandom block, until they have enough entropy. However their entropy sources differ. /dev/random draws from &quot;truly random, crpto-ready&quot; bits that came directly from a hardware source of some kind, where as /dev/urandom draws from a PRNG that is seeded from /dev/random&#x27;s hardware-backed bits.<br>
<p>
But we don&#x27;t care, because the bits that have passed through the pseudo-RNG have like 99% of the randomness of the hardware bits and are &quot;good enough&quot; for crypto to rely on? (even though they might be a little stale if it&#x27;s been a while since the PRNG was re-seeded)<br>
<p>
I _suppose_ that drawing from /dev/urandom right after it&#x27;s been seeded the first time with bits from /dev/random might be just as good as drawing from /dev/urandom, but what&#x27;s the difference in their worst case? ie. if I&#x27;m an attacker and later I draw 1 billion numbers from the PRNG before the next time it&#x27;s re-seeded.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2022 5:59 UTC (Fri)
                               by <b>Otus</b> (subscriber, #67685)
                              [<a href="/Articles/885239/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, other than initial blocking behavior they are the same already, they use the same entropy pool and the same crng algorithm. If there is not yet enough entropy one blocks while the other warns and returns possibly-not-random data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor885355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2022 16:58 UTC (Fri)
                               by <b>derobert</b> (subscriber, #89569)
                              [<a href="/Articles/885355/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s not right. Both give you bits from a CSPRNG, they work exactly the same. It has to be that way — the entropy collected from most sources isn&#x27;t fully random, so you need some process to extract the entropy from it and a CSPRNG is a good way to do that.<br>
<p>
Originally /dev/random made some guess of when entropy was &quot;depleted&quot;, but that didn&#x27;t really make sense — one effect of a PRNG being cryptography secure is it doesn&#x27;t deplete the entropy. So a while back, that was removed.<br>
<p>
An attacker can gain no knowledge of the CSPRNG&#x27;s state from its output (well, at least not without an impossible number of them, like 2^128). It doesn&#x27;t matter if they have a few billion or trillion. <br>
<p>
And Linux keeps mixing in new entropy, so the internal state changes over time.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor885473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2022 14:37 UTC (Sat)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/885473/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Currently /dev/urandom doesn&#x27;t block.  This means there is a window once the machine has booted where you can draw numbers from /dev/urandom and it isn&#x27;t properly seeded.  /dev/random will block until it is properly seeded.  Other than that, since 2020 they are equivalent, and /dev/random won&#x27;t ever block after it has been seeded.<br>
<p>
Once /dev/urandom is properly seeded (or you read from /dev/random), if you&#x27;re an attacker and you draw 1 billion numbers, ... it doesn&#x27;t help you because you can&#x27;t crack the crypto in the PRNG.  (well, if you *can*, you&#x27;ve made a breakthrough in crypto that will make you as famous as you&#x27;ll be infamous).<br>
<p>
In the old days (well, I think prior to 2020?  So not so old), /dev/random would remove N bits of entropy from the pool for every N bits read from /dev/random, and if there isn&#x27;t N bits of entropy available then it would block until there is.  This was based on a misunderstanding that you need to consume entropy to generate cryptographically secure random numbers.  But if you use a cryptographically secure PRNG, then you only need enough bits of entropy for the seed of the PRNG, and you can generate as many secure random bits as you like.  Predicting the next number in the sequence requires determining the internal state of the PRNG, which isn&#x27;t possible from examining the prior output (as long as the crypto algorithm doesn&#x27;t contain any flaws).  So there is an assumption that the crypto is strong and won&#x27;t be broken.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor885734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 23:40 UTC (Mon)
                               by <b>koh</b> (subscriber, #101482)
                              [<a href="/Articles/885734/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unfortunately - or fortunately - the fact that /dev/random and /dev/urandom use the same CRNG implies that /dev/random no longer behaves as the name suggests: you get crypto-strength random bits, but not random bits. It&#x27;s clear that you didn&#x27;t get random bits before they&#x27;ve been made the same, but that could&#x27;ve been considered a bug: preprocessing the hardware source&#x27;s output may be necessary, but algorithmically modifying output and thereby decreasing entropy (necessarily) for hardware RNGs is suboptimal at best when you&#x27;re after random numbers (opposed to crypto-strength random numbers).<br>
<p>
While that change may have been motivated by practical reasons, it nonetheless means you now get a filtered view on random bits - filtered through the eyes of crypto-strength. It may easily not be what an application wants to receive. This blurring of semantics concerns me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885742"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 8:30 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/885742/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you have found a vulnerability in the BLAKE2 hash function that makes this distinction remotely meaningful in any way I&#x27;d encourage you to publish that research as soon as possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885742/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 0:28 UTC (Sun)
                               by <b>koh</b> (subscriber, #101482)
                              [<a href="/Articles/886257/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If you have found a vulnerability in the BLAKE2 hash function</font><br>
<p>
well, that&#x27;s cheap; of course not and it&#x27;s beside the point.<br>
<p>
<font class="QuotedText">&gt; that makes this distinction remotely meaningful in any way</font><br>
<p>
This is more to the point: before I could assume that /dev/random gives to me whatever the hardware generates - meaning, I can test the acquired data itself, develop and test hardware based on it and even find out when there is not enough data. I realize that the last point was meant to be fixed, but it does constitute a quite substantial shift in semantics I honestly see no reason for - if you want unlimited &quot;randomness&quot; go for /dev/urandom. Hiding the distinction between the two devices is a step in the wrong direction.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 4:06 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/886312/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; before I could assume that /dev/random gives to me whatever the hardware generates</font><br>
<p>
That has not been the case in any version of /dev/random in Linux since the feature was first implemented as a mix of sources of hardware entropy based on secure hashes in 1994. The notable differences since then are (a) using better mixing functions, (b) adding more sources of entropy, and (c) no longer limiting the amount of data read (after initialization) based on a flawed interpretation of entropy.<br>
<p>
If you want &quot;raw&quot; random data from hardware then you want /dev/hwrng, not /dev/random.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 22:57 UTC (Mon)
                               by <b>koh</b> (subscriber, #101482)
                              [<a href="/Articles/886421/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So exactly when do I want /dev/random in contrast to /dev/urandom?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 23:17 UTC (Mon)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/886422/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Now? When it disappearing would break a userspace program you don&#x27;t want to (or lack the means to) recompile.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886441"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uniting the Linux random-number devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 11:07 UTC (Tue)
                               by <b>neggles</b> (subscriber, #153254)
                              [<a href="/Articles/886441/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Under the current behaviour, /dev/random will block if the CSPRNG has not yet been fully seeded, and /dev/urandom will not. For 99.9% of use cases in userspace there's no functional difference between the two; by the time your program is running, the CSPRNG will almost certainly be fully seeded. on a systemd system it definitely will be.</p>

<p>
systemd and other initsystems are just about the only place where the distinction between "blocks until fully seeded" and "gives you the best numbers it can even if they suck" - as Lennart mentioned <a href="https://lore.kernel.org/lkml/Ygps2W6MfxKkP5eD@gardel-login/">here,</a> systemd uses the non-blocking source during early boot to seed some hash tables; the quality of that randomness is not important since they'll be reseeded later if collisions occur, but it can't carry on with boot until it's got <i>something</i> to work with.
</p>
<p>
In other words, the distinction only really matters if you're writing an initsystem.
</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/886441/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
