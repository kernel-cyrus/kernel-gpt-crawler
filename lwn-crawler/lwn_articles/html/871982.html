        <!DOCTYPE html>
        <html lang="en">
        <head><title>Pulling slabs out of struct page [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/871982/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/872158/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/871982/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Pulling slabs out of struct page</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 8, 2021</br>
           </div>
For the time being, the effort to add <a href="/Articles/849538/">the folio
concept</a> to the memory-management subsystem <a
href="/Articles/868598/">appears to be stalled</a>, but appearances can
be deceiving.  The numerous folio discussions have produced a number of
points of consensus, though; one of those is that far too much of the
kernel has to work with <tt>page</tt> structures to get its job done.  As
an example of how a subsystem might be weaned off of <tt>struct&nbsp;page</tt>
usage, Matthew Wilcox has <a
href="/ml/linux-mm/20211004134650.4031813-1-willy@infradead.org/">split out
the slab allocators</a> in a 62-part patch set.  The result may be
a foreshadowing of changes to come in the memory-management subsystem.

<p>
The kernel maintains one <tt>page</tt> structure for every physical page of
memory that it manages.  On a typical system with a 4KB page size, that
means managing millions of those structures.  A <tt>page</tt> structure
tells the kernel about the state of the page it refers to: how it is being
used, how many references to it exist, its position in various queues, and
more.  The required information varies depending on how any given page is
being used at the moment; to accommodate this, <tt>struct&nbsp;page</tt> is a
complicated mess of 
structures and unions.  The <a
href="https://elixir.bootlin.com/linux/v5.15-rc4/source/include/linux/mm_types.h#L31">current
definition of <tt>struct&nbsp;page</tt></a> makes for good pre-Halloween
reading, but those who truly want a good scare may want to see <a
href="https://elixir.bootlin.com/linux/v4.17.19/source/include/linux/mm_types.h#L31">what
it looked like</a> before Wilcox cleaned things up for 4.18.
<p>
One of the users of <tt>struct&nbsp;page</tt> is the set of slab allocators,
which obtain blocks of pages ("slabs") from the kernel and hand them out in
smaller, fixed-size chunks.  They are used heavily, and their performance
will affect the performance of the system as a whole, so it is not
surprising that they reach into the memory-management subsystem at the
lowest levels.  To support this usage, many of the fields in <tt>struct
page</tt> are there specifically for the slab allocators.  Just to
complicate things, the kernel has three slab allocators: SLAB (the original
allocator, often used by Android), SLUB (often used for desktop and data-center
systems), and SLOB (a tiny allocator intended for embedded systems).  Each
has its own needs for fields in <tt>struct&nbsp;page</tt>.
<p>
Wilcox's patch set <a
href="/ml/linux-mm/20211004134650.4031813-4-willy@infradead.org/">creates a
new <tt>struct&nbsp;slab</tt></a> by removing the relevant fields from
<tt>struct&nbsp;page</tt>.  The new structure is, in its 
entirety:
<p>
<pre>
    struct slab {
	unsigned long flags;
	union {
	    struct list_head slab_list;
	    struct {	/* Partial pages */
	        struct slab *next;
    #ifdef CONFIG_64BIT
	        int slabs;	/* Nr of slabs left */
	        int pobjects;	/* Approximate count */
    #else
	        short int slabs;
	        short int pobjects;
    #endif
	    };
	    struct rcu_head rcu_head;
	};
	struct kmem_cache *slab_cache; /* not slob */
	/* Double-word boundary */
	void *freelist;		/* first free object */
	union {
	    void *s_mem;	/* slab: first object */
	    unsigned long counters;	/* SLUB */
	    struct {			/* SLUB */
	        unsigned inuse:16;
	        unsigned objects:15;
	        unsigned frozen:1;
	    };
	};

	union {
	    unsigned int active;	/* SLAB */
	    int units;			/* SLOB */
	};
	atomic_t _refcount;
    #ifdef CONFIG_MEMCG
	unsigned long memcg_data;
    #endif
    };
</pre>
<p>

As can be seen, this structure still relies heavily on unions to overlay
the information that each allocator needs to store with the page.  Those
could be eliminated by splitting the structure into three
allocator-specific variants, but that would add complication to a patch set
that is already large (and set to grow).
<p>
It is worth noting that <tt>struct&nbsp;slab</tt> is really <tt>struct&nbsp;page</tt>
in disguise; instances of <tt>struct&nbsp;slab</tt> overlay the corresponding
<tt>page</tt> structure in the kernel's memory map.  It
is, essentially, the kernel's view of <tt>struct&nbsp;page</tt> for pages that
are owned by a slab allocator, extricated from its coexistence with all of
the other views of that structure.  This means that <tt>struct&nbsp;slab</tt>
must be laid out with care; some fields (<tt>_refcount</tt>, for example)
are shared with <tt>struct&nbsp;page</tt>, and the results of a disagreement
over its location would be unfortunate.  To ensure that no such calamity
occurs, Wilcox has included a set of compile-time tests verifying the
offsets of the shared fields.
<p>
After that, the remaining patches in the series convert various code in
the slab allocators (and beyond) to use the new type.  The SLUB conversion
is done meticulously, in over 40 small steps.  Wilcox described the
conversion of the other allocators as "<q>slapdash</q>", done in a
single patch each.  Presumably a later version of the patch set will turn
these proof-of-concept patches into a proper series of their own, but it's
not entirely clear who will do that; Wilcox wrote in the cover letter:
<p>
<blockquote class="bq">
	I don't know the slab allocators terribly well, so I would be very
	grateful if one of the slab maintainers took over this effort.
	This is kind of a distraction from what I'm really trying to
	accomplish with folios, although it has found one minor bug.
</blockquote>
<p>
As of this writing, no slab maintainers (who tend to be thin on the ground
in the best of times) have responded to this request.
<p>
This might seem like a lot of work to put an old structure into a new form,
but there are a number of reasons to want something like this.  Just
pulling the slab-specific fields out of <tt>struct&nbsp;page</tt> simplifies
that structure significantly.  Using a separate type makes it clear which
variant of the <tt>page</tt> structure the code expects to deal with, and
it adds 
a degree of type safety; it is no longer possible to accidentally access
the wrong union fields.
<p>
But the biggest benefit comes simply from beginning to separate the slab
allocators from <tt>struct&nbsp;page</tt>.  Eventually it may become possible to
disassociate <tt>struct&nbsp;slab</tt> from <tt>struct&nbsp;page</tt> entirely and
allocate it dynamically.  That would be one small step toward encapsulating
<tt>struct&nbsp;page</tt> within the core memory-management code and hiding it
from the rest of the kernel, a change that would ease the much-needed task
of improving page-level memory management.
<p>
First, though, some variant of this work must make it into the mainline
kernel.  It should be an easier process than getting folios merged, but
getting big changes into the memory-management code is never easy.  The
relative silence that has greeted this work so far might be a bit
worrisome, especially since Wilcox has requested help, but it is the early
days for this series still.  Regardless of how <tt>struct&nbsp;slab</tt> fares,
though, it provides an indication of the direction that the
memory-management developers are trying to go.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Memory_descriptors">Memory management/Memory descriptors</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/871982/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor872298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 16:34 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/872298/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; instances of struct slab overlay the corresponding page structure in the kernel&#x27;s memory map</font><br>
<p>
In that case it is good that the kernel is compiled with -fno-strict-aliasing.<br>
<p>
<a href="https://en.cppreference.com/w/c/language/object#Strict_aliasing">https://en.cppreference.com/w/c/language/object#Strict_al...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 21:12 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872318/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
TBAA is unsuited to kernel development.<br>
<p>
<a href="https://www.yodaiken.com/2021/10/06/plos-2021-paper-how-iso-c-became-unusable-for-operating-system-development/">https://www.yodaiken.com/2021/10/06/plos-2021-paper-how-i...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 7:03 UTC (Sun)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/872395/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s certainly &lt;i&gt;an&lt;/i&gt; article. Starting with lines like &quot;The C programming language [33] is the first, and, so far,only widely successful programming language that provides operating system developers with a high-level language alternative to assembler (compare to [42])&quot;? BLISS, PL/I and Algol 68 all were used as implementation languages for OSes released before Unix, and afterwards, any number of languages have been used, with &quot;only widely successful&quot; coming off as a weaselly way of saying &quot;most widely successful&quot;.<br>
<p>
It concludes with &quot;A small performance improvement will generally not justify a decrease in code stability for operating systems...&quot;, but as I see it, that&#x27;s not supported by reality; stuff like <a href="https://lwn.net/Articles/871726/">https://lwn.net/Articles/871726/</a> makes it clear Linux kernel programmers will write to conventions no C compiler ever has promised they won&#x27;t break (multiprocessing largely postdates ISO C) for a speedup. My guess is that if kernel developers got a -kernel switch that gave them everything they claimed to want at the cost of an average of 15% loss in performance, they&#x27;d be up in arms.<br>
<p>
In any case, all the article really says about &quot;TBAA is unsuited to kernel development.&quot; is &quot;it may be possible in ISO C to push all these different types into a union, but that would harm modularity,...&quot; Given that C is about the only language in modern use not to have a module or package system (showing a lack of commitment to modularity) and we&#x27;re talking about a direct hit to code stability, I&#x27;m not overwhelmed by that argument.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872432"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 18:20 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/872432/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; with &quot;only widely successful&quot; coming off as a weaselly way of saying &quot;most widely successful&quot;.</font><br>
<p>
How many successful operating systems have been written in C? Two? Unix of course, I don&#x27;t know what language Windows was written in, but I suspect most of it is C nowadays if it wasn&#x27;t to start with?<br>
<p>
To my knowledge Multics predates C - Fortran? Pr1mos was a multics-derivative - that was Fortran, then they ADDED PL/? (is that PL/1, PL/P, SPL, ...  a whole bundle of variants/dialects/whatever). Then they TRIED to port the whole shebang to C and the result was a disaster.<br>
<p>
How many other OS ports to C have been a disaster? I strongly suspect C owes its success to Unix, NOT the other way round.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872432/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 19:58 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/872440/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C and Unix&#x27;s success is mutualistic.<br>
<p>
The 1973 rewrite of Unix from PDP-11 assembly to C would eventually allow it to proliferate off of DEC hardware (the first such port being to the Interdata 8/32 in 1978); Unix succeeding, in turn, allowed C to proliferate off of Unix.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2021 6:47 UTC (Mon)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/872457/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends on what we call successful and operating system, doesn&#x27;t it. Windows and most forms of Un*x have kernels written primarily in C. (Windows 3.0 apparently rewrote a bunch of stuff from C into assembly.) MacOS X and Windows NT kernels have some C++, especially at the edges. It&#x27;s hard to tell for many, but C and C++ seem to dominate, with other programming languages now for one-offs or research.<br>
<p>
MacOS seems to have drifted through assembly, Pascal, and then C. Multics was PL/I. PRIMOS was originally Fortran IV, then a PL/1 dialect and Modula-2.<br>
<p>
I tend to agree with mpr22 that Unix and C&#x27;s success were mutual. If nothing else, the Lions book offered a good example of what could be done, and how to do it in C, and Ada and ALGOL-68 were complex, Modula-2 and LISP too academic and not specifically designed for it, PASCAL way too academic and not designed for it, except in a horde of dialects, and BLISS, JOVIAL and PL/S too proprietary and ill-documented. Unix could have won and eventually been rewritten in Modula-2 or something else, had C not been at least good enough.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2021 12:36 UTC (Mon)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/872483/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;It depends on what we call successful and operating system, doesn&#x27;t it. </font><br>
<p>
Don&#x27;t forget various RTOSes and other embedded stuff -- C (and to a lesser extent, C++) overwhelmingly dominate.<br>
<p>
Rust has some promise to supplant things there, but the amount of unsafe boilerplate needed to drive a modern MCU is staggering.  Some of that can be automated away but it results in a much steeper curve to being productive.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2021 19:36 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/872884/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Windows and most forms of Un*x have kernels written primarily in C. (Windows 3.0 apparently rewrote a bunch of stuff from C into assembly.)</font><br>
<p>
This is true, but Microsoft historically has not made a very strong effort to distinguish between &quot;the kernel&quot; and &quot;the rest of Windows.&quot; To some extent, this is an arbitrary line-drawing exercise. For example, you could take the position that every process which runs as SYSTEM is the Windows equivalent of a kernel thread, and therefore large chunks of the Windows kernel are actually written in managed languages like C#, but I imagine some people would violently disagree with that characterization.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor882019"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2022 22:17 UTC (Thu)
                               by <b>yodaiken</b> (guest, #156253)
                              [<a href="/Articles/882019/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Multics scheduler  <a rel="nofollow" href="http://web.mit.edu/multics-history/source/ldd_listings/mcs/scheduler.list">http://web.mit.edu/multics-history/source/ldd_listings/mc...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882019/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor882031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2022 23:05 UTC (Thu)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/882031/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><em>To my knowledge Multics predates C - Fortran?</em></blockquote>
<p>
According to <a href="https://multicians.org/features.html#tag17">multicians.org</a>, PL/1, or specifically a subset thereof called EPL.
</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/882031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor881465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2022 22:31 UTC (Sat)
                               by <b>yodaiken</b> (guest, #156253)
                              [<a href="/Articles/881465/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
<p>
&quot;Starting with lines like &quot;The C programming language [33] is the first, and, so far,only widely successful programming language that provides operating system developers with a high-level language alternative to assembler (compare to [42])&quot;? BLISS, PL/I and Algol 68 all were used as implementation languages for OSes released before Unix, ...&quot;<br>
<p>
See that &quot;(compare to [42])&quot; ? That is a citation. If you look on the bottom of the article you can find<br>
<p>
42]William A Wulf. 1972.   Systems for systems implementors: some experiences from Bliss. In Proceedings of the December 5-7, 1972, fall joint computer conference, part II. 943–948.<br>
<p>
As for Pl/1 and Algol68, I&#x27;d love to see references to actual operating systems implemented in either.  The Bliss article is interesting and perhaps you should read it. <br>
<p>
Thanks for calling my paper  &quot;weaselly&quot; though. Impressive criticism.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/881465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor881470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2022 1:29 UTC (Sun)
                               by <b>mgb</b> (guest, #3226)
                              [<a href="/Articles/881470/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I never used it and had no part in it&#x27;s implementation but I did stand next to the CAP computer once.  It had an ALGOL 68C OS.<br>
<p>
<a rel="nofollow" href="https://en.wikipedia.org/wiki/CAP_computer">https://en.wikipedia.org/wiki/CAP_computer</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/881470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor872309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 19:45 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/872309/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is the reason for placing _refcount at the end of the structure rather than at the beginning?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">_refcount</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 20:02 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/872311/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      For <tt>struct slab</tt>, it has to be in the same place as with <tt>struct page</tt>.  As for why its location in <tt>struct page</tt>, that's probably an outcome of years of history.  But is there some special reason why <tt>_refcount</tt> should be at the beginning?


      
          <div class="CommentReplyButton">
            <form action="/Articles/872311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">_refcount</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 23:53 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/872324/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I mean, typically you would want to have all the shared fields to come first in the structure. That&#x27;s how inheritance is usually done in plain C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor872317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 21:10 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872317/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ooh, ooh, I know this one! Hope you like horror films ...<br>
<p>
Slub needs to cmpxchg_double() freelist &amp; counters. That means that freelist has to be dword aligned on both 32 and 64 bit. _refcount is word sized on 32-bit and half-word sized on 64-bit. For compactness, we pair it with _mapcount. Now the pair are either one or two words, depending on 32/64 bit.  So _refcount has to be after freelist+counters in order for them to be dword aligned on both 32 and 64 bit.  It&#x27;s advantageous to make the main union as large as possible, so _refcount has to go towards the end of the struct.<br>
<p>
There are other considerations in the layout of struct page, but these are the ones that pertain to the location of _refcount.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 23:55 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/872325/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah. I suspected as much. Thanks for the night-time alignment horror story!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 0:54 UTC (Sun)
                               by <b>vivo</b> (subscriber, #48315)
                              [<a href="/Articles/872388/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
this one deserve a place in the weekly &quot;Brief items&quot; page<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor872320"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 21:36 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872320/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Those could be eliminated by splitting the structure into three allocator-specific variants, but that would add complication to a patch set that is already large (and set to grow).</font><br>
<p>
I&#x27;m glad someone sees where I&#x27;m going! Yes, I did think about doing that, but decided not to do it as part of this patch. partial_pages will still need a union, but there will be far less unions once struct slab is defined based on CONFIG options.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872320/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 21:55 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872322/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have some further thoughts indicating where I&#x27;m going at <a href="https://kernelnewbies.org/MemoryTypes">https://kernelnewbies.org/MemoryTypes</a><br>
<p>
The dynamically allocated struct folio/slab/pgtable is where Kent Overstreet and Johannes Weiner want to go. It&#x27;s more work, with a bigger payoff. We can collaborate on the steps along the way, since so much of the way is shared.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2021 15:40 UTC (Sat)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/872363/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At the risk of asking a horrible question: do we really need the ability to start with a _page_ (PFN mapped to userspace, for example) and find type information?<br>
<p>
I don’t think we really need this. We already support, in a very limited way, non-struct-page user mappings.  For lightweight operations on user memory, we can use the uaccess functions, and they inherently lock correctly against unmapping. For heavyweight operations, we can look up the VMA.  This leaves things that don’t want to pay the full price of finding a VMA.  Whether those really exist isn’t quite clear to me on a conceptual level, but there is certainly a lot of code that calls get_user_pages [0] and expects the result to be live until release. (And some FS code may want to do useful IO.)<br>
<p>
I wonder if performance could be acceptable if GUP walked the VMA tree to find a refcountable object.  Some interesting locking would be needed to compete with get_user_pages_fast.<br>
<p>
[0] This is all kinds of messy. KVM does unspeakable and blatantly incorrect to host user memory. Even the normal pattern of GUPping a page interacts in unfortunate ways with COW.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2021 15:46 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872364/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; At the risk of asking a horrible question: do we really need the ability to start with a _page_ (PFN mapped to userspace, for example) and find type information?</font><br>
<p>
Yes. Some of the places we need this:<br>
<p>
 - GUP gets back a page and then calls set_page_dirty(). That needs to figure out whether this is a file/anon/ksm/netpool/DEVICE/... page and call the filesystem if required.<br>
<p>
 - compaction walks the memmap and needs to figure out what this memory is and whether it can be relocated.<br>
<p>
 - memory failure gets a physical address and needs to understand how to handle it<br>
<p>
There are more, but these should illustrate some of the problems we have to solve.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2021 16:08 UTC (Sat)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/872366/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  - GUP gets back a page and then calls set_page_dirty(). That needs to figure out whether this is a file/anon/ksm/netpool/DEVICE/... page and call the filesystem if required.</font><br>
<p>
Is this done directly in GUP?  If so, surely it could work like the fault code and look up the VMA.<br>
<p>
<font class="QuotedText">&gt; - compaction walks the memmap and needs to figure out what this memory is and whether it can be relocated.</font><br>
<p>
Hmm, this one is legit.<br>
<p>
<font class="QuotedText">&gt; - memory failure gets a physical address and needs to understand how to handle it</font><br>
<p>
In my dream world, the low-level memory failure / machine check code gets a virtual address and can look up a VMA or vmap area.  Making this work with kmap might be interesting.<br>
<p>
<font class="QuotedText">&gt; There are more, but these should illustrate some of the problems we have to solve.</font><br>
<p>
I wonder if it&#x27;s possible to reduce the dependency on struct page or equivalent to the point that everything works without it except for some nice-to-have features like compaction.  (I&#x27;m not saying that the colossal amount of effort involved is worthwhile.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2021 16:59 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872369/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m really just trying to avoid the bugs we have where people look at page-&gt;mapping and the compiler can&#x27;t say &quot;this is a tail page, that doesn&#x27;t do what you think it does&quot;. Everybody keeps trying to get me to solve their problems as well.<br>
<p>
Please, just let me solve a problem, not rewrite the entire kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872370"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2021 17:06 UTC (Sat)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/872370/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t want you to rewrite the whole kernel!  I&#x27;m just contemplating how it _could_ be rewritten if someone were inclined to do so.<br>
<p>
(Also, I do care about the KVM mess, and I don&#x27;t think KVM could have dug itself into quite the hole its in if there hadn&#x27;t been a struct page to begin with for most user mappings, but fixing that needs a rewrite and a time machine.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872370/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor872417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 14:39 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872417/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In my dream world, the low-level memory failure / machine check code gets a virtual address and can look up a VMA or vmap area. Making this work with kmap might be interesting.</font><br>
<p>
I don&#x27;t think your dream world is possible. It&#x27;s the same problem the page cache has with errors on writeback -- the producer might not be around any more. We might have unmapped the vmap/kmap; the user process that dirtied the cache line might have exited, or just been switched away from.<br>
<p>
But more importantly, unless the cache is writethrough, the CPU no longer knows which virtual address(es) were used to dirty the cache line.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 14:53 UTC (Sun)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/872421/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I understand it, on Intel chips that support memory failure recovery, failed writes may not be notified at all.  (I’ve at least been told this is true for the TDX style machine checks.)<br>
<p>
And Linux’s entry code makes quite weak guarantees about recoverability of machine checks: we make a best (and pretty good) effort to recover from a fault in user code, and we try to recover from kernel code with exception table entries. If normal kernel code without an exception table entry hits a memory failure entry, forget about struct page: we may be 100% dead regardless because we have no idea how to resume execution.<br>
<p>
If we hit a machine check with an exception handler, then we know the program counter, and we have a full register file. Figuring out the failed virtual address isn’t much of a problem even if the hardware doesn’t help.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 14:57 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872422/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having the full register file doesn&#x27;t matter if the store that dirtied the cache line was 10ms ago. I can&#x27;t imagine how any CPU vendor would keep the register state around until the cache line moves from L3 to DRAM<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 15:32 UTC (Sun)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/872423/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You’re assuming that the CPU will notify the OS at all when a store from L3 to DRAM fails and that the OS actually needs to do anything about it.  I don’t know all the nasty details, but it may be possible (and even mandatory?) to mark the memory bad when writeback fails and deliver a fault on a subsequent read.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor872367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2021 15:55 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872367/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, since you mentioned unspeakable things, the graphics stack does horrendous hacks, so a VMA no longer tells you anything about the page you found. It might be anon, or it might be a page that belongs to a graphics device. And now they want to do that to file mappings too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 11:39 UTC (Sun)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/872412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I won&#x27;t deny that KVM does the unspeakable, but I think the idioms are more or less common to all users of MMU notifiers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor872326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pulling slabs out of struct page</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2021 0:18 UTC (Sat)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/872326/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do the various slab allocators see much, if any, usage? I vaguely recall that after the switch to slub as the default in the 2.6(?) era the feeling was that slab support would eventually be removed. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
