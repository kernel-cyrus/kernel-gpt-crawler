        <!DOCTYPE html>
        <html lang="en">
        <head><title>Validating Memory Barriers and Atomic Instructions [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/470681/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/470152/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/470681/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Validating Memory Barriers and Atomic Instructions</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="GAByline">
           <p>December 6, 2011</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
Some of the most obscure corners of the Linux kernel are those
employing the dark arts of atomic instructions and memory barriers.
Although things are better than they were (say) ten years ago,
atomic instructions and memory barriers are still a not-infrequent
source of confusion.

<p>One of the difficulties with atomic instructions and especially with
memory barriers is that the documentation for the underlying machine
instructions can be a bit difficult to understand.
It is not hard to work around obtuse documentation for arithmetic
instructions:  Simply test them.
However, simple testing
does not work for memory barriers and atomic instructions
because these
instructions must handle non-deterministic situations.
Furthermore, unlike arithmetic instructions, a given piece of hardware
is free to be more strict that absolutely necessary
in its interpretation of ordering requirements.
Therefore, your test results might
not apply to the next generation of that same hardware,
which in turn might result in your code breaking horribly.

</p>

<div class="tlr"><a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
Yeah, right!!!
Since when has anything ever made the Linux kernel's memory barriers
and atomic instructions easier???
<a href="#aqq1">Answer</a>
</div>


<p>What we need is a tool that evaluates a code sequence
containing atomic operations and memory barriers, telling the developer
whether or not a given assertion is guaranteed never to trigger.
Given such a guarantee, the developer could then be reasonably confident
that this code sequence would operate correctly on all current and future
versions of the hardware in question.

</p><p>Previous LWN articles
(<a href="http://lwn.net/Articles/243851/">here</a> and
<a href="http://lwn.net/Articles/279077/">here</a>), as well as Mathieu
Desnoyers's 
<a
href="http://www.lttng.org/pub/thesis/desnoyers-dissertation-2009-12.pdf">doctoral
dissertation [PDF]</a>,
describe how to use <code>Promela</code> and <code>spin</code>
to test assertions on
code fragments that execute concurrently.
Because <code>Promela</code> and <code>spin</code>
search the code fragments' full state space,
the developer can be reasonably confident that the
code fragments will operate correctly on real hardware.
Unfortunately, most code fragments using atomic instructions
and memory barriers require detailed knowledge
of the semantics of a given CPU's memory barriers and atomic instructions.
<code>Promela</code> and <code>spin</code>
do not have such knowledge, so the developer must explicitly write
<code>Promela</code>/<code>spin</code>
code that captures this detailed knowledge.
This is not helpful if the developer in question does not possess
this detailed knowledge in the first place.

</p><p>It would clearly be much better to have a tool that
already understands this detailed knowledge.
I am happy to report that such tools are now becoming available,
for example, from
Peter Sewell and Susmit Sarkar at the University of Cambridge,
Luc Maranget, Francesco Zappa Nardelli, and Pankaj Pawan at INRIA, and
Jade Alglave at Oxford University.
This group has done some excellent work over the past few years
<a href="http://www.cl.cam.ac.uk/~pes20/weakmemory/index.html">
formalizing memory models for real computer systems</a>,
including that of ARM, Power,
some additional 64-bit members of the Power family, x86
(and yes, academics consider x86 to be a weak-memory system),
and C/C++11's new memory model.

</p>

<div class="tlr"><a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
But what about x86?
<a href="#aqq2">Answer</a>
</div>

<p>A prototype interactive version of this tool is
available for
<a href="http://www.cl.cam.ac.uk/~pes20/ppcmem/index.html#ARM">ARM</a> and
<a href="http://www.cl.cam.ac.uk/~pes20/ppcmem/">Power</a>.

<p>This article describes this tool as follows:

<ol>
<li>	<a href="#Anatomy of a Litmus Test">
	Anatomy of a Litmus Test</a>.
<li>	<a href="#What Does This Litmus Test Mean?">
	What Does This Litmus Test Mean?</a>
<li>	<a href="#Running a Litmus Test">
	Running a Litmus Test</a>.
<li>	<a href="#Full State-Space Search">
	Full State-Space Search</a>.
<li>	<a href="#Conclusions">
	Conclusions</a>.
</ol>

<p>Following this is the obligatory
<a href="#Answers to Quick Quizzes">Answers to Quick Quizzes</a>.

<h4><a name="Anatomy of a Litmus Test">
Anatomy of a litmus test</a></h4>

<p>The input to this tool is a &ldquo;litmus test&rdquo;
that consists of assembly language, register initializations, and
an assertion, for example,
as follows for the
<a href="http://www.cl.cam.ac.uk/~pes20/ppcmem/">
Power interface to the model</a>:

<blockquote>
<pre>
  1 PPC SB+lwsync-RMW-lwsync+isync-simple
  2 ""
  3 {
  4 0:r2=x; 0:r3=2; 0:r4=y;   0:r10=0 ; 0:r11=0; 0:r12=z ;
  5 1:r2=y; 1:r4=x;
  6 }
  7  P0                 | P1           ;
  8  li r1,1            | li r1,1      ;
  9  stw r1,0(r2)       | stw r1,0(r2) ;
 10  lwsync             | sync         ;
 11                     | lwz r3,0(r4) ;
 12  lwarx  r11,r10,r12 | ;
 13  stwcx. r11,r10,r12 | ;
 14  bne Fail1          | ;
 15  isync              | ;
 16  lwz r3,0(r4)       | ;
 17  Fail1:             | ;
 18 
 19 exists
 20 (0:r3=0 /\ 1:r3=0)
</pre>
</blockquote>

<p>The ARM interface works exactly the same way, but with ARM
instructions substituted for the Power instructions and with
the initial &ldquo;PPC&rdquo; replaced by &ldquo;ARM&rdquo;.
You can select the ARM interface by clicking on
&ldquo;Change to ARM Model&rdquo; at the
web page called out above.

</p><p>In the example, line&nbsp;1 identifies the type of system
(&ldquo;ARM&rdquo; or
&ldquo;PPC&rdquo;) and contains the title for the model.
Line&nbsp;2 provides a place for an alternative name for the test,
which you will usually want to leave blank as shown in the above example.
Comments can be inserted between lines&nbsp;2 and&nbsp;3 using the
OCaml (or Pascal) syntax of &ldquo;(*&nbsp;*)&rdquo;.

</p><p>Lines&nbsp;3-6 give initial values for all registers; each is of the
form &ldquo;P:R=V&rdquo;, where &ldquo;P&rdquo; is the process identifier,
&ldquo;R&rdquo; is the register identifier, and &ldquo;V&rdquo; is the
value.
For example, process&nbsp;0's register&nbsp;r3 initially contains the
value&nbsp;2.
If the value is a variable (&ldquo;x&rdquo;, &ldquo;y&rdquo;, or
&ldquo;z&rdquo; in the example) then the register is initialized
to the address of the variable.
It is also possible to initialize the contents of variables,
for example, &ldquo;x=1&rdquo; initializes the value of &ldquo;x&rdquo;
to 1.
Uninitialized variables default to the value zero, so that
in the example,
&ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;z&rdquo;
are all initially zero.

</p><p>Line&nbsp;7 provides identifiers for the two processes, so that
the &ldquo;0:r3=2&rdquo; on line&nbsp;4 could instead have been
written &ldquo;P0:r3=2&rdquo;.
Line&nbsp;7 is required, and the identifiers must be of the form
&ldquo;Pn&rdquo;, where &ldquo;n&rdquo; is the column number, starting
from zero for the left-most column.
This may seem unnecessarily strict, but it does prevent considerable
confusion in actual use.

</p>

<div class="tlr">
<a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
Why does line&nbsp;8 initialize the registers?
Why not instead initialize them on lines&nbsp;4 and&nbsp;5?
<a href="#aqq3">Answer</a>
</div>
<p>Lines&nbsp;8-17 are the lines of code for each process.
A given process can have empty lines, as is the case for P0's
line&nbsp;11 and P1's lines&nbsp;12-17.
Labels and branches are permitted, as demonstrated by the
branch on line&nbsp;14 to the label on line&nbsp;17.
That said, too-free use of branches will expand the state space.
Use of loops is a particularly good way to explode your state space.
</p>


<p>Lines&nbsp;19-20 show the assertion, which in this case indicates
that we are
interested in whether P0's and P1's r3 registers can both contain
zero after both threads complete execution.
This assertion is important because there are a number of use cases
that would fail miserably if both P0 and P1 saw zero in their respective r3
registers.

</p><p>This should give you enough information to construct simple litmus
tests.
Some additional documentation is
<a href="http://diy.inria.fr/doc/litmus.html">available</a>, though
much of this additional documentation is intended for a different
research tool that runs tests on actual hardware.
Perhaps more importantly, a large number of pre-existing litmus tests
are available with the
<a href="http://www.cl.cam.ac.uk/~pes20/ppcmem/">online tool</a>
(available via the &ldquo;Select ARM Test&rdquo; and
&ldquo;Select POWER Test&rdquo; buttons).
It is quite likely that one of these pre-existing litmus tests will
answer your Power or ARM memory-ordering question.

<h4><a name="What Does This Litmus Test Mean?">
What does this litmus test mean?</a></h4>

<div class="tlr">
<p><a name="Quick Quiz 4"><b>Quick Quiz 4</b>:</a>
But whatever happened to line&nbsp;17, the one that is
the <code>Fail:</code> label?
<a href="#aqq4">Answer</a>
</div>

<p>P0's lines&nbsp;8 and&nbsp;9 are equivalent to the C statement
<code>x=1</code> because
line&nbsp;4 defines P0's register <code>r2</code> to be the
address of <code>x</code>.
P0's lines&nbsp;12 and&nbsp;13 are the mnemonics for load-linked
(&ldquo;load register exclusive&rdquo; in ARM parlance and
&ldquo;load reserve&rdquo; in Power parlance)
and store-conditional (&ldquo;store register exclusive&rdquo; in ARM
parlance), respectively.
When these are used together, they form an atomic instruction sequence,
roughly similar to the compare-and-swap sequences exemplified by
the x86 <code>lock;cmpxchg</code> instruction.
Moving to a higher level of abstraction, the sequence from lines&nbsp;10-15
is equivalent to 
the Linux kernel's <code>atomic_add_return(&amp;z,&nbsp;0)</code>.

Finally, line 16 is roughly equivalent to the C statement
<code>r3=y</code>.

<p>P1's lines&nbsp;8 and&nbsp;9 are equivalent to the C statement
<code>y=1</code>, line&nbsp;10 is a memory barrier, equivalent to the Linux
kernel 
statement <code>smp_mb()</code>, and line&nbsp;11 is equivalent to
the C statement <code>r3=x</code>.

</p><p>Putting all this together, the C-language equivalent to the entire
litmus test is as follows:

<pre>
  1 void P0(void)
  2 {
  3   x = 1; /* Lines 8 and 9 */
  4   atomic_add_return(&amp;z, 0); /* Lines 10-15 */
  5   r3 = y; /* Line 16 */
  6 }
  7 
  8 void P1(void)
  9 {
 10   y = 1; /* Lines 8-9 */
 11   smp_mb(); /* Line 10 */
 12   r3 = x; /* Line 11 */
 13 }
</pre>

<div class="tlr">
<p><a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Can both threads' <code>r3</code> registers be equal to
zero after both threads complete?
<a href="#aqq5">Answer</a>
</div>

<p>Now that we have a meaningful litmus test, it is time to run it.

<h4><a name="Running a Litmus Test">
Running a litmus test</a></h4>

<p>To run the litmus test, paste it into the textbox at
<a href="http://www.cl.cam.ac.uk/~pes20/ppcmem/">
http://www.cl.cam.ac.uk/~pes20/ppcmem/</a>, but use 
<a href="/Articles/470785/">a version without line numbers</a>.
Press the "Interactive" button at the lower left-hand side of the
page, and you should then see something like this:
<p>
<blockquote>
<a href="/Articles/470787/"><img src="https://static.lwn.net/images/2011/ppcmem/ppcmem_0-sm.png"
width=500 height=345 alt="[Screen shot]" border=0></a>
</blockquote>
<p>
(Click on the images for full-size versions)
</p><p>The upper portion of the screen beginning with
&ldquo;Storage subsystem state&rdquo; tracks an abstraction of the state
of the processor's write buffers, caches, and cache-coherence messages.
The next two portions, beginning with &ldquo;Thread 0 state&rdquo;
and &ldquo;Thread 1 state&rdquo;, track the instruction and memory-reference
progress of each of the two threads.
For more details on the information presented by this tool, refer to
the PLDI 2011 paper entitled
&ldquo;Understanding Power Multiprocessors&rdquo;, which may be found
<a href="http://www.cl.cam.ac.uk/~pes20/ppc-supplemental/">here</a>.

</p><p>Because this model is intended for a super-scalar weak-memory system,
a given thread can have several different operations that might
happen at a given time.
For example, for thread&nbsp;0 there are two operations, indicated by
the links (&ldquo;Commit&rdquo; and &ldquo;Read reserve k:W z 0&rdquo;),
while thread&nbsp;1 has only a single &ldquo;Commit&rdquo; link.
Clicking on a given link allows you to manually advance the state of
the system.

</p><p>In this particular case, it is most instructive to start by
clicking the links for thread&nbsp;0, ignoring thread&nbsp;1 completely
and also ignoring any links that appear in the
&ldquo;Storage subsystem state&rdquo; section preceding thread&nbsp;0.
There will come a time when the &ldquo;stwcx&rdquo; instruction gives
you a choice between &ldquo;Commit (fail)&rdquo; and
&ldquo;Commit (succ)&rdquo;.
Choosing &ldquo;Commit (succ)&rdquo; results in the following state:

<p>
<blockquote>
<a href="/Articles/470789/"><img src="https://static.lwn.net/images/2011/ppcmem/ppcmem_1-sm.png"
width=500 height=358 alt="[Screen shot]" border=0></a>
</blockquote>
<p>

</p><p>At this point, it is time to click the links for thread&nbsp;1,
resulting in the following state:

<p>
<blockquote>
<a href="/Articles/470790/"><img src="https://static.lwn.net/images/2011/ppcmem/ppcmem_2-sm.png"
width=500 height=373 alt="[Screen shot]" border=0></a>
</blockquote>
<p>

</p><p>Now, click the last link, which is in the
&ldquo;Storage subsystem state&rdquo; section and is labeled
&ldquo;(0:) Write propagate to thread: f:W y 1 to Thread 0&rdquo;,
and then click the
&ldquo;(0:) Barrier propagate to thread: g:Sync  to Thread 0&rdquo;
that replaces it, and then the second link (labeled
&ldquo;Write reaching coherence point: f:W y 1&rdquo;),
and finally the
&ldquo;Acknowledge sync: Sync g:Sync&rdquo;.
This results in the following state:

<p>
<blockquote>
<a href="/Articles/470792/"><img src="https://static.lwn.net/images/2011/ppcmem/ppcmem_3-sm.png"
width=500 height=360 alt="[Screen shot]" border=0></a>
</blockquote>
<p>

</p><p>This will result in thread&nbsp;1 gaining a
&ldquo;Read i:W x 0&rdquo; link.
Click this and the &ldquo;Commit&rdquo; link that replaces it.
Then click all the remaining links in any order, resulting in
the following final state:

<p>
<blockquote>
<a href="/Articles/470793/"><img src="https://static.lwn.net/images/2011/ppcmem/ppcmem_4-sm.png"
width=500 height=358 alt="[Screen shot]" border=0></a>
</blockquote>
<p>


<div class="tlr">
<a name="Quick Quiz 6"><b>Quick Quiz 6</b>:</a>
But suppose that I didn't think to try this particular
execution sequence.
How could I have found this bug using this tool?
<a href="#aqq6">Answer</a>
<p>
<a name="Quick Quiz 7"><b>Quick Quiz 7</b>:</a>
Does the ARM Linux kernel have a similar bug?
<a href="#aqq7">Answer</a>
</div>

</p><p>This shows that the values loaded into both threads'
<code>r3</code> registers to be zero, in violation of the
requirements set forth in
<code>Documentation/atomic_ops.txt</code>.
This bug is easily fixed by replacing the <code>isync</code> instruction
with <code>sync</code>, and a
<a href="http://www.mail-archive.com/linuxppc-dev@lists.ozlabs.org/msg54753.html">patch</a>
exists to carry out this fix.

</p><p>The fact that this tool is capable of finding this sort of
bug is a testament to its usefulness.


<h4><a name="Full State-Space Search">
Full state-space search</a></h4>

<p>The interactive web-based tool is fun to use and can be quite enlightening,
but it is very difficult to make sure that you have checked for every
possible error condition.
For that reason, there is an executable tool that conducts a full
state-space search, whose source code may be downloaded
<a href="http://www.cl.cam.ac.uk/~pes20/ppcmem/help.html">here</a>,
covered by the BSD license, with some components licensed under
<a href="http://caml.inria.fr/ocaml/license.en.html">LGPL with an
exception for linking</a>.
The tool may be built by following the instructions in the README file,
which requires a recent version of
<a href="http://caml.inria.fr/download.en.html">OCaml</a>
(3.12.0 works for me, but 3.11.2 doesn't cut it).
Please note that this tool is a research prototype that is completely
unsupported.
That said, I have found it to be quite useful.

</p><p>The tool is run from its build directory.
For litmus tests containing only normal memory accesses and memory
barriers, the following command suffices:

<pre>
    ./ppcmem filename.litmus
</pre>
<div class="tlr">
<a name="Quick Quiz 8"><b>Quick Quiz 8</b>:</a>
But when I built the tool, I didn't find an <code>armmem</code>
program.
How am I supposed to test ARM code fragments???
<a href="#aqq8">Answer</a>
</div>
<p>where &ldquo;filename.litmus&rdquo; is the path to the file containing
your litmus test.



<p>The tail end of the output of this tool when presented the litmus
test discussed earlier is as follows:

<blockquote>
<pre>
States 6
0:r3=0; 1:r3=0;
0:r3=0; 1:r3=1;
0:r3=1; 1:r3=0;
0:r3=1; 1:r3=1;
0:r3=2; 1:r3=0;
0:r3=2; 1:r3=1;
Ok
Condition exists (0:r3=0 /\ 1:r3=0)
Hash=e2240ce2072a2610c034ccd4fc964e77
Observation SB+lwsync-RMW-lwsync+isync-simple Sometimes 1 
</pre>
</blockquote>

<p>The list of states includes &ldquo;0:r3=0; 1:r3=0;&rdquo;, indicating
once again that the old powerpc implementation of
<code>atomic_add_return()</code> does not act as a full barrier.
The &ldquo;Sometimes&rdquo; on the last line confirms this: the
assertion triggers for some executions, but not all of the time.
As before, the fix is to replace P0's <code>isync</code> with <code>sync</code>,
which results in the following at the end of the tool's output:
<p>
<blockquote>
<pre>
States 5
0:r3=0; 1:r3=1;
0:r3=1; 1:r3=0;
0:r3=1; 1:r3=1;
0:r3=2; 1:r3=0;
0:r3=2; 1:r3=1;
No (allowed not found)
Condition exists (0:r3=0 /\ 1:r3=0)
Hash=77dd723cda9981248ea4459fcdf6097d
Observation SB+lwsync-RMW-lwsync+sync-simple Never 0 5
</pre>
</blockquote>
<p>This output confirms the fix: &ldquo;0:r3=0; 1:r3=0;&rdquo; does
not appear in the list of states, and the last line calls out
&ldquo;Never&rdquo;.
Therefore, the model predicts that the offending execution sequence
cannot happen.

<h4><a name="Conclusions">
Conclusions</a></h4>

<p>These tools promise to be of great help to people working on
low-level parallel primitives that run on ARM and on Power.
These tools do have some intrinsic limitations:

<ol>
<li>	These tools do not constitute official statements by
	IBM or ARM on their respective CPU architectures.
	For example, both corporations reserve the right to report
	a bug at any time against any version of any of these tools.
	These tools are therefore not a substitute for careful stress
	testing on real hardware.
	Moreover, both the tools and the model that they are based on
	are under active development and might change at any time.
	On the other hand, this model was developed in consultation
	with the relevant hardware experts, so there is good reason
	to be confident that it is a robust representation of the
	architectures.
<p>
<li>	These tools currently handle a subset of the instruction set.
	This subset has been sufficient for my purposes, but your
	mileage may vary.
	In particular, the tool handles only word-sized accesses
	(32 bits), and the words accessed must be properly aligned.
	In addition, the tool does not handle some of the weaker
	variants of the ARM memory-barrier instructions.
<p>
<li>	The tools are restricted to small loop-free code fragments running
	on small numbers of threads.
	Larger examples result in state-space explosion, just as
	with similar tools such as <code>Promela</code> and <code>spin</code>.
<p>
<li>	The full state-space search does not give any indication of
	how each offending state was reached.
	That said, once you realize that the state is in fact reachable,
	it is usually not too hard to find that state using the interactive
	tool.
<p>
<li>	The tools will detect only those problems for which you code
	an assertion.
	This weakness is common to all formal methods, and is yet another
	reason why testing remains important.
	In the immortal words of Donald Knuth,
	&ldquo;Beware of bugs in the above code; I have only proved it
	correct, not tried it.&rdquo;
</ol>

<p>That said, one strength of these tools is that they are designed
to model the full range of behaviors allowed by the architectures,
including behaviors that are legal, but which current hardware
implementations do not yet inflict on unwary software developers.
Therefore,
an algorithm that is vetted by these tools likely has some additional
safety margin when running on real hardware.
Furthermore, testing on real hardware can only find bugs; such testing
is inherently incapable of proving a given usage correct.
To appreciate this, consider the table in Section 8 on page 10 of
<a href="http://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf">
Understanding POWER Multiprocessors [PDF]</a>:
the researchers routinely ran in excess of 100 billion test runs
on real hardware to validate their model.
In one case, behavior that is allowed by the architecture did not occur,
despite 176 billion runs.
In contrast, the full-state-space search allows the tool to prove
code fragments correct.

</p><p>It is worth repeating that formal methods and tools are no
substitute for testing.
The fact is that producing large reliable concurrent software
artifacts, the Linux kernel for example, is quite difficult.
Developers must therefore be prepared to apply every tool at
their disposal towards this goal.
The tools presented in this paper are able to locate bugs that are
quite difficult to produce (let alone track down) via testing.
On the other hand, testing can be applied to far larger bodies of
software than the tools presented in this paper are ever likely
to handle.
As always, use the right tools for the job!

<div class="tlr">
<a name="Quick Quiz 9"><b>Quick Quiz 9</b>:</a>
Where can I find out more about the formal model underlying this tool?
<a href="#aqq9">Answer</a>
</div>

<p>Of course, it is always best to avoid the need to work at
this level by designing your parallel code to be easily partitioned
and then using higher-level primitives (such as locks, sequence counters,
atomic operations, and RCU) to get your job done more
straightforwardly.
And even if you absolutely must use low-level memory barriers and
read-modify-write instructions to get your job done, the more
conservative your use of these sharp instruments, the easier
your life is likely to be.

<h4><a name="Acknowledgments">
Acknowledgments</a></h4>

<p>I am grateful to
Peter Sewell and Susmit Sarkar at the University of Cambridge,
Luc Maranget, Francesco Zappa Nardelli, and Pankaj Pawan at INRIA,
Jade Alglave at Oxford University, and a number of their colleagues
for their efforts on this research topic.
We all are indebted to Ben Herrenschmidt for fixing the bug noted in
this article.
I am thankful to great number of members of the C and C++ standards committees
for many stimulating discussions on memory models and concurrency,
including Hans Boehm, Lawrence Crowl, Peter Dimov, Clark Nelson, Raul Silvera,
Mark Batty, N.M. Maclaren, Anthony Williams, Blaine Garst, Scott Owens,
Tjark Weber, Michael Wong, Benjamin Kosnik, and Bjarne Stroustrup.
I owe thanks to
Derek Williams and Richard Grisenthwaite for their patient
explanations of the Power and ARM memory models, respectively,
and to Jim Wasko of IBM and Dave Rusling of Linaro for their support of
this effort.

</p><h4><a name="Answers to Quick Quizzes">
Answers to quick quizzes</a></h4>

<a name="aqq1"></a>
<p><b>Quick Quiz 1</b>:
Yeah, right!!!
Since when has anything ever made the Linux kernel's memory barriers
and atomic instructions easier???

</p><p><b>Answer</b>:
There really have been some improvements over the years, including updates
to <code>Documentation/memory-barriers.txt</code> and
<code>Documentation/atomic_ops.txt</code>.
Perhaps more important, the <code>scripts/checkpatch.pl</code> script
complains if memory barriers are not accompanied by a comment, which
has made the code using memory barriers a bit less obscure.

</p><p>But yes, more help is needed, hence this article.

</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>
<hr width="60%" align="left">
<a name="aqq2"></a>
<p><b>Quick Quiz 2</b>:
But what about x86?

</p><p><b>Answer</b>:
The ppcmem tool could in fact be extended to handle x86 as well as ARM
and Power, but there are no definite plans to carry out this work at
the moment.

</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>
<hr width="60%" align="left">
<a name="aqq3"></a>
<p><b>Quick Quiz 3</b>:
Why does line&nbsp;8 initialize the registers?
Why not instead initialize them on lines&nbsp;4 and&nbsp;5?

</p><p><b>Answer</b>:
Either way works.
However, in general, it is better to use initialization than explicit
instructions.
The explicit instructions are used in this example to demonstrate
their use.
In addition, many of the litmus tests available on the tool's
<a href="http://www.cl.cam.ac.uk/~pes20/ppcmem/">web site</a>
were automatically generated, which generates explicit initialization
instructions.

</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>
<hr width="60%" align="left">
<a name="aqq4"></a>
<p><b>Quick Quiz 4</b>:
But whatever happened to line&nbsp;17, the one that is
the <code>Fail:</code> label?

</p><p><b>Answer</b>:
The implementation of powerpc version of <code>atomic_add_return()</code>
loops when the <code>stwcx</code> instruction fails, which it
communicates by setting non-zero status in the condition-code register,
which in turn is tested by the <code>bne</code> instruction.
Because actually modeling the loop would result in state-space
explosion, we instead branch to the <code>Fail:</code> label,
terminating the model with the initial value of 2 in thread&nbsp;1's
<code>r3</code> register, which will not trigger the <code>exists</code>
assertion.

</p><p>There is some debate about whether this trick is universally
applicable, but I have not seen an example where it fails.
(Famous last words!)

</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>
<hr width="60%" align="left">
<a name="aqq5"></a>
<p><b>Quick Quiz 5</b>:
Can both threads' <code>r3</code> registers be equal to
zero after both threads complete?

</p><p><b>Answer</b>:
Not if <code>atomic_add_return()</code> acts as a full barrier,
as is set out as required behavior in
<code>Documentation/atomic_ops.txt</code>.

</p><p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a>
<hr width="60%" align="left">
<a name="aqq6"></a>
<p><b>Quick Quiz 6</b>:
But suppose that I didn't think to try this particular
execution sequence.
How could I have found this bug using this tool?

</p><p><b>Answer</b>:
You can easily miss problematic execution sequences when using
the interactive tool.
Which is why the next section covers the full state-space-search tool.

<p><a href="#Quick%20Quiz%206"><b>Back to Quick Quiz 6</b>.</a><hr width="60%" align="left">

<a name="aqq7"></a>
<p><b>Quick Quiz 7</b>:
Does the ARM Linux kernel have a similar bug?

</p><p><b>Answer</b>:
ARM does not have this particular bug, given that it places
<code>smp_mb()</code> before and after the
<code>atomic_add_return()</code> function's assembly-language
implementation.
Finding any other bugs that ARM might have is left as an exercise
for the reader.

<p><a href="#Quick%20Quiz%207"><b>Back to Quick Quiz 7</b>.</a><hr width="60%" align="left">

<a name="aqq8"></a>
<p><b>Quick Quiz 8</b>:
But when I built the tool, I didn't find an <code>armmem</code>
program.
How am I supposed to test ARM code fragments???

</p><p><b>Answer</b>:
Just replace the litmus file's initial &ldquo;PPC&rdquo; with &ldquo;ARM&rdquo;
and put ARM assembly language into your litmus file and pass it
to the <code>ppcmem</code> program.
Yes, <code>ppcmem</code> is multilingual.
Perhaps this is because the researchers who created it have a variety of
native languages.
Or maybe because none of them live or work in the USA.  ;&ndash;)

<p><a href="#Quick%20Quiz%208"><b>Back to Quick Quiz 8</b>.</a><hr width="60%" align="left">

<a name="aqq9"></a>
<p><b>Quick Quiz 9</b>:
Where can I find out more about the formal model underlying this tool?

</p><p><b>Answer</b>:
Currently the best source of information is the PLDI 2011 paper entitled
&ldquo;Understanding Power Multiprocessors&rdquo;, which may be found
<a href="http://www.cl.cam.ac.uk/~pes20/ppc-supplemental/">here</a>.
This paper covers memory barriers, but not atomic instruction sequences.
Additional papers that include atomic-instruction-sequence extensions
to this model are likely to appear Real Soon Now.


<p><a href="#Quick%20Quiz%209"><b>Back to Quick Quiz 9</b>.</a><hr width="60%" align="left"><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools">Development tools</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/470681/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor471122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Building the PPCMEM web interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2011 10:11 UTC (Thu)
                               by <b>scottt</b> (guest, #5028)
                              [<a href="/Articles/471122/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>
Mad props to the authors and to Mr. McKenney for the well written article.
</p>

I wanted to compile PPCMEM myself and found out that:
<ol>
<li>It's implemented in Ocaml</li>
<li>Compiling the web interface locally was non-trivial. There were some sources missing from the tarball and the Makefile required some hacking</li>
</ol>
I documented how I got it working <a href="http://blog.scottt.tw/2011/12/compiling-web-interface-of-ppcmemarmmem.html">here</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/471122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor471232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank you for the Fedora build instructions!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2011 15:37 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/471232/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As you might have guessed, I run Ubuntu, so it just worked for me.  Thank you for persisting in getting it working on Fedora, and even more thanks for posting the instructions for getting it running!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/471232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor471238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank you for the Fedora build instructions!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2011 16:27 UTC (Thu)
                               by <b>scottt</b> (guest, #5028)
                              [<a href="/Articles/471238/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect you built the ppcmem curses UI but not the web interface? <br>
<p>
For the web interface, the Ocaml code gets compiled into a system.js file but the ppcmem-tarball.tar.gz I downloaded was still missing a few other required Javascript files. (the Makefile rule for taring up the project missed a few)<br>
<p>
Luckily the files missing from the source tarball are readily available from the web site so I was able to build and run that pretty point and click web interface locally in the end :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/471238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor471254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank you for the Fedora build instructions!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2011 16:53 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/471254/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are quite correct -- I was content to use the University of Cambridge web site, so didn't try to build my own.  I just used the ppcmem program.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/471254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor471643"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Validating Memory Barriers and Atomic Instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2011 16:17 UTC (Sat)
                               by <b>timur</b> (guest, #30718)
                              [<a href="/Articles/471643/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Awesome!  I work for Freescale on the PowerPC kernel, so I really appreciate the effort, and I'm going to be thoroughly studying this article.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/471643/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor472266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Validating Memory Barriers and Atomic Instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2011 13:49 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/472266/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;and yes, academics consider x86 to be a weak-memory system</font><br>
<p>
Uhm, and how the Alpha is considered: ultra-weak? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/472266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor472491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Is Alpha considered ultra-weak?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2011 17:31 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/472491/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Heh!  From what I can see, many academics consider even ARM and PowerPC to be ultra-weak.  Then again, many such academics have never heard of RCU, so they would likely put Alpha into the same bucket as ARM and PowerPC.  :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/472491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor473365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Is Alpha considered ultra-weak?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 22, 2011 17:44 UTC (Thu)
                               by <b>mfedyk</b> (guest, #55303)
                              [<a href="/Articles/473365/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about MIPS? My understanding is that it is a very weak memory architecture. How does it compare? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/473365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor473388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Is MIPS considered?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 22, 2011 18:31 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/473388/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have yet to see a definition of the MIPS memory-ordering model, but I do hope to at some point.  Until then, I have no idea, but MIPS is rumored to have a weak memory model similar to ARM and PowerPC.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/473388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
