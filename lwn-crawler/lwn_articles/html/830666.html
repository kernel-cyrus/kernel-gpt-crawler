        <!DOCTYPE html>
        <html lang="en">
        <head><title>Conventions for extensible system calls [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/830666/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/830524/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/830666/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Conventions for extensible system calls</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 8, 2020</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2020-Linux_Plumbers_Conference">LPC</a>
</div>
The kernel does not have just one system call to rename a file; instead,
there are three of them: <a
href="https://man7.org/linux/man-pages/man2/renameat.2.html"><tt>rename()</tt>,
<tt>renameat()</tt>, and <tt>renameat2()</tt></a>.  Each was added when the
previous one proved unable to support a new feature. A similar story has
played out with a number of system calls: a feature is needed that doesn't
fit into the existing interfaces, so a new one is created — again.  At the
2020 <a href="https://linuxplumbersconf.org">Linux Plumbers Conference</a>,
Christian Brauner and Aleksa Sarai ran a pair of sessions focused on the
creation of future-proof system calls that can be extended when the need
for new features arises.
<p>
Brauner started by noting that the problem of system-call extensibility has
been discussed repeatedly on the mailing lists.  The same arguments tend to
come up for each new system call.  Usually, developers try to follow one of
two patterns: a full-blown multiplexer that handles multiple functions
behind a single system call, or creating a range of new, single-purpose
system calls.  We have burned ourselves and user space with both, he said.
There are no good guidelines to follow; it would be better to establish some
conventions and come to an agreement on how future kernel APIs should be
designed.  
<p>
The requirements for system calls should be stronger, and they should be
well documented.  There should be a minimal level of extensibility built
into every new call, so that there is never again a need to create a
<tt>renameat2()</tt>.  The baseline, he said, is <a
href="/Articles/585415/">a flags argument</a>; that convention is arguably
observed for new system calls today.  This led to a brief side discussion
on why the type of the flags parameter should be <tt>unsigned int</tt>; in
short, signed types can be sign extended, possibly leading to the setting
of a lot of unintended flags.
<p>
Sarai took over to discuss the various ways that exist now to deal with
system-call extensions.  One of those is to add a new
system call,
which works, but it puts a big burden on user-space code, which must change
to make use of this call.  That includes checking to see whether the new
call is supported at all on the current system and falling back to some
other solution in its absence.  The other extreme, he said, is
multiplexers, which have significant problems of their own.
<p>
Yet another
approach is to set a flag (on calls that support flags, obviously) and make
the system call take a variable number of arguments; among other things,
variadic calls are difficult for C libraries to support properly.  It is
necessary to pass all possible arguments, leading to passing garbage on the
stack into the kernel.  System
calls could be designed with fixed-size structs as arguments, with the idea
that these structs would contain enough padding to handle any future
needs.  The problem with this approach, he said, was that it requires an
ability to predict the future, which turns out to be difficult to do.
<p>
Finally, he said, the problem could be solved by getting and using a time
machine.  This solution, too, suffers from practical difficulties.
<p>
<h4>Extensible structs</h4>
<p>
Brauner and Sarai are pushing a different solution that they call
"extensible structs"; it is the approach used in the design of the <a
href="https://man7.org/linux/man-pages/man2/openat2.2.html"><tt>openat2()</tt></a>
system call.  This mechanism works by marshaling parameters to a system call 
into a single C structure; a pointer to that structure and the size of the
structure are passed as the parameters to the system call.  That size
parameter
acts as a sort of version number.  When the time comes to extend the
system call in a way the requires passing new data to the kernel, new
fields are added to the end of the structure, increasing the size.  Those
new fields are always 
designed so that a value of zero implies the behavior that existed before
those fields were added.
<p>
When the system call is invoked from user space, the kernel compares the
structure size passed in to its own idea of how big the structure should
be.  If the size from user space is smaller, that indicates that the caller
expects to use an older version of the system call; the fields that
user space did not provide are filled with zeroes and the call proceeds as
usual, with no visible change in behavior.  If, instead, the kernel's size
is smaller than the structure passed from user space, then the kernel is
the older side.  In that case, all of the excess fields (from the kernel's
point of view) are checked; if they are all zero, the call can proceed.
Otherwise, the call fails with an <tt>E2BIG</tt> error, since user space is
requesting functionality that the kernel does not know how to provide.
<p>
H. Peter Anvin questioned the use of the <tt>E2BIG</tt> return code.  Sarai
responded that its assigned meaning is "argument list too long"; it is a
bit weird, he said, but "it makes sense if you squint".
<p>
<blockquote>
<a href="/Articles/830675/"><img
src="https://static.lwn.net/images/conf/2020/lpc/syscalls-sm.png" alt="[Aleksa Sarai, Arnd
Bergmann, Christian Brauner, and Florian Weimer]"
title="Aleksa Sarai, Arnd Bergmann, Christian Brauner, and Florian Weimer"
border=0 class="photo"></a>
</blockquote>
<p>
Brauner emphasized that the rules should prohibit
any further multiplexer system calls.  This is
almost universally agreed on now.  <tt><a
href="https://man7.org/linux/man-pages/man2/bpf.2.html">bpf()</a></tt> is
not an extensible system call; it is a multiplexer that happens to use
extensible structs.  So <tt>bpf()</tt> is not an example of how system
calls should be designed in the future.  The GNU C Library developers have
also made it clear that they would rather not see any more multiplexer
calls, since they are hard to deal with at that level.  Arnd Bergmann said
that a number of developers try to block multiplexer system calls, but it
is hard to see them all; that is why this rule should be in the
documentation, Brauner replied.
<p>
Anvin asked why the structure size is passed as a separate argument rather
than being embedded in the structure itself.  Brauner replied that it feels
more "C-like" to pass the size in the argument list, but that it doesn't
matter that much in the end.  The community should pick one convention or
the other, though.  Anvin said that the separate size can create problems
if the struct is being passed through different user-space layers that may
have different ideas of what its proper size is; that could result in
passing bad data to the kernel.
<p>
Kees Cook, instead, said that confusion in user space is preferable to
confusion in the kernel.  There could be problems if the kernel reads the
size from within the structure, then uses that size to read the structure
itself in to kernel space.  That size might have changed in between the two
reads, possibly opening up vulnerabilities within the kernel.  Thus, he
said, the size is better passed as a separate element.  When asked which
convention would work better for C libraries, Florian Weimer responded that
he didn't have a strong opinion either way.
<p>
Brauner said that, in the past, Al Viro has <a
href="/ml/linux-kernel/20200719171054.GK2786714%40ZenIV.linux.org.uk/">called</a>
extensible structs a "<q>crap insertion vector</q>", saying that they
could be used to sneak new features into the kernel without review.  That
view doesn't hold up, Brauner said; as an example, the feature that
prompted this reaction was indeed caught in review.  There is not a problem
there that is worse than with any other system call, he said.
<p>
This part of the discussion closed with Brauner saying that the new
conventions need to be added to the documentation.  The current <a
href="https://www.kernel.org/doc/html/latest/process/adding-syscalls.html">documentation
on adding system calls</a> is not up to date; he tried to update it in the
past the but that effort "went largely unnoticed".  He has been trying to build
more consensus around the extensible structs idea; meanwhile, he has landed
two new system calls using it.  He will be working on a new version of the
documentation patch that is intended to describe the current best practices
as he sees them.


<h4>Probing feature support</h4>
<p>
Extensible structs might be a solution to the problem of adding features to
system calls, but they do not, in themselves, address the other part of the
problem: helping user space to figure out which features are actually
supported on a given system.  As Brauner noted, programs normally have to
adopt a sort of trial-and-error approach, where they try to exercise each
feature in question and see if it actually works.  This process is painful
at best, and it can become expensive, especially in libraries and
short-running programs.  It should be possible to do better.  The
conversation on just how to do better got started in this session, then
continued in a birds-of-a-feather session later.
<p>
Sarai mentioned one proposal that has been circulating: add a "no-op" flag
to the system call.  The kernel would respond by returning a copy of the
extensible struct with all valid flag bits set and non-flag fields filled
with the highest supported value.  A unique error code would be returned if
the queried operation is not supported at all.  Bergmann quickly pointed
out that this flag would turn the system call into a sort of multiplexer
with multiple functions, but noted that he could see the upside of doing
things that way.
<p>
The alternative would be to create a new system call dedicated to checking
which features are supported by other system calls.  This would not be
entirely straightforward to implement, since it requires adding a new
infrastructure within the kernel for defining system-call features.
Brauner noted that there are two specific types of extensibility that would
have to be handled: adding a new flag, and increasing the size of the
struct.
<p>
Bergmann suggested that a minimal solution might be to add a counter in the
VDSO area exported by the kernel to user space; every time a feature is
added, the counter would be incremented.  Cook answered that it was a
little too minimal; user space would benefit more from the ability to
inquire about the availability of specific features.  Weimer said that this
would make writing portable software more difficult, since it would be
necessary to test all possible permutations of features, but Cook responded
that this problem already exists, and the ability to query features would
just improve visibility.  Mark Rutland suggested starting with a single
system call defining exactly which information would be exposed; Brauner
said that <a
href="https://man7.org/linux/man-pages/man2/clone3.2.html"><tt>clone3()</tt></a>
might be a good starting point.
<p>
There appeared to be a consensus that a separate system call is the right
way to solve this problem, so the discussion turned to what this system
call would look like.  Brauner started with a suggestion that this new call
would take the number of the system call of interest, and would return the
current set of valid flags and struct size.  Sarai pointed out that
<tt>openat2()</tt> has two flags arguments, complicating the situation.
Weimer, instead, said he would like to be able to query whether <a
href="https://man7.org/linux/man-pages/man2/vfork.2.html"><tt>vfork()</tt></a>
is available, but there's no flags argument there at all.
<p>
Mark Rutland suggested an API that would look something like:
<p>
<pre>
    int sys_features(int syscall_no, u32 *map, size_t mapsize);
</pre>
<p>
The kernel would treat <tt>map</tt> as a bitmap to be filled in describing
the available features for the requested system call.
Each system call would have a set of constants for each feature that may or
may not be present, each corresponding to one bit that would be set in
<tt>map</tt> if the feature is available.  This proposal seemed to gain
some support during the discussion.
<p>
Brauner said that there is also a need to automate the process of adding a
system call to the kernel — preferably one not written in Perl.  It could
perform a number of checks, including whether the struct size is described
correctly and the <tt>sys_features()</tt> information is correct.  Bergmann
suggested extending the <tt>DECLARE_SYSCALL()</tt> macro in the kernel to
take the bitmap of supported features as an additional argument.
<p>
The conversation wandered on for a little longer, but the form of the
 outcome was already clear.  For the extensible structs portion, the
main action item will be to update the documentation to reflect the new
consensus (if there is truly a consensus) on how extensibility should be
handled.  For the feature-query system call, the task will be to write some
code showing how it would actually work.  Once the concept hits the mailing
lists it may end up changing significantly.  One can only hope that the end
result gets things right, so we won't need a <tt>sys_features2()</tt> in
the future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls">System calls</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2020">Linux Plumbers Conference/2020</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/830666/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor830951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 15:33 UTC (Tue)
                               by <b>famzheng</b> (subscriber, #121411)
                              [<a href="/Articles/830951/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What happened to &quot;everything is a file&quot;, why not just expose features with sysfs in a well defined way so that we don&#x27;t need yet another syscall to probe for syscalls?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 16:45 UTC (Tue)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/830962/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Especially since we already have a format for describing struct layouts for tracepoints - i.e. /sys/kernel/debug/tracing/events/*/*/format<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 0:28 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/830993/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some downsides I can see with that are file descriptor resource limits (which is unlikely), but setups which restrict which paths can be accessed isn&#x27;t going to be getting less common.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 0:54 UTC (Wed)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/830994/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All you need is CRUD:)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 6:56 UTC (Wed)
                               by <b>diconico07</b> (guest, #117416)
                              [<a href="/Articles/831002/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My main concern with using files would be performance, you may end up calling this feature checking syscall quite often (maybe even do that within C library), so between calling a dedicated syscall and opening,reading,closing a file (min 3 syscalls) the dedicated syscall wins. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 7:29 UTC (Wed)
                               by <b>famzheng</b> (subscriber, #121411)
                              [<a href="/Articles/831005/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that&#x27;s a fair concern, can open/read/close be made a single syscall eg with io_uring?<br>
<p>
The file approach may have much better introspective capabilities. It&#x27;s easy to version it. If it were implemented a syscall, how do we probe for the feature of this probing syscall itself?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 11:01 UTC (Wed)
                               by <b>artizirk</b> (subscriber, #113443)
                              [<a href="/Articles/831026/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
readfile() could work quite well for this usecase.<br>
<p>
<a href="https://lwn.net/Articles/813827/">https://lwn.net/Articles/813827/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 16:04 UTC (Wed)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/831074/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do not see this as a big problem, this feature-checking can be done once during the first call and then cached. I think glibc already does such things today (by trying to use a syscall and if the result is ENOSYS, remember that and fall back to something else).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 6:17 UTC (Thu)
                               by <b>notriddle</b> (subscriber, #130608)
                              [<a href="/Articles/831127/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That’s the minimum bar, then. Whatever design they go with has to be faster than the trial-and-error version.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor830955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 15:46 UTC (Tue)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/830955/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      I'm surprised nobody mentioned the security issues with this approach&nbsp;&ndash; the struct containing the arguments would now have embedded pointers, including pointers to e.g. filenames, but would be impossible to securely inspect using <tt>seccomp</tt> or similar mechanisms.

<p>Or has this somehow been solved (in a generic fashion) while I wasn't looking?
      
          <div class="CommentReplyButton">
            <form action="/Articles/830955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 18:14 UTC (Tue)
                               by <b>nickodell</b> (subscriber, #125165)
                              [<a href="/Articles/830971/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are various ideas for how to address that: <a href="https://lwn.net/Articles/822256/">https://lwn.net/Articles/822256/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 1:05 UTC (Wed)
                               by <b>imMute</b> (guest, #96323)
                              [<a href="/Articles/830995/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;but would be impossible to securely inspect using seccomp or similar mechanisms.</font><br>
<p>
Impossible today, or impossible forever?  *Today* seccomp can&#x27;t inspect embedded pointers, but there&#x27;s no reason it can&#x27;t in the future.<br>
It&#x27;s not a great idea to design APIs around current limitations, especially when said limitations have other reasons for being overcome.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831019"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 10:29 UTC (Wed)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/831019/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kees has been on how to expand seccomp to deal with pointer-to-struct syscalls (he gave a talk about it at LPC as well, and we&#x27;ve been talking with him about this problem as well). It should be noted that this really isn&#x27;t a new problem -- there are already other syscalls which take struct pointers and seccomp can&#x27;t filter them properly right now either (though admittedly, the extensibility does require a bit more design work if we want filters to also be forward-compatible).<br>
<p>
I do want to point out that (even though I assume it was just an example), filenames are something you don&#x27;t want to try to restrict with seccomp. That&#x27;s what LSMs are for -- there&#x27;s no reasonable way to be sure that a path-based filter will actually stop someone from accessing a path.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831019/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831437"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2020 12:43 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831437/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
I do want to point out that (even though I assume it was just an example), filenames are something you don't want to try to restrict with seccomp. 
</blockquote>
The driving use case for modern seccomp was web browsers. Absolutely all of these have seccomp filters that filter by path, because glibc and other libraries routinely used by sandboxed rendering processes want to access particular paths -- usually root-writable-only, things like stuff under /sys, /dev, /usr/lib, that sort of thing -- but the whole point of the sandbox is that they can't go rootling around in your home directory (or, users being prone to weird stuff, /dir-off-the-root-directory-where-I-keep-my-bank-account-details).
<blockquote>
That's what LSMs are for -- there's no reasonable way to be sure that a path-based filter will actually stop someone from accessing a path.
</blockquote>
Having unprivileged web browsers hack your LSM configuration is unlikely to be the most practical approach. (And it is actually perfectly reliable to use this method to stop people accessing all paths other than a limited subset which is rarely-mutated and is only-root-writable: you can rely on races not being present and you don't need to worry about hostile attackers being able to modify the directories you're allowing through.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/831437/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor831075"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 16:29 UTC (Wed)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/831075/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even if they don&#x27;t solve that problem in general, it would be possible to arrange that any syscall that follows the extensible system call pattern first gets decoded into the logical arguments and that gets passed to seccomp. Of course, this exposes the opposite issue: newer kernels will effectively switch to a version of the syscall with more arguments and flags than existing seccomp filters are expecting, and something has to decide what to do about that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831075/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 20:16 UTC (Wed)
                               by <b>Twistlock</b> (guest, #135955)
                              [<a href="/Articles/831100/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;m surprised nobody mentioned the security issues with this approach – the struct containing the arguments would now have embedded pointers, including pointers to e.g. filenames, but would be impossible to securely inspect using seccomp or similar mechanisms.</font><br>
<p>
I don&#x27;t think the pressing issue here is with embedded pointers, since seccomp can&#x27;t filter pointers regardless if they&#x27;re embedded in a struct. The problem is more with arguments that would have been passed by value, but will now be hidden behind a struct pointer (in future syscalls that follow this design).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 21:34 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/831106/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like what we need is some way of saying &quot;syscalls take one argument, a struct passed by value&quot;.<br>
<p>
Might play havoc with normal C calling conventions, though :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 12:00 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/831152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The multicians found they needed to take a similar approach. For library and system calls that took more than a very few parameters, they passed a versioned struct.<br>
<p>
--DRBrown.TSDC@Hi-Multics.ARPA(:-))<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831438"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2020 12:47 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831438/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s easy enough -- the problem is preventing a parallel userspace thread from modifying the struct between the point at which the seccomp filter evaluates it and the point at which the args are used. This problem doesn&#x27;t arise with actual arguments because those end up on the kernel stack, which userspace cannot modify at all. (And no, marking the struct as nonmodifiable by userspace for the duration of the syscall would be horrendously expensive, and because of the page granularity of protection changes would tend to mark a lot of other variables as nonmodifiable as well, with likely-disastrous results.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831438/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831441"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2020 13:47 UTC (Mon)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/831441/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The solution being proposed is that seccomp does the copy first, operates on it, and then gives the copied data (which has been checked by the filter) to the syscall proper. The kernel has to do the copy anyway, doing the copy earlier in the syscall path and then re-using the copy would add no overhead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831441/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2020 17:29 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This will probably take some interesting fiddling around, given that the copies now are scattered all over the place in countless copy_from_user calls. I look forward to watching the fireworks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 15:56 UTC (Tue)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/830956/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I remain confused by using &quot;unsigned int&quot; for flags. Using &quot;unsigned long&quot; makes more sense as it allows for 64-bit only features to be selected in bits which don&#x27;t exist for 32-bit machines, leaving space in the low flags for features which are useful for both 32 and 64 bit machines.<br>
<p>
Somewhere we made a mess of this already is with hugetlb size flags. Bits 26-31 are used for order 0-63. But there&#x27;s no need for a 32 bit process to be able to specify an order above 31, so we would have been better off using bits 27-32 which lets 32-bit processes ask for order 0-31 and 64 bit processes can go all the way to 63.<br>
<p>
(Actually there&#x27;s no need to support orders below 13, so we could stuff the bits even harder into 28-33; supporting orders 13-28 on 32-bit and 13-63 on 64-bit, but some might complain that order 30 (1GB) pages couldn&#x27;t be requested on x86-32)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 18:50 UTC (Tue)
                               by <b>fenncruz</b> (subscriber, #81417)
                              [<a href="/Articles/830974/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whats the logic behind using the size of the struct instead of just passing a version number?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 19:44 UTC (Tue)
                               by <b>Villemoes</b> (subscriber, #91911)
                              [<a href="/Articles/830978/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A version number wouldn&#x27;t allow the &quot;new userspace on old kernel&quot;. As the older kernel would not in now how much of userspace memory to check for all-zeroes, an old kernel would always have to reject too high version numbers, instead of gracefully handling the many cases where userspace hasn&#x27;t actually used any of the newer features.<br>
<p>
Also, having the size passed directly avoids each syscall having their own version-&gt;size table, avoiding a cache miss and a place to worry about Spectre.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor831003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 7:09 UTC (Wed)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/831003/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I fail to see how do these structs make a difference. The struct size (i.e. version number) is nothing else than the number at the end of rename() or a new flag. If either kernel or userspace does not support it, it doesn&#x27;t work.<br>
<p>
I used to work on Android userspace drivers, which use similar versioning conventions in their APIs. Versioned structs didn&#x27;t simplify anything there. What they do is to complicate matters if you what to handle them with a code generator or wrap them somehow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 10:33 UTC (Wed)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/831020/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      I wrote a pretty detailed explanation for how the compatibility works in the <a href="https://man7.org/linux/man-pages/man2/openat2.2.html">openat2 man page</a>. The short answer is that the struct size isn't just a version number, it allows the kernel to know how much of the passed struct userspace knows about (and in the case of an old kernel, whether the userspace program is requesting a feature it doesn't know about). Creating a new syscall means that userspace has to support both the old and new versions so that it can work on old kernels, but with this design userspace doesn't need to do anything to continue to work on old kernels (assuming it doesn't try to use a feature the old kernel doesn't support).
      
          <div class="CommentReplyButton">
            <form action="/Articles/831020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 12:23 UTC (Wed)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/831028/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wrote a pretty detailed explanation for how the compatibility works in the openat2 man page.</font><br>
<p>
It still doesn&#x27;t make sense to me.<br>
<p>
<font class="QuotedText">&gt; The short answer is that the struct size isn&#x27;t just a version number, it allows the kernel to know how much of the passed struct userspace knows about (and in the case of an old kernel, whether the userspace program is requesting a feature it doesn&#x27;t know about).</font><br>
<p>
Using *any* number instead of size tells the kernel the same; as long that number increases with the number of supported features. And that&#x27;s a version number.<br>
<p>
An actual version number has the (admittedly questionable) benefit, that you could pack parameters for additional features into existing, unused bits. The struct size doesn&#x27;t allow this. You have to append parameter to the struct&#x27;s end.<br>
<p>
<font class="QuotedText">&gt; Creating a new syscall means that userspace has to support both the old and new versions so that it can work on old kernels, but with this design userspace doesn&#x27;t need to do anything to continue to work on old kernels (assuming it doesn&#x27;t try to use a feature the old kernel doesn&#x27;t support).</font><br>
<p>
The algorithm for compatibility is simple: always use the oldest syscall that supports whatever you&#x27;re trying to do.<br>
<p>
These versioned structs (or version numbers) just move the problem from userspace to kernel, but don&#x27;t solve anything.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 14:31 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/831039/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Using *any* number instead of size tells the kernel the same; as long that number increases with the number of supported features. And that&#x27;s a version number.</font><br>
<p>
The main benefit with using a size is that when running on an older kernel, that kernel now knows how much to check for all-zeros before rejecting the call. If I use a bigger structure than it knows about, but it is all zero beyond what it does, the old kernel can still satisfy the call. With a version number, anything it doesn&#x27;t know about is automatically unsatisfiable since it doesn&#x27;t know how far into the struct to check.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 17:36 UTC (Wed)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/831084/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, the trick only works if these zeros don&#x27;t carry any additional meaning by themselves.<br>
<p>
But just to be clear. I&#x27;m not speaking in favor version numbers either. IMHO if there&#x27;s an incompatible change, a new syscall should be introduced. Anything else is fragile fiddling.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 19:26 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/831099/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well, the trick only works if these zeros don&#x27;t carry any additional meaning by themselves.</font><br>
<p>
The new semantics have to be able to express the old semantics as well, so you may as well make that case the zero case for the new fields.<br>
<p>
<font class="QuotedText">&gt; IMHO if there&#x27;s an incompatible change, a new syscall should be introduced. Anything else is fragile fiddling.</font><br>
<p>
IIRC, syscall numbers are a fairly limited resource. I don&#x27;t know how close we are to the limit though. I remember some LWN article mentioning it, but maybe it was in reference to the limit being lifted? Does anyone have numbers on how often syscall structures get expanded?<br>
<p>
In any case, I think everyone would agree that most syscalls will need some future changes over time (especially ones being introduced today). I think it&#x27;s better to think about how those changes will work into the future, both on the kernel and the userspace side. If completely different syscalls are made for structure expansions, it means, as a user, I need to either bind the syscall myself or wait for glibc/some other library to expose it and have some hierarchy of call precedence for what I&#x27;m doing. I don&#x27;t think that seems to make sense in the long run personally.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 6:13 UTC (Thu)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/831125/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well, the trick only works if these zeros don&#x27;t carry any additional meaning by themselves.</font><br>
<p>
Yes, that is part of the API promise. You need to be able to support the old semantics on a new kernel anyway. And this isn&#x27;t a new requirement either -- any fixed-size struct extension system also has to require that zero means &quot;the old behaviour&quot;. I&#x27;m not sure if there is a kernel API that doesn&#x27;t act like this.<br>
<p>
<font class="QuotedText">&gt; IMHO if there&#x27;s an incompatible change, a new syscall should be introduced. Anything else is fragile fiddling.</font><br>
<p>
This isn&#x27;t about handling incompatible changes, this is about &quot;we want to add a new feature to an existing syscall&quot;. Without extensible structs (in the most extreme version of the view you&#x27;ve described) you would need to create a new syscall each time you wanted to add a field to a struct. I&#x27;m sure you&#x27;d agree that this would be ludicrous, since adding new syscalls for each new feature creates extra work for userspace (not to mention that a lot of newer syscalls don&#x27;t have glibc wrappers so all of the fallback code has to be open-coded into every project that uses that syscall).<br>
<p>
The only thing that this design allows which is different to previous extension designs is that you can add fields to a structure passed to a syscall in a way that preserves forwards and backwards compatibility, without having to reserve a fixed amount of padding (the issue with reserving a fixed amount of padding is that you have to be able to predict how many extensions will be needed for the entire life of that syscall -- it&#x27;s just simpler to not need to worry about it). That&#x27;s really all this is -- though it does have the nice consequence of removing a whole bunch of needless busywork from userspace.<br>
<p>
It&#x27;s not even that new! In addition to clone3() and openat2(), some older syscalls (like sched_set_attr(), perf_event_open(), and buried inside the bpf() union) all use the same design. All we&#x27;re trying to do is to document this as being one of the few ways extensible syscalls should be designed (the other major way being the classic flags argument).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 12:06 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/831157/">Link</a>] 
      </p>
      
      </div>
      </summary>
      As always, <I>communicating</I> a new, better algorithm is harder than inventing one.  The multicians did a similar thing, but the best reference is a retrospective by Paul Stachour, published years later (I was his editor (;-)) https://cacm.acm.org/magazines/2009/11/48444-you-dont-know-jack-about-software-maintenance/fulltext
      
          <div class="CommentReplyButton">
            <form action="/Articles/831157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor831130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conventions for extensible system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 6:39 UTC (Thu)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/831130/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can&#x27;t stop thinking that the true problem here is &#x27;machine-readable&#x27; documentation for syscall. Some form of BNF to declare available syntax. One more problem is that syscall must be binary and fast. But docs aren&#x27;t. Should kernel keep a ascii version of description of each syscall in machine and human readable form?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
