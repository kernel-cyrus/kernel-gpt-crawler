        <!DOCTYPE html>
        <html lang="en">
        <head><title>Supporting 64-bit ARM systems [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/506148/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/505476/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/506148/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Supporting 64-bit ARM systems</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 10, 2012</br>
           </div>
ARM is one of the most successful processor architectures ever created;
most of us possess several ARM cores for every x86 processor we have.  ARM
is very much thought of as an embedded systems processor; it is focused on
minimal power use and the ability to be built into a variety of system-on-chip
configurations.  The "small systems" image of ARM is certainly encouraged
by the fact that ARM processors are all 32-bit only.  That situation is
about to change, though, with the arrival of 64-bit ARM processors.  Linux
will be ready for these systems — the first set of 64-bit ARM support
patches have just been posted — but there is still some debate around a
couple of fundamental decisions.
<p>
One might well wonder whether a 64-bit ARM processor is truly needed.
64-bit computing seems a bit rich even for the fanciest handsets or
tablets, much less for the kind of embedded controllers where ARM
processors predominate.  But mobile devices are beginning to push the
memory-addressing limits of 32-bit systems; even a 1GB system requires the
use of high memory in most configurations.  So, even if the heavily
foreshadowed ARM server systems never materialize, there will be a need for
64-bit ARM processors just to be able to efficiently use the memory that
future mobile devices will have.  "Mobile" and "embedded" no longer mean
"tiny." 
<p>
Naturally, Linux support is an important precondition to a successful
64-bit ARM processor introduction, so ARM has been supporting work in that
area for some time.  The <a
href="http://gcc.gnu.org/ml/gcc-patches/2012-05/msg01694.html">initial GCC
patches</a> were posted back in May, and the <a href="/Articles/505682/">first
set of kernel patches</a> was posted by Catalin Marinas on July&nbsp;6.
All this code exists despite the fact that no 64-bit ARM hardware is yet
available; it all has been developed on simulators.  Once the hardware
shows up, with luck, the software will work with a minimum of tweaking
required.
<p>
64-bit ARM support involves the addition of thousands of lines of new code
via a 36-part patch set.  There are some novel features, such as the
ability to run with a 64KB native memory page size, and a lot of important
technical decisions to be reviewed.  So the kernel developers did what one
would expect: they started complaining about the name given to the
architecture.  That name ("AArch64") strikes many as simultaneously
redundant (of course it is an architecture) and uninformative (what does
"A" stand for?).  Many would prefer either ARMv8 (which is the actual
hardware architecture name—"AArch64" is ARMv8's 64-bit operating mode) or
arm64.
<p>
Arguments in favor of the current name include the fact that it is already used
to identify the architecture in the ELF triplet used in binaries; using the
same name everywhere should help to reduce confusion.  But, then, as Arnd
Bergmann <a href="/Articles/506158/">noted</a>: "<q>If everything else
is aarch64, we should use that in the kernel
	directory too, but if everyone calls it arm64 anyway, we should
	probably use that name for as many things as possible.</q>"

Jon Masters <a href="/Articles/506159/">added</a> that, in classic
contrarian style, he likes the name as it is; Fedora is planning to use
"aarch64" as the name for its 64-bit ARM releases.  Others, such as <a
href="/Articles/506160/">Ingo Molnar</a>, argue in favor of changing the
name now when it is relatively easy to do.  Catalin <a
href="/Articles/506161/">seems inclined</a> to keep the current name but
says he will think about it before posting the next version of the patch
series.
<p>
An arguably more substantive question was raised by a number of developers:
wouldn't it make more sense to unify the 32-bit and 64-bit ARM
implementations from the outset?  A number of other architectures (x86,
PowerPC, SPARC, and MIPS) all started with separate implementations, but
ended up merging them later on, usually with some significant pain involved.  Rather
than leave that pain for future ARM developers, it has been suggested that,
perhaps, it would be better to start with a unified implementation.
<p>
There are a lot of reasons given for the separate 64-bit ARM architecture
implementation.  Much of the relevant thinking can be found in <a
href="/Articles/506165/">this note from Arnd</a>.  The 64-bit ARM
instruction set is completely different from the 32-bit variety, to the
point that there is no possibility of writing assembly code that works on
both architectures.  The system call interfaces also differ significantly,
with the 64-bit version taking a more standard approach and leaving a lot
of legacy code behind.  The 64-bit implementation hopes to leave the entire
32-bit ARM "platform" concept behind as well; indeed, as Jon <a
href="/Articles/506169/">put it</a>, there are hopes that it will be
possible to have a single kernel binary that runs on all 64-bit ARM systems from the
outset.  In general, it is said, giving AArch64 a clean start in its own
top-level hierarchy will make it possible to leave a lot of ARM baggage
behind and will result in a better implementation overall.
<p>
Others were quick to point out that most of these arguments have been heard
in the context of other architectures.  x86_64 was also meant to be a clean
start that dumped a lot of old i386 code.  In the end, things have turned
out otherwise.  It may be possible that things are different here; 32-bit
ARM has rather more legacy baggage than other architectures did, and the
processor differences seem to be larger.  Some have said that the proper
comparison is with x86 and ia64, though one gets the sense that the
AArch64 developers don't want to be seen in the same light as ia64 in
general.
<p>
This decision will come down to what the AArch64 developers want, in the
end; it's up to them to produce a working implementation and to maintain it
into the future.  If they insist that it should be a separate top-level
architecture, it is unlikely that others will block its merging for that
reason alone.  Of course, it will also be up to those developers to manage
a merger of the two in the future, should that prove to be necessary.  If
nothing else, life as a separate top-level architecture will allow some
experimentation without the fear of breaking older 32-bit systems; the
result could be a better unified architecture some years from now, should
things move in that direction.
<p>
Thus far, there has been little in the way of deeper technical criticism of
the AArch64 patch set.  Things may stay that way.  The code has already
been through a number of rounds of private review involving prominent
developers, so the worst problems should already have been found and
addressed.  Few developers have the understanding of this new processor
that would be necessary to truly understand much of the code.  So it may go
into the mainline kernel (perhaps as early as 3.7) without a whole lot of
substantial changes.  After that, all that will be needed is actual
hardware; then things should get truly interesting.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures-Arm">Architectures/Arm</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/506148/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor506251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2012 20:59 UTC (Tue)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/506251/">Link</a>] (35 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually in reading the differences between ARM32 and ARM64.. I kept thinking "Isn't this what happened with IA-64?" I wonder how long until some ARM manufacturer decides it is too much work to redo everything for the AArch64 platform and adds in 6-8 instructions to make ARM work with 64 bit instructions like AMD did with the x86_64? <br>
<p>
[And yes I know it is a lot more work than say 6-8 instructions but the amount of work sounds less than the Aarch64 takes.]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2012 21:39 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/506257/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As long as the ARMv8 instantiations run both instruction sets relatively well, I doubt it'll have quite the hurdle as IA64 did even if the ISAs are rather different.  <br>
<p>
The original IA64 parts couldn't run x86 code worth a crap, and so not only did you have to change everything to use the new 64-bit functionally, you had to change everything before the device was even useful.  That's a much bigger hurdle to clear.<br>
<p>
Assuming ARMv8 processors run ARMv7 code relatively well outside of AArch64 mode, then you could deploy quite a lot of hardware with ARMv8, and only move to 64-bit when needed.  I think that was much of the allure of x86-64.  Many people ran 32-bit OSes on 64-bit devices for quite awhile, until the 64-bit software matured.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 3:01 UTC (Wed)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/506274/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect the reverse: ARM users don't expect new ARM sub-architectures to run their code without changes, let alone new major architectures. Porting is a normal part of developing against ARM hardware. There just isn't a legacy base of binary software to worry about being compatible with.<br>
<p>
ARM64 doesn't have to run ARM32 code, it just has to be vaguely sane to port code for ARM32 over to ARM64.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 3:27 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/506277/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Disclaimer:  I haven't read the ARMv8 docs yet.  (Still wrapping my head around v7.)<br>
<p>
My understanding is that ARM generally has kept pretty strong source-level compatibility, and that includes at the assembly level (a few esoteric CPxx registers notwithstanding).  So, if I've optimized some algorithm in ARM v5 assembly, lets say, I have a pretty good chance of running that code on ARM v7 with at most a recompile, but quite likely just a relink.<br>
<p>
That's at least my understanding.  If that weren't true, then it seems like ARM could have shed more baggage more often.  After all, ARMv7 still "supports" Jazelle (albeit with a "null" implementation) for example.  Why would it need to, unless there's the expectation of running some ARMv5J binaries?<br>
<p>
If the ARMv8 AArch64 code is as different as everyone's saying, then it's not clear that you'll be compatible at the assembly level at all.  You may be compatible at the C/C++ level, except in cases where pointer sizes break you.  Porting may be vaguely sane, but I suspect still a bigger chore than moving among existing 32-bit ARM variants.<br>
<p>
In any case, I imagine the first year or two of ARMv8 hardware will come with 32-bit OSes, or at least 32-bit userlands on 64-bit kernels if ARMv8 supports that, until the software stabilizes.<br>
<p>
I guess it's time for me to start reading up on ARMv8, eh?  *sigh*  I just finished absorbing a couple thousand pages of docs on ARM Cortex-A15 and the current round of AXI/ACE protocols....<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 3:55 UTC (Wed)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/506279/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for that. I didn't realise that ARM arches retained such a high level of source compatibility despite continually breaking binary compatibility. <br>
<p>
I've only dealt with ARM in a few areas like mutex/locking asm helpers, where the best sequence to use is different for different sub-architectures.<br>
<p>
I can see that the break of source compatibility would make v8/ARM64 a bigger challenge if perfect source-level ASM compatibility has been the norm up until now. It still sounds more like an ia32-to-x86_64 move than an ia32-to-itanic move, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 7:09 UTC (Wed)
                               by <b>cmarinas</b> (subscriber, #39468)
                              [<a href="/Articles/506283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The assembler syntax is different. It has some similarities for a few mnemonics but you cannot compile one into the other (like we could do with the Thumb-2 unified syntax). The register names are different: R0 on 32-bit vs X0 on 64-bit. Even the comment syntax has been changed from "@" to "//" (because of some clashes of the former).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor507155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2012 21:58 UTC (Tue)
                               by <b>Tuna-Fish</b> (guest, #61751)
                              [<a href="/Articles/507155/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ARMv8 really is that different. As 64-bit forced break in backcompat, they got rid of everything they felt was not a good idea in a modern instruction set. Gone are the multiple load instructions, simd on gprs and conditions on everything. Instead, we now have a zero reg and 31 gprs, IP and SP(!) not included.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/507155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor507170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2012 22:40 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/507170/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sad to see the IP (aka PC) leave the GPR file.  It's a concept that was past its freshness date in the 80s.  <br>
<p>
But SP's not a GPR?  Wow...  It makes a certain amount of sense, really, since stack pointers move in rather particular ways.  Treating it specially may help when speculating memory accesses.  I'm going to guess they have dedicated ways of generating SP-relative addresses for local variables, along with frame pointers.<br>
<p>
Otherwise, it sounds very MIPS-y, at least superficially.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/507170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor506261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2012 21:55 UTC (Tue)
                               by <b>stevenb</b> (guest, #11536)
                              [<a href="/Articles/506261/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps this isn't so easy for ARM as it was for x86_64. The instruction length on i386 and x86_64 is basically variable, so the x86_64 instructions sometimes are just the same opcodes with a different or extra prefix. On ARM you don't have that, ehm, luxury?<br>
<p>
I just hope they're not going to do a 64-bits Thumb :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor506270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 2:45 UTC (Wed)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/506270/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The biggest problem with IA64 seemed to be that the early parts were crap. All the parts were and are expensive and confined to pricey big iron.<br>
<p>
They implemented ia32 emulation, but so slowly that they'd have been better off not doing so and requiring software emulation with a few helper instructions from the outset.<br>
<p>
Because of the big-end-of-town focus, most of the commercial software for Itanium only came in special price-gouging editions, further inflating its already uncompetitive costs.<br>
<p>
More importantly, they were really expensive parts to make and were based on a completely new very long instruction word design that turned out not to perform half as well in reality as it did in theory. It also relied on compilers to do a huge amount of work, but the compilers just weren't ready for it. They had huge caches (esp. for the time), low yields, and insanely expensive packaging with complex daughterboards. There was no such thing as a low-cost, entry-level Itanium system; the whole thing was a push-it-down-from-the-top big iron and big clusters concept.<br>
<p>
'cos, y'know, that's exactly how ia32 came to dominance over SPARC, PPC, Alpha, etc, right?<br>
<p>
<p>
<p>
It sounds like ARM64 is closer to "pure" x86_64 than Itanium/IA64; it's a major cleanup and extension of ARM32, but recognisably related.<br>
<p>
I doubt ARM will screw this up, not least because they will've learned from the Itanium fiasco. They're sure to have low cost entry-level parts available directly or via licensees from the beginning. They'll be be focused on keeping costs low, yields high, and porting relatively easy. I'd be surprised if some of the changes in ARM64 weren't to get rid of hard- or expensive- to implement instructions and other simplifications for easier manufacturing.<br>
<p>
ARM also have another advantage: there isn't much of a legacy base of binary software that people expect to be portable to new arches. It's the norm to have to rebuild binaries for different ARM sub-arches. They don't have Intel's problem of people expecting to be able to run their 1981 copy of QBase on their new Itanium server.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 2:59 UTC (Wed)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/506271/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>For an example of insanely expensive packaging, check <a href="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/KL_Intel_Itanium2.jpg/250px-KL_Intel_Itanium2.jpg">this</a> image of an Itanium 2 CPU assembly out.</p>

<p>Compare to <a href="http://upload.wikimedia.org/wikipedia/commons/thumb/0/00/KL_Intel_Pentium_III_Coppermine.jpg/220px-KL_Intel_Pentium_III_Coppermine.jpg">this</a> Intel Pentium III Coppermine CPU package.</p>

<p>It isn't hard to see part of why Itanium struggled even before AMD came along with AMD64 and finished it off.</p>

<p>Have a look at the <a href="http://ark.intel.com/products/family/451">Intel price list</a> for some of the Itanium family. Do you really think they're that much better than a Core i7 or the Xeon variants? I don't. Sure, those are current prices not historical ones from the time when itanium used to be almost-relevant, but the prices then were <i>at least</i> as bad.</p>

<p>Also, notice how the TDP ratings on those parts are absolutely nuts? Some of those parts dissapate 180W and cost nearly $4k in bulk! You aren't going to get many of those into a rack, not least because the CPU packages are so physically huge as well. Now there are further disincentives like the lack of <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/advanced-encryption-standard--aes-/data-protection-aes-general-technology.html">AESNI instructions</a> in Itanium.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/506271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 8:23 UTC (Wed)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/506289/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Also, notice how the TDP ratings on those parts are absolutely nuts? Some of those parts dissapate 180W and cost nearly $4k in bulk!</font><br>
<p>
Well, it was about the P4-Netburst time, so the TDP is... accurate :)<br>
As for the prices, the enterprise segment is never understandable to mortal users: the $4k price tag does not even include a next-day replacement service.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor506302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 11:29 UTC (Wed)
                               by <b>kskatrh</b> (guest, #73410)
                              [<a href="/Articles/506302/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; They're sure to have low cost entry-level parts available directly or </font><br>
<font class="QuotedText">&gt; via licensees from the beginning. They'll be be focused on keeping costs </font><br>
<font class="QuotedText">&gt; low, </font><br>
<p>
The number I've heard bandied about was $15K for the some of the first Aarch64 boards/systems. Perhaps that was for one of the big Calxeda boxes, fully populated?<br>
<p>
Contrast that with a $60 gooseberry or a $45 Raspberry Pi (if my order ever gets filled.)<br>
<p>
I'll be much more interested when I can get something for &lt;$200.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 13:55 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/506321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">The number I've heard bandied about was $15K for the some of the first Aarch64 boards/systems.</font></blockquote>

<p>I think you are comparing apples and oranges. I don't believe in $15K Aarch64 <b>system</b> for a nanosecond. Boards, sure, this is about what you can expect from brand-new architecture. I remember how we've developed software for $5 cryptogadget (that's retail price, bulk prices were about 2-3 times smaller and CPU itself was well below $0.5). Development board for a CPU was $5K.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/506321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor506357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 16:35 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/506357/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
$15k is probably the price of a devkit. It's a bit high, but not outrageously so.<br>
<p>
I fondly remember paying several thousand dollars for development boards, with retail prices of the end-user hardware below $200.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor507182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2012 0:10 UTC (Wed)
                               by <b>plugwash</b> (subscriber, #29694)
                              [<a href="/Articles/507182/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"It's the norm to have to rebuild binaries for different ARM sub-arches."<br>
Maybe that is true of the microcontroller variants of ARM and of kernel code but userland code on linux tends to keep running fine on newer versions of arm. Debian armel will run happilly on everything from V4t right through to v7.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/507182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor506285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 7:19 UTC (Wed)
                               by <b>gidoca</b> (subscriber, #62438)
                              [<a href="/Articles/506285/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Armv8 Technology Preview says: "Instruction semantics broadly the same as in AArch32". Doesn't sound like the differences will be that big to me. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 14:12 UTC (Wed)
                               by <b>mwsealey</b> (guest, #71282)
                              [<a href="/Articles/506322/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The instruction encoding is different though. ARM 32 and 64 are mutually incompatible at that level even if the source code looks similar. That said, AArch64 and ARMv8-A has ARMv7-A compatibility built-in the same way you can run Thumb and ARM code together these days. So there's no reason you can't run the old stuff in a 32-bit execution mode, the problem here is that the kernel itself absolutely has to run in 64-bit mode to manage this. The ability to run all this "legacy" code is going to be restricted to userspace.<br>
<p>
It's not like PPC where the instruction encodings are identical to a high degree and 64-bit code barely has a handful of extra instructions for dealing with 64-bit values directly. Power Architecture was designed very, very well from the beginning, and the mnemonics are identical and the generated bytecode is identical barring the 64-bit specifics. You can't say that about ARM. ARM decided to reinvent the architecture to get rid of all that cruft (but they have to keep compatibility with at least the ARMv7).<br>
<p>
Most of the available userspaces are going to stay ARMv7-A for a long, long time.. like running a 64-bit kernel with a 32-bit userspace is common on x86 these days (and x32 just compounds it). Those that need to have 64-bit userspaces will have them.. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506432"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 22:02 UTC (Wed)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/506432/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps I'm dating myself just a little, but this looks like the 8085-&gt;8086 transition.  There was no 8080 code out that would run on the 8086. 8086 did retain the weird side effects of 8080 arithmetic and attendant conditionals, so transcoding was easy to automate.  8085+1=8086 was a shuck that worked.<br>
<p>
DEC provided a translator from x86 to Alpha, and the translated code ran lots faster on Alpha than the original code did on x86.  IIRC, interpreted x86 ran as fast as x86.  It didn't save them in the end.  How the market will respond to a new architecture depends on details, and nobody knows which details will turn out to be important.<br>
<p>
Compatibility can be a trap: IBM OS/2 ran windos programs unchanged. windos could not run OS/2 programs.  Which target should you code for?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506432/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor506330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 14:39 UTC (Wed)
                               by <b>Lumag</b> (subscriber, #22579)
                              [<a href="/Articles/506330/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Judging from the previous experience and architecture similarities, it may end up like ppc64 - it is like ppc32, but slower (according to benchmarks), due to more instructions required to load integers, etc.<br>
<p>
X86_64 gained additional registers and that is one of the main reasons, why it is really faster than i386 (IA-32)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 17:26 UTC (Wed)
                               by <b>gnb</b> (subscriber, #5132)
                              [<a href="/Articles/506383/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; X86_64 gained additional registers and that is one of the main reasons, why it is really faster than i386 (IA-32)</font><br>
<p>
That's equally true of AArch64: you get 31 GP registers against 15 in 32-bit ARM mode.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 17:33 UTC (Wed)
                               by <b>Lumag</b> (subscriber, #22579)
                              [<a href="/Articles/506385/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no such register shortage on ARM as it is on IA-32.<br>
<p>
P.S. I'm not voting against Aarch64. I just say that "just extending registers to 64-bit" probably won't work as expected.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 18:20 UTC (Wed)
                               by <b>gnb</b> (subscriber, #5132)
                              [<a href="/Articles/506391/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed it's nothing like as bad as IA-32 but I suspect the increase in registers will still give some benefit. Also worth noting is that all useful ARMv8 implementations will probably still support 32-bit ARM, so the 32-bit app. on 64-bit kernel pattern can be used.,<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor506595"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2012 22:16 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/506595/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends on what you are trying to do.<br>
<p>
For instance, the inner loop of SHA-512 needs 8 64-bit registers, plus an array of 16 64-bit values. On a 32-bit architecture with 15 registers, you will have to spill to the stack (each 64-bit register would be represented by a pair of 32-bit registers, so you would need 16 of them). On a 64-bit architecture with 31 registers, you could have the whole state (8+16 values) in the registers, and still have a few left for the intermediate calculations. The entire inner loop can run without having to touch the stack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506595/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2012 22:40 UTC (Sat)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/506771/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>In the specific case of ARMv7 vs. ARMv8, you need to consider NEON.  An ARMv7 with NEON, wouldn't you do the SHA-512 hash using the NEON registers?
</P><P>
(<A rel="nofollow" HREF="http://cr.yp.to/highspeed/neoncrypto-20120320.pdf">These guys</A> show decent results for other crypto algorithms using NEON.  They suggest SHA-512 would speed up well also, but say they "didn't bother" with it yet.)
</P><P>
I guess my point is, ARM v7 already offers a path to way more registers than the base 16 x 32.  I would imagine anyone springing for a Cortex-A15 would also include NEON.  NEON is designed to absorb the heavy duty bulk computation, leaving the 16 GPRs for the more general control stuff.  
</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/506771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2012 23:00 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/506774/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you are building software for one device, everything you say is reasonable.<br>
<p>
But if you are trying to build software for many different devices (like a disto needs to), then you can't count on optional features being there<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506779"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2012 4:42 UTC (Sun)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/506779/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are CP15 registers (ID_ISARx, MVFRx, CPACR, NSACR) that tell you whether VFP and NEON are present, and if present, whether they're powered up and available.  (VFP/NEON are in a separate power domain on A15.)  So, you could theoretically build software that includes NEON-optimized algorithms, and set up the right versions of the functions at the start of the code.<br>
<p>
Your point stands, though, for devices that would have to run the fallback version.  Those would benefit from ARMv8 without having to use NEON.  Plus, keeping the multiple versions around takes up more space, wrangling them is added complexity, etc. etc.<br>
<p>
For something like a cell phone, where interpreters like Dalvik have a JIT, the compiled code can match the exact CPU in the phone.  After all, that isn't exactly a user-serviceable part.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506779/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor506331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 15:52 UTC (Wed)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/506331/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aside from the fact that IA64 wasn't a good match for IA32, it also wasn't that great an architecture on its own. It was very much designed to be implemented like the P4, with deep pipelines and a lot of control logic that figures out what your code is doing and does things in parallel and speculatively in complicated ways, with the goal of making use of lots of functional units when your programs are single-threaded. But then the x86 went the opposite way, towards more processors (and more cores, and even pretending you have more cores than you actually do). If your code runs best on a P4 than any other x86, it would be even better in IA64, but nobody's code is like that.<br>
<p>
There's nothing terrible about designing an architecture that's just different from the other architecture the chip supports, so long as the new architecture isn't nuts. If arm64 is a different architecture from a company that knows a lot about a certain sweet spot from their 32-bit architecture, that's a whole lot better than IA64 being a different architecture from a company that'd been driven temporarily insane by their 32-bit architecture.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 19:39 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/506402/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that you may be confused about your chips.<br>
<p>
The Itanium was nearly the complete OPPOSITE of a P4 design. In the Itanium design the compiler was responsible for figuring out what memory to preload, what branches to predict and what instructions to run in parallel. The Itanium CPU itself was a very RISCy design in its way without much special logic.<br>
<p>
In a P4 and other IA32 designs, the CPU has big piles of logic dedicated to branch predictions, instruction decoding, speculative execution and parallel instruction dispatch with the associated timeline cleanup at the end to make it all appear sequential.<br>
<p>
Itanium dropped quite a lot of that, which I think was a very good decision.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 20:46 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/506416/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">In a P4 and other IA32 designs, the CPU has big piles of logic dedicated to branch predictions, instruction decoding, speculative execution and parallel instruction dispatch with the associated timeline cleanup at the end to make it all appear sequential.</font></blockquote>

<p>P4 is step in the same direction as Itanic - just not as big. That's why it was merely "reputation disaster" instead of "billions down the drain". For example for good performance it <b>needed</b> branch taken/branch not taken hints from a compiler (they were added to x86 specifically for P4).</p>

<blockquote><font class="QuotedText">Itanium dropped quite a lot of that, which I think was a very good decision.</font></blockquote>

<p>Yeah, good decision. For AMD, that is. Itanium is designed for weird and quite exotic corner case: tasks where SMP is unusable yet compiler is capable of making correct predictions WRT memory access and branch execution. Sure, such tasks <b>do</b> exist (most cryptoalgorithms, for example), but they are <b>rare</b>. We all know the result.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/506416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506420"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 20:58 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/506420/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It works great, especially after a profiling run of the code.<br>
<p>
Is there ANYTHING that CPU silicon can do with an instruction stream that software cannot do? No, not really.<br>
<p>
It's not rare at all. Most software improves quite a bit on any CPU when rebuilt with performance feedback optimizations. After profiling, true data is available for branch and memory predictions. CPU silicon without hints can only look a few steps ahead and make guesses.<br>
<p>
And I'm not sure what you mean by tasks where SMP is unusable. Most Itanium systems are SMP. IA64 SMP works even better than Xeon's because Intel fixed some of x86's short-sighted memory ordering rules.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506420/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2012 14:31 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/506503/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">Is there ANYTHING that CPU silicon can do with an instruction stream that software cannot do? No, not really.</font></blockquote>

<p>This is were you are wrong. Dead wrong as Itanic story showed. There is one thing software can not do - and sadly (for guys who dreamed up this still-born archtitecture) this is the only thing that matters. Software can not optimize your software for the CPU which does not even exist yet.</p>

<blockquote><font class="QuotedText">Most software improves quite a bit on any CPU when rebuilt with performance feedback optimizations. After profiling, true data is available for branch and memory predictions. CPU silicon without hints can only look a few steps ahead and make guesses.</font></blockquote>

<p>This is classic case of the <i>In theory, there is no difference between theory and practice. But, in practice, there is.</i></p>

<p>Theory: you can use PGO and produce nice and fast code. Itanium should kill all other CPUs!

<p>Practice: Even if software is built in-house it's usually built once and used on system with different CPU generations (often from different vendors). COTS is used for <b>decades</b> without recompilation. Itanic is gigantic waste of the resources.</p>

<blockquote><font class="QuotedText">IA64 SMP works even better than Xeon's because Intel fixed some of x86's short-sighted memory ordering rules.</font></blockquote>

<p>Not really. Compare obvious competitors: <a href="http://ark.intel.com/products/43410/Intel-Itanium-Processor-9350-(24M-Cache-1_73-GHz-4_80-GTs-Intel-QPI)">Itanium® Processor 9350</a> and <a href="http://ark.intel.com/products/53571/Intel-Xeon-Processor-E7-4860-(24M-Cache-2_26-GHz-6_40-GTs-Intel-QPI)">Xeon® Processor E7-4860</a>. Surely Itanium wins because of it's better architecture? Nope: if your task is SMP-capable then 10 cores of Xeon can easily beat 4 Itanium cores. And this is not an aberration: Xeon systems usually had 2x more cores (often difference was more then 2x) than identically priced Itanium systems. Even will all fixes in memory-ordering rules Itanium was never able to win such competition if task was able to use all the cores of Itanium and all the cores of Xeon.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/506503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor506644"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2012 8:55 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/506644/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is there ANYTHING that CPU silicon can do with an instruction stream that software cannot do? No, not really.</font><br>
<p>
Seems that CPU silicon can adapt to memory access taking different times (in layer 1 cache / in layer 2 cache...) (so re-order instructions) better than compiler, mostly when the same code is executed at different times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506644/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2012 22:58 UTC (Sat)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/506772/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was going to say much the same thing:  Hardware can adapt to dynamically changing conditions.  The compiler can, at best, look at a set of profiling runs and try to shoot down the middle.  Or, if it's particularly aggressive, try to issue multiple versions for the different dynamic probabilities.  It does not have the opportunity to respond to the exact conditions that arise when any given instruction executes.<br>
<p>
For example, the compiler doesn't have sight of the other software on the system.  Suppose process A is polluting the caches.  When running unrelated process B, the CPU still could improve its performance through out-of-order scheduling and other tricks that hide the miss penalties.  The compiler had no way of predicting those when it compiled process B's executable.<br>
<p>
Statically scheduled architectures such as IA64 won't reorder the instruction scheme, although they will (especially once they got to McKinley) aggressively try to reorder memory requests and allow multiple misses in flight.  As a result, to address concerns such as the pollution issue above, the compiler needs to try to schedule loads as early as possible.  This is why IA64 has "check loads."  they all you issue a speculative load even earlier -- perhaps before you even know the pointer is valid -- and then issue a "check load" to copy the loaded value into an architectural register at the load's original execution point.<br>
<p>
The "check load" is where all exceptions get anchored in the case of a fault.  If the speculative load got invalidated for some reason (it doesn't have to be a fault -- the hardware can drop a speculative load for any reason at all), the check-load will re-issue it.  It allows the compiler to mimic the hardware's speculation to a certain extent.<br>
<p>
It's not problem free.  Speculative load / check load pairs tie up more issue slots than straight loads that hardware might speculate.   If the check load stalls, it stalls all the code that follows it (statically scheduled, remember?), whereas with hardware speculation, only the dependent instructions stall while others can proceed.<br>
<p>
The original promise of the IA-64 architecture was to be able to ramp up the processor clock given the simplified instruction pipeline thanks to static scheduling, to overcome any losses associated with lack of hardware speculation.  Furthermore, it was supposed to be more energy efficient since it wasn't spending hardware tracking dependencies in large instruction windows.  In the end, it didn't seem to live up to any of that.<br>
<p>
I don't think IA64 failure is an indictment of VLIW principles, though.  I work with a VLIW processor regularly that doesn't seem to have any of the same problems.  When measured against the promises, EPIC (the official name for IA64's brand of VLIW), was an EPIC failure, IMHO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor508464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2012 21:06 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/508464/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I was going to say much the same thing: Hardware can adapt to dynamically changing conditions. The compiler can, at best, look at a set of profiling runs and try to shoot down the middle.</font><br>
<p>
Not just hardware but self-modifying software too. This how "Hotspot" got its name. This looks like a more general compile-time versus run-time question rather than a hardware versus software one.<br>
<p>
At this stage this thread could probably use an informed post about Transmeta?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/508464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor508479"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2012 21:48 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/508479/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is true, although to a lesser extent.  I'd say it gives you a point on the continuum.  <br>
<p>
JITs can use dynamic profile information (both block and path frequency) and specific details of the run environment to tailor the code, but they can't respond at the granularity of, say, re-ordering instructions due to cache misses, for example.  If you have a purely statically scheduled instruction set like EPIC, no amount of JIT will help reorder loads if the miss patterns are data dependent and dynamically changing.  (Speculate/Check loads can help, but only so much.)<br>
<p>
Speaking of the ultimate JIT platform Transmeta:  Even Transmeta has some hardware patents for hardware memory access speculation mechanisms.  I recall one which was a speculative store buffer:  The software would queue up stores for a predicted path, and then another instruction would either commit the queue or discard it.  Or something like that...   Ah, I think this might be the one:  <a rel="nofollow" href="http://www.freepatentsonline.com/7225299.html">http://www.freepatentsonline.com/7225299.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/508479/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor506305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2012 12:15 UTC (Wed)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/506305/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ARM 64 bits address space is needed even *now* for embedded boxes, I currently need to map &gt; 4 Gb on PCIe interface (a lot more...) onto an ARM 32 address space and it is not fun doing it with memory windows... DMA delayed writes have a major problem when you change the memory window base address...<br>
I just have 64 memory window base address to manage, plus things which are really windows into some other kind of memory.<br>
Also, having a massive amount of I/O mapped control/status registers, I am no more using readl()/writel() with #defined register address and content and MASKs, but array of structures containing arrays of structures and a lot of bitfields in there - the whole lot declared volatile.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor506605"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2012 23:08 UTC (Thu)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/506605/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Debian users might be interested to note that there is already 64-bit ARM port in progress, which was demoed at DebConf12. The port was prepared by ARM employees and the demo was run on the so called "Fast Model". The demo included Linux, Xfce, a LAMP stack and Firefox loading a phpinfo() page from that stack. The port builds on the recent multi-arch, cross-compiling and bootstrap work happening in and around Debian.<br>
<p>
<a href="http://penta.debconf.org/dc12_schedule/events/882.en.html">http://penta.debconf.org/dc12_schedule/events/882.en.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506605/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor507369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting 64-bit ARM systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2012 3:03 UTC (Thu)
                               by <b>guillemj</b> (subscriber, #49706)
                              [<a href="/Articles/507369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW the dpkg architecture name will be arm64:<br>
<p>
<a href="http://anonscm.debian.org/gitweb/?p=dpkg/dpkg.git;a=commitdiff;h=7786b93c8005b2f7a5a1043c2f07d06a80563e72">http://anonscm.debian.org/gitweb/?p=dpkg/dpkg.git;a=commi...</a><br>
<p>
And I'd be happy to change the GNU triplet match, if that got renamed to something less unfortunate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/507369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
