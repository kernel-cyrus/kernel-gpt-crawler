        <!DOCTYPE html>
        <html lang="en">
        <head><title>The future of 32-bit Linux [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/838807/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/838888/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/838807/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The future of 32-bit Linux</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="GAByline">
           <p>December 4, 2020</p>
           <p>This article was contributed by Arnd Bergmann</p>
           </div>
<p> The news for processors and system-on-chip (SoC) products these
days is all about 64-bit cores powering the latest computers and
smartphones, so it's easy to be misled into thinking that all 32-bit
technology is obsolete. That quickly leads to the idea of removing support
for 32-bit hardware, which would clearly make life easier for kernel
developers in a number of ways.

At the same time, a majority of embedded systems shipped today do use 32-bit
processors, so a valid question is if this will ever change, or if 32-bit
will continue to be the best choice for devices that do not require
significant resources.

<p>
To find an answer, it is worth taking a look at different types of systems
supported in Linux today, how they have evolved over time with the
introduction of 64-bit processors, why they remain popular, and what
challenges these face today and in the future.</p>

<h4>32-Bit desktops</h4><p>

Linux was first written as a desktop system for IBM PC compatibles, and was
eventually ported to almost every other desktop platform available in the
1990s, including a lot of the early Unix workstations across all
architectures.
Over time, all of these were replaced with 64-bit machines or they
disappeared from the market, or in case of Unix workstations, both. The
earliest i386, Arm, MIPS, and PowerPC processors all got phased out over
time, but a lot of others still remain.

<p>
The table shows the 32-bit desktop platforms that proved popular enough to
make it into mainline Linux and stay there, supported mainly by loyal
hobbyists:

<p>
</p>
<blockquote>
<table class="OddEven"><tbody><tr>
<th valign="top">Platform</th>
<th valign="top">Architectures</th>
<th valign="top">Earliest supported machine</th>
<th valign="top">Last supported 32-bit machine</th>
<th valign="top">End of marketing</th>
<th valign="top">Replaced by</th>
</tr>
<tr><td valign="top">
Unix workstation</td>
<td valign="top">
m68k
<br>
MIPS<br>SPARC
<br>
PA-RISC
<br>
PowerPC</td>
<td valign="top">
Sun-3/60
<br>
(1985)
</td>
<td valign="top">
IBM RS/6000 43P-240,
<br>
HP Visualize B180L 
<br>
(1997)</td>
<td valign="top">
1999</td>
<td valign="top">
x86 Linux, 64-bit Unix</td>
</tr><tr><td valign="top">
Apple Macintosh</td>
<td valign="top">
m68k<br>PowerPC<br>ia32</td>
<td valign="top">
Mac II (1987)</td>
<td valign="top">
Macbook<br>(2006)</td>
<td valign="top">
2007</td>
<td valign="top">
x86-64, arm64 Mac</td>
</tr><tr><td valign="top">
IBM compatible PC</td>
<td valign="top">
ia32</td>
<td valign="top">
PS/2 model 70 486
<br>
(1989)</td>
<td valign="top">
Intel Atom D270 Netbooks<br>(2009)</td>
<td valign="top">
2011</td>
<td valign="top">
x86-64 PC</td>
</tr><tr><td valign="top">
Amiga</td>
<td valign="top">
m68k
<br>
PowerPC</td>
<td valign="top">
A2500
<br>
(1989)</td>
<td valign="top">
AmigaOne SE<br>(2003)</td>
<td valign="top">
2004</td>
<td valign="top">
-</td>
</tr><tr><td valign="top">
Atari</td>
<td valign="top">
m68k</td>
<td valign="top">
Atari TT<br>(1990)</td>
<td valign="top">
Falcon<br>(1992)</td>
<td valign="top">
1993</td>
<td valign="top">
-</td>
</tr><tr><td valign="top">
Acorn RiscPC</td>
<td valign="top">
Arm</td>
<td valign="top">
StrongARM RiscPC
<br>
(1996)</td>
<td valign="top">
StrongARM RiscPC J233
<br>
(1997)</td>
<td valign="top">
2003</td>
<td valign="top">
-</td>
</tr><tr><td valign="top">
Netwinder</td>
<td valign="top">
Arm
<br>
x86</td>
<td valign="top">
Netwinder &ldquo;Frog&rdquo; (1999)</td>
<td valign="top">
NetWinder 3100<br>
 (2001)</td>
<td valign="top">
2001</td>
<td valign="top">
-</td>
</tr><tr><td valign="top">
Android Tablet/Laptop</td>
<td valign="top">
Arm
<br>
ia32<br>MIPS</td>
<td valign="top">
Nexus 7<br>(2012)</td>
<td valign="top">
Various, Android 8<br>(2019)</td>
<td valign="top">
Ongoing</td>
<td valign="top">
arm64</td>
</tr><tr><td valign="top">
ChromeOS</td>
<td valign="top">
Arm</td>
<td valign="top">
Samsung 303c
<br>
(2012)</td>
<td valign="top">
Asus Chromebook Flip <br>
(2015)</td>
<td valign="top">
2017</td>
<td valign="top">
x86-64, arm64</td>
</tr><tr><td valign="top">
Baikal T1</td>
<td valign="top">
MIPS</td>
<td valign="top">
Tavolga Terminal
<br>
(2018)</td>
<td valign="top">
Tavolga Terminal
<br>
(2018)</td>
<td valign="top">
Ongoing</td>
<td valign="top">
arm64</td>
</tr>
</tbody></table>
</blockquote>

<p>
Android tablets using Armv7 processors are the only platform from the list
above  that
remains widely available in 2020, but the end of marketing is in sight here as
well. Tablets based on 64-bit Armv8 CPUs are not just more powerful but
often also cheaper. Mainline support for many 32-bit Android tablets is
only starting to get added to the kernel.  (For those who are unfamiliar
with the taxonomy of Arm processor variants, <a
href="https://en.wikipedia.org/wiki/List_of_ARM_microarchitectures">this
table</a> describes them all).

<p>

<p>
The Baikal T1 chip is a curiosity, as it only exists for the Russian
domestic market to avoid relying on chip imports. It too has an Armv8
successor, but that is not yet widely deployed. Kernel support for the
Baikal T1 was added in 2020.</p>

<h4>Traditional embedded Linux</h4><p>

The use of Linux in embedded devices started in the late 1990s and, over
time, spread to around 30 architectures, largely replacing
other embedded operating systems. A lot of these were custom architectures
made by companies that build system-on-chip designs around their own CPU
cores. Over time, licensable CPU IP cores took over, with MIPS, PowerPC,
x86, and SuperH cores being popular until Arm started replacing them.

<p>
These are the most recent licensable 32-bit generations for each of the
main processor families supported in Linux-5.10:

<p>
</p>
<blockquote>
<table class="OddEven"><tbody>
<tr><th valign="top">
Core</th>
<th valign="top">
Architecture</th>
<th valign="top">
Introduced</th>
<th valign="top">
Replacement</th>
<th valign="top">
New Architecture</th>
</tr><tr><td valign="top">
Renesas SH-4A</td>
<td valign="top">
SuperH</td>
<td valign="top">
2004</td>
<td valign="top">
(Licensed from Arm)</td>
<td valign="top">
Armv7-A, Armv8-A</td>
</tr><tr><td valign="top">
AMCC PowerPC 460</td>
<td valign="top">
Power ISA 2.03</td>
<td valign="top">
2006</td>
<td valign="top">
X-Gene</td>
<td valign="top">
Armv8-A</td>
</tr><tr><td valign="top">
IBM PowerPC 470</td>
<td valign="top">
Power ISA 2.04</td>
<td valign="top">
2008</td>
<td valign="top">
IBM A2</td>
<td valign="top">
ppc64le</td>
</tr><tr><td valign="top">
Freescale e500mc</td>
<td valign="top">
Power ISA 2.06</td>
<td valign="top">
2008</td>
<td valign="top">
(Licensed from Arm)</td>
<td valign="top">
Armv7-A, Armv8-A</td>
</tr><tr><td valign="top">
MIPS Warrior P5600</td>
<td valign="top">
MIPS32r5</td>
<td valign="top">
2014</td>
<td valign="top">
P6600, I8500</td>
<td valign="top">
MIPS64r6, RV64</td>
</tr><tr><td valign="top">
Arm Cortex-A17</td>
<td valign="top">
Armv7-A</td>
<td valign="top">
2014</td>
<td valign="top">
(various)</td>
<td valign="top">
Armv8-A</td>
</tr><tr><td valign="top">
Cadence Xtensa LX7</td>
<td valign="top">
Xtensa LX</td>
<td valign="top">
2016</td>
<td valign="top">
(unknown)</td>
<td valign="top">
(unknown)</td>
</tr><tr><td valign="top">
Andes D15F</td>
<td valign="top">
NDS32v3</td>
<td valign="top">
2017</td>
<td valign="top">
A25, AX25</td>
<td valign="top">
RV32, RV64</td>
</tr><tr><td valign="top">
OpenCores mor1kx v5</td>
<td valign="top">
OpenRISC 1000</td>
<td valign="top">
2017</td>
<td valign="top">
(various)</td>
<td valign="top">
RV32, RV64</td>
</tr><tr><td valign="top">
Microblaze v10.0</td>
<td valign="top">
Microblaze32</td>
<td valign="top">
2017</td>
<td valign="top">
Microblaze v11.0</td>
<td valign="top">
Microblaze32,Microblaze64</td>
</tr><tr><td valign="top">
ARC HS4x</td>
<td valign="top">
ARCv2</td>
<td valign="top">
2017</td>
<td valign="top">
HS5x, HS6x</td>
<td valign="top">
ARCv3 (32/64 bit)</td>
</tr><tr><td valign="top">
MIPS Warrior I7200</td>
<td valign="top">
nanoMIPS</td>
<td valign="top">
2017</td>
<td valign="top">
I8100</td>
<td valign="top">
RV64</td>
</tr><tr><td valign="top">
T-HEAD CK870</td>
<td valign="top">
C-SKY v2</td>
<td valign="top">
2018</td>
<td valign="top">
C910</td>
<td valign="top">
RV64</td>
</tr><tr><td valign="top">
Gaisler LEON5</td>
<td valign="top">
SPARCv8</td>
<td valign="top">
2019</td>
<td valign="top">
NOEL-V</td>
<td valign="top">
RV64</td>
</tr></tbody></table>
</blockquote><p>

<p>
As the table shows, almost all of these cores have introduced 64-bit
replacements 
from their original designers, but most manufacturers keep on supporting
the 32-bit 
versions as well. Hitachi (now Renesas) and Freescale (now NXP) introduced
64-bit core designs of their SuperH and PowerPC cores, but subsequently
abandoned them in favor of licensed Arm Cortex-A cores.

<p>
The OpenRISC project is still active, but a lot of its contributors have
moved on to working on RISC-V designs. Cadence Tensilica has not announced
a replacement for the Xtensa LX7 but is apparently focusing on its DSP
cores.

<p>
Some CPU cores end up being used for a long time in new SoCs. For instance,
the Arm9 CPU was originally created in 1998, with the Arm926EJ-S update
from 2001 still making it into the new Microchip SAM9X60 in 2019. Not only
that, Microchip also still supports mainline Linux on its ancestor, the
2003 vintage AT91RM9200, and promises to sell it as long as there is
demand.

<p>
The manufacturers' specifications for product longevity of a part can
give some indication of how long it will be used, but this is not
always the same as the time for which it will receive kernel upgrades. Many
embedded systems are shipped with an old kernel and never upgraded, others
may be required to get periodic upgrades many years after the last one has
shipped.

<p>
These are some more examples of notable chips that are built on older cores
or CPU architectures but will remain in production for several years to
come, usually side by side with more powerful and newer Armv7 or Armv8
based parts.

<p>
<blockquote>
<table class="OddEven">
<tbody><tr><th valign="top">
SoC name</th>
<th valign="top">
CPU</th>
<th valign="top">
Introduced</th>
<th valign="top">
Armv7/v8
Replacement</th>
<th valign="top">
Projected EOL</th>
</tr><tr><td valign="top">
Renesas SH7734</td>
<td valign="top">
SH-4A</td>
<td valign="top">
2010</td>
<td valign="top">
RZ, R-Car series</td>
<td valign="top">
March 2025</td>
</tr><tr><td valign="top">
NXP QorIQ P3041</td>
<td valign="top">
PowerPC e500mc</td>
<td valign="top">
2010</td>
<td valign="top">
QorIQ Layerscape</td>
<td valign="top">
June 2025</td>
</tr><tr><td valign="top">
NXP MCF5441x</td>
<td valign="top">
Coldfire v4 (m68k)</td>
<td valign="top">
2010</td>
<td valign="top">
i.MX</td>
<td valign="top">
September 2025</td>
</tr><tr><td valign="top">
Broadcom BCM2835</td>
<td valign="top">
Arm1176JZF-S</td>
<td valign="top">
2011</td>
<td valign="top">
BCM2836+</td>
<td valign="top">
January 2026</td>
</tr><tr><td valign="top">
Qualcomm QCA9531</td>
<td valign="top">
MIPS 24Kc</td>
<td valign="top">
2014</td>
<td valign="top">
IPQ series</td>
<td valign="top">
</td>
</tr><tr><td valign="top">
Intel Quark SE C1000</td>
<td valign="top">
Quark (486-like)</td>
<td valign="top">
2015</td>
<td valign="top">
-</td>
<td valign="top">
July 2022</td>
</tr><tr><td valign="top">
Allwinner F1C200s</td>
<td valign="top">
Arm926EJ-S</td>
<td valign="top">
2017</td>
<td valign="top">
sunxi series</td>
<td valign="top">
</td>
</tr><tr><td valign="top">
Microchip SAM9X60</td>
<td valign="top">
Arm926EJ-S</td>
<td valign="top">
2019</td>
<td valign="top">
SAMA5</td>
<td valign="top">
</td>
</tr><tr><td valign="top">
DM&amp;P Vortex86EX2</td>
<td valign="top">
Dual i686-like</td>
<td valign="top">
2019</td>
<td valign="top">
-</td>
<td valign="top">
February 2029</td>
</tr><tr><td valign="top">
Mediatek MT7621DAT</td>
<td valign="top">
MIPS 1004Kc</td>
<td valign="top">
2019</td>
<td valign="top">
MT7622</td>
<td valign="top">
</td>
</tr><tr><td valign="top">
Ingenic X2000</td>
<td valign="top">
Xburst2 (MIPS32r5)</td>
<td valign="top">
2020</td>
<td valign="top">
-</td>
<td valign="top">
</td>
</tr></tbody></table>
</blockquote>

<p>
The end-of-life date in this table usually refers to the
manufacturer&rsquo;s last guaranteed shipment date, often 10 or 15 years
after the introduction, but for popular chips like the BCM2835, kernel
updates may be needed long after the last chip has been sold. The m68k-based
Coldfire MCF5441x is interesting because it represents the oldest
architecture that Linux runs on, and it will still be sold until at least
2025, which is 40 years after the introduction of its Sun-3 ancestor, the
oldest machine with Linux support. At that point it will have outlived
almost every other 32-bit architecture that was meant to replace it.

<p>
The more recent examples tend to be built as system-in-package processors
that include 32 to 256&nbsp;megabytes of DRAM. This helps further reduce board
design cost, which is the main reason to use any of these parts instead of
the more common Armv7 alternatives in new designs.</p>

<h4>Microcontrollers and DSPs</h4><p>

The line between an SoC and a microcontroller can be hard to
draw. Typically a microcontroller is a highly integrated system that leaves
out one or more of the essential parts of a modern SoC: a memory-management
unit (MMU), data cache, external DRAM memory, or sometimes an
IEEE-754-compatible floating-point unit. Linux does not strictly require
any of those, but running without an MMU in particular limits the
applications that can be used on the system.
<p>
Digital signal processors (DSPs) are another special class of
processor. Like the 
now-removed Blackfin architecture, both the Texas Instruments C6x and
Qualcomm Hexagon DSPs are capable of running Linux in a limited way, but
this rarely seems to happen. Typically, these processors instead run
bare-metal code and communicate with Linux running on an Arm core on the
same chip.

<p>
Support for MMU-less processors was merged into Linux-2.5.45 in 2002 and
has been proclaimed to be dying ever since. At its height, 12 MMU-less CPU
architectures were supported, but most of those are obsolete and no longer
work with mainline kernels. The following are some of the still-supported
SoCs as of Linux-5.10:

<p>
<blockquote>
<table class="OddEven"><tbody>
<tr><th valign="top">
MCU name</th>
<th valign="top">
CPU</th>
<th valign="top">
Introduced</th>
</tr><tr><td valign="top">
NXP MCF537x</td>
<td valign="top">
Coldfire v3</td>
<td valign="top">
2007</td>
</tr><tr><td valign="top">
NXP LPC4357</td>
<td valign="top">
Cortex-M4</td>
<td valign="top">
2012</td>
</tr><tr><td valign="top">
TI TMS320C6678</td>
<td valign="top">
C66</td>
<td valign="top">
2014</td>
</tr><tr><td valign="top">
J-core FPGA SoC</td>
<td valign="top">
J2</td>
<td valign="top">
2016</td>
</tr><tr><td valign="top">
ST STM32H7</td>
<td valign="top">
Cortex-M7</td>
<td valign="top">
2016</td>
</tr><tr><td valign="top">
Mediatek MT3620</td>
<td valign="top">
Cortex-A7</td>
<td valign="top">
2017</td>
</tr><tr><td valign="top">
NXP i.MX RT1050</td>
<td valign="top">
Cortex-M7</td>
<td valign="top">
2017</td>
</tr><tr><td valign="top">
Kendryte K210</td>
<td valign="top">
RV64</td>
<td valign="top">
2018</td>
</tr><tr><td valign="top">
Espressif ESP32-S2</td>
<td valign="top">
Xtensa LX7</td>
<td valign="top">
2019</td>
</tr></tbody></table>
</blockquote>

<p>
The most active microcontroller platform running Linux is now the STM32
series. These can be even cheaper than the low-end MIPS32 or Armv5 chips,
so they are sometimes used when manufacturing cost is more important than
performance or the additional development effort. Power consumption and
physical size can also be reasons to use them. Some products have shipped
running inside the built-in 2MB of SRAM, others use external DRAM or <a
href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory#PSRAM">PSRAM</a>,
which again increases cost.

<p>
Kernel support for the i.MX RT series, MT3620, and ESP32 exists out of tree
but has not been submitted for inclusion in mainline Linux. The Kendryte
K210 is special for being a 64-bit MMU-less CPU system; the kernel port
mainly exists because there are still no other low-cost RISC-V chips with
Linux support. The Mediatek MT3620 is another special case, it is designed
for the Microsoft Azure Sphere and does have an MMU, but runs Linux in only
4MB of integrated <a
href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>.

<p>
Linux on microcontrollers competes with a wide range of open-source
realtime operating systems including
<a href="https://www.zephyrproject.org/">Zephyr</a>,
<a href="https://nuttx.apache.org/">NuttX</a>,
<a href="https://os.mbed.com/">Mbed</a>, and
<a href="https://www.freertos.org/">FreeRTOS</a>.
These tend to need less memory and are better suited for running
without a memory-management unit.</p>

<h4>Linux on Armv7-A</h4><p>

It's hard to overstate the impact that Armv7 has had on embedded
computing. This can be largely attributed to the never-ending demand for
faster and more efficient processors in smartphones. Over the evolution
from  the high-end
Nokia N96 in 2008 to this year's Apple iPhone&nbsp;12, we see a 10x increase
in clock frequency, an 8x increase in pipeline width, and a 6x increase in
the number of cores.

<p>
The Cortex-A9 managed to surpass practically all competing 32-bit cores of
the time. It combined the advantages of an out-of-order pipeline, up to
four cores, NEON SIMD, and 40nm manufacturing, and went on to become the most
successful licensable 32-bit CPU core of all time. In Linux-5.10, there are
452 devicetree files based on 76 SoCs, or&nbsp;30 SoC families, far more
than any other Arm core, and more than all non-Arm machines combined.

<p>
While the popular Cortex-A9 was the most advanced core in the first
generation of Armv7-A, which includes Cortex-A8, Cortex-A5, PJ4, and
Scorpion, the second generation Armv7VE cores ended up with the
opposite situation. The high-end Cortex-A15, Cortex-A17, Brahma-B15, and
Krait cores made a big entrance in mobile phones, automotive, and networking
equipment from 2012 to 2013, but as they ran into limitations of the
32-bit virtual address space, they were quickly replaced with the emerging
64-bit Armv8 based products.

<p>
Cortex-A7, in comparison, is a relatively simple, in-order CPU core, but on
the typical 28nm process it beats a 40nm Cortex-A9 in performance and
outclasses it in power consumption and die area. It also offers many of the
features of the Armv8 cores that were integrated into Armv7VE:
virtualization, large physical address extensions (LPAE), up to eight cores,
big.LITTLE configurations, and hardware integer division. Seven years after
its launch, Cortex-A7 remains the most common option for new low-cost
embedded SoCs with two or four cores, most commonly paired with around
256MB of DDR3L memory per core either inside a system-in-package or on the board.

<p>
Cortex-A9 and Cortex-A7 together with their 64-bit counterparts have
replaced most other 32-bit architectures in embedded systems, including the
MIPS32r2 cores that were common in wireless networking SoCs until
about 2017. The 64-bit Cortex-A53 is now used in more SoCs than the
Cortex-A7, but is still behind the Cortex-A9.

<p>
There are two obvious factors that will determine the eventual demise of
Armv7-A:</p>
<ul class="spacylist">
<li> A system that needs more than 2GB of memory or
higher performance than a quad-core Cortex-A7 ends up on 64-bit
hardware.</li>
<li> Cortex-A7 is not available below 28nm semiconductor
technology and loses its cost advantage over 64-bit cores as 22nm and 14nm
processes get cheaper.</li></ul><p>


<p>
The Cortex-A32 core is a 32-bit version of the 64-bit Cortex-A35 that could
theoretically address both the performance and the manufacturing points,
but so far no SoC has been built around it. Apparently there is simply no
point in using a feature-reduced core when the Cortex-A35 can do all the
same things but also support 64-bit code at only a marginally higher
cost. This means that, unless a new 32-bit Arm or RISC-V core manages to
take over the extreme low end, Cortex-A7 will be the end of the line for
32-bit Linux.

<p>

<blockquote>
<img src="https://static.lwn.net/images/2020/arnd-soc-graph.png"
alt="[Armv7 core use over time]" border=0 class="photo">
</blockquote>

<p>
This graph shows how many SoCs use each of the Armv7 CPU cores over time as
the kernel adds devicetree source files for each one. Cortex-A9 initially
saw the highest growth but has stagnated since, along with all cores other
than the Cortex-A7. This timeline is delayed from the introduction of the
hardware because support for older SoCs is sometimes added many years after
the hardware was built.


Looking at individual boards, there would be an additional delay based on
how long an SoC is used in new products.</p>

<h4>Year 2038</h4><p>

It is well understood that many 32-bit systems will stop working in the
year 2038 when the 32-bit <tt>time_t</tt> overflows. Extrapolating from the
current 
popularity of Armv7 SoCs and the time that chips for older architectures
are getting deployed, it seems likely that 32-bit hardware running
Linux will be sold well into the 2030s and in some cases stay in use for
decades after a product has first shipped, so this is a very real threat.

<p> After years of work, the kernel itself is now completely converted to
using 64-bit <tt>time_t</tt> internally, and the musl C&nbsp;library has
switched 
over, but any distributions based on the GNU C&nbsp;Library (glibc) are still
affected by this problem and need to be rebuilt against a future version of
the library once its 64-bit time support has been completed.

<p> The degree to which distributions will be rebuilt is an open question,
given the 
declining interest in 32-bit architectures among developers. Many binary
distributions, like Fedora, Ubuntu, and openSUSE Leap, have dropped support
for all 32-bit architectures other than Armv7 and are likely to drop that
as well before they would consider rebuilding against a new glibc.

<p>
Debian still supports its official ports to Armv5 (armel), Armv7 (armhf),
x86-32 (i386), and MIPS32r2 (mipsel), as well as non-official 32-bit ports
to PowerPC, SuperH, PA-RISC, Motorola 68000, and x32. The port to Armv7 is
likely to outlive all the other architectures the way it did on the other
distributions, possibly for another ten years after the remaining ones are
gone. This means there will likely be embedded users that want
Debian armhf to work beyond 2038.
<p>

While there was <a
href="https://lwn.net/Articles/812767/">a plan to move
to a time64 glibc for Debian 11 (Bullseye) on armhf</a>, 
the
earliest possible release is now Debian 12 (Bookworm). There are still open
questions regarding whether this should replace the existing armhf port or
whether 
it needs to be able to coexist as a multiarch target with a new name and
target triplet, which adds more work. These questions may become moot if
there is not enough interest among porters to keep Debian supported on
32-bit architectures in the future, which does seem to be a growing problem.

<p>
In embedded systems that compile everything from source using the
<a href="https://www.yoctoproject.org/">Yocto Project</a>,
<a href="https://buildroot.org/">Buildroot</a>,
<a href="https://openwrt.org/">OpenWRT</a>, or similar distributions, there
is usually
already an option to use the musl-1.2 library to get full support
for 64-bit <tt>time_t</tt>, if this isn't already the default.

<h4>Highmem</h4><p>

When a 32-bit system has more physical RAM than it can map into its linear
virtual address space, anything outside of that linear mapping is called
highmem and requires using the <tt>kmap()</tt>, <tt>kmap_atomic()</tt>,
or the new
<tt>kmap_thread()</tt> helpers to be accessible temporarily from kernel
code. Requiring all user-space memory access to be written based on these
interfaces is a burden to not just 32-bit architectures but also 64-bit
ones. Given the observation that 32-bit systems with a lot of memory are
actually getting rarer over time, the question of
<a href="/Articles/813201/">deprecating highmem</a> comes
up on <a href="/Articles/836144/">a regular basis</a>. 

<p>
This is a list of common 32-bit systems with large memory requirements, to
show which machines would be impacted the most from deprecating highmem:

<p>
<blockquote>
<table class="spacylist"><tbody><tr><th valign="top">
Platform</th>
<th valign="top">
Maximum memory</th>
<th valign="top">
Introduced</th>
<th valign="top">
Processor</th>
<th valign="top">
Typical application</th>
</tr><tr><td valign="top">
Intel Xeon MP</td>
<td valign="top">
64 GB</td>
<td valign="top">
2002</td>
<td valign="top">
Netburst (x86)</td>
<td valign="top">
Server</td>
</tr><tr><td valign="top">
Calxeda Midway</td>
<td valign="top">
16 GB</td>
<td valign="top">
2013</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
Server</td>
</tr><tr><td valign="top">
HiSilicon HiP04</td>
<td valign="top">
16 GB</td>
<td valign="top">
2014</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
Server</td>
</tr><tr><td valign="top">
Annapurna AL5140</td>
<td valign="top">
8 GB</td>
<td valign="top">
2014</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
NAS Server</td>
</tr><tr><td valign="top">
NXP QorIQ P4080</td>
<td valign="top">
16 GB</td>
<td valign="top">
2008</td>
<td valign="top">
e500mp (ppc32)</td>
<td valign="top">
Networking</td>
</tr><tr><td valign="top">
Intel Axxia 5500</td>
<td valign="top">
8 GB</td>
<td valign="top">
2013</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
Networking</td>
</tr><tr><td valign="top">
TI Keystone 2</td>
<td valign="top">
8 GB</td>
<td valign="top">
2013</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
Networking</td>
</tr><tr><td valign="top">
Marvell Armada XP</td>
<td valign="top">
8 GB</td>
<td valign="top">
2012</td>
<td valign="top">
PJ4B-MP</td>
<td valign="top">
Networking</td>
</tr><tr><td valign="top">
Nvidia Tegra K1 (T124)</td>
<td valign="top">
8 GB</td>
<td valign="top">
2014</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
Industrial</td>
</tr><tr><td valign="top">
Renesas RZ/G1H</td>
<td valign="top">
8 GB</td>
<td valign="top">
2016</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
Industrial</td>
</tr><tr><td valign="top">
NXP i.MX 6QuadPlus</td>
<td valign="top">
4 GB</td>
<td valign="top">
2015</td>
<td valign="top">
Cortex-A9</td>
<td valign="top">
Industrial</td>
</tr><tr><td valign="top">
Baikal T1</td>
<td valign="top">
8 GB</td>
<td valign="top">
2015</td>
<td valign="top">
MIPS P5600</td>
<td valign="top">
PC</td>
</tr><tr><td valign="top">
Rockchips RK3288</td>
<td valign="top">
4 GB</td>
<td valign="top">
2014</td>
<td valign="top">
Cortex-A17</td>
<td valign="top">
Chromebook</td>
</tr><tr><td valign="top">
Samsung Exynos 5800</td>
<td valign="top">
4 GB</td>
<td valign="top">
2013</td>
<td valign="top">
Cortex-A15</td>
<td valign="top">
Chromebook</td>
</tr><tr><td valign="top">
Intel Core Duo</td>
<td valign="top">
3 GB</td>
<td valign="top">
2006</td>
<td valign="top">
P6 (x86)</td>
<td valign="top">
Laptop</td>
</tr><tr><td valign="top">
NXP MPC7448</td>
<td valign="top">
2 GB</td>
<td valign="top">
2005</td>
<td valign="top">
PowerPC G4</td>
<td valign="top">
Laptop</td>
</tr></tbody></table>
</blockquote>

<p> The largest configurations appear in large server systems that were
replaced with larger, 64-bit server systems many years ago. The same is
true for most 32-bit PC and laptop systems with 2GB of memory or
more. Early Chromebooks used Cortex-A15 or A17 CPU cores with 4GB of
memory; they have stopped getting software updates in June 2020 but are often
still in active use and can run modern Armv7 Linux distributions as a
long-term alternative.

<p>
For embedded industrial and networking systems, 32-bit configurations
with up to 8GB exist and still require future kernel updates, but they are
rare as the practical configuration is limited by the available DDR3
memory they use.  A board with 8GB of DDR3 memory needs eight 8Gb chips that are
expensive and not widely available, or sixteen 4Gb chips in a multi-rank
setup and complex board layout. Later 64-bit SoCs in comparison often use
LP-DDR4 memory that supports up to 8GB with a single 64Gb chip.

<p>
Configurations with 2GB or 4GB of DDR3 or LP-DDR3 memory are common enough on
Cortex-A15-based embedded systems that they will have to be supported for a
long time.  Cheaper Cortex-A7 based SoCs, instead, have a single narrow
DDR3 interface, which limits the practical configurations to one or two
chips with either 2Gb or 4Gb each, and avoids the use of highmem when
all memory fits into a 1GB low-memory area. LP-DDR4 or other technologies that
allow higher capacity are rarely used on these cheapest SoCs, because they
tend to be more expensive for small configurations.

<p>
A rough plan for removing highmem, based these observations, could unfold
like this:

<p>
</p><ul class="spacylist">
<li> Support for highmem gets worse over time, as the kernel is modified to
work better on 64-bit systems while adding larger overhead on 32-bit
kernels. This can be seen happening with the <tt>kmap_thread()</tt>
addition.</li> 

<li> 32-Bit machines with the largest memory configurations, including
everything over 4GB, are rare enough that they can eventually stop getting
kernel updates. Keystone2 and GZ/G1H are among those that still need kernel
updates on 8GB machines for the moment, i.MX6 with 4GB is in a similar
situation.</li>

<li> Compressed swap pages in the highmem area might still be used on later
kernels for that hardware, instead of directly providing high memory pages
to user space.</li>

<li> SoCs based on Armv7VE cores (Cortex-A7, -A15, and A17) in
configurations with 2-4GB of RAM can move to the work-in-progress
support for <tt>CONFIG_VMSPLIT_4G_4G</tt> that will allow accessing close
to 4GB of 
physical memory while also providing 4GB of virtual memory for
processes. This comes at a higher performance cost than highmem but, since
it is  based
on features of the Armv7 MMU, will not be nearly as bad
as the comparable feature that was used on x86 in the past.</li>

<li> The same trick as Armv7VE might also be used on Baikal T1 with its
MIPS32r5 processor, but is harder to implement there. Older MIPS32 machines
only support up to 512 MB of low memory due to hardware limitations.</li>

<li> Other 32-bit architectures can use <tt>CONFIG_VMSPLIT_2G_OPT</tt> to
make up to 2GB of physical memory available without highmem support, at the
cost of reduced user virtual memory. This would include Cortex-A9 as well
as x86 and PowerPC machines, on which a <tt>CONFIG_VMSPLIT_4G_4G</tt>
option is unlikely to get implemented because of hardware limitations or
lack of interest.</li></ul><p>


<p> If the plans for <tt>CONFIG_VMSPLIT_4G_4G</tt> work out, less than 1%
of the machines should lose support for newer kernels after highmem gets
removed, and that number goes down as time passes. Without
<tt>CONFIG_VMSPLIT_4G_4G</tt> on the other hand, losing support for a
portion of the 32-bit machines might not be acceptable at all, so highmem
would have to remain an option for as long as users update their Armv7
kernels.
Either way, this topic will remain interesting for years to
come, as compromises continue to be made based on shifts in priority.</p>

<h4>64-Bit hardware</h4><p>

The continued move towards 64-bit hardware means that most users no longer
have to worry about the problems of 32-bit systems such as the <tt>time_t</tt>
overflow and limits of the virtual and physical address space, but this is
not true for everyone.  For example:

<p>
</p><ul class="spacylist">

<li> There are a lot of legacy binaries that users may need to keep
running, in particular on x86 machines, that have 30&nbsp;years of backward
compatibility including games ported from 32-bit Windows</li>

<li> Similarly, Android apps are often still being distributed as
32-bit Arm binaries for the widest hardware compatibility in some markets,
despite Google's push for apps in its own Play store to be built
for 64-bit or architecture-independent.</li>

<li> As 64-bit processors take over the low-cost market, they get combined
with smaller memory configurations, with as little as a single 2Gb DDR3
system-in-package configuration for 256MB of physical memory. At this
point, running 64-bit code has a significant overhead and there is a
strong cost incentive to run 32-bit code instead of doubling the memory
capacity.</li></ul><p>


<p>
The most common way to deal with this problem is to run a 64-bit kernel but boot
into an unmodified file system containing a 32-bit user space. This works
because the kernel has long supported both types of applications by
implementing a second set of system call entry points known simply as the
"compat" layer for each interface that is incompatible. There
are a few exceptions in device drivers that do not support compat tasks,
but those are mostly limited to third-party modules outside of the mainline
kernel.

<p>
The same compat kernel support allows mixing 32-bit and 64-bit container
instances, as well as mixing both types of applications inside of a single
"multilib" or "multiarch" root filesystem. Using
compat mode avoids most of the problems with highmem, but still requires
compiling all the 32-bit user application code with a time64-capable C
library to be able to run beyond year 2038.

<p>
On x86 and MIPS machines, another option is to run a 32-bit kernel directly
on 64-bit hardware, which provides better compatibility with device drivers
and lets users share both the kernel and root file system across 32-bit and
64-bit hardware, but brings back the virtual address limitations of the
32-bit kernel and will lack kernel features that are only available in
64-bit builds. In theory, this is also possible on many Arm processors, but
there are many limitations:

<p> </p><ul class="spacylist"> <li> Armv8 processors lack certain
instructions (<tt>setend</tt>, <tt>cp15</tt> barriers,
<tt>swp</tt>/<tt>swpb</tt> atomics) that may be used in older 32-bit
binaries. While the 64-bit kernel emulates these in compat mode, the 32-bit
kernel emulation is less complete, so existing binaries that work on 64-bit
Armv8 kernels as well as 32-bit Armv7 systems might not work on the same
32-bit kernel running on Armv8 hardware.</li>

<li> Most CPU implementations require some errata workarounds in the kernel
to work correctly. The 32-bit Arm kernel has workarounds for all Armv7
cores, but not for Armv8 cores. This can result in undefined behavior and
data corruption in the worst case.</li>

<li> Many security features require 64-bit kernels, either because of
hardware limitations or missing implementation in 32-bit kernels. This
includes <a href="/Articles/741878/">kernel page-table isolation</a>
("Meltdown" protection), <a href="/Articles/569635/">kernel address-space
layout randomization</a>,
<a href="/Articles/651614/">PAN</a>,
<a
href="https://developer.arm.com/docs/ddi0595/h/aarch64-system-registers/uao">UAO</a>,
<a href="/Articles/804982/#bti">BTI</a>,
<a href="/Articles/718888/">PTR_AUTH</a>, and hardware
cryptography. Running
a 32-bit kernel can therefore be less secure.</li>

<li> In general, this configuration is not well tested, as kernel
developers rightfully point to using 64-bit kernels as a better
alternative.</li>

<li> The latest generation of Armv8.2 cores have dropped hardware support
for running 32-bit kernels completely. This includes the
"little" Cortex-A55 as well as the all "big" cores
starting with Cortex-A76. These can still run 32-bit user space code in
compat mode. Some future cores will drop 32-bit user mode as well, but
it seems likely that there will still be "little" cores for as
long as there is demand for them. In fact it <a
href="/Articles/838339/">appears</a> that there will be 
systems that can run 32-bit code only on some of the cores.</li>
</ul><p>

Despite these limitations, there have been large-scale deployments of
32-bit Arm kernels on 64-bit hardware, notably in the Raspbian distribution
that manages to use the same code across Armv6 (Raspberry Pi&nbsp;1 and Zero),
Armv7-A (Raspberry Pi&nbsp;2), and Armv8 (Raspberry Pi&nbsp;3 and&nbsp;4),
as well as some 
low-end Android systems that appear to do this primarily to avoid the
stricter Generic Kernel Image (GKI) rules that are required for shipping
Android&nbsp;10 with 64-bit Arm kernels.

<p>
Memory consumption by the kernel itself may turn out to be a reason to
finally add proper support for Armv8 processors to the 32-bit Arm kernel,
to squeeze out the few last percent of usable memory in very small
machines. As an estimate, there are multiple areas in which 64-bit kernels
add an unavoidable overhead that can amount to dozens of megabytes:</p>

<ul class="spacylist">

<li> The kernel image itself is roughly 50% larger compared to a
Thumb2-enabled Armv7 kernel. On a typical configuration, it can grow from
10MB to 15MB, or more if the 64-bit configuration includes support for
additional hardware as is the case with Android GKI.</li>

<li> As each 4KB page in the system requires a <tt>struct page</tt>
entry that is typically 32&nbsp;bytes larger on 64-bit kernels, one extra
megabyte of memory is consumed for each 128MB of installed memory just to
store the <tt>mem_map</tt> array.</li>

<li> Each thread needs its own kernel stack, which is 16KB instead of
8KB. This requires one extra megabyte for every 128 threads.</li>

<li> Page tables need one or two extra indirection levels to describe the
larger virtual address space, adding at least 4KB per process.</li>

<li> Slab caches in the kernel tend to be larger as well; in particular the
inode cache can appear to use significant memory resources. This
is harder to quantify, as the inode cache is dynamically sized; it grows as
long as memory is available but shrinks under memory pressure.</li></ul><p>


On processors that have no native 32-bit mode, it is also possible to
define an "<a
href="https://docs.oracle.com/cd/E19620-01/805-3024/lp64-1/index.html">ILP32</a>"
ELF format for 64-bit instructions. This is 
in fact available on both MIPS under the "n32" name and on x86
as "x32". Neither of the two is widely deployed in practice,
and the patches to add the same for 64-bit Arm kernels were never merged,
in order to avoid fragmenting the ecosystem with incompatible binary
formats.

<p>
It appears that the emerging RISC-V SoCs designed to run Linux offer only
64-bit mode. All the options available to Arm processors are theoretically
available there as well, but in the absence of an established 32-bit RISC-V
Linux ecosystem, it seems the architecture will end up largely skipping
that step entirely and instead accept the higher memory
consumption. There are a few 32-bit RISC-V cores that include an MMU, such
as Rocket, Andes A25, VexRiscv, and Cloudbear BI-350, but so far, 32-bit
RISC-V has 
only managed to make its way into microcontrollers, and while compat mode
is theoretically possible with the architecture, neither the kernel nor
actual CPU implementations support it. An extreme example here is <a
href="https://www.cnx-software.com/2020/11/09/xuantie-c906-based-allwinner-risc-v-processor-to-power-12-linux-sbcs">a 
recently announced low-cost SoC</a> using a 64-bit RISC-V CPU with as little as
64MB of RAM.

<p>
For the moment, 64-bit Arm processors hold the advantage over RISC-V,
as they have two mature software ecosystems they can run, using more
space-efficient 32-bit user space for machines under 1GB. As memory
requirements and capacities grow, more applications will run better when
built for 64-bit and this difference becomes less important.</p>

<h4>Conclusion</h4><p>

As a general rule, cutting-edge technology is short-lived as it quickly
gets replaced with the next generation, while anything that performs its
function more cheaply than the competition can remain popular for a long
time, possibly decades. This effect can be seen with Motorola 68000
architecture, the Arm9 CPU core, and the Raspberry Pi Zero board, which are all
outliving generations of superior replacements.

This effect gives hope to those waiting for the end of highmem, as the only
hardware with memory configurations that require it was cutting-edge five
or more years ago and can be expected to be retired within the next five
years.

<p>
The MMU-less microcontrollers and the smallest memory configurations for
embedded systems may die a different death in the same time frame, as these
are often deployed in highly customized environments without a plan for
kernel updates. Once the companies using them have stopped deploying
systems on new kernels, it may finally end, the same way that once-popular
architectures like Arm7TDMI or Blackfin disappeared in Linux.

<p>
In between those two extremes are a large number of embedded SoCs that are
still popular today, with Cortex-A7-based designs over time becoming the
only viable option for new 32-bit SoCs. These are cheaper and better than
anything below them, while anything more powerful is in turn being replaced
by 64-bit products. Once a 64-bit core beats the Cortex-A7 on performance,
power consumption, and cost, this last market will move on to that for new
products and 32-bit Linux kernels will only be needed for supporting
existing users. New board designs are likely to appear for five to ten
years after the last Armv7 chip has been created, but after that it can
take another decade before the remaining users finally stop upgrading their
kernels or replace their hardware.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures">Architectures</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Bergmann_Arnd">Bergmann, Arnd</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/838807/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor838999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2020 21:46 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/838999/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
struct page is almost never 32 bytes on 32-bit. Usually it&#x27;s 40 bytes (last_cpupid and memcg). So the extra overhead of a 64 byte struct page is only 60%, not 100%.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor839008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 0:48 UTC (Sat)
                               by <b>BirAdam</b> (guest, #132170)
                              [<a href="/Articles/839008/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a general rule, hardware is fine and in use longer than developers care to worry about it. I have zero doubt that a ton of currently perfectly fine hardware will be thrown out adding to the more than 50 million tons of ewaste largely due to software-caused obsolescence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 11:20 UTC (Sat)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/839018/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I recently reconverted my 12 years old Atom based notebook into a laptop for my 7 years old daughter. It runs fine, allowing her to learn how to use a computer with Abiword, Gnumeric, Scratch, GCompris, Python and a few educational games. Updating it is not crucial as I wouldn&#x27;t mind disconnecting it completely, but I would still be sad to see the compatibility dropped.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 12:50 UTC (Sat)
                               by <b>amacater</b> (subscriber, #790)
                              [<a href="/Articles/839025/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s part of the problem - it&#x27;s the fact that hardware is heading for 12 years old and becomes a law of diminishing returns to keep the infrastructure to produce a whole distribution for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839055"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 11:25 UTC (Sun)
                               by <b>glaubitz</b> (subscriber, #96452)
                              [<a href="/Articles/839055/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not really a problem. We&#x27;re building Debian for the m68k which is mostly hardware from the 80s and 90s.<br>
<p>
It&#x27;s maintained, so I don&#x27;t see the problem. On the contrary, it helps to find portability issues and hidden bugs because many issues are only immediately visible on architectures such as m68k and SPARC with their peculiar alignment requirements.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839055/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839064"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 14:27 UTC (Sun)
                               by <b>amacater</b> (subscriber, #790)
                              [<a href="/Articles/839064/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my comment above, I was thinking specifically of the AMD/Intel 32 bit only architecture. Over the years in Debian, we&#x27;ve had to effectively change the minimum spec of the processor it runs on - it&#x27;s now, effectively, i686 and some of the Via and Cyrix processors are excluded - and a lot of the hardware that is 32 bit only out in the world is increasingly unreliable with the years. I spent yesterday working with the Debian images team producing boot images. Every AMD/Intel 64 bit machine (apart from the Itanium) can boot 32 bit code but can also run 64 bit code. One comment made then: running the oldest 32 bit laptop is probably less effective than running a slightly newer second hand Thinkpad and moving to newer models every few years: maybe the oldest machines do need to go to recycling<br>
<p>
The long term future of AMD/Intel 32 bit only is rapidly downhill, I think, though I&#x27;m fairly sure that we&#x27;ve committed to supporting it for the lifetime of Debian 11 (Bullseye) - the discussions on architectures are going on at the moment as Bullseye will be released next year and porters and maintainers for the various architectures have to step up and be counted at the moment.<br>
<p>
In the ARM world, there&#x27;s a large number of small boards / embedded systems as noted - but it&#x27;s hard to build 32 bit code for some large packages on the 32 bit boards themselves because they have small memory. Some packages have to be built on an ARM 64 bit platform in a 32 bit environment - not all ARM 64 bit processors will now run 32 bit code. Various build farms of small boards are also increasingly flaky to support. [Speaking for myself and not on behalf of the Debian project].<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839064/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 16:28 UTC (Sun)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/839070/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is the problem with i486/i586 the lack of atomics and CMOV?  I try to keep the kernel working all the way back to 486 and whatever Cyrix and VIA chips people are willing to test.  The kernel probably works better now on a 486 than it has for a long time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 17:18 UTC (Sun)
                               by <b>amacater</b> (subscriber, #790)
                              [<a href="/Articles/839074/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
2016: <a href="https://lists.debian.org/debian-devel-announce/2016/05/msg00001.html">https://lists.debian.org/debian-devel-announce/2016/05/ms...</a> refers - from Ben Hutchings.  I think it was the fact that gcc was moving to target newer processors. I know it caused anguish amongst some of the folks with firewalls running the lowest powered processors at the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor841532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 1, 2021 10:44 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/841532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the other hand, home firewalls are often drop-in boxes that don&#x27;t really need to follow upgrades when there is zero exposed service running on them. Mine runs on a 2002-era VIA-Eden i586-like CPU with a 2.4 kernel last built in 2010... it will eventually be replaced but migrating rules is a pain when everything works fine out of the box. I&#x27;ll probably wait for the hardware to die.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/841532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor839073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 17:33 UTC (Sun)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/839073/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Increasingly, the problem with i386 is that upstream user-space developers want to rely on having SSE so they don&#x27;t have to deal with the i387 FPU&#x27;s strange quirks, but that isn&#x27;t actually allowed in Debian&#x27;s current baseline (although some packages unconditionally use SSE anyway).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor839750"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2020 20:19 UTC (Thu)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/839750/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>We dropped 486 support by accident. It was broken in the kernel by <tt>sync_core()</tt> using <tt>CPUID</tt> unconditionally (<a href="https://bugs.debian.org/515982">Debian bug #515982</a>), and then by stack-protector initialisation using <tt>RDTSC</tt> unconditionally (<a href="https://bugs.debian.org/766105">Debian bug #766105</a>). The latter was reported 5 years after the regression and after it had been included in 2 stable releases, which indicated to me that it wasn't worth fixing.</p>
<p>We dropped 586 support more deliberately, after <a href="https://lists.debian.org/debian-devel/2015/09/msg00589.html">discussion on debian-devel</a>.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/839750/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor839090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2020 3:57 UTC (Mon)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/839090/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This happened with mips too, to the point where I can&#x27;t run Debian on my router any more since it is MIPS r1 and Debian bumped to MIPS r2 (and then dropped big-endian mips entirely).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2020 8:00 UTC (Mon)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/839091/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Same here: I keep Linux running on rbtx4927, but nfsroot userspace is stuck at Debian Jessie.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor839824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2020 11:50 UTC (Fri)
                               by <b>winden</b> (subscriber, #60389)
                              [<a href="/Articles/839824/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you aware of anyone running / fixing m68k Debian for vampire boards? They are getting fairly high performance (at least 4x of a 060/50 for cpu intensive work) and it seems to me that they are being well-enough engineered.<br>
<p>
Ps. Thankyou for latest information about m68k and how to get a fully-working Debian chroot / nspwand ... it works great! :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2020 11:57 UTC (Fri)
                               by <b>glaubitz</b> (subscriber, #96452)
                              [<a href="/Articles/839825/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you aware of anyone running / fixing m68k Debian for vampire boards? They are</font><br>
<font class="QuotedText">&gt; getting fairly high performance (at least 4x of a 060/50 for cpu intensive work) and it</font><br>
<font class="QuotedText">&gt; seems to me that they are being well-enough engineered.</font><br>
<p>
I know about the Vampire boards and I talked to one of the developers at the Amiga32<br>
conference in Neuss, Germany.<br>
<p>
The problem is that Vampire currently does not emulate an MMU that is compatible with<br>
the Linux/m68k kernel. However, the FPGA they are using has its own MMU and the<br>
Vampire developers speculated whether it could be used by the Linux kernel instead.<br>
<p>
<font class="QuotedText">&gt;  Ps. Thankyou for latest information about m68k and how to get a fully-working Debian</font><br>
<font class="QuotedText">&gt; chroot / nspwand ... it works great! :)</font><br>
<p>
You&#x27;re welcome. Please also have a look at <a href="http://m68k.info">http://m68k.info</a> which brings news about new<br>
development in the m68k community. You will find a talk about the upcoming M68k backend<br>
for LLVM as well as a new qemu virtual machine type for m68k with 3.2 GB RAM and 128<br>
virtual devices.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor839030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 15:14 UTC (Sat)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/839030/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In general I agree with you, but do you think that the Linux kernel is really the bottleneck here? I would imagine for end-user facing hardware the biggest problem is the necessity of modern enough web browser and the never-ending JavaScript bloat...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 1:23 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/839040/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t imagine that it&#x27;s really possible to blame this problem on any one piece of software, or even any one category of software. The simple and uncomfortable reality is that newer hardware is more lucrative to support, so that is what people and businesses choose to spend their time and effort on supporting. This is not a technical problem, and will not admit a technical solution.<br>
<p>
Even more bluntly: If you want support for hardware X, you can support it yourself* or hire someone to support it for you. If X happens to be popular, you might receive support for free, but this is a gift and not an entitlement.<br>
<p>
* There are complications if we&#x27;re talking about closed hardware, but I&#x27;m mostly talking about general-purpose computing devices. IMHO closed hardware should have a minimum support period codified into law, but I have no idea how such a law might be written. It would need to provide a precise legal definition of &quot;support,&quot; and I just don&#x27;t see how you would go about defining such a thing. And then you have issues of &quot;I modded it and now their new firmware update broke everything,&quot; which is a whole other can of worms... IMHO you get to keep both pieces if that happens, but others will disagree with me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 12:07 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/839057/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  It would need to provide a precise legal definition of &quot;support,&quot; and I just don&#x27;t see how you would go about defining such a thing. And then you have issues of &quot;I modded it and now their new firmware update broke everything,&quot; which is a whole other can of worms... IMHO you get to keep both pieces if that happens, but others will disagree with me.</font><br>
<p>
Similar to what they do with cars - spare parts etc MUST be freely available for ten years after manufacturing stops.<br>
<p>
Let&#x27;s define &quot;lifetime suppport&quot; as say 5 years. So if a phone maker releases a phone with a version of Android for which support stops in a year, the manufacturer is on the hook to take over for the remaining four.<br>
<p>
And I don&#x27;t know about other law, but we have a concept in UK law of &quot;fit for purpose&quot;, and if you have a security breach or something, then that surely is NOT &quot;fit for purpose&quot;.<br>
<p>
Note also the thing about cars - it&#x27;s down to the manufacturer to make sure spares are available, they don&#x27;t have to do it themselves, they can off-load it. So if they can find a bunch of enthusiasts to take over with a bit of support from the manufacturer, that&#x27;s good enough. Those enthusiasts might even upstream a load of proprietary fixes ... :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor839013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 5:57 UTC (Sat)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/839013/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Applications that would have difficulty moving to a 64-bit time_t, typically for object-size and alignment in legacy protocols, can often be recompiled to use an unsigned 32-bit value there, taking them up into 2106.  So, a 32-bit kernel, typically forked from 2.6 or 3.x and with unsigned 32-bit time_t, is a viable alternative for rescuing legacy embedded uses.<br>
<p>
Probably by 2106 the machines will be responsible for coding, and it will then be their problem; or, civilization might collapse, so any people remaining will have bigger worries. Or (best case) both.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 11:50 UTC (Sat)
                               by <b>warrax</b> (subscriber, #103205)
                              [<a href="/Articles/839020/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; can often be recompiled to use an unsigned 32-bit value there, taking them up into 2106.</font><br>
<p>
I&#x27;m a bit curious about this, actually. It&#x27;s been a while since doing anything serious in C/C++, but wouldn&#x27;t a signed -&gt; unsigned change be rife for UB due to implicit conversions?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 14:57 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/839028/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Surprisingly enough no. It's not an UB to convert from signed to unsigned type and back. When number is representable in both  conversion is guaranteed to keep it's value, if not  it's <b>implementation-defined</b> behavior, not undefined behavior.

<p>This being said it's not all peach and roses. Unsigned type is dominant, if you mix signed and unsigned in the same expression results can be surprising, e.g. u &gt; -1 is almost always true because -1 is interpreted as 0xFFFFFFFF.

<p>But no, there are no problems with UB.
      
          <div class="CommentReplyButton">
            <form action="/Articles/839028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 9:58 UTC (Sun)
                               by <b>niner</b> (subscriber, #26151)
                              [<a href="/Articles/839051/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn&#x27;t u &gt; -1 be always false then?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 22:01 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/839374/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Good catch. I was think about u &gt;= -1. But "always false" also probably for what people expect when they write. And note: compilers are happy to optimize that code  but offer no warnings (<a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tEJNJb0AGTy1MAOWMAjTMRABmUgAdUCwuto9QxMzb19/Ohs7RyMXN08lFTU6BgJmYgIg41NzRMxVANT0giiHZ1cPRTSMrJDc6pLbMtiK9wBKRVQDYmQOAHJbAgBqAkwFAggDWj9gO3QhgA82ofEAdlkABgBBId2h4kwCbtpFlfdsIYBaTnF3Ta21gBE%2BjtYQPoBWPtJTPo3v1DvHRyORDBRdHqYFaSdycb4Ed7/NodADWXA2GyE7243yMIA%2BHwAdBtuAAOUnuCkfDakyQATkpP0RAPe3wUIExCL%2BL1IcFgMEQKFQRi8eHYZAoEDQIrFFWAnA25ioYtGxHZECczNITls6QAnu84aRpUYtAQAPK0VgG7mkLBGETAdha/AHAoANzGWswC3yBlGhu%2Bg2UWtYeCcxH1eiwgdIBGIeDxfThHRo9CYbA4PH4gmEohQIJkQnD7MgHVQXmS03el3NkjZynyVc02lqpk4Fm0pRicUEPj8VbbffCVe75TcHbyBRSDSHk8b09oRQyY5aE6qxTnG5XTR7FU4HXB3V6XFe7y%2BTNtgL6C1JADZLnfuENgMhkEMFYTJEMILhCCRoVhUghj0GVxUAg8QMLaR4WZZFSAQTBmCwNwIFRMxMTePocVIPFuCJelJEkD56U4SRuG4DZVg%2BS9/lIa82Q5OM4N5AUICQaVRXFchKE42U3GQPN5QVTFlVYVV1U1W0dVofVYxNM1LWtF1MAdURnVtV0mzwT12VtH0/QDZMg3oENbTDCMowwfojXjRNA1TOhGBYZ1swEcwhILGQ5GLJxSzQ%2BjKwCPTa3rRQF2bCBLC3SxV17Dt%2BwiQJ9GyYcBwCOL93CpJClnFKQnnHKZ2KTL13GTd8vbbdGmicdT06Y8szPT5vl%2BOjr1vB8nyGQTHQ/ThiWJH8/yIYgIOA0CuNcQDJGWYFvJkWDuXgxDkIqAK0UkTDsVarUGMUJiuSRVj4HYoUwNcHipWFKa3HdZAvC8AB9d1ODpJ7JFWJ7OtIMSJMoKS6JkuTjONYVTXoJSbTo%2B1HQ0mG8DdNRdO9X1kH9GyTNGLC6IsyNiD1aNMbjBMkxTX6nIzVzeAETxPIkBb5As/zyyCuh2QAejrbLtI0KLW0qwRYt3OqEpHAIt0S0cRbXQQpyrZdMkFwreaXBpSrlvLgiq8qd1q2WDwayF6qwi82pZG97yGIwFHuoZXrpL9VmG/BRvGkCbv4wD2igxmlqRdCtqxbDdqvVkDs5Fi%2BUFPjuMlWOKjwN8tskTg3t%2BlVXEkrVgYJ%2BTwcUq1oe%2BWH1P6BGkZ0r19LRjHY2DHHvjxqyY1BuyyZ5NNnMzLgaZAXh6eg3yWcCqsQrrBsitMfndGVztrBl%2BKwnSuhJfFyJF6y%2BXcoq7W5Yine9eaJfdaVvfJ3VzeJ0PCET0N03Q/a95OsfZ8k/fVPCQGukXf/MapCAh7C6/8YTcDmtBf2LxA7bRDrRC2jFI7LROrAJARB9BXXSMAPS3xMEKAAAoiGUAwBAqAADu%2BdgFC1diQQQXcqZZgvvgX4bICBMIIXYVgxCyG/FsqgfQABJdAIA8EADUGCXFSAYfAqBSCkMjF4FiD84H0XeKI8RkjpEQSGKQwgCBFj3lfi%2BN8H4NhfkgfBTaMCcLmxUX0BBzFlrNTCnhbghI6QfDTneTgT46ScFWBsO8ngbH7SOlA0gaIRLB3cI/eBDiA6kE9GqAI/cgA%3D%3D">except for specialized static analysis tools</a>).
      
          <div class="CommentReplyButton">
            <form action="/Articles/839374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor839032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 18:04 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/839032/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The code can use time_t both for the absolute time and for relative time intervals when it is essential that the type is signed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839045"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 1:46 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/839045/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Additionally, it may be imprudent to assume that the system clock is correct. For quite a while, iOS would brick your phone if you set its date and time to January 1, 1970. There may not be any good reason for the user to do that, but of course* as soon as it began circulating on social media, lots of people tried it and bricked their phones.<br>
<p>
* <a href="https://www.youtube.com/watch?v=lFAPjHjaUns">https://www.youtube.com/watch?v=lFAPjHjaUns</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839045/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor839015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 8:42 UTC (Sat)
                               by <b>ewen</b> (subscriber, #4772)
                              [<a href="/Articles/839015/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For what its worth, 32-bit RISC-V Linux is being used on FPGA based RISC-V builds (often VexRisc as RV32I).  Particularly LiteX (Enjoy Digital) has done a lot of work on RV32 Linux in a FPGA, as boards with enough RAM to run Linux are fairly common, but FPGAs with open tools big enough to fit RV64 designs and other things are less common/much more expensive.<br>
<p>
But I do agree it seems likely that in a few years therell only be a few 32 bit architectures still supported in Linux.  32 bit ARM and 32 but RISC-V seem the most relevant.<br>
<p>
Ewen<br>
<p>
PS: for ASIC/Silicon designs aimed to run Linux, most of those have gone direct to RV64.  And I agree the only silicon designs for RV32I are aimed at microcontroller/embedded controller replacements rather than Linux at present.  But it wouldnt surprise me to see RV32I in things like NAS or routers running Linux, in future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 4:13 UTC (Tue)
                               by <b>mithro</b> (subscriber, #50469)
                              [<a href="/Articles/839228/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The key thing for FPGAs is that wider bit widths dramatically reduce the frequency a soft processor is able to achieve. A 64bit adder is usually more than twice as slow as a 32bit adder, routing a 64bit bus is more than twice as hard as routing a 32bit bus, etc.<br>
<p>
This is very different to ASICs on modern process nodes where the extra cost of going to 64bit is generally dwarfed by the investment needed and general lifetime of the part. <br>
<p>
If there is a resurgence of ASICs which want to run Linux on older process nodes (like maybe 130nm due to a new fully open source ecosystem - <a href="https://www.youtube.com/watch?v=EczW2IWdnOM">https://www.youtube.com/watch?v=EczW2IWdnOM</a> - and a free shuttle program - <a href="https://efabless.com/open_shuttle_program">https://efabless.com/open_shuttle_program</a> ;-) then the trend might change. When your cache sizes are small due to silicon limitations, those 64bit wide values start to seem more problematic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 8:52 UTC (Tue)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/839237/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right, when dealing with a small RV32I core comparable to a 1990s ARM7 or i386, going to 64 bits is out of the question. Once you get to bigger FPGAs and add in M, A, F, D, C and V extensions, as well go to larger caches, TLBs, and pipelines, the core is more like a Cortex-A7 or an early Intel Atom, so going to 64 bit is only a small step.<br>
<p>
For the smallest cores, you&#x27;d also leave out the MMU and run some other OS that correspond to a modern take on CLinux-2.0, but the interesting spot to watch is everything in between -- how big does an FPGA core have to be to make Linux-5.x the OS of choice without getting so big that you want to go straight to 64-bit Linux, and how long does it take before that niche disappears.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 17:54 UTC (Tue)
                               by <b>mithro</b> (subscriber, #50469)
                              [<a href="/Articles/839336/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Due to plentify block ram in most modern FPGAs, an MMU implementation on an FPGA can actually be pretty cheap.<br>
<p>
At the moment a &lt;$100 USD FPGA dev board with &lt;1 gigabytes RAM can be purchased that a 32bit Linux + MMU is *significantly* smaller and faster than 64bit. Due to the newer FPGAs mostly been focused on the datacenter use case and thus in the &gt;$500 USD per FPGA IC, I don&#x27;t see this changing for at least another 5ish years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor839348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 19:44 UTC (Tue)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/839348/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can&#x27;t you mitigate this partly by adding one or two pipeline stages, to split 64-bit additions and address calculations in two 32-bit operations?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor839031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2020 18:16 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/839031/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>As a general rule, cutting-edge technology is short-lived as it quickly gets replaced with the next generation, while anything that performs its function more cheaply than the competition can remain popular for a long time, possibly decades.
</blockquote>

A nice example of that is USA's bomber programs: If you read the Wikipedia articles on the B52, B58, (X)B-70, B1 and B2, you find that the newer designs always beat the B52 at some requirement that either was no longer relevant after some time or was surpassed by an even newer type, while the B52 beats the newer designs at operating cost, and (according to current plans) is going to survive them all, although most of these types were intended to replace the B52.
      
          <div class="CommentReplyButton">
            <form action="/Articles/839031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 1:13 UTC (Sun)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/839042/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s hard to improve on a thing that has no plausible legitimate use.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor841291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 27, 2020 1:57 UTC (Sun)
                               by <b>set</b> (guest, #4788)
                              [<a href="/Articles/841291/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Presumably you refer to its role in the nuclear deterrence triad. The B-52 has actually been flown in thousands of sorties delivering conventional bombs (and leaflets?) in several wars.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/841291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor839066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 14:37 UTC (Sun)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/839066/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a good point. There are some niche products, in a lecture on maintaining legacy ARM32 systems I pointed out that I am spending a considerable amount of time making sure that the Intel StrongARM-descendant IXP4xx is well supported. This is most famous because of its use in the NSLU2 and may seem legacy in some sense.<br>
<p>
What is unique about the IXP4xx is the strictly military operating conditions:<br>
<p>
* Temperature: -40C to +85C<br>
* Humidity (non-condensing): 20% to 90%<br>
* MTBF (mean time before failure): 60 Years at 55C<br>
<p>
This makes it plausible that this chip is in use in some installations that will outlive us all. I don&#x27;t know of any ARM32 or ARM64 SoC with this kind of characteristics. If there is one, it will likely be as important as IXP4xx.<br>
<p>
This doesn&#x27;t mean it will have kernel upgrades though: it is more likely to be embedded and deployed in a remote location for decades. Sadly, it is probably network connected, so it would be better if it did see kernel upgrades.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor841533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 1, 2021 11:03 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/841533/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Only having kernel upgrades is not sufficient to keep an old system up to date. With newer kernels come new constraints and code sizes that are not always compatible with older hardware. I haven&#x27;t tried booting 5.10 on my NSLU2 but I doubt it would be an option anymore. I barely managed to do it on a 9G20 board with 32MB RAM where I had to load it from the network to RAM because it wouldn&#x27;t fit into the previous flash partition anymore.<br>
<p>
The real problem with upgrades is connected systems. When you see a CNC device driven by an old 386 PC running MS-DOS 5.0 you smile and figure it was reliable and doesn&#x27;t present any issue since that&#x27;s not remotely accessible. It&#x27;s the same for lots of deeply embedded Linux devices. The problem is that Linux is often used in networked environments and that it&#x27;s so easy to connect it to a network that it&#x27;s often done. And being exposed to the outside world *is* what requires security upgrades.<br>
<p>
Thus we should admit that support for deeply buried systems can be dropped from newer kernels simply because these ones will not be updated and do not even need to. My point of view is that kernel support needs only to start from old devices that users want to repurpose. For sure I would be sad if I can&#x27;t boot my old dockstar (ARM926) on a recent kernel. But let&#x27;s be honest, the most recent version I&#x27;ve built for it was 3.7, 8 years ago. If 5.10 were to become the last one supported on it, it would apparently not be dramatic as I didn&#x27;t feel the need for a more recent kernel on it for 8 years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/841533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor839047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 7:22 UTC (Sun)
                               by <b>atomsymbol</b> (guest, #109825)
                              [<a href="/Articles/839047/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      In my opinion, this is a highly unbalanced article in the sense that it does not mention any of the following items:

<ul>
<li>Many (such as: 80% of all) mobile and desktop applications do not require a 64-bit address space <b>in order to function properly</b>, for example:
<ul>
<li>A Bash script that would require more than 1 GiB of memory is highly improbable, thus Bash (which is implemented in C) does not actually require 64-bit pointers in order to function properly
<li>Anybody running top/htop on their machine once in a while can clearly see that many apps (random examples: bluetoothd, nm-applet, xscreensaver) consume about 5-30 MiB of memory
</ul>
<li>32-bit pointers are more efficient than 64-bit pointers in terms of how big a <a href="https://en.wikipedia.org/wiki/Working_set_size">working set size</a> can fit into L1D/L2 caches
<li>The belief that time_t is somehow required to be linked to the size of the address space is false. That is, a 64-bit time_t and 32-bit pointers are perfectly compatible with each other.
<li>It is possible to have both 32-bit and 64-bit versions of the same library installed on a Linux-based system. In other words, it is very easy for an application developer to <b>freely</b> choose a 32-bit or a 64-bit address space depending on the particular needs of the application.
<ul>
<li>Maybe if clang/gcc made the choice between the command-line options -m32 and -m64 mandatory then it would enable programmers to give it some thought
</ul>
</ul>

-atom
      
          <div class="CommentReplyButton">
            <form action="/Articles/839047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 9:39 UTC (Sun)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/839050/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;The belief that time_t is somehow required to be linked to the size of the address space is false. That is, a 64-bit time_t and 32-bit pointers are perfectly compatible with each other.</font><br>
<p>
I think everybody agrees on that. The link is more of a practical one: the size of a pointer and the size of the largest native integer type typically go hand in hand. 32-bit architectures have 32-bit registers, and both pointers and native arithmetic instructions are limited to 32 bits. This has led to C compilers defining the primitive integer data types as having a maximum size of 32 bits, which in turn is reflected in the ABIs. Furthermore, the time_t type is defined as an arithmetic type, i.e. it must support arithmetic using C&#x27;s arithmetic operators.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 11:29 UTC (Sun)
                               by <b>glaubitz</b> (subscriber, #96452)
                              [<a href="/Articles/839056/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like something that can and should be addressed in software.<br>
<p>
Just deprecating old hardware because it&#x27;s convenient leads to obscure bugs and reduced portability.<br>
<p>
We found lots of such weird bugs in Debian while building the distribution for 20 different architectures.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 13:39 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/839062/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Sounds like something that can and should be addressed in software.</font><br>
<p>
That only works if you have the source code to everything and/or infinite developer-hours at your disposal.<br>
<p>
Binary compatibility going back decades is the primary reason Intel and Windows are still relevant.  Arm is now in the same boat, with the stratospheric rise of cortex-A and cortex-M making binary blobs commercially (and routinely) viable to distribute.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 14:08 UTC (Sun)
                               by <b>glaubitz</b> (subscriber, #96452)
                              [<a href="/Articles/839065/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  That only works if you have the source code to everything and/or infinite developer-hours at your disposal.</font><br>
<p>
We have the first requirement fulfilled in the open source world. And you don&#x27;t really need infinite developer hours, it&#x27;s not as bad as you claim it is.<br>
<p>
<font class="QuotedText">&gt; Binary compatibility going back decades is the primary reason Intel and Windows are still relevant.</font><br>
<p>
Windows isn&#x27;t really binary compatible. You can&#x27;t run many Windows 95 binaries on Windows 10 anymore. Linux has, in fact, a much better binary compatibility allowing you to run software from the 90s provided that you have the necessary shared libraries as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 15:18 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/839068/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Windows isn&#x27;t really binary compatible. You can&#x27;t run many Windows 95 binaries on Windows 10 anymore. Linux has, in fact, a much better binary compatibility allowing you to run software from the 90s provided that you have the necessary shared libraries as well.</font><br>
<p>
&quot;Provided you have the necessary libraries&quot; can be a pretty massive undertaking, and is one of the points of the TFA.  It&#x27;s also not a new problem; commercial users of Linux have been complaining about this for over twenty years, and another point of the TFA is that commercial users are beginning to discover just how much they&#x27;ve been reliant upon volunteers, and if they want something differently, they&#x27;re going to have to start paying to get what they want.  And perhaps the main point of TFA is that &quot;solving this in software&quot; is exactly what&#x27;s being done at the kernel level, because that&#x27;s a lot smaller/simpler/cheaper than getting every random binary to get recompiled/fixed for 64-bit systems. And new software built/tested/fixed for 32-bit systems.<br>
<p>
Meanwhile.  IIRC, generally it wasn&#x27;t the Win95 applications that have problems, it&#x27;s the *installers* for those Win95-era applications, which relied on 16-bit Win3.1-era binaries that don&#x27;t work on x86_64.  <br>
<p>
Offhand I can only think of a handful of Win95-era applications/games that simply didn&#x27;t work on more modern systems, one relied on Win95 not trapping an illegal memory access, and the others relied on reserved filenames like &quot;CON&quot;.  (I&#x27;m also deliberately skipping over applications that required specific hardware/device drivers that never got ported to later versions of Windows)<br>
<p>
But there were plenty of applications that technically ran, but were only ever tested on Win95 and therefore assumed they had full administrator access and behaved accordingly, writing files anywhere they wanted and other questionable assumptions.  I should point out that this was in violation of MS&#x27;s guidelines.  WinXP SP2 further tightened down many other areas that were critical for changing Windows&#x27; reputation as security swiss cheese, but this &quot;broke binary compatibility&quot; and pissed off a lot of users.<br>
<p>
But with regards to the latter; random decades-old Linux binaries will find themselves in the same boat when plonked down into modern distributions; assumptions they made about how things are laid out might not hold, and if they directly interfaced with kernel interfaces (eg OSS, specific /proc files, VFL1, or whatever) they might not get very far.<br>
<p>
(In more modern times, the general attitude towards this sort of backwards compatibility has shifted towards &quot;Just run the old system in a VM and firewall the crap out of it&quot; -- That&#x27;s what MS finally did with Win10, including XP in a sandboxed VM)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor839923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2020 10:15 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/839923/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That only works if you have the source code to everything and/or infinite developer-hours at your disposal.</font><br>
<p>
Java already does this automatically.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2020 14:49 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/839941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; That only works if you have the source code to everything and/or infinite developer-hours at your disposal.</font><br>
<font class="QuotedText">&gt; Java already does this automatically.</font><br>
<p>
That&#x27;s great, but we&#x27;re not talking about Java.  <br>
<p>
(Or the fact that Java shops inevitably end up becoming 3rd-world body farms)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor839063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 13:36 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/839063/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
... are we reading the same article? Most of these points are mentioned at least once: some (like the ability to run 32-bit stuff on 64-bit platforms) more than once (it covers both 64-bit kernel / 32-bit userspace, and 64-bit hardware / 32-bit kernel).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor840440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2020 20:23 UTC (Wed)
                               by <b>atomsymbol</b> (guest, #109825)
                              [<a href="/Articles/840440/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, we are reading the same article, but the point is that my viewpoint greatly differs from the article's viewpoint. The article's viewpoint is that 32-bit pointers on 64-bit machines is a question of the last resort, i.e. use 32-bit pointers if you are forced to do so ---- while my viewpoint is to use 32-bit pointers on 64-bit machines when it makes sense, i.e. use 64-bit pointers if you are forced to do so.

<ul>
<li>The article generally implies the following: 32-bit pointers are a legacy thing if you have more than 8 GB of RAM
<li>My comment generally implies the following: 64-bit pointers might be unnecessary even if you have more than 8 GB of RAM
</ul>

-atom
      
          <div class="CommentReplyButton">
            <form action="/Articles/840440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor839059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 13:49 UTC (Sun)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/839059/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the feedback. I agree I could have expanded the section on compat mode, which is indeed an extremely important tool for reducing memory usage on 64-bit machines, and should in my opinion be the default on any machines with less than a few gigabytes of RAM.<br>
<p>
For the performance benefit of running 32-bit code, the tradeoff is less clear than you describe it. While there are obvious benefits to running smaller code because of cache footprint, TLB usage and and memory interface limits, the two most common architectures also benefit a lot from running 64-bit code: on x86, 32-bit mode is limited to eight general-purpose registers compared to 16 on 64-bit, and on Arm, you go from 16 to 32 registers as well as a more modern instruction set. Unlike other traditional architectures (powerpc, sparc, mips, parisc, s390), this means you only get the clear performance benefits when you run the 64-bit instruction set with an ILP32 toolchain (x32 in case of x86). As I described, these have largely failed to gain traction despite being faster, because of the cost of maintaining a third set of binaries in addition to the ones that are already needed.<br>
<p>
Even the mixed 32/64 environments are on their way out in common distros. This used to be common in Android and ChromeOS and well supported in Red Hat, SUSE, Ubuntu and others, but these days the binary distros either only offer full builds for 64-bit or like Android always pick the 64-bit binaries when both are available. Debian is the most notable exception of course, allowing to mix and match binaries from three different targets (arm64/armhf/armel or x86_64/i386/x32) plus more if you count qemu-user. A more common and more practical way of mixing nowadays is to use containers to e.g. run a 32-bit Debian or Adelie docker image on an Arm64 or x86-64 host, as this avoids tricky library dependencies. Note also that a mixed root file system is less portable on Arm as it does not work on modern aarch64-only processors, and it adds overhead for keeping two sets of shared libraries on disk and in memory, but that is a similar overhead to any container setup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor840445"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2020 21:20 UTC (Wed)
                               by <b>atomsymbol</b> (guest, #109825)
                              [<a href="/Articles/840445/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I agree with most parts of your comment. However, just some notes:

<ul>
<li>It is likely that the number of programmer-visible registers in future CPUs will be less relevant to performance than today:
<ul>
<li>Future CPUs will be able to process multiple L1D cache loads and stores per cycle
<ul>
<li>Year 2021: A fast x86 CPU core can process up to 3 L1D loads per cycle
</ul>
<li>A Zen 2 CPU core, or a Skylake CPU core, has 180 integer registers. Zen 2 integer reorder buffer size is 224 items. A Zen 3 CPU core has 192 integer registers.
<ul>
<li>The main question is how to extract more ILP (instruction-level parallelism) from a sequential instruction stream in order to maximize the utilization of those 180/192 integer registers.
</ul>
<li>A high-performance CPU core contains a data forwarding network bypassing the L1D cache
</ul>
<li>I believe you might be putting too much emphasis on what the programmer sees (8 registers vs 16 registers), instead of putting emphasis on what the CPU is doing
</ul>
      
          <div class="CommentReplyButton">
            <form action="/Articles/840445/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor841534"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 1, 2021 11:14 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/841534/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually I&#x27;ve used to run my previous PC for 5 years or so with a 64-bit kernel and a 32-bit distro. This was a nice solution. By then, no single application required more than 2G of RAM, the code was compact and used to load fast. I&#x27;d say that upgrading an old 32-bit system just by using a 64-bit kernel in compat mode is already a nice and easy step forward.<br>
<p>
On ARM, I consistently found that 32-bit thumb2 code runs 20% faster than 64-bit armv8 code for compilation jobs, leading me to build my toolchains in 32-bit and run them on a 64-bit system in compat mode as well.<br>
<p>
My feeling is that compat mode is another good solution to allow the kernel to abandon older 32-bit support (I mean at least the largest setups which do not make sense anymore).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/841534/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor839072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2020 18:17 UTC (Sun)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/839072/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are 32bit binaries that cannot be build on 32bit platforms because g++ (etc.) require more than 4GB of RAM to compile them, so they are cross-build on 64bit platforms, even though they do not require that much memory to run.<br>
This is a problem for Debian.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor839245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 10:42 UTC (Tue)
                               by <b>mzyngier</b> (subscriber, #32898)
                              [<a href="/Articles/839245/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Small correction:<br>
<p>
<font class="QuotedText">&gt; The latest generation of Armv8.2 cores have dropped hardware support for running 32-bit kernels completely. This includes the &quot;little&quot; Cortex-A55 [...]</font><br>
<p>
A55 supports 32bit at all exception levels, and so does A75. Hopefully these are the last ARM 64bit cores to support 32bit at privileged exception levels.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 15:34 UTC (Tue)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/839256/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the correction. I had actually looked it up but then forgot I already had the incorrect information in the article. I should have written &quot;Most newer Armv8.2 cores starting with the Cortex-A76 ...&quot;.<br>
<p>
I fear the Cortex-A53/A35/A55 cores are still going to be used in new SoCs for a while though. Maybe we can add a boot-time warning into the kernel to alert users that running 32-bit kernels is a bad idea and they should be using 64-bit kernels with 32-bit user space instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 17:17 UTC (Tue)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/839324/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I suspect it's worse than that. There are a number of new phone SoCs with A73 and A53 (Snapdragon 662/665/460/439, Exynos 9610) that are going into fairly cheap phones (such as the 130 Nokia 5.3).<p>
Which makes it look as though Arm are licensing the A73 core cheaply as an intermediate level between the in-order  A55 and the high-end A76 and above, giving it a new lease of life.<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/839324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2020 20:37 UTC (Tue)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/839347/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect it&#x27;s more tied to the manufacturing process than with licensing: Cortex-A73/A53 based SoCs started out as high-end designs on 14nm, which can be refreshed into a 12nm or 11nm product without doing a complete redesign.<br>
<p>
Cortex-A75/A55 usually started out on 10nm, with a possible shrink to 8nm. It appears that this generation is not economical yet for a small low-end to mid-range chip like the Snapdragon 66x, and the Snapdragon 460 looks like a co-design of that, if not the same chip in a lower bin.<br>
<p>
I would not expect the Cortex-A73/A53 generation to be nearly as long-lived as the pure A7 or A53 versions, but instead get replaced with A75/A55, A76/A55 etc as the respective designs make it from high-end to mid-range chips. There are already Snapdragon 690 and Exynos 800-series mid-range chips based on 8nm A77/A55  that fit this description, while Mediatek and Unisoc already tend to use newer cores on older processes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor840771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2020 20:10 UTC (Fri)
                               by <b>midol</b> (guest, #25855)
                              [<a href="/Articles/840771/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
this is a terrific article on a difficult subject, hats off to Arnd!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/840771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor841535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 1, 2021 11:25 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/841535/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice write-up Arnd. A few points:<br>
<p>
- I haven&#x27;t seen Alpha mentioned anywhere, probably because it directly entered as 64-bit, as the 32-bit variants were already outdated when Linux was ported there<br>
<p>
- there were 32-bit x86 systems after the atom 270. I&#x27;ve been trapped into this by buying a cheap ASUS EeePC netbook equipped with a Atom N2600 (which I&#x27;m currently typing on). While the CPU was designed to be 64-bit (and I bought it for this reason), this one is limited to 32-bit, and long mode cannot be enabled in the BIOS. I suspect that ASUS had a deal with intel to buy the defective 64-bit chips that were still working fine for 32-bit. I don&#x27;t think this practice exists anymore though.<br>
<p>
- the RK3288 (quad-cortex A17) was present a lot in the wild but mostly in proprietary Android-based set-top-boxes and HDMI sticks. These were not documented and were a real pain to convert to Linux, hence why there are almost no DTS files for them, and it&#x27;s sad because these chips are very powerful and available at plenty of places in large configurations which could have made nice little PCs by then (typically 1-2GB RAM)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/841535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2021 22:44 UTC (Mon)
                               by <b>mat2</b> (guest, #100235)
                              [<a href="/Articles/849452/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;While the CPU was designed to be 64-bit (and I bought it for this reason), this one is limited to 32-bit, and long mode cannot be enabled in the BIOS.&quot;<br>
<p>
Well, I wonder whether the 64-bit mode is really disabled in the CPU or only hidden in the CPUID flags. If the latter, the computer could be made to run a 64-bit kernel.<br>
<p>
Similarly, there are some Pentium M processors that support PAE (Physical Address Extensions), but do not show this support in CPUID. They could be made to run distributions that require PAE with the &quot;forcepae&quot; kernel command line parameter.<br>
<p>
This could be tested by removing the verify_cpu check in arch/x86/boot/compressed/head_64.S<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2021 13:11 UTC (Tue)
                               by <b>amacater</b> (subscriber, #790)
                              [<a href="/Articles/849474/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A quicker check, maybe, for this situation on an unknown PC: boot the netinst for Debian multi-arch - there are various settings there, one of which is 64 bit kernel and 32 bit userland.<br>
<p>
I do remember a Toshiba tablet/convertible PC which was almost exactly this and the multi-arch was the only thing that would boot<br>
it at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849524"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2021 18:08 UTC (Tue)
                               by <b>mat2</b> (guest, #100235)
                              [<a href="/Articles/849524/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This won&#x27;t work because the 64-bit kernel detects whether the CPU supports the 64-bit mode and refuses to boot otherwise.<br>
So a mixed mode system will not boot, it is necessary to override the check in the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849524/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor904764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2022 17:53 UTC (Mon)
                               by <b>tim_small</b> (guest, #35401)
                              [<a href="/Articles/904764/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The currently announced end of manufacture date for the STMicroelectronics STM32MP1 processors (at least the dual core Cortex A7 variant STM32MP157DAA1) is 2036 - so these will be going into embedded systems for a while longer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The future of 32-bit Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 21:58 UTC (Wed)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/908940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are indeed new Cortex-A7 based SoCs running Linux coming out all the time, including some on modern process nodes down to 5nm (e.g. Qualcomm SDX65), so my prediction about <br>
it ending with 28nm availability was clearly wrong, though those particular chips probably don&#x27;t have a 10+ year product life.<br>
<p>
NXP has extended product longevity for parts of its i.MX6 (Cortex-A9) family up to 20 years ending in 2035, and Microchip recently announced their SAMA7G54 (Cortex-A7) that may live even longer.<br>
<p>
On the other hand, some products had their availability cut by the semiconductor shortage: I had listed QorIQ P3-Series EOL for 2025, but now the entire 32-bit QorIQ family has gone out of production.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
