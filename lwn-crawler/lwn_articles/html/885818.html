        <!DOCTYPE html>
        <html lang="en">
        <head><title>Extending restartable sequences with virtual CPU IDs [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/885818/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/885967/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/885818/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Extending restartable sequences with virtual CPU IDs</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 28, 2022</br>
           </div>
Restartable sequences, a Linux kernel feature that facilitates the writing
of lockless, per-CPU code in user space, has been around for some years,
but it only just <a href="/Articles/883104/">received support in the GNU C
Library</a> this month.  Now that this barrier has been crossed, it would
seem that the time has come to start adding features.  Mathieu Desnoyers
has responded to this challenge with <a
href="/ml/linux-kernel/20220218210633.23345-1-mathieu.desnoyers@efficios.com/">a
patch set</a> adding an extension mechanism and a new "virtual CPU ID"
feature.
<p>
See the above-linked article for an overview of how restartable sequences
work.  As a reminder, any thread using restartable sequences must first make 
use of the <tt>rseq()</tt> system call to register a special structure
with the kernel.  That structure is used to point to the <tt>rseq_cs</tt>
structure describing the current critical section (if any); the kernel also
ensures that it contains the ID number of the current CPU whenever the
thread is running.  Consistent with the pattern used in many relatively
recent system 
calls, <tt>rseq()</tt> requires the caller to also provide the size of the
<tt>rseq</tt> structure being passed in.
<p>
That length parameter exists to support future extensions to the system
call.  New features will generally require new data, increasing the size of
the <tt>rseq</tt> structure.  By looking at the size passed by user space,
the kernel can tell which version of the <tt>rseq()</tt> API the calling
process expects.  When carefully used, this mechanism allows existing
system calls to be extended in a way that preserves compatibility with
older programs.
<p>
That still leaves an open question for programs that need to discover
which API version they are dealing with as a way of knowing which features
are available.  One possibility is to invoke the system call with the most
recent version of the structure and fall back to an earlier version if the
call fails.  Another is to simply have the kernel say which structure size
it is prepared to accept.  The <tt>rseq()</tt> patches take the latter
approach, making the maximum accepted structure size available via <a
href="https://man7.org/linux/man-pages/man3/getauxval.3.html"><tt>getauxval()</tt></a>.
<p>
Having added this extension mechanism, the patch set goes on to add two
extensions without actually using it.  These extensions add two 32-bit
values to <tt>struct rseq</tt>, which does extend its length.  But, due to
the way that the structure was defined (with 32-byte alignment), it will
already have a 32-byte allocated size, even though the (pre-extension)
structure only required 20&nbsp;bytes.  That said, user space will still be
able to tell whether the new values are supported by looking at the return
value from <tt>getauxval()</tt>.  Since the new value
(<tt>AT_RSEQ_FEATURE_SIZE</tt>) did not exist before this patch set showed
up, <tt>getauxval()</tt> will return zero on older kernels.
<p>
The first of the new values in <tt>struct rseq</tt> is called
<tt>node_id</tt> and it contains exactly that: the ID number of the NUMA
node on which the current thread is running.  This is evidently useful for
some memory allocators and, as noted in <a
href="/ml/linux-kernel/20220218210633.23345-4-mathieu.desnoyers@efficios.com/">the
patch changelog</a>, supports (in conjunction with the already-present CPU
ID) an entirely user-space implementation of <a
href="https://man7.org/linux/man-pages/man2/getcpu.2.html"><tt>getcpu()</tt></a>. 
<p>
The other new value is a bit further off the beaten path: it is called
<tt>vm_vcpu_id</tt>.  Like the <tt>cpu_id</tt> field in the same structure,
it contains an integer ID number identifying the CPU on which the thread is
running.  But, while <tt>cpu_id</tt> contains the CPU's ID number as known
by the 
kernel (and the rest of the system), <tt>vm_vcpu_id</tt> has no connection
with the actual CPU number; it is a virtual number managed by the kernel in a
process-private number space.
<p>
This new CPU ID appears to be aimed at the needs of programs running
threads on a relatively small number of CPUs in a large system.  Remember
that <tt>rseq()</tt> is aimed at helping programs access per-CPU data
structures; such structures usually take the form of an array indexed by
the current CPU ID number.  That array must be large enough to hold an
entry for every CPU in the system, and every entry must be properly
initialized and maintained.
<p>
That is just part of the task of working with per-CPU data structures.  But
imagine a smallish program, with a mere dozen threads or so, running on a
large server with, say, 128 CPUs.  Those threads may migrate over those
CPUs as they run, or they may be bound to a specific subset of CPUs; either
way, that per-CPU data structure must be set up for all 128 CPUs, which is
not particularly efficient.  It would be much nicer to match the "per-CPU"
array size to the size of the program rather than that of the system it
happens to be running on.
<p>
That is the purpose of the virtual CPU ID number.  These numbers are
assigned by the kernel when a thread is scheduled onto a (real) CPU; the
kernel takes pains to ensure that all concurrently running threads in the
same process have
different virtual CPU ID numbers.  Those numbers are assigned from their
own space, though, and are chosen to be close to zero.  That leaves the
program with fewer possible CPU numbers to deal with while preserving the
benefits of working with per-CPU data structures.
<p>
That does raise an interesting question, though: how does an application
developer know what the range of possible virtual-CPU numbers is?  When
asked, Desnoyers <a
href="/ml/linux-kernel/1323451367.108396.1645811762372.JavaMail.zimbra@efficios.com/">explained</a>:
<p>
<blockquote class="bq">
	I would expect the user-space code to use some sensible upper bound
	as a hint about how many per-vcpu data structure elements to expect
	(and how many to pre-allocate), but have a "lazy initialization"
	fall-back in case the vcpu id goes up to the number of configured
	processors&nbsp;-&nbsp;1.
</blockquote>
<p>
One might expect the virtual-CPU ID to be bounded by the number of running
threads, but the full story is more complicated than that.
Using this feature, thus, will require a bit of additional complexity on
the user-space side.
<p>
Managing these virtual CPU IDs has a potential downside on the kernel side
of the API as well: a certain
amount of the work must be done in the scheduler's context-switch path,
which is one of the hottest and most performance-critical paths in the
kernel.  Adding overhead there is not welcome.  Desnoyers has duly taken a
number of steps to minimize that overhead; they are described in <a
href="/ml/linux-kernel/20220218210633.23345-10-mathieu.desnoyers@efficios.com/">this
patch changelog</a>.  For example, a context switch between two threads of
the same program just moves the virtual CPU ID from the outgoing thread to
the incoming one, with no atomic operations required.  Single-threaded
programs are handled specially, and there is a special cache of virtual CPU
IDs attached to each run queue which can be used to avoid atomic operations
as well.
<p>
Benchmarks included in that changelog show that the performance impact of
these changes is small in most cases.  Whether that will be enough to get
the patches past the scheduler maintainers remains to be seen, though; they
have yet to comment on this version of the series.  Should this mechanism
eventually be 
merged, though, it will be another tool available to developers looking for
the best scalability possible in multithreaded applications.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Restartable_sequences">Restartable sequences</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/885818/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor886387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 17:44 UTC (Mon)
                               by <b>Bigos</b> (subscriber, #96807)
                              [<a href="/Articles/886387/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aren&#x27;t programs that don&#x27;t use too many threads better served by just using Thread Local Storage? I always thought that restartable sequences were a tool to reduce the number of &quot;aggregators&quot; (e.g. counters) for software that was running more threads than there were CPUs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 18:28 UTC (Mon)
                               by <b>compudj</b> (subscriber, #43335)
                              [<a href="/Articles/886392/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If an application has few threads, using either TLS or a per-vcpu-id approach should typically provide similar results, perhaps except on NUMA systems: in this situation the per-vcpu-id approach would help reducing the amount of CPU affinity tweaks required to provide good NUMA locality of TLS accesses.<br>
<p>
The major use-case where the vcpu-id provides a clear gain is for applications with many threads which run on a subset of the system&#x27;s cores, through use of cgroup cpusets or sched affinity. This kind of workload is typical of applications running in containers on machines that have a large number of physical cores. In this case, neither a per-core nor a per-thread approach provides an efficient use of the system&#x27;s memory.<br>
<p>
But there are also other scenarios where the virtual CPU IDs improve things. For instance, even a single-threaded application running in a NUMA system can leverage the virtual CPU IDs to make sure all per-vcpu-id data structure accesses are NUMA-node-local.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 22:52 UTC (Mon)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/886417/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For those ricers who want every last gram of performance, wouldn&#x27;t it make sense to allow a compilation option disabling the virtual CPU IDs?<br>
<p>
Obviously, more compile options is inadvisable in general, but on a system with only a few cores and a fairly large amount of memory, the benefits from virtual CPU ids are negligible, but that 2% performance change is doesn&#x27;t change in relative magnitude.  The option wouldn&#x27;t need to be complex: just make the virtual CPU ID the same as the real one, and update both parts of the structure simultaneously.  It&#x27;s really easy to implement: wrap all the V_CPU logic in a #ifndef, and add a #ifdef assignment from the CPU id to the V_CPU.  No distribution will enable it by default, but ricers and embedded programmers probably will.<br>
<p>
If you want to be extra nice, this optimization could be automatically enabled at boot on all machines with 8 or fewer cores and no CPU hotplug (eg, my laptop&#x27;s quad-core processor with SMT on).  That&#x27;d be significantly harder than just adding a few #ifdef statements, but it&#x27;d deliver a minor speed improvement to a lot of users.<br>
<p>
(not a kernel dev, so there might be some egregious flaw in my reasoning)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 1:34 UTC (Tue)
                               by <b>compudj</b> (subscriber, #43335)
                              [<a href="/Articles/886430/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree with your statement about not multiplying the number of semi-useless config options, and this is indeed one of my objectives. So currently CONFIG_VCPU_DOMAIN is only enabled if CONFIG_RSEQ and CONFIG_SMP are enabled, but it is not exposed as an explicit Kconfig option. This means building a kernel without this feature is as simple as configuring with RSEQ=n. And indeed with CONFIG_VCPU_DOMAIN=n, the implementation of task_mm_vcpu_id() uses raw_smp_processor_id(), so if we ever want to expose this as an explicit Kconfig option, we can, but I&#x27;m not convinced this is a good idea.<br>
<p>
It&#x27;s unclear to me whether there would be any overall gain in disabling this feature on systems that have a user-space that make use of it. The memory allocators (glibc, tcmalloc) will be some of the first heavy users, so I expect we will end up in a situation where having the VCPU_DOMAIN feature enabled will actually bring performance benefits to the overall system (including user-space) due to improved memory allocation/access locality.<br>
<p>
Also you are presuming that the virtual CPU IDs will bring &quot;negligible&quot; performance benefits on systems with few cores but with large amount of memory. I would like to see numbers here, because even though a system has a lot of memory, the locality of cache accesses still matters, and I expect that having the memory allocator pools spread over fewer vcpu ids (compared to number of possible cpus) will provide significant gains on workloads that have few concurrently running threads that migrate between cores.<br>
<p>
You are also presuming that virtual CPU IDs bring a 2% performance degradation. Is that number made up or did you benchmark the patch series discussed in the article ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886512"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 2:20 UTC (Wed)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/886512/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The memory allocators (glibc, tcmalloc) will be some of the first heavy users, so I expect we will end up in a situation where having the VCPU_DOMAIN feature enabled will actually bring performance benefits to the overall system (including user-space) due to improved memory allocation/access locality.</font><br>
<p>
It&#x27;d be very important how they use VCPU_DOMAIN.  If they&#x27;re indexing into an array of pointers, it wouldn&#x27;t make a difference for cache locality on a few-core system: 8 cores * 8 bytes/pointer is 64 bytes, conveniently close to where I drew my arbitrary line.  Of course, that&#x27;s assuming they align these arrays to cache lines, but I think that&#x27;s a perfectly reasonable optimization to expect.<br>
<p>
Of course, if they&#x27;re using them in any other way, than the cache optimizations are up for grabs.  <br>
<p>
<font class="QuotedText">&gt; I would like to see numbers here</font><br>
<p>
Sadly, like any annoying internet commentator, I am not tooled up to provide any numbers to back up my wild assertions.<br>
<p>
<font class="QuotedText">&gt;  I expect that having the memory allocator pools spread over fewer vcpu ids (compared to number of possible cpus) will provide significant gains on workloads that have few concurrently running threads that migrate between cores.</font><br>
<p>
That is an excellent argument that I did not think into: how migration between cores would interact with the cache locality.  I think there are some problems with assuming that locality would naturally increase using VCPU versus a standard ID, however.  <br>
<p>
Firstly, I believe (though I could be very wrong) that the scheduler will try to preferentially place a process on the same core repeatedly, so it can benefit from L1 caches.  If that is the case, VCPU makes fairly little difference in practice: the indexed structure will be repeatedly accessed at the same location, holding the same cache lines hot.<br>
<p>
Also, because the differences only matter when tasks migrate cores, by necessity the L1 and (possibly) the L2 caches won&#x27;t matter.  The difference made by caches is thus limited sharply.<br>
<p>
<font class="QuotedText">&gt; You are also presuming that virtual CPU IDs bring a 2% performance degradation. Is that number made up or did you benchmark the patch series discussed in the article ?</font><br>
<p>
Completely and utterly made up.  These are the idle theories of a procrastinating college students.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886512/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor886436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 8:25 UTC (Tue)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/886436/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is that just me or does that whole business of identifying the version of the struct by its size smell quite a bit?<br>
<p>
Why not include a version number in the struct?<br>
<p>
What happens if user-space passes in an invalid size (e.g. very large)?<br>
<p>
What happens if a future extension wants two versions of the call, each with some extra data that happens to be the same size?<br>
<p>
This just seems like a way to implement this that is broken by design.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 10:18 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/886439/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What happens if a future extension wants two versions of the call, each with some extra data that happens to be the same size?</font><br>
<p>
- Doctor, it hurts when I do that!<br>
- Then don&#x27;t do it.<br>
<p>
Gradual steps, gradual steps.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 13:24 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/886444/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <p>The length of the struct <em>is</em> a version number; each "API level" has a fixed size struct, where you only access elements that you're supposed to given the known struct size.
<p>If user space passes in a struct whose size isn't one of the known values, whether it be very large and invalid, or just from a newer kernel version, the kernel rejects it, same as it would if the version number is wrong.
<p>The extensions are ordered by presence in the kernel; if two extensions want extra data, then that's two separate struct fields, and the struct as a whole grows (it's a struct, not a union). The flags tell the kernel which fields are valid.
<p>The advantage of size as opposed to version number is that C makes it easy to get right. I call the syscall with a pointer to the struct, and sizeof(user-space version of struct), and the compiler will assist me in getting it right (failing if I try to fill in fields I don't have, not letting me give a version number that's larger than the struct). All I have to do is ensure that the compiler can see the right definition for the struct, and I'm golden.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 15:38 UTC (Tue)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886488/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The - huge - disadvantage is that any version changes must be size modifying.  What if there’s a bug or a desire to change the behavior of an existing field?  Well, we can’t handle it with versioning unless we want to blow out the size.<br>
<p>
Full stop, end of story.  Sadness and clever workarounds ensue.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886498"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 19:27 UTC (Tue)
                               by <b>compudj</b> (subscriber, #43335)
                              [<a href="/Articles/886498/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If an existing struct rseq field needs to change semantic/behavior, then it is not struct rseq anymore, and it would be named something else, and possibly registered through a new system call or with specific flags set when calling sys_rseq. The extensibility scheme for struct rseq is &quot;append only&quot; on purpose, so user-space applications can rely on having the exposed structure content unchanged in future kernels.<br>
<p>
An explicit version number that would be expected to change the semantic of existing struct rseq fields whenever it is bumped would not be practical: an application supporting the current version number could not hope to support newer versions until it is recompiled, which is a no-go in terms of backward compatibility of kernel ABIs exposed to user-space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886498/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 2:20 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886518/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you’ve decided it’s not struct rseq anymore.  That’s just something you’ve decided as a definitional line in the sand - it could just as easily be struct rseq v2, with the same layout but different semantics because you decided the earlier semantics were bad.<br>
<p>
To the second part: well, yes - you’d have to carry support for multiple versions in the kernel.   That’s all it means.  Other projects do this all time.<br>
<p>
The opposition to this is just a matter of preferring a new syscall with almost identical semantics or an extra field which changes semantics - which is what would happen if a major deficiency in the semantics were found - to an explicit versioning scheme.  And that’s …. It’s a valid preference, though it’s definitely not mine.<br>
<p>
I’m not asking you to fight this fight in the kernel, the choice has been made by others, but I do know which side I fall on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 2:21 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886519/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
By the way, this is (for my money) exactly the point of a version number - backwards compatibility by supporting multiple versions inside the API provider.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886536"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 11:37 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/886536/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Same layout but different semantics can be covered by a flags field (with the kernel rejecting requests where the flags are unknown); this means that the same fields can be interpreted differently by different kernel versions, depending on which flags you set.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886536/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 5:02 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886634/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, you can do this with flags - sometimes you end up with a flag that basically says “new version”, but it can be done.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886581"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 15:59 UTC (Wed)
                               by <b>compudj</b> (subscriber, #43335)
                              [<a href="/Articles/886581/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
struct rseq is quite different from the usual system call input/output parameters.<br>
<p>
struct rseq is meant to: have its fields populated/read by both the kernel and user-space, be allocated by a single &quot;owner&quot; library (e.g. glibc), and be used by the application executable as well as by various shared objects.<br>
<p>
So it&#x27;s not as simple as having the kernel support various versions, because all users of rseq within a process (main executable and shared libraries) need to agree on its size and feature set, because there is only a single struct rseq per thread.<br>
<p>
Therefore, the solution proposed in the patch set expose the &quot;feature size&quot; supported by the kernel through auxiliary vectors, which allows glibc to allocate enough memory in the per-thread area, and register that to the kernel through sys_rseq. This way, all rseq users within the process can agree on the size of the supported rseq feature set by looking at both glibc&#x27;s __rseq_size and the auxiliary vector rseq feature size.<br>
<p>
If many struct rseq per thread were a possibility, things would be very much different and then version numbering would be possible, but it&#x27;s been decided otherwise for the sake of keeping the kernel implementation simple and time-bounded.<br>
<p>
So independently of the preference for version vs size-based extensibility, a version-based extensibility scheme for struct rseq simply won&#x27;t work, because all user-space binaries linked into a process need to agree on the layout.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886581/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886633"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 5:01 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886633/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, thank you for that clarification - that’s quite an extra ball of complexity.  Interesting :o<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886633/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 12:07 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/886537/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could just set a flag bit. Or add a flag field if there isn&#x27;t one already.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Extending restartable sequences with virtual CPU IDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 11:02 UTC (Tue)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/886442/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, we are &quot;extending&quot; it to fit in a smaller space :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
