        <!DOCTYPE html>
        <html lang="en">
        <head><title>The fanotify API [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/339399/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/338579/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/339399/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The fanotify API</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 1, 2009</br>
           </div>
One of the features merged for 2.6.31 is the "fsnotify" file event
notification framework.  Fsnotify serves as a new, common underpinning for
the inotify and dnotify APIs, simplifying the code considerably.  But this
simplification, as welcome as it is, was never the real purpose behind
fsnotify.  Instead, fsnotify exists to serve as the support structure for
<a href="http://lwn.net/Articles/339253/">fanotify</a>, the "fscking all
notification system," which has now been posted for further review.
<p>
Fanotify was once known as <a
href="http://lwn.net/Articles/292872/">TALPA</a>; its main purpose is to
enable the implementation of malware scanners on Linux systems.  When TALPA
was first proposed, it ran into criticism on a number of fronts, not the
least of which being a general disdain for malware scanning as a security
technique.  The sad fact of the matter, though, is that a number of
customers require this functionality, so a market for such products on
Linux exists.  Thus far, scanning products for Linux have relied on a
number of distasteful techniques, including hooking into the system call
table or the loading of binary-only security modules.  Fanotify, it is
hoped, will help to wean these products off of such hacks and get them out
of the kernel altogether.
<p>
The user-space API used by fanotify is, to your editor's eye, a little
strange.  An fanotify application starts by opening a socket with the new
<tt>PF_FANOTIFY</tt> protocol family.  This socket must then be bound to an
"address" described this way:
<p>
<pre>
    struct fanotify_addr {
	sa_family_t family;
	__u32 priority;
	__u32 group_num;
	__u32 mask;
	__u32 timeout;
	__u32 unused[16];
    };
</pre>
<p>
The <tt>family</tt> field should be <tt>AF_FANOTIFY</tt>.  The
<tt>priority</tt> field is used to determine which socket gets a specific
event if more than one fanotify socket exists; lower priority values win.
The <tt>group_num</tt> is used by the fsnotify layer to identify a group of
event listeners.  The <tt>timeout</tt> field currently appears to be
unused.  Finally, <tt>mask</tt> describes the events that the application
is interested in hearing about:
<p>
<ul>
<li> <tt>FAN_ACCESS</tt>: every file access.
<li> <tt>FAN_MODIFY</tt>: file modifications.
<li> <tt>FAN_CLOSE</tt>: when files are closed.
<li> <tt>FAN_OPEN</tt>: <tt>open()</tt> calls.
<li> <tt>FAN_ACCESS_PERM</tt>: like <tt>FAN_ACCESS</tt>, except that the 
     process trying to access the file is put on hold while the fanotify
     client decides whether to allow the operation.
<li> <tt>FAN_OPEN_PERM</tt>: like <tt>FAN_OPEN</tt>, but with the
     permission check.
<li> <tt>FAN_EVENT_ON_CHILD</tt>: the caller is interested in events on 
     full directory hierarchies.
<li> <tt>FAN_GLOBAL_LISTENER</tt>: notify for events on all files in the
     system.
</ul>
<p>
Once the socket has been bound, the application can learn about filesystem
activity using the well-known event-reading system call
<tt>getsockopt()</tt>.  A call to <tt>getsockopt()</tt> with
<tt>SOL_FANOTIFY</tt> as the level and <tt>FANOTIFY_GET_EVENT</tt> as the
option will return one or more structures like this:
<p>
<pre>
    struct fanotify_event_metadata {
	__u32 event_len;
	__s32 fd;
	__u32 mask;
	__u32 f_flags;
	pid_t pid;
	pid_t tgid;
	__u64 cookie;
    };
</pre>
<p>
Here, <tt>fd</tt> is an open, read-only file descriptor for the file in
question, <tt>mask</tt> describes the event (using the flags described
above), <tt>f_flags</tt> is a copy of the flags provided by the process
trying to access the file, and <tt>pid</tt> and <tt>tgid</tt> identify that
process (in a namespace-unaware way, currently).  If the event is one
requiring permission from the application, <tt>cookie</tt> will contain a
value which can be used to grant or deny that permission.
<p>
Note that the provided file descriptor should eventually be closed;
otherwise these file descriptors are likely to accumulate rather quickly.
<p>
When access decisions are being made, the application must notify the
kernel with a call to <tt>setsockopt()</tt> using the
<tt>FANOTIFY_ACCESS_RESPONSE</tt> option and a structure like:
<p>
<pre>
    struct fanotify_so_access {
	__u64 cookie;
	__u32 response;
    };
</pre>
<p>
The <tt>cookie</tt> value from the event should be provided, and
<tt>response</tt> should be one of <tt>FAN_ALLOW</tt> or
<tt>FAN_DENY</tt>.  If the application does not respond within five
seconds, the kernel will allow the action to proceed.  Five seconds should
be sufficient for file scanning, but it could be a problem with some other
possible applications of fanotify, such as hierarchical storage management
systems.  Fanotify developer Eric Paris <a
href="/Articles/339413/">notes</a> that a future option allowing the
response to be delayed indefinitely will probably be added at some point.
<p>
It is possible to adjust the set of files subject to notifications with the
<tt>FANOTIFY_SET_MARK</tt>, <tt>FANOTIFY_REMOVE_MARK</tt>, and
<tt>FANOTIFY_CLEAR_MARKS</tt> operations.  If the
<tt>FAN_GLOBAL_LISTENER</tt> option was provided at bind time, then all
files are "marked" at the outset; <tt>FANOTIFY_REMOVE_MARK</tt> can be used
to prune those which are not interesting.  Otherwise at least one
<tt>FANOTIFY_SET_MARK</tt> call must be made before events will be
returned. 
<p>
Some details have been left out, but the above discussion covers the core
parts of the fanotify API.  Comments on this posting have been relatively
scarce; opposition to this feature seems to have faded away over the last
year or so.  What's left is getting the API right; your editor suspects
that the use of <tt>getsockopt()</tt> as an event retrieval interface may
raise a few eyebrows sooner or later.  But, once that's ironed out, chances
are good that Linux will be well on the way toward having a general file
access notification and permission interface.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#fanotify">fanotify</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Security_technologies">Security/Security technologies</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/339399/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor339508"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 1:14 UTC (Thu)
                               by <b>jamesmrh</b> (guest, #31622)
                              [<a href="/Articles/339508/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It might get more comments if posted to fsdevel &amp; cc'd to previous commenters.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339508/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor339536"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">*getsockopt*, of all things?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 5:13 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/339536/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What's wrong with sendmsg/recvmsg? Isn't that the interface commonly-used for special purpose messages over sockets? That's how SCM_RIGHTS works, after all. Come to think of it, aren't there a dozen or so  kernel&lt;-&gt;userspace interfaces that work?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339536/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">*getsockopt*, of all things?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 16:22 UTC (Thu)
                               by <b>RobSeace</b> (subscriber, #4435)
                              [<a href="/Articles/339710/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I don't understand why even normal I/O wouldn't be sufficient, without even needing control messages...  But, even control messages sound better than using a socket option for something like this...<br>
<p>
How exactly are apps to be notified that a new event is ready to be retrieved?  Will they select()/poll() as readable still, even though you don't actually read from them to get the event data?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">*getsockopt*, of all things?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 16:39 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/339716/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Normal IO isn't sufficient because we need to send a file descriptor over the socket. I think the original author decided to go with a new socket family because there's no way to send a file descriptor over an AF_NETLINK socket.
<p>
Speaking of which, AF_NETLINK seems to be exactly what's needed here, just extended to support sending file descriptors over ancillary messages.
<p>
Of course, the other option is to just create a device node and use <code>ioctl</code>. That's frowned upon, but what harm does it really do? Plus, using a device node allows you to restrict access to the device using all the usual UNIX-permission-and-POSIX-ACL goodness available anywhere else.

      
          <div class="CommentReplyButton">
            <form action="/Articles/339716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">*getsockopt*, of all things?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 18:01 UTC (Thu)
                               by <b>RobSeace</b> (subscriber, #4435)
                              [<a href="/Articles/339736/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh yeah, I kind of missed the whole FD passing part of the API...  (Is that really necessary, instead of, say, giving the filename and letting the app do its own open, or whatever it wants to do to the file?)<br>
<p>
But, yeah, I think your netlink + control message idea sounds a lot better than this method, anyway...  I still don't get how the app will be notified when it's supposed to do the getsockopt(), unless select()/poll() gets kluged up to falsely indicate readability (when you can't really read from it) when one of these events are ready to be retrieved...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339742"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">*getsockopt*, of all things?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 18:05 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/339742/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>giving the filename and letting the app do its own open</blockquote>Racetastic, yes?
<blockquote>select()/poll() gets kluged up to falsely indicate readability</blockquote>Well, to be fair, select even on ordinary objects doesn't indicate readability. It's more like "it might have been readable sometime in the recent past, if you're lucky". That's why you always call select() on non-blocking sockets, and why you always prepare to get EAGAIN even after select() reports a file descriptor to be readable.
      
          <div class="CommentReplyButton">
            <form action="/Articles/339742/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">*getsockopt*, of all things?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 18:41 UTC (Thu)
                               by <b>RobSeace</b> (subscriber, #4435)
                              [<a href="/Articles/339757/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, but this sounds even worse than that, since it was never truly readable at all, but merely has a sockopt ready to be gotten... *shrug*  It just sounds like an ugly kluge to me...<br>
<p>
How about just treating the socket as if it were a listening socket, and use accept() to return the FD (and fill the other related necessary info into the returned client sockaddr)?  Then, readability on the listener fits the already established model for normal listening sockets, to indicate a new connection to accept, and no need for any klugey FD passing behavior...  Of course, returning a non-socket FD from accept() is probably just as ugly a kluge, I suppose... *shrug*<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor340948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">*getsockopt*, of all things?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2009 23:28 UTC (Fri)
                               by <b>efexis</b> (guest, #26355)
                              [<a href="/Articles/340948/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>"(Is that really necessary, instead of, say, giving the filename and letting the app do its own open, or whatever it wants to do to the file?)"</i><br><br>

That would require the scanner (or whatever) to be running with permission to open any file on the file system... you might not want that. Much more secure to pass it a read-only already-open filehandle, and allow it to run as an unprivileged user.


      
          <div class="CommentReplyButton">
            <form action="/Articles/340948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor339575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 9:13 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/339575/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
*Finally* we can write efficient indexers and a non-disk-bashing locate(1) <br>
that doesn't rely on weird kernel hacks (was it rlocate that used a custom <br>
*LSM*, of all things, to trap file creations?)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 20:44 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/339780/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, the version of <a
href="https://www.complang.tuwien.ac.at/anton/rlocate/">rlocate</a>
for Linux-2.6 used an LSM to be able to track changes to the
file system.  The Linux-2.4 version used a more direct approach, but
that had been blocked in 2.6.  AFAIK since 2.6.24 even the LSM
approach no longer works.

      
          <div class="CommentReplyButton">
            <form action="/Articles/339780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor339627"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API - corrections</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 14:21 UTC (Thu)
                               by <b>eparis</b> (guest, #33060)
                              [<a href="/Articles/339627/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not just for anti-malware snake oil vendors.  Userspace indexers seem interested, the readahead process to profile boot operation is interested, along with some storage management techniques, which you describe.<br>
<p>
"FAN_EVENT_ON_CHILD: the caller is interested in events on full directory hierarchies."<br>
<p>
It's only for the children of the inode in question.  So marking /tmp/dir will tell you about /tmp/dir/file, but not about /tmp/dir/subdir/file.  So it still has that same PITA problem of watching a complete directory tree as inotify.<br>
<p>
<p>
"If the FAN_GLOBAL_LISTENER option was provided at bind time, then all files are "marked" at the outset; FANOTIFY_REMOVE_MARK can be used to prune those which are not interesting;"<br>
<p>
Not quite true, if FAN_GLOBAL_LISTENER is provided at bind time then all file events matching the mask provided at bind time will be sent to the listener.  FANOTIFY_SET_MARK using the ignored_mask field is used to stop notification about events.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339627/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339813"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API - corrections</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 1:28 UTC (Fri)
                               by <b>jlokier</b> (guest, #52227)
                              [<a href="/Articles/339813/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh dear.  If it has the same silly open-the-whole-tree problem before you know you have all change events, it's *not* suitable for non-disk bashing indexers.<br>
<p>
And it's not suitable for non-disk bashing virus checkers / tripwire-like programs either.<br>
<p>
Disk bashing is what happens each time you restart or remount a filesystem.  Just to traverse the directory tree to set inotify events on it.<br>
<p>
Last time I discussed this with Tracker folks, their answer was "most users don't have a lot of files, you are unusual as only developers typically have lots of files and a rich directory tree".<br>
<p>
Thanks, guys.  What happened to doing things right?<br>
<p>
Occasionally a thoughtful response emerges: "but you can't notify all the parent directories if a hard-linked file is modified".  A natural gut instinct, but mistaken.<br>
<p>
inotify already determines parent directories of all files, including linked ones, in a path-based manner: when you change a file, it follows the path used to access the file to notify listeners on the containing directory.  Linked files can be monitored accurately by either watching the inode itself, or watching all known parent directories, which you can verify from the link count and bind-mount points - a userspace problem.<br>
<p>
So do the obvious thing, and notify listeners on all containing directories up the whole path used to access the file.  (And provide an IN_ATTRIB event when the link count is incremented by linking - seen by watchers on the source path - currently that omission makes directory inotify unsuitable for verifying lack of file changes even with deep tree traversal at the moment).<br>
<p>
Then userspace has enough to watch whole trees with the same fidelity as it can now, but much more efficiently - no massive traversal required.  No disk bashing.  It'd be nice to catch up with Windows 2000 in this department.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339813/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339842"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API - corrections</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 11:04 UTC (Fri)
                               by <b>brother_rat</b> (subscriber, #1895)
                              [<a href="/Articles/339842/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I think you've misunderstood things. Try reading the original <a href="http://lwn.net/Articles/339253/"> announcement</a> and you'll see how simple it is to watch the entire file system. In particular:
<blockquote>
fanotify has two basic 'modes' directed and global.  fanotify directed
works much like inotify in that userspace marks inodes it is interested
in and gets events from those inodes.  fanotify global instead indicates
that it wants everything on the system and then individually marks
inodes that it doesn't care about.  They both have the same userspace
interface and rely on the same fsnotify in kernel infrastrucute
(although the infrastructure did have to modified to support the global
listener concept)
</blockquote>
Also look at the example program at the end of the e-mail.
      
          <div class="CommentReplyButton">
            <form action="/Articles/339842/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339973"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API - corrections</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2009 9:43 UTC (Sat)
                               by <b>jlokier</b> (guest, #52227)
                              [<a href="/Articles/339973/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The global mode does work if you want to monitor everything, system-wide, but it is too broad-scope if you just want to monitor, say, $HOME.  Or /var/www/databases.  Etc., you get the idea.  There are many good reasons to monitor everything below a particular directory.  Especially on multi-user systems.  An off the wall example: Recursively monitoring changes below $PWD would be useful for speeding up programs like Make and Git between invocations.  Recursively monitoring $HOME is appropriate for personal indexers on multi-user systems.<br>
<p>
So the obvious thing to do is improve inotify to provide recursive notifications, instead of Yet Another API to a slightly different mix of the same features.  IN_RECURSIVE: "notify this directory of events occuring on any path below the directory, not just immediately below the directory".  There you go.  Making it efficient is left as an exercise :-) (hint: lazily propagate flags up and down the dentry tree)<br>
<p>
That's notifications.  The other part is blocking operations on files - the filtering part.  We already have a mechanism for that, too: leases.  The F_SETLEASE API is clearly not suitable, but the underlying lease mechanism is close.  Suggestion: return a leased file descriptor alongside an inotify event if IN_LEASE_* flags are set.  Use F_SETLEASE or something like it to release a lease, granting or denying permission.<br>
<p>
In it's present form it is sure to be rejected due to the very strange and unnecessary API, and it  which looks like it was written by people who did not read the history of inotify's inclusion into the kernel.  inotify has it's own system calls because the original version was rejected on l-k, and told to use system calls because it's not a device or socket.<br>
<p>
As a small incremental change to inotify, it's much more likely to be accepted, and it's also much more likely to be useful for applications you haven't thought of.<br>
<p>
There might still be a reason to add a netlink socket API as well (though I can't think of one), but if so it should be a general addition to inotify, not a complete replacement which happens to be like inotify in some ways and different in others.<br>
<p>
We already have F_NOTIFY, inotify and F_SETLEASE.  We don't need yet another slightly different but nearly the same thing, which happens to be useful for a tiny set of applications but still very limited in arbitrary ways, when a little incremental improvement to inotify would be both cleaner and useful for a lot more applications.<br>
<p>
Don't get me wrong, inotify has flaws, but together with leases, it's not far off what the fanotify-using applications need.  I strongly advocate fixing them, rather than starting again.<br>
<p>
This discussion should be on linux-fsdevel...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339973/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor340949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API - corrections</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2009 23:53 UTC (Fri)
                               by <b>efexis</b> (guest, #26355)
                              [<a href="/Articles/340949/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The global method should work fine then surely; set a global listener, and ignore any notifications where the pathname doesn't begin with your required string (eg, '/home/'). If you're worried that that'll get triggered more often that it need be (esp if you want different trees monitored for different purposes) then it's not much work to create a plugable super-server that listens globally and hands you the notifications you're interested in... then everyone can have their own monitoring process for their own home directory, without there being several processes woken with each file opened... and the super-server could do extra things like make sure the monitor has read access to the file opened before handing it the FD.<br>
<p>
Also, the fact that inotify and dnotify code can be dropped from the kernel and replaced by slim wrappers around these calls instead makes sense from a code tidying/maintenance point of view. If you really think that inotify is the interface you want to use, but want it to be able to watch entire sections of the filesystem (a 'recurse' flag), then as inotify will become a wrapper around this interface that will allow you to do it, it's really not going to be hard for you to add that feature to it.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/340949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor341284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API - corrections</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2009 22:30 UTC (Tue)
                               by <b>icculus</b> (guest, #4942)
                              [<a href="/Articles/341284/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"...ignore any notifications where the pathname doesn't begin with your <br>
required string (eg, '/home/')"<br>
<p>
I don't see a way to get an actual path from this API, just the file <br>
handle.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/341284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor342044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API - corrections</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2009 7:22 UTC (Sat)
                               by <b>efexis</b> (guest, #26355)
                              [<a href="/Articles/342044/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh yeah it certainly does look like that... it can't possibly be true though, after all, how would a virus scanner warn of which file is infected without path information? How would it move or delete the file without knowing what directory it's in? It would also make it useless for an indexing system, as the indexing system is surely a file contents/metadata &lt;--&gt; file path lookup, so without the path, it's useless. You couldn't tie it to git or anything to monitor for code changes because you wouldn't know what file's being changed.<br>
<p>
Is there no file descriptor path lookup method? Would it not appear in /proc/self/fd/? There's gotta be a way otherwise surely this patch would just be laughed out. <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/342044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor347456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2009 5:49 UTC (Tue)
                               by <b>rawler</b> (guest, #60308)
                              [<a href="/Articles/347456/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can also see two relevant use-cases not mentioned here;<br>
<p>
File-system-optimisation; While ext4 now have aquired defragmentation, I <br>
still haven't seen any way in Linux other than the old tar/untar-way to <br>
re-optimise files and directories for proximity to reduce seek-time. <br>
(Say, for the apt/dpkg database). With this, it seems it would be <br>
possible having a low-priority daemon tracking file-access-order, and on <br>
system-idle (say, screensaver-time) simulate a tar/untar in frequent-<br>
access-order to reorder them into better-on-disk positions.<br>
<p>
Clutter removal; Now with the atime defaulting to relatime, it's getting <br>
a bit harder to find old unused stuff, and wipe unused packages etc. This <br>
new API should allow creating an ionice:d daemon with lax disk-queuing <br>
track usage of files in the system, mapped to apt-packages, and track how <br>
often packages are actually used. Given that accessing-process-info is <br>
now also monitored, it may even be possible to prune indexers, grep and <br>
friend from polluting the data. (By name, or by tracking access-patterns. <br>
If something walks every file in a directory, we could probably ignore <br>
it)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/347456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor443624"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2011 0:27 UTC (Thu)
                               by <b>anjwicks</b> (guest, #75008)
                              [<a href="/Articles/443624/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A use case you mentioned is exactly why I'm interested in fanotify. I tried very hard to make inotify work for this purpose but could not get the information I needed (scan and parse /proc) in time (the event would be gone by the time I got around to finding it). The problem is, inotify simply didn't provide the pid of the process who triggered the event.<br>
<p>
I am excited about fanotify and found out about it just in time. I want to thank Eric and the other guys who put in the work and provided the capabilities.<br>
<p>
I'm going to try to use fanotify to help tune a Linux installation based on what software is actually being used. There is a tool out there like this called popcon, but it is difficult to get proper precision based on atime accesses.<br>
<p>
Currently, I'm only interested in OPEN events and don't yet care about blocking events. So, this will work just fine.<br>
<p>
The reason I mentioned all of this is because I'm under the impression the tool I need doesn't exist. So I'm off to try to make it. If anybody knows of something already completed, please stop me now! :) -jeff wicks<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/443624/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor443635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The fanotify API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2011 4:04 UTC (Thu)
                               by <b>dtlin</b> (subscriber, #36537)
                              [<a href="/Articles/443635/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Kinda expensive/verbose, but <a href="http://people.redhat.com/sgrubb/audit/">auditd</a> would work, wouldn't it?
      
          <div class="CommentReplyButton">
            <form action="/Articles/443635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor462678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fanotify has a bug in kernel 3.1 or below</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2011 3:38 UTC (Wed)
                               by <b>searockcliff</b> (guest, #76465)
                              [<a href="/Articles/462678/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fanotify has a bug. <a rel="nofollow" href="http://stackoverflow.com/questions/7566755/multi-thread-opening-file-hangs-when-fanotify-is-on">http://stackoverflow.com/questions/7566755/multi-thread-o...</a><br>
<p>
here is a patch for kernel 3.1:<br>
<a rel="nofollow" href="http://marc.info/?l=linux-kernel&amp;m=131822913806350&amp;w=2">http://marc.info/?l=linux-kernel&amp;m=131822913806350&amp;...</a><br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/462678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
