        <!DOCTYPE html>
        <html lang="en">
        <head><title>Teaching the scheduler about power management [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/602479/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/602163/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/602479/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Teaching the scheduler about power management</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="GAByline">
           <p>June 18, 2014</p>
           <p>This article was contributed by Nicolas Pitre</p>
           </div>
Power-efficient CPU scheduling is increasingly important in the mobile
world, but it has become just as important in large data-center settings,
where the electricity bills can be painful indeed.  Unfortunately, the
kernel's infrastructure for CPU power management lacks integration with the
scheduler itself, with the result that scheduling decisions are not as good
as they should be.  This article reviews the state of the CPU
power-management mechanisms in the kernel and looks at what is being done
to improve the situation.
<p>

<h4>A bit of history</h4>

<p>A process
scheduler is the core component of an operating system responsible for
selecting 
which process to run next.  The scheduler implementation in the Linux
kernel has been through a couple of iterations — and even complete rewrites —
over the years. The <a
href="http://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Completely
Fair Scheduler (CFS)</a>, written by Ingo Molnar, was <a
href="http://lwn.net/Articles/230501/">introduced</a> in the 2.6.23 kernel. It
replaced the <a href="http://en.wikipedia.org/wiki/O(1)_scheduler">O(1)
scheduler</a> which, in turn, was <a
href="http://lwn.net/2002/0110/a/scheduler-e1.php3">introduced</a> in
version 2.5.2 of the kernel, also by Ingo, replacing the scheduler
implementation that existed before that. Despite all of the different
algorithms, the general goal is always the same: to try to make the most of
available CPU resources.</p>

<p>CPU resources have also evolved during this time.  Initially, the
scheduler's role was simply to properly manage processor time between all
runnable processes.  Increasing parallelism in hardware due to
the emergence of <a
href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a>, <a
href="http://en.wikipedia.org/wiki/Simultaneous_multithreading">SMT</a> (or
Hyper-threading), and <a
href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a>
added more twists to the problem. And, of course, the scheduler
had to scale to an ever-increasing number of processes and
processors in the same system without consuming too much CPU time on its
own.  These changes explain why multiple scheduler implementations have been
developed over the last half-century and are still being worked on today.
In the process, the scheduler has grown in complexity and only a few
individuals have become 
experts in this area.</p>

<p>Initially, task scheduling was all about throughput with no regard for
energy consumption; scheduler work was driven by the enterprise space, where
everything was plugged into the wall. At the other end of the spectrum, we
saw the emergence of battery-operated devices from the embedded and mobile
space, where power management is a primary concern. Separate subsystems
dealing with power management, such as <a
href="http://lwn.net/Articles/384146/">cpuidle</a> and <a
href="https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt">cpufreq</a>,
were introduced and contributed to by a different set of developers with
little scheduler experience. In due course, the power management subsystems
grew in 
complexity as well with its own experts.</p> 

<p>This split arrangement worked out reasonably well&#8230; at least
initially.  The isolation between the subsystems allowed for easier
development and maintenance. With mobile devices growing in capabilities, as
well as ever-increasing data-center electric bills, everyone started caring
about energy efficiency. This brought about core kernel changes such as <a
href="http://lwn.net/Articles/228143/">deferrable timers</a>, <a
href="http://lwn.net/Articles/223185/">dyntick</a>, and <a
href="http://lwn.net/Articles/347573/">runtime power management</a>.  The
rise of multi-core portable devices pushed the need for yet more aggressive
power-management tricks such as the <a
href="http://lwn.net/Articles/570392/">controversial use</a> of CPU
offlining.</p>

<p>There is a pattern that emerges from these changes: the more complex
scheduler and power management become, the more isolated they are from each
other. And this turns out to be completely counterproductive, since, as
we'll see later, one side can't predict what the other side
might do in the near future. Because (or in spite) of that, some chip
manufacturers are increasingly implementing <a
href="http://en.wikipedia.org/wiki/Voltage_and_frequency_scaling">DVFS</a>
in hardware away from the operating system, which exacerbates the
problem. Yet <a href="http://lwn.net/Articles/481055/">support for
ARM's big.LITTLE</a> and the increasing influence scheduler
decisions have on power consumption in general have <a
href="http://lwn.net/Articles/552889/">made it clear</a> that 
merging power management with the
scheduler is becoming unavoidable. 
</p>

<p>
<h4>Scheduler: meet cpuidle</h4>

<p>The cpuidle subsystem tries to minimize power consumption by selecting a
low-power mode, or idle mode (often referred as <a
href="http://www.hardwaresecrets.com/article/611">C-State</a>), when the
CPU is idle.  However, idling a CPU comes with a 
price: the 
more power savings such a mode provides, the longer it will take for the
affected CPU to become fully operational again. A good balance between the
power actually saved and the time "wasted" in entering and exiting a
power-saving mode has to be reached.  Furthermore, many modes consume some 
non-negligible amount of power for the CPU simply to transition in and out
of them, meaning the CPU has to be idle for a sufficiently long period of
time for those modes to be worth entering.  Most CPUs have multiple idle
modes, providing different trade-offs between achievable power savings and
latency.</p>

<p>Therefore, the cpuidle code has to gather statistics on actual CPU usage
to select the most appropriate idle mode depending on the observed idleness
pattern 
of the CPU. And this statistics-gathering work duplicates what the
scheduler already does, albeit through indirect and somewhat imprecise
heuristics.</p>

<p>Idleness patterns are determined by wake-up events bringing the CPU out of
idle. Those events can be classified into three categories:</p>

<ul>
<li> <b>Predictable events</b>:
        This group comprises all timers from which we can obtain their next
	expiry time and deduce a minimum idle period.
<p>
<li> <b>Semi-predictable events</b>:
        These are somewhat repetitive events, like I/O request completions,
        that often follow a known pattern.
<p>
<li> <b>Random events</b>:
        Anything else, such as keystrokes, touchscreen events, network
	packets, etc. 
</ul>

<p>By directly involving the scheduler in the idle-state selection
process, we can do a much better job at considering the semi-predictable
events. I/O patterns are mainly a function of those tasks generating them
and the device they're directed to.  The scheduler can therefore keep
track of the average I/O latency on a per-task basis and, possibly, with
some input from the <a
href="http://en.wikipedia.org/wiki/I/O_scheduling">I/O scheduler</a>,
provide an estimated delay for the next I/O completion to occur according
to the list of waiting tasks on a given CPU.  And if a task is migrated to
a different CPU, its I/O latency statistics are migrated along. The
scheduler is therefore in a better position to appreciate the actual
idleness of a CPU.</p>

<p>It is therefore necessary for the scheduler and cpuidle to
become better integrated, to
let the scheduler manage the available idle modes and eventually bypass the
current cpuidle governors entirely. Moving the main idle loop into the
scheduler code will also allow for better accounting of CPU time spent in the
servicing of interrupts and their occurrence rate while idle.</p>

<p>Furthermore, the scheduler should be aware of the current idle mode on
each CPU to do a better job at load balancing. For instance, let's
consider the function <tt>find_idlest_cpu()</tt> in
<tt>kernel/sched/fair.c</tt>, which looks 
for the least-loaded CPU by comparing the weighted CPU load value for each
CPU.  If multiple CPUs are completely idle, their load would be zero, with
no distinction for the idle mode they're in. In this case, it would
be highly beneficial to choose the CPU whose current idle mode has the
shortest exit latency. If idle exit latency is the same for all idle CPU
candidates then the last to have entered idle mode is more likely to have a
warmer cache (assuming the relevant idle mode preserves cache, of course).
An <a href="http://lkml.org/lkml/2014/3/28/181">initial 
patch series</a> to that effect was posted by Daniel Lezcano.</p>

<p>This also <a href="http://lkml.org/lkml/2014/4/15/364">highlighted</a>
the fact that some definitions for the same expression may differ depending
on one's perspective. A function called <tt>find_idlest_cpu()</tt> in the
scheduler context is simply the converse of <tt>find_busiest_cpu()</tt>,
whereas in 
the cpuidle context this would mean looking for the CPU with the deepest
idle state.  The deeper an idle state is, the more costly it is to bring a
CPU back to operational state&#8201;&#8212;&#8201;clearly not what we want
here.  A similar confusion may occur with the word "power".  The
traditional meaning in the scheduler code is "compute capacity" while it
means "energy consumption rate" in a power management context. <a
href="http://lkml.org/lkml/2014/5/26/614">Patches</a> to clarify this have
recently been merged.</p>

<p>
<h4>Scheduler: meet cpufreq</h4>

<p>The scheduler keeps track of the average amount of work being done by
scheduled tasks on each CPU in order to give each task fair access to
CPU resources and to decide when to perform load balancing. The <a
href="http://lwn.net/Articles/384132/">ondemand cpufreq governor</a> does
similar load tracking in order to dynamically set each CPU's clock frequency
to optimize battery life. Since energy consumption is proportional to the
square of the voltage, it
is desirable to run at the lowest clock frequency, which allows for voltage
reduction to the CPU, while still being fast enough to perform all the
scheduled work during a given period of time.  
<p>
As with cpuidle, the cpufreq subsystem was developed in isolation from the
CPU scheduler.  Many problems result from
the split between those subsystems:</p>
<p>
<ul>
<li>
<p>
The cpufreq code goes to great lengths trying to evaluate the actual CPU
  load through indirect means, including
  heuristics to avoid misprediction, while,
  once again, the scheduler has all this information available already.
</p>
</li>
<li>
<p>
The scheduler can determine the
  <a href="http://lwn.net/Articles/531853/">load contribution of individual tasks</a>,
  whereas the cpufreq code has no such ability.  In the occurrence of a
  task migration, or a task waking up, the scheduler may determine in advance
  what the load on the target CPU is likely to become. The cpufreq code may
  only notice an average load increase and react to it after the fact.
</p>
</li>
<li>
<p>
The scheduler records the execution time for each  task
  in order to ensure fairness between all tasks.  However, since the
  scheduler has no awareness of CPU frequency changes, tasks executing on a
  CPU whose clock has been slowed down will be unfairly charged more
  execution time than similar tasks running on another CPU with a faster
  clock for the same amount of work. Fairness is thus compromised.
</p>
</li>
<li>
<p>
As the CPU clock frequency is reduced, the resulting apparent increase in
task load 
may trigger 
  load balancing toward a less-loaded CPU in order to spread the
  load, despite the fact that this increased apparent load was indeed the
  cpufreq's goal initially.
</p>
</li>
<li>
<p>
And if that load balancing happens while the target CPU's clock frequency is
  reduced, then that CPU could end up being oversubscribed.  Because there
  is no coordination
  between the scheduler and cpufreq, either (or both) of them may react by,
  respectively, migrating a task back or raising the CPU clock frequency.
  The CPU may suddenly be underutilized, and the cycle could repeat again.
</p>
</li>
</ul>

<p>To fix this, the current plan is to integrate cpufreq more tightly with
the scheduler.  The various platform-specific, low-level cpufreq drivers
will remain unchanged and still register with the cpufreq core as usual;
however, the governors — the part that decides what clock
frequency to ask for and when — could be bypassed
entirely.  In fact, the scheduler could simply register itself as a new
governor with the cpufreq core.</p>

<p>The advantage of a tighter integration of cpufreq with the
scheduler is the ability to be proactive with clock frequency changes
rather than reactive, and also to coordinate better with scheduler
activities like load balancing. A CPU clock frequency change could be
requested in anticipation of a load change; this could happen in response
to a call to <tt>fork()</tt>, <tt>exit()</tt>, or when a task sleeps or
wakes up. The frequency policy could be different depending on the
particular scheduler event, task historical behavior patterns, etc.</p>

<p>However, to be able to perform well in the presence of varying CPU clock
frequencies, the notion of scale-invariant task load tracking must be added
to the scheduler.  This is a correction factor to normalize load
measurements from CPUs executing code at different speeds so the load
contribution of a task can be predicted when the task is moved.  The relative
computation capacity of each CPU as seen by the scheduler also has to be
adjusted according to its effective clock frequency in order to do proper
load balancing. It is still unclear how accurate this correction factor can
be, considering that tasks making lots of memory accesses are less likely
to be influenced by the CPU clock speed compared to tasks performing
computational work, etc.  Still, anything is going to be better than no
correction at all like we have today.</p>

<p>Incidentally, the scale-invariant load tracking does apply to big.LITTLE
scheduling as well.  Leaving cpufreq aside for a moment, a "little"
CPU is permanently slowed down, which translates into a reduced compute
capacity to the scheduler, and conversely a "big" CPU has more
capacity. With distinct correction factors permanently applied to "big" and
"little" CPUs, the scheduler is likely to just work optimally in terms of
task throughput, with no further changes to the scheduler.  The cpufreq
correction factor simply has to be combined with the "big" and "little"
factors afterward.</p>

<p>Several developers, including Mike Turquette and Tuukka Tikkanen, are
working on the <a
href="http://www.slideshare.net/linaroorg/lca14-306-cpuidlecpufreqintegrationwithscheduler">cpufreq
integration</a> and initial patches should be posted for public review
soon.</p>
<p>
<h4>Scheduler: may the power be with you</h4>

<p>Okay&#8230; So we might get to the point where cpuidle and cpufreq are
tightly integrated with the scheduler. Are we done? Unlikely. In fact we
now have more difficult decisions to make than before and they all relate
to the new mechanisms at the scheduler's disposal to perform load
balancing. For example:</p>

<ul>
<li>
<p>
When the system load goes up, should a new CPU be brought out of idle, or
  should the clock frequency on an already running CPU be increased instead?
  Or both?
</p>
</li>
<li>
<p>
Conversely, when the system load goes down, is it best to keep more CPUs
  alive with a reduced clock frequency or pack more tasks on fewer CPUs in
  order to send the other CPUs to sleep?
</p>
</li>
<li>
<p>
Is it best to consolidate loads onto fewer CPUs
  or to spread the load over more CPUs?
</p>
</li>
<li>
<p>
When is it time to perform active <a href="http://lwn.net/Articles/520857/">task
  packing</a> to let a whole CPU cluster (or package)  get into low-power mode?
</p>
</li>
</ul>

<p>The latest <a href="http://lwn.net/Articles/600419/">power-aware
scheduler</a> work from Morten Rasmussen provides a framework to evaluate
the power cost of the available scheduling scenarios. This, in combination
with Vincent Guittot's <a
href="https://lkml.org/lkml/2014/3/19/377">sched_domain topology</a> and <a
href="https://lkml.org/lkml/2014/5/23/458">CPU capacity tracking
consolidation</a> work, should provide answers to the above questions.</p>
<p>
<h4>What else?</h4>

<p>We desperately need
measurement
tools to validate proposed solutions. Linaro is working on a tool
called <a
href="https://wiki.linaro.org/WorkingGroups/PowerManagement/Resources/Tools/Idlestat">idlestat</a>
to validate idle-state usage and its effectiveness.  Traditional
benchmark tools such as <a
href="http://www.howtoforge.com/how-to-benchmark-your-system-cpu-file-io-mysql-with-sysbench">sysbench</a>
may be combined with <a href="http://lkml.org/lkml/2014/6/6/286">energy
usage monitoring</a> to provide a way to perform power characterization of
a system. Extensions to <a
href="https://rt.wiki.kernel.org/index.php/Cyclictest">cyclictest</a> to
create various synthetic workloads are being explored as well. This is
still unwieldy, though, and more integration and automation are required.</p>

<p>This article hasn't covered <a
href="http://en.wikipedia.org/wiki/Thermal_management_of_electronic_devices_and_systems">thermal
management</a>.  The Linux kernel implements a thermal-management <a
href="https://www.kernel.org/doc/Documentation/thermal/sysfs-api.txt">interface</a>
that allows a <a
href="http://www.linux.com/news/featured-blogs/200-libby-clark/721494-linux-thermal-daemon-monitors-and-controls-temperature-in-tablets-laptops">user-space
daemon</a> to control thermal constraints. However, as we've 
seen, power-related issues are intertwined, and a thermal-control
solution that lives separately from the scheduler is likely to be
suboptimal. If the scheduler controls power states, it will also have to
deal with platform temperature someday, providing <a
href="http://lwn.net/Articles/599598/">thermal "provisioning"</a> or the
like. But we can save this for another day.</p>
<p>
<h4>Thanks</h4>

<p>Thanks to Amit Kucheria, Daniel Lezcano, Kevin Hilman, Mike Turquette,
and Vincent Guittot for their help in reviewing this article.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Power_management-CPU_scheduling">Power management/CPU scheduling</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler-and_power_management">Scheduler/and power management</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Pitre_Nicolas">Pitre, Nicolas</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/602479/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor602960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2014 7:00 UTC (Fri)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/602960/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This was a tremendously interesting article. Nice job.<br>
I've a few comments, and questions, hopefully none of which are naive:)<br>
Shouldn't predictable events, plus timer slack, indicate a maximum, rather than minimum, idle period?<br>
You mentioned thermal management at the end, but what about platform power management? Say, putting USB to sleep, powering down the pcie bus a bit, etc?<br>
All the questions at the end seem as though they should have fairly easy answers assuming the scheduler is made aware of a few package constants (available c/p states, energy consumed transitioning between c/p states (with the average wakeup period being then inferable), this scale invariant correction factor), along with the data its already gathered for scheduling purpose.<br>
Lastly, given your description of the interplay between the scheduler, cpufreq, and cpuidle, it's astonishing things have worked as well as they have. I'm not saying we should call the Vatican, but is there any other possibility than divine intervention that could explain how cpufreq and the scheduler have managed as well as they have?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/602960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor602963"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2014 7:57 UTC (Fri)
                               by <b>amit.kucheria</b> (subscriber, #59246)
                              [<a href="/Articles/602963/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; but what about platform power management? Say, putting USB to sleep, powering down the pcie bus a bit, etc?</font><br>
<p>
The scheduler should only make decisions based on the active subset of available idle states for the CPU. The assumption I'll make here is that peripheral power management is being handled by runtime PM.<br>
<p>
If the available idle state of the CPU depends on the state of certain peripherals (e.g. having USB active prevents a CPU OFF state), then IMO the peripheral PM code should active/deactivate the associated C-state. Then the scheduler/cpuidle just won't select it. <br>
<p>
This requires modeling the SoC's separate power domains. There is some work happening in that area but there are probably gaps in what the current pm_domain/genpd/runtime PM/pm-qos abstractions allow us to do that still need fixing.<br>
<p>
However, it can happen in parallel to the work of making the scheduler a bit more energy-aware.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/602963/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor603032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2014 21:59 UTC (Fri)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/603032/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The scheduler should only make decisions based on the active subset of available idle states for the CPU. The assumption I'll make here is that peripheral power management is being handled by runtime PM.</font><br>
<p>
Well, also p-states, I'd imagine, but it seems like you'd want to centralize power management SOMEWHERE. By centralize I mean that some single component is aware of all peripherals (including CPU) and can make decisions based upon overall system state (not always needed, but certainly useful at times). Such decisions seen best left up to the scheduler. A trivial example would be a lightning/thunderbolt connected peripheral, say, a GPU. The driver handles the power state of the GPU itself, but the pcie connection would be handled by the platform pm, I believe. Now, for a laptop, that GPU should be seen as just another compute source (not handled in the same way as the CPU cores by the scheduler but still as computational units for at least certain kinds of loads). Given some highly vectorized opencl code, the scheduler would seem to be in the best position to determine if it's worth bringing the GPU out of sleep to pound away at the data. <br>
In more general cases, the scheduler would be the only single component in the system capable of making decisions about the periodic and semi-periodic events that would heavily inform power management of peripherals. For one thing, this can cut down on latency if the scheduler can accurately predict peripheral events some of the time. This is obviously a place where the data gathered would heavily inform the heuristics... and it's possible it may not be something that helpful in general. I don't know, but it appears to be the next needed step in order to increase platform efficiency.<br>
It's for the above reasons that it seems, to me, that the scheduler would be in the best position to make decisions about peripheral power states.<br>
<p>
<p>
<p>
<font class="QuotedText">&gt; This requires modeling the SoC's separate power domains. There is some work happening in that area but there are probably gaps in what the current pm_domain/genpd/runtime PM/pm-qos abstractions allow us to do that still need fixing.</font><br>
<p>
I'm sure you're right. Even now, I don't think all of the common drivers support pm-qos properly. <br>
This is clearly an area where Linux has some catching up to do. Has anyone looked at how the OTHERS manage things?<br>
<p>
<font class="QuotedText">&gt; However, it can happen in parallel to the work of making the scheduler a bit more energy-aware.</font><br>
<p>
Well, yeah, but only if it turns out that it doesn't make sense for the scheduler to be involved. I think I've provided a few cases where it having the scheduler involved in platform level decisions can yield benefits... but o might be completely off-base.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/603032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor602967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2014 8:40 UTC (Fri)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/602967/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; it's astonishing things have worked as well as they have. I'm not saying we should call the Vatican, but is there any other possibility than divine intervention that could explain how cpufreq and the scheduler have managed as well as they have?</font><br>
<p>
Thanks to heuristics accumulated over the years. And it's not working so well, there still are common cases where cpufreq fails to ramp up frequencies sufficiently with CPU-bound workloads, like configure scripts or two processes synchronously communicating via RPC.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/602967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor603254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2014 21:45 UTC (Mon)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/603254/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For completion I guess I would complement the article with the concept of deep sleep, (the lowest C-state in ACPI lingo). This happens when the scheduler calls arch_cpu_idle() meaning "I have nothing whatsoever to do". So actually the scheduler *is* already doing some kind of power management: the final sledgehammer type.<br>
<p>
At this point, if the hardware supports it, everything is powered off in the system, often including all the CPU cores, and the system goes into a state where it is totally dependent on some special always-on hardware to detect an external event (such as a wake-up signal from a keypad or network card) to occur until Cinderella wakes up. In embedded system these events are very often actually controlled into the pad ring around the chip edge (which we model and set up with the pin control mechanism). Sometimes the chip has a small low-power microcontroller for the sole purpose of waking up the system.<br>
<p>
Systems that do not have the hardware to actually power off CPU cores usually have its cores go to a state where the CPU is powered but similarly catatonic, waiting for an IRQ of some sort, a state called "Wait For Interrupt" or WFI.<br>
<p>
Another thing that occurred to me was inputs that sometimes needs to come into the cpu frequency or idleness selection related to the state of the entire electronic or SoC system, and unknown even to the scheduler. A typical example would involve a system with heavy use of DMA or GPUs or other accelerators, where these system components may require that the CPU be in a very responsive mode due to the fact that these hardware engines need quick responses to their IRQs etc, or that the system in some other way need to take power decisions (such as related to thermal) depending on the load on such CPU-external datapaths.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/603254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor603291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2014 6:20 UTC (Tue)
                               by <b>amit.kucheria</b> (subscriber, #59246)
                              [<a href="/Articles/603291/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This happens when the scheduler calls arch_cpu_idle() meaning "I have nothing whatsoever to do". So actually the scheduler *is* already doing some kind of power management: the final sledgehammer type.</font><br>
<p>
Right. The closer cpuidle-scheduler integration will encourage this behaviour - if we get the right task spread across the CPUs, we should be able to go to these deep sleep states more often and stay there longer without impacing performance.<br>
<p>
<font class="QuotedText">&gt; A typical example would involve a system with heavy use of DMA or GPUs or other accelerators, where these system components may require that the CPU be in a very responsive mode due to the fact that these hardware engines need quick responses to their IRQs etc,</font><br>
<p>
I believe this is the bit liam was alluding to earlier - whole-system power/performance  management. A combination of runtime PM-enabled drivers, correct PM domain modeling of the SoC and smart use of pm-qos constaints *should* allow us to do this but there aren't many good examples of how to do this today. Definitely something to fix.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/603291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor603641"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 26, 2014 19:20 UTC (Thu)
                               by <b>facorread</b> (guest, #59578)
                              [<a href="/Articles/603641/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for posting this excellent article.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/603641/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor603755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2014 16:21 UTC (Fri)
                               by <b>richdawe</b> (subscriber, #33805)
                              [<a href="/Articles/603755/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you, this article is excellent.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/603755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor604016"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Teaching the scheduler about power management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 1, 2014 14:53 UTC (Tue)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/604016/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;As the CPU clock frequency is reduced, the resulting apparent increase in task load may trigger load balancing toward a less-loaded CPU in order to spread the load</font><br>
<p>
Is this something that only happens if the load on that CPU is &gt;=1, or will it always try to keep CPUs balanced even when they're all below capacity? If the latter, what's the reasoning behind that?<br>
<p>
I've noticed, on both Linux and Windows, that a task consuming 100% CPU will be shuffled around frequently enough that (on a quad core CPU) each core permanently appears to be 25% loaded.<br>
<p>
This seems suboptimal, and I've done some informal benchmarking on Windows with the apparent result that manually setting the processor affinity of such processes to two cores increases overall throughput by several percent, by allowing Turbo Boost to do its thing. I say 'apparent' result, because I've not done a large sampling, though I did do enough runs that I'm reasonably happy with the result.<br>
<p>
(Specifically, I was trying to reduce my Civ 5 turn times. Two cores work better than one there because it is in fact multithreaded; it's just that one thread represents at least 90% of the total load. So I'd guess that on a purely single-threaded workload it would probably be even better to force it on to one core.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604016/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
