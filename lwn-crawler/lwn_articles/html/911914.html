        <!DOCTYPE html>
        <html lang="en">
        <head><title>Would you like signs with those chars? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/911914/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/911876/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/911914/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Would you like signs with those chars?</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 24, 2022</br>
           </div>
Among the many quirks that make the C language so charming is the set of
behaviors that
it does not define; these include whether a <tt>char</tt> variable is a
signed quantity or not.  The distinction often does not make a difference,
but there are exceptions.  Kernel code, which runs on many different
architectures, is where exceptions can certainly be found.  A recent
attempt to eliminate the uncertain signedness of <tt>char</tt> variables
did not get far — at least not in the direction it originally attempted to
go.
<p>
As a general rule, C integer types are signed unless
specified otherwise; <tt>short</tt>, <tt>int</tt>, <tt>long</tt> all
work that way.  But <tt>char</tt>, which is usually a single byte on
current machines, is different; it can be signed or not, depending on
whatever is most convenient to implement on any given architecture.  On x86
systems, a <tt>char</tt> variable is signed unless declared as
<tt>unsigned&nbsp;char</tt>.  On Arm systems, though, <tt>char</tt>
variables are unsigned (unless explicitly declared <tt>signed</tt>) instead.
<p>
The fact that a <tt>char</tt> variable may or may not be signed is an easy
thing for a developer to forget, especially if that developer's work is
focused on a single architecture.  Thus, x86 developers can get into the
habit of thinking of <tt>char</tt> as always being signed and, as a result,
write code that will misbehave on some other systems.  Jason Donenfeld
recently encountered this sort of bug and, after fixing it, posted <a
href="/ml/linux-kernel/20221019162648.3557490-1-Jason@zx2c4.com/">a
patch</a> meant to address this problem kernel-wide.  In an attempt to
"<q>just eliminate this particular variety of heisensigned bugs
entirely</q>", it added the
<tt>-fsigned-char</tt> flag to the compiler command line, forcing the bare
<tt>char</tt> type to be signed across all architectures.
<p>
This change turned out to not be popular.  Segher Boessenkool <a
href="/ml/linux-kernel/20221019165455.GL25951@gate.crashing.org/">pointed
out</a> that it constitutes an ABI change, and could hurt performance on
systems that naturally want <tt>char</tt> to be unsigned.  Linus Torvalds
<a
href="/ml/linux-kernel/CAHk-=wiMWk2t8FHn0iqVVe1mn62OTAD6ffL5rn9Eeu021H9d1Q@mail.gmail.com/">agreed</a>,
saying that: "<q>We should just accept the standard wording, and be aware
that 'char' has indeterminate signedness</q>".  He disagreed, however, with
Boessenkool's suggestion to remove the <tt>-Wno-pointer-sign</tt> option
used now (thus enabling <tt>-Wpointer-sign</tt> warnings).  That change
would enable a warning that results from the mixing of
pointers to signed and unsigned <tt>char</tt> types; Torvalds complained
that it fails to warn when using <tt>char</tt> variables, but <a
href="/ml/linux-kernel/CAHk-=wiNNKLFfa0d+Hk=Wm5caiKjLY4V9wwu9DhcSSwPuMbxrg@mail.gmail.com/">produces
a lot of false positive warnings</a> with correct code.
<p>
Later in the discussion, though, Torvalds <a
href="/ml/linux-kernel/CAHk-=whT+xyge9UjH+r6dt0FG-eUdrzu5hDMce_vC+n8uLam2A@mail.gmail.com/">wondered</a>
whether it might be a good idea to nail down the signedness of
<tt>char</tt> variables after all — but to force them to be <i>un</i>signed
by default rather than signed.  That, he said, shouldn't generate worse
code on any of the commonly used architectures.  "<q>And I do think that
having odd architecture differences is generally a bad idea, and making the
language rules stricter to avoid differences is a good thing</q>".
Amusingly, he noted that, with this option, code like:
<p>
<pre>
    const unsigned char *c = "Subscribe to LWN";
</pre>
<p>
will still, with the <tt>-Wpointer-sign</tt> option, generate a warning,
since a string constant pointer is still considered to be a bare
<tt>char&nbsp;*</tt> 
type, which is then treated as being different from an explicit
<tt>unsigned char&nbsp;*</tt> type.  "<q>You *really* can't win this
thing. The game is rigged like 
some geeky carnival game</q>".
<p>
Donenfeld <a href="/ml/linux-kernel/Y1BcpXAjR4tmV6RQ@zx2c4.com/">saw
merit</a> in the idea, even though he thinks that the potential to break
some code exists.  He sent out <a
href="/ml/linux-kernel/20221019203034.3795710-1-Jason@zx2c4.com/">a new
patch</a> adding <tt>-funsigned-char</tt> to the compiler command line
to effect this change.  He had suggested that it could perhaps be merged immediately,
given that there is time to fix any fallout before the 6.1 release, but
Torvalds <a
href="/ml/linux-kernel/CAHk-=wit-67VU=kt-8Ojtx04m6wxfqypKLzW7CuSeEH_9MYZvw@mail.gmail.com/">declined
that opportunity</a>: "<q>if we were still in the merge window, I'd probably apply this,
but as things stand, I think it should go into linux-next and cook
there for the next merge window</q>".  He added that any problems that
result from the change are likely to be subtle and to be in driver code
that isn't widely used across architectures.  The core kernel code,
instead, has always had to work across architectures, so he does not
believe that problems will show up there.
<p>
So Donenfeld's patch is sitting in linux-next instead, waiting for the 6.2
merge window in December.  That gives the community until late February to
find any problems that might be caused by forcing bare <tt>char</tt>
variables to be unsigned across all architectures supported by Linux.  That
is a fair amount of time, but it is also certainly not too soon to begin
testing this change in as many different environments as possible.  It is,
after all, a fundamental change to the language in which the kernel is
written; a lack of resulting surprises would, itself, be surprising.
<p>
One way to identify potential problems is to find the places where the
generated code changes when <tt>char</tt> is forced to be unsigned.
Torvalds has already <a
href="/ml/linux-kernel/CAHk-=whg00wpUzNLs0obmMKA3GhUnLzat9syA1=_tfi8Ms8TLg@mail.gmail.com/">made
some efforts in that direction</a>, and Kees Cook has <a
href="/ml/linux-kernel/202210201056.DEE610F6F@keescook/">used a system
designed for checking reproducible builds</a> to find a lot of changes.
Many of those changes will turn out to be harmless, but the only way to
know for sure is to actually look at them.  Meanwhile, the <a
href="/ml/linux-kernel/Y1EZuQcO8UoN91cX@localhost.localdomain/">posting of
one fix</a> by Alexey Dobriyan has caused Torvalds to <a
href="/ml/linux-kernel/CAHk-=whFow9Wd6C8htoRUt5wXbwf1i_qbuArBbhXOPqYsTFvtw@mail.gmail.com/">request</a>
that the <tt>char</tt> fixes be collected into a single tree.  As those
fixes accumulate, the result should be a sign of just how much
disruption this change is actually going to cause.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Build_system">Build system</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/911914/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor912200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 18:14 UTC (Mon)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/912200/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C has also the isalpha et al class of function that conveniently take an int argument, but  are sometime implemented as an array so you have to cast any char argument to unsigned char to shut up the compiler, even if your strings are 7bit.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 21:29 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/912210/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That isn't the problem, as far as I can tell. The problem is that, if you accidentally have a character with the high bit set (because you're using ISO-8859-1 or Windows-1252 or some other 8-bit ASCII superset instead of* UTF-8), then it will sign extend and you will get nonsense. Since those non-Unicode encodings used to be fairly popular, compilers started warning on this, even though I believe there's nothing in the standard that explicitly requires a diagnostic on conversion from char to int. Taking care to do this is good practice, because if you offer a 7 bit channel, people will (ab)use it as an 8 bit channel whether it is intended to support that or not.<br>
<p>
If you can find an environment where someone actually declared isalpha and relatives with arrays rather than ints, I would be very surprised, because the standard specifies that the argument must be an int, and any subsequent int-to-array conversion is the callee's problem.<br>
<p>
* This problem is theoretically also possible if you are using UTF-8, but in that case, you'll get nonsense anyway, because UTF-8 has to be decoded before you can call functions like isalpha on it - and at that point, you've already widened everything to 32 bit, so hopefully you did it correctly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912218"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 22:45 UTC (Mon)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/912218/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; That isn't the problem, as far as I can tell.</span><br>
<p>
I can't find conclusive examples for is- ctype routines, but here is how tolower was defined during the first few releases of OpenBSD, as forked from NetBSD:<br>
<p>
  #define tolower(c)	((_tolower_tab_ + 1)[c])<br>
<p>
It's still defined similarly on NetBSD, today: <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/sys/ctype_inline.h?rev=1.4">http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/sys/ctype_inl...</a><br>
<p>
Also, EOF is a permitted value and typically -1 (thus the +1 in the above), though that would typically only be an issue for non-C locales.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912218/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 23:41 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/912221/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; #define tolower(c) ((_tolower_tab_ + 1)[c])</span><br>
<p>
Even so, I don't believe that the standard *actually* says that c has to be unsigned in that expression - just that the "usual arithmetic conversions" happen (i.e. the compiler magicks it into an int when you're not looking). Compilers presumably added that warning because there were instances of arrays being indexed with negative char, but not negative int or any other signed type. And, again, that presumably had something to do with ASCII supersets and other nonsense involving dirty 7 bit channels.<br>
<p>
<span class="QuotedText">&gt; Also, EOF is a permitted value and typically -1 (thus the +1 in the above), though that would typically only be an issue for non-C locales.</span><br>
<p>
The argument is of type int (according to the standard, not that untyped macro), not char, so it's completely unambiguous: You are allowed to pass negative numbers to those routines, because int is always signed, and if it is implemented as a macro, it has to accept signed values in the int range. Of course, if you pass negatives other than EOF (or whatever EOF is #define'd to), then the standard presumably gives you UB (which is why it's OK for the array implementation to walk off the end in that case).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 0:22 UTC (Tue)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/912224/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The C standard says, "The header &lt;ctype.h&gt; declares several functions useful for classifying and mapping characters. In all cases the argument is an int, the value of which shall be representable as an unsigned char or shall equal the value of the macro EOF. If the argument has any other value, the behavior is undefined."<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor912331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 15:13 UTC (Tue)
                               by <b>mrvn42</b> (guest, #161806)
                              [<a href="/Articles/912331/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;&gt; #define tolower(c) ((_tolower_tab_ + 1)[c])</span><br>
<span class="QuotedText">&gt;&gt; Also, EOF is a permitted value and typically -1 (thus the +1 in the above), though that would typically only be an issue for non-C locales.</span><br>
<p>
<span class="QuotedText">&gt; The argument is of type int (according to the standard, not that untyped macro), not char, so it's completely unambiguous: You are allowed to pass negative numbers to those routines, because int is always signed, and if it is implemented as a macro, it has to accept signed values in the int range. Of course, if you pass negatives other than EOF (or whatever EOF is #define'd to), then the standard presumably gives you UB (which is why it's OK for the array implementation to walk off the end in that case).</span><br>
<p>
The problem is that this will only work for values between -1 and 127 for an array of 129 bytes. A value of -2 (or any other non-ascii value other than EOF with signed char) would access memory before the array and a value of 255 (EOF mistakenly stored in an unsigned char or anything non ascii) would access memory after the array.<br>
<p>
Looking at the source link in the other comments the BSD code seems to assume chars are unsigned. The test for ascii doesn't work with signed chars at all.<br>
<p>
So I assume that "_tolower_tab_" is actually 257 bytes long to cover all unsigned chars and EOF (which is -1 when stored as int).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor912223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 0:31 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/912223/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; you'll get nonsense anyway, because UTF-8 has to be decoded before you can call functions like isalpha on it</span><br>
<p>
ASCII is a subset of UTF-8. So if you have a C library which is content to implement these functions for ASCII, they do that fine on UTF-8 data without any decoding.<br>
<p>
You run into a problem, as you should expect, if the C library thinks the data is 8859-1 when it's actually UTF-8 but otherwise it just provides the very useful answer to the question: is this (alphabetic / a digit / punctuation/ whitespace / etc.) in ASCII ?<br>
<p>
Rust deliberately provides the ASCII variants of these functions on both char (a Unicode scalar value) and u8 (an unsigned 8-bit integer ie like C's unsigned char) named is_ascii_digit and so forth. You often do not need the fancy Unicode is_digit but only is_ascii_digit for real software because overwhelmingly the "is it a digit?" question is not cultural but purely technical.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912229"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 3:29 UTC (Tue)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/912229/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
isalpha and friends are defined to work on the current locale; you can't trust them to work on just ASCII. <br>
<p>
isxdigit is always 0-9A-F, and as far as I can tell from the manpage, isdigit is always 0-9. Barring those, why is it useful to ask "is this an alphabetic/punctuation/whitespace character in ASCII?" Pretty much everything is defined in terms of Unicode now; even if you're processing C code, you should still be prepared for identifiers in Russian, Greek or Chinese. I have a hard time thinking about a case where it's the right thing to check if something is some unspecified alphabetic character, but only those in ASCII.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912229/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 9:48 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/912256/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The typical example is configuration files where you *can* restrict identifiers to ASCII. Using locale functions will cause a mess for Turkish and Azerbaijani speakers, thanks to the "dotless i" and "dotted I" characters in their alphabets.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 15:46 UTC (Tue)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/912348/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can restrict it to ASCII, but the question is*should* you. The dotted I / dotless i issues only matter if you're doing case-insensitive comparisons, which isn't a very Unix thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor912347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 15:46 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912347/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Pretty much everything is defined in terms of Unicode now; even if you're processing C code, you should still be prepared for identifiers in Russian, Greek or Chinese.</font>

<p>Sure, but only part of your program which deals with identifiers needs adjustment.</p>

<p>You can write <code>int ｆｏｏ = 42;</code> but can not write <code>int foo = ４２;</code> which means that you can easily use “C” locale and all ASCII-only functions with a simple change: where before Unicode you used is <code>isalpha(c)</code> or <code>isalnum(c)</code> now you would use <code>c &lt; 0 || isalpha(c)</code> and <code>c &lt; 0 || isalnum(c)</code>.</p>

<p>That's how <a href="https://github.com/albert-github/doxygen/commit/7c429806b072dd8bf777d93035ffda817976adc0">doxygen handles it</a>, I would assume someone may use <code>isalpha(c)</code> and/or <code>isalnum(c)</code> in a similar way.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/912347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912351"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 16:01 UTC (Tue)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/912351/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That diff shows doxygen keeping UTF-8 characters together. The question is why do you need to know that a character is alphabetic but only in ASCII. In your example, the lex is "int" identifier "=" integer ";". It's not looking for ASCII letters; it's looking for 'i', 'n', 't', or the identifier in Unicode.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912351/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 16:10 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912352/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It's not looking for ASCII letters; it's looking for 'i', 'n', 't', or the identifier in Unicode.</font>

<p>Only identifier is not “Unicode”. It's <code>alpha</code> <b>or</b> Unicode then <code>alnum</code> <b>or</b> Unicode (where Unicode is defined as “anything with a high bit set”).</p>

<p>Doxygen does that with lex, but in simpler cases you may do the same with <code>ctype.h</code>.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/912352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 23:41 UTC (Tue)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/912385/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, not if that was C or C++ code. I dug up a copy of the C++2003 standard I had laying around, and it specifically defines the set of letters in an identifier, and there's a limited number of usable Unicode characters. I pretty sure that any standard updated this century will have been made with reference to Unicode Standard Annex #31. The JVM (not Java) standard goes the other way and only restricts . ; [ / from being in a name. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 0:36 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912389/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Sure, but standard doesn't say what compiler (or, even worse non-compiler) have to do with broken programs.</p>

<p>And if you ignore what standard says and just go with <code>isalpha/isalnum</code> + Unicode (where Unicode == “high bit is set”) then you would handle all correct programs perfectly. And if someone feeds incorrect one… who cares how would it be handled?</p>

<p>It's not as if we live in a world where everyone cares all that much about following the standard to a <code>T</code>.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/912389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor912402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 7:32 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/912402/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; they do that fine on UTF-8 data without any decoding.</span><br>
<p>
No they won't, at best they will pass through non-ASCII without doing whatever the function is defined to do (e.g. tolower won't actually lowercase your letters), and at worst they will silently corrupt it (if they think it's one of the legacy 8-bit encodings).<br>
<p>
<span class="QuotedText">&gt; You often do not need the fancy Unicode is_digit but only is_ascii_digit for real software because overwhelmingly the "is it a digit?" question is not cultural but purely technical.</span><br>
<p>
There are a subset of edge cases where a string does not contain linguistically useful information, like a phone number or UUID. In those cases, these ASCII-only functions are somewhat useful, but most of them could just as easily be done with regular expressions like [0-9]+. Realistically, you need nontrivial parsing logic anyway, to deal with things like embedded dashes and other formatting vagaries, so you may as well solve both problems with the same tool (which can and should be Unicode-capable, because ASCII is ultimately "just" a subset of UTF-8). In that context, these ASCII-only functions look rather less useful to me.<br>
<p>
The problem is, ASCII-only functions are also an attractive nuisance. They make things a little too comfortable for the programmer who's still living in 1974, the programmer who still thinks that strings are either ASCII or "uh, I dunno, those funny letters that use the high bit, I guess?" Those programmers are the reason that so many Americans "can't" have diacritical marks in their names (on their IDs, their airline tickets, etc.). If you are writing string logic in 2022, and your strings have anything to do with real text that will be read or written by actual humans, then your strings are or should be Unicode. Unicode is the default, not the "fancy" rare exception. If you have strings, and they're not some variety of Unicode, then one of the following is true:<br>
<p>
1. They're encoding something that sort of looks like text, but is not really text, like a phone number.<br>
2. They are raw bytes in some binary format, and not text at all.<br>
3. In practice, they mostly are Unicode, but that's not your problem (e.g. because you're a filesystem and the strings are paths).<br>
4. You hate your non-English-speaking users (and the English-speakers who have diacritical marks anywhere in their string for whatever reason - we shouldn't make assumptions).<br>
5. You inherited a pile of tech debt and it's too late to fix it now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912425"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 12:03 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/912425/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thread you're replying in is about the "isalpha et al class of function" - to my mind that's specifically the predicates, but if you insist on also including tolower and toupper from the same part of the standard library, then that's still fine although more narrowly useful, they perform exactly as anticipated.<br>
<p>
Sure enough Rust provides to_ascii_uppercase and to_ascii_lowercase here too.<br>
<p>
[ Rust also provides to_uppercase and to_lowercase on char, but because this is a tricky problem these are appropriately more complicated ]<br>
<p>
I already mentioned (but you snipped) that this will go wrong if your C library thinks it knows the byte is from some legacy encoding like 8859-1<br>
<p>
<span class="QuotedText">&gt; most of them could just as easily be done with regular expressions like [0-9]+</span><br>
<p>
This sort of completely inappropriate use of technology (resorting to regular expressions to just match ASCII digits) is how we get software that is hundreds of times bigger and slower than necessary.<br>
<p>
<span class="QuotedText">&gt; Realistically, you need nontrivial parsing logic anyway</span><br>
<p>
Again, you seem to have determined that people would be looking at these functions where they're completely inappropriate, but C itself isn't the right choice in the applications you're thinking about.<br>
<p>
<span class="QuotedText">&gt; If you are writing string logic in 2022, and your strings have anything to do with real text that will be read or written by actual humans, then your strings are or should be Unicode.</span><br>
<p>
Certainly, but again, we're not asking about Javascript or C# or even Rust, we're talking about C and most specifically about the Linux kernel. Whether the people implementing a driver for a bluetooth device are "actual humans" is I guess up for question, but they're focused very tightly on low level technical details where the fact that the Han writing system has numbers is *irrelevant* to the question of whether this byte is "a digit" in the sense they mean.<br>
<p>
C only provides these 1970s functions, and so you're correct that you should not try to write user-facing software in C in 2022. But, the 1970s style ASCII-only functions are actually useful, like it or not, because a bunch of technical infrastructure we rely on works this way, even if maybe it wouldn't if you designed it today (or maybe it would, hard to say)<br>
<p>
Example: DNS name labels are (a subset of) ASCII. to_ascii_lowercase or to_ascii_uppercase is exactly appropriate for comparing such labels, and you might say "Surely we should just agree on the case on the wire" but actually we must not do that, at least not before all DNS traffic is DoH because it turns out our security mitigation for some issues relies on random bits in DNS queries, and there aren't really enough so we actually put more randomness in the case bits of the letters in the DNS name, so your code needs to work properly with DNS queries that have the case bits set or unset seemingly at random, so as to prevent attackers guessing the exact name sent...<br>
<p>
The end user doesn't see any of this, you aren't expected to type randomly cased hostnames in URLs, nor to apply Punycode rules, you can type in a (Unicode) hostname, and your browser or other software just makes everything work. But the code to do that may be written in C (or perhaps these days Rust) and its DNS name matching only cares about ASCII, even though the actual names are Unicode.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912425/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor912253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 9:14 UTC (Tue)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/912253/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;if you accidentally have a character with the high bit set (because you're using ISO-8859-1 or Windows-1252 or some other 8-bit ASCII superset instead of* UTF-8), then it will sign extend and you will get nonsense.</span><br>
<p>
int lowertbl[] = {-1, 0, 1, ..., 0x40, 0x61, 0x62, ...};<br>
#define tolower(c) ((lowertbl+1)[c])<br>
<p>
Sign extension need not produce nonsense. Thanks to the equivalency of the expressions lowertbl+1[c] &lt;=&gt; lowertbl+1+c &lt;=&gt; lowertbl+c+1 &lt;=&gt; lowertbl[c+1], what matters is if the pointer still points to something sensible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 7:35 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/912405/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The standard requires that all functions implemented as macros must also be implemented as functions, so that you can take their addresses. If implemented as a function, the type must be declared as int, and then c gets coerced to a negative number by sign extension before you even get to the indexing expression. You would have to pad out the table with an extra 128 entries, not an extra 1 entry.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor912203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 19:41 UTC (Mon)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/912203/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      That signed / unsigned <code>char</code> difference is a potent source of subtle bugs.<br>
<br>
For example the following code:
<pre>
char c = 0xff;
printf ("%x\n", c - 1);
</pre>
will print <code>fffffffe</code> if <code>char</code> is signed but just (intuitively expected) <code>fe</code> if it is unsigned.







      
          <div class="CommentReplyButton">
            <form action="/Articles/912203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 21:29 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/912213/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;will print fffffffe if char is signed but just (intuitively expected) fe if it is unsigned. </span><br>
<p>
Well, char in case of signed is consistent with short (always signed).<br>
<p>
short c = 0xffff;<br>
printf ("%x\n", c - 1);<br>
<p>
prints fffffffe.<br>
<p>
Therefore, char = unsigned char actually is inconsistent.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 6:35 UTC (Tue)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/912236/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The difference with char and short is that people primarily expect char to contain a character (it's even in its name, and string literals are arrays of char), but shorts are used for numbers. This is why having char as a signed type is insane. Whoever has heard of a negative letter 'A'? Back in eighties when first learning C, and porting C programs from the usenet to my crummy PC/XT clone, I often tripped up because of this, as my language requires more than A-Z to write. It was a real pain.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 10:36 UTC (Tue)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/912261/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't forget all of this was introduced in the days of 7-bit ASCII[*], so a signed char was fine.  In fact it also allows you to store a negative error code, without wasting precious memory on expanding beyond a single byte.<br>
8-bit ASCII (e.g. ISO-8859-*) was only standardized in the eighties, which is about the same time as PowerPC and ARM saw the day of light, so making char default to unsigned may made sense for them (modulo the compatibility issues).<br>
<p>
[*] EBCDIC is 8-bit, and seems to have an intentional division in characters with and without bit 7 (the "sign" bit) set.<br>
<a href="https://en.wikipedia.org/wiki/EBCDIC#Code_page_layout">https://en.wikipedia.org/wiki/EBCDIC#Code_page_layout</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 13:15 UTC (Tue)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/912266/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
8-bit character sets were not that new, although I agree they mostly post-date C. The Commodore micros since the 1970's used "PETSCII" with graphics characters in the upper half, and the IBM PC has since 1981 had its own character set with ASCII in the lower half, and a mixture of graphics and accented letters in upper (selection depending on the region).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 19:58 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912372/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; 8-bit character sets were not that new, although I agree they mostly post-date C.</font>

<p>Note that <a href="https://en.wikipedia.org/wiki/EBCDIC#Code_page_layout">bunch of these</a> was in wide use way before C was a thing.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/912372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor913893"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2022 20:07 UTC (Fri)
                               by <b>fest3er</b> (guest, #60379)
                              [<a href="/Articles/913893/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is why the DEC-10 was nice. Bytes could be defined from 1 to 36 bits in length. Granted, this could result in unused bits in words, but that's the price of flexibility. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/913893/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor912231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 4:56 UTC (Tue)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/912231/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Though in the signed case it might print or do anything else too (in standard C), since assigning an overflowing value to a signed integer is undefined behavior. Unless there is some exception for chars (C is quirky and I don't remember).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 7:06 UTC (Tue)
                               by <b>Villemoes</b> (subscriber, #91911)
                              [<a href="/Articles/912240/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Let's be completely precise here. It is not undefined, it is "implementation-defined or an implementation-defined signal is raised".<br>
<p>
C99, 6.5.16.1 Simple assignment<br>
<p>
(2) In simple assignment (=), the value of the right operand is converted to the type of the<br>
assignment expression and replaces the value stored in the object designated by the left<br>
operand.<br>
<p>
and that "converted to the type of" is covered in<br>
<p>
6.3 Conversions, 6.3.1.3 Signed and unsigned integers:<br>
<p>
(1) When a value with integer type is converted to another integer type other than _Bool, if<br>
the value can be represented by the new type, it is unchanged.<br>
(2) Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or<br>
subtracting one more than the maximum value that can be represented in the new type<br>
until the value is in the range of the new type.<br>
(3) Otherwise, the new type is signed and the value cannot be represented in it; either the<br>
result is implementation-defined or an implementation-defined signal is raised.<br>
<p>
And in practice, any relevant compiler (at least when we're talking the linux kernel, but I'd be surprised if any non-academic compiler did otherwise) does as gcc:<br>
<p>
   * 'The result of, or the signal raised by, converting an integer to a<br>
     signed integer type when the value cannot be represented in an<br>
     object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).'<br>
<p>
     For conversion to a type of width N, the value is reduced modulo<br>
     2^N to be within range of the type; no signal is raised.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 9:31 UTC (Tue)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/912255/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, indeed; I forgot that there's a difference between conversions (which is implementation-defined) and general signed overflow, which is undefined. Thanks for pointing that out :)<br>
<p>
I don't think it's only a matter of being "completely precise"; relying on implementation-defined behavior can be reasonable choice, relying on undefined behavior that a compiler vendor has not explicitly declare they define, to me, usually cannot. (I know Linus would disagree with me :D)<br>
<p>
Allowing an implementation-defined signal seems a bit horrible here, though, but I think I understand where the committee was coming from...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor912246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 7:39 UTC (Tue)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/912246/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In this case, there is no overflow. Subtracting 1 from 0xff is non-overflowing regardless of whether the type is signed or unsigned. If it is signed, the result is -2 (0xfe) And in both cases, the result is well within the bounds of an int. The difference is whether it gets sign-extended (signed char) or not (unsigned char).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 9:59 UTC (Tue)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/912258/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True. I was thinking that the assigning 255 to a signed char part would be UB (like signed integer overflow), but as was pointed above, conversion when the number does not fit is merely implementation-defined.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor912204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 20:08 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/912204/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another advantage of making "char" always unsigned: it better matches Rust. In Rust, a string constant can be viewed as an &amp;[u8] (actually &amp;str, but str is nothing more than an [u8] which is guaranteed to contain valid UTF-8), so it can be argued that Rust's equivalent to a bare "char" would be u8, which is unsigned.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 21:14 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/912207/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
More to the point, it better matches reality. A byte is 8 bits, not a number. You can use it to store numbers, but in practice it will be a component of a short or int (or a UTF-8 code point sequence, which sometimes might happen to only be one byte long), not a number in its own right. I don't visualize bytes as getting magically sign-extended when I do bitwise operations on them, and I pretty much never use char for math or counting things. I suppose there might be some situations where you really are extremely sure that you'll never need to count higher than 127 or lower than -128, but it's difficult to imagine a specific example (that does not involve the phrase "for historical reasons").<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 22:13 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/912219/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's fairly common to use these types to save memory. Just to take a random example from work: A counting Bloom filter will almost never need to count higher than 255, so why waste four times the memory (and cache space)?<br>
<p>
I do wish C had made a separate “byte” type, though, for aliasing reasons. char has too many tasks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 23:26 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/912220/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
1. short is very often good enough for use cases like that. Not always, but often.<br>
2. If you must use char, unsigned will work perfectly well (does your Bloom Filter have a negative count?!), so this isn't actually a use case for signed char.<br>
3. If you need a sentinel value, you can use 255; there is no magical rule that says sentinel values have to be negative.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor912244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 7:30 UTC (Tue)
                               by <b>gspr</b> (guest, #91542)
                              [<a href="/Articles/912244/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Re the aliasing of char: wouldn't uint8_t be a nicely named type for your use?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 7:34 UTC (Tue)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/912245/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would, except it maps onto unsigned char, which can alias on anything as it stands. And it's about fifty years too late to change that :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 19:18 UTC (Tue)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/912365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
uint8_t isn't required to be typedef'd to unsigned char. An implementation could choose to treat it differently from unsigned char, precisely to avoid the aliasing behavior of char. It seems that in the case of GCC, it may have been C++ partly to blame for the current state of affairs: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66110#c13">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66110#c13</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor912233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 5:09 UTC (Tue)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/912233/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I really wonder (but am too lazy to Google now) what even is the history of signed chars. It seemed like a weird thing to me anyway. Was it some kind of wish to have a type that represents "all the characters we care about" and -1 for EOF, in times before the relevant routines were int?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912354"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 16:15 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912354/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I suspect it was just added when the C Standard committee realized that on some platforms simple <code>char</code> is unsigned. They needed single-byte signed type thus <code>signed char</code> was born.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/912354/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor912587"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2022 2:09 UTC (Thu)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/912587/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem being solved is moving a byte in memory to a word-sized register. If you want to do that load in one processor instruction then you have to accept the processor's choice of sign extension or otherwise as that byte is expanded into the register.<br>
<p>
If the language insists on "char" being "unsigned char" then some processors will need to follow the register load with an AND instruction to clear the sign extension. If loading that register also sets register flags (eg, Negative) then you'll need to clear those register flags too.  You could, of course, perhaps avoid this with careful compiler optimisations, but that's asking too much of the compilers of the era.<br>
<p>
Well before the ANSI standards committee started work, the convention in C was to let these differences in processor implementations shine through, with an obligation on people writing code intended to be 'portable' between differing processors to deal with the results. Considering that C was a systems programming language, this wasn't an unreasonable choice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912587/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912604"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2022 6:01 UTC (Thu)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/912604/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, right, makes total sense. Thank you!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912604/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor912608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2022 7:18 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/912608/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://trofi.github.io/posts/203-signed-char-or-unsigned-char.html">https://trofi.github.io/posts/203-signed-char-or-unsigned...</a> has some investigation on this issue. Turns out there are quite a few architectures that only provide zero extending byte loads but the ABI has chosen char's to be signed, thus requiring an extra instruction to patch it up.<br>
<p>
(That blog post is a few years old and doesn't include results for RISC-V, but I understand that RISC-V is like ARM, in that it provides both zero extending and sign extending byte loads but the ABI has chosen char's to be unsigned)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor912209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 21:19 UTC (Mon)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/912209/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not sure why that would matter?<br>
<p>
When passing strings between C and Rust, the pointers can/must be cast to the correct type anyway. And when working in Rust-land, the Rust compiler handles strings per its own rules, and in C-land the C compiler handles chars per its rules.<br>
<p>
(Adding to the potential confusion, Rust also has a 'char' type, which is a 4-byte value capable of storing a single UTF-32 codepoint, presumably under the covers it's considered unsigned. But indeed a string (str/String) is an u8 array containing UTF-8.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 3:30 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/912228/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Rust also has a 'char' type, which is a 4-byte value capable of storing a single UTF-32 codepoint, presumably under the covers it's considered unsigned.</span><br>
<p>
Rust defines char as a Unicode scalar value, Unicode only has one set of codepoints, and some of them aren't valid scalar values because they were used to make UTF-16 work, but UTF-32 maps all that ones which are scalar values to single code *units* and the rest are invalid.<br>
<p>
Thus  char::from_u32(0xDE01).unwrap(); will  panic because this claims 0xDE01 is a Unicode scalar value, but it isn't because code point U+DE01 is a surrogate used for UTF-16 and has no meaning on its own.<br>
<p>
char is not "considered" to be signed or unsigned. You can't do arithmetic on Rust types unless they implement the (Traits signifying) arithmetic operators, which char does not, so in Rust neither 'A' + 'B' nor false + true  (bools only implement some logical and bitwise boolean operators, not general arithmetic) work.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor912212"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2022 21:31 UTC (Mon)
                               by <b>lisch</b> (subscriber, #36574)
                              [<a href="/Articles/912212/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Thus, x86 developers can get into the habit of thinking of char as always being signed and, as a result, write code that will misbehave on some other systems.
</blockquote>

In my experience, x86 developers are more likely to unwittingly think of <code>char</code> as <code>unsigned</code>. For example,
<pre>
char c = '\xfc';
int array[256] = { ... };
do_something(array[c]);   // BOOM!
</pre>




      
          <div class="CommentReplyButton">
            <form action="/Articles/912212/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 6:42 UTC (Tue)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/912237/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
<i>In my experience, x86 developers are more likely to unwittingly think of char as unsigned.</i>
</blockquote>
<p>
Maybe because some early C compilers for the PC worked this way. Like Lattice C. The original 16-bit 8086 did not have the sign-extending 8-bit load as a single instruction, so it was more efficient to treat char as unsigned.



      
          <div class="CommentReplyButton">
            <form action="/Articles/912237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 9:51 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/912257/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect most x86 developers have never heard of Lattice C. :)<br>
<p>
<span class="QuotedText">&gt; The original 16-bit 8086 did not have the sign-extending 8-bit load as a single instruction, so it was more efficient to treat char as unsigned. </span><br>
<p>
"mov al, [x] + cbw" (sign extending) is even one byte shorter than "xor ax, ax + mov al, [x]", so there is no particular x86-specific reason to pick unsigned over signed. Unsigned chars are simply more intuitive; signed-by-default chars are a relic of K&amp;R C not having the signed keyword at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912356"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 16:20 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912356/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I suspect most x86 developers have never heard of Lattice C. :)</font>

<p>They may not have heard about it, but they definitely know its properties. Lattice C is <a href="https://winworldpc.com/product/microsoft-c-c/1x">maiden name of Microsoft C</a> and I doubt x86 developers who have never heard about Microsoft C exist.</p>

<p>P.S. Yes, Microsoft C 3.0 is independent rewrite but it had to be compatible with Microsoft C 1.x and 2.x and thus it had to be compatible with Lattice C, too.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/912356/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 14:29 UTC (Wed)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/912510/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I recall Microsoft C switched to signed characters in that rewrite, probably to be compatible with most Unix compilers. Xenix used Microsoft C as its system compiler, so compatibility helped porting. That is when I found out about the indeterminate behaviour of char in real life.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor912357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 16:34 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912357/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><code>cbw</code> only works with accumulator, though. If you want speed and use register variables (means you use <code>di</code> and <code>si</code>) then you cannot use it.</p>

<p>Whether that was actual reason for the use of unsigned <code>char</code> or not we would never know, of course.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/912357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 8:18 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/912410/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Compilers at the time weren't super smart on register allocation (also because only AX and BX were both 8-bit accessible and not given special duties by the ISA; there simply wasn't a lot of freedom). Loading from memory into the accumulator was by far the common case. Even though a simple char+char addition would have had to use "XCHG BX,AX" or something like that in order to sign extend both operands, CBW+XCHG would be the same length as clearing BH.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor912259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 10:16 UTC (Tue)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/912259/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
XLATB treats AL as unsigned, too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor912230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 4:16 UTC (Tue)
                               by <b>scientes</b> (guest, #83068)
                              [<a href="/Articles/912230/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; On Arm systems, though, char variables are unsigned (unless explicitly declared signed) instead. </span><br>
<p>
I want to point out that the LDRB and LDRBT instructions also zero-extend byte loads, so this unsignedness is part of the ABI.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912525"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 15:42 UTC (Wed)
                               by <b>jrtc27</b> (subscriber, #107748)
                              [<a href="/Articles/912525/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LDRx for B/H(/W on AArch64) zero-extends in general, yet short and int are still signed. Plus if you put an S after the R you get the sign-extending version of the instruction (which even exists for the LDRxT (AArch32) / LDTRx (AArch64) unprivileged loads). Thus nothing about the ABI is forced, or even made more efficient if a particular choice is made, by the instruction set here, just whether the mnemonics have an S in them or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912525/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor912264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 12:54 UTC (Tue)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/912264/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Mostly OT... I first learned assembler on the Motorola 6809.  It had two sets of conditional branch instructions: One set interpreted the comparisons as signed, and the other as unsigned.  It's been decades since I did any Intel assembler, but I assume the same thing holds?  Are there any real architectural reasons to prefer signed over unsigned or vice-versa?

<p>The 6809 had an instruction called <tt>SEX</tt>.  It sign-extended accumulator B into double-accumulator D.  It also had a <tt>BRA</tt> instruction, which was an unconditional branch.  Someone tended sophomoric when naming the instructions. :)



      
          <div class="CommentReplyButton">
            <form action="/Articles/912264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 14:00 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/912268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I assume the same thing holds?</span><br>
<p>
Yes, JL/JG/JLE/JGE are for signed comparisons while JB/JA/JBE/JAE are for unsigned comparisons.<br>
<p>
Other architectures use LT/GT/LE/GE for signed and LTU/GTU/LEU/GEU for unsigned.<br>
<p>
POWER is special in that it has separate "compare signed" and "compare unsigned" instructions, and the branches are just less than/equal/greater than.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor912369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 19:27 UTC (Tue)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/912369/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not use uint8_t and int8_t when dealing with numeric values or octets, and keep char just for characters and strings?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 20:03 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/912373/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Because C it not made that way. <code>uint8_t</code> and <code>int8_t</code> are not types, they are type aliases.</p>

<p>You still end up dealing with that <code>char</code>/<code>signed char</code>/<code>unsigned char</code> whether you like it or not.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/912373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor912361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2022 19:31 UTC (Tue)
                               by <b>daniel.glasser</b> (guest, #97146)
                              [<a href="/Articles/912361/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sometimes code uses a byte as a very short signed integer in one instance, an unsigned integer in another instance, and as a character where sign did not matter in other instances. I do a lot of coding for embedded (and otherwise resource limited) targets, so this comes up a lot; using compact data structures, and on some targets eliminating generation of sign extension instructions can make the difference between an application that fits on the target and code that doesn't fit, and also affects the runtime efficiency of said code. (Anyone who's written firmware for microcontrollers in C can probably back me up on this.)<br>
<p>
Back in the 1980s, I gave up explicitly using "char" for anything other than strings and/or API compatibility, and instead moved to a precursor of the types defined by the header file &lt;stdint.h&gt;, which are now "uint8_t" for unsigned and "int8_t" for signed (I think that the non-standard version was just "uint8" and "int8", respectively, but I'm not sure anymore). Not all compiler toolchains included a header file with consistent names, so I had my own. Using this convention, my code was portable between PDP-11, VAX-11, M68000, Intel8086, and Zilog Z8000, all of which I was using at the time, and eventually PPC, DEC Alpha, ARM, and other architectures with a number of different compilers with, at most, a change in a #define for whether "char" was signed or unsigned if the compiler didn't provide a pre-defined macro for that.<br>
<p>
When ISO/IEC 9899:1999 (C99) added "&lt;stdint.h&gt;", I switched to using the standard typedef names for new code and my projects included a "include/compat" directory with versions of "stdint.h" and "stdbool.h" (and a few other "standard" header files introduced by C99) to be used for pre-C99 conforming compilers.<br>
<p>
Adopting this sort of thing in the kernel at this stage would likely be a herculean task, but for any new software project in C it is trivial to standardize on using typedefs with explicit properties (signed/unsigned, width) where the built-in C types may vary between targets.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 8:27 UTC (Wed)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/912412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Adopting this sort of thing in the kernel at this stage would likely be a herculean task, but for any new software project in C it is trivial to standardize on using typedefs with explicit properties (signed/unsigned, width) where the built-in C types may vary between targets.</span><br>
<p>
Fortunately that herculean task has already been completed, using {,__}[us]{8,16,32,64}.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor912399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 6:04 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/912399/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was fortunate to get hit by this a few decades ago, when seeing that my old dirty code doing this:<br>
<p>
    char c;<br>
<p>
    while ((c = getchar()) != EOF) {<br>
       /* do something */<br>
    }<br>
<p>
would turn to an infinite loop on PPC, because chars were unsigned there and would never match EOF(-1). Since then I've been insisting on building and running my code on various architectures, among which Arm, in part for unsigned chars.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 8:29 UTC (Wed)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/912413/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BTW, getchar() returns int, not (signed) char, so assigning to char causes truncation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912433"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2022 13:15 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/912433/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes exactly! But when you're young you don't notice ;-)  It's just that 0xFF also ends up the stream. Nowadays it's still possible to seldom spot programs which stop parsing input after 0xFF, and when I see that it just reminds me that they made the same mistake I made, believing that getchar() would return ... a char!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912433/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2022 15:10 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/912714/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Nowadays it's still possible to seldom spot programs which stop parsing input after 0xFF</span><br>
<p>
As luck would have it, 0xFF never appears in any valid UTF-8 stream (even in the original definition of UTF-8 which allowed for longer sequences), so the strong push to use UTF-8 everywhere lessens the impact of these bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor912753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2022 17:45 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/912753/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No it makes them harder to test in fact. FWIW it was sound processing so any char is valid. And when you do that with unsigned values, you only face the problem when reaching saturation ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor912693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2022 13:59 UTC (Thu)
                               by <b>kpfleming</b> (subscriber, #23250)
                              [<a href="/Articles/912693/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <pre>
const unsigned char *c = u"Subscribe to LWN";
</pre>

Would be fine, if it was an option :-)


      
          <div class="CommentReplyButton">
            <form action="/Articles/912693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor913639"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would you like signs with those chars?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2022 14:49 UTC (Thu)
                               by <b>welinder</b> (guest, #4699)
                              [<a href="/Articles/913639/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; As a general rule, C integer types are signed unless specified otherwise;</span><br>
<p>
True.<br>
<p>
<span class="QuotedText">&gt; short, int, long all work that way.</span><br>
<p>
Ah, no.  They mostly work that way.<br>
<p>
"int" has unspecified signedness in the following code:<br>
<p>
struct X {<br>
  int m : 8;<br>
};<br>
<p>
Luckily bitfields are rare enough that you can just always insist on specifying "unsigned int" or "signed int"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/913639/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
