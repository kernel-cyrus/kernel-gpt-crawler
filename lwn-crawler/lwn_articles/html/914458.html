        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rust in the 6.2 kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/914458/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/915255/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/914458/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rust in the 6.2 kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 17, 2022</br>
           </div>
The merge window for the 6.1 release brought in <a
href="/Articles/910762/">basic support</a> for writing kernel code in Rust
— with an emphasis on "basic".  It is possible to create a "hello world"
module for 6.1, but not much can be done beyond that.  There is, however, a
lot more Rust code for the kernel out there; it's just waiting for its turn to be
reviewed and merged into the mainline.  Miguel Ojeda has now posted <a
href="/ml/linux-kernel/20221110164152.26136-1-ojeda@kernel.org/">the next
round</a> of Rust patches, adding to the support infrastructure in the
kernel.
<p>
This 28-part patch series is focused on low-level support code, still
without much in the way of abstractions for dealing with the rest of the
kernel.  There will be no shiny new drivers built on this base alone.  But
it does show another step toward the creation of a workable environment for
the development of code in the Linux kernel.
<p>
As an example of how stripped-down the initial Rust support is, consider
that the kernel has <a
href="https://docs.kernel.org/next/core-api/printk-basics.html">eight
different logging levels</a>, from "debug" through "emergency".  There is a
macro defined for each level to make printing simple; screaming about an
imminent crash can be done with <tt>pr_emerg()</tt>, for example.  The Rust
code in 6.1 defines equivalent macros, but only two of them:
<a
href="https://elixir.bootlin.com/linux/v6.1-rc5/source/rust/kernel/print.rs#L151"><tt>pr_info!()</tt>
and <tt>pr_emerg!()</tt></a>; the macros for the other log 
levels were left out.  The first order of business
for 6.2 appears to be to fill in the rest of the set, from
<tt>pr_debug!()</tt> at one end through <tt>pr_alert!()</tt> at the other.
There is also <tt>pr_cont!()</tt> for messages that are pieced together
from multiple calls.
<a href="/ml/linux-kernel/20221110164152.26136-5-ojeda@kernel.org/">This
sample kernel module</a> shows all of the print macros in action.
<p>
A rather more complex macro added in this series is <tt>#[vtable]</tt>.
The kernel makes extensive use of structures full of pointers to functions;
these structures are at the core of the kernel's object model.  A classic
example is <a
href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L2093"><tt>struct
file_operations</tt></a>, which is used to provide implementations of the
many things that can be done with an open file.  The functions found
therein vary from relatively obvious operations like <tt>read()</tt> and
<tt>write()</tt> through to more esoteric functionality like
<tt>setlease()</tt> or <tt>remap_file_range()</tt>.  Anything in the kernel
that can be represented as an open file provides one of these structures to
implement the operations on that file.
<p>
Operations structures like <tt>file_operations</tt> thus look a lot like
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Rust
traits</a>, and they can 
indeed be modeled as traits in Rust code.  But the kernel allows any given
implementation to leave out any functions that are not relevant; a
<tt>remap_file_range()</tt> operation will make no sense in most device
drivers, for example.  In the kernel's C code, missing operations are
represented by a null pointer; code that calls those operations will detect
the null pointer and execute a default action instead.  Null pointers,
though, are the sort of thing that the Rust world goes out of its way to
avoid, so representing an operations structure in Rust requires some extra
work. 
<p>
The <tt>#[vtable]</tt> macro is intended to perform the necessary impedance
matching between C operations structures and Rust traits.  Both the
declaration of a trait and of any implementations will use this macro, so a
trait definition will look like:
<p>
<pre>
    #[vtable]
    pub trait Operations {
        /// Corresponds to the `open` function pointer in `struct file_operations`.
    	fn open(context: &amp;Self::OpenData, file: &amp;File) -&gt; Result&lt;Self::Data&gt;;
    // ...
    }
</pre>
<p>
While an implementation for a specific device looks like:
<p>
<pre>
    #[vtable]
    impl kernel::file::Operations for some_driver {
        fn open(_data: &amp;(), _file: &amp;File) -&gt; Result {
            Ok(())
        }
	// ...
    }
</pre>
<p>
If this implementation is to be passed into the rest of the kernel, it must
be turned into the proper C structure.  Rust can create the structure, but
it is hard-put to detect which operations have been implemented and which
should, instead, be represented by a null pointer.  The <tt>#[vtable]</tt>
macro helps by generating a special constant member for each defined
function; in the above example, the <tt>some_driver</tt> type would have a
constant <tt>HAS_OPEN</tt> member set to <tt>true</tt>.  The code that
generates the C operations structure can query those constants (at compile
time) and insert null pointers for missing operations; the details of how
that works can be seen in <a
href="/ml/linux-kernel/20221110164152.26136-7-ojeda@kernel.org/">this
patch</a>.
<p>
The submission for 6.2 adds <tt>#[vtable]</tt> but does not include any
uses of it.  The curious can see it in use by looking at <a
href="/ml/linux-kernel/20220802015052.10452-18-ojeda@kernel.org/">this
large patch</a> posted in August; searching for <tt>#[vtable]</tt> and
<tt>HAS_</tt> will turn up the places where this infrastructure is used.
<p>
Yet another new macro is <tt>declare_err!()</tt>, which can be used to
declare the various error-code constants like <tt>EPERM</tt>.  The 6.2
kernel will likely include <a
href="/ml/linux-kernel/20221110164152.26136-10-ojeda@kernel.org/">a full
set of error codes</a> declared with this macro rather than the minimal set
included in&nbsp;6.1.  There is also <a
href="/ml/linux-kernel/20221110164152.26136-11-ojeda@kernel.org/">a
mechanism</a> to translate many internal Rust error into Linux error codes.
<p>
The Rust <a
href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><tt>Vec</tt>
type</a> implements an array that will grow as needed to
hold whatever is put into it.  Growing, of course, involves memory
allocation, which can fail in the kernel.  In 6.2, <tt>Vec</tt> as
implemented in the kernel will likely have two methods called
<tt>try_with_capacity()</tt> and <tt>try_with_capacity_in()</tt>.  They act
like the standard <a
href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity"><tt>with_capacity()</tt></a>
and <a
href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity_in"><tt>with_capacity_in()</tt></a> 
<tt>Vec</tt> methods in that they preallocate memory for data to be stored
later, but with the difference that they can return a failure 
code.  The <tt>try_</tt> variants will allow kernel code to attempt to
allocate <tt>Vec</tt>s of
the needed size and do the right thing if the allocation fails, rather than
just calling <tt>panic()</tt> like the standard versions do.
<p>
One of the more confusing aspects of Rust for a neophyte like your editor
is the existence of two string types: <a
href="https://doc.rust-lang.org/std/primitive.str.html"><tt>str</tt></a>
and <a
href="https://doc.rust-lang.org/std/string/struct.String.html"><tt>String</tt></a>;
the
former represents a borrowed reference to a string stored elsewhere, while
the latter actually owns the string.  The kernel's Rust support will define
two variants of those, called <a
href="/ml/linux-kernel/20221110164152.26136-17-ojeda@kernel.org/"><tt>CStr</tt></a>
and <a
href="/ml/linux-kernel/20221110164152.26136-22-ojeda@kernel.org/"><tt>CString</tt></a>,
which 
serve the same function for C strings.  Specifically, they deal with a
string that is represented as an array of bytes and terminated with a
<tt>NUL</tt> character.  Rust code that passes strings into the rest of the
kernel will need to use these types.
<p>
The series ends with a grab-bag of components that will be useful for
future additions.  The <a
href="/ml/linux-kernel/20221110164152.26136-24-ojeda@kernel.org/"><tt>dbg!()</tt>
macro</a> makes certain types of debugging easier.  There is <a
href="/ml/linux-kernel/20221110164152.26136-25-ojeda@kernel.org/">code for
compile-time assertions</a> and to <a
href="/ml/linux-kernel/20221110164152.26136-26-ojeda@kernel.org/">force
build errors</a>.  The <a
href="/ml/linux-kernel/20221110164152.26136-28-ojeda@kernel.org/"><tt>Either</tt>
type</a> can hold an object that can be either one of two distinct types.
Finally, the <a
href="/ml/linux-kernel/20221110164152.26136-29-ojeda@kernel.org/"><tt>Opaque</tt>
type</a> is for structures used by the kernel that are never accessed by
Rust code.  Using this type can improve performance by removing the need to
zero-initialize the memory holding it before calling the initialization
function.
<p>
As can be seen, these patches are slowly building the in-kernel Rust code
up so that real functionality can be implemented in Rust, but this process
has some ground to cover yet.  It's not clear whether more Rust code will
be proposed for 6.2, or whether this is the full set.  The pace of change
may seem slow to developers who would like to start doing real work in
Rust, but it does have the advantage of moving in steps that can be
understood — and reviewed — by the kernel community.  The Rust-for-Linux
work has been underway for a few years already; getting up to full
functionality may well take a while longer yet.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/914458/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor915285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 16:46 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/915285/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; One of the more confusing aspects of Rust for a neophyte like your editor is the existence of two string types: str and String; the former represents a borrowed reference to a string stored elsewhere, while the latter actually owns the string.</span><br>
<p>
On an interesting historical note, I recall there were a number of people who wanted to use Box&lt;&amp;str&gt; as an owned string type instead, which would have been both easier to understand and more efficient given that the vast majority of strings are write-once anyway, making the capacity field unnecessary. The current growable string type would still have be kept under it's old StrBuf name. However as I understand this wasn't really possible in the language back then, so a new type was the direction they had to go, somewhat unfortunately I think.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 16:49 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/915287/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, Box&lt;str&gt; of course, not Box&lt;&amp;str&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 17:03 UTC (Thu)
                               by <b>rillian</b> (subscriber, #11344)
                              [<a href="/Articles/915292/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      FWIW re our editor's difficulty, the C++17 standard library has a similar construction with <code>std::string_view</code> vs. <code>std::string</code>. Rust "simplifies" things a bit by making the string_view the same thing as a <code>const std::string&amp;</code> and keeping track of the relative lifetimes of the two. In C it's all the same thing, of course.


      
          <div class="CommentReplyButton">
            <form action="/Articles/915292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 13:15 UTC (Fri)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/915344/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In C it's all the same thing, of course. </span><br>
<p>
Not quite; without a capacity value from a standard NUL terminated string, one can't do some useful patterns like having a single allocated "buffer" used in a loop without allocating/freeing.  The equivalent of Rust's String is really things like https://developer-old.gnome.org/glib/stable/glib-Strings.html<br>
(I'd assume there's some variant of this in the linux kernel?  But not seeing it offhand)<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor915294"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 17:32 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/915294/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <p>The difference between <code>&amp;str</code>, <code>String</code> and <code>Box&lt;str&gt;</code> (which <b>also</b>) shows why Rust is a step forward while C++… not so much.</p>

<p>In C, of course, both “owned” and “borrowed” strings are represented as <code>char *</code>. C++ offers <code>std::string</code> and <code>std::string_view</code>, but… it's still responsibility of the developer to keep track of <code>std::string_view</code>'s validity!</p>

<p>This makes C++ complication over C somewhat… unsatisfying: yes, we encoded difference in intents, but it's still our responsibility to keep track of everything… why do we need that complication?</p>

<p>But <code>&amp;str</code> comes with additional assurances from the compiler: it's borrowed string, but it's compiler job to ensure that it's correctly borrowed! And <code>String</code> and <code>Box&lt;str&gt;</code> are owned, but it's compiler job to ensure they are correctly owned (initialized before use, etc).</p>

<p>That's why people say that <a href="https://people.kernel.org/linusw/rust-in-perspective">Rust is attempting to raise the abstraction in the programming language</a>: you genuinely can offload some of your knowledge into the machine and hope that it would verify that everything is done correctly.</p>

<p>It's similar to <a href="https://en.wikipedia.org/wiki/Sparse">Sparse</a> in some sense.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/915294/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915338"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 5:25 UTC (Fri)
                               by <b>ma4ris5</b> (guest, #151140)
                              [<a href="/Articles/915338/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is some information, that Rust language is near Calculus of Constructions,<br>
which is a bit different than Lambda Calculus.<br>
<p>
With Calculus of Constructions, it is possible to implement logical proofs.<br>
This would imply, that Rust implementation needs to be within the logical proofs,<br>
for being robust.<br>
<p>
<a href="https://www.subarctic.org/is_rust_a_purely_functional_programming_language.html">https://www.subarctic.org/is_rust_a_purely_functional_pro...</a><br>
<a href="https://hbr.github.io/Lambda-Calculus/cc-tex/cc.pdf">https://hbr.github.io/Lambda-Calculus/cc-tex/cc.pdf</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915338/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 8:56 UTC (Sat)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/915459/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I know about the Calculus of Construction, and I can tell you that this is mostly wrong. There is no obvious relation between Rust and the Calculus of Construction (which is about dependent types, no linear types), and the subarctic blog you cite is wrong. This also has no relevance to the Linux kernel or string types whatsoever.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 15:58 UTC (Sat)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/915476/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your #rude filter seem to be off.<br>
The poster was making a good point (as does the linked page) that the dependent typing usage possible using Rust traits can be used to construct purely (or semi-purely) funcional Rust programs, that can be checked via automation. The correlation to the kernel is that the same tooling possible with Rust is not possible with C++ or C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 21:46 UTC (Sat)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/915501/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Your #rude filter seem to be off.</span><br>
<p>
Maybe? I find it rather perplexing to see important technical ideas of our field being cargo-culted around. Why would someone name-drop the Calculus of Constructions (a rather technical topic that is mostly of experts interest) if they clearly don't know what it is? (Otherwise they couldn't claim that Rust is closely related, which is grossly wrong.) It may be that some language communities or discussion spaces are used to this kind of pseudo-technical discourse, but I'm not, <br>
and it hurts.<br>
<p>
(I have tried to be short and factual in my post above, which I certainly did not intend to be insulting or deprecating.)<br>
<p>
<p>
The message I was replying can be decomposed as follows:<br>
<p>
<span class="QuotedText">&gt; There is some information, that Rust language is near Calculus of Constructions,</span><br>
<p>
This information is wrong, the Rust language is nowhere near the Calculus of Constructions. Rust has a strong type system with polymorphism, sure, but that's about it (so do many other languages). The characteristic feature of the Calculus of Constructions is its very powerful pi-types / dependent abstractions, which are completely absent from Rust -- or most programming languages.<br>
<p>
<span class="QuotedText">&gt; With Calculus of Constructions, it is possible to implement logical proofs.</span><br>
<p>
This is true.<br>
<p>
<span class="QuotedText">&gt; This would imply, that Rust implementation needs to be within the logical proofs,</span><br>
for being robust.<br>
<p>
I don't know what this is supposed to mean, but my best guess is that there is a fundamental misunderstanding here. Even if the Rust system *could* in theory express logical proofs (Coq or Agda can, for example), it would be entirely possible to write code that contains bugs in the language (at less precise types).<br>
<p>
<p>
The blog post that is being cited in the message ( <a href="https://www.subarctic.org/is_rust_a_purely_functional_programming_language.html">https://www.subarctic.org/is_rust_a_purely_functional_pro...</a> ) is similarly fundamentally wrong. Out of the five subsections, exactly 2 are correct ("What is the Calculus of Constructions" is essentially correct, and "So is Rust purely functional" is arguably correct), the 3 other contain gross mistakes. I mean, this blog post is titled "Is Rust a Purely Functional Programming Language?", and it starts with a definition of "purely functional programming language" that is wrong?! (ML is not a purely functional programming language.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 22:45 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/915502/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I think you are talking past each other.</p>

<font class="QuotedText">&gt; Even if the Rust system *could* in theory express logical proofs (Coq or Agda can, for example), it would be entirely possible to write code that contains bugs in the language (at less precise types).</font>

<p>Rust type system <b>can</b> express logical proofs and it's <b>not</b> possible to circumvent it (except for bugs in the compiler, of course). That's precisely <a href="https://research.ralfj.de/thesis.html">what the Ralf's Phd thesis is about</a>.</p>

<p>Now, the weird part: Rust doesn't contain full-blown dependent types system which can be used pervasively, it's complicated system is centered on lifetimes and soundness.</p>

<p>Which basically means that it's enough to prove that there are no UBs in safe Rust, but not enough to prove much beyond that.</p>

<p>That's still significantly different property from what C/C++ have. And very practically useful.</p>

<p>As for how all that is related to functional programming… it's, basically, impossible to say.</p>

<font class="QuotedText">&gt; it starts with a definition of "purely functional programming language" that is wrong?! (ML is not a purely functional programming language.)</font>

<p>Who said it's “wrong?” Even Wikipedia's <a href="https://en.wikipedia.org/wiki/Purely_functional_programming#Difference_between_pure_and_impure_functional_programming">article on subject</a> start with <i>the exact difference between pure and impure functional programming is a matter of controversy</i> sentence for crying out loud!</p>

<p>The big issue here is that reasonable people define “pureness” differently and then arrive at different conclusions.</p>

<p>Basically the best I can say about that link is… I couldn't say if he's even right or wrong because he talks about things which have not single “proper” definition.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/915502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2022 6:28 UTC (Sun)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/915521/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Rust type system *can* express logical proofs</span><br>
<p>
You are changing what you mean by "express logical proofs" quite a bit from what the original poster said with "implement logical proofs", quote:<br>
<p>
<span class="QuotedText">&gt; With Calculus of Constructions, it is possible to implement logical proofs. This would imply, that Rust implementation needs to be within the logical proofs, for being robust.</span><br>
<p>
With the Calculus of Constructions (or other similar logics), you can define types that correspond to interesting mathematical propositions, and then you can "implement" a proof of this proposition as a program fragment at this type. This is the "Curry-Howard" view of proving things using a typed lambda-calculus, it is what the Calculus of Propositions was designed for, and this is *not* something that is done in Rust.<br>
(Of course, as any reasonably-powerful type system, it is possible through a lot of effort to encode something similar to this process for weaker notions of propositions, using for example singleton types and what not. This does not change the fact that claiming that Rust is related to the Calculus of Constructions is fundamentally nonsensical.)<br>
<p>
Now you are talking about a much weaker (but still important/relevant) meaning of "logical proofs", which is: proof of safety guarantees guaranteed by the type system. The idea is not that you can define types to express mathematical properties of interest, but that each type come with behavioral guarantees that gives a property that each program fragment at this type must verify. (Working out precisely how to define these guarantees is the essence of the RustBelt project and Ralf Jung's thesis.) This has, again, nothing to do with the Calculus of Constructions -- well, this work was formulated in Coq, which is maybe how the crackpots above thought to claim a connection.<br>
<p>
<span class="QuotedText">&gt; and it's not possible to circumvent it (except for bugs in the compiler, of course)</span><br>
<p>
and except for, you know, *unsafe*.<br>
<p>
<span class="QuotedText">&gt; Which basically means that it's enough to prove that there are no UBs in safe Rust, but not enough to prove much beyond that.</span><br>
<p>
To be fair (I'm not trying to be critical here, and your point at least are informed and make sense), you can get more than the absence of UB when you look at programs at higher type. (For example I would expect that polymorphism gives you representation-independence properties that let you reason on whether some values remain "hidden" inside a module, or what API usage patterns are prevented by the types. Some of this stuff is standard in ML/Haskell grade type systems, and there are new Rust-specific tricks that we can play with lifetimes and the static discipline.)<br>
<p>
<span class="QuotedText">&gt; Who said it's “wrong?” Even Wikipedia's article on subject start with the exact difference between pure and impure functional programming is a matter of controversy sentence for crying out loud!</span><br>
<p>
There is disagreement on the finer details (and sometimes the word is used in a completely different  context, "pure lambda calculus" means something else), but there is no disagreement on the fact that ML-family languages are *impure* functional programming languages; they allow for unrestricted non-termination but also mutable state, exceptions... Anyone in the field agrees that ML-family languages are *not* purely functional.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor915410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 16:48 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/915410/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      In fact, <tt>std::string_view</tt> validity does not need to be "kept track of". Passed down a call chain, it remains valid throughout, with no phony "complication".

When you need to lie to make your case, it tells us all we need to know about your case.
Hype reliant on spurious denigration of other languages adds no value here.



      
          <div class="CommentReplyButton">
            <form action="/Articles/915410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 17:05 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/915413/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>It does need to be kept track of - you need to ensure that the underlying string is not deallocated before the string view is deallocated.
<p>For the very specific case of just passing a string view of a string you own down a call stack, there's no issues, but as soon as the string view relates to a string whose lifespan is not determined purely by the enclosing scope (e.g. because you put the string view in a heap-allocated data structure), you have a lifespan tracking issue to worry about.


      
          <div class="CommentReplyButton">
            <form action="/Articles/915413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 18:02 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/915418/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>If someone claims that use of <code>std::string_view</code> doesn't lead to the problems then you can safely say that it's another crop of the “just don't do any mistakes and then C works fine… oh, and don't upgrade the compiler ever because these evil guys make it break it my programs”, just with C++ theme.</p>

<p>Here is <a href="https://github.com/isocpp/CppCoreGuidelines/issues/1038">discussion about dangers of std::string_view</a> on the Core Guidelines site, here is <a href="https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/">article</a> with more arguments and there are more, but they all are, obviously, wrong, because admitting that they are right means years of investment in C++ are in jeopardy.</p>

<p>Just leave these guys alone. It's the same thing as with <code>systemd</code> introduction: there would be lots of complains and there would be holdouts and yet it would happen in the classic <a href="https://en.wikipedia.org/wiki/Planck%27s_principle">planck's principle</a> way:</p>

<font class="QuotedText">&gt; An important scientific innovation rarely makes its way by gradually winning over and converting its opponents: it rarely happens that Saul becomes Paul. What does happen is that its opponents gradually die out, and that the growing generation is familiarized with the ideas from the beginning.</font>


      
          <div class="CommentReplyButton">
            <form action="/Articles/915418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor917708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2022 21:04 UTC (Mon)
                               by <b>oconnor663</b> (guest, #119484)
                              [<a href="/Articles/917708/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You (farnz) probably already know this but I think it's worth adding: Not only deallocated, but also reallocated. Calling .push_back() or .append() on the original string also potentially invalidates a string_view.<br>
<p>
It could be totally fair to describe these as niche issues that don't affect most callers of string_view. But I don't agree with calling someone a "liar" because you (ncm) think it's niche. Or if these issues are new to you, great! None of us is ever done learning.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2022 11:14 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/917751/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Yes - apologies for being unclear. I think of reallocations as an optimized form of allocate, copy and deallocate, so it's implicit to me that reallocation can invalidate the original string.
<p>At heart, this is the same problem as iterator invalidation. You have a reference to some underlying data, and changes to that underlying data can result in your reference no longer being valid. C++ has no compiler checks for reference validity, and relies on the programmer not getting it wrong; this makes some sense, since any check for reference validity is going to be conservative and thus will need overriding from time to time, but the history of "rely on the programmer not getting it wrong" suggests it's not a great decision.


      
          <div class="CommentReplyButton">
            <form action="/Articles/917751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor918011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Illuminating background on Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2022 12:25 UTC (Fri)
                               by <b>sdalley</b> (subscriber, #18550)
                              [<a href="/Articles/918011/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>That's why people say that Rust is <a href="https://people.kernel.org/linusw/rust-in-perspective"> attempting to raise the abstraction</a> in the programming language: you genuinely can offload some of your knowledge into the machine and hope that it would verify that everything is done correctly.</blockquote>
<p>
Thanks khim for that very illuminating link on the functional-programming origins of Rust!
</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/918011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor915304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 19:52 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/915304/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sadly interop with C means &amp;CStr is way less useful than &amp;str.<br>
<p>
&amp;str is a (aside from the UTF-8 promise which holds for all Rust strings including CStr I believe) just a slice, a "fat" pointer, an address (of the string) plus a length. Which means operations to get a substring don't mutate the string, they're just different addresses and lengths, the underlying string is unchanged. That includes strip_prefix, split_once, trim_end_matches, and a good many more.<br>
<p>
Sadly &amp;CStr can't do that, under the hood it too is an address plus a length (a slice), but it promises the last byte is always 0, ASCII NUL for C compatibility, and of course such substring operations wouldn't deliver that, so &amp;CStr can't efficiently do them. [I guess it could do some of the strip_prefix type operations since those leave the far end alone]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 21:22 UTC (Thu)
                               by <b>djc</b> (subscriber, #56880)
                              [<a href="/Articles/915315/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also note that while the article seems to imply that CStr and CString are kernel-specific (and their implementation might well be), normal Rust code also has these types in the std library.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 22:57 UTC (Thu)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/915325/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I suspect it has to do with accessing them through <code>core::ffi::CStr</code> and <code>core::ffi::CString</code> being an experimental/nightly-only feature (<code>core_c_str</code>) and them wanting to get to compatibility with stable compilers as quickly as possible.

<p>It wouldn't surprise me if this contributes to the stabilization of the <code>core_c_str</code> feature.


      
          <div class="CommentReplyButton">
            <form action="/Articles/915325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 23:00 UTC (Thu)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/915326/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Correction: I forgot to update my Dash/Zeal docset. <code>core_c_str</code> got stabilized in 1.64.

<p>It's still possible that they're duplicating it to keep compatibility with earlier revisions of the Rust compiler that distros may be packaging though.



      
          <div class="CommentReplyButton">
            <form action="/Articles/915326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 23:02 UTC (Thu)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/915328/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Correction: ...and "core::ffi::CString"? It's an <i>allocating</i> thing. I clearly need to go to sleep <i>right now</i>.


      
          <div class="CommentReplyButton">
            <form action="/Articles/915328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor915319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 21:45 UTC (Thu)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/915319/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;the UTF-8 promise which holds for all Rust strings including CStr I believe</span><br>
<p>
CStr and CString only seem to promise to be NUL-terminated, I believe any valid char* should make a valid &amp;CStr (which explains why I rememberd &amp;CStr as _not_ cheap to convert to &amp;str)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 3:18 UTC (Fri)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/915334/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually &amp;CStr differs from &amp;str in that it is *not* a slice and doesn't hold a length asking with an address. So while I do prefer the standard &amp;str, &amp;CStr does have the advantage of taking up half as much space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 3:59 UTC (Fri)
                               by <b>ABCD</b> (subscriber, #53650)
                              [<a href="/Articles/915337/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
CStr (both kernel::str::CStr and core::ffi::CStr) are implemented as dynamically-sized types (specifically, a newtype wrapper around [u8]), so a &amp;CStr is a fat pointer containing both the pointer to the data and the length of that data, just like a &amp;str or &amp;[u8].<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 14:21 UTC (Fri)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/915379/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is yes, but AFAIK it's an oversight and could be replaced soon with a thin pointer - this is alluded to here for example: <a href="https://github.com/m-ou-se/rfcs/blob/c-str-literal/text/3348-c-str-literal.md">https://github.com/m-ou-se/rfcs/blob/c-str-literal/text/3...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor915340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 8:58 UTC (Fri)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/915340/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      In the real world, Asahi Linya has been writing a kernel GPU driver for M1 Macs in Rust, and has made remarkable progress in a matter of weeks . Here's a<a href="https://twitter.com/LinaAsahi/status/1577667445719912450">twitter thread</a> from early October. Clearly it uses much more than the minimal Rust framework code that is being upstreamed so far. Perhaps LWN can ask her for a guest post with some details on this? 




      
          <div class="CommentReplyButton">
            <form action="/Articles/915340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915346"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 13:30 UTC (Fri)
                               by <b>Darkstar</b> (guest, #28767)
                              [<a href="/Articles/915346/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I tried watching one of her streams once. Got an immediate headache because of the fake voice she's using :-D If anyone interviews her, please do it in text-only<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915346/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 13:57 UTC (Fri)
                               by <b>lwn@pck.email</b> (guest, #121154)
                              [<a href="/Articles/915348/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a mean thing you're going entirely out of the way to say, particularly given how entirely unrelated it is to the original request for her to _write_ a guest post. <br>
<p>
If you choose to post again here, I personally would appreciate it if you would choose to stay remotely on topic and to be a nicer person :-D. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 15:24 UTC (Fri)
                               by <b>Lumia</b> (subscriber, #161010)
                              [<a href="/Articles/915383/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What an unpleasant thing to say.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915434"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 21:15 UTC (Fri)
                               by <b>beagnach</b> (guest, #32987)
                              [<a href="/Articles/915434/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not actually... the complaint is about a very high-pitched machine-generated fake voice that the developer of the M1 GPU driver adds to their YouTube videos. So not a personal attach. <br>
<p>
I also find it unbearable.<br>
<p>
Example:<br>
<a href="https://www.youtube.com/watch?v=XG9xUxIf73o">https://www.youtube.com/watch?v=XG9xUxIf73o</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915434/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 22:00 UTC (Fri)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/915436/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which is, again, not relevant when discussing _writing_and article. It should ever be here on LWN, which we all consider a civilised place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915438"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 22:00 UTC (Fri)
                               by <b>gspr</b> (guest, #91542)
                              [<a href="/Articles/915438/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Has LWN done a lot of voice interviews? No. The comment clearly brought up something completely irrelevant in order to be mean.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915438/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 22:09 UTC (Fri)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/915439/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unless "you" was being used in the broader sense of "anyone who chooses to interview her", rather than LWN specifically.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915466"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 13:37 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/915466/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or they don't do email interviews and it has to be a video ... if they're a vlogger they might insist ...<br>
<p>
Anyways, I consider it useful information to know that their videos are unwatchable ... there might be better ways to do it (I don't see how in this instance) but just telling the truth is not being nasty. Yes it can be told in a nasty way, but here it was just to inform ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915466/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 15:07 UTC (Sat)
                               by <b>amacater</b> (subscriber, #790)
                              [<a href="/Articles/915471/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is, of course, possible that this content is effectively generated as anime-style content and a synthetic voice to preserve someone's<br>
identity for some reason. There aren't many folk contributing to the kernel or other projects entirely pseudonymously but there are<br>
a few, usually to prevent an obvious conflict of interest - maybe to preserve the ability to work on something as their own rather than as their employers' work - or to prevent themselves being marginalised for some other reason.<br>
<p>
The synthetic-sounding voice *is* annoying but the content is useful. <br>
<p>
Disclaimer: I only watched a few short segments of the video but I could certainly see that the voice would grate after a while.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor919069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2023 18:07 UTC (Wed)
                               by <b>sammythesnake</b> (guest, #17693)
                              [<a href="/Articles/919069/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it were me doing those videos, I would certainly have aimed for a clearer choice, as well as one that's less piercing. I doubt I could cope with that voice for 8 hours(!)<br>
<p>
It's worth noting that the (auto-generated) subtitles are usable, even if not perfect, so you could watch with the audio turned down, though that wouldn't work well with having it on in the background of some other task and dipping in when something piques interest.<br>
<p>
I wonder if there's an audio filter that approximates the inverse of whatever was used to mask the voice in the first place - that might provide a more natural sounding option that at least *my* ears would find kinder.<br>
<p>
For now, I'll stick to reading her excellent blog posts as and when they get lunk to here on LWN :-P<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor915455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 6:23 UTC (Sat)
                               by <b>eean</b> (subscriber, #50420)
                              [<a href="/Articles/915455/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
they're a vtuber so it actually isn't that bad, ha. it's cool that people are making content like this for different audiences.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor915381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 14:26 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/915381/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      There's an awful lot of Rust infrastructure that has been posted in the past, including complete drivers; it's just not being pushed upstream yet.  I've been fairly deliberately looking closely at the code as it heads toward the mainline just because it breaks the problem down into manageable pieces.  The whole Rust-for-Linux patch set is a fair amount to absorb all at once.


      
          <div class="CommentReplyButton">
            <form action="/Articles/915381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2022 18:32 UTC (Fri)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/916687/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And I very much thank you for the work. I'm trying to understand Rust's advantages and disadvantages, and this step-wise approach is hugely helpful to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor915380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 14:23 UTC (Fri)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/915380/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder why they didn't use the standard log::info, log:debug etc. (and just added the missing levels) ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 16:11 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/915397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
By "standard" do you mean the `log` crate? I believe some of its guarantees are around flushing and such, so `PR_CONT` might be tougher to implement using the APIs set down in the crate itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor915460"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 9:02 UTC (Sat)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/915460/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
`Either` sounds like a generic type that would have its place in any "standard library for building stuff" for the Rust language, not particularly related to kernel programming. Do I correctly understand that the Rust-in-kernel people are not using any of the existing Rust stdlib, and are in fact reinventing their own stdlib? If so, then what are the mechanisms in place to ensure the ongoing quality and consistency of the design?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915460/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 9:42 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/915461/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bear in mind the kernel does not use the standard C stdlib either. Could they be re-writing the Rust stdlib for the exact same reason, namely (a) the stdlib breaks kernel invariants, and (b) the stdlib does not take into account that hardware breaks stdlib invariants?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 11:06 UTC (Sat)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/915464/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can see many reasons why kernel-side programming is a different enough environment to need its own stdlib, and there is nothing fundamentally wrong with that. But on the other hand, I would expect some principles about how to grow this kernel-stdlib. (Some people have experience growing standard libraries for languages/environments and some idea are probably worth porting over from the start.)<br>
<p>
For example (this is just a random idea, not a suggestion or anything) Rust-in-kernel could have decided to minimize the diff with outside-kernel Rust code by sticking to subsets of standard APIs or well-known third party packages whenever possible, or taking other steps to avoid divergence and reuse existing design choices. I see no trace of such a process in the [Either patchset](<a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-28-ojeda@kernel.org/">https://lwn.net/ml/linux-kernel/20221110164152.26136-28-o...</a>), which does not make any mention of pre-existing Either code in Rust outside the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 11:19 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/915465/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Rust doesn't have Either in it's <code>stdlib</code>. There are <a href="https://docs.rs/either/latest/either/">either crate</a> with <a href="https://docs.rs/either/latest/either/enum.Either.html">really featureful Either</a>, and it's <a href="https://lib.rs/crates/either/rev">widely used</a>, but from my understanding Linux kernel doesn't like to depend on external crates.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/915465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor915479"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2022 14:57 UTC (Sun)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/915479/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; `Either` sounds like a generic type that would have its place in any "standard library for building stuff"</span><br>
<p>
This is somewhat unrelated to the rest of your question, but I personally really don't agree. Rust core already has types for Option and Result, which are the common case for things that can be one of two types. But to me the Either type ends up simultaneously too broad and specific compared to just defining your own enum. The generic "left" and "right" names are cryptic and confusing, there is little commonality betwen users and it has worse type safety and error reporting. It also lacks extensibility by only offering two variants, making for a painful refactoring if you notice you do need three options after all. Lastly a lot of the time when a function can take multiple things, those things usually share some property which can perhaps be better represented by a trait.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915479/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2022 20:42 UTC (Sun)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/915537/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We've had this argument within the OCaml community, and actually I'm the person who ended up proposing 'either' for the standard library. I agree with your point that, very often, defining your own enum / variant type is the better approach, and also with your point that Option and Result already cover a lot of cases. But:<br>
<p>
- The argument that "defining your own variant with domain-specific names etc." also applies as a criticism of both Option and Result, and the fact that actually we use Option and Result a lot shows that this criticism only goes so far. Sometimes there are common scenarios were having a enum of fixed shape with standard name is a good approach, and the benefits in terms of reusing other people's code (auxiliary support functions etc.) are higher than the cost of the less-specific names.<br>
<p>
- There are generic functions for which Result could be used, but the more symmetric Either is more natural and thus a better API. (Result and Either are isomorphic so you can clearly always use one instead of the user, the question is how much of a conceptual mismatch this creates.) My main example in OCaml is<br>
<p>
      val partition_map : ('a -&gt; ('b, 'c) either) -&gt; 'a list -&gt; 'b list * 'c list<br>
<p>
It expects a function that, for any value of type 'a, will compute either a 'b or a 'c from it. Then it takes a list of elements of type 'a, and partitions it (using the function) into a list of 'b and a list of 'c. (Interestingly, this is an instance of a sort of generic operation that would split the 'a into an arbitrary sum of possible types, and return as many lists; but that function cannot be expressed easily in the OCaml type system, while 'partition_map' above can.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915642"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2022 17:06 UTC (Mon)
                               by <b>steveklabnik</b> (guest, #114343)
                              [<a href="/Articles/915642/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A small amount of history here: Rust *did* include Either in its standard library long, long ago. <a href="https://doc.rust-lang.org/0.7/std/either.html">https://doc.rust-lang.org/0.7/std/either.html</a><br>
<p>
My recollection of its removal was a survey of usage, and Result was used instead by 99.9% of the existing code instead.<br>
<p>
That said, it is true that the crates.io has high usage; it is the dependent of two *extremely* popular packages, itertools and rayon. I'm not aware of any movement to move it back into the standard library, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915642/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2022 21:16 UTC (Mon)
                               by <b>micka</b> (subscriber, #38720)
                              [<a href="/Articles/915660/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looking at the Either crate api, it’s awful. At least Result gives you a meaningful name for each variant (ok, err).<br>
Either gives you a... left and a right. Which is which? If both have the same content type, how do you differentiate? <br>
By the way, some people (like me) can’t tell the right from the left. Or rather can’t give them a name (but never will for example drive on the wrong side of the road). I had to work on codd which used an Either type in another language and could never manage to understand any of it even after multiple years.<br>
I guess it’self OK as write-only code...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2022 14:11 UTC (Tue)
                               by <b>TheGopher</b> (subscriber, #59256)
                              [<a href="/Articles/915710/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agree. Having worked with either in scala I can say that the overhead of a dedicated struct/union/variant is minimal - and the readability is much higher! This is the wrong place to be lazy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor915837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 23, 2022 17:17 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/915837/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; - The argument that "defining your own variant with domain-specific names etc." also applies as a criticism of both Option and Result, and the fact that actually we use Option and Result a lot shows that this criticism only goes so far.</font>

<p>How? <code>Option</code> and <code>Result</code> <b>are</b> domain-specific.</p>

<p><code>Option</code> is the fix for <a href="https://www.youtube.com/watch?v=ybrQvs4x0Ps">the billion-dollar mistake</a>: it handles the case where object may or may not be present.</p>

<p><code>Result</code> is for the case where function may return “normal” result or “error result”. Open POSIX specifications (or practically any API specification) and you'll find many such functions.</p>

<font class="QuotedText">&gt; - There are generic functions for which Result could be used, but the more symmetric Either is more natural and thus a better API.</font>

<p>It's not enough to have one such function. One function is always better server with ad-hock type. You need <b>series</b> of functions which may share a common type. It's easy to imagine such for <code>Options</code>: lot's of data structures have “leaf nodes”. It even easier to do that with <code>Result</code>: almost all functions which deal with files or network may suffer from the same errors (it doesn't matter whether you are creating file or removing it, if you don't have permission to do that error would be the exact same one).</p>

<p>Just what class of functions do you have in mind where you may have symmetrical two choices and these are the same across the whole range of functions?</p>

<p>Yes, <code>partition_map</code> example makes sense (and that's exactly where <code>itertools</code> are using <code>Either</code>), but Rust is imperative language with <code>for</code>. It's really not clear how often do you even need such thing in Rust.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/915837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2022 1:48 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/915854/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; the benefits in terms of reusing other people's code (auxiliary support functions etc.) are higher than the cost of the less-specific names.</span><br>
<p>
That is my problem with Either though. It's too vague to enable any reuse at all. I think a look at the associated functions of Option and Result in rust compared to the Either crate illustrate that quite clearly.<br>
<p>
Option and Result have dozens of combinators each that compose usefully. You can turn Results into Options, Options into Results, Options into Iterators, Results of Options into Results, Iterators of Options into Options, Iterators of Results into Results...<br>
<p>
Meanwhile on the Either side we get:<br>
(<a href="https://docs.rs/either/1.8.0/either/enum.Either.html">https://docs.rs/either/1.8.0/either/enum.Either.html</a>)<br>
- A few map variations, duplicated for left and right of course<br>
- Some forwarding of inner traits<br>
- A bunch of methods that turn it back into the more useful Option and Result types<br>
- Flip, that swaps the sides<br>
<p>
This is not a swipe against the authors. It just shows you just can't really do very much with types that are completely unconstrained and semantically meaningless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2022 14:21 UTC (Sat)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/916006/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another type that is "too vague" is the type of pair `(A, B)` -- and there are not that many standard-library functions defined on it. But we use it all the time! Honestly I think that the criticism against `Either` here comes from a lack of familiarity, rather than a deep reason. We programmers tend to be more familiar with product types than with sum types; for sums the most well-known is `Option&lt;A&gt;` that is the sum (A + 1), and we still need to time to collectively get used to using anonymous sum types when they make sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor916265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 30, 2022 12:07 UTC (Wed)
                               by <b>mlindner</b> (guest, #162450)
                              [<a href="/Articles/916265/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't really understand the need of adding the `Either` type, it's just a very very thin wrapper around "enum" with functionality limited to only two types. I wonder why they added it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust in the 6.2 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2022 0:58 UTC (Sat)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/916731/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
`Either` is one of the two combinators needed to represent arbitrary arithmetic data types, together with the zero/void (`!`) and one/unit (`()`) atomic types. `Either` represents the capacity for sums (enums). Pairs / tuples are their dual, representing product types (structs). They're both very abstract, but sometimes that's exactly what you want.<br>
<p>
It's true that you could just create your own custom enum type instead (which would be isomorphic to some tree of nested `Either` types) but your custom type won't benefit from any functions the standard library might provide for working generically with values which might be "either" one type or another. For example, partitioning a list of `Either&lt;A,B&gt;` into a list of `A` and a list of `B`. I'm not as familiar with what Rust provides for working with `Either` values but in Haskell the `Either` type is a key component of the Arrow abstraction, a more powerful (albeit less popular) alternative to monads, where they are used to represent conditional processing (`ArrowChoice`). It also benefits from ready-made instances of `Bifunctor`, `Bifoldable`, and `Bitraversable`.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
