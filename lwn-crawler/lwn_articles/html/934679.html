        <!DOCTYPE html>
        <html lang="en">
        <head><title>Scope-based resource management for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/934679/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/934728/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/934679/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Scope-based resource management for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 15, 2023</br>
           </div>
The C language does not provide the sort of resource-management features
found in more recent languages.  As a result, bugs involving
leaked memory or failure to release a lock are relatively common in
programs written in C — including the kernel.  The kernel project has never
limited itself to the language features found in the C standard, though;
kernel developers will happily
use extensions provided by compilers if they prove helpful.  It looks like
a relatively simple compiler-provided feature may lead to a significant
change in some common kernel coding patterns.
<p>
The feature, specifically, is the <tt>cleanup</tt> attribute, which is
implemented by both <a
href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#index-cleanup-variable-attribute">GCC</a>
and <a
href="https://clang.llvm.org/docs/AttributeReference.html#cleanup">Clang</a>.
It allows a variable to be declared using a syntax like:
<p>
<pre>
   type my_var __attribute__((__cleanup__(cleanup_func)));
</pre>
<p>
The extra attribute says that, when <tt>my_var</tt>, a variable of the
given <tt>type</tt>, goes out of scope, a
call should be made to:
<p>
<pre>
    cleanup_func(&amp;my_var);
</pre>
<p>
This function, it is assumed, will do some sort of final cleanup on that
variable before it disappears forever.  As an example, one could declare a
pointer (in the kernel) this way:
<p>
<pre>
   void auto_kfree(void **p) { kfree(*p); }

   struct foo *foo_ptr __attribute__((__cleanup__(auto_kfree))) = NULL;
   /* ... */
   foo_ptr = kmalloc(sizeof(struct foo));
</pre>
<p>
Thereafter, there is no need to worry about freeing the allocated memory;
once <tt>foo_ptr</tt> goes out of scope, the compiler will ensure that it
will be passed to a call to <tt>kfree()</tt>.  It is no longer possible to
leak this memory — at least, not without actively working at it.
<p>
This attribute is not particularly new, but the kernel has never taken
advantage of it.  In late May, Peter Zijlstra decided to change that
situation, posting <a
href="/ml/linux-kernel/20230526150549.250372621@infradead.org/">a patch
set</a> adding "lock and pointer guards" using that feature.  A <a
href="/ml/linux-kernel/20230526205204.861311518@infradead.org/">second
version</a> followed shortly thereafter and resulted in quite a bit of
discussion, with Linus Torvalds <a
href="/ml/linux-kernel/CAHk-=wg2RHZKTN29Gr7MhgYfaNtzz58wry9jCNP75LAmQ9t8-A@mail.gmail.com/">encouraging</a>
Zijlstra to generalize the work away from just protecting locks.

The result was the <a
href="/ml/linux-kernel/20230612090713.652690195@infradead.org/">scope-based
resource management</a> patch set posted on June&nbsp;12, which creates a
new set of macros intended to make the use of the <tt>cleanup</tt>
attribute easy.  The 57-part patch set also converts a lot of code to use
the new macros, giving an extensive set of examples of how they would
change the look of the kernel code base.
<p>
<h4>Cleanup functions in the kernel</h4>
<p>
The first step is to define a new macro, <tt>__cleanup()</tt>, which
abbreviates the attribute syntax shown above.  Then, a set of macros makes
it possible to create and manage a self-freeing pointer:
<p>
<pre>
    #define DEFINE_FREE(name, type, free) \
	static inline void __free_##name(void *p) { type _T = *(type *)p; free;}

    #define __free(name)	__cleanup(__free_##name)

    #define no_free_ptr(p) \
	({ __auto_type __ptr = (p); (p) = NULL; __ptr; })

    #define return_ptr(p)	return no_free_ptr(p)
</pre>
<p>
The purpose of <tt>DEFINE_FREE()</tt> is to associate a cleanup function
with a given type (though the "type" is really just a separate identifier
than is not associated with any specific C type).  So, for example, a
free function can be set up with a declaration like:
<p>
<pre>
    DEFINE_FREE(kfree, void *, if (_T) kfree(_T))
</pre>
<p>
Within the macro, this declaration is creating a new function called
<tt>__free_kfree()</tt> that makes a call to <tt>kfree()</tt> if the
passed-in pointer is not <tt>NULL</tt>.  Nobody will ever call that
function directly, but the declaration makes it possible to write code
like:
<p>
<pre>
    struct obj *p __free(kfree) = kmalloc(...);

    if (!p)
        return NULL;
    if (!initialize_obj(p))
        return NULL;
    return_ptr(p);
</pre>
<p>
The <tt>__free()</tt> attribute associates our cleanup function with the
pointer <tt>p</tt>, ensuring that that <tt>__free_kfree()</tt> will be
called when that pointer goes out of scope, regardless of how that happens.
So, for example, the second <tt>return</tt> statement above will not leak
the memory allocated for <tt>p</tt>, even though there is no explicit
<tt>kfree()</tt> call.
<p>
Sometimes, though, the automatic freeing isn't wanted; the case where
everything goes as expected and a pointer to the allocated object should be
returned to the caller is one example.  The <tt>return_ptr()</tt> macro,
designed for this case, defeats the automatic cleanup by copying the value
of <tt>p</tt> to another variable, setting <tt>p</tt> to <tt>NULL</tt>,
then returning the copied value.  There are usually many ways in which
things can go wrong and only one way where everything works, so arguably it
makes more sense to annotate the successful case in this way.
<p>
<h4>From cleanup functions to classes</h4>
<p>
Automatic cleanup functions are a start, but it turns out that there's more
that can be done using this compiler feature.  After some discussion, it
was decided that the best name for a more general facility to handle the
management of resources in the kernel was "class".  So, the next step is to
add "classes" to the C language as is used by the kernel:
<p>
<pre>
    #define DEFINE_CLASS(name, type, exit, init, init_args...)		\
        typedef type class_##name##_t;					\
	static inline void class_##name##_destructor(type *p)		\
	    { type _T = *p; exit; }					\
	static inline type class_##name##_constructor(init_args)	\
	    { type t = init; return t; }
</pre>
<p>
This macro creates a new "class" with the given <tt>name</tt>,
encapsulating a value of the given <tt>type</tt>.  The <tt>exit()</tt>
function is a destructor for this class (the cleanup function, in the end),
while <tt>init()</tt> is the constructor, which will receive
<tt>init_args</tt> as parameters.  The macro defines a type and a couple of
new functions to handle the initialization and destruction tasks.
<p>
The <tt>CLASS()</tt> macro can then be
used to define a variable of this class:
<p>
<pre>
    #define CLASS(name, var)						\
	class_##name##_t var __cleanup(class_##name##_destructor) =	\
		class_##name##_constructor
</pre>
<p>
This macro is substituted with a declaration for a variable <tt>var</tt>
that is initialized with a call to the constructor.  Note that the result
is an incomplete statement; the arguments to the
constructor must be provided to complete the statement, as shown below.
The use of the <tt>__cleanup()</tt> macro here ensures that the destructor
for this class will be called when a variable of the class goes out of
scope.
<p>
One use of this macro, as shown in the patch set, is to bring some
structure to the management of file references, which can be easy to leak.
A new class, called <tt>fdget</tt>, is created that manages the acquisition
and release of those references.
<p>
<pre>
    DEFINE_CLASS(fdget, struct fd, fdput(_T), fdget(fd), int fd)
</pre>
<p>
A constructor (named <tt>class_fdget_constructor()</tt>, but that name will
never appear explicitly in the code) is created to initialize the class
with a call to <a
href="https://elixir.bootlin.com/linux/v6.3.8/source/include/linux/file.h#L61"><tt>fdget()</tt></a>,
with the integer <tt>fd</tt> as its parameter.  This initialization creates
a reference to the file that must, at some point be returned.  The
class definition also creates a destructor, which calls <a
href="https://elixir.bootlin.com/linux/v6.3.8/source/include/linux/file.h#L42"><tt>fdput()</tt></a>,
that will be invoked by the compiler when a variable of this class goes out
of scope.
<p>
Code that wants to work with a file descriptor <tt>fd</tt> can make use of
this class structure with a call like:
<p>
<pre>
    CLASS(fdget, f)(fd);
</pre>
<p>
This line declares a new variable, called <tt>f</tt>, of type <a
href="https://elixir.bootlin.com/linux/v6.3.8/source/include/linux/file.h#L35"><tt>struct&nbsp;fd</tt></a>,
that is managed by the <tt>fdget</tt> class.  
<p>
Finally, there are macros to define classes related to locks:
<p>
<pre>
    #define DEFINE_GUARD(name, type, lock, unlock) \
	DEFINE_CLASS(name, type, unlock, ({ lock; _T; }), type _T)
    #define guard(name) \
	CLASS(name, __UNIQUE_ID(guard))
</pre>
<p>
<tt>DEFINE_GUARD()</tt> creates a class around a lock type.  For example,
it is used with mutexes with this declaration:
<p>
<pre>
    DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T)):
</pre>
<p>
The <tt>guard()</tt> macro then creates an instance of this class,
generating a unique name for it (which nobody will ever see or care about).
An example of the usage of this infrastructure can be seen in <a
href="/ml/linux-kernel/20230612093537.833273038@infradead.org/">this
patch</a>, where the line:
<p>
<pre>
    mutex_lock(&amp;uclamp_mutex);
</pre>
<p>
is replaced with:
<p>
<pre>
    guard(mutex)(&amp;uclamp_mutex);
</pre>
<p>
After that, the code that explicitly unlocks <tt>uclamp_mutex</tt> can be
deleted — as can all of the error-handling code that ensures that the
unlock call is made in every case.
<p>
<h4>The guard-based future</h4>
<p>

The removal of the error-handling code in the above example is significant.
A common pattern in the kernel is to perform cleanup at the end of a
function, and to use <tt>goto</tt> statements to jump to an appropriate
point in the cleanup code whenever something goes wrong.  In pseudocode
form:
<p>
<pre>
    err = -EBUMMER;
    mutex_lock(&amp;the_lock);
    if (!setup_first_thing())
       goto out;
    if (!setup_second_thing())
       goto out2;
    /* ... */
    out2:
        cleanup_first_thing();
    out:
        mutex_unlock(&amp;the_lock);
        return err;
</pre>
<p>
This is a relatively restrained use of <tt>goto</tt>, but it still adds up
to vast numbers of <tt>goto</tt> statements in the kernel code and it is
relatively easy to get wrong.  Extensive adoption of this new mechanism
would allow the above pattern to look more like this:
<p>
<pre>
    guard(mutex)(&amp;the_lock);
    CLASS(first_thing, first)(...);
    if (!first or !setup_second_thing())
        return -EBUMMER;
    return 0;
</pre>
<p>
The code is more compact, and the opportunities for the introduction of
resource-related bugs are reduced.
<p>
There's more to these macros than has been discussed here, including a
special variant for managing read-copy-update (RCU) critical sections.
Curious readers can find the whole set in <a
href="/ml/linux-kernel/20230612093537.614161713@infradead.org/">this
patch</a>.
<p>
One potentially interesting side-change in the series is the <a
href="/ml/linux-kernel/20230612093537.693926033@infradead.org/">removal</a>
of the compiler warning for declarations after the first statement — a
warning that has backed up the longstanding requirement in the kernel's
coding style to avoid intermixing declarations and statements in that way.
It simply was not possible to make these macros work without relaxing that
rule.  Torvalds <a
href="/ml/linux-kernel/CAHk-=wi-RyoUhbChiVaJZoZXheAwnJ7OO=Gxe85BkPAd93TwDA@mail.gmail.com/">agreed</a>
with this change, saying that perhaps the rule can be softened somewhat:
<p>
<blockquote class="bq">
	I think that particular straightjacket has been a good thing, but I
	also think that it's ok to just let it go as a hard rule, and just
	try to make it a coding style issue for the common case, but allow
	mixed declarations and code when it makes sense.
</blockquote>
<p>
The reaction to this work has been mostly positive; Torvalds seems to be
happy with the general direction of this new mechanism and has <a
href="/ml/linux-kernel/CAHk-=wj3jV+v63RA30eVpjHVyrGmmTF7d3ajdV=1wBU=5OHa=A@mail.gmail.com/">limited
himself</a> to complaining about potential bugs in a couple of specific
conversions and  the length of the patch series in general.
So it seems reasonably likely that something like this will find its way
into a future kernel release.  The result could be safer resource
management in the kernel and a lot fewer <tt>goto</tt>s.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools">Development tools</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.5">Releases/6.5</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/934679/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor934835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2023 21:17 UTC (Thu)
                               by <b>lucaswerkmeister</b> (subscriber, #126654)
                              [<a href="/Articles/934835/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’m surprised, but excited, that the kernel is open for this feature. (I believe systemd extensively uses it, for instance.) The lock integration is really interesting too.<br>
<p>
But I wonder how it will affect backporting of patches? It’s easy to imagine a patch written for a kernel with scope-based resource management being backported to a kernel without it, accidentally creating a resource leak. Will the whole infrastructure be backported, or will the people doing backports take care of adding all the explicit cleanups? (Perhaps they can have some automated assistance, at least – some kind of tooling which shows all the places where the compiler is inserting the automatic cleanup.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 0:39 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/934843/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just backport the scope macros into the old kernels. It's a purely additive change, without any API impact.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor934866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 9:50 UTC (Fri)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/934866/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <q>I believe systemd extensively uses it, for instance.</q>
<br>
Not only systemd, every well-written Glib-based C project should use <code>g_autoptr()</code> and friends instead of manual cleanups (many already do).<br>
<br>
I myself try to convert code to automatic resource management when I work on neighboring areas - for example <a href="https://gitlab.freedesktop.org/geoclue/geoclue">GeoClue</a> is now mostly <code>g_autoptr()</code>-based, solving many memory safety issues that older versions had.<br>
<br>
In the C++ world RAII is also pretty much <b>the</b> right way to manage resources (even in code that does not require exception safety).<br>
<br>
<q>It’s easy to imagine a patch written for a kernel with scope-based resource management being backported to a kernel without it, accidentally creating a resource leak.</q>
<br>
I'm not sure how this patch set does this exactly but in Glib's implementation if the object type does not have its cleanup function defined the code that uses <code>g_autoptr()</code> on this type won't compile or link.<br>
<br>
Assuming that this patch set implements its cleanup support in a similar way backporting a patch that uses automatic cleanups for a type to an older kernel version that does not define cleanup function for this type yet should be caught by the compiler.
<hr>
As I said <a href="https://lwn.net/Articles/930955/">here in May</a> it would be nice if the <code>defer</code> feature did make to the next C standard after C23 - it would allow implementing these automatic cleanups without having to resort to non-standard compiler extensions.<br>
<br>



      
          <div class="CommentReplyButton">
            <form action="/Articles/934866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2023 3:58 UTC (Mon)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/935093/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;As I said here in May it would be nice if the defer feature did make to the next C standard after C23 - it would </span><br>
<span class="QuotedText">&gt;allow implementing these automatic cleanups without having to resort to non-standard compiler extensions.</span><br>
<p>
Given that the kernel has only recently updated to C11, it's unlikely that C23 would have been adopted even if it included defer.     It's too bad that defer has been reinvented as a long series of macros, although everyone will be glad to see functions that are 2/3 error-handling  goto's and associated labels get shorter.   Perhaps the new macros could significantly reduce lines of code in source files that are full of error handlers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor935762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 11:10 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/935762/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The defer feature as proposed for C23 was massive over-engineering and not even good.  What the C committee needs to do is standardize __attribute__((cleanup)).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor938159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2023 22:26 UTC (Thu)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/938159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;As I said here in May it would be nice if the defer feature did make to the next C standard after C23 - it would allow implementing these automatic cleanups without having to resort to non-standard compiler extensions.</span><br>
<p>
The problem with defer, as it was proposed for C23, was that it was conjoined with a nonlocal exit syntax ("panic") which were effectively C++/Java/Ada exceptions by a different name. And it makes sense: with autocleanup it'd be desirable, and not a large leap, to prefer acquisition code to run without introducing silly errors in the error checks which must occur at every (re-)turn. Not that routine unlikely()[0] didn't take care of the performance issue already.<br>
<p>
The downside was that this would also pull in lambda syntax which makes it three features instead of one, the bonus ones being a nonlocal exit mechanism that can't be audited against by grepping for &lt;setjmp.h&gt;, and all the fun and games that follow from first-class anonymous functions in a world where trampolines can't be emitted on the stack for security reasons. (imagine arguments about elevator controllers with 256 bytes of modifiable RAM, here.) All three put together would've made that proposal of C23 so radically different, and so hitherto unexplored, that those ideas were tabled until the fashionable feature fever had passed -- presumably to be reintroduced in the C3x process.<br>
<p>
[0] ... and also the CPU advances of 1996, i.e. branch prediction in combination with an instruction window.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/938159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor935913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 19:52 UTC (Thu)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/935913/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 &gt; I’m surprised, but excited, that the kernel is open for this feature. (I believe systemd extensively uses it, for instance.) <br>
<p>
I am curious if they considered some prior art (like systemd) and a compatible implementation. For example systemd use take_ptr, where in this example it is used free_ptr.<br>
<p>
This would help the portability of the code and pushing to standardize some features.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934838"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 4:32 UTC (Fri)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/934838/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a code style in C where missed cleanup calls happens less frequently. One bans any kind of an early return. The return statement can be only at the last of the function. Then one does all cleanups at single place before that. In place of early return goto to that cleanup block is  used.<br>
<p>
In my experience with this style it is much harder to miss a cleanup action. Plus it allows for the cleanup to have more than one parameter. The latter is even the problem in C++ where a destructor cannot be called with extra arguments.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934838/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934861"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 8:03 UTC (Fri)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/934861/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm curious. In all my 30 years or so of writing C++ code I've never felt the need or even had the idea to have destructors with parameters (or more generally, to have cleanup code that requires parameters to work correctly). Can you give me some examples when that might be necessary? Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934861/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 9:53 UTC (Fri)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/934867/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Any extra arguments you would want to pass to a destructor function (i.e. besides the pointer to the object being destroyed) can be transformed to/from a model where those arguments are kept around as members of the object. Both approaches make an appearance in the POSIX environment:<br>
<p>
1. void *p = mmap(..., z, ...); /* workworkwork */; munmap(p, z);<br>
2. void *p = malloc(z); /* workworkwork */; free(p);<br>
<p>
It's a tradeoff. #2 needs memory in each object to store the 'z' used during construction, while #1 needs CPU instructions to load 'z' from some memory location into the function call.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 10:12 UTC (Fri)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/934871/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I know, but I was explicitly asking about C++, not C, as ibukanov's statement was:<br>
<p>
<span class="QuotedText">&gt; The latter is even the problem in C++ where a destructor cannot be called with extra arguments.</span><br>
<p>
In C++ both of your examples would not be a problem as you'd encapsulate the knowledge in types, e.g. using std::shared_ptr/std::unique_ptr for ownership management, a custom allocator for malloc/free and a custom thin wrapper class around mmap/munmap that stores z as a member.<br>
<p>
That's why I asked &amp; why I'm still curious of situations where "embed required arguments in thin wrapper class" isn't working.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 9:28 UTC (Sat)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/934982/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fewer things are implicit in C. A wrapper, as thin as it might be, may need more lines of source code than invoking a (C) destructor function with multiple arguments a few times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 12:23 UTC (Fri)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/934884/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  1. void *p = mmap(..., z, ...); /* workworkwork */; munmap(p, z);</span><br>
<span class="QuotedText">&gt; 2. void *p = malloc(z); /* workworkwork */; free(p);</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; It's a tradeoff. #2 needs memory in each object to store the 'z' used during construction, while #1 needs CPU instructions to load 'z' from some memory location into the function call.</span><br>
<p>
For #1 there is another disadvantage: you also need to pass `z` to all functions that may destroy (or may call functions that destroy) `p`.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor934977"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 3:49 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/934977/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In modern C++ you can just use a scope guard with a small lambda function to capture the needed variables.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934977/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor935910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 19:47 UTC (Thu)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/935910/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Any extra arguments you would want to pass to a destructor function (i.e. besides the pointer to the object being destroyed) can be transformed to/from a model where those arguments are kept around as members of the object. Both approaches make an appearance in the POSIX environment:</span><br>
<p>
<span class="QuotedText">&gt; 1. void *p = mmap(..., z, ...); /* workworkwork */; munmap(p, z);</span><br>
<span class="QuotedText">&gt; 2. void *p = malloc(z); /* workworkwork */; free(p);</span><br>
<p>
<span class="QuotedText">&gt; It's a tradeoff. #2 needs memory in each object to store the 'z' used during construction, while #1 needs CPU instructions to load 'z' from some memory location into the function call.</span><br>
<p>
I am not sure that these can be called 'destructor'; a destructor is a way to release automatically the resource. If you have to call explicetely it is not a destructor but is a 'classic' resource releasing.<br>
<p>
If the releasing is automatic, you cannot forgot to do that.<br>
<p>
Instead if you have to pass a parameter to a destructor you are introducing another potential mistake: what if in your example you call munmap(p, y) (note y as last argument) ?<br>
<p>
Using a destructor, or __attribute__((__cleanup__)) are not magic bullet that solve all the issues. A more interesting example is what if two abject are linked and have to be released together (i.e. explicitly). A destructor cannot solve this kind of issue, because it assume that the objects are independent each others, and the destructorS can operate independently.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2023 4:55 UTC (Fri)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/935954/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is not classic resource releasing. The compiler verifies that a destructor with extra arguments is called exactly at places in the code where an automatic destructor is called.<br>
<p>
If there are several things that need to be destructed, then the compiler still inserts automatically calls to parameter-less destructors before or after the explicit call in the reverse order of construction.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor936161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2023 8:31 UTC (Sat)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/936161/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It is not classic resource releasing. The compiler verifies that a destructor with extra arguments is called exactly at places in the code where an automatic destructor is called.</span><br>
<p>
<span class="QuotedText">&gt; If there are several things that need to be destructed, then the compiler still inserts automatically calls to parameter-less destructors before or after the explicit call in the reverse order of construction.</span><br>
<p>
This seems more error prone than any other solution. A mix of actions of the developers and the compiler. Still doesn't solve the issue of calling a destructor with a wrong parameter.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/936161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor934874"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 10:34 UTC (Fri)
                               by <b>vegard</b> (subscriber, #52330)
                              [<a href="/Articles/934874/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I tried converting some kernel driver C code to C++ once and I don't remember all the details but it was something like a network driver that had two DMA ring buffer objects. Destroying those buffer objects required the buffer size to be passed in (presumably to do some unmapping operation). In normal object-oriented code, those buffer objects would know how to destroy themselves, and the device object would just tell them to do that. However, because they were both the same size, that size was stored in the device struct rather than in the buffer struct (presumably as an optimization -- why store the size in 2 or 3 places when one is sufficient?). It meant that the buffers didn't know how to destroy themselves, as that required information from the device struct. If we'd had destructors with parameters then the device destructor could have passed the size in and called the buffer destructors with the size parameter.<br>
<p>
There is probably a more elegant example, but the general idea is "information required to destroy an object comes from outside the object itself".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934874/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor934879"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 12:01 UTC (Fri)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/934879/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is about performance and ownership. <br>
<p>
Storing extra fields in the object just for accessing in the destructor will lead to extra memory load that the compiler does not typically optimize away.<br>
<p>
Then if one has a unique ptr to a resource manager, one does not want to store that in the object. A workaround is shared_ptr or raw pointers, but they do not reflect the ownership model.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934879/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 9:28 UTC (Fri)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/934865/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;One bans any kind of an early return</span><br>
<p>
That is the "structured programming" paradigm, and the downside is that - unless you split code off to separate functions - the nesting level can go deep quickly (i.e. right side edge of the editor), violating other coding style paradigms. The lack of an early exit also means you have to mentally keep track of all the branches and conditions to reach a particular line - quickly exceeding the limit of ~7 objects that the human short-term memory can hold. That's all why GNU coding style is unwieldly. [Cf. e.g. coreutils:src/ls.c:do_statx.]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 12:05 UTC (Fri)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/934881/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is not a structured programming. It is about replacing any early return with goto to the cleanup block shared by all code paths.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 18:09 UTC (Fri)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/934953/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since 2010, I have fixed or reported more kernel error handling bugs than anyone else.  It's my thing.<br>
<p>
This kind of One Exit Style is doesn't work.  It doesn't prevent any bugs.  People who are going to forget to unlock are going to forget regardless of what style you use.<br>
<p>
There is no upside and there are some downsides to the One Exit Style.  It hurts readability, because now you have to scroll to the bottom of the function to see what "goto out;" does where a "return -EINVAL;" is obvious.  The second downside is that it introduces forgot to set the error code bugs.  People think error codes are a minor thing but returning success on an error path is going to lead to a crash of some sort.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 3:24 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/934976/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; what "goto out;" does where a "return -EINVAL;" is obvious</span><br>
<p>
res = -EINVAL; goto out.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 6:49 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/934979/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, if res is not initialised by the time the code reaches the out: label, then modern compilers will warn about it.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 11:34 UTC (Sat)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/934991/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The kernel disables GCC's uninitialized variable warning because it had too many false positives.  We use Clang and Smatch (my static checker) to find uninitialized variables but that doesn't really help with missing error code bugs.  Normally the buggy code looks like:<br>
<p>
ret = frob();<br>
if (ret)<br>
        goto free_thing;<br>
<p>
if (val &gt; limit)<br>
       goto free_thing;<br>
<p>
In Smatch, I consider that ret is set intentionally to zero if the "ret = " assignment is within 5 lines of the goto.  But this is kind of a new rule and some people think you should be able to tell it's intentional from the context.<br>
<p>
int ret = 0;<br>
<p>
/* twenty lines of code */<br>
<p>
if (on == ON)<br>
        goto done;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor935100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2023 9:15 UTC (Mon)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/935100/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
modern = gcc-4.1? ;-)<br>
<p>
That's the reason I kept on compiling kernels with gcc-4.1 for a while, even after the bar was raised to gcc-4.6... <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor938158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2023 21:45 UTC (Thu)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/938158/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Alternatively one can place resource acquisition and release in a function, and the operation on those resources in a second function, which is then at liberty to early-exit as much as it jolly pleases. A single-caller static function will be inlined by the compiler, yielding much the same result as a block of "Enomem: ret = -ENOMEM; goto cleanup;" lines.<br>
<p>
More related to the automatic cleanup as discussed in the article, I have to wonder whether the utility of autocleanup is commensurate with the number of possible errors in usage that these structures harbour, and the length of time it'll take before kernel review is up to the task of catching them as well as mistakes in non-compiler cleanup. Forgetting the __highly__((__underscored__)) mess of attributes, which must go after each variable declaration[0] where autocleanup is desired, is just the tip of the iceberg. Could there please be some kind of a linter program to highlight suspicious cases such as "return ptr;" when "return_ptr(ptr);" was intended, so that this glass tower doesn't become a source of the next dozen years' worth of exploitable use-after-frees? A cleanup sanitizer pass in GCC perhaps?<br>
<p>
To contrast, in Ada[1] the equivalent of an autocleanup property is associated with a type by specifying it as an extension of a "controlled" base type, and is thereafter transparent[2] to the programmer whether such controlled objects are passed around by copy, out-parameter, array slice, or whatever. This entirely eliminates usage errors in cases where the object is treated as though it contained no pointers, if its implementations of the "dispose" and "post-copy rejigger" methods are correct. Seeing that the amount of diddle involved in approximating something similar in C is about the same, only to give up some of C's flexibility and transparency, I have to wonder if this metaprogramming exercise is worth using "in anger".<br>
<p>
[0] which appears to restrict variable declarations to one per line, not unlike the coward's maladaptation to C declaration-follows-use pointer syntax.<br>
[1] please note that this is not in support of its use in the kernel; far from it.<br>
[2] in the sense of "invisible but tangible".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/938158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934855"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 6:19 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/934855/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent. I have a case for variables inside for loops:<br>
<p>
void LOCK(void);<br>
void UNLOCK(void);<br>
<p>
static inline void dtor_UNLOCK(int *_)<br>
{<br>
        UNLOCK();<br>
}<br>
<p>
#define with_LOCK       for (int x __attribute__((cleanup(dtor_UNLOCK))) = (LOCK(), 1); x; x = 0)<br>
<p>
<span class="QuotedText">&gt;  -mutex_lock(&amp;uclamp_mutex);</span><br>
<span class="QuotedText">&gt; +guard(mutex)(&amp;uclamp_mutex);</span><br>
<p>
This should be rejected just by the looks of it. Tupolev once said "Ugly planes don't fly".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934855/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor934856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 6:23 UTC (Fri)
                               by <b>sulix</b> (subscriber, #97003)
                              [<a href="/Articles/934856/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Very neat: I can't begin to count how many times this would've been useful.</p>

<p>In fact, it's interesting to see how many resource management things there are in the kernel already, like the <a href="https://docs.kernel.org/driver-api/basics.html#device-resource-management">Device Resource Management</a> functions, and KUnit's <a href="https://docs.kernel.org/dev-tools/kunit/api/resource.html">resource API</a> and <a href="https://git.kernel.org/pub/scm/linux/kernel/git/shuah/linux-kselftest.git/commit/?h=kunit&id=b9dce8a1ed3efe0f5c0957f4605140f204226a0f">deferred action API</a> (planned for 6.5).</p>

<p>There'll obviously still be a need for those in cases where the lifecycle doesn't match the stack / scope, but I think this could take over a lot of the simpler "I just don't want to write error handling" cases.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/934856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor934858"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 6:48 UTC (Fri)
                               by <b>xi0n</b> (subscriber, #138144)
                              [<a href="/Articles/934858/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think the very first example in the article is correct. kfree() takes the pointer to allocated memory directly, which means that if you use with the cleanup attribute, it will get the address of the local variable containing the allocated pointer. In other words, it will try to free stack memory rather than the kmalloc'ed chunk, thus creating a memory access bug rather than preventing one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934858/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kfree() example</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 12:32 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/934885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You are correct, I went a little off-track when pulling that out of <tt>DEFINE_FREE()</tt>, which does the indirection.  I have fixed the example, apologies for the confusion.


      
          <div class="CommentReplyButton">
            <form action="/Articles/934885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 10:22 UTC (Fri)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/934872/">Link</a>] (42 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
More macro hell to emulate C++ badly using multiple non-standard GNU extensions. So much is wrong with this implementation, worse than just switching to (a subset of) C++.<br>
<p>
With C++, the owner of a pointer can be expressed in the type system. While Peter's code is a clever hack, it's still fragile because you still have to do things manually that the C++ compiler would assist you with.<br>
<p>
Why do Linux kernel developers inflict so much pain on themselves?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 14:23 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/934910/">Link</a>] (39 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If your proposal is to instead use a different programming language, Linux already has Rust for Linux. Judging from their experience, if you start now with a team of people to address this and Linus approves your C++ language features could begin to be available in 2026. I'd guess this macro will land rather sooner than that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 14:51 UTC (Fri)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/934942/">Link</a>] (37 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If your proposal is to instead use a different programming language, Linux already has Rust for Linux.</span><br>
<p>
You're missing the point. Rust's scope within the Linux kernel is extremely limited (no Rust core code, only a narrow scope of modules/drivers). Rust will not help with the problem that those macros are attempting to solve, because that would require converting all caller locations of those macros to Rust before doing anything else, and that would require converting all their dependencies to Rust, and so on... won't happen.<br>
<p>
On the other hand, allowing a C++ (subset) would make all desirable C++ features available everywhere, immediately.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 15:05 UTC (Fri)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/934944/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; On the other hand, allowing a C++ (subset) would make all desirable C++ features available everywhere, immediately.</span><br>
<p>
Aren't several of you arguing in this very thread against one of the most iconic &amp; useful C++ feature, RAII? Mostly because it imposes a performance impact (which it does, I don't dispute that; see ibukanov's comment) &amp; isn't as efficient if it requires storing a second copy of a pointer that's already available elsewhere (see vegard's comment)?<br>
<p>
Be prepared for resistance, not just from the folks who don't want C++ or don't want language no. 3 in the kernel, but also from those preferring raw speed &amp; space efficiency.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 15:28 UTC (Fri)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/934945/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Aren't several of you arguing in this very thread against one of the most iconic &amp; useful C++ feature, RAII?</span><br>
<p>
Several of "us"? I see nobody arguing against RAII. This whole thread is about adding RAII to the C part of the kernel (implemented with macros and non-standard extensions). RAII already exists in the Rust part of the kernel, it's a standard Rust feature.<br>
<p>
<span class="QuotedText">&gt; Mostly because it imposes a performance impact</span><br>
<p>
That is not a natural property of RAII. It is possible to use C++ in a way that is less efficient than C, and it is just as possible to use C++ in a way that is more efficient than C, but such comparisons are difficult. In any case, my point is: RAII has no performance impact per se.<br>
<p>
(But the more important point is: it is easier to write correct C++ code than to write correct C code.)<br>
<p>
<span class="QuotedText">&gt; if it requires storing a second copy of a pointer that's already available elsewhere</span><br>
<p>
Sometimes, extra context needs to be stored in the RAII class, that is true. But often, that overhead will be optimized away by the compiler.<br>
<p>
I just wrote an example on Godbolt: <a href="https://godbolt.org/z/GjsWx1vda">https://godbolt.org/z/GjsWx1vda</a> - as you see, the machine code is identical, and the whole RAII class gets optimized away; the allocated pointer lives in the same register in both versions, and the size isn't stored anywhere, it remains in the register argument (in both versions).<br>
<p>
Writing code where the C++ compiler can optimize away all the RAII "overhead" can be tricky, but even if your compiler is too dumb or your code isn't optimized well enough - optimize later, but have good robust leak-free code from the beginning. Those who really care will get identical machine code, with less effort than writing plain C.<br>
<p>
<span class="QuotedText">&gt; but also from those preferring raw speed &amp; space efficiency.</span><br>
<p>
That's a myth.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 16:45 UTC (Fri)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/934951/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Several of "us"? I see nobody arguing against RAII.</span><br>
<p>
Sorry about the "us"; I was just conflating the different people I was replying to.<br>
<p>
OK, maybe "against RAII as commonly used in C++" would be more precise? I was only confused by ibukanov's initial statement that C++'s destructors not allowing arguments. The examples that were given sounded very un-C++-like to me as both cases could easily be solved in the usual C++-RAII style by storing copies of the relevant pointers inside the class. But the arguments against that was "no, bad for performance" (paraphrasing).<br>
<p>
I'm really, really not arguing against RAII or against C++ in general, nor against RAII in C++ in particular; quite the opposite. RAII in C++ is one feature I really like about C++. I'm just… confused by what different people wrote.<br>
<p>
And about performance: I was referring to std::unique_ptr notbeing a zero-cost abstraction; see Chandler Carruth's presentation about it: <a href="https://www.youtube.com/watch?v=rHIkrotSwcc">https://www.youtube.com/watch?v=rHIkrotSwcc</a> (the most interesting part is probably 17:30–24:00) That falls into the category you've mentioned yourself:<br>
<p>
<span class="QuotedText">&gt; Writing code where the C++ compiler can optimize away all the RAII "overhead" can be tricky</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 17:25 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/934952/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The examples that were given sounded very un-C++-like to me as both cases could easily be solved in the usual C++-RAII style by storing copies of the relevant pointers inside the class. But the arguments against that was "no, bad for performance" (paraphrasing).</span><br>
<p>
For the kernel, yes. Don't forget, if your structures grow in size, you're talking cache misses, cache eviction, cache line bounce, etc. All of which can be VERY expensive.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor934980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 7:00 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/934980/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are two separated questions. RAII as a paradigm and RAII as it is implemented in C++.<br>
<p>
From a system/emebeded programming point of view I would rather prefer if C++ would require explicit destructor calls for RAII rather than calling destructors automatically. Yes, it will make code more verbose, but at least it will make very obvious what the code is doing. And it will prevent a few bugs due to unexpected destruction of temporaries. For C such enforcement of destructor-type calls will be even more natural that the current attribute hack.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934983"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 7:31 UTC (Sat)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/934983/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The whole idea of RAII is automatic freeing of the acquired resources in order to prevent memory leaks. Additionally in C++ you get the nice property that you have deterministic behavior when the resource is freed: when the life of the object holding the <br>
resource ends.<br>
<p>
Manual calls to destructors are not RAII. You don't gain any of RAII's advantages by requiring manual calls to free the resource.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934983/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2023 14:46 UTC (Sun)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/935048/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The idea is that the compiler requires explicit destructor calls exactly at the places where presently it inserts it automatically.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935086"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2023 0:32 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/935086/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linear aka Use-exactly-once types. C++ isn't very well suited for this kind of types. Neither is Rust. There are languages which thrive on linear types and a few newer ones are purpose built for these types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935086/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor935076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2023 21:13 UTC (Sun)
                               by <b>nksingh</b> (subscriber, #94354)
                              [<a href="/Articles/935076/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would instead prefer a paradigm like WordPerfect's 'reveal codes', where the compiler and editor can display the code that the compiler is injecting as an option rather than needing to have the code visible at all times.<br>
<p>
The advantage of producing the code as needed for review/debugging rather than requiring it to be explicit: when editing, your code remains flexible and modifiable with the compiler doing the bookkeeping at the end, rather than you having to compensate for changes manually before you can even test your code out. I think for domains like embedded, high performance, and kernel code, this transform between 'debuggable' and 'editable' source code would help satisfy both people who want productivity and those who want to know exactly what will happen in the CPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor936318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 26, 2023 6:13 UTC (Mon)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/936318/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Then it should all be implemented in the editor. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/936318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor937122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2023 17:05 UTC (Sun)
                               by <b>bluss</b> (subscriber, #47454)
                              [<a href="/Articles/937122/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Non-trival C++ functions have two exit paths: the return statement (if a single one) and when unwinding an exception. To be fully explicit, one needs to write out destructor calls that happen in both those cases(!).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/937122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor934972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 0:09 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/934972/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; On the other hand, allowing a C++ (subset) would make all desirable C++ features available everywhere, immediately.</span><br>
<p>
In the C++ fantasy (which Bjarne has been selling for decades) you take any C software, you just rename a few files and bingo, a more capable, more expressive much better language. What are people waiting for?<br>
<p>
It's a fantasy, which Linus won't be indulging in his tree. The Linux source code is readily available though, so you can try this out for yourself and make sure not to go talking about this fantasy again until you've actually found out what the reality is like and have something to show for your effort.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 8:15 UTC (Sat)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/934985/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The Linux source code is readily available though, so you can try this out for yourself and make sure not to go talking about this fantasy again until you've actually found out what the reality is like and have something to show for your effort.</span><br>
<p>
Sure there's a lot of hate for C++, the language has its many warts and gives you lots of reasons to hate it, and of course people can have different opinions, but your comment bashing it as "fantasy" and asking me to "have something to show" doesn't quite shine a good light on your competence in programming languages.<br>
<p>
Long ago, I was a C fanboy and disliked C++, but then came C++11 which solved many of the things I disliked. In the following years, I converted all of my dayjob C projects to C++ and did the same to several open source projects I manage. (Maybe even one you're using.)<br>
<p>
My point is: your rather immature request "not to go talking about this fantasy again" is aimed at the wrong guy. I went through this "fantasy", and I've been living in this C++ utopia for many years. It's not fantasy, it works. Of course, it's not all unicorns and rainbows, but strictly better than C in every aspect.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 19:03 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/935009/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; My point is: your rather immature request "not to go talking about this fantasy again" is aimed at the wrong guy. I went through this "fantasy", and I've been living in this C++ utopia for many years. It's not fantasy, it works. Of course, it's not all unicorns and rainbows, but strictly better than C in every aspect.</span><br>
<p>
There speaks the user-space programmer who thinks the solution for a slow program is to throw hardware at it.<br>
<p>
Many moons ago, my company was given a six week deadline, and I accepted the challenge to try and meet it. I had five weeks to automate a very manual setup. Four weeks into the project, I estimated my program would take three or four weeks to just run... Oh - and I met the deadline.<br>
<p>
That was back in the day when the most powerful weather-forcasting computers had difficulty forcasting the weather before it happened.<br>
<p>
Less so now, but as a database programmer I've heard plenty of stories of changes to the Oracle optimiser screwing over carefully crafted and optimised queries.<br>
<p>
The kernel programmers have enough trouble fighting C optimisations in gcc - they don't want to have to fight far more obscure optimisations in C++.<br>
<p>
How much effort / often times have you had to optimise a program for speed? It's an art that most young people just don't understand.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 19:36 UTC (Sat)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/935010/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; There speaks the user-space programmer who thinks the solution for a slow program is to throw hardware at it.</span><br>
<p>
Your whole post sounds awfully arrogant (and wrong). It doesn't add any content to the discussion, you only bash somebody you don't know with bogus and strawman arguments.<br>
<p>
Compiler optimizations in C and C++ aren't fundamentally different, and aren't fundamentally different between userspace and kernel space. Yes, there are differences in both aspects, but not in a way that adds to the difficulty like you pretend it does.<br>
<p>
<span class="QuotedText">&gt;  How much effort / often times have you had to optimise a program for speed? It's an art that most young people just don't understand.</span><br>
<p>
Every day for several decades, and I wouldn't call it "art", because it's deterministic and mechanical, the simplest part of my job. Yes, many people don't value fast/lean code, that's a big problem that annoys me a lot, but your way of ranting at me says more about yourself. You sound like "confused old man yells at cloud" rather than "wise old man".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor936367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 26, 2023 14:36 UTC (Mon)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/936367/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Compiler optimizations in C and C++ aren't fundamentally different
</blockquote>

My impression is that they are, and that the pretence that programs do not exercise standard-undefined behaviour comes, for a large part, from C++ programmers, while those who use options like <code>-fno-strict-aliasing</code> to get rid of "optimizations" that are based on this pretence are, for a large part, C programmers.

<p>In earlier discussions on the topic, several advocates of these "optimizations" argued that they are very useful for not-quite-source code coming from expanding the original source code (typically when I pointed out that nobody writes programs in a way that the advocate just showed as an example of the usefulness of the "optimization"), and for the same reason that it's not a good idea to warn when the "optimization" strikes (supposedly there is so much not-quite-source code where the "optimization" strikes that one supposedly would be flooded with warnings).  Both claims are very doubtful for even the most macro-laden C code, so I assumed the advocates had C++ code in mind; or maybe the advocates were just bullshitting me.

<p>Anyway, I wonder how much the fact that GCC and Clang are written in C++ contributes to adding these kinds of "optimizations" (especially adding them (at first) without a kill switch).





      
          <div class="CommentReplyButton">
            <form action="/Articles/936367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor935027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2023 2:24 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/935027/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So where is it then? Where is your C++ Linux kernel?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2023 11:38 UTC (Mon)
                               by <b>zorro</b> (subscriber, #45643)
                              [<a href="/Articles/935109/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You already know the answer to that question, so why ask it? Your trolling doesn't add anything useful to the discussion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2023 12:32 UTC (Mon)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/935112/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  You already know the answer to that question, so why ask it? Your trolling doesn't add anything useful to the discussion.</span><br>
 <br>
Bringing up C++ when it is never going to be used in the Linux kernel adds nothing to the discussion in the first place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor934988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 20:57 UTC (Sat)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/934988/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <q>The Linux source code is readily available though, so you can try this out for yourself and make sure not to go talking about this fantasy again until you've actually found out what the reality is like and have something to show for your effort.</q><br>
<br>
There has been a few patch sets posted to allow C++ usage in the Linux kernel - the most recent one AFAIK was posted as an April Fools' joke 5 years ago.<br>
<br>
Although, given the well-known upstream hostility to C++, people find it hard to justify the amount of work required to prepare a serious RFC.



      
          <div class="CommentReplyButton">
            <form action="/Articles/934988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 21:22 UTC (Sat)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/935013/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no hostility.<br>
It's just that the advantages of using C++ are not seen by kernel developers as being significant enough to justify the downsides of having C++. (e.g. much longer build time).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 22:29 UTC (Sat)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/935014/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <q>There is no hostility.</q><br>
<br>
Expressions like <a href="https://harmful.cat-v.org/software/c++/linus"><q>C++ is a horrible language</q> or <q>the crap that is C++</q></a> or (more recent) <a href="https://itwire.com/business-it-news/open-source/rust-support-in-linux-may-be-possible-by-5-14-release-torvalds.html"><q>It really is a crap language</q></a> certainly sound like hostility.





      
          <div class="CommentReplyButton">
            <form action="/Articles/935014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2023 12:38 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/935039/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sentiments from WG21 (the C++ committee) members don't seem far removed from what you're describing here as "hostility". Their conclusions are different but the reported facts seem similar.<br>
<p>
The remaining C++ proponents continue to believe in a sort of Phlogiston Theory for programming languages. If they can just add the right things to C++ then it will not be an over-complicated language any more. It's true that in C++ 11, C++ 14, C++ 17, C++ 20 and C++ 23 the additions did make the language even more complicated each time, but surely this time it will work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor935034"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2023 6:01 UTC (Sun)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/935034/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; much longer build time</span><br>
<p>
Switching GCC from C to C++ mode alone has no effect on the build time. There are C++ features that do add to the build time, like excessive use of templates, but so do C features like excessive use of macros. It depends on which C++ subset you allow.<br>
<p>
I bet there's no build-time difference between Peter's pseudo-RAII using macros and the GNU extensions and "true" C++ RAII (using no other C++ feature).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935034/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor935023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2023 23:11 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/935023/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; There has been a few patch sets posted to allow C++ usage in the Linux kernel</span><br>
<p>
It used to be possible to compile Linux with C++ enabled, back in the early 2.6 days. I remember because I worked with a hardware device that had a C++ kernel module.<br>
<p>
Then the kernel started using "class" and "operator" as regular variables.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor935743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 8:28 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/935743/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; On the other hand, allowing a C++ (subset) would make all desirable C++ features...</span><br>
<p>
This is the main issue: define "subset" and "desirable".<br>
Everyone will have different answers (and C++ has everyone's favorite features). <br>
<p>
Another top problem is: "C++ is not hard, your developers are just holding it wrong". I've called this the "mythical workplace" argument.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 9:24 UTC (Thu)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/935745/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; This is the main issue: define "subset" and "desirable". Everyone will have different answers (and C++ has everyone's favorite features). </span><br>
<p>
If that's your main issue, then luckily it's a non-issue.<br>
<p>
The premise of the article is that the kernel developers have already decided they want (something like) RAII, and my point is that for this feature, C++ is a better tool than C with non-standard extensions.<br>
<p>
Discussions which C++ features are allowed in the kernel is no different than any other coding style discussion. There are already discussions on which C standard shall be used and which new C standard features are acceptable in the kernel (like atomics). Nothing new here, just more of the usual.<br>
<p>
<span class="QuotedText">&gt; Another top problem is: "C++ is not hard, your developers are just holding it wrong".</span><br>
<p>
That's a straw man. Let's discuss the language rather than discussing theoretical arguments from hypothetical C++ fanboys, because that's not relevant for the language choice.<br>
<p>
About C++: I know very well that C++ is hard, and I admit it's a complex mess of a language. Many reasonable things can be said about the ugliness of C++.<br>
<p>
If you're starting with C, and you want to use certain advanced features like RAII, C++ is a good choice, because the migration is so simple. It is certainly reasonable to say Rust is better than C++, and I don't argue C++ should be used *instead* of Rust - I only say C++ could easily be used *now* to improve code quality where a Rust migration is not possible currently. Additionally, a future rewrite to Rust is easier from C++ with RAII than from plain C, because the source code flow in C++ and Rust is similar. C++ is actually a good intermediate language for a smoother migration to Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 10:32 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/935759/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;because the source code flow in C++ and Rust is similar.</span><br>
<p>
No, not at all.<br>
Rust has no inheritance. Code flows between ideomatic C++ and ideomatic Rust are quite different.<br>
<p>
It does not work to say that we're going to switch to C++ but only use RAII from it.<br>
People *will* start using more and more of C++'s features.<br>
<p>
It's better to keep that huge amount of stuff out of the kernel to begin with.<br>
The C implementation might not be as pretty as C++, but pulling in C++ comes with a tremendous cost of arguing over and over again why this and that C++ feature shall not be used in the kernel.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 18:38 UTC (Thu)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/935898/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; No, not at all. Rust has no inheritance. Code flows between ideomatic C++ and ideomatic Rust are quite different.</span><br>
<p>
You're missing the point. The article and this thread is about using RAII in the Linux kernel, not about inheritance. RAII works the same in C++ and Rust (and in C with GNU extensions, as it's going to be used soon).<br>
<p>
The fact that C++ has features that Rust has not (which I didn't suggest to use and which do not affect the code flow) does not falsify my argument - it doesn't even have anything to do with this thread.<br>
<p>
<span class="QuotedText">&gt; It does not work to say that we're going to switch to C++ but only use RAII from it.</span><br>
<p>
It works with other C language features or Rust language features or coding style policies or anything else. What makes you think policies about acceptable C++ features are different? Just because of "arguing over and over again"? Why is arguing over C++ features different? Bikeshedding discussions have existed as long as Linux exists, and will always exist. This argument seems rather arbitrary, because you can use the same argument to reject C11, C17, Rust (or anything else).<br>
<p>
<span class="QuotedText">&gt; The C implementation might not be as pretty as C++</span><br>
<p>
Agree. We don't agree on the rest, but that's fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 18:55 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/935901/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;You're missing the point.</span><br>
<p>
No. But you didn't read my full text, before answering on the first paragraph.<br>
<p>
<span class="QuotedText">&gt;What makes you think policies about acceptable C++ features are different?</span><br>
<p>
So you really think that inheritance and virtual functions would not be one of the first next C++ features that people would demand, if we would compile the kernel with a C++ compiler?<br>
<p>
Converting all manual implementations of virtual function calls is the next obvious transistion we would have.<br>
And there goes your same code flow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 19:07 UTC (Thu)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/935904/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; No. But you didn't read my full text, before answering on the first paragraph.</span><br>
<p>
Oh yes, you were missing the point, because instead of replying to the point I made (about RAII), you made up a new story and replied to this story of yours.<br>
<p>
Now you came up with a new story, this time about virtual functions, only to prove that code flow in C++ and Rust is different after all, but that again misses my point. Don't you get it? This article and this thread is about RAII and nothing else.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935906"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 19:19 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/935906/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;only to prove that code flow in C++ and Rust is different after all</span><br>
<p>
Nice that you agree.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935906/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 19:35 UTC (Thu)
                               by <b>make</b> (guest, #62794)
                              [<a href="/Articles/935908/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Nice that you agree.</span><br>
<p>
No, I don't agree. Virtual functions don't affect the code flow; they are just syntactic sugar for dynamic dispatch, but the code flow is the same as with other ways of doing dynamic dispatch (no matter if C++, C or Rust). But, uh, we're now even more off-topic, you're dragging me away from the topic (=RAII) so much, that I'm confident you're just a troll, and I've already been feeding you too much, shame on me. That was unexpected on LWN.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 19:41 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/935912/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;but the code flow is the same as with other ways of doing dynamic dispatch (no matter if C++, C or Rust).</span><br>
<p>
No it isn't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor935922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 20:51 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/935922/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; So you really think that inheritance and virtual functions would not be one of the first next C++ features that people would demand, if we would compile the kernel with a C++ compiler?</span><br>
<p>
Of course it would; implementing classes in C is not fun at all and it's done all over the kernel already: <a href="https://lwn.net/Articles/444910/">https://lwn.net/Articles/444910/</a><br>
<p>
BTW I suspect this is another reason people want to keep C++ out: Object-Oriented Obfuscation. There are some problems to which object-orientation maps well but C++ went really "all-in" and kept functional programming techniques out of developers' mindsets for much too long of a time, holding back the entire industry for decades.<br>
<p>
Funny how Javascript out of all languages helped functional programming finally break out.<br>
<p>
Rust is of course more functional than OO.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 21:02 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/935923/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; There are some problems to which object-orientation maps well but C++ went really "all-in" and kept functional programming techniques out of developers' mindsets for much too long of a time, holding back the entire industry for decades.</span><br>
<p>
Forgot the mandatory reference to the masterpiece, sorry for the extra email:<br>
<p>
http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html<br>
<p>
Yes this one is not about C++ but Java which is even worse. But: close enough.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor935920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 20:42 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/935920/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If that's your main issue, </span><br>
<p>
Not "mine"; the issue of everyone who does not want C++<br>
<p>
<span class="QuotedText">&gt; then luckily it's a non-issue.</span><br>
<p>
Must feel good to be right when so many people are wrong :-)<br>
<p>
<span class="QuotedText">&gt; my point is that for this feature, C++ is a better tool than C with non-standard extensions.</span><br>
<p>
Yes! But: see above.<br>
<p>
<span class="QuotedText">&gt; Discussions which C++ features are allowed in the kernel is no different than any other coding style discussion.</span><br>
<p>
Qualitatively yes. Quantitatively no. I know: I don't have any metrics to show you; these things are very hard to measure. But you don't have any either and the consensus / educated guess in Linux (and some other projects) is that the trade-off is not worth it. That is of course based on observations in other, actual C++ projects, I mean  the lack of metrics does not mean it's based on thin air either.<br>
<p>
BTW: which features are allowed is IMHO a small part of code style discussions. A very important part of course, maybe the most important one but small in "email volume". I'm just saying "code style" is not a great choice of words here, never mind.<br>
<p>
<span class="QuotedText">&gt; That's a straw man. Let's discuss the language rather than discussing theoretical arguments from hypothetical C++ fanboys</span><br>
<p>
Oh come on: "you're holding it wrong" is the typical answer of _every_, _real_ C++ fanboy! Very vocal and hopefully not representative as usual on  the Internet but certainly not "hypothetical".<br>
<p>
<span class="QuotedText">&gt;  I know very well that C++ is hard, and I admit it's a complex mess of a language.</span><br>
<p>
Thank you!<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor934971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 22:16 UTC (Fri)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/934971/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, and by the reasoning of the comment you're replying to, they'd be landing a much worse alternative much faster.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 14:26 UTC (Fri)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/934914/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <q>More macro hell to emulate C++ badly using multiple non-standard GNU extensions.</q>
<br>
The <code>defer</code> feature proposed for a future C standard will allow implementing these automatic cleanups without having to use non-standard compiler extensions.<br>
<br>
With new features like that one or (even more so) lambdas it looks like modern C is getting closer and closer to being "C++ without classes".<br>
<br>
I guess the reason for this is to avoid the stigma that <a href="https://medium.com/nerd-for-tech/linus-torvalds-c-is-really-a-terrible-language-2248b839bee3">some people</a> associate with the "C++" name.<br>
<br>
Otherwise, there are few reasons not to just use the desired C++ subset - especially that it is already there, well tested and supported by compilers.





      
          <div class="CommentReplyButton">
            <form action="/Articles/934914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2023 13:38 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/935046/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This "subset" is a trick. It's a good conjuring trick, but it isn't real. You are actually obliged to have the whole C++ language, you can choose not to use all of it, but it's all still there anyway dragging you down. It reminds me of the excuse used for C++ move like fifteen years ago when it was just an idea not a language feature yet.<br>
<p>
See, C++ move is just strictly worse than Rust's "destructive" move which was already a known idea. But you can construct an argument where the C++ move looks more fundamental, you say well this "destructive move" is move + destroy, if we wanted that in C++ we just do move and then destroy, so that's better 'cos we had the choice. Except, it turns out that's not actually how it works. Move is destructive by its nature on real computers, so in C++ you must have code to construct a dummy value so as to achieve the non-destructive move, whereupon of course if you did want it destroyed you also then need to destroy your dummy value.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor934877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 11:16 UTC (Fri)
                               by <b>karim</b> (subscriber, #114)
                              [<a href="/Articles/934877/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting foray into pseudo-C++ and garbage collection within the Linux kernel. I, for one, welcome our new __cleanup__ overlords ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor935728"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 5:39 UTC (Thu)
                               by <b>irogers</b> (subscriber, #121692)
                              [<a href="/Articles/935728/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I like scope-based resource management but this is only solving a problem with local variables within the scope of functions. Full RAII would allow destructors to run say when a variable in the heap was overwritten by NULL. We can't have a factory returning memory with a cleanup on the return type, and the caller must be aware to do this.<br>
<p>
I worry about the cleanup attribute. Weak is another attribute, outside of the C spec, that is widely used. However, in contexts like the perf tool, it breaks (legitimately) gcc's LTO. The perf tool has had bugs with weak and const on global variables allowing optimizations that break code. The bugs with weak have always been subtle and I can imagine that cleanup's bugs will be similar. Moving to the cleanup approach means that if a bug in the compiler does occur the changes may need to be reverted or only the latest compilers can build the kernel, neither option sounds appealing.<br>
<p>
Fwiw, a similar macro magic hack that is related is the reference count checking work in the perf tool. The approach allocates memory on a get, the contents of the memory pointing to the original object, and on a put it releases the memory. A get without a put is a memory leak. A use after put is a use-after-free/fault. Leak sanitizer will identify all places where the gets with no puts occur with their stack traces. Unlike cleanup it works for any kind of variable but it is invasive, requires effort by the user and leans heavily on leak sanitizer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935728/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor935735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Scope-based resource management for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2023 6:28 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/935735/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;if a bug in the compiler</span><br>
<p>
Is there any sign that such a bug ever existed w.r.t. cleanup routines?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/935735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
