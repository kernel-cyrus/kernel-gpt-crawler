        <!DOCTYPE html>
        <html lang="en">
        <head><title>Fast commits for ext4 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/842385/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/842693/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/842385/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Fast commits for ext4</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="GAByline">
           <p>January 15, 2021</p>
           <p>This article was contributed by Marta Rybczyńska</p>
           </div>
<p>The Linux 5.10 release included a <a
href="/ml/linux-ext4/20201015203802.3597742-1-harshadshirwadkar@gmail.com/">change</a>
that is expected to significantly increase the performance of the ext4
filesystem; it goes by the name "fast commits" and introduces a new,
lighter-weight journaling method. Let us look into how the feature works, who
can benefit from it, and when its use may be appropriate.</p>

<p>Ext4 is a <a
href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling  
filesystem</a>, designed to ensure that filesystem structures appear
consistent on disk at all times. A single filesystem operation (from
the user's point of view) may 
require multiple changes in the filesystem, which will only be coherent
after all of those changes are present on the disk. If a power
failure or a system crash happens in the middle of those operations,
corruption of the data and filesystem structure (including unrelated
files) is possible.  Journaling prevents corruption by maintaining a log
of transactions in a separate journal on disk. In case of a power
failure, the recovery procedure 
can replay the journal and restore the filesystem to a
consistent state.</p>

<p>The ext4 journal includes the metadata changes associated with an
operation, but not necessarily the related data changes.  Mount
options can be used to select one of three journaling modes, as
described in the <a
href="https://www.kernel.org/doc/html/latest/admin-guide/ext4.html">ext4 kernel
documentation</a>. <tt>data=ordered</tt>, the default, causes ext4 to write all
data <i>before</i> committing the associated metadata to the journal. It <a
href="/Articles/322823/">does not put the data itself into the journal</a>. 
The <tt>data=journal</tt> option, instead, causes all data to be written
to the journal before it is put into the main filesystem; as a side effect, it
disables delayed allocation and direct-I/O support. Finally,
<tt>data=writeback</tt> relaxes the constraints, allowing data to be written to
the filesystem after the metadata has been committed to the
journal.</p>

<p>Another important ext4 feature is delayed allocation, where the
filesystem defers the allocation of blocks on disk for data written by
applications until that data is actually written to disk.
The idea is to wait until
the application finishes its operations on the file, then allocate the
actual number of data blocks needed on the disk at once. This
optimization limits unneeded operations related to short-lived, small
files, batches large writes, and helps ensure that data space is
allocated contiguously.  On the other hand, the writing of data
to disk might be delayed (with the default settings) by a minute or so.
In the default
<tt>data=ordered</tt> mode, where the journal entry is written only after
flushing all pending data, delayed allocation might thus
add more delay between the actual change and writing of the journal. To
assure data is actually written to disk,
applications use the <a
href="https://man7.org/linux/man-pages/man2/fsync.2.html"><tt>fsync()</tt>
or <tt>fdatasync()</tt></a> system calls, causing the data (and the
journal) to be written immediately.

<h4>Ext4 journal optimization</h4>

<p>One might assume that, in such a situation, there are a number of
optimizations that could be made in the commit path; that
assumption turns out to be correct. In <a
href="https://www.usenix.org/system/files/conference/atc17/atc17-park.pdf">this
USENIX'17 paper [PDF]</a>, Daejun Park and Dongkun Shin showed that the
current ext4 journaling scheme can introduce significant
latencies because <tt>fsync()</tt> causes a lot of unrelated
I/O. They proposed a faster scheme, taking into account the fact that
some of the metadata written to the journal could instead be derived
from changes to the inode being written, and it is possible to
commit transactions related to the requested file descriptor only. Their
optimization works in the <tt>data=ordered</tt> mode.</p>

<p>The fast-commit changes, implemented by Harshad Shirwadkar, are
based on the work of Park and Shin. This work implements an
additional journal for fast commits, but simplifies the commit
path. There are now two journals in the filesystem: the fast-commit
journal for operations that can be optimized, and the regular journal for
"standard commits" whose handling is unchanged.
The fast-commit journal contains operations executed since the last
standard commit.</p>

<p>Ext4 uses a generic journaling layer called "Journaling Block
Device&nbsp;2" (JBD2), with the exact on-disk format documented in the <a
href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Journal">ext4  
wiki</a>. JBD2 operates on blocks, so when it commits a transaction,
this transaction includes all changed blocks. One
logical change may affect multiple blocks, for example the inode
table and the block bitmap.</p>

<p>The fast-commit journal, on the other hand, contains changes at
the file level, resulting in a more compact format.  Information
that can be recreated is left out, as described in the patch posting:
<p>
<div class="BigQuote">
	For example, if a new extent is added to an inode, then
	corresponding updates to the inode table, the block bitmap, the
	group descriptor and the superblock can be derived based on just
	the extent information and the corresponding inode information.
</div>
<p>
During recovery
from this journal, the filesystem must recalculate all
changed blocks from the inode changes, and modify all affected data
structures on the disk. This requires specific code paths for each
file operation, and not all of them are implemented right now. The
fast-commits feature currently supports unlinking and linking a
directory entry, creating an inode and a directory entry, adding blocks
to and removing blocks from an inode, and recording an inode that
should be replayed.</p>

<p>Fast commits are an addition to — not a replacement of — the standard
commit path; the two work together. If fast commits cannot handle an
operation, the filesystem falls back to the standard commit
path. This happens, for example, for changes to extended
attributes. During recovery, JBD2 first performs replay of the
standard transactions, then lets the filesystem recover fast
commits.</p>

<h4><tt>fsync()</tt> side effects</h4>

<p>The fast-commit optimization is designed to work with applications using
<tt>fsync()</tt> frequently to ensure data integrity. When we look
at the <tt>fsync()</tt> and <tt>fdatasync()</tt> man pages, we see that those
system calls only guarantee to write data linked to the given file
descriptor. With ext4, as a side effect of the filesystem structure, all
pending data and metadata for <i>all</i> file descriptors will be flushed
instead.  This creates a lot of I/O traffic that is unneeded to satisfy any
given <tt>fsync()</tt> or <tt>fdatasync()</tt> call.

</p>

<p>This side effect leads to a difference between the paper and the
implementation: a fast commit may still include changes affecting
other files. In a review, Jan Kara <a
href="/ml/linux-ext4/20201023103013.GF25702@quack2.suse.cz/">asked</a> why
unrelated changes are committed. Shirwadkar <a
href="/ml/linux-ext4/CAD+ocbws2J0boxfNA+gahWwTAqm8-Pef9_WkcwwKFjpiJhvJKw@mail.gmail.com/">replied</a>
that, in an earlier version of the patch, he did indeed write only the file
in question. However, this change broke some existing tests that
depend on <tt>fsync()</tt> working as a global barrier, so he backed it out.
<p>
Ted Ts'o <a
href="/ml/linux-ext4/20201027184507.GD5691@mit.edu/">commented</a> that the
current version of the patch set keeps the existing behavior, but he
can see workloads where "<q>not requiring entanglement of unrelated file
writes via fsync(2) could be a huge performance win.</q>" He added that a
future solution could be a new system call taking
an array of file descriptors to synchronize together. For now, application
developers should base their code on the POSIX definition, and not rely
on that specific <tt>fsync()</tt> side effect, as it might change in the
future.</p>

<h4>Using fast commits</h4>

<p>Fast commits are activated at filesystem creation time, so users
will have to recreate their filesystems to use this feature. In
addition, the required <a
href="https://github.com/harshadjs/e2fsprogs/tree/fast-commit-v2">support
in <tt>e2fsprogs</tt></a> has not yet been added to the <a
href="https://git.kernel.org/pub/scm/fs/ext2/e2fsprogs.git">main
branch</a>, but is still in development. So interested users
will need to compile the tool on their own, or wait until the feature is
supported by their distribution. When enabled, information on fast
commits shows up in a new <tt>/proc/fs/ext4/<i>dev</i>/fc_info</tt>
file.</p>

<p>On the development side, there are numerous features to be added to
fast commits. These include making the operations more fine-grained
and supporting more cases that fall back to standard commits today.
Shirwadkar <a href="https://github.com/harshadjs/linux/tree/fc-pmem-renewed">is
also working</a> on fast commits with byte-granularity (instead of
the current block-granularity) support for direct-access (<a
href="https://www.kernel.org/doc/Documentation/filesystems/dax.txt">DAX</a>)  
mode, to be used on <a
href="https://en.wikipedia.org/wiki/Persistent_memory">persistent  
memory</a> devices.</p>

<p>The benchmark results given by Shirwadkar in the posted patch set show
20-200% performance improvements with filesystem benchmarks for
local filesystems, and 30-75% improvement for NFS workloads. We can
assume that the performance gain will be more important in applications
doing many <tt>fsync()</tt> operations than in those doing only a few.
Either way, though, the fast-commits feature should lead to better ext4
filesystem performance going forward.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-ext4">Filesystems/ext4</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Rybczynska_Marta">Rybczynska, Marta</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/842385/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor842838"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2021 18:49 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842838/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have some thoughts about this:<br>
<p>
1. As usual, Ted&#x27;s reasoning seems eminently sensible to me. Apps that really want to sync the whole filesystem should *already* be using syncfs(2).<br>
2. Still, I could imagine some apps not knowing about the &quot;and also you have to fsync the directory&quot; rule (see fsync(2)), which is currently not really enforced since fsync in practice flushes &quot;everything.&quot; It might be worth special-casing that, or providing a flag. But hard links make this trickier (which directory do you want to fsync?).<br>
3. It would be really nice if rename(2) would function as a write barrier, or at least not be reordered before any writes to the file that is renamed, but I&#x27;m not sure where current filesystems stand on that... I know this has definitely been discussed in the past, though (see for example this article: <a href="https://lwn.net/Articles/351422/">https://lwn.net/Articles/351422/</a>).<br>
4. Maybe if this gets performant enough, we can rename O_DSYNC to O_PONIES.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842838/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842879"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 7:46 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/842879/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Hyrum's Law says that what Ted says is kind of irrelevant. If implementation provided full sync instead of what the documentation says then it should continue to do so.</p>
<p>You may provide <b>optional</b> support for something else and then, over course of <b>many years</b> test more and more apps with it. Maybe, just <b>maybe</b> it may become a new default, eventually. But that's not guaranteed…</p>
<p>Doing anything else is just asking for trouble, unfortunately.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/842879/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842906"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 19:39 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842906/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am generally in favor of Hyrum&#x27;s law, but I do have my limits, and one of those limits is &quot;Was anyone even relying on that in the first place?&quot;<br>
<p>
See for example the line in <a href="https://www.freebsd.org/cgi/man.cgi?query=fcntl&amp;sektion=2">https://www.freebsd.org/cgi/man.cgi?query=fcntl&amp;sekti...</a> about the &quot;completely stupid semantics of System V&quot; (yes, they really put that in a man page). IIRC someone looked into it, and:<br>
<p>
1. It had been standardized that way because that&#x27;s what one particular implementation decided to do. There was never a proper rationale or anything.<br>
2. Nobody could find any apps which actually rely on this behavior.<br>
3. They were able to find at least one app which *accidentally* triggers this behavior and gets buggy file locking as a result.<br>
<p>
If this wasn&#x27;t already standardized in POSIX, I would be heavily in favor of Linux etc. just changing the behavior to something more sensible. Unfortunately, it&#x27;s probably a Bad Idea to deliberately violate POSIX, even when POSIX is obviously silly, so we&#x27;re likely stuck with it. But it would&#x27;ve been nice if someone would have caught this earlier, and I think that Hyrum&#x27;s Law would not have been helpful in that situation.<br>
<p>
Moving on to the actual topic of discussion here. Applications, in general, don&#x27;t use fsync much at all. Many of them do the open/write/rename ritual, which technically requires an fsync (after the write and before the rename) to guarantee a safe ordering, but I don&#x27;t think many people bother with that.  I am of the opinion that Hyrum&#x27;s Law ought to require the rename to function as a barrier in this case, as I wrote in my initial comment. I don&#x27;t think many apps are using an fsync of /path/to/foo.txt in order to guarantee durability of /path/to/bar.txt, but we would need to do a survey to be sure. If I&#x27;m right about that, then I don&#x27;t think we need to apply Hyrum&#x27;s Law here as (a) few apps would be broken in practice, (b) there&#x27;s already an interface (syncfs) to do what those apps want (so it&#x27;d be easy to fix), and (c) the performance wins for all of the apps which use fsync correctly could potentially be quite large. Also (d) we don&#x27;t want to penalize apps written for other Unices for using the standard interface, so introducing a Linux-only &quot;no really, just fsync this one file&quot; syscall is a Bad Idea.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842906/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor843084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 19:24 UTC (Mon)
                               by <b>tytso</b> (subscriber, #9993)
                              [<a href="/Articles/843084/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So for decades, competently written text editors write new precious files, such as source files via:<br>
<p>
1)  Write the new contents of foo.c to foo.c.new<br>
2)  Fsync foo.c.new --- check the error return from the fsync(2) as well as the close(2)<br>
3)  Delete foo.c.bak<br>
4)  Create a hard link from foo.c to foo.c.bak<br>
5) Rename foo.c.new on top of foo.c<br>
<p>
This doesn&#x27;t require an fsync of the directory, but it guarantees that /path/to/foo.c will either have the original contents of foo.c., or the new contents of foo.c, even if there is a crash any time during the above process.   If you want portability to other Posix operating systems, including people running, say, retro versions of BSD 4.3, this is what you should do.  It&#x27;s what emacs and vi does, and some of the &quot;ritual&quot;, such as making sure you check the error return from close(2), is because other wise you might lose data if you run into a quota overrun on the Andrew File System (the distributed file system developed at CMU, and used at MIT Project Athena, as well as several National Labs and financial institutions).<br>
<p>
That being said, rename is not a write barrier, but as part of the O_PONIES discussion, on a close(2) of an open which was opened with O_TRUNC, or on a rename(2) where the destination file is getting overwritten, the file being closed, or the source file of the rename will have an immediate write-out initiated.  It&#x27;s not going to block the rename(2) operation from returning, but it narrows the race window from 30 seconds to however long it takes to accomplish the writeout, which is typically less than a second.    It&#x27;s also something that was implemented informally by all of the major file systems at the time of the O_PONIES controversy, but it doesn&#x27;t necessarily account for what newer file systems (for example, like bcachefs and f2fs) might decide to do, and of course, this is not applicable for what other operating systems such as MacOS might be doing.<br>
<p>
The compromise is something that was designed to minimize performance impact, since users and applications also depend upon --- and get cranky --- when there are performance regressions, while still papering over most of the problems caused by careless application.  From file system developers&#x27; perspective, the ultimate responsibility is on application writers if they think a particular file write is precious and must lost be lost after a system or application crash.  After all, if the application is doing something really stupid, such as overwriting a precious file by using open(2) with O_TRUNC, because it&#x27;s too much of a pain to copy over ACL&#x27;s and extended attributes, so it&#x27;s simpler to just use O_TRUNC and overwrite the data file and crossing your fingers.   There is absolutely no way the file system can protect against application writer stupidity, but we can try to minimize the risk of damage, while not penalizing the performance of applications which are doing the right thing, and are writing, say, a scratch file.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor843100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2021 8:15 UTC (Tue)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/843100/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What does the system call do in other filesystems?<br>
<p>
If it&#x27;s an ext4 quirk then any software relying on that would already break just by virtue of moving to a different filesystem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor843198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2021 7:48 UTC (Wed)
                               by <b>viiru</b> (subscriber, #53129)
                              [<a href="/Articles/843198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What does the system call do in other filesystems?</font><br>
<p>
<font class="QuotedText">&gt; If it&#x27;s an ext4 quirk then any software relying on that would already break just by virtue of moving to a </font><br>
<font class="QuotedText">&gt; different filesystem.</font><br>
<p>
In my understanding that is exactly what it is. Ext3 shares the behavior, but for example XFS does not. This caught many application developers by surprise, but that happened a couple of decades ago and has most likely been fixed in any sensible application.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor842850"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2021 19:57 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842850/">Link</a>] (45 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All this talk about &quot;apps should use fsync&quot; or &quot;apps should use fsfsync&quot; fills me with horror, as someone who wants to write a system that relies on data integrity. Are you telling me that my app needs to be filesystem-aware, and not only that but aware of what mount options were used, so I know which commands to call to make sure that my data is safe?<br>
<p>
And no, I don&#x27;t want to offload that onto the glibc guys either.<br>
<p>
I know it&#x27;ll be hard, but is there any way we can get the VFS to dictate that certain things are supposed to happen in a certain order. As an app, I don&#x27;t care *how* the OS does it, but I want to be able to reason about what&#x27;s hit the disk and when. And I DON&#x27;T want to have to worry about what the filesystem is or how it does it.<br>
<p>
I&#x27;ve said it before, but I don&#x27;t care too much about fsync or fsfsync, and I really don&#x27;t want to have to worry about how the OS will react to those calls - one only has to go back to the ext3/ext4 transition/debacle where code that was fast on ext3 brought ext4 to its knees... if I can know for certain that stuff hits the disk in the order I write it, and tell the system what it can write in parallel and what it can&#x27;t ... (basically data can be written in parallel, logs can be written in parallel, just not in parallel with each other. And the OS needs me to tell it the difference between the two, it won&#x27;t know by itself.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842850/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842852"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2021 20:19 UTC (Fri)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/842852/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Carefully ordering writes was the idea behind &lt;a href=&quot;<a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix99/full_papers/mckusick/mckusick.pdf">https://www.usenix.org/legacy/publications/library/procee...</a>&quot;&gt;soft updates&lt;/a&gt; previously(?) used in the BSD FFS.  I believe it was replaced by a more traditional journaling approach because modern hardware is dependent on queuing for good performance, and all current hardware command queuing mechanisms are unordered.  On such hardware soft updates wasn&#x27;t able to keep up with journaling, which is better able to batch updates.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842852/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 0:13 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/842860/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You may be thinking of NetBSD, which replaced softupdates with journaling in FFS. Softupdates is still the only option on OpenBSD, but I&#x27;m more than contented on that front. AFAIU, FreeBSD also still supports softupdates, though the FreeBSD community seems to be migrating to ZFS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor844689"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2021 14:25 UTC (Mon)
                               by <b>drjohnnyfever</b> (guest, #144560)
                              [<a href="/Articles/844689/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The situation on FreeBSD is actually a bit complicated. The current default configuration uses journaled soft updates (su+j) which work like traditional soft updates with the exception that there is enough metadata journaled to avoid having to run a background fsck to reclaim space from orphaned allocations. <br>
<p>
FreeBSD also supports proper journaling (logging) with gjournal which works at the block layer rather than in UFS itself. If I recall correctly, gjournal keeps a proper intent log of disk writes rather than just a metadata journal. It also allows you to use a separate device for the log.<br>
<p>
ZFS does seem to be the way forward on FreeBSD but Netflix is pretty big consumer of UFS/FFS so they have been sponsoring continued development.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/844689/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor842866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2021 23:18 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/842866/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The way I remember it is that code which was fast on ext3 would lose all of its data on ext4. Or xfs. Or any filesystem other than ext3.<br>
<p>
It was fast because it took advantage of ext3 data=ordered mode which forced all of the data writes to commit before doing things like a file rename. But that code was _never correct_. It was simply lucky.<br>
<p>
From that whole disaster I think we all learned that making your filesystem provide ponies is dumb and stupid. Unless you brought ponies for every filesystem all you have accomplished is to create application developers who write applications that WILL lose data on any filesystem without ponies.<br>
<p>
POSIX applications that need data safely on disk need to use fsync() or they are not POSIX and they are broken.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842876"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 7:27 UTC (Sat)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/842876/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
fsync() is not ISO C; if I&#x27;m reading and understanding the man pages right, it wasn&#x27;t in POSIX pre-2001 nor in versions of Unix prior to BSD 4.3. So standard C and old-school Unix had no support for applications that needed data safely on disk?<br>
<p>
Linux filesystems still provide all sorts of ponies. POSIX filenames are way more limited than XFS, ext3 or ext4 provide, and it does bite people when interfacing with other OSes, including other Unixes. It&#x27;s frustrating to call data safety a pony instead of admitting that they were trading data safety for speed, and that other people could validly disagree with your tradeoffs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842876/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 17:08 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842896/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; fsync() is not ISO C; if I&#x27;m reading and understanding the man pages right, it wasn&#x27;t in POSIX pre-2001 nor in versions of Unix prior to BSD 4.3. So standard C and old-school Unix had no support for applications that needed data safely on disk?</font><br>
<p>
I think old-school Unix ran on disks that wrote data in the order it was passed down to it. And old-school Unix just wrote stuff to disk without buffering and re-ordering and all that stuff.<br>
<p>
And what application developers need is the ability to tell new-school Unix that SOMETIMES, the old way is best!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor842905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 19:15 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842905/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Under old-school Unix, if power dropped at the wrong moment, you could lose the whole filesystem. In practice, you would often be able to recover some or most of it with fsck (or an fsck-like process), but there was never any guarantee that a system crash was a recoverable event. As a result, it has always been the case that &quot;If you don&#x27;t call fsync, then you might lose data.&quot; It&#x27;s just that this used to be vacuously true (you couldn&#x27;t call fsync, because it didn&#x27;t exist).<br>
<p>
On the other hand, an orderly shutdown has never lost data on any  (reasonable, properly-engineered)Unix (that I&#x27;m aware of), whether you fsync or not. This is still true today.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 8:16 UTC (Sun)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/842922/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux can&#x27;t save you if the computer fails due to any number of physical problems. It has always been the case that &quot;you might lose data&quot;. The change is that older Unixes don&#x27;t require you to do anything special to achieve maximal data safety offered, whereas modern systems require you to do something special for the OS to try its best. Arguably (as Wol does), going from ordered behavior to complex reordering is a downgrade in the promised level of support.<br>
<p>
Taking code that didn&#x27;t require fsync (because it doesn&#x27;t exist) and, in the words of zlynx, saying that &quot;it&#x27;s broken&quot; makes all ISO C code that needs data safety broken, which seems extreme. From my perspective, filesystem developers got the ability to increase safety by default or speed by default, and chose speed. That doesn&#x27;t really upset me, so much as the fact that the word &quot;pony&quot; gets pulled out and one side gets painted as unreasonable, instead of it getting painted as a tradeoff and argued on that basis.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 9:33 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842926/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
1. Modern filesystems are much safer than old filesystems, by default. When was the last time you had to run fsck on boot?<br>
2. I did not claim that old code was &quot;broken,&quot; merely that it was at risk of losing data. My point is that both the application developer and the sysadmin would have been aware of that problem, and would take appropriate steps to remediate it (such as making regular backups, building a RAID, or whatever else makes sense). Everyone should still be taking those steps today, because as you say, nothing is 100% reliable.<br>
3. Safety and speed are a tradeoff. But since we can&#x27;t get to 100% safety, the primary value of safety is extrinsic: a safer system causes us to spend less time and resources on recovery (e.g. sitting around waiting for fsck to complete so I can boot my machine). So safety is itself a form of speed, and we can directly compare the time spent on recovery to the time spent on disk I/O - and as it turns out, once you make fsck obsolete, the disk I/O is a lot bigger for most people under most circumstances.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 17:25 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842931/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 2. I did not claim that old code was &quot;broken,&quot; merely that it was at risk of losing data. My point is that both the application developer and the sysadmin would have been aware of that problem, and would take appropriate steps to remediate it (such as making regular backups, building a RAID, or whatever else makes sense). Everyone should still be taking those steps today, because as you say, nothing is 100% reliable.</font><br>
<p>
RAID is useless if it can&#x27;t guarantee that stuff has been safely saved to disk ... which it can&#x27;t if the linux layers provide no guarantees ...<br>
<p>
Backups are pretty much useless BY DEFINITION, because if the data is corrupted while saving to disk (which is what we&#x27;re discussing here), then it&#x27;s not been around long enough to be saved to backup.<br>
<p>
Come on, all I&#x27;m asking for is the ABILITY TO REASON about what is happening, so I can provide my own guarantees. &quot;The system may or may not have saved this data in the event of a crash&quot; is merely the filesystem guys saying &quot;not our problem&quot;, and the references to the SQLite guys jumping through hoops to make certain is the perfect example of them having to do somebody else&#x27;s job, because surely it&#x27;s the filesystem&#x27;s guys&#x27; job to make sure that data entrusted to the filesystem is actually safely saved by the filesystem.<br>
<p>
If I can have some guarantee that &quot;this data is saved before that data starts to be written&quot;, then at least I can reason about it.<br>
<p>
And yes, I know making all filesystems provide these sort of guarantees may be fun - I&#x27;m on the raid mailing list - I know - because I read all the messages and glance at all the patches and all that stuff (and don&#x27;t understand much of it :-) - but when (I know, I know) I find the time to start really digging in to it, I want the raid layer to provide exactly those guarantees.<br>
<p>
And why can&#x27;t we say &quot;these are the guarantees we *intend* to provide&quot;, and make it a requirement that anything new *does* provide them! If I provide a &quot;flush&quot; in the raid code, I can then pass it on to the next layer down, and then when it says it&#x27;s done it I can then pass success back up (or E_NOTSUPPORTED if I can&#x27;t pass it down). But this is exactly another of those *new* things they&#x27;re trying to get into the linux block layer, isn&#x27;t it - the ability to pass error codes back to the caller other than the most basic of &quot;succeeded&quot; or &quot;failed&quot;, isn&#x27;t it? If they can get that in, surely they can get my &quot;flush&quot; in, can&#x27;t they?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor843076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 17:47 UTC (Mon)
                               by <b>hkario</b> (subscriber, #94864)
                              [<a href="/Articles/843076/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
precisely, the issue is not that hardware can fail and that the file system can&#x27;t promise anything in such case, the problem is that there is no specification common _to all file systems_ that says what is expected to happen under such and such scenarios<br>
<p>
or to put it other way round: every file system will exhibit different behaviour on power failure and every file system requires slightly different handling to get something you can reasonably expect (like, when the file system says it committed data to disk, the data is committed to disk)<br>
<p>
that&#x27;s no way to program stuff when dealing with such fundamental thing in computing as data storage<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor842933"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 17:28 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842933/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Taking code that didn&#x27;t require fsync (because it didn&#x27;t (sic) exist) and, in the words of zlynx, saying that &quot;it&#x27;s broken&quot; makes all ISO C code that needs data safety broken, which seems extreme.</font><br>
<p>
Actually, I think that&#x27;s called a regression, is it not? And one of Linus&#x27; absolute rules is &quot;no regressions&quot;, isn&#x27;t it?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842933/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 20:31 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/842936/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; Taking code that didn&#x27;t require fsync (because it didn&#x27;t (sic) exist) and, in the words of zlynx, saying that &quot;it&#x27;s broken&quot; makes all ISO C code that needs data safety broken, which seems extreme.</font><br>
<font class="QuotedText">&gt;Actually, I think that&#x27;s called a regression, is it not? And one of Linus&#x27; absolute rules is &quot;no regressions&quot;, isn&#x27;t it?</font><br>
There is no regression. The code works as good as back in the days. Back in the days it was clear, that the data is only safe is the system is working properly, including no power outages. If you make sure that your system never crashes, the old code will work fine. If the system crashes, the old code might loose data, but this was always the case with this code. If you want additional guarantees (like no data loss in case of power loss), you have to use fsync. <br>
<p>
Best,<br>
Matthias<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 21:23 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842939/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
mmmm<br>
<p>
The risk of a corrupted filesystem hasn&#x27;t changed.<br>
<p>
But if the application writes a journal before doing an update, then provided there&#x27;s no collateral damage it can recover from a crash mid transaction on an old unix system.<br>
<p>
On a new system, it can&#x27;t be sure whether the transaction log is okay and the update is damaged, or the transaction log is damaged and the transaction is lost, or even worse the transaction log is damaged and the transaction is partially complete!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 10:29 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/842953/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>No, because even on ancient systems, you had elevator reordering for performance, and no guarantees about metadata writes; in the event of a crash, you simply did not know the state of the update or the transaction log, as even if you wrote them in a careful order, the elevator could reorder writes to disk, and the metadata writes might be reordered, too.
<p>In other words, as soon as there's a kernel panic or a power failure, all bets are off on an old UNIX system. This wasn't an issue with reliable systems, but as reliability went down (no dedicated power supplies, no UPSes etc), it became an issue again.
      
          <div class="CommentReplyButton">
            <form action="/Articles/842953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor842869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2021 23:46 UTC (Fri)
                               by <b>MrWim</b> (subscriber, #47432)
                              [<a href="/Articles/842869/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the lesson is use sqlite, unless you&#x27;ve got a very good reason not to. They do care about persistence, compatibility and performance, and they&#x27;ve done (and will continue to do) all the hard work to make it work correctly, easily and predictably.<br>
<p>
If you try and build on plain POSIX APIs you run the risk of filesystem developers changing the behaviour that you built and tested against out from under you, complete with a bunch of grey beards on the internet telling you that you&#x27;ve been doing it wrong all along..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 17:32 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842897/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think the lesson is use sqlite, unless you&#x27;ve got a very good reason not to.</font><br>
<p>
Like wanting to edit existing files that are in other formats? Like wanting a simple human-readable file that works with &quot;cat&quot; or &quot;less&quot; etc? Like me wanting to write a database back end!!!?<br>
<p>
There are myriad reasons for not wanting to off-load to sqlite. There are myriad reasons for not wanting to offload full stop. All I want is the ability to reason about what my program is doing, and that includes what it is doing when writing to disk.<br>
<p>
Oh - and I know bufferbloat kills networking speed, but haven&#x27;t they started finding the same problem in other places - INCLUDING the disk subsystem? Might it not be a performance improvement to have a drain() syscall that empties the buffers before accepting new input? And that would also provide exactly the semantics we need to reason about safely writing to disk?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor842880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 8:14 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/842880/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <p><i>Situation:</i> we have coarse-grained API which describes what can be done when and in what order.</p>

<p><i>Problem:</i> even this coarse-grained API (with the exact semantic as described in the documentation) is hard enough to implement in practice thus filesystem developers make shortcuts — and then apps start relying on these shortcuts.</p>

<p><i>Solution</i>: let's invent even <b>more</b> fine-grained, even <b>harder</b> to implement API — and then apps would be happy.</p>

<p>Is that about right?</p>

<p>I don't see how this can ever work. Applications have never used existing APIs correctly — because implementations allowed this. What makes you sure that would use your new, “better”, APIs correctly?</p>

<p>It would be the-same-as-before-only-worse.</p>

<p>Now, if we can implement in ext4 (ext5, xfs7, doesn't matter… any filesystem which is sufficiently popular for the developers to care) fine-grained enough handling of these hints supplied by your “better APIs” <b>completely</b> (as in: incorrect use would, actually, be <b>visible</b> to developers) then and <b>only</b> then pushing new APIs would make sense.</p>

<p>We are not yet even at stage where incorrect use fsync and co is visible to developers thus it's definitely too early to talk about more fine-grained API.</p>

<p>Or maybe, if with “fast transactions” we can ensure that misuse if that API would be <b>visible</b> to developers then it's time to introduce it and ask developers to test apps with it.</p>

<p>But please don't introduce API misuse of which developers couldn't easily detect. Fsync story is problematic enough as it is. Don't make it worse.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/842880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 9:52 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/842884/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Situation: we have coarse-grained API which describes what can be done when and in what order.</font><br>
<p>
I would not call POSIX API course-grained. It is a very low-level API that requires many syscalls and taking care about all the ordering issues with fsync.<br>
<p>
<font class="QuotedText">&gt; Problem: even this coarse-grained API (with the exact semantic as described in the documentation) is hard enough to implement in practice thus filesystem developers make shortcuts — and then apps start relying on these shortcuts.</font><br>
<p>
As far as I know, filesystem developers have managed quite well of implementing the exact semantics. However the semantics have much implementation specific behavior. Apps should not rely on this, but the problem is that they did and do.<br>
<p>
<font class="QuotedText">&gt; Solution: let&#x27;s invent even more fine-grained, even harder to implement API — and then apps would be happy.</font><br>
<p>
The new API should not be more fine-grained. It should be more high-level. Transactional semantics are much easier to deal with on the app level. You basically need two new syscalls: start_transaction() and commit_transaction(). The semantics would be far more intuitive than what we have now, where you need to remember not only to fsync your file, but also the directory you created your file in and to do it in the correct order.<br>
<p>
Of course this is harder to implement of the fs level, but it is easier to get right on the app level. And while there are thousands of apps, there are only a few filesystems. I see a clear benefit of moving complexity from the app level to the fs level. And you cannot get easy to implement APIs for both levels. Somewhere you need to hide the underlying complexity of the hardware (parallelism, NCQ, etc.).<br>
<p>
<font class="QuotedText">&gt; Is that about right?</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; I don&#x27;t see how this can ever work. Applications have never used existing APIs correctly — because implementations allowed this. What makes you sure that would use your new, “better”, APIs correctly?</font><br>
<p>
Because high-level APIs should be easier and more intuitive to use.<br>
<p>
<font class="QuotedText">&gt; It would be the-same-as-before-only-worse.</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; Now, if we can implement in ext4 (ext5, xfs7, doesn&#x27;t matter… any filesystem which is sufficiently popular for the developers to care) fine-grained enough handling of these hints supplied by your “better APIs” completely (as in: incorrect use would, actually, be visible to developers) then and only then pushing new APIs would make sense.</font><br>
<p>
This is not possible. But an API with less implementation specific behavior than POSIX should already help in getting the apps right. <br>
<p>
<font class="QuotedText">&gt; We are not yet even at stage where incorrect use fsync and co is visible to developers</font><br>
<p>
Of course, this is not visible. After all, in almost all cases, everything goes well. The order in which data hits the disk only matters if a crash occurs in the very right (or wrong) moment.<br>
<p>
<font class="QuotedText">&gt;  thus it&#x27;s definitely too early to talk about more fine-grained API.</font><br>
<p>
The API should not be more fine-grained. It should be easier to use. Even changing a simple config file in a consistent way is horrible in POSIX. With transactions this would look like: start_transaction() open() write() close() commit_transaction(). This looks much more intuitive to me than the POSIX way, where you need to take care of creating a new file, renaming it afterwards, and issuing the right fsync calls at the right times. <br>
<p>
And now try to imagine dependent changes in two different files. With POSIX this requires you to implement some journaling on the app level, as there is no way of renaming two files atomically.<br>
<p>
<font class="QuotedText">&gt; Or maybe, if with “fast transactions” we can ensure that misuse if that API would be visible to developers then it&#x27;s time to introduce it and ask developers to test apps with it.</font><br>
<p>
This is the wrong way to go. To detect misuse will only be possible if the system crashes in the right moment. And of course also &quot;fast transactions&quot; have implementation specific behavior. This is inherent to the current API. If you want to test apps for compliance with this API, you will need some kind of fuzzer that randomly reorders everything to the extend allowed by POSIX and then crashing at some random point of time.  <br>
<p>
<font class="QuotedText">&gt; But please don&#x27;t introduce API misuse of which developers couldn&#x27;t easily detect. Fsync story is problematic enough as it is. Don&#x27;t make it worse.</font><br>
<p>
Ordering issues in parallelism are always hard to detect. Not only for fs writes but also for multiple threads. If you want to avoid that entirely, then you need to use an implementation that is strictly ordered (and by no means parallel). I doubt that many people are willing to pay that price. <br>
<p>
The current API is horrible for app developers. Let&#x27;s create an API that is easier to get right. And yes this means it has to be harder for the fs developers.<br>
<p>
Best,<br>
Matthias<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842893"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 16:38 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842893/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The current API is horrible for app developers. Let&#x27;s create an API that is easier to get right. And yes this means it has to be harder for the fs developers.</font><br>
<p>
AND YOU CAN&#x27;T EVEN RELY ON JOURNALLING because you don&#x27;t know whether the file system has written the journal before, after, or in the middle of writing the data.<br>
<p>
Really, all I want is something like fsbarrier(), which GUARANTEES that stuff written after it is written after stuff that was written before it. I don&#x27;t give a monkeys whether the filesystem batches, parallelises, or what ever other O_PONIES writes, provided I can reason that this call makes sure my stuff hits the disk in the order I expect.<br>
<p>
If I want to trash my application&#x27;s performance with excessive use of fsbarrier(), that&#x27;s my problem. If the OS expects me to trash EVERYONE ELSE&#x27;S performance with excessive use of fsync() or fsfsync(), then that&#x27;s a BIG problem for the OS!<br>
<p>
Oh - and wasn&#x27;t advice about how to shut a system down always &quot;# sync; sync; sync; halt&quot;? So all of us old hands expect sync() to do a filesystem flush? And do you really expect me as a developer to do that after most writes when I expect something like that to bring the system to its knees?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842893/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 21:10 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/842909/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;AND YOU CAN&#x27;T EVEN RELY ON JOURNALLING because you don&#x27;t know whether the file system has written the journal before, after, or in the middle of writing the data.</font><br>
<p>
Journalling was primarily invented to ensure the integrity of the filesystem. I.e., to avoid a total loss of the filesystem in case of power loss/crash.<br>
<p>
<font class="QuotedText">&gt; Really, all I want is something like fsbarrier(), which GUARANTEES that stuff written after it is written after stuff that was written before it. </font><br>
<p>
This would be quite nice. fsync() only guarantees ordering for data written to the given file descriptor. fsbarrier() would probably be easier to use for the app developer. No need to call it for every involved file descriptor. And yes, in many cases guaranteeing ordering would be enough. No need to actually force the data to the disk before the syscall can return.<br>
<p>
<font class="QuotedText">&gt; I don&#x27;t give a monkeys whether the filesystem batches, parallelises, or what ever other O_PONIES writes, provided I can reason that this call makes sure my stuff hits the disk in the order I expect.</font><br>
<font class="QuotedText">&gt; If I want to trash my application&#x27;s performance with excessive use of fsbarrier(), that&#x27;s my problem. If the OS expects me to trash EVERYONE ELSE&#x27;S performance with excessive use of fsync() or fsfsync(), then that&#x27;s a BIG problem for the OS!</font><br>
<p>
Why should fsbarrier() be any different in this regard than fsync(). Neither of the two requires the system to cripple performance. And both of them can be implemented by just forcing a global filesystem sync. The performance of fsync is getting much better, as the developers actually use the freedom they have. But I am wondering why you expect filesystem developers to implement the (from a filesystem perspective) much harder fsbarrier() call more efficiently than the relatively straightforward fsync() call. fsbarrier() would probably require a major rewrite of the VFS layer to even be able to compute the list of files that are effected by such a call. Chances are good that developers will use similar shortcuts as they have done for fsync() for decades and performance of the whole system will cripple with such a call.<br>
<p>
<font class="QuotedText">&gt; Oh - and wasn&#x27;t advice about how to shut a system down always &quot;# sync; sync; sync; halt&quot;? So all of us old hands expect sync() to do a filesystem flush? And do you really expect me as a developer to do that after most writes when I expect something like that to bring the system to its knees?</font><br>
<p>
sync guarantees a full filesystem flush. No changes there. That is indeed a bit of overkill if you just require ordering. fsync used to be quite inefficient as well, but it is getting better in this regard. And I know nobody who suggests to use sync in normal apps. fsync should be enough if used correctly.<br>
<p>
Best,<br>
Matthias<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 21:42 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842912/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why should fsbarrier() be any different in this regard than fsync(). Neither of the two requires the system to cripple performance. And both of them can be implemented by just forcing a global filesystem sync. The performance of fsync is getting much better, as the developers actually use the freedom they have. But I am wondering why you expect filesystem developers to implement the (from a filesystem perspective) much harder fsbarrier() call more efficiently than the relatively straightforward fsync() call. fsbarrier() would probably require a major rewrite of the VFS layer to even be able to compute the list of files that are effected by such a call. Chances are good that developers will use similar shortcuts as they have done for fsync() for decades and performance of the whole system will cripple with such a call.</font><br>
<p>
So let&#x27;s say I want to guarantee - let&#x27;s say ten or twenty - files have all flushed before I start writing the next file, can I do those fsync()s in parallel? Without having to spawn 20 threads and then wait on them all? Whatever, that&#x27;s a lot of work.<br>
<p>
And with an fsfsync, again does that provide the ordering guarantee? I&#x27;ve heard that yes it guarantees everything that&#x27;s been written gets flushed, but does it put a hard barrier in (like my fsbarrier()), or does it just stall all new writes until all the old writes have been flushed, or does it just guarantee that everything written before the fsfsync is flushed but it doesn&#x27;t stop newer writes being merged forwards and being caught up in the flush?<br>
<p>
Because if fsfsync() puts that barrier in, I&#x27;m simply changing a synchronous fsfsync() to an asynchronous fsbarrier(), if it&#x27;s the second option it&#x27;s causing a performance impact on the system, and if it&#x27;s the third option then my app has to do a synchronous call with the performance impact that implies.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 4:41 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842920/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends. Let&#x27;s go through these:<br>
<p>
- For fsync()&#x27;ing multiple files, the standard answer is &quot;use a thread pool.&quot; This is also the standard answer to &quot;I want asynchronous I/O like on Windows,&quot; so no surprise there.<br>
- As the article mentions, they are discussing an &quot;fsync multiple files&quot; syscall, which will (probably) further alleviate this problem (if it actually happens).<br>
- I&#x27;m not aware of any syscall called &quot;fsfsync(),&quot; so I assume you meant syncfs(2). That function is not in POSIX, so all we have to go on is the note in that man page, which explicitly states that &quot;sync() or syncfs() provide the same guarantees as fsync() called on every file in the system or filesystem respectively.&quot;<br>
- POSIX says that sync(2) is not required to wait for the writes to complete before returning (unlike fsync()). As noted above, POSIX does not specify syncfs() at all.<br>
- Arguably, a conforming implementation could implement sync() as a no-op, because POSIX says it causes outstanding data &quot;to be scheduled for writing out&quot; - but it was *already* scheduled for writing out.<br>
- Therefore, if you want to be pedantically POSIX-correct, you should not use sync(2) at all, because it gets you exactly nothing according to the standard.<br>
- Since syncfs() is already Linux-specific, you can rely on its Linux-specific guarantees, if you are in a position to call it in the first place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 5:34 UTC (Mon)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/842948/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe io_uring supports fsync, so that would be a way to do an asynchronous fsync on somewhat modern Linux.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 7:16 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842949/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you can also use aio_fsync(3), but that&#x27;s basically just a crappier version of &quot;use a thread pool.&quot;<br>
<p>
IMHO this is a broader issue with aio(7) and not a problem with fsync in particular.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor842954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 10:45 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/842954/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p><tt>io_uring</tt> does provide the primitives needed; there's <tt>IORING_OP_FSYNC</tt> (with <tt>IORING_FSYNC_DATASYNC</tt> to weaken from fsync to fdatasync) and <tt>IORING_OP_SYNC_FILE_RANGE</tt> for flushing  caches asynchronously, and the <tt>IOSQE_IO_DRAIN</tt> and <tt>IOSQE_IO_LINK</tt> flags to order <tt>io_uring</tt> operations with respect to each other so that you can issue the fsync after all the related writes have been done.
      
          <div class="CommentReplyButton">
            <form action="/Articles/842954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor842956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 13:05 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/842956/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  AND YOU CAN&#x27;T EVEN RELY ON JOURNALLING because you don&#x27;t know whether the file system has written the journal before, after, or in the middle of writing the data.</font><br>
<p>
The filesystem is going to write data before metadata, so that you won&#x27;t have a file that&#x27;s full of zeros (or worse, full of stale data including another user&#x27;s cleartext password). With &quot;old Unix&quot; you could get a file that&#x27;s full of trash after a power failure; I sure did. So if anything journalling makes things better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor843471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2021 19:42 UTC (Thu)
                               by <b>mstone_</b> (subscriber, #66309)
                              [<a href="/Articles/843471/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, the confusion here comes from comparing the current state of affairs to a past state that didn&#x27;t exist.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor843269"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2021 17:44 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/843269/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>Oh - and wasn't advice about how to shut a system down always "# sync; sync; sync; halt"?</blockquote>

No, the advice was to type

<pre>
sync
sync
sync
halt
</pre>

That's because sync did not block (unlike on Linux), so the time you needed to type the additional syncs and the halt was needed to finish the sync.
      
          <div class="CommentReplyButton">
            <form action="/Articles/843269/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor842911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 20:49 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842911/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fundamental problem with this argument is that the API you describe can be (and has been) implemented in userspace (in the form of SQLite, as well as numerous &quot;real&quot; databases). Therefore, if you want to argue in favor of doing this in kernel space, it is not enough to argue that a new API would be &quot;better&quot; in various ways. You need to *specifically* address one question: Why should anyone re-implement already working userspace code in the kernel? Would it provide some performance advantage? Would it somehow enable you to do things that you can&#x27;t currently do? Or would it just be &quot;more convenient?&quot; If the latter, how is that the kernel&#x27;s problem?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842934"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 17:40 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842934/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What I find hard to understand is, if the database (SQLite, whatever) is using linux syscalls, how does it know the data has actually been written? Or does it do loads of sync()s, and then pause all writes for ten seconds or so waiting for the data to flush, etc etc.<br>
<p>
I can see how databases can provide 99.999% reliability. I&#x27;m active on the raid list. I know all about disk timeouts, disks lying, how long things take to get flushed, etc etc. I simply do not see how an application can guarantee safety.<br>
<p>
As for &quot;why should it be in the kernel&quot; - because LOTS of developers will benefit from the ability to reason about the state of a system in a crash scenario. Why should all the database developers be forced to duplicate each others&#x27; work?<br>
<p>
And frankly, if I commit something to the filesystem for saving, surely I should be able to ask the filesystem &quot;have you saved it?&quot; AND BE ABLE TO RELY ON THE ANSWER! (Yep, I know disks lie, and I don&#x27;t expect the file system necessarily to deal with that, but it really should be held responsible for its own actions!)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842934/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 22:13 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/842941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The process that SQLite uses is documented in <a href="https://sqlite.org/atomiccommit.html">https://sqlite.org/atomiccommit.html</a> in a very high level of detail.<br>
<p>
TL;DR: They make a copy (&quot;rollback journal&quot;) of the data they are about to overwrite, fsync that copy, overwrite the data, fsync the database itself, and finally delete the rollback journal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor842882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 8:51 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/842882/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; All this talk about &quot;apps should use fsync&quot; or &quot;apps should use fsfsync&quot; fills me with horror, as someone who wants to write a system that relies on data integrity. Are you  telling me that my app needs to be filesystem-aware, and not only that but aware of what mount options were used, so I know which commands to call to make sure that my data is safe?</font><br>
<p>
The app does not need to be filesystem-aware. If it closely follows the POSIX standard, the data should be safe on any filesystem, of course excluding ancient filesystems like FAT. Unfortunately, the POSIX standards is not very intuitive when it comes to data ordering and lacks some features. If your app chooses to ignore the POSIX standard, then you depend on the filesystem implementation and you are at the risk that things break when this implementation changes. <br>
<p>
<font class="QuotedText">&gt; And no, I don&#x27;t want to offload that onto the glibc guys either.</font><br>
<font class="QuotedText">&gt; I know it&#x27;ll be hard, but is there any way we can get the VFS to dictate that certain things are supposed to happen in a certain order. </font><br>
<p>
What I would like to have are transactional semantics with ACID properties. Unfortunately, I do not see the VFS interface to be extended by transactions in any foreseeable future. The ways in which config files are updated always was a dirty workaround. Even if you strongly order: create new file, write new file, rename new file to old file, there is still the possibility of ending up with old file and new file existing in parallel after a crash. If this would be an atomic transaction, this could not happen. And it should even be more efficient to implement on the fs level, as there would be no need to fsync after every step.<br>
<p>
<font class="QuotedText">&gt; As an app, I don&#x27;t care *how* the OS does it, but I want to be able to reason about what&#x27;s hit the disk and when. </font><br>
<p>
According to POSIX, some data has hit the disk after fsync() returned. <br>
<p>
<font class="QuotedText">&gt; And I DON&#x27;T want to have to worry about what the filesystem is or how it does it.</font><br>
<p>
Of course. But this is only possible if you closely follow POSIX rules. If you do not follow these rules closely, you will always depend on implementation details.<br>
<p>
<font class="QuotedText">&gt; I&#x27;ve said it before, but I don&#x27;t care too much about fsync or fsfsync, and I really don&#x27;t want to have to worry about how the OS will react to those calls -</font><br>
<p>
Then you should not program at the POSIX level. The data safety according to POSIX always relied on using the ordering primitives like fsync. With some filesystems you can be lucky that it works without fsync, but there never was a guarantee. You can still use some safe abstraction that takes care of your needs. SQlite was already suggested. It will happily do all the needed fsync calls for you and your data should be safe.<br>
<p>
<font class="QuotedText">&gt; one only has to go back to the ext3/ext4 transition/debacle where code that was fast on ext3 brought ext4 to its knees... if I can know for certain that stuff hits the disk in the order I write it, and tell the system what it can write in parallel and what it can&#x27;t ... (basically data can be written in parallel, logs can be written in parallel, just not in parallel with each other. And the OS needs me to tell it the difference between the two, it won&#x27;t know by itself.)</font><br>
<p>
This can only be done by an API extension on the VFS level. As I already said, I would like to have transactional semantics for filesystems, but it is quite unlikely that we will get these.<br>
<p>
Best,<br>
Matthias<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 18:13 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842898/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The app does not need to be filesystem-aware. If it closely follows the POSIX standard, the data should be safe on any filesystem, of course excluding ancient filesystems like FAT. Unfortunately, the POSIX standards is not very intuitive when it comes to data ordering and lacks some features. If your app chooses to ignore the POSIX standard, then you depend on the filesystem implementation and you are at the risk that things break when this implementation changes. </font><br>
<p>
Are you sure!? As I understood POSIX, it dictates what an app sees on a properly functioning system. If my app follows POSIX, it will work fine so long as the underlying system is working fine. As far as POSIX was concerned (dunno if it&#x27;s changed), if the system crashed then that was &quot;undefined behaviour&quot;, with all the same downsides as the C definition of undefined behaviours.<br>
<p>
So when we&#x27;re talking about system crashes, POSIX is the wrong spec ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 18:37 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/842899/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you sure!? As I understood POSIX, it dictates what an app sees on a properly functioning system. If my app follows POSIX, it will work fine so long as the underlying system is working fine. As far as POSIX was concerned (dunno if it&#x27;s changed), if the system crashed then that was &quot;undefined behaviour&quot;, with all the same downsides as the C definition of undefined behaviours.</font><br>
<p>
Actually this was very well what could happen and still can happen with non-journaling filesystems.  Plugging the power-cord in the wrong moment and you have a broken filesystem that cannot not be mounted. With a bit of luck you can get your files back with fsck. Fortunately, the situation improved. In a journaling filesystem you should in any way only loose data in modification. <br>
<p>
fsync() was added for precisely one reason: to have less undefined behavior in the case of a crash. As long as the system is properly functioning, there is no need for fsync() at all. Unfortunately, not all systems are properly functioning. Furthermore, not all people are happy with the semantics of the good old days that said: undefined behavior, all your data might be lost after a power outage. <br>
<p>
<font class="QuotedText">&gt; So when we&#x27;re talking about system crashes, POSIX is the wrong spec ...</font><br>
<p>
Nowadays, POSIX can give some guarantees on what can happen in certain situations. If you do not use fsync() your writes might be hitting the disk in some random order and what you can see after a crash is any intermediate state of this random order. If you use fsync(), you are sure that the fsynced data actually hit the disk and you have some control of the order. And if I got this correctly, the whole discussion is about the order in which data hits the disk and what can happen in case of a system crash. None of what we are discussing has any relevance in a properly working system, as after umount, all data has hit the disk and in a properly functioning system all disks are unmounted before the power is turned off.<br>
<p>
Of course, even todays newer spec (which include fsync) do not help if the reason for the system crash was the hard drive catching fire or the storage driver turning mad. But it should help a lot for more common causes of crashes like power outage or the kernel panicking.<br>
<p>
Cheers,<br>
Matthias<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842935"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 17:58 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842935/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Actually this was very well what could happen and still can happen with non-journaling filesystems. Plugging the power-cord in the wrong moment and you have a broken filesystem that cannot not be mounted. With a bit of luck you can get your files back with fsck. Fortunately, the situation improved. In a journaling filesystem you should in any way only loose data in modification.</font><br>
<p>
And this is pretty much the perfect example of what is wrong with the current setup. The filesystem journal is there to protect the filesystem, to hell with the user&#x27;s data. So HOW as a database developer am I supposed to protect my database (other than writing to a raw partition!) if I can&#x27;t trust the filesystem to protect my user-space journal!<br>
<p>
That&#x27;s why ext3 journal=&quot;ordered&quot; was so good - it gave the APPLICATION DEVELOPERS the guarantee that, after a crash, writes *appeared* to have been written to disk in the order that they were made. That&#x27;s ALL a developer needs!<br>
<p>
(Oh, and I don&#x27;t think my work on raid would help that, even if raid could provide those guarantees which I hope it can, that an application could rely on it unless the filesystem ALSO provided those guarantees.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842935/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 21:03 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/842937/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; Actually this was very well what could happen and still can happen with non-journaling filesystems. Plugging the power-cord in the wrong moment and you have a broken filesystem that cannot not be mounted. With a bit of luck you can get your files back with fsck. Fortunately, the situation improved. In a journaling filesystem you should in any way only loose data in modification.</font><br>
<p>
<font class="QuotedText">&gt;And this is pretty much the perfect example of what is wrong with the current setup. The filesystem journal is there to protect the filesystem, to hell with the user&#x27;s data. </font><br>
<p>
If the filesystem gets corrupted, then all user data is lost, so  indeed the journal is there to protect the data.<br>
<p>
<font class="QuotedText">&gt;So HOW as a database developer am I supposed to protect my database (other than writing to a raw partition!) if I can&#x27;t trust the filesystem to protect my user-space journal!</font><br>
<p>
You can trust it. Do an fsync on the user-space journal. Anything else will not work and has never worked. Ok, especially if you are developing databases, O_DIRECT might be a viable alternative. And writing to a raw partition also does not guarantee that the writes are in order. You still have to flush the cashes to ensure that something actually has hit the disk, or use synchronous IO from the beginning.<br>
<p>
<font class="QuotedText">&gt;That&#x27;s why ext3 journal=&quot;ordered&quot; was so good - it gave the APPLICATION DEVELOPERS the guarantee that, after a crash, writes *appeared* to have been written to disk in the order that they were made. That&#x27;s ALL a developer needs!</font><br>
<p>
This is clearly wrong. data=ordered only ensures that data is written before related meta-data. Writes to different files are not guaranteed to be ordered. Overwriting a file is not guaranteed to be ordered. The blocks can hit the disk in a random order. The things that are guaranteed by data=ordered is that when appending a file the new data hits the disk before the new blocks are added to the inode, i.e., it is not possible that the file contains garbage instead of the new data. And I think it is guaranteed that a rename only is done after the renamed file has hit the disk. This of course helps for those people that update data by the create new file, rename model. But there is not much that really helps for databases.<br>
<p>
<font class="QuotedText">&gt;(Oh, and I don&#x27;t think my work on raid would help that, even if raid could provide those guarantees which I hope it can, that an application could rely on it unless the filesystem ALSO provided those guarantees.)</font><br>
<p>
The work on raid is essential, as of course all layers below the filesystem have to provide certain data safety features. Especially the filesystem requires some kind of transactional semantics for its own journal.<br>
<p>
Best,<br>
Matthias<br>
<p>
P.S.: Actually database developers are probably among the first to scream in terror if a filesystem will guarantee strong ordering properties because of the immense performance penalties, which they do not want to buy. At least the big systems know pretty well which data has which ordering requirements, which data should be in memory cache or will likely not be used again soon and want to control all these aspects themselves. If they do not use a raw partition from the beginning, they will just use the filesystem to reserve a bunch of blocks and then use synchronous IO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor842938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 21:18 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/842938/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Actually database developers are probably among the first to scream in terror if a filesystem will guarantee strong ordering properties</font><br>
<p>
I did say the *appearance* of strong ordering guarantees :-)<br>
<p>
<font class="QuotedText">&gt; If the filesystem gets corrupted, then all user data is lost, so indeed the journal is there to protect the data.</font><br>
<p>
But if the data in flight is corrupted, then the only way to get the system back to a sane (for the user) state may be &quot;format, recover backup&quot;. Yes making sure the filesystem is itself consistent is important but it&#x27;s only part of the picture. If I can&#x27;t trust the state of the data, I need to recover from backup.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2021 17:55 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/864181/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can trust the data if you tell the OS you want to pay the price (use fsync, or O_SYNC/O_DSYNC) and you only rely on data known to be flushed after a crash.<br>
<p>
The alternative you&#x27;re proposing basically implies that writes cannot be buffered for any meaningful amount of time. Oh, your browser updated it&#x27;s history database? Let&#x27;s just make that wait for all temporary files being written out, the file being copied concurrently, etc. And what&#x27;s worse, do not allow any concurrent sync writes to finish (like file creation), because that would violate ordering.<br>
<p>
Ext3&#x27;s ordering guarantees were weaker and yet lead to horrible stalls all the time. There constantly were complaints about Firefox&#x27;s SQLite databases stalling the system etc.<br>
<p>
The OS/FS aren&#x27;t magic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2021 18:01 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/864183/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 &gt; The OS/FS aren&#x27;t magic.<br>
<p>
In particular they have no reliable way of knowing which files (or even parts of files) are related and need constrained ordering between writes, and which are unrelated and thus can handled independently. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor864076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2021 13:10 UTC (Fri)
                               by <b>Defenestrator</b> (guest, #153400)
                              [<a href="/Articles/864076/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  And I think it is guaranteed that a rename only is done after the renamed file has hit the disk.</font><br>
<p>
This is often true in practice (in particular, in ext3 and in ext4 outside of early versions), but not always explicitly guaranteed.  See the auto_da_alloc option added to ext4 for more info and background.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor864167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2021 17:43 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/864167/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Do an fsync on the user-space journal. </font><br>
<p>
With a small bit of care fdatasync() should be enough, and will often be a lot faster (no synchronous updating of unimportant filesystem metadata like mtime, turning a single write into multiple).<br>
<p>
<font class="QuotedText">&gt; Anything else will not work and has never worked. Ok, especially if you are developing databases, O_DIRECT might be a viable alternative.</font><br>
<p>
O_DIRECT on its own does not remove the need for an fsync/fdatasync. Devices have volatile write caches, and they do loose data on power loss/reset. O_DIRECT alone only avoids issues with the OS write cache. And makes the f[data]sync cheaper, because it will often only have to send a cache flush (and transparently avoid that on devices without volatile write caches).<br>
<p>
Alternatively it can be combined with O_DSYNC to achieve actually durable writes - but if one isn&#x27;t careful that can tank throughput. It either adds the FUA flag to each write or does separate sync commands after each write, which can end up being more cache flushes for a workload. It can be significantly faster to do a series of writes and then a single cache flush.<br>
<p>
It&#x27;s hardware dependant too whether FUA or separate cache flush commands are faster :(. Dear Samsung, please fix your drives.<br>
<p>
My testing says that on most NVMe devices with a volatile cache DSYNC wins if the queue depth is very low and latency is king (only one roundtrip needed). fdatasync wins if there&#x27;s more than a few writes happening at once, especially if all/most need to complete before the &quot;user transaction&quot; finishes - the lower number of flushes saves more than the additional roundtrip costs.<br>
<p>
<font class="QuotedText">&gt; Actually database developers are probably among the first to scream in terror if a filesystem will guarantee strong ordering properties because of the immense performance penalties, which they do not want to buy.</font><br>
<p>
Indeed! And there&#x27;s no realistic way the FS can do better. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor842915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2021 0:53 UTC (Sun)
                               by <b>orib</b> (subscriber, #62051)
                              [<a href="/Articles/842915/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; All this talk about &quot;apps should use fsync&quot; or &quot;apps should use fsfsync&quot; fills me with horror, as someone who wants to write a system that relies on data integrity. Are you telling me that my app needs to be filesystem-aware, and not only that but aware of what mount options were used, so I know which commands to call to make sure that my data is safe?</font><br>
<p>
No, the opposite: your app needs to be aware of the *STANDARDS* that the filesystem is attempting to conform to, rather than what the implementation of the day happens to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor843071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2021 17:05 UTC (Mon)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/843071/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From reading from your other posts on this, I think you also have to be aware of what the hardware the system has in it if you want that level of guarantee. There are large number of hardware pieces who for the sake of speed fool the OS into saying stuff was written but wasn&#x27;t. You can fsync(), sync(), and all otehr things and the hardware will write stuff in the order it wants. And yes like bufferbloat it is built into all parts of modern hardware from the cache on the harddrive, to the controller of the harddrive to the PCI bus the controller is connected to the memory subsystem. <br>
<p>
In the end for a lot of hardware you just have to throw away guarenteeing a lot of things because the entire industry has agreed to lie in order to give the feeling of speed.  To get around this you start having to move back to Real Time hardware which is much slower (less smart caches which could break RT guarantees) but more predictable. Not the answer you probably want to hear.. but I think a good reason the kernel people don&#x27;t see the lies as a problem any more is that finding hardware post 2004 which doesn&#x27;t lie in someway to its calling system is rare. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor843272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2021 18:51 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/843272/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>All this talk about "apps should use fsync" or "apps should use fsfsync" fills me with horror, as someone who wants to write a system that relies on data integrity. Are you telling me that my app needs to be filesystem-aware, and not only that but aware of what mount options were used, so I know which commands to call to make sure that my data is safe?</blockquote>

I think that the Ted Ts'o position is that you should use fsync a lot, independent of the file system; and that you should not just use it on the file you were working on, but possibly on other files; he explicitly mentions the directory that contains the file, but my expectation is that it might also affect other files, depending on the file system.  E.g., some file systems have a file that contains the inodes, so why not require that the application also fsyncs that?

<p>My position is pretty much the opposite: A good file system should provide decent consistency guarantees in case of an OS crash or power outage (which, BTW, is not covered by POSIX, so any claim by Ted Ts'o that POSIX requires applications to use fsync the way he likes is nonsense).  And these consistency guarantees should orient themselves on the guarantees that file systems give in the non-crash case.  This is the usual case, which is what programmers develop for and test against; so even if Ted Ts'o's file systems would guarantee to corrupt all non-fsynced data in case of a crash, it is unlikely that all applications would contain so many fsyncs that Ted Ts'o would not blame them on data loss.

<p>Given that POSIX guarantees sequential consistency for file system operations in the non-crash case, my take is that file systems should guarantee a sequential consistent state in case of a crash; but for performance reasons, not the state at the time of the crash.  You can use sync whenever you want the crash state to be consistent with the logical state, e.g., before reporting the completion of a transaction over the network.

<p>Unfortunately, there is only one file system in Linux that gives such a guarantee last I looked (NILFS2), but that's because we let Linux get away with file systems that don't give such guarantees; admittedly Linux crashes so rarely these days and at least around here power outages are so rare that the itch is small.

<p>Concerning whether apps should be file system aware, my take is that you should program for a filesystem that gives good guarantees, and recommend that the user should not be using other file systems (I have certainly avoided any file system maintained by Ted Ts'o since the O_PONIES discussion).  Or, if you feel like accomodating bad file systems, have a flag for the application that insert an fsync of the file and its directory after every change of the file (that may satisfy Ted Ts'o for now); the user can use that flag when using a bad file system.

<p>Concerning efficiency, this can be implemented efficiently, by writing the changes (data blocks and/or journal entries) to free blocks in arbitrary order, then a write barrier, then a root block that allows finding all this stuff, and once that root block reaches the platter, the recovery code will find everything.  This does not even require any synchronous operation in principle, so it could be very efficient (in practice, I think that the barrier operations on existing drives are synchronous).

<p>Concerning lying hardware: If the hardware lies, all the fsyncs that Ted Ts'o asks for will not help you.  Just as we need file systems with decent guarantees, we need honest hardware.  And I expect it exists, because otherwise database servers would be unable to guarentee consistency after crashes.

      
          <div class="CommentReplyButton">
            <form action="/Articles/843272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor842891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2021 15:54 UTC (Sat)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/842891/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However, this change broke some existing tests that depend on fsync() working as a global barrier, so he backed it out. </font><br>
<p>
It would be interesting to know how fsync() is implemented on other filesystems than ext*, whether it guarantees committing other files, too.<br>
<p>
Looking at btrfs and xfs code it seems that they only sync the current inode when handling f(data)sync() calls so applications depending on fsync() being a FS-wide barrier are probably broken on these filesystems, too.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/842891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor843097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL might benefit from a fd-list fsync() API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2021 4:36 UTC (Tue)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/843097/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think PostgreSQL might benefit significantly from a fsync() variant that takes a fd-list. Though the project is considering moving to syncfs() on Linux. It generally only cares about flushes to many files when it&#x27;s doing checkpoints, and ordering of individual flushes isn&#x27;t important for those. <br>
<p>
Pg has three major write/flush order requirements.<br>
<p>
1. For WAL (its journal): WAL record writes must be flushed to disk strictly in ascending byte order in the WAL files. Not all WAL record writes must be immediately durable, but all writes prior to a durable record like a commit must complete before the durable record is flushed. PostgreSQL uses either O_DATASYNC or fdatasync() to ensure this.<br>
<p>
2. Ordering of non-WAL writes with respect to their corresponding WAL record writes. Non-WAL writes such as heap pages, index pages, clog (commit state) must not be flushed to disk until the corresponding WAL writes are known to be durable. To do this, PostgreSQL buffers the data to be written in its own shared memory, delaying any write() to the OS until it knows the WAL for these writes is durable. This causes significant double-buffering waste and write latency.<br>
<p>
3. Checkpoint WAL segment removal vs non-WAL writes. PostgreSQL must know that all non-WAL writes corresponding to WAL records up to a given point in the WAL are durably on disk before it removes or overwrites a WAL segment (file). PostgreSQL does this by remembering each file descriptor that was touched since the last checkpoint and fsync()ing it before removing any WAL segments.<br>
<p>
If this sounds inefficient to you, that&#x27;s because it is.<br>
<p>
The O_DATASYNC or fdatasync() after many WAL record writes can limit overall throughput of sync-sensitive writes like commit records, especially since sometimes a large volume of less critical records must be flushed before the critical record is durably flushed. WAL writing spends a lot of time waiting because there&#x27;s no API that lets us pipeline or queue up fsync()s in a non-blocking manner - except possibly helper threads for blocking calls, and they cause plenty of other issues.<br>
<p>
For non-WAL (heap) writes, PostgreSQL has to tie up memory for its pending writes until it knows the OS has flushed the corresponding WAL writes. Only then can it write() them, because it has no way to tell the OS that they must not hit disk before the corresponding WAL records are durable. That means it has to buffer them for longer, and double handle the writes.<br>
<p>
Finally, for checkpoints PostgreSQL must fsync() all the dirty files it has open. This will force all pending writes on those files to disk, not just the writes made before the current checkpoint target position. On most Linux FSes it also flushes a bunch of other irrelevant and uninteresting files that don&#x27;t need to be durable at all.<br>
<p>
What I&#x27;d really like to have is a way to tell the FS about write-order dependencies when PostgreSQL issues a write().<br>
<p>
Postgres would request a tag for each WAL record write, and then tag each write that depends on that WAL record with an ordering requirement against that WAL write tag. Then if WAL ordering was critical for a given WAL write it&#x27;d tag the next WAL write with an ordering requirement against the previous critical WAL write. So the OS would be free to write in natural order:<br>
<p>
* WAL record A<br>
* Heap changes for A<br>
* WAL record B<br>
* Heap changes for B<br>
<p>
or reorder:<br>
<p>
* WAL record A<br>
* WAL record B<br>
* Heap changes for A and B in any combination<br>
<p>
but could not write heap changes for A before WAL A, or heap changes for B before WAL B if postgres specified the A before B write-order requirement.<br>
<p>
That&#x27;d let Pg just write everything to the OS without blocking on fsync() etc, and let the kernel&#x27;s dirty writeback and VFS/block layer sort out the ordering.<br>
<p>
Basically a kind of AIO with the ability to impose write ordering requirements and with a sensible interface for confirming data is durably flushed. The latter is woefully lacking in any current AIO facilities.<br>
<p>
It&#x27;d be necessary to guarantee that any read of a file with pending writes always returned the latest data that&#x27;s pending writeback. Otherwise Pg would have to pin each dirty buffer in its own buffer cache until it knew it was flushed by the OS anyway.<br>
<p>
I hope that the recent blk-mq work may well benefit PostgreSQL if the needed balance between permitting reordering and imposing necessary write-order constraints proves to be possible. <br>
<p>
Note that Pg can&#x27;t use FS-level write-order barriers after each WAL record written. It&#x27;d eliminate the latency after each fsync(), but would be grossly inefficient for this because it&#x27;d prevent reordering of non-WAL writes across barriers, and we want the FS to be free to reorder non-WAL writes as aggressively as possible (up to the next checkpoint) in order to do write combining and write deduplication.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor843112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL might benefit from a fd-list fsync() API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2021 14:51 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/843112/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Finally, for checkpoints PostgreSQL must fsync() all the dirty files it has open. This will force all pending writes on those files to disk, not just the writes made before the current checkpoint target position. On most Linux FSes it also flushes a bunch of other irrelevant and uninteresting files that don&#x27;t need to be durable at all.</font><br>
<p>
Does PG tend to have a lot of these (dirty files)? Because Pick, the database I&#x27;m thinking of, typically stores a single &quot;table&quot; in one OR MORE os files, so I could have a *lot* of dirty files open ...<br>
<p>
Although of course, like PG, the main thing I&#x27;m concerned about is knowing that the journal is flushed ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor843509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL might benefit from a fd-list fsync() API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2021 1:15 UTC (Fri)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/843509/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. PostgreSQL may have many dirty FDs. Each tables or index is stored as separate file, and split into 1GB extents. I imagine that the extent splitting could be changed if there&#x27;s a benefit to doing so, but the separate files per relation not so much.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor843113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL might benefit from a fd-list fsync() API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2021 14:55 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/843113/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Note that Pg can&#x27;t use FS-level write-order barriers after each WAL record written. It&#x27;d eliminate the latency after each fsync(), but would be grossly inefficient for this because it&#x27;d prevent reordering of non-WAL writes across barriers, and we want the FS to be free to reorder non-WAL writes as aggressively as possible (up to the next checkpoint) in order to do write combining and write deduplication.</font><br>
<p>
Does PG often spend time io-bound? How important really is &quot;as efficient as possible&quot; disk io?<br>
<p>
I would have thought this issue would actually impact me even more, given that traditionally Pick has always been &quot;don&#x27;t bother with caching, it&#x27;s faster to retrieve it from disk&quot; and Pick can also really hammer the disk.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor843106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2021 14:24 UTC (Tue)
                               by <b>jan.kara</b> (subscriber, #59161)
                              [<a href="/Articles/843106/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In the default data=ordered mode, where the journal entry is written only after flushing all pending data, delayed allocation might thus delay the writing of the &gt; journal. </font><br>
<p>
This is actually not quite correct. Delayed allocation just means that write(2) stores data in the page cache without actually allocating blocks on disk. This also means that the journalling machinery is completely ignorant of the write at this moment. Later, when VM decides to write out dirty pages from the page cache, filesystem allocates blocks for the pages and it is only at this point that there are filesystem metadata changes that are journalled. So it isn&#x27;t true that &quot;delayed allocation may delay writing of the journal&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/843106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fast commits for ext4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2021 15:58 UTC (Mon)
                               by <b>mrybczyn</b> (subscriber, #81776)
                              [<a href="/Articles/845388/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you for the comment, Jan. We&#x27;ve clarified the sentence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
