        <!DOCTYPE html>
        <html lang="en">
        <head><title>Pointer tagging for x86 systems [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/888914/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/889125/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/888914/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Pointer tagging for x86 systems</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 28, 2022</br>
           </div>
Pointers are a fact of life for developers working in numerous languages.
It is often convenient to be able to associate a small
amount — a few bits at most — of ancillary information with a pointer.
This can often be done within the pointer value itself with some careful
masking and shifting.  CPU manufacturers have been adding ways to support
the addition of this sort of "tag" to pointers; the most recent may be
AMD's "upper address ignore" (UAI) feature, support for which was
recently <a
href="/ml/linux-kernel/20220310111545.10852-1-bharata@amd.com/">posted</a>
by Bharata B Rao.  This feature has an uncertain future in Linux, though,
as the result of a fundamental design decision.
<p>
On a 64-bit system, a pointer is, naturally, 64 bits wide.  But the CPU
does not actually need all of those bits to dereference an address stored
in a pointer.  There are no systems (yet) that require — or can provide —
all of the memory that can be addressed by 64&nbsp;bits, meaning that there
are ranges of address space that do not map to physical memory.  Normally,
user-space addresses start at (or near) zero and increase from there; that
means that the highest-order bits will be zero even with the largest
possible addresses.  As a result, it can be possible to use those
high-order bits to store other types of information.
<p>
There are numerous use cases for stashing metadata into those unused bits.
Memory allocators could use that space to track different memory pools, for
example, or for garbage collection.  Database management systems have their
own uses for that space.  Applications can implement this sort of tagging
now, but it must be done with care; an address with extra bits set is no
longer a valid pointer, so that metadata must be masked out before
dereferencing that pointer or passing it into code that does not understand
the tagging scheme.  That is error-prone and may slow down the application.
<p>
To make life easier for the developers of this sort of application, CPU
manufacturers have been adding the ability for the processor to simply
ignore the non-address bits in an address value.  Naturally, every
manufacturer has invented its own way of supporting this feature.  The AMD
version, UAI, specifically allows the uppermost seven bits of an address to
be used for ancillary data.
<p>
If accepted, AMD's implementation of this feature would not be the first;
support for the Arm "top-byte ignore" feature was merged for the 5.4 kernel
in 2019.  At that time, a set of <a
href="https://man7.org/linux/man-pages/man2/prctl.2.html"><tt>prctl()</tt></a>
commands was added to control the use of this feature.  Top-byte ignore
can be enabled with:
<p>
<pre>
    int prctl(PR_SET_TAGGED_ADDR_CTRL, PR_TAGGED_ADDR_ENABLE, 0, 0, 0);
</pre>
<p>
This interface was designed around Arm's implementation, which makes eight
bits available for tag data.  The AMD implementation only allows for seven
bits, meaning that applications wanting to use tagged addresses will need a
way to discover how many bits are available.  So Rao's patch set starts
with <a href="/ml/linux-kernel/20220310111545.10852-2-bharata@amd.com/">a
patch from Kirill Shutemov</a> (intended to add support for a similar Intel
feature, more about that below) adding two new parameters to the above
<tt>prctl()</tt> call, both of which are integer pointers.  The first of
those is for the caller to specify how many bits they would like to use for
pointer metadata; the kernel will update that value to reflect the number
of bits that are actually available.  The second pointer tells the kernel
where to store the number of bits to right-shift a pointer value to obtain
the tag data.
<p>
The subsequent patches then implement support for UAI in the Linux kernel.
<p>
The idea is simple enough, and this feature already exists for the Arm
architecture, but the UAI patches have still run into pushback, for a
number of reasons.  Perhaps the most fundamental of those is that UAI
allows the most-significant bit of the address to be used by user space.
In current systems, only kernel-space addresses have that bit set.  Turning
on UAI would allow user space to create pointer values that <i>look</i> like
kernel addresses, but which would actually be valid user-space pointers.
Those pointers can, of course, be passed into the kernel via
system calls where, in the absence of due care, they might be interpreted
as kernel-space addresses.  The consequences of such confusion would not be
good, and the possibility of it happening is relatively high.
<p>
This mechanism could probably be made to work safely, but, as Andy Lutomirski
<a
href="/ml/linux-kernel/6a5076ad-405e-4e5e-af55-fe2a6b01467d@www.fastmail.com/">said</a>:
"<q>A lot of auditing of existing code would be needed to make it safe</q>".
Even more auditing would be required, of course, to keep it safe in a
rapidly evolving kernel.  It sounds like a recipe for ongoing security
problems, which is why Thomas Gleixner <a
href="/ml/linux-kernel/87fsnac3pb.ffs@tglx/">said</a> that "<q>there is
no justification for the bit 63 abuse</q>".  He suggested that AMD
should rework the feature in its processors to disallow that bit in address
tags; he did not 
say that this problem would block the merging of UAI, but the meaning was
reasonably clear.
<p>
Another problem that Lutomirski pointed out is that UAI is not specific to
any running context; once it is enabled, it is turned on for the entire
CPU.  That, too, could lead to unpleasant surprises, so he suggested that
the kernel would need to make the UAI settings process-local, even if it
slows down context switches considerably.
<p>
Finally, there is the issue of Intel's similar feature, called "Linear
Address Masking" (LAM).  It does not have the most-significant-bit issue
that UAI has, and it is managed as part of the process context.  It
supports two modes, with either six or 15&nbsp;bits being made available
for ancillary data; the 15-bit mode only works if five-level page tables
are not in use.  LAM has been around for a while, and <a
href="/ml/linux-kernel/20210205151631.43511-1-kirill.shutemov%40linux.intel.com/">support
patches</a> were posted (by Shutemov) in early 2021.  That work seems to
have stalled after that posting, but can be expected to come back at some
point.
<p>
Rao's UAI patch set deliberately keeps the AMD implementation entirely
separate from the proposed LAM implementation, even though the two are
doing essentially the same thing.  That led recently appointed x86
co-maintainer Dave Hansen to <a
href="/ml/linux-kernel/81b6f618-05bc-f7d0-5461-4c3f0ca42d3f@intel.com/">object</a>:
"<q>We'll have one x86 implementation of address bit masking.  Both the
Intel and AMD implementations will feed into a shared
implementation</q>".  So this is something that would certainly need to
be fixed before this work could be considered for mainline merging.
<p>
The other issues are tied to the design of the hardware, though, and will
be rather harder to fix in kernel code.  For these reasons, the sentiment
among kernel developers seems to be that LAM is a better-designed
implementation of pointer tagging and should perhaps be what all x86
systems use.  In the above-linked message, Lutomirski concluded:
<p>
<blockquote class="bq">
	I believe it's possible for a high-quality kernel UAI
	implementation to exist, but, as above, I think it would be slow,
	and it might be quite complex and fragile.  Are we sure that it's
	worth supporting it?
</blockquote>
<p>
A better solution, he suggested, would be for AMD to go back to the drawing
board and create its own implementation of LAM instead.
<p>
In the early days of Linux, kernel developers had to adapt to whatever the
hardware manufacturers put out; the alternative was to not have hardware to
run on at all.  In 2022, though, those developers feel more confident in
their ability to reject support for hardware features that, for whatever
reason, they feel do not fit in well with the design of the system.  If AMD
is unable to get support for UAI into the kernel (it's worth noting that
Rao <a
href="/ml/linux-kernel/b0861376-e628-06bd-713e-8837e0dc9d0b@amd.com/">hasn't
given up yet</a>), UAI is likely to go
mostly unused and developers needing pointer tagging may gravitate toward
competing CPUs.  According to Gleixner (linked above), AMD was told about
the problems with its implementation some time ago; the company may yet
have reason to wish it had listened.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures-x86">Architectures/x86</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/888914/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor889453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 17:10 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/889453/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Pointer tagging is super useful, especially with 64-bit systems where plenty of bits are irrelevant. But while I&#x27;m always using the lower ones (and would love to abuse upper ones instead), I agree with Thomas and Andy that playing with the topmost one sounds particularly insane. And doing it per-cpu instead of per-task doesn&#x27;t make it particularly appealing either.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor889455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 17:49 UTC (Mon)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/889455/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The wisdom of using addresses with bit 63 set aside, wouldn&#x27;t it be trivial for an attacker to construct such addresses and trigger any latent bugs in the kernel related to this already?  Surely that work is required either way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889460"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 18:50 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/889460/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>While you're right that constructing kernel addresses is trivial, the mitigation today is also trivial - if an address is passed to the kernel with its top bit set, then the called code should simply fail noisily because Something is Bad.
<p>In the UAI world, a pointer with the top bit set could be a kernel address, but it could also be the case that the user is using bit 63 as a tag bit, and the CPU will ignore it on access - the kernel can't tell.


      
          <div class="CommentReplyButton">
            <form action="/Articles/889460/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 20:12 UTC (Mon)
                               by <b>bartoc</b> (guest, #124262)
                              [<a href="/Articles/889469/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
yeah, but since you need to ask the kernel to turn the feature on in the first place the kernel could presumably just say &quot;yeah I know technically you could stash stuff in bit 63, but I&#x27;m not gunna let you do that. It could then tell userspace that only 6 bits were available. Sure, userspace could just ignore the kernel and set the 63rd bit, but it could do that already, unfortunately after UAI is enabled there won&#x27;t be a noisy fault if the kernel dereferences such a pointer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor889691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 15:12 UTC (Wed)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/889691/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With UAI enabled the critiical bit becomes bit 56, not bit 63. All the existing checks - which could be written as (long)addr &amp; BIT(63), or (long)addr &lt; 0, or even implemented in assembly - would need to be updated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor889458"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 18:15 UTC (Mon)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/889458/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does windows still set the top 16bits? If so, amd would seem to have designed this feature ignoring the behavior of operation systems most likely to run on their hardware.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889458/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 18:33 UTC (Mon)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/889461/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Servers mostly run Linux, so that&#x27;s not a market that can be ignored.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 19:43 UTC (Mon)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/889462/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux, and most other unix like, kernel space addesss layout seems to have not been considered. Windows is the only other player with significant market share in the x86 space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor889496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 22:35 UTC (Mon)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/889496/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think his point is basically “doesn’t this also mess up Windows?  Who on earth *was* it designed for?”<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor889473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 20:29 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/889473/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I know that Our Benevolent Editor knows this is misleading (and this is presumably just clumsy wording):<br>
<p>
<font class="QuotedText">&gt; There are no systems (yet) that require — or can provide — all of the memory that can be addressed by 64 bits, meaning that there are ranges of address space that do not map to physical memory. </font><br>
<p>
This conflates userspace addressing and kernel addressing. Userspace would love to have more address space available. Even with 64 bit pointers, address space fragmentation is a real thing, and prevents doing things like mmap() of an entire multi-petabyte file.<br>
<p>
The real problem is with the CPU. More virtual address bits available to userspace means more levels of page table or larger tables at each level or some other undesirable expansion that affects performance. It also affects how the L3 (perhaps also L2 and L1?) caches are implemented as more address bits must be checked, and thus also stored. Five level page tables come with some real costs beyond the obvious extra level of lookup!<br>
<p>
It is my opinion (based on precisely zero inside information) that Intel and AMD have decided that their current architectures will stop at five levels (57 bits of virtual address). When they need to go beyond this, we&#x27;re talking about a 128 bit architecture with a rather different approach to page tables. So they&#x27;re using the last few top bits to provide useful functionality like pointer tagging that people actually want. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889481"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 21:29 UTC (Mon)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/889481/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
128b would be wasteful in terms of I/D cache space.  80b/95b would probably be a reasonable next step. There is also an argument to be made for having the size of memory addresses != size of integers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889481/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 3:10 UTC (Tue)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/889510/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you have experience in CPU design?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor889515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 6:07 UTC (Tue)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/889515/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There is also an argument to be made for having the size of memory addresses != size of integers.</font><br>
<p>
This argument can only come from those nostalgic of the 8086/8088! What a disaster it was!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 12:33 UTC (Tue)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/889533/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or the PDP-10, which had a word size of 36 bits, and an address size of half a word (18 bits). The PDP-10 was word addressable, i.e. the address pointed to a 36-bit word, but there were also &quot;byte instructions&quot;, which used special 36-bit byte pointers. Instructions using these byte pointers could load or store any number of bits (1-36) starting from any bit position. (I don&#x27;t know what happened if the offset+size exceeded the number of bits in a word.)<br>
<p>
sizeof (int) == 5 according to a C compiler I got to try out on a DEC-20.<br>
<p>
<a href="http://pdp10.nocrew.org/docs/instruction-set/Byte.html">http://pdp10.nocrew.org/docs/instruction-set/Byte.html</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 1:02 UTC (Fri)
                               by <b>azz</b> (subscriber, #371)
                              [<a href="/Articles/889932/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s also idiomatic on the PDP-10 to use 36-bit &quot;AOBJN&quot; pointers where the low 18 bits contains the address, and the high 18 bits contains a negated count of words following the address - so each pointer also contains the length of the thing it points at, and you can easily do bounds checks and iteration.<br>
<p>
C is really not a good fit for the PDP-10. There&#x27;s at least one PDP-10 C compiler (Alan Snyder&#x27;s) where all the primitive types, including char, are 36 bits...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor890629"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2022 14:35 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/890629/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not quite: <a rel="nofollow" href="https://nw0.github.io/cheri-rust.pdf">https://nw0.github.io/cheri-rust.pdf</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890629/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor889517"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 9:31 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/889517/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>One thing that adds weight to your notion that they'll not go beyond 57 bits of VA space is that thus far, each page level in x86-64 adds 9 bits of VA space (because that fills an entire 4K page), and apart from the PTEs having their PAT bit in a different place to PDE and PDPTE (the PTE place for PAT is used in all higher level tables for "stop paging here, this is a large page"), the levels are all identical layouts.
<p>And a second thing is the existence of Arm Morello as an implementation that supports the <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-951.pdf">CHERI capabilities model</a> (effectively 129 bit pointers consisting of a hidden "is a valid pointer" bit, then 64 bits used for compressed bounds, permissions and an object type field, 64 bits for an address). If Morello demonstrates that CHERI capabilities can be made to work well and have significant benefits while not hurting existing code, then Intel or AMD may well want to expand chapter 6 of the CHERI paper into a full design.


      
          <div class="CommentReplyButton">
            <form action="/Articles/889517/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor889479"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 21:23 UTC (Mon)
                               by <b>abufrejoval</b> (guest, #100159)
                              [<a href="/Articles/889479/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
x86-CFI, ARM memory tagging extensions and CHERI are ultimately just stopgap measures, ultimately capability based addressing or something similar needs to break these PDP/VAX based notions of a fully qualified global shared address space.<br>
<p>
Best get started earlier fixing this properly than pushing this along with these half-hearted approaches that just pile on more legacy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889479/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 21:42 UTC (Mon)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/889490/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; ultimately capability based addressing or something similar needs to break these PDP/VAX based notions of a fully qualified global shared address space.</font><br>
<p>
you mean you want x86 segmentation fully reinstated for AMD64?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 21:58 UTC (Mon)
                               by <b>abufrejoval</b> (guest, #100159)
                              [<a href="/Articles/889492/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please leave the Intel box: the PDP-11 (and many others) was segmented, long before the 8086 did it with a static offset.<br>
<p>
But generally speaking the old guys in the 1960&#x27;s were much less restrained by todays VAX legacy and had some pretty cool ideas (and implementations like the IBM i-Series). There is a lot of inspiration to be found by looking back at what they had theorized on and implemented back then.<br>
<p>
Please note that capability based security is finding its way back in projects like Google&#x27;s Fuchsia and many others really concerned about the long term viability of the von Neumann/Princeton memory model.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 23:33 UTC (Mon)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/889503/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe you should take another look at protected mode segmentation then.<br>
<p>
It&#x27;s very very much like a capabilities bases permissions system (and very very much unlike the 8086 segmentation that was only for getting around the 16-bit limit).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor889508"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 3:01 UTC (Tue)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/889508/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Everywhere I turn I see portions of the ideas that were in the mill computer&#x27;s far more unified versions, gradually being retrofitted into existing architectures.<br>
<p>
I wish they&#x27;d build it, even just as a virtual machine. It would help people to think better about where we should have started going in the 90s, especially securitywise, when it came to cpu architectures.<br>
<p>
Take out some popcorn and watch their talk about security... <a href="https://millcomputing.com/docs/#security">https://millcomputing.com/docs/#security</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889508/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 5:03 UTC (Tue)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/889514/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there any prospect of Mill resulting in some gateware or hardware that people can use? Or will it remain something that doesn&#x27;t exist outside the designers minds, talks, documentation and patents?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor889581"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 15:11 UTC (Tue)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/889581/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But the Mill is legit crazy. I forget whether they track dirtiness on a per byte or per bit level, but that level of detail in tracking dirtiness can only hurt. If anything, we should track dirtiness at a super-cache-line level and move things around in a group of two or four cache lines. Of course, that comes with a false sharing problem, which is why it hasn&#x27;t happened yet.<br>
<p>
There&#x27;s always trade-offs and people can have a real conversation about whether 32, 64 or 128 bytes is the correct size of a cache line, but there&#x27;s a knee to this curve and 1-4 bytes is outside the scope of sane conversation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889581/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor889491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 21:48 UTC (Mon)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/889491/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not worried about the legacy added by these new measures: we&#x27;ll need a whole new architecture for (insert new memory addressing scheme here), which means we can ignore most portability problems.  Since apps already have to account for systems that don&#x27;t support this newfangled technology anyways, and porting to an entirely new addressing scheme will probably require work for any application doing low-level shenanigans like memory tagging, it&#x27;s not like this hurts anything.<br>
<p>
Besides, inventing a new magic CPU architecture that fixes all our problems will take years.  In the meantime, lets try and use the stopgap measures to get as much performance and power efficiency as we can.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 22:05 UTC (Mon)
                               by <b>abufrejoval</b> (guest, #100159)
                              [<a href="/Articles/889494/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I do agree with you in a way, this topic keeps reminding me of the climate change debate: we all know something needs to be done, but nobody seems to work on solutions with the proper level of forward looking research.<br>
<p>
And we should at least invest into making sure that new code can be written without fully qualified pointers (somewhat like Rust vs. Cx).<br>
<p>
Finding ways to defuse pointers seems pretty easy compared to saving the planet, especially when potential architectures have already been proposed decades ago...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889497"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 22:39 UTC (Mon)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/889497/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You know, “next” architectures have been tried before - several times, including with huge amounts of $$$ behind them (Alpha, Itanic, others).  For the last few decades at least, they’ve been losing out to extensions/cleanups of the existing models.<br>
<p>
It’s not obvious to me these thoughts about addressing will be different.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889497/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889522"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 10:38 UTC (Tue)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/889522/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The big problem with "next" architectures is that they don't have access to all the decades of experience conventional architectures do, but the first generation is expected to be at least competitive. If the general conclusion is that "this would be good if they changed x, y and z", it's probably too late (especially if changing those features can't be done while keeping compatibility). I'm hoping that ARM has learnt that lesson and aren't trying to productise CHERI too soon.
<p><b>Examples</b><br>
Take MIPS and SPARC as successful "next" architectures -- tremendously influential, but with a number of features which later RISC designs dropped.
<p>i432 -- <a href="https://www.sigmicro.org/media/oralhistories/colwell.pdf">Bob Colwell</a> (one of the lead designers of the Pentium Pro and Pentium 4) is fascinating on the subject: he says that both hardware and software engineers dropped the ball on performance. If they hadn't -- if they'd got to within 50% of competitive on performance, with security and reliability improvements, there would have been a market for the chip.
<p>
Itanium -- the <em>big</em> lesson they should have learnt before they ploughed billions into hardware and software is "can we actually provide compilers that do what we say they can", but it's at least arguable there were other mistakes. I seem to remember that when compilers scheduled Itanium programs, they used cycle timings from the current processors -- in particular, fast level 1 cache. That meant that a (theoretical) high-clocking Itanium with caches that were slower in terms of cycles (but not in nanoseconds) would spend a disproportionate amount of time waiting for data from cache when running existing binaries, so Intel didn't produce a system like that. 
<p>
I really don't think that Alpha counts as "next" for anything other than performance -- and dominating the CPU performance tables throughout the 1990s, then getting dropped for business reasons, doesn't exactly count as an engineering failure.









      
          <div class="CommentReplyButton">
            <form action="/Articles/889522/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 13:24 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/889532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>CHERI has a decent chance, because it's designed to let you have a "legacy" capability that gives code all the permissions it had before CHERI came into existence; the theory is that you'll start your porting with all of the kernel and userspace pointers living in the legacy capability, and then gradually narrow things down over time, rather than having to do a big bang port. The idea is that you can put capabilities in place at the edges, and move inwards over time, to have a tiny trustworthy core that has "full" capabilities, and that simply restricts the capabilities on offer as you head further from the core.
<p>One more thing I'd add to your Itanium example; the simulations that justified Itanium's design compared hand-written "perfect" Itanium code to current compiler output for x86. With hindsight, the thing that they could easily have seen up-front and didn't spot is that the compiler improvements needed for EPIC also improved performance of compiled code for OoOE, and thus their predicted performance advantage wasn't nearly as good as it could be because OoOE also benefited from their compiler improvements.


      
          <div class="CommentReplyButton">
            <form action="/Articles/889532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor889501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 23:21 UTC (Mon)
                               by <b>jrtc27</b> (subscriber, #107748)
                              [<a href="/Articles/889501/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; x86-CFI, ARM memory tagging extensions and CHERI </font><br>
<p>
CHERI is not like the other two, it *is* full capability-based addressing; the C stands for Capability<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor889495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 22:11 UTC (Mon)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/889495/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <i>Perhaps the most fundamental of those is that UAI allows the most-significant bit of the address to be used by user space. In current systems, only kernel-space addresses have that bit set. Turning on UAI would allow user space to create pointer values that look like kernel addresses, but which would actually be valid user-space pointers.</i>

<p>
Couldn't this be changed so that the most significant non-UAI bit, instead of the most significant bit, would be used to distinguish kernel addresses?



      
          <div class="CommentReplyButton">
            <form action="/Articles/889495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2022 23:36 UTC (Mon)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/889504/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That would add significant overhead to basically all code paths that need to check a pointers validity<br>
<p>
(to be clear: any overhead to those code paths will be significant)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889590"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 16:36 UTC (Tue)
                               by <b>imMute</b> (guest, #96323)
                              [<a href="/Articles/889590/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How would checking if bit 47 was set be any more expensive than checking bit 63?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889590/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 16:44 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/889591/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>Bit 63 of a 64 bit register is the sign bit if you're interpreting the register contents as a signed integer; it thus has special handling to make it easier to check. <tt>test rax, rax ; jl error</tt> will jump to the label <tt>error</tt> if the pointer in rax has bit 63 set. <tt>test</tt> doesn't support a 64 bit immediate, so you need to free up a register, or accept the slowdown from accessing memory, if you want to check any bits other than 63.


      
          <div class="CommentReplyButton">
            <form action="/Articles/889591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889609"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2022 22:00 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/889609/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>Why would you need <code>test</code> for that? Just use <code>bt rax, 47; jc error</code> and that's it.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/889609/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889622"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 8:33 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/889622/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Because <tt>test</tt> is friendlier to the OoOE machinery on modern CPUs than <tt>bt</tt>, and hence faster to execute. As this is pure overhead in the absence of bugs and/or malicious code attacking the kernel, we want it to be as lightweight as possible so as to spend more CPU resource doing useful work, and less CPU resource validating that userspace hasn't gone insane.
<p>Using <a href="https://www.agner.org/optimize/instruction_tables.pdf">Agner's instruction table PDF</a>, <tt>test reg, reg</tt> has had a lower reciprocal throughput than <tt>bt reg, imm</tt> since IvyBridge on Intel's high performance side, and since Intel Haswell processors, up until the latest Xeons, can be executed on more execution ports than <tt>bt reg,imm</tt>. On the low power Intel side (Atom from Silvermont onwards), <tt>test reg, reg</tt> takes one execution unit instead of both on Silvermont, and has 3x the throughput on Goldmont.
<p>On the AMD side, <tt>test reg, reg</tt> becomes higher throughput than <tt>bt reg, imm</tt> in Excavator cores, returns to be equally cheap for Zen 1 and Zen 2, and then <tt>test reg, reg</tt> becomes cheaper than <tt>bt reg, imm</tt> in Zen 3. In the low power cores (Bobcat, Jaguar), the cost is the same for either instruction.
<p>Hence the preference for <tt>test reg, reg</tt> over <tt>bt reg, imm</tt> - there are no CPUs on Agner's list where <tt>bt</tt> is faster than <tt>test</tt>, but there are several cores, including the current high performance µarches from Intel and AMD, where <tt>test</tt> is cheaper to execute than <tt>bt</tt>.



      
          <div class="CommentReplyButton">
            <form action="/Articles/889622/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889629"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 10:21 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/889629/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I'm not asking about why you would use 63th bit instead of 47th if you have a choice.</p>

<p>But we are discussing here AMD-only features and you say that one would <i>need to free up a register, or accept the slowdown from accessing memory</i>. That's not true. If these future CPUs have fast enough <code>bt</code> then there would be no slowdown (at least if that would be CPU-specific kernel build which is often acceptable for servers or things like ChromeOS).</p>

<p>Yes, you probably couldn't build an universal kernel which is both supporting UAI and Intel CPUs, but that's another, separate, issue.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/889629/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 13:59 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/889631/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>If we change future CPUs to have a fast <tt>bt</tt>, then yes, we can use it instead of the <tt>test</tt> instruction that's faster on AMD EPYC processors.
<p>But if we change UAI to not use bit 63 as part of the tag, then we could avoid the whole problem, too. And given that both Intel and AMD have changed from having <tt>bt reg, imm</tt> be as fast as <tt>test reg, reg</tt> to having <tt>test reg, reg</tt> be faster than <tt>bt reg, imm</tt>, I think a fix to UAI is almost certainly the simpler route.
<p>This is especially true because UAI is the new thing - if making <tt>bt</tt> fast was worthwhile for things other than <tt>bt</tt>, then we'd have done it already. Making <tt>test reg, reg</tt> fast is worthwhile because it's a common idiom used by compilers for testing the relationship between a register and 0, so having it be fast speeds up other code.
<p>Plus, your example code <tt>bt reg, 47</tt> is buggy in its own right if AMD ever implement 5-level paging, and is buggy on Intel chips that exist today with 5 level paging. And, on top of that, if AMD do implement 5 level paging, UAI would leave no bit that can be uniquely used to distinguish kernel and user addresses, so there's no way to make the <tt>bt</tt> solution work reliably (with 5 level paging, bits 56 to 0 are VA bits, leaving 7 bits at bit 57 to 63 not translated, but UAI permits userspace processes to convert bits 63 to 56 into tag bits). Intel, at least, left bit 63 spare, and said that you get 6 tag bits with 5 level paging, or 15 with 4 level.


      
          <div class="CommentReplyButton">
            <form action="/Articles/889631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor889949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 7:57 UTC (Fri)
                               by <b>ecm</b> (guest, #129897)
                              [<a href="/Articles/889949/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While jl may work to branch depending on the most significant bit, the idiomatic choice is js/jns, &quot;jump if (not) sign bit set&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor889642"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 13:51 UTC (Wed)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/889642/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;test rax, rax; js&quot; is smaller than &quot;bt rax, 47; jc&quot;<br>
<p>
0000000000000000 &lt;f&gt;:<br>
   0:   48 85 c0                test   rax,rax<br>
   3:   48 0f ba e0 3f          bt     rax,0x3f<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889642/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor889702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 16:00 UTC (Wed)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/889702/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not use low bit instead ?<br>
After all unaligned accesses are not supported anymore so all pointers start with 3 zero bits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 17:17 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/889713/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That means you need to manually mask off the bits before any actual dereference instead of the hardware supporting &quot;I ignore the upper bits&quot; support.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2022 9:57 UTC (Sun)
                               by <b>dcoutts</b> (subscriber, #5387)
                              [<a href="/Articles/890084/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is exactly how GHC&#x27;s pointer tagging works.<br>
<p>
<a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/haskell-execution/pointer-tagging">https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2022 12:08 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/890087/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s fine in a language which hides raw pointers from you in the first place. I think I&#x27;d prefer using the upper bits in C if the CPU had support for ignoring them for me rather than asking &quot;umm, did I remember to mask this out properly?&quot; before any pointer dereference.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2022 12:01 UTC (Mon)
                               by <b>dcoutts</b> (subscriber, #5387)
                              [<a href="/Articles/890149/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, it would be a nightmare in C. I guess it&#x27;d be doable in C++.<br>
<p>
This hardware feature is for almost certainly for performance though, not convenience. My guess is that it&#x27;s primarily aimed at JVMs and similar.<br>
<p>
I don&#x27;t know for sure, but I&#x27;d guess that doing pointer tagging in software (and thus having to untag before dereferencing) is cheaper to do for the low bits than the high bits. That is, cheaper in terms of the extra instructions and their sizes. But then when doing it in hardware, a hardware impl can do it cheaply either way, and given that there&#x27;s more bits available at the high end, it makes sense to use the high bits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor890336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2022 6:51 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/890336/">Link</a>] 
      </p>
      
      </div>
      </summary>
      In many cases you know when using the address what the tag is, and then you can just use an offset at no or very low extra cost.  E.g., if tag 3 means that we have a pointer to a cons cell, then car (aka head) accesses the machine word at offset -3, while cdr (tail) accesses the word at offset 5.

<p>Low-bit tagging is used when 3, maybe 4 bits of tags are enough.  If you need more, it becomes impractical, and you use high-bit tagging.


      
          <div class="CommentReplyButton">
            <form action="/Articles/890336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor889767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2022 23:25 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/889767/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When accessing a single-byte (e.g. ASCII character) the low bit is a meaningful bit.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor889953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">why not use low bit instead ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 8:13 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/889953/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; After all unaligned accesses are not supported anymore </font><br>
<p>
Says who?<br>
<p>
<font class="QuotedText">&gt; so all pointers start with 3 zero bits.</font><br>
<p>
Yes as long as you use only 64 bits values.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor889951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 8:07 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/889951/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It sounds like a recipe for ongoing security problems, ...</font><br>
<font class="QuotedText">&gt; ....</font><br>
<font class="QuotedText">&gt; In the early days of Linux, kernel developers had to adapt to whatever the hardware manufacturers put out; the alternative was to not have hardware to run on at all. In 2022, though, those developers feel more confident in their ability to reject support for hardware features that, for whatever reason, they feel do not fit in well with the design of the system. </font><br>
<p>
In the early days, software developers trusted CPU designs. Sure there were a couple bugs now and then but nothing huge. Then came spectre and friends...<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor892760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer tagging for x86 systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2022 8:35 UTC (Wed)
                               by <b>cavok</b> (subscriber, #33216)
                              [<a href="/Articles/892760/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn&#x27;t all this pointer tagging affect address randomization as well?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/892760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
