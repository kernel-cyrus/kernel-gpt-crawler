        <!DOCTYPE html>
        <html lang="en">
        <head><title>The RCU API, 2019 edition [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/777036/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/776990/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/777036/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The RCU API, 2019 edition</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="GAByline">
           <p>January 23, 2019</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<p>Read-copy update (RCU) is a synchronization mechanism that was added to
the Linux kernel in October 2002.
RCU is most frequently described as a replacement for reader-writer locking,
but has also been used in a number of other ways.
RCU is notable in that readers do not directly synchronize with
 updaters,
which makes RCU read paths extremely fast; that also
permits RCU readers to accomplish useful work even
when running concurrently with updaters.
Although the basic idea behind RCU has not changed in
decades following its introduction into DYNIX/ptx, the API has
evolved significantly over the five years since the
<a href="/Articles/609904/">2014 edition of the RCU API</a>,
to say nothing of the nine years since the
<a href="/Articles/418853/">2010 edition of the RCU API</a>.

<p>
The most recent five years of this evolution is described in the
following sections:
</p>

<ul class="spacylist">
<li>	<a href="#Summary of RCU API Changes">
	Summary of RCU API changes</a>
</li><li>	<a href="#RCU%20has%20a%20Family%20of%20Wait-to-Finish%20and%20Data-Access%20APIs">
	RCU has a family of wait-to-finish and data-access APIs</a>
</li><li>	<a href="#RCU%20has%20List-Based%20Publish-Subscribe%20and%20Version-Maintenance%20APIs">
	RCU has list-based publish-subscribe and version-maintenance APIs</a>
</li><li>	<a href="#How Did Those 2014 Predictions Turn Out?">
	How did those 2014 predictions turn out?</a>
</li><li>	<a href="#What Next for the RCU API?">
	What next for the RCU API?</a>
</li>
</ul>

<p>These sections are followed by the
<a href="#Answers%20to%20Quick%20Quizzes">answers to the quick quizzes</a>.
There is also a sidebar article on <a href="/Articles/777214">
	Kernel configuration parameters for RCU</a>.
</p>

<a name="Summary of RCU API Changes"></a>
<h4>Summary of RCU API changes</h4>

<p>The following sections summarize some of the most visible changes to RCU since
the 2014 article.

<a name="RCU Flavor Consolidation"></a>
<h4>RCU flavor consolidation</h4>

<p>The big change is the consolidation of the RCU bh, RCU preempt, and
RCU sched flavors, which was carried out in response to an exploitable bug
resulting from confusion between two flavors.
The bug naturally led Linus Torvalds to call for a long-term solution,
which ended up being this consolidation.

<p>Before this consolidation, these flavors could be accessed using different
APIs, for example, in <code>CONFIG_PREEMPT=y</code> kernels,
waiting for a grace period is done via <code>synchronize_rcu_bh()</code>
for RCU bh, via <code>synchronize_rcu()</code> for RCU preempt, and via
<code>synchronize_sched()</code> for RCU sched.
Similarly, in <code>CONFIG_PREEMPT=n</code> kernels,
<code>synchronize_rcu_bh()</code> is again used for RCU bh, but
either <code>synchronize_rcu()</code> or <code>synchronize_sched()</code>
may be used for RCU sched, given that RCU preempt does not exist
in <code>CONFIG_PREEMPT=n</code> kernels.

<p>After consolidation (Linux 4.20 or later), a given running kernel has but
one flavor of RCU, namely RCU preempt in <code>CONFIG_PREEMPT=y</code>
kernels and RCU sched in <code>CONFIG_PREEMPT=n</code> kernels.
This works because RCU preempt now waits for the completion of
bh-disable, irq-disable, and preempt-disable regions of code in addition
to the traditional <code>rcu_read_lock()</code>-style RCU read-side
critical sections.
Therefore, the vanilla RCU update-side primitives may be used in place
of their RCU bh and RCU sched counterparts.
Specifically:

<ul class="spacylist">
<li>	<code>synchronize_rcu()</code> may be used in place of
	<code>synchronize_rcu_bh()</code> and <code>synchronize_sched()</code>,
	as well as all current uses of
	<code>synchronize_rcu_mult()</code>.
<li>	<code>synchronize_rcu_expedited()</code> may be used in place of
	<code>synchronize_rcu_bh_expedited()</code> and
	<code>synchronize_sched_expedited()</code>.
<li>	<code>call_rcu()</code> may be used in place of
	<code>call_rcu_bh()</code> and <code>call_rcu_sched()</code>.
<li>	<code>rcu_barrier()</code> may be used in place of
	<code>rcu_barrier_bh()</code> and <code>rcu_barrier_sched()</code>.
<li>	<code>get_state_synchronize_rcu()</code> and
	<code>cond_synchronize_rcu()</code> may be used in place of
	<code>get_state_synchronize_sched()</code> and
	<code>cond_synchronize_sched()</code>, respectively.
</ul>

<div class="tlrw">
<a name="Quick Quiz 1"></a><b>Quick Quiz 1</b>:
Why do <code>synchronize_rcu_mult()</code>,
<code>get_state_synchronize_sched()</code>, and
<code>cond_synchronize_sched()</code> have both blue and red backgrounds?
<a href="#qq1answer">Answer</a>
</div>

<p>The intent is to retire these RCU bh and RCU sched update-side APIs
(along with <code>synchronize_rcu_mult()</code>,
as indicated by the red backgrounds in those cells of
<a href="/Articles/777165/#RCU Per-Flavor API Table">the big API table</a>
(see the <a href="/Articles/777165/#Key">key</a>).

<div class="tll">
<a name="Quick Quiz 2"></a><b>Quick Quiz 2</b>:
Doesn't this consolidation also mean that it is no longer possible
to wait only on preempt-disable regions of code in
<code>CONFIG_PREEMPT=y</code> kernels?
<a href="#qq2answer">Answer</a>
</div>

<p>In addition, the RCU bh and RCU sched read-side APIs may now be used
with the vanilla RCU update-side APIs, as shown in blue in the
"RCU" column of
the big API table,
However, these read-side APIs are still separate, for example,
<code>rcu_dereference()</code> will still give a lockdep complaint if it is
used under <code>rcu_read_lock_bh()</code> instead of the matching
<code>rcu_read_lock()</code>.

<div class="tlrw">
<a name="Quick Quiz 3"></a><b>Quick Quiz 3</b>:
Why not also remove <code>rcu_read_lock_bh()</code>,
<code>rcu_read_unlock_bh()</code>, <code>rcu_read_lock_sched()</code>,
and <code>rcu_read_unlock_sched()</code>?
<a href="#qq3answer">Answer</a>
</div>

<p>
This change does simplify RCU updaters, for which developers no longer
need to gingerly select an RCU update API that matches the readers.
However, nothing comes for free, and in this case the price is that
extra care is required for certain backports.</p>

<div class="tlr">
<a name="Quick Quiz 4"></a><b>Quick Quiz 4</b>:
How about doing something more reliable by, for example, making the
compiler complain about such backports?
<a href="#qq4answer">Answer</a>

<br><br><a name="Quick Quiz 5"></a><b>Quick Quiz 5</b>:
Might we all be better off if the RCU flavors had remained unconsolidated?
<a href="#qq5answer">Answer</a>
</div>

<p>
To see this, suppose that a bug was introduced in v4.17 in which
a <code>synchronize_sched()</code> was omitted.
Suppose further that this bug was fixed in v5.10 by adding a
<code>synchronize_rcu()</code>.
If this was a serious bug, it would of course need to be backported
to the various -stable releases.
Except that the <code>synchronize_rcu()</code> must be changed to
<code>synchronize_sched()</code> for v4.19 and earlier.
The current thought is that high-risk patches will be flagged by the
-stable scripting so that yours truly (and hopefully also the
respective maintainers) can inspect them.</p>

<p>This RCU flavor consolidation is the most profound change since 2014,
but there have also been a number of other changes worth noting.
The next section deals with a few additions to the sleepable RCU (SRCU) API.

</p>
<a name="Addition of RCU Tasks"></a>
<h4>Addition of RCU tasks</h4>

<div class="tlrw">
<a name="Quick Quiz 6"></a><b>Quick Quiz 6</b>:
Why not modify the scheduler-clock interrupt to check for user-mode execution?
<a href="#qq6answer">Answer</a>

<br><br><a name="Quick Quiz 7"></a><b>Quick Quiz 7</b>:
Why not force a tasks RCU quiescent state by preempting all currently
executing tasks?
<a href="#qq7answer">Answer</a>
</div>

<p><a href="/Articles/607117/">RCU tasks</a> has voluntary context switch
and user-space execution as 
its sole quiescent states, but applies only to non-idle tasks.
This form of RCU is used by Ftrace and kprobes to manage the lifetime
of "trampolines" containing the executable code used by
 these two facilities.
The RCU tasks API consists of only <code>synchronize_rcu_tasks()</code>
and <code>call_rcu_tasks()</code>, although many of the generic RCU APIs
may be pressed into service as well.
Note that this implementation exists only in <code>CONFIG_PREEMPT=y</code>
kernels; otherwise <code>synchronize_rcu_tasks()</code> is just another
name for <code>synchronize_rcu()</code> and <code>call_rcu_tasks()</code>
is just another name for <code>call_rcu()</code>.

<p>It is important to note that RCU tasks grace periods can be quite
long, in fact, the shortest they can be is about 100&nbsp;milliseconds.
On a busy system, they could range up into the tens of seconds and
perhaps even minutes.</p>

<a name="SRCU Updates"></a>
<h4>SRCU updates</h4>

<div class="tlr">
<a name="Quick Quiz 8"></a><b>Quick Quiz 8</b>:
Why is extreme caution required for <code>call_srcu()</code>
and <code>srcu_barrier()</code>?
<a href="#qq8answer">Answer</a>
</div>

<p>Although the SRCU API has changed little since
2014,
SRCU itself has been reimplemented (almost) from scratch one
more time to provide much greater update-side scalability.
It still handles readers in the idle loop and even from offline CPUs.
One thing that has not changed is the need for extreme caution when
using <tt>call_srcu()</tt>.

<p>Because SRCU is now used in tracepoint code, there are now
<code>_notrace()</code> variants of
<code>srcu_read_lock()</code>,
<code>srcu_read_unlock()</code>, and
<code>srcu_dereference()</code>.
There is also a new <code>cleanup_srcu_struct_quiesced()</code>
that is similar to <code>cleanup_srcu_struct()</code>, except that it
prints an error to the console if it detects continued use of
the <code>srcu_struct</code> in question.
In contrast, <code>cleanup_srcu_struct()</code> will flush the
<code>srcu_struct</code> structure's workqueues, but then blindly trust
the caller beyond that point, which is easier to use, but can
also result in hard-to-debug memory corruption.

</p>
<a name="Abolition of RCU-Protected Array Indexes"></a>
<h4>Abolition of RCU-protected array indexes</h4>

<p>The RCU API has long permitted RCU-protected array indexes, but it
turned out that these were used only in one place in x86-specific code.
Because x86 has relatively strong total store order (TSO)
<a href="https://en.wikipedia.org/wiki/Memory_ordering">memory ordering</a>, <code>rcu_dereference_index_check()</code> may be
replaced with <code>smp_load_acquire()</code> on x86 with little or no
performance penalty.
In other words, in the only place using <code>rcu_access_index()</code>
and <code>rcu_dereference_index_check()</code>, they were not helping
much.</p>

<div class="tlr">
<a name="Quick Quiz 9"></a><b>Quick Quiz 9</b>:
Given that dependencies are quite natural and intuitive, what excuse
would compilers have for breaking them?
And why isn't this bug being fixed?
<a href="#qq9answer">Answer</a>
</div>

<p>In addition, both <code>rcu_dereference()</code> (and friends)
and <code>rcu_dereference_index_check()</code> rely on the compiler
to preserve dependencies from those two invocations to any later
dereferencing of the returned pointer.
Neither the C nor the C++ standard make any sort of dependency-preservation
guarantee, and compilers much more aggressively optimize integer
expressions than pointer expressions, which means that dependencies carried
by integers are more likely to be broken than those carried by pointers.
The
<a href="https://www.kernel.org/doc/Documentation/RCU/rcu_dereference.txt">rules</a>
for preventing the compiler from breaking dependencies carried by pointers
are complex enough, and so it seemed best to remove integers from the mix.
</p>

<a name="New Data-Access RCU API Members"></a>
<h4>New data-access RCU API members</h4>

<p>It is not unusual to fetch the value of an RCU-protected pointer,
and then use <code>rcu_assign_pointer()</code> to update it, preferably
under the protection of the relevant update-side lock.
The shiny new <code>rcu_swap_protected()</code> combines this into
a single call, saving a few lines of code.

<p>It is also not unheard of to access some data under RCU protection,
but to also sometimes use some other synchronization mechanism in cases
where longer-term protection is required.
For example, the <code>__i915_gem_active_get_rcu()()</code> function
picks up a pointer under RCU protection and, while still under RCU
protection, checks to see if the corresponding operation has completed.
If so, it returns a <code>NULL</code> pointer, for which no protection
of any kind is required.
Otherwise, it acquires a reference and returns the pointer,
thus no longer needing RCU protection.
The <code>rcu_pointer_handoff()</code> macro is used to document
this hand-off from RCU to reference counter, and will hopefully also be
useful to the hoped-for RCU pointer-leak diagnostic tools.

</p>
<a name="RCU Validation API Changes"></a>
<h4>RCU validation API changes</h4>

<p>The <code>rcu_cpu_stall_reset()</code> function is used to suppress
<a href="https://www.kernel.org/doc/Documentation/RCU/stallwarn.txt">RCU CPU stall warnings</a>
(also see this presentation
<a href="https://www.youtube.com/watch?v=23_GOr8Sz-E">video [YouTube]</a> and
these <a
href="http://www.rdrop.com/~paulmck/RCU/stallwarning.2018.01.22a.pdf">slides
[PDF]</a>).
Such suppression is useful in diagnostic code which might itself
cause an RCU CPU stall warning, or where a more specific diagnostic
for the condition causing the warning has already been emitted.

<p>The <code>rcu_head_init()</code> and <code>rcu_head_after_call_rcu()</code>
functions can be used to check whether a given <code>rcu_head</code>
structure has already been passed to <code>call_rcu()</code>.
The usage pattern is to invoke <code>rcu_head_init()</code> at allocation
or initialization time, and then invoke
<code>rcu_head_after_call_rcu()</code> thereafter, which will return
true if that structure has already been passed to
<code>call_rcu()</code>.
If desired, <code>rcu_head_init()</code> could be invoked within the
callback function to retrigger, but in that case providing any needed
ordering with concurrent calls to <code>rcu_head_after_call_rcu()</code>
is the caller's responsibility.

<p>The old <code>rcu_lockdep_assert()</code> facility has been renamed
to <code>RCU_LOCKDEP_WARN()</code> for better alignment with other
warnings.
Note that the sense of the argument has also reversed, as would be
expected when switching from an assertion to a warning.

<p>The new <code>rcu_sleep_check()</code> emits a lockdep complaint
if invoked within any flavor of RCU read-side critical section.
Of course, because SRCU is sleepable, <code>rcu_sleep_check()</code>
emits no complaints if used within an SRCU read-side critical section.

</p>
<a name="RCU-Protected List Changes"></a>
<h4>RCU-protected list changes</h4>

<p>A number of new RCU list macros were added.
The first set traverses lists protected by RCU-like
mechanisms that do not require RCU read-side markers such as
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>.
One trivial example of such an RCU-like mechanism involves lists
to which elements may be added but never removed.
For this and similar cases, <code>list_for_each_entry_lockless()</code>
traverses the list and <code>list_entry_lockless()</code> translates
from a <code>list_head</code> pointer to a pointer to the enclosing
structure.

<p>A couple additional traversal-resumption primitives have been added,
namely <code>list_for_each_entry_from_rcu()</code> for normal lists and
<code>hlist_for_each_entry_from_rcu()</code> for hash lists (hlists).
A <code>hlist_nulls_for_each_entry_safe()</code> macro now allows
deletion during traversal of hlist_nulls lists.
Finally, a new <code>list_next_or_null_rcu()</code> allows easier
stepwise traversal of normal lists by permitting the conventional
check of the pointer against <code>NULL</code>.

<p>The name of <code>hlist_add_after_rcu()</code> was changed to
<code>hlist_add_behind_rcu()</code> to assist a change in the order
of arguments to this macro.
In addition, a new <code>hlist_add_tail_rcu()</code> function allows
easier appending to the ends of hlists.

<p>Finally, <code>list_splice_tail_init_rcu()</code> allows an
RCU-protected list to be spliced onto the tail of another list.

<a name="RCU has a Family of Wait-to-Finish and Data-Access APIs"></a>
<h4>RCU has a family of wait-to-finish and data-access APIs</h4>

<p>RCU is a four-member family of APIs as shown
in the table,
with four columns corresponding to one of the family members and
the last column containing generic APIs that apply across families.
If you are new to RCU, you might consider focusing on just one
of the columns in the big RCU API table.
For example, if you are primarily interested in understanding how RCU
is most frequently used in the Linux kernel, "RCU"
would be the place to start.
On the other hand, if you want to understand RCU for its own sake,
"SRCU" has the simplest API, though to a lesser extent
than in the past.
In both cases, you will need to refer to the final "Generic"
column.
You can always come back to the other columns later.
If you are already familiar with RCU, this table can
serve as a useful reference.

</p><p>As illustrated by the
key,
the green-colored RCU API members are those that
existed back in the 1990s, a time when I was under the delusion
that I knew all that there is to know about RCU.
The blue-colored cells correspond to the RCU API members that are new
since the
2014 RCU API documentation
came out.
The red-colored cells corresponding to RCU API members that have
been deprecated (or removed entirely) since the
2014 RCU API documentation
came out.

</p><p>The "RCU" column corresponds to the
original RCU implementation,
in which RCU read-side critical sections are delimited by
a wide assortment of markers for a wide range of varieties of
RCU readers, most famously
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>.
All of these markers may be nested.
RCU-protected data is accessed using <code>rcu_dereference()</code> and
<code>rcu_dereference_check()</code>, with the former used
within RCU read-side critical sections and the latter used by code
shared between readers and updaters.
In both cases, the pointers must be C-language <a href="https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue">lvalues</a>.
These read-side APIs are extremely lightweight, although the
two data-access APIs
execute a memory barrier on DEC Alpha.
RCU's performance and scalability advantages stem from the lightweight
nature of these read-side APIs.

</p><p>The corresponding synchronous update-side primitives,
<code>synchronize_rcu()</code>, along with its synonym
<code>synchronize_net()</code>, wait for any currently executing
RCU read-side critical sections to complete.
The length of this wait is known as a "grace period".
If grace periods are too long for you, <code>synchronize_rcu_expedited()</code>
speeds things up by about an order of magnitude, but at the expense of
significant CPU overhead and of latency spikes on other CPUs.
The asynchronous update-side primitive, <code>call_rcu()</code>,
invokes a specified function with a specified argument after a
subsequent grace period.
For example, <code>call_rcu(p,f)</code> will result in
the "RCU callback" <code>f(p)</code>
being invoked after a subsequent grace period.
There are situations,
<a href="/Articles/217484/">such as when unloading a module that uses
<code>call_rcu()</code></a>, 
when it is necessary to wait for all
outstanding RCU callbacks to complete.
The <code>rcu_barrier()</code> primitive does this job.
The <code>kfree_rcu()</code> primitive serves as a shortcut for
an RCU callback that does nothing but free the structure passed to it.
Use of <code>kfree_rcu()</code> can both simplify code and
reduce the need for <code>rcu_barrier()</code>.
Finally, the <code>rcu_read_lock_held()</code> may be used in assertions
and lockdep expressions to verify that RCU read-side protection is
in fact being provided.
This primitive is conservative, and thus can produce false negatives,
particularly in kernels built with <code>CONFIG_PROVE_RCU=n</code>.

</p><p>The "RCU BH" column contains the RCU bh primitives.
These are analogous to their RCU counterparts, and as noted
<a href="#RCU Flavor Consolidation">earlier</a>, the update-side
RCU bh primitives are deprecated in favor of their vanilla RCU counterparts.
This RCU API family was added to permit better handling of network-based
denial-of-service attacks, but this functionality has since been
incorporated into the vanilla RCU API.
Unrelated more-aggressive transitioning from softirq context to
the ksoftirqd kthreads has also helped immensely.</p>

<div class="tlr">
<a name="Quick Quiz 10"></a><b>Quick Quiz 10</b>:
What happens if you mix and match RCU and RCU sched?
<a href="#qq10answer">Answer</a>
</div>

<p>In the "RCU Sched" column, in addition to
<code>rcu_read_lock_sched()</code> and <code>rcu_read_unlock_sched()</code>,
anything that disables preemption also
acts as an RCU read-side critical section.
Other than that, the RCU sched primitives are analogous to their RCU
counterparts, though again the update-side RCU sched primitives are
deprecated in favor of their vanilla RCU counterparts.</p>

<div class="tlrw">
<a name="Quick Quiz 11"></a><b>Quick Quiz 11</b>:
Can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?
If so, why?  If not, why not?
<a href="#qq11answer">Answer</a>

<br><br><a name="Quick Quiz 12"></a><b>Quick Quiz 12</b>:
Why isn't there an
<code>smp_mb__after_rcu_read_unlock()</code>,
<code>smp_mb__after_rcu_bh_read_unlock()</code>, or
<code>smp_mb__after_rcu_sched_read_unlock()</code>?
<a href="#qq12answer">Answer</a>
</div>

<p>The "SRCU" column displays a specialized RCU API that permits
general sleeping in RCU read-side critical sections, as was
described in the LWN article
"<a href="/Articles/202847/">Sleepable RCU</a>".
SRCU is also the only RCU flavor whose read-side primitives may
be freely invoked from the idle loop and from offline CPUs.
Of course,
use of <code>synchronize_srcu()</code> in an SRCU read-side
critical section can result in
self-deadlock, so should be avoided.
SRCU differs from earlier RCU implementations in that the caller
allocates an <code>srcu_struct</code> for each distinct SRCU
usage, which must either be statically allocated using either
<code>DEFINE_SRCU()</code> or <code>DEFINE_STATIC_SRCU()</code> on the
one hand, or be initialized after dynamic allocation
using <code>init_srcu_struct()</code> on the other.
This approach prevents SRCU read-side critical sections from blocking
unrelated <code>synchronize_srcu()</code> invocations.
In addition, in this variant of RCU, <code>srcu_read_lock()</code>
returns a value that must be passed into the corresponding
<code>srcu_read_unlock()</code>.
There is also an <code>smp_mb__after_srcu_read_unlock()</code>
that, when combined with an immediately prior <code>srcu_read_unlock()</code>,
provides a full memory barrier.
When finished with a runtime-initialized <code>srcu_struct</code> structure,
pass it to either <code>cleanup_srcu_struct()</code> or
<code>cleanup_srcu_struct_quiesced()</code>, depending on how carefully
you control uses of this structure, though the latter is usually
preferable.
Finally, there is no counterpart to
RCU's <code>synchronize_net()</code> and <code>kfree_rcu()</code> primitives.

<p>The "RCU tasks" column corresponds to a
<a href="#Addition of RCU Tasks">newly added</a>
special-purpose RCU implementation intended for the removal of the
trampolines used by Ftrace and kprobes to handle the executable code
that they insert into the kernel.
RCU tasks features voluntary context switch and user-space execution as
its sole quiescent states, but applies only to non-idle tasks.
The RCU tasks API consists of only <code>synchronize_rcu_tasks()</code>
and <code>call_rcu_tasks()</code>, although many of the generic RCU APIs
may be pressed into service as well.

</p><p>The final column contains a few additional RCU APIs that apply
equally to all five flavors.

</p><p>The following primitives do initialization:

<ul class="spacylist">
<li>	<code>RCU_INIT_POINTER()</code> may be used instead of
	<code>rcu_assign_pointer()</code> to assign a value to an RCU-protected
	pointer in a few special cases where reordering from both the
	compiler and the CPU can be tolerated.
	These special cases are as follows:</li>
	<ul>
	<li>	You are assigning <code>NULL</code> to the pointer, or
	<li>	You have prevented RCU readers from accessing the
		pointer, for example, during initialization when
		RCU readers do not yet have a path to the pointer
		in question, or
	<li>	The pointed-to data structure whose pointer is being
		assigned has already been exposed to readers, and
		<ul>
		<li>	You have not made any reader-visible changes
			to the pointed-to data structure since then, or
		<li>	It is OK for readers to see the old state of
			the structure
		</ul>
		An example of this third case is when removing an element
		from an RCU-protected linked list, in which case that
		element's successor has already been exposed to readers.
	</ul>
<li>	<code>RCU_POINTER_INITIALIZER()</code> is used for compile-time
	initialization of RCU-protected pointers within a structure.
</ul>

<p>The following primitives access RCU-protected data:

<ul class="spacylist">
<li>	<code>rcu_access_pointer()</code> fetches an RCU-protected
	pointer in cases where ordering is not required.
	This primitive may be used instead of one of the
	<code>rcu_dereference()</code> group of primitives when
	only the value of the RCU-protected pointer is used without
	being dereferenced; for example, the RCU-protected pointer
	might simply be compared against <code>NULL</code>.
	There is therefore no need to protect against concurrent
	updates, and there is also no need to be under the protection
	of <code>rcu_read_lock()</code> and friends.
<li>	<code>rcu_dereference_protected()</code> primitive is used to
	access RCU-protected pointers from update-side code.
	Because the update-side code is using some other synchronization
	mechanism (locks, atomic operations, single updater thread,
	etc.), it does not need to put RCU read-side protections in
	place.
	This primitive also takes a lockdep expression, which can be
	used to assert that the right locks are held and that any
	other necessary conditions hold.
<li>	<code>rcu_dereference_raw()</code> disables lockdep checking,
	which allows it to be used in cases where the lockdep correctness
	condition cannot be expressed in a reasonably simple way.
	For example, the RCU list macros might be protected by any
	combination of RCU flavors and locks, so they use
	<code>rcu_dereference_raw()</code>.
	That said, some <code>_bh</code> list macro variants have
	appeared, so it is possible that lockdep-enabled variants
	of these macros will appear in the future.
	However, when you use <code>rcu_dereference_raw()</code>,
	please include a comment saying why its use is safe and
	why other forms of <code>rcu_dereference()</code>
	cannot be used.
<li>	<code>rcu_dereference_raw_notrace()</code> is similar to
	<code>rcu_dereference_raw()</code>, but additionally
	disables function tracing.
<li>	<code>rcu_assign_pointer()</code> acts like an assignment statement,
	but enforces store-release (as in <code>smp_store_release()</code>)
	ordering on both compiler and CPU as needed.
	The caller is responsible for providing any needed synchronization
	among updates.
<li>	<code>rcu_swap_protected()</code> is shorthand for a call to
	<code>rcu_dereference_protected()</code> followed by a call to
	<code>rcu_assign_pointer()</code>, thus updating an RCU-protected
	pointer and returning the previous value.
	Again, the caller is responsible for providing any needed
	synchronization among updates.
<li>	<code>rcu_pointer_handoff()</code> returns the value of the
	specified pointer, and indicates that something other than
	RCU now protects that pointer.
</ul>

<p>Finally, the following primitives do validation:

<ul class="spacylist">
<li>	<code>__rcu</code> is used to tag RCU-protected pointers, allowing
	<code>sparse</code> to check for misuse of such pointers.
<li>	<code>init_rcu_head_on_stack()</code> initializes an on-stack
	<code>rcu_struct</code> structure for debug-objects use.
	The <a href="/Articles/271614/">debug-objects subsystem</a> checks
	for memory-allocation 
	usage bugs, for example, double <code>kfree()</code>.
	If the kernel is built with
	<code>CONFIG_DEBUG_OBJECTS_RCU_HEAD=y</code>,
	this checking is extended to double <code>call_rcu()</code>.
	Although debug-objects automatically sets up its state for
	global variables and heap memory, explicit setup is required
	for on-stack variables, hence the
	<code>init_rcu_head_on_stack()</code>.
<li>	<code>destroy_rcu_head_on_stack()</code> must be used on
	any on-stack variable passed to
	<code>init_rcu_head_on_stack()</code> before returning
	from the function containing that on-stack variable.
<li>	<code>init_rcu_head()</code> and
	<code>destroy_rcu_head()</code> also initialize objects for
	debug-objects use and do cleanup, respectively.
	These are normally not needed because the first call to 
	<code>call_rcu()</code> will implicitly set up debug-objects
	state for non-stack memory.
	However, if that <code>call_rcu()</code> occurs in the memory
	allocator or in some other function used by debug-objects,
	this implicit <code>call_rcu()</code>-time invocation can
	result in deadlock.
	Functions called by debug-objects that also use <code>call_rcu()</code>
	should therefore manually invoke <code>init_rcu_head()</code>
	during initialization in order to break such deadlocks.
<li>	<code>rcu_cpu_stall_reset()</code> disables RCU CPU stall
	warnings for the remainder of the current grace period,
	or for <code>ULONG_MAX / 2</code> jiffies, whichever comes first.
	This is useful for diagnostics or debugging situations in
	which an RCU CPU stall warning is expected behavior and in
	which those warnings would not be helpful.
<li>	<code>rcu_head_init()</code> prepares an <code>rcu_head</code>
	structure for later calls to <code>rcu_head_after_call_rcu()</code>.
<li>	<code>rcu_head_after_call_rcu()</code> returns true
	if the <code>rcu_head</code> structure has been passed to
	<code>call_rcu()</code>.
<li>	<code>rcu_is_watching()</code> checks to see if the
	current code may legally contain RCU read-side critical
	sections.
	Examples of places where RCU read-side critical sections
	are <i>not</i> legal include the idle loop (but see
	<code>RCU_NONIDLE()</code> below) and offline CPUs.
	Note that SRCU read-side critical sections are legal
	anywhere, including in the idle loop and from offline CPUs.
<li>	<code>RCU_LOCKDEP_WARN()</code> is used to verify that
	the code has the needed protection.
	For example:
<pre>
    RCU_LOCKDEP_WARN(!rcu_read_lock_held(), "Need rcu_read_lock()!");
</pre>
	This is a way to enforce the toothless comments stating that
	the current function must be invoked within an RCU
	read-side critical section.
	But please note that the kernel must be built with
	<code>CONFIG_PROVE_RCU=y</code> for this enforcement
	to take effect.
<li>	<code>RCU_NONIDLE()</code> takes a C statement as its
	argument.
	It informs RCU that this CPU is momentarily non-idle,
	executes the statement, then informs RCU that this
	CPU is once again idle.
	Note that event tracing uses RCU, which means that
	if you are doing event tracing from the idle loop,
	you must use the <code>_rcuidle</code> form of the
	tracing functions, for example,
	<code>trace_rcu_dyntick_rcuidle()</code>.
<li>	<code>rcu_sleep_check()</code> complains if any sort of
	RCU read-side critical section is in effect in kernels
	built with <code>CONFIG_PROVE_RCU=y</code>.
</ul>

</p>
<a name="RCU has List-Based Publish-Subscribe and Version-Maintenance APIs"></a>
<h4>RCU has list-based publish-subscribe and version-maintenance APIs</h4>

<p>Fortunately, most of RCU's list-based publish-subscribe and
version-maintenance primitives shown in the
<a href="/Articles/777165/#RCU List APIs">this RCU List APIs table</a>
apply to all of the variants of RCU discussed above.
This commonality can in some cases allow more code to be shared,
which certainly reduces the API proliferation that would otherwise
occur.
However, it is quite likely that software-engineering considerations
will eventually result in variants of these list-handling primitives
that are specialized for each given flavor of RCU, as has in fact
happened with
<code>hlist_for_each_entry_rcu_bh()</code> and
<code>hlist_for_each_entry_continue_rcu_bh()</code>.
Alternatively, perhaps it will prove useful to consolidate the read-side
RCU flavors.

<p>The APIs in the first column of the
table
operate on the Linux kernel's
<code>struct&nbsp;list_head</code> lists, which are circular, doubly-linked
lists.
These primitives permit lists to be modified in the face of concurrent
traversals by readers.
The list-traversal primitives are implemented with simple instructions,
so are extremely lightweight, though they also
execute a memory barrier on DEC Alpha
(as does <code>READ_ONCE()</code> in recent kernels).
The list-update primitives that add elements to a list incur memory-barrier
overhead, while those that only remove elements from a list are implemented
using simple instructions.
The <code>list_splice_init_rcu()</code> and <code>list_splice_tail_init_rcu()</code>
primitives incur not only
memory-barrier overhead, but also grace-period latency, and are therefore
the only blocking primitives shown in the table.

</p><p>The APIs in the second column of the
table
operate on the Linux kernel's
<code>struct&nbsp;hlist_head</code>, which is a linear doubly linked list.
One advantage of <code>struct&nbsp;hlist_head</code> over
<code>struct&nbsp;list_head</code> is that the former requires only
a single-pointer list header, which can save significant memory in
large hash tables.
The <code>struct&nbsp;hlist_head</code> primitives in the table
relate to their non-RCU counterparts in much the same way as do the
<code>struct&nbsp;list_head</code> primitives.
Their overheads are similar to that of their list counterparts in the
first two categories in the table.

</p><p>The APIs in the third column of the
table
operate on Linux-kernel
hlist-nulls lists, which are made up of <code>hlist_nulls_head</code> and
<code>hlist_nulls_node</code> structures.
These lists have special multi-valued <code>NULL</code> pointers, which
have the low-order bit set to 1 with the upper bits available to the
programmer to distinguish different lists.
There are hlist-nulls interfaces for non-RCU-protected lists as well.

To see why this sort of list is useful,
suppose that CPU 0 is traversing such a list
within an RCU read-side critical section,
where the elements are allocated from a <code>SLAB_TYPESAFE_BY_RCU</code>
slab cache.
The elements could therefore be freed and reallocated at any time.
If CPU 0 is referencing an element while CPU 1 is freeing that element,
and if CPU 1 then quickly reallocates that same element and adds it to
some other list,
then CPU 0 will be transported to that new list along with the element.
In this case, remembering the starting list would clearly be unhelpful.

</p><p>To make matters worse, suppose that CPU 0 searches a list and
fails to find the element that it was looking for.
Was that because the element did not exist?
Or because CPU 0 got transported to some other list in the meantime?
Readers traversing <code>SLAB_TYPESAFE_BY_RCU</code> lists must carefully
validate each element and check for being moved to another list.
One way to check for being moved to another list is for each list to
have its own value for the <code>NULL</code> pointer.
These checks are subtle and easy to get wrong, so please be careful!

</p><p>A major advantage of hlist-nulls lists is that updaters can
free elements to <code>SLAB_TYPESAFE_BY_RCU</code> slab caches without
waiting for an RCU grace period to elapse.
However, readers must be extremely careful when traversing such lists.
Not only must they conduct their searches within a single RCU read-side
critical section, but because any element might be freed and then
reallocated at any time, readers must also validate each element that
they encounter during their traversal.

</p><p>The APIs in the fourth and final column of the
table
operate on Linux-kernel
hlist-bitlocked lists, which are made up of <code>hlist_bl_head</code> and
<code>hlist_bl_node</code> structures.
These lists uses the low-order bit of the pointer to the first element
as a lock, which allows per-bucket locks on large hash tables while
still maintaining a reasonable memory footprint.

</p>
<a name="List Initialization"></a>
<h4>List initialization</h4>

<p>The <code>INIT_LIST_HEAD_RCU()</code> API member allows
a normal list to be initialized even when there are concurrent readers.
This is useful for constructing list-splicing functions.

</p>
<a name="Full Traversal"></a>
<h4>Full traversal</h4>

<p>The macros for full list traversal must be used within an
RCU read-side critical section.
These macros map to a C-language <code>for</code> loop, just as their
non-RCU counterparts do.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_for_each_entry_rcu()</code>: Iterate over a
	list from the beginning.
<li>	<code>list_for_each_entry_lockless()</code>: Iterate over a
	insertion-only list (or similar) from the beginning.
<li>	<code>hlist_for_each_entry_rcu()</code>: Iterate over an
	hlist from the beginning.
<li>	<code>hlist_for_each_entry_rcu_bh()</code>: Iterate over a
	bh-protected hlist from the beginning.
<li>	<code>hlist_for_each_entry_rcu_notrace()</code>: Iterate over an
	hlist from the beginning, but disable tracing.
	This macro can thus be safely used within the tracing code.
<li>	<code>hlist_nulls_for_each_entry_rcu()</code>: Iterate over an
	 hlist-nulls from the beginning.
<li>	<code>hlist_bl_for_each_entry_rcu()</code>: Iterate over a
	bitlocked hlist from the beginning.
<li>	<code>hlist_nulls_for_each_entry_safe()</code>: Iterate over a
	bitlocked hlist from the beginning, but allowing
	the current element to be deleted.
</ul>

<a name="Resume Traversal"></a>
<h4>Resume traversal</h4>

<p>The macros for resuming list traversal must also be used within an
RCU read-side critical section.
It is the caller's responsibility to make sure that the list element
that traversal has started from remains in existence, and the usual
way to do this is to make sure that the RCU read-side critical
section covers both the original traversal and the resumption.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_for_each_entry_continue_rcu()</code>: Iterate over a
	list starting after specified element.
<li>	<code>list_for_each_entry_from_rcu()</code>: Iterate over a
	list from the specified element.
<li>	<code>hlist_for_each_entry_continue_rcu()</code>: Iterate over an
	hlist starting after the specified element.
<li>	<code>hlist_for_each_entry_continue_rcu_bh()</code>: Iterate over a
	bh-protected hlist starting after the specified element.
<li>	<code>hlist_for_each_entry_from_rcu()</code>: Iterate over an
	hlist from the specified element.
</ul>

<a name="Stepwise Traversal"></a>
<h4>Stepwise traversal</h4>

<p>The macros for doing stepwise traversal are used when more control
is required.
When repeatedly invoking these macros to step through a list, the
full set of macro invocations must be enclosed in an RCU read-side
critical section.
If you must split the traversal into more than one RCU read-side
critical section, you must also
do something else to guarantee the existence of the relevant elements
during the time between successive RCU read-side critical sections.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_entry_rcu()</code>: Given a pointer to a
	<code>list_head</code> structure, return a pointer to the
	enclosing element.
<li>	<code>list_entry_lockless()</code>: Given a pointer to a
	<code>list_head</code> structure, return a pointer to the
	enclosing element, but don't require that the caller be within
	an RCU read-side critical section.
<li>	<code>list_first_or_null_rcu()</code>: Return a pointer to the
	first element on a list, or <code>NULL</code> if the list
	is empty.
<li>	<code>list_next_rcu()</code>: Return a pointer to the
	next element on the list, which must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>list_next_or_null_rcu()</code>: Similar to
	<code>list_next_rcu()</code>, except that it returns <code>NULL</code>
	when invoked on the last element of the list.
<li>	<code>hlist_first_rcu()</code>: Return a pointer to the
	first element on an hlist, or <code>NULL</code> if the
	hlist is empty.
	If non-<tt>NULL</tt>, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_next_rcu()</code>: Return a pointer to the
	next element on an hlist, or <code>NULL</code> if at
	the end of the hlist.
	If non-<tt>NULL</tt>, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_pprev_rcu()</code>: Return a pointer to the
	previous element's pointer to the current element.
	This must not be used by RCU readers because the <tt>-&gt;pprev</tt> pointer
	is poisoned at deletion time.
<li>	<code>hlist_nulls_first_rcu()</code>: Return a pointer to the
	first element on an hlist-nulls, or
	<code>NULL</code> if the hlist is empty.
	If non-<tt>NULL</tt>, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_nulls_next_rcu()</code>: Return a pointer to the
	next element on an hlist-nulls, or <code>NULL</code>
	if at the end of the hlist.
	If non-<tt>NULL</tt>, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_bl_first_rcu()</code>: Return a pointer to the
	first element on the bitlocked hlist, applying
	<code>rcu_dereference()</code>.
	The caller must either be in an RCU read-side critical
	section or have locked the hlist.
	Note that this cannot be an RCU bh, RCU sched, or SRCU
	read-side critical section, only an RCU read-side critical
	section will do.
</ul>

<a name="List Addition"></a>
<h4>List addition</h4>

<p>The list-addition APIs require some form of mutual exclusion,
for example, using locking or single designated updater task.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_add_rcu()</code>: Add an element at the head of
	the list.
<li>	<code>list_add_tail_rcu()</code>: Add an element at the tail of
	the list.
<li>	<code>hlist_add_before_rcu()</code>: Add an element before the
	specified element in the  hlist.
<li>	<code>hlist_add_behind_rcu()</code>: Add an element after the
	specified element in the  hlist.
<li>	<code>hlist_add_head_rcu()</code>: Add an element to the beginning
	of the  hlist.
<li>	<code>hlist_add_tail_rcu()</code>: Add an element to the end
	of the  hlist.
<li>	<code>hlist_nulls_add_head_rcu()</code>: Add an element to the
	beginning of the  hlist-nulls.
<li>	<code>hlist_bl_add_head_rcu()</code>: Add an element to the
	beginning of the  bitlocked hlist.
<li>	<code>hlist_bl_set_first_rcu()</code>: Add an element to the
	beginning of the  bitlocked hlist, which must
	initially be empty.
</ul>

<a name="List Deletion"></a>
<h4>List deletion</h4>

<p>The list-deletion APIs also require some form of mutual exclusion,
for example, using locking or single designated updater task.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_del_rcu()</code>: Delete the specified element from
	its  list.
<li>	<code>hlist_del_rcu()</code>: Delete the specified element from
	its  hlist.
<li>	<code>hlist_del_init_rcu()</code>: Delete the specified element from
	its  hlist, initializing its pointer to form an
	empty list.
<li>	<code>hlist_nulls_del_rcu()</code>: Delete the specified element from
	its  hlist-nulls.
<li>	<code>hlist_nulls_del_init_rcu()</code>: Delete the specified
	element from its  hlist-nulls, initializing its
	pointer to form an empty list.
<li>	<code>hlist_bl_del_rcu()</code>: Delete the specified element from
	its  bitlocked hlist.
<li>	<code>hlist_bl_del_init_rcu()</code>: Delete the specified
	element from its  bitlocked hlist, initializing its
	pointer to form an empty list.
</ul>

<a name="List Replacement"></a>
<h4>List replacement</h4>

<p>The list-replacement APIs replace an existing element with a new
version.
The caller is responsible for disposing of the old (existing) element.
These also require some form of mutual exclusion,
for example, using locking or single designated updater task.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_replace_rcu()</code>: Replace an element in a
	 list.
<li>	<code>hlist_replace_rcu()</code>: Replace an element in an
	 hlist.
</ul>

<a name="List Splice"></a>
<h4>List splice</h4>

<div class="tlr"><a name="Quick Quiz 13"></a><b>Quick Quiz 13</b>:
Why a mutex instead of a simple spinlock?
<a href="#qq13answer">Answer</a>
</div>

<p>The list-splice APIs join a pair of lists into a single combined list.
This also requires some form of mutual exclusion,
for example, using a mutex or a single designated updater task.

<p>The two API members are as follows:

<ul class="spacylist">
<li>	<code>list_splice_init_rcu()</code>: Splice a pair of lists
	together, initializing the source list to empty.
	Note that this primitive waits for a grace period to elapse.
	You determine the RCU flavor by passing in the corresponding
	grace-period-wait primitive, for example, <code>synchronize_rcu()</code>
	for RCU and <code>synchronize_rcu_bh()</code> for RCU bh.
<li>	<code>list_splice_tail_init_rcu()</code>: Similar to
	<code>list_splice_init_rcu()</code>, but splices to the tail
	of the destination list.
</ul>

<a name="How Did Those 2014 Predictions Turn Out?"></a>
<h4>How did those 2014 predictions turn out?</h4>

How good were those old <a href="/Articles/609904/#What%20Next%20for%20the%20RCU%20API?">predictions</a>?

<ul>
<li>	"It is possible that <code>rcu_dereference_index_check()</code>
	will be retired if it is reasonable to convert all current use of
	RCU-protected indexes into RCU-protected pointers.
	Yes, I am doubling down on this one."
<p>
	And <code>rcu_dereference_index_check()</code> is in fact gone.
<li>	"It is quite possible that large systems might encounter
	problems with <code>synchronize_rcu_expedited()</code> scalability.
	I am doubling down on this one as well, and extending it to
	normal grace-period operations.
	For example, it might be necessary to parallelize grace-period
	operations.
	For another example, it might be necessary to make
	<code>synchronize_rcu_expedited()</code> stop interrupting
	dyntick-idle CPUs."
<p>
	And <code>synchronize_rcu_expedited()</code> now uses workqueues
	to parallelize expedited grace period initialization.
<li>	"Additional diagnostics will be required, for example, detecting
	pointers leaking out of RCU read-side critical sections."
<p>
	Although RCU pointer leaks still go undiagnosed, <tt>rcutorture</tt> has
	been upgraded multiple times.
	In addition, formal verification has been applied to the Linux-kernel
	RCU code
	<a href="https://paulmck.livejournal.com/46993.html">several times</a>.
	Nevertheless, much more could be done in this area, in particular,
	no formal verifier has yet found a bug that I didn't already
	know about.
<li>	"A <code>kmem_struct</code> counterpart to
	<code>kfree_rcu()</code> will likely be required."
<p>
	There has been some work in this direction, but <code>kfree_rcu()</code>
	still goes unaccompanied.
<li>	"Inlining of <code>TREE_PREEMPT_RCU</code>'s
	<code>rcu_read_lock()</code>
	primitive."
<p>
	And finally, <code>rcu_read_lock()</code> still goes uninlined.
</ul>

<p>Two and a half out of five, so, as predictions go, they could have
been worse.  However, it is also illuminating to list the unexpected
changes—all 21 of them:

<ul class="spacylist">
<li>	RCU flavor consolidation, courtesy of an exploitable security bug.
<li>	Tree SRCU, that is, providing update-side scalability for SRCU.
<li>	Tasks RCU, which is a specialized RCU implementation designed
	for trampoline removal; it uses voluntary context switch and
	user-mode execution as its quiescent states.
<li>	Complete rework of expedited RCU grace periods, providing
	greater update-side scalability and allowing
	<code>synchronize_rcu_expedited()</code> to be invoked from
	within CPU-hotplug notifiers.
<li>	Consolidation of (almost) all calls to
	<code>cond_resched_rcu_qs()</code> into <code>cond_resched()</code>,
	along with fixing an embarrassing consequent forward-progress issue.
<li>	Nested NMIs.
	Or at least things that look like nested NMIs from an RCU
	viewpoint.
<li>	Removal of the need to handle interrupts that never return as well
	as the need to return from interrupts that never happened.
<li>	Allowing <code>call_rcu()</code> to be used at very early boot.
<li>	Allowing <code>synchronize_rcu()</code> to be used during the
	<a href="/Articles/716148/">mid-boot dead zone</a>.
<li>	Addition of the <code>rcupdate.rcu_normal</code> and
	<code>rcupdate.rcu_normal_after_boot</code> kernel boot parameters
	to shield real-time workloads from IPIs due to expedited grace
	periods, while still allowing expedited grace periods to speed up
	boot.
<li>	Several applications of funnel locking to avoid scalability
	bottlenecks.
<li>	A number of interesting and embarrassing shortcomings in
	RCU callback offloading.
<li>	Further simplification of Tiny RCU, perhaps most notably removing
	its ability to issue RCU CPU stall warnings.
<li>	Addition of RCU CPU stall warnings to expedited RCU grace periods.
<li>	The use of <tt>rcutorture</tt> as a stress test for other parts of the kernel.
<li>	Tagging groups of RCU callbacks with grace-period numbers in
	order to permit idle CPUs with callbacks to sleep longer.
<li>	Rewriting the interface between CPU hotplug and RCU to avoid
	a number of race conditions and deadlocks.
<li>	The <tt>rcutorture</tt> scripts now automatically create the required
	initrd if it does not already exist.
<li>	The removal of quite a few Kconfig options, along with the move
	of most RCU-specific Kconfig options to <code>kernel/rcu/Kconfig</code>
	and <code>kernel/rcu/Kconfig.debug</code>.
<li>	Removal of <code>CONFIG_NO_HZ_FULL_SYSIDLE</code> due to lack
	of in-tree usage.
<li>	Removal of RCU's debugfs tracing, again due to lack of users.
</ul>

<a name="What Next for the RCU API?"></a>
<h4>What next for the RCU API?</h4>

<p>The most honest answer is still that I do not know.
That said, the following seem to be a few of the more likely directions:

<ul class="spacylist">
<li>	A <code>kmem_struct</code> counterpart to <code>kfree_rcu()</code>
	will likely be required.
	Yes, I am doubling down on this one.

<li>	Inlining of <code>TREE_PREEMPT_RCU</code>'s
	<code>rcu_read_lock()</code> primitive.
	Yes, I am doubling down on this one too.

<li>	Additional forward-progress work, both in <tt>rcutorture</tt> and in
	RCU proper.

<li>	Better handling of
	<a href="https://www.usenix.org/conference/atc17/technical-sessions/presentation/prasad">vCPU preemption within RCU readers</a>.

<li>	Adding <tt>rcutorture</tt> to kselftests, that is, adding a
	<code>Makefile</code> to
	<code>tools/testing/selftests/rcutorture</code>
	that carries out a quick <tt>rcutorture</tt>-based
	"smoke test" of RCU.

<li>	Disentangling <code>rcu_barrier()</code> from CPU hotplug operations,
	which could permit this function to be invoked from CPU-hotplug
	notifiers.
</ul>

<p>But if the past is any guide, new use cases and workloads will place
unanticipated demands on RCU.

</p>

<h4>Acknowledgments</h4>

<p>We are all indebted to a huge number of people who have used,
abused, poked at, and otherwise helped to improve the RCU API, as well
as to Joel Fernandes for his careful review and thoughtful comments.
I am grateful to Mark Figley for his support of this effort.

</p>

<a name="Answers to Quick Quizzes"></a>
<h4>Answers to quick quizzes</h4>

<a name="qq1answer"></a>
<p><b>Quick Quiz 1</b>:
Why do <code>synchronize_rcu_mult()</code>,
<code>get_state_synchronize_sched()</code>, and
<code>cond_synchronize_sched()</code> have both blue and red backgrounds?


</p><p><b>Answer</b>:
Because they were added since 2014, but are slated for removal.
As with an unfortunate but fictional legionnaire, they arrived, and
then they departed.


</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

<a name="qq2answer"></a>
<p><b>Quick Quiz 2</b>:
Doesn't this consolidation also mean that it is no longer possible
to wait only on preempt-disable regions of code in
<code>CONFIG_PREEMPT=y</code> kernels?


</p><p><b>Answer</b>:
That is quite true.
For example, <code>synchronize_rcu()</code> waits on
<code>rcu_read_lock()</code>-delimited RCU read-side critical sections
as well as preempt-disabled code regions.
One possible concern is that <code>rcu_read_lock()</code>-delimited
RCU read-side critical sections might be preempted, which could greatly
increase the latency of <code>synchronize_rcu()</code> over that of
pre-v4.20 <code>synchronize_sched()</code>.
Should this become a problem, one way to deal with it is to build
with <code>CONFIG_BOOST_RCU=y</code>, which has seen significant use
by the real-time Linux community.

<p>It is also important to note that even the disabling of interrupts
is no panacea within guest OSes, given that disabling interrupts within
the guest does nothing to prevent the host OS from preempting even a
interrupts-disabled vCPU.


</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

<a name="qq3answer"></a>
<p><b>Quick Quiz 3</b>:
Why not also remove <code>rcu_read_lock_bh()</code>,
<code>rcu_read_unlock_bh()</code>, <code>rcu_read_lock_sched()</code>,
and <code>rcu_read_unlock_sched()</code>?


</p><p><b>Answer</b>:
That might happen some time in the future, but the current thought is
that one advantage of (say) <code>rcu_read_lock_bh()</code> over
<code>local_bh_disable()</code> is that <code>rcu_read_lock_bh()</code>
clearly indicates that RCU is involved.
In addition, some developers and maintainers might be relying on the
finer-grained checking provided by lockdep, requiring for example that
<code>rcu_dereference_bh()</code> be within an RCU bh read-side critical
section.


</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

<a name="qq4answer"></a>
<p><b>Quick Quiz 4</b>:
How about doing something more reliable by, for example, making the
compiler complain about such backports?


</p><p><b>Answer</b>:
That was considered but rejected due to excess churn,
the reason being that there are a great many more calls to
<code>synchronize_rcu()</code>,
<code>synchronize_rcu_expedited()</code>,
<code>call_rcu()</code>, and
<code>rcu_barrier()</code>
than to their RCU bh and RCU sched counterparts.
People are also looking into use of static analysis (for example,
Coccinelle) to help with this.
If you know of a better way to handle this, please don't keep it a
secret.


</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>

<a name="qq5answer"></a>
<p><b>Quick Quiz 5</b>:
Might we all be better off if the RCU flavors remained unconsolidated?


</p><p><b>Answer</b>:
The consolidation does have some disadvantages, but so do exploitable
security holes.
In addition, the consolidation has the unintended benefit of fulfilling
a long-standing request by reducing
the number of <code>rcuo</code> callback-offload kthreads by a factor
of two in <code>CONFIG_PREEMPT=n</code> kernels and by a factor of
three in <code>CONFIG_PREEMPT=y</code> kernels, and eliminating the
<code>rcuob</code> callback-offload kthreads completely.
Furthermore, the consolidation reduced RCU's memory footprint
slightly but significantly.
Finally, the consolidation greatly simplified RCU's implementation, at
least in terms of lines of code.

<p>All in all, therefore, this consolidation should be an overall positive.


</p><p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a>

<a name="qq6answer"></a>
<p><b>Quick Quiz 6</b>:
Why not modify the scheduler-clock interrupt to check for user-mode execution?


</p><p><b>Answer</b>:
Because it already does this checking.
The scheduler-clock interrupt handler invokes
<code>rcu_check_callbacks()</code>,
which invokes the <code>CONFIG_PREEMPT=y</code>
<code>rcu_flavor_check_callbacks()</code>, which, if <code>user</code> is
set, invokes <code>rcu_note_voluntary_context_switch()</code>, which
will result in a tasks RCU quiescent state in kernels implementing
RCU tasks.


</p><p><a href="#Quick%20Quiz%206"><b>Back to Quick Quiz 6</b>.</a>

<a name="qq7answer"></a>
<p><b>Quick Quiz 7</b>:
Why not force a tasks RCU quiescent state by preempting all currently
executing tasks?


</p><p><b>Answer</b>:
Because only a <b>voluntary</b> context switch constitutes a tasks RCU
quiescent state, such preemption is of no help.


</p><p><a href="#Quick%20Quiz%207"><b>Back to Quick Quiz 7</b>.</a>

<a name="qq8answer"></a>
<p><b>Quick Quiz 8</b>:
Why is extreme caution required for <code>call_srcu()</code>
and <code>srcu_barrier()</code>?


</p><p><b>Answer</b>:
Because SRCU readers are allowed to block indefinitely, these two
primitives might take a long time to invoke their callbacks, if they invoke
them at all.
So if you use either <code>call_srcu()</code> or
<code>srcu_barrier()</code>, it is your responsibility to make sure
that readers complete in a timely fashion, lest large numbers of
<code>call_srcu()</code> calls OOM the kernel or your
<code>srcu_barrier()</code> refuse to ever return.
Or, alternatively, it is your responsibility to make sure that your
code does not care that <code>call_srcu()</code> and
<code>srcu_barrier()</code> take forever to find the end of the
grace period.


</p><p><a href="#Quick%20Quiz%208"><b>Back to Quick Quiz 8</b>.</a>

<a name="qq9answer"></a>
<p><b>Quick Quiz 9</b>:
Given that dependencies are quite natural and intuitive, what excuse
would compilers have for breaking them?
And why isn't this bug being fixed?


</p><p><b>Answer</b>:
In practice, compilers normally cannot reasonably break dependencies
carried by pointers, however, integers are another matter altogether.
To see this, consider an array whose size depends on a Kconfig option.
If that array ends up having only one element, the compiler <b>knows</b>
that the index must be zero, and an aggressively optimizing compiler
just might decide to skip the computation entirely and just use the
constant zero, which would break any dependency.
Of course, pointers can also be zero, but this also means that non-buggy
code won't be dereferencing them, thus defining this particular cause
of dependency breaking out of existence.
Issues with dependency breaking are discussed at length
<a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0098r0.pdf">here
[PDF]</a>.

<p>One could argue that compilers do in fact respect dependencies via
the C and C++ <code>memory_order_consume</code> facility.
However, this is only ever implemented by promoting it to
<code>memory_order_acquire</code>, which on weakly ordered systems
can result in unnecessary memory-barrier instructions on your fast paths,
which might not be what you want.
The reason for the promotion to <code>memory_order_acquire</code> is
that compiler writers positively despise having to trace dependencies.
In fact, there is a proposal to temporarily
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r0.html">deprecate</a>
<code>memory_order_consume</code>.

<p>So what is to be done?
One
<a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0190r4.pdf">proposal 
[PDF]</a>
restricts dependency chains to cases where it is difficult for the
compiler to break them, and further requires that pointer variables
carrying dependencies be marked.
Such marking might not go down well with the Linux-kernel community,
which has been carrying dependencies in unmarked variables for more
than 15&nbsp;years, so there is a further informal proposal asking
C and C++ implementations to
provide a command-line option forcing the compiler to treat any pointer
variable as if it had been marked.
(Why informal?  Because command-line options are outside of the scope
of the standard.)

<p>There is a prototype implementation that obtains the functionality of
<code>memory_order_consume</code> without actually using
<code>memory_order_consume</code>, which is briefly described
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0750r1.html">here</a>.
However, the committee was not all that happy with this approach, preferring
marking of a single pointer variable to maintaining a separate variable
to carry the dependency.

<p>So there is some progress and some hope, but not yet a complete and
agreed-upon solution.


</p><p><a href="#Quick%20Quiz%209"><b>Back to Quick Quiz 9</b>.</a>

<a name="qq10answer"></a>
<p><b>Quick Quiz 10</b>:
What happens if you mix and match RCU and RCU sched?


</p><p><b>Answer</b>:
In v4.20 and later kernels, nothing:  It just works.
Not so much in v4.19 and earlier kernels, as discussed below.

<p>In a <code>CONFIG_TREE_RCU</code> or a
<code>CONFIG_TINY_RCU</code> kernel, mixing these
two works "by accident" because in those kernel builds, RCU and RCU sched
map to the same implementation.
However, this mixture is fatal in <code>CONFIG_TREE_PREEMPT_RCU</code> builds,
due to the fact that RCU's read-side critical
sections can then be preempted, which would permit
<code>synchronize_sched()</code> to return before the
RCU read-side critical section reached its <code>rcu_read_unlock()</code>
call.
This could in turn result in a data structure being freed before the
read-side critical section was finished with it,
which could in turn greatly increase the actuarial risk experienced
by your kernel.

</p><p>Even in <code>CONFIG_TREE_RCU</code> and
<code>CONFIG_TINY_RCU</code> builds, such mixing and matching is of
course strongly discouraged.
Mixing and matching other flavors of RCU is even worse: it can result
in hard-to-debug bad-pointer bugs.


</p><p><a href="#Quick%20Quiz%2010"><b>Back to Quick Quiz 10</b>.</a>

<a name="qq11answer"></a>
<p><b>Quick Quiz 11</b>:
Can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?
If so, why?  If not, why not?


</p><p><b>Answer</b>:
In theory, you can use
<code>synchronize_srcu()</code> with a given <code>srcu_struct</code>
within an SRCU read-side critical section that uses some other
<code>srcu_struct</code>.
In practice, however, such use is almost certainly a bad idea,
as it means that the SRCU readers take a long time to complete.
Worse yet, the following could still result in deadlock:

</p><blockquote>
<pre>idx = srcu_read_lock(&amp;ssa);
synchronize_srcu(&amp;ssb);
srcu_read_unlock(&amp;ssa, idx);

/* . . . */

idx = srcu_read_lock(&amp;ssb);
synchronize_srcu(&amp;ssa);
srcu_read_unlock(&amp;ssb, idx);
</pre>
</blockquote>

<p>The reason that this code fragment can result in deadlock is that we
have a cycle.
The <code>ssa</code> read-side critical sections can wait on an
<code>ssb</code> grace period, which waits on <code>ssb</code> read-side
critical sections, which contains a <code>synchronize_srcu()</code>, which
in turn waits on <code>ssa</code> read-side critical sections.

</p><p>So if you do include <code>synchronize_srcu()</code> in SRCU
read-side critical sections, make sure to avoid cycles.
Of course, the simplest way to avoid cycles is to avoid using
<code>synchronize_srcu()</code> in SRCU read-side critical sections
in the first place.


</p><p><a href="#Quick%20Quiz%2011"><b>Back to Quick Quiz 11</b>.</a>

<a name="qq12answer"></a>
<p><b>Quick Quiz 12</b>:
Why isn't there an
<code>smp_mb__after_rcu_read_unlock()</code>,
<code>smp_mb__after_rcu_bh_read_unlock()</code>, or
<code>smp_mb__after_rcu_sched_read_unlock()</code>?


</p><p><b>Answer</b>:
Because these primitives never imply any sort of barrier.
In contrast, the current implementation of <code>srcu_read_unlock()</code>
actually does imply a full barrier, so
<code>smp_mb__after_srcu_read_unlock()</code>
can be an informative no-op.


</p><p><a href="#Quick%20Quiz%2012"><b>Back to Quick Quiz 12</b>.</a>

<a name="qq13answer"></a>
<p><b>Quick Quiz 13</b>:
Why a mutex instead of a simple spinlock?


</p><p><b>Answer</b>:
Because both of these primitives wait for a grace period, which is
not something you should be doing while holding a spinlock.


</p><p><a href="#Quick%20Quiz%2013"><b>Back to Quick Quiz 13</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/777036/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor777431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2019 1:55 UTC (Thu)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/777431/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good one, Paul. Enjoyed very much! thanks, a bunch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2019 15:06 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/777464/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Glad you like it!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor777436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2019 4:59 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/777436/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nit: I wish RCU docs and articles would sometimes mention prior art: <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">https://en.wikipedia.org/wiki/Multiversion_concurrency_co...</a><br>
<p>
Maybe they don't to avoid patent/legal issues?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2019 1:10 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/777465/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmmm...  You are right that there is a rough relation between MVCC and RCU, but there is a much closer relation between MVCC and things like read-log update (RLU, see <a href="https://lwn.net/Articles/667593/">https://lwn.net/Articles/667593/</a> and its URLs).  One key distinction is that both MVCC and RLU provide much stronger consistency guarantees to readers than does RCU.  Of course, nothing comes for free, and so MVCC and RLU readers are quite a bit more expensive than are RCU readers.<br>
<p>
But I will nevertheless give some thought to calling out the connection between MVCC and RCU, rough though it might be.  No guarantees, of course!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor777519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2019 5:04 UTC (Fri)
                               by <b>cornelio</b> (guest, #117499)
                              [<a href="/Articles/777519/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Have the patents expired yet? It's rather unusable for non-copyleft projects until it does.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2019 16:35 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/777691/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suggest checking the dates on the patents themselves -- they are rather well known.  And dates that took place during the mid-1990s are quite some time in the past.  But that is a legal question, and I am not a lawyer.<br>
<p>
In addition, please note that non-copyleft projects always have the option of using the userspace RCU library, which is LGPL, and thus can be linked to even proprietary code.  Longer term, there is also work ongoing to add RCU to the C++ language (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1122r2.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p...</a>), which would eventually make things easier for projects that are C or C++ or that can easily interface to C or C++.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor778369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2019 14:56 UTC (Mon)
                               by <b>cornelio</b> (guest, #117499)
                              [<a href="/Articles/778369/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am not a lawyer either but the license has consequences.<br>
<p>
Some organizations, including the Apache Software Foundation, ban both GPL and LGPL so unless a new independent implementation appears I can't really even look at RCU.<br>
<p>
(Not a complaint, and surely not your fault.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/778369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor778464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2019 edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2019 8:09 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/778464/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, the policies of the Apache Software Foundation are not under my control.  :-)<br>
<p>
There is a C++ implementation of RCU licensed under Apache v2 here:  <a href="https://github.com/facebook/folly/blob/master/folly/synchronization/Rcu.h">https://github.com/facebook/folly/blob/master/folly/synch...</a>.<br>
<p>
In addition, I believe that Samy Al Bahra has an RCU implementation based on epochs in his concurrency library, and I believe that it uses a non-copyleft license.<br>
<p>
There are quite likely other implementations out there.<br>
<p>
I have not done a detailed evaluation of either of these code bases, nor do I plan to.  But it should not be hard to run them through an appropriate evaluation.  One approach would be to create something like rcutorture at user level, perhaps guided by Linux-kernel RCU or by the test suite that is part of userspace RCU.  Or, if licensing is still a problem even for testing, you can always create your own from scratch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/778464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
