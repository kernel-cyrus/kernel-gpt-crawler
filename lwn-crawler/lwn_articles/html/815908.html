        <!DOCTYPE html>
        <html lang="en">
        <head><title>Avoiding retpolines with static calls [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/815908/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/816069/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/815908/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Avoiding retpolines with static calls</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 26, 2020</br>
           </div>
January 2018 was a sad time in the kernel community.  The Meltdown and
Spectre vulnerabilities had finally been disclosed, and the required
workarounds hurt kernel performance in a number of ways.  One of those
workarounds — <a
href="https://support.google.com/faqs/answer/7625886">retpolines</a> —
continues to cause pain, with developers going
out of their way to avoid indirect calls, since they must now be implemented
with retpolines.  In some cases, though, there may be a way to 
avoid retpolines and regain much of the lost performance;
after a long gestation period, the "static calls" mechanism may finally be
nearing the point where it can be merged upstream.
<p>
Indirect calls happen when the address of a function to be called is not
known at compile time; instead, that address is stored in a pointer
variable and used at run time.  These indirect calls, as it turns out, are
readily exploited by speculative-execution attacks.  Retpolines defeat
these attacks by turning an indirect call into a rather more complex (and
expensive) code sequence that cannot be executed speculatively.
<p>
Retpolines solved the problem, but they also slow down the kernel, so
developers have been keenly interested in finding ways to avoid them.  A
number of approaches have been tried; a few of which were <a
href="/Articles/774743/">covered here</a> in late 2018.  While some of
those techniques have been merged, static calls have remained outside of
the mainline.  They have recently returned in the form of <a
href="/ml/linux-kernel/20200324135603.483964896@infradead.org/">this patch
set</a> posted by Peter Zijlstra; it contains the work of others as well,
in particular Josh Poimboeuf, who posted the original static-call
implementation.
<p>
An indirect call works from a location in writable memory where the
destination of the jump can be found.  Changing the destination of the call
is a matter of storing a new address in that location.  Static calls,
instead, use a location in <i>executable</i> memory containing a jump
instruction that points to the target function.  Actually executing a
static call requires "calling" to this special location, which will
immediately jump to the real target.  The static-call location is, in other
words, a 
classic code trampoline.  Since both jumps are direct — the
target address is found directly in the executable code itself — no
retpolines are needed and execution is fast.
<p>
Static calls must be declared before they can be used; there are two macros
that can do that:
<p>
<pre>
    #include &lt;linux/static_call.h&gt;

    DEFINE_STATIC_CALL(name, target);
    DECLARE_STATIC_CALL(name, target);
</pre>
<p>

<tt>DEFINE_STATIC_CALL()</tt> creates a new static call with the given
<tt>name</tt> that initially points at the function <tt>target()</tt>.
<tt>DECLARE_STATIC_CALL()</tt>, instead, declares the existence of a static
call that is defined elsewhere; in that case, <tt>target()</tt> is only
used for type checking the calls.
<p>
Actually calling a static call is done with:
<p>
<pre>
    static_call(name)(args...);
</pre>
<p>
Where <tt>name</tt> is the name used to define the call.  This will cause a
jump through the trampoline to the target function; if that function
returns a value, <tt>static_call()</tt> will also return that value.

<p>
The target of a static call can be changed with:
<p>
<pre>
    static_call_update(name, target2);
</pre>
<p>
Where <tt>target2()</tt> is the new target for the static call.  Changing
the target of a static call requires patching the code of the running
kernel, which is an expensive operation.  That implies that static calls
are only appropriate for settings where the target will change rarely.
<p>
One such setting can be found in the patch set: tracepoints.  Activating a
tracepoint itself requires code patching.  Once that is done, the kernel
responds to a hit on a tracepoint by iterating through a linked list of
callback functions that have been attached there.  In almost every case, though,
there will only be one such function.  <a
href="/ml/linux-kernel/20200324142246.005164711@infradead.org/">This
patch</a> in the series optimizes that case by using a static call for the
single-function case.  Since the intent behind tracepoints is to minimize their
overhead to the greatest extent possible, use of static calls makes sense
there.
<p>
This patch set also contains a further optimization not found in the
original.  Jumping through the trampoline is much faster than using a
retpoline, but it is still one more jump than is strictly necessary.  So <a
href="/ml/linux-kernel/20200324142245.694414364@infradead.org/">this
patch</a> causes static calls to store the target address directly into the
call site(s), eliminating
the need for the trampoline entirely.  Doing so may require changing
multiple call sites, but most static calls are unlikely to have many of
those.  It also requires support in the <tt>objtool</tt> tool to locate
those call sites during the kernel build process.
<p>
The end result of this work <a
href="/ml/linux-kernel/20181126155405.72b4f718@gandalf.local.home/">appears
to be</a> a significant reduction in the cost of the Spectre mitigations
when using tracepoints — a slowdown of just over&nbsp;4% drops to
about&nbsp;1.6%.  It has been through a number of revisions, as well as
some improvements to the underlying text-patching code, and appears to be
about ready.  Chances are that static calls will go upstream in the near
future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Retpoline">Retpoline</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Static_calls">Static calls</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/815908/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor816096"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 4:53 UTC (Fri)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/816096/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point of indirect branches is that the address of the function to be called is known only at runtime, where it is read from writable memory, and is not known at compile time.   The article makes it sound like instead static calls may be inserted into .text at compile time, but then how is the problem of dynamic function lookup addressed?   It doesn't magically go away.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816096/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 6:50 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/816097/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A lot of dynamic calls change infrequently and do not depend on data. So it's possible to patch the calling code.<br>
<p>
This won't work if you make calls, for example, into a filesystem driver from the VFS layer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 15:21 UTC (Fri)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/816136/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A lot of dynamic calls change infrequently and do not depend on data. So it's &gt; possible to patch the calling code.</font><br>
<p>
In other words, if the calling code wants one function from library A and another from library B, we just change the code.<br>
<p>
<font class="QuotedText">&gt; This won't work if you make calls, for example, into a filesystem driver from &gt; the VFS layer.</font><br>
<p>
That's pretty much the case I was considering: resolution of a base class pointer.  In your example, the VFS has a default implementation of whatever action, and individual filesystems may override it.    Compiler Explorer shows explicitly that the base class pointer resolution is in fact an indirect branch.   AFAICT, this new mechanism offers no hope to eliminate this branch.  Some type of "reflection" would be needed to resolve the problem, perhaps with _THIS_IP and _RET_IP_ in include/linux/kernel.h.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 17:48 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/816150/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In other words, if the calling code wants one function from library A and another from library B, we just change the code.</font><br>
Yep.<br>
<p>
<font class="QuotedText">&gt; That's pretty much the case I was considering: resolution of a base class pointer. </font><br>
This can also be done, but not with this approach. Basically, you rewrite indirect calls into "if" chains:<br>
if (this-&gt;class == ClassA) return ClassA_Method(this, ...)<br>
if (this-&gt;class == ClassB) return ClassB_Method(this, ...)<br>
<p>
This actually can work faster than indirects if you only have a couple of implementations (which is normally the case).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816191"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 10:07 UTC (Sun)
                               by <b>Homer512</b> (subscriber, #85295)
                              [<a href="/Articles/816191/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could extend this to an unrolled binary search similar to what the compiler does with large, sparsely populated switch-case statements. I'm wondering whether the kernel could just generate trampoline functions with such code on-the-fly. Then you could just register a new indirect call target, the kernel rewrites its trampoline and everything is done via direct calls. You can even leave in the indirect call as a fallback.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816191/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor816194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 14:28 UTC (Sun)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816194/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      Actually the literature on implementing object-oriented languages discusses optimizations called "inline caching" and "polymorphic inline caching", which are targeted at exactly this problem.

<p>Inline caching corresponds pretty much with the "further optimization" of the article: it works with an inline call, and guards it with an inline check that the object has the correct class (in VFS, that the file has the correct file system type); it was useful if the class rarely changes for a call site.

<p>Polymorphic inline caching has several inline calls, selected by several inline checks.  It was useful if a call site gets passed objects of a few classes alternatingly, and may be appropriate for the VFS case.

<p>These techniques fell out of fashion when correctly predicted indirect branches became as fast as direct branches and indirect-branch prediction became pretty good.  Now, with Spectre they may see a renaissance (hopefully a short one curtailed by the introduction of properly fixed hardware).
      
          <div class="CommentReplyButton">
            <form action="/Articles/816194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 18:30 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/816201/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (hopefully a short one curtailed by the introduction of properly fixed hardware).</font><br>
<p>
As I currently understand things, this is at best optimistic.<br>
<p>
Spectre is not a simple hardware flaw that you can fix by rearranging a few transistors. It is a design flaw in speculative execution itself. Spectre has been endemic to every general-purpose microprocessor that has been manufactured in the past twenty or more years (and probably most special-purpose microprocessors too). To "fix" it, you would have to completely redesign, not just one or two architectures, but the entire concept of what a modern microprocessor looks like.<br>
<p>
I am open to being corrected, of course. It's entirely possible that some manufacturers have gone down that "redesign everything from the ground up" road that I described, or perhaps they found a simpler path forward. But my current understanding is that workarounds, usually at higher layers of the system, are all we've got right now and for the foreseeable future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816202"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 18:47 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/816202/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speculative (mis-)execution is not a problem in itself, it's the fact that it may cause observable side effects. So one avenue of attack on this problem is removing the side effects.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816202/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 20:56 UTC (Sun)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816209/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Yes. E.g., do not update the caches from speculative loads.  Instead, keep the load results in a private buffer and only update the caches if the loads become non-speculative, or when they are committed.

<p>Another avenue is to make it hard to train the predictor for a Spectre v2 exploit, e.g., by scrambling the input and/or the output of the predictor with a per-thread secret that changes now and then.  You can combine this avenue with the other one.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 21:01 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/816210/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've spoken with hardware people about it a couple of years ago and they had some ideas like separate speculative caches, that can be referred only from speculative contexts. Or adding artificial access delay to cache lines added by from speculative contexts. I'm sure other ideas will come in future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816218"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2020 1:52 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/816218/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not convinced that is sufficient. If there is any statistical relationship between any part of the processor's observable behavior and any data that any higher-level code might possibly consider a "secret," then you can perform a statistical analysis of that behavior to recover that secret, with arbitrarily good statistical confidence (depending on the available data). This is basic information theory. Adding noise at random parts of the processor will force the attacker to gather more data, but if the system under attack belongs to a cloud provider, then that's not an obstacle (because renting out processors for extended periods is their entire business model).<br>
<p>
The problem is that performance is a form of observable behavior. So you have to completely disentangle performance variations from every piece of data in main memory, cache, and registers, or else you have to exhaustively prove that the code under execution has access to that data, in every security model that the system cares about. The latter would extend to, for example, determining that the code under execution lives inside of a Javascript sandbox and should not be allowed to access the state of the rest of the web browser. I don't see how the processor can be reasonably expected to do that, so we're back to the first option: The processor's performance must not vary in response to any data at all. But then you can't have a branch predictor.<br>
<p>
I would really like someone to convince me that I'm wrong, because if true, this is rather terrifying. But as far as I can see, there is no catch-all mitigation for this problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816218/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2020 2:32 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/816220/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; because renting out processors for extended periods is their entire business model</font><br>
Pretty much all major cloud computing providers assign CPUs exclusively to customers, except maybe for the cheapest offerings (like T2/T3 instances on AWS).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 8:35 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/816566/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
By CPUs do you mean cores or packages? Multiple cores on a single package share cache (e.g. L3) and are vulnerable to cross-core, cross-VM leaks. (See <a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-yarom.pdf">https://www.usenix.org/system/files/conference/usenixsecu...</a>.) I don't know how much of a headache are cross-package attacks that exploit cache coherency protocols, but there are such attacks in the literature, which I'd keep in mind for high-value assets absent details from AWS.<br>
<p>
I'd be surprised if the bulk of instances were package isolated. The Xeon Platinum 8175M used for M5 instances has 24 cores per package, 48 threads, and therefore 48 vCPUs. AFAIU, EC2 doesn't share cores, but a vCPU is still the equivalent of a logical SMT-based core, so any instance type using less than 47 vCPUs would be leaving at least an entire core unused. AWS offers 2-, 8-, 16-, 32-, 48-, 64-, and 96-vCPU M5 instances. I'd bet a large number and probably a majority of customers are utilizing 2- to 32-vCPU instances, that they invariably share packages, and thus share L3 cache. And I'd also bet that 64-vCPU instances share one of their packages with other instances.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816659"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 16:37 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/816659/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm pretty sure AWS splits nodes in such way that instances don't share cache.<br>
<p>
<font class="QuotedText">&gt; I'd keep in mind for high-value assets absent details from AWS.</font><br>
All major cloud providers also have dedicated instances that won't be shared across customers. In case of AWS you can even run your own T2/T3 instances on top of the dedicated hardware nodes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816659/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor816232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2020 9:50 UTC (Mon)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816232/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It's not clear what attack scenario you have in mind.  Can you give an example?

<p>If you refer to the scrambling of the branch predictor inputs and outputs , note that the secret changes regularly (with an interval designed such that only a small part of the secret can be extracted).

<p>Concerning attacks from within the same thread (as in JavaScript engines), assuming good-enough scrambling, the attacker cannot predict which other branches a branch is aliased with in the branch predictor, and also cannot get the prediction to branch to the gadget the attacker wants to be speculatively executed.
 
<p>Concerning observable behaviour, lots of things are theoretically observable (e.g., through power consumption or electromagnetic emissions), and have been used practically on other components (e.g., emissions from CRTs or screen cables to watch what you are watching), but the danger is that you get into a "the sky is falling" mode of thinking that does not differentiate how realistically possible an attack is.  I have seen hardware and software providers blamed for waiting for the demonstration of an attack before they start acting, but OTOH, if they acted on any far-fetched theoretical weakness (not even attack scenario) that somebody worries about, they would not have a product.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor816571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 9:32 UTC (Thu)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/816571/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Uhmmm, in this case the side effect they are exploiting is the speed up of the program.  That happens to the very side effect caches were added for.  Any mitigation will reduce that highly desirable side effect, and thus reduce the usefulness of cache's in general.<br>
<p>
The more general problem is privilege separation.  This is just a case of lower privilege code being able to deduct what higher privilege code left in its cache.  I wonder how long it will be before someone figures out how to exploit spectre via a javascript JIT, or wasm.  The only solution is hardware protecting the browser memory from the javascript, but the hardware doesn't provide anything lightweight enough.  If we did have something lightweight enough micro kernels would be more viable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816579"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 12:04 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816579/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The question is how much a proper hardware mitigation costs compared to the current mitigations.  So what are the costs of not updating caches on speculative memory accesses?

<p>If the access becomes non-speculative (the vast majority of cases in most code), the caches will be updated a number of cycles later.  The performance impact of that is minimal.

<p>If the access is on a mispredicted path, the caches will not be updated.  If the line is then not accessed before it would be evicted, this is a win.  If the line is accessed, we incur the cost of another access to an outer level or main memory.  A somewhat common case is when you have a short if, and then a load after it has ended; if the if is mispredicted, and the load misses the cache, the speculative execution will first perform an outer access, and then it will be reexecuted on the corrected path and will perform the outer access again; the cost here is the smaller of the cache miss cost and the branch misprediction cost.  And the combination is relatively rare.

<p>Overall, not updating caches on speculative memory accesses reduces the usefulness of caches by very little, if at all (there are also cases where it increases the usefulness of caches).

<p>A Spectre-based exploit using JavaScript has been published pretty early.  No, MMU-style memory protection is not the only solution, Spectre-safe hardware as outlined above would also be a solution.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816579/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor816584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 11:58 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/816584/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
re: Spectre has been endemic to every general-purpose microprocessor that has been manufactured in the past twenty or more years<br>
<p>
I suspect that the cpu family used in the T5 from (the late, lamented) Sun Microsystems dodged this: it's claim to fame was running other, non-blocked code whenever a thread was blocked on a memory fetch, as described in <a href="https://en.wikipedia.org/wiki/UltraSPARC_T1">https://en.wikipedia.org/wiki/UltraSPARC_T1</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816586"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 12:27 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816586/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      Generally, in-order implementations are not affected, and existing out-of-order implementations are affected; not because it's not possible to make Spectre-immune OoO implementations, but because they did not think about how to do it when they designed these CPUs (Spectre was discovered later).

<p>UltraSPARC T1-SPARC T3 are in-order, but SPARC T4, T5, M7, M8 are OoO.  Performing other threads on a cache miss does not protect against Spectre: The cache or other microarchitectural state can still be updated from a speculative load.

<p>Recent in-order CPUs include Cortex A53 and A55, and Bonnell, the first generation of Intel's Atom line.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816586/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816590"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 12:47 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/816590/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many thanks!<br>
<p>
Interestingly, the kind of side-channel attack that Spectre and friends are variants of were studied back in the mainframe days, well before anyone got around to inventing them (;-))<br>
<p>
--dave<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816590/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816593"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 13:27 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/816593/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>Note, though, that even in-order CPUs can be affected. The core of Spectre family attacks is that the CPU speculatively executes code that changes micro-architectural state, and thus any CPU with speculation can be affected. There exist demonstrations that suggest that the Cortex A53, for example, is partially affected by Spectre, but the resulting side channel is too limited to be practical with the currently known exploits.
<p>In theory, even a branch predictor can carry enough state to be attacked!
      
          <div class="CommentReplyButton">
            <form action="/Articles/816593/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 15:12 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/816635/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes: in an experiment at Sun, we found branch prediction could cause differing numbers of cache-line fills. Logically you could use it to signal single bits, for a lowish-speed side channel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816636"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 15:37 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816636/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Yes, in-order CPUs perform branch prediction and use that to perform several stages of the pipeline of the first predicted instructions, but normally they do not do anything that depends on the result of one of the predicted instructions; they would need some kind of register renaming functionality for that, and if as a hardware designer you go there, you can just as well do a full OoO design.

<p>A Spectre-style attack consists of a load of the secret, and some action that provides a side channel, with a data flow from the load to the action (otherwise you don't side-channel the secret).  An OoO processor can do that, but an in-order processor as outlined above cannot AFAICS.  If you can provide a reference to the A53 demonstration, I would be grateful.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816636/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2020 18:18 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/816669/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Even something as apparently trivial as using the branch predictor to decide which instructions to fetch is enough to make a timing difference that Spectre-type exploits can predict. "All" you need to do is ensure that the branch predictor correctly predicts for a single value of the secret and mispredicts for all others (or vice-versa), and that I have a timer that lets me determine whether or not the branch predictor correctly predicted (made easier if I can control L1I$ contents), and I have a side-channel. Not a very good side channel, but enough that I can extract secrets slowly.
<p>And there's no point having a branch predictor if you then insert a pipeline bubble that means that there's no timing difference between a correct prediction and a mispredict; it's that timing difference that creates the side-channel, though, so you need to somehow prevent the attacker from measuring a timing difference there to be completely Spectre-free.
<p>The demonstration was something in-house, using exactly the components I've described above; it was a slow enough channel to be effectively useless, but it existed.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2020 7:59 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816722/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, the branch predictor can be used as the side channel; in a Spectre-type attack the action part would then be a branch.

<p>But for a Spectre-type attack the branch predictor needs to be updated based on the speculatively loaded value.  This does not happen in in-order processors (because the execution does not get that far), and it will not happen in a Spectre-resistant OoO CPU (e.g., by only updating the branch predictor based on committed branches).

<p>Note that not all side-channel attacks are Spectre attacks.  We can prevent some side channels through hardware design.  E.g., there are Rowhammer-immune DRAMs; I also dimly remember some CPU-resource side channel (IIRC a limitation on the cache ports) that was present in one generation of Intel CPUs, but not in the next generation, which had more resources.  Closing other side channels in the non-speculative case appears to be too expensive, e.g., cache and branch predictor side channels, as you explain.

<p>There are established software mitigations for protecting critical secrets (branchless code, data-independent memory accesses for code that handles these secrets) such as encryption keys from non-Spectre/Meltdown side channels.   But these do not help against Spectre, because Spectre can use all code in the process to extract the secret.

<p>From your description, you read about a non-Spectre side-channel attack through the branch predictor of the A53.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor816735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2020 14:30 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/816735/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A Spectre-style attack consists of a load of the secret, and some action that provides a side channel, with a data flow from the load to the action (otherwise you don't side-channel the secret). An OoO processor can do that, but an in-order processor as outlined above cannot AFAICS.</font><br>
<p>
I don't see why an in-order processor couldn't do that, in principle. They're still going to do branch prediction, and speculatively push some instructions from the predicted target into the start of the pipeline. Once they detect a mispredict they'll flush the pipeline and start again with the correct target. As long as the flush happens before the mispredicted instructions reach a pipeline stage that writes to memory or to registers, that should be safe (ignoring Spectre). But if the mispredicted instructions read from a memory address that depends on a register (which may contain secret data), and the read modifies the TLB state or cache state, then it would be vulnerable to Spectre-like attacks.<br>
<p>
(I'm thinking of an artificial case like "insecure_debug_mode = 0; int x = secret; if (insecure_debug_mode) x = array[x];", where mispredicting the 'if' means the very next instruction will leak the secret data via the cache. It doesn't need a long sequence of speculative instructions. That could be a case where the programmer has carefully analysed the expected code path to avoid data-dependent memory accesses etc so their code is safe from side-channels attacks according to the advertised behaviour of the processor, but the processor is speculatively executing instructions that the programmer did not expect to be executed, so I think that counts as a Spectre vulnerability. As I see it, the fundamental issue with Spectre is that it doesn't matter how careful you are about side-channels when writing code, because the processor can (speculatively) execute an arbitrarily different piece of code that is almost impossible for you to analyse.)<br>
<p>
In practice, in-order processors seem to typically have short enough pipelines that the misprediction is detected within a few cycles, before the mispredicted instructions have got far enough through the pipeline to have any side effects. But that seems more by luck than by design, and maybe some aren't quite lucky enough. OoO processors aren't more dangerous because they're OoO, they're more dangerous because they typically have much longer pipelines and mispredicted instructions can progress far enough to have many side effects.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2020 16:10 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816760/">Link</a>] 
      </p>
      
      </div>
      </summary>
      So you are thinking about an architecturally visible (i.e., non-speculative) secret, and using speculation only for the side channel.  One difference from the classical Spectre attacks is that, like for non-speculative side-channel attacks, software developers only need to inspect the code that deals with the secret and avoid such ifs there; but yes, it's an additional rule they have to observe in such code.

<p>The length of the pipeline of an OoO processor is not the decisive factor.  Unlike an in-order processor, speculatively executed instructions on an OoO do not just enter the pipeline, they produce results that other speculatively executed instructions can use as inputs.  Essentially the in-order front end (instruction fetch and decoding) is decoupled from the in-order commit part (where the results become architecturally visible) by the OoO engine, and the front end can run far ahead (by hundreds of instructions and many cycles) of the commit part.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor816233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2020 9:32 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/816233/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><font class="QuotedText">
&gt; These techniques fell out of fashion when correctly predicted indirect branches became as fast as direct branches and indirect-branch prediction became pretty good. Now, with Spectre they may see a renaissance (hopefully a short one curtailed by the introduction of properly fixed hardware). 
</font></p>

<p>Inline caching and polymorphic inline caching are not only useful to avoid indirect branches, but also (and especially) to avoid method lookups in dynamic languages. The code for an inline cache would be more like this</p>

<pre>
    if (class != inline_cache-&gt;last_class) {
        inline_cache-&gt;last_class = class;
        inline_cache-&gt;last_method = hashtable_lookup(class, method_name);
    }
    inline_cache-&gt;last_method(...);
</pre>

where possibly <code>inline_cache-&gt;last_method</code> is not an indirect call but a patched (self-modifying) direct call.
      
          <div class="CommentReplyButton">
            <form action="/Articles/816233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2020 17:35 UTC (Mon)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/816286/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, inline caching was originally introduced in a Smalltalk implementation, which had a hash-table-based cache as an intermediate-speed path and the slow path was not even a hash table, but a linear search through the chain of superclasses (I don't remember what was used for looking up methods within a class).  I think that one reason for that was that the RAM sizes of the time discouraged speeding up the method lookup with complete hash tables or  full class*methods matrices.

<p>But why did they patch the code rather than using separate variables as your C code does?  The paper states

<blockquote>Note that this is a kind of dynamic
  code modification, which is generally condemned in modern
  practice. The n[ative]-method address can just as well be placed out-of-line and accessed indirectly; code modification is more
efficient, and we are using it in a well-confined way.
</blockquote>

Why was it more efficient?  Apart from the relative speed of direct vs. indirect calls at the hardware of the time there were the following factors:

<ul>
<li>Hardware at the time typically (I do not find what hardware they used) did not have a separate instruction cache, and therefore there was no cache consistency cost of writing to the code; by contrast, when I last measured it (IIRC on a Skylake CPU), writing to the cache line that also contains executed code had an overall cost of &gt;300 cycles.

<li>The hardware had just a single CPU core, so it was easy to protect against execution concurrent with the update of the inline cache (if that was an issue at all).
</ul>

One other difference from the C code you posted is that the actual check for the correct class was in the called method:

<blockquote>
     The entry code of an n-code method checks the stored
receiver class from the point of call against the actual receiver
class. If they do not match, relinking must occur, just as if the
call had not yet been linked.
</blockquote>
      
          <div class="CommentReplyButton">
            <form action="/Articles/816286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor816186"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 0:39 UTC (Sun)
                               by <b>ndesaulniers</b> (subscriber, #110768)
                              [<a href="/Articles/816186/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Consider the difference between having a collection of different objects, and calling a similarly identified method on each of them, vs having a function pointer that once assigned to never changes.  In the latter case, it would be nice to provide some form of optimization for these write once semantics (or even write-infrequently semantics, as is the current use of static keys).  In this case, it's possible to replace indirect calls with direct calls, and change them only when needed, which is both infrequent and relatively expensive compared to the cost of an indirect call.  You have to be careful about leaving enough space to patch in a jmp to an offset within an encode-able range, and be careful about concurrent modifications, but it's possible, and the kernel does so today, via static keys.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816186/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor816098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 7:36 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/816098/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If we compile the kernel with link-time optimization, in theory the compiler could know every possible value stored into a function pointer, such as a filesystem driver's callback functions. Together with a compiler plugin, could that allow generating devirtualized function calls to a fixed set of callback functions?<br>
<p>
(This would also allow eliminating a type of callback entirely if no non-NUL function is ever stored in that function pointer. That could optimize various kinds of function pointers that don't always get used in a given struct of pointers.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 9:07 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/816102/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was wondering how much of this would be dealt with if the kernel used C++, with virtual functions taking the place of the current indirect calls.  A good C++ compiler,  if it knows the type of an object, can optimize a virtual function call into a direct call.  Though I don't know whether any compiler has the option to generate retpolines or similar armouring.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 9:31 UTC (Fri)
                               by <b>gus3</b> (guest, #61103)
                              [<a href="/Articles/816103/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It isn't a virtual "function"; it's a virtual method bound to an object. It's most useful when the derived class of the object is unknown at runtime, so the call is made through the base class instead, which fetches the method pointer from the object (via _vptr in g++) in order to make the "proper" call.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2020 9:39 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/816104/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was trying to follow the C++ terminology that calls them functions rather than methods.  To be completely clear I should have said 'virtual member function'.  See <a href="http://www.stroustrup.com/glossary.html">http://www.stroustrup.com/glossary.html</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2020 10:41 UTC (Sat)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816180/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is correct. Furthermore, a virtual member function *really is* just a function. The implied object is just a pointer argument passed to the function, and might not even be used there.<br>
<p>
Fetishism around object-oriented conventions is worse than pointless. Virtual calling is a language mechanism that has various uses, implementing polymorphic runtime binding being one among them. <br>
<p>
Sometimes virtual calls perform better than calling through a function pointer, because there is less choice. But sometimes the function pointer call is faster, particularly if the pointer rarely or never changes. On modern cores, both are hardly slower than a direct call except in pathological cases.<br>
<p>
A virtual call, by offering fewer choices for what could happen, is often easier for a reader to understand than a call through a function pointer. So, it is often a good idea to cobble up a base class just to provide a virtual call, even where there is logically no meaningful object involved. Having cobbled one up, though, it often becomes useful to park things there. Having parked things there, it may be worth formalizing a class with invariants. Or it might not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2020 19:12 UTC (Sat)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/816181/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The technique in the article is for the "pathological" case of retpolines, which don't allow speculation and hence are guaranteed to be much slower than direct calls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 3:18 UTC (Sun)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816187/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems like a virtual call would be closely akin to the static mechanism, as the vtable array of function pointers is in the object-code, "text" section.<br>
<p>
But of course C++ code is hard to get into the kernel. Linus's deliberate choice to use C++ keywords in kernel headers is one barrier to overcome.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 4:06 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/816188/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Virtual calls in C++ defeat the whole purpose of the exercise. They still require an indirect jump and so can be exploited by Spectre.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816192"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 10:41 UTC (Sun)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/816192/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are missing th historical perspective.<br>
Stroupstrup deliberate choice to break C compatibility by adding new keyword to C++ is one barrier to overcome.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816192/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816193"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 12:28 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/816193/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The historical perspective includes the fact that Linux is newer than C++.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816193/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2020 18:07 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/816789/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In a perfect world (lets call it TexC) keywords would start with backslash...<br>
<p>
\let foo: u32 = 0;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2020 17:18 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/816812/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that's overdoing it. Even C's done that, repeatedly. Do you blame the ANSI C committee for adding new keywords? (They added almost as many as C++ did.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2020 15:03 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/816891/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aren't they all in the `_Upper` namespace (namepattern?) though? C reserved that long ago (and is why C++ can't use it either; C may add names there at any time).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor816197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 15:11 UTC (Sun)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/816197/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure what you mean by that. The "static" mechanism discussed in the article is self-modifying code that patches the text to make a direct call. The vtable array is just a const array of function pointers, but is still accessed via an indirect call, which would have all the overhead of retpoline blocking branch prediction. The "closely akin" method would be if the compiler optimizes the virtual function call to a couple of test-and-direct-branch based on knowledge of what types could be involved.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor816196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding retpolines with static calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2020 15:07 UTC (Sun)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/816196/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would hope that the -mindirect-branch option if used also uses retpolines for virtual calls, not just function pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
