        <!DOCTYPE html>
        <html lang="en">
        <head><title>What's scheduled for sched_ext [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/974387/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/974710/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/974387/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>What's scheduled for sched_ext</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Daroc Alden</b><br>May 23, 2024</br>
           <hr>
<a href="/Articles/lsfmmbpf2024/">LSFMM+BPF</a>
</div>
<p>
David Vernet's second talk at the 2024
<a href="https://events.linuxfoundation.org/lsfmmbpf/">Linux Storage,
Filesystem, Memory Management, and BPF Summit</a> was a summary of the state of
sched_ext, the extensible BPF scheduler that <a href="/Articles/972710/">LWN
covered in early May</a>. In short, sched_ext is intended as a platform for
rapid experimentation with schedulers, and a tool to let performance-minded
administrators customize the scheduler to their workload. The patch set has seen
several revisions, becoming more generic and powerful over time.
Vernet spoke about what has been done in the past year,
and what is still missing before sched_ext can be considered pretty much
complete.
</p>

<h4>A year of improvements</h4>

<p>
Vernet opened the talk with a bit of background on sched_ext, and then
went through a quick list of improvements made in the last year. First on
his list was better debugging support, including hooks for dumping
information about the running sched_ext scheduler to user space. He gave a demo,
showing how to dump the list of tasks being managed by the scheduler and their
states. He then spoke
about the work done to integrate sched_ext more tightly with the CPU-frequency
and scaling code. That work involved adding kfuncs to let BPF control the CPU
frequency, but also improving the tracking code to make use of the current
frequency when accounting how long a task ran for. The pieces are all in place
now for sched_ext schedulers to implement
<a href="/Articles/531853/">per-entity load tracking</a> (PELT), Vernet said.
</p>

<p>
Other improvements include some changes to the dispatch API, hotplug support,
and better backward compatibility. The sched_ext code has also motivated
expanding BPF's support for <a href="/Articles/900749/">kptrs</a> (pointers to kernel objects).
</p>

<p>
Vernet spoke next about the improvements to the schedulers themselves,
highlighting two in particular. <tt>scx_rusty</tt> is a hybrid BPF/user-space
scheduler; it handles load balancing and statistics in user space, with the
hot-path decisions made in BPF. <tt>scx_rusty</tt> improves on
<a href="/Articles/969062/">
the new EEVDF scheduler</a> for
latency-sensitive tasks, such as gaming, by using slightly different heuristics.
EEVDF uses a task's eligibility and time-slice length to determine when to schedule
it. Unfortunately, slice length is not responsive to the actual workload.
It can be configured by an administrator, but often isn't, particularly because
it can often be hard to tell what slice length is appropriate for a workload.
<tt>scx_rusty</tt> uses the length of time for which a task actually ran,
instead of its static slice length, which lets it schedule tasks that only run
for a short time before blocking more frequently than tasks that use their
whole time quantum. The scheduler also considers whether the task often blocks
waiting for other tasks (indicating a consumer), wakes other tasks (indicating a
producer), or both (indicating the middle of a pipeline).
It factors this information in to the virtual deadline calculated for the task,
slightly prioritizing tasks that block frequently, and greatly prioritizing
tasks that wake other threads.
</p>

<p>
These improvements combine to make <tt>scx_rusty</tt> noticeably more performant
for games. Vernet showed another demo of a game experiencing lag under EEVDF,
which immediately disappears upon enabling <tt>scx_rusty</tt>. Normally,
interactivity is a tradeoff against throughput. Vernet claimed that
<tt>scx_rusty</tt> actually <em>also</em> has slightly better throughput than EEVDF,
but didn't cite specific numbers.
</p>

<p>
The other scheduler Vernet highlighted was <tt>scx_layered</tt>, a
statically-configured scheduler. Users can sort processes into "layers" by
factors like the name of the executable, the process's control group,
or other metadata. Each layer
can then be statically configured with different properties. He said that Meta
uses the scheduler for a lot of web workloads, where the ability to have
fine-grained control over scheduling was valuable.
</p>

<p>
There are other sched_ext schedulers in active development, including
<tt>scx_lavd</tt>, a scheduler designed specifically for the Steam Deck, and
<tt>scx_rustland</tt>, which delegates scheduling decisions to user space. Since
last year, many of the sched_ext schedulers were moved into
<a href="https://github.com/sched-ext/scx">
a separate GitHub
repository</a> from
<a href="https://github.com/sched-ext/sched_ext">
the main sched_ext code</a>. Vernet said the scheduler repository was intended to have a low
barrier to entry, calling for people to "submit your scheduler, do whatever",
hopefully leading to an exchange of ideas. The repository also has some helpful
libraries and Rust crates for writing schedulers.
Vernet was careful to point out that the schedulers moved to the separate
repository remain GPLv2 licensed, even if they are no longer intended to become
part of the kernel sources —
and, in fact, the BPF verifier refuses to load code that does not claim to be
GPLv2-licensed.
</p>

<h4>What's coming</h4>

<p>
Vernet then turned to what remains to be done. "It's incredible what you can do
in schedulers already," but there are still areas to work on, he said. Some
examples of rough edges right now include the facts that BPF programs can't hold
a spinlock around a kernel function call, nested structures that contain pointers to
kernel objects confuse the verifier, and BPF programs still have an incredibly
small stack size (512 bytes), which is sometimes hard to work around.
He also commented that it would be nice if the build system could be made to
produce bindings that are more amenable to safe backward compatibility.
</p>

<p>
Despite
that, Vernet called the situation on the BPF side "really really encouraging,"
and said that the most helpful thing people could do at this point would be to
improve existing schedulers, particularly adding tests. He also highlighted a
few different areas of upcoming work, including restructuring things so that a
scheduler can be attached to a specific control group. That is one use case for
larger BPF stacks, because it means that schedulers could be called recursively
(since control groups can be nested). Another upcoming item is managing idle
policies — currently, these are managed separately from the scheduler, but
Vernet is "not convinced that they should be". All of the recent improvements have
had some spillover benefits, as well. The recent cpufreq tuning has uncovered
bottlenecks elsewhere in the code, and the sched_ext work has motivated
other improvements to BPF that are likely to be useful elsewhere.
</p>

<p>
Vernet concluded by asking people to join the conversation on the mailing list
if sched_ext was useful to them, noting that it will be the users who
ultimately cause the feature to be merged. At that point, discussion opened up more
widely, with several people having questions about Vernet's summary.
</p>

<p>
One audience member asked what Vernet was working on next in terms of core BPF
programs. He responded with two main items: stack allocation
(<a href="https://man7.org/linux/man-pages/man3/alloca.3.html"><tt>alloca()</tt></a>)
for BPF programs, and making it possible to attach <tt>struct_ops</tt> programs to a
control group, instead of having them all be global. Vernet also intends to make small
usability improvements wherever possible. He called out holding a spinlock
around a call to a kfunc as an example, saying that this is what prevents people
from implementing EEVDF in sched_ext for rapid experimentation.
</p>

<p>
Another participant asked what Vernet thought about tail-end latency (how long
the longest operations take) versus
generic latency (how long operations take on average),
and whether that presented any areas for scheduler improvement.
Vernet clarified that for gaming, people mostly care about tail latency.
<tt>scx_rusty</tt>, the scheduler he demonstrated,
reduces the time slices it gives out when the system
is overloaded in order to help with that. But Vernet doesn't think that
improving tail-end latency needs to come at the expense of generic latency or
vice versa: "I think we could get a win on every front." The audience member was
skeptical about that, saying that existing schedulers have a lot of optimization
put into them. Vernet remained optimistic, however, saying that EEVDF is
relatively new, and therefore there may still be places to make improvements.
</p>

<p>
A third audience member noted that they had looked at running EEVDF on
Chromebooks for the upcoming <a href="https://retis.sssup.it/ospm-summit/">Power
Management and Scheduling in the Linux Kernel</a> (OSPM) conference, and had
seen a big reduction in tail latency. Vernet asked what version of the kernel
that was, to which the audience member responded that they had actually
backported EEVDF to 5.15 and disabled the eligibility checks. Vernet replied
that EEVDF's eligibility mechanism hurts the latency of the system, but without
it the scheduler doesn't actually bound lag. He continued to say that ideally
the perfect scheduler would adapt to what the system is actually doing.
</p>

<p>
Sched_ext has continued improving, becoming increasingly tempting for
workloads that have been less well-served by traditional schedulers, but there
remain some bumps in the road before it becomes as useful as it could be. Minor
BPF improvements will open up much more flexibility for future schedulers, but
the big remaining obstacle is getting the code merged at all — even though the
topic was hardly touched on.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF-CPU_scheduling">BPF/CPU scheduling</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler-Extensible_scheduler_class">Scheduler/Extensible scheduler class</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2024">Storage, Filesystem, Memory-Management and BPF Summit/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/974387/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor974850"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's scheduled for sched_ext</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2024 17:57 UTC (Thu)
                               by <b>shironeko</b> (subscriber, #159952)
                              [<a href="/Articles/974850/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
maybe I'm missing something, but is the difficulty with testing schedulers the normal way in that you need to reboot the system?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/974850/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor974863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's scheduled for sched_ext</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2024 20:28 UTC (Thu)
                               by <b>daroc</b> (editor, #160859)
                              [<a href="/Articles/974863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that's certainly the main difficulty with testing schedulers. The other problem, as I understand it, is that it's relatively easy to wedge a system by not scheduling a task. Sched_ext also has some safeguards that kick out the BPF program if it fails to schedule a pending task within a given timeout.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/974863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor974941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's scheduled for sched_ext</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2024 15:45 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/974941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The other difficulty is that people like Google have systems with wildly different load profiles that need different knobs to control their scheduler. You don't want five schedulers. Or a single one that understands all of these controls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/974941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor975467"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's scheduled for sched_ext</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 27, 2024 23:11 UTC (Mon)
                               by <b>gghh</b> (subscriber, #102105)
                              [<a href="/Articles/975467/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; maybe I'm missing something, but is the difficulty with testing schedulers the normal way in that you need to reboot the system?</span><br>
<p>
Yes I think you're missing something!<br>
<p>
2001, Apple releases iPod, the Slashdot guy goes "No wireless. Less space than a Creative Nomad. Lame."<br>
2007, Drew Houston and Arash Ferdowsi make Dropbox, the top HN comment is "On Linux you can already do this with an FTP server mounted locally."<br>
<p>
Your comment gives me the same vibes :)<br>
<p>
There is no "testing schedulers the normal way", because there is only one scheduler, singular quantity. That was CFS by Ingo Molnár for 15 years, and it's EEVDF by Peter Zijlstra since last October.<br>
The realtime schedulers are trivial and come verbatim from the POSIX spec: round-robin (take turns) and fifo (just run). deadline.c from 2012 is sophisticated, so that could warrant you saying "there exists another scheduler", but it came out of circumstances so exceptional, and never repeated since, that it doesn't count. No less that four phd students, and as many tenured researches from Italy, so dead set on getting it upstream that the maintainer eventually said "alright alright I'll merge this".<br>
<p>
What you really do today isn't "testing schedulers", but rather testing tiny tweaks, little changes to the heuristic of the only one scheduler you've got. Uhm, what if I prioritize the task that just woke up from waiting on I/O? Five lines diff. Let's try packing tasks on fewer cores so they get a clock boost; another five lines diff. No wait, let's spread tasks over many cores otherwise we waste resources. Undo previous five lines diff. It goes on.<br>
<p>
If you want to try something radically different, say a tickless scheduler that only sends a rescheduling IPI when needed (or whatever)? Where do you even begin? Sure, technically you can create your own new class, but boy... the last time someone did it was in 2012! The muscle has atrophied. People forgot how it's done. Sched-Ext makes this easy, that's the point. Fill in the blanks for the select_cpu()/enqueue()/dequeue() callbacks and boom, you're in business. Doesn't even need to be kernel code, you can do that in userspace. Doesn't it sound fun?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/975467/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor975470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's scheduled for sched_ext</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 27, 2024 23:26 UTC (Mon)
                               by <b>shironeko</b> (subscriber, #159952)
                              [<a href="/Articles/975470/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How it's that different from fill in the blank directly? What you described still sounds like the only difference is whether you need to reboot or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/975470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor975484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's scheduled for sched_ext</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 28, 2024 5:11 UTC (Tue)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/975484/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Loading a scheduler module does not have to mean that a reboot is required. The BPF code could just be a normal loadable module. "Pluggable scheduler" has been discussed 20 years ago already.<br>
<p>
I also don't really understand why this must be BPF code.<br>
Yes, sure, you can't crash the kernel with it. That's probably the main benefit. Granted.<br>
But I think it would be better to substitute the BPF code with a Rust module in sched_ext.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/975484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
