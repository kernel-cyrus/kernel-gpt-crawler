        <!DOCTYPE html>
        <html lang="en">
        <head><title>Supporting filesystems in persistent memory [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/610174/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/609799/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/610174/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Supporting filesystems in persistent memory</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we donâ€™t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 2, 2014</br>
           </div>
For a few years now, we have been told that upcoming non-volatile memory (NVM)
devices are going to change how we use our systems.  These devices provide
large amounts (possibly terabytes) of memory that is persistent and that
can be 
accessed at RAM speeds.  Just what we will do with so much persistent
memory is not entirely clear, but it is starting to come into focus.  It
seems that we'll run ordinary filesystems on it â€” but those filesystems
will have to be tweaked to allow users to get full performance from NVM.
<p>
It is easy enough to wrap a block device driver around an NVM device and make it
look like any other storage device.  Doing so, though, forces all data on
that device to be copied to and from the kernel's page cache.  Given that
the data could be accessed directly, this copying is inefficient at best.
Performance-conscious users would rather avoid use of the page cache
whenever possible so that they can get full-speed performance out of NVM
devices. 
<p>
The kernel has actually had some support for direct access to non-volatile
memory since 
2005, when <a href="/Articles/135472/">execute-in-place (XIP)</a> support was
added to the ext2 filesystem.  This code allows files from a
directly-addressable device to be mapped into user space, allowing file
data to be accessed without going through the page cache.  The XIP code has
apparently seen little use, though, and has not been improved in some
years; it does not work with current filesystems.
<p>
Last year, Matthew Wilcox began work on improving the XIP code and
integrating it into the ext4 filesystem.  Along the way, he found that it
was not well suited to the needs of contemporary filesystems; there are a
number of unpleasant race conditions in the code as well.  So over time,
his work shifted from enhancing XIP to replacing it.  That work, currently
<a href="/Articles/609652/">a 21-part patch set</a>, is getting closer to
being ready for merging into the mainline, so it is beginning to get a bit
more attention.
<p>
Those patches replace the XIP code with a new subsystem called DAX (for
"direct access," apparently).  At the block device level, it replaces the
existing <tt>direct_access()</tt> function in <tt>struct
block_device_operations</tt> with one that looks like this:
<p>
<pre>
    long (*direct_access)(struct block_device *dev, sector_t sector,
			  void **addr, unsigned long *pfn, long size);
</pre>
<p>
This function accepts a <tt>sector</tt> number and a <tt>size</tt> value
saying how many bytes the caller wishes to access.  If the given space is
directly addressable, the base (kernel) address should be returned in
<tt>addr</tt> and the appropriate page frame number goes into
<tt>pfn</tt>.  The page frame number is meant to be used in page tables
when arranging direct user-space access to the memory.
<p>
The use of page frame numbers and addresses may seem a bit strange; most of
the kernel deals with memory at this level via <tt>struct page</tt>.  That
cannot be done here, though, for one simple reason: non-volatile memory is
not ordinary RAM and has no <tt>page</tt> structures associated with it.
Those missing <tt>page</tt> structures have a number of consequences;
perhaps most 
significant is the fact that NVM cannot be passed to other
devices for DMA operations.  That rules out, for example, zero-copy network
I/O to or from a file stored on an NVM device.  Boaz Harrosh is working on
<a href="/Articles/608538/">a patch set</a> allowing <tt>page</tt>
structures to be used with NVM, but that work is in a relatively early
state.
<p>
Moving up the stack, quite a bit of effort has gone into pushing NVM
support into the virtual filesystem layer so that it can be used by all
filesystems.  Various generic helpers have been set up for common
operations (reading, writing, truncating, memory-mapping, etc.).  For the
most part, the filesystem need only mark DAX-capable inodes with the new
<tt>S_DAX</tt> flag and call the helper functions in the right places; see
<a href="/Articles/610316/">the documentation in the patch set</a> for (a
little) more information.
The patch set finishes by adding the requisite support to ext4.
<p>
Andrew Morton <a href="/Articles/610182/">expressed some skepticism</a>
about this work, though.  At the top of his list of questions was: why not
use a "<q>suitably modified</q>" version of an in-memory filesystem
(ramfs or tmpfs, for example) instead?  It seems like a reasonable
question; those filesystems are already designed for directly-addressable
memory and have the necessary optimizations.  But RAM-based filesystems are
designed for RAM; it turns out that they are not all that well
suited to the NVM case.
<p>
For the details of why that is, <a href="/Articles/610184/">this message
from Dave Chinner</a> is well worth reading in its entirety.  To a
great extent, it comes down to this: the RAM-based filesystems have not
been designed to deal with persistence.  They start fresh at each boot and
need never cope with something left over from a previous run of the
system.  Data stored in NVM, instead, is expected to persist over reboots,
be robust in the face of crashes, not go away when the kernel is upgraded,
etc.  That adds a whole set of requirements that RAM-based filesystems do
not have to satisfy.
<p>
So, for example, NVM filesystems need all the tools that traditional filesystems
have to recognize filesystems on disk, check them, deal with corruption,
etc.  They need all of the techniques used by filesystems to ensure that the
filesystem image in persistent storage is in a consistent state at all
times; metadata operations must be carefully ordered and
protected with barriers, for example.  Since compatibility with different kernels is
important, no in-kernel data structures can be directly stored in the
filesystem; they must be translated to and from an on-disk format.
Ordinary filesystems do these things; RAM-based filesystems do not.
<p>
Then, as Dave explained, there is the little issue of scalability:
<p>
<div class="BigQuote">
	Further, it's going to need to scale to very large amounts of
	storage.  We're talking about machines with *tens of TB* of NVDIMM
	capacity in the immediate future and so free space management and
	concurrency of allocation and freeing of used space is going to be
	fundamental to the performance of the persistent NVRAM filesystem.
	So, you end up with block/allocation groups to subdivide the space.
	Looking a lot like ext4 or XFS at this point.
<p>
	And now you have to scale to indexing tens of millions of
	everything. At least tens of millions - hundreds of millions to
	billions is more likely, because storing tens of terabytes of small
	files is going to require indexing billions of files. And because
	there is no performance penalty for doing this, people will use the
	filesystem as a great big database. So now you have to have a
	scalable posix compatible directory structures, scalable freespace
	indexation, dynamic, scalable inode allocation, freeing, etc. Oh,
	and it also needs to be highly concurrent to handle machines with
	hundreds of CPU cores.
</div>
<p>
Dave concluded by pointing out that the kernel already has a couple of
"persistent storage implementations" that can handle those needs: the XFS
and ext4 filesystems (though he couldn't resist poking at the scalability
of ext4).  Both of them will work now on a block device based on persistent
memory.  The biggest thing that is missing is a way to allow users to directly
address all of that data without copying it through the page cache; that is
what the DAX code is meant to provide.
<p>
There are groups working on filesystems designed for NVM from the
beginning.  But most of that work is in an early stage; none has been
posted to the kernel mailing lists, much less proposed for merging.  So
users wanting to get full performance out of NVM will find little help in
that direction for some years yet.  It is thus not unreasonable to conclude
that there will be some real demand for the ability to use today's
filesystems with NVM systems.
<p>
The path toward that capability would appear to be DAX.  All that is needed
is to get the patch set reviewed to the point that the relevant subsystem
maintainers are comfortable merging it.  That review has been somewhat slow
in coming; the patch set is complex and touches a number of different
subsystems.  Still, the code has changed considerably in response to the
reviews that have come in and appears to be getting close to a final
state.  Perhaps this functionality will find its way into the mainline in a
near-future development cycle.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#DAX">DAX</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Nonvolatile_memory">Memory management/Nonvolatile memory</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/610174/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor610492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 2:36 UTC (Wed)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/610492/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was going to ask essentially the same question as Andrew Morton, along the lines of "Why not just treat it as persistent RAM, aka a RAM disk?"  But the point about persistence requiring consistency checks and the other features that a full-on filesystem provides is a good one.<br>
<p>
Now I just find myself hoping that the DAX feature, somewhere, has something called "Jadzia"...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 23:56 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/610671/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Pick the previous host. It's quite plausible that a filesystem could be split into zones of some kind and have some identifier somewhere relating to the current zone...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor610506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 8:41 UTC (Wed)
                               by <b>lpremoli</b> (guest, #94065)
                              [<a href="/Articles/610506/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For some time I have been studying PRAMFS and I think that PRAMFS pretty much satisfies most requirements an NVM has (persistency, memory mappable contents, simple structures and small code base).<br>
<p>
Does anybody have comments about the fitting of PRAMFS with mmappable NVMs?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610513"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 10:11 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/610513/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Looking at PRAMFS's tech page <a href="http://pramfs.sourceforge.net/tech.html">on SourceForge</a>, I seriously doubt its suitability for multi-terabyte file systems. A free-block <i>bitmap</i>, linear directories, and no hard links? No way.
      
          <div class="CommentReplyButton">
            <form action="/Articles/610513/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610637"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 21:48 UTC (Wed)
                               by <b>ssl</b> (guest, #98177)
                              [<a href="/Articles/610637/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; free block bitmap</font><br>
<p>
By the way, is there a comparision how modern FS keep tabs on free space?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610637/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor611761"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2014 19:40 UTC (Fri)
                               by <b>vedantk</b> (guest, #88435)
                              [<a href="/Articles/611761/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Btrfs: Btrfs keeps track of the space it allocates in its extent tree [1]. Holes between extents correspond to free space. There's a free space cache but no explicit free space tracking [2].<br>
<p>
ZFS: ZFS appends allocation/deallocation metadata to a log, which it replays into an in-memory AVL tree. You can read about ZFS-style space maps in [3].<br>
<p>
Those are the only two `modern' (read: non-bitmappy) approaches I know of, but I could be missing others.<br>
<p>
[1]: <a rel="nofollow" href="https://btrfs.wiki.kernel.org/index.php/Btrfs_design#Extent_Trees_and_DM_integration">https://btrfs.wiki.kernel.org/index.php/Btrfs_design#Exte...</a><br>
<p>
[2]: <a rel="nofollow" href="https://btrfs.wiki.kernel.org/index.php/Glossary">https://btrfs.wiki.kernel.org/index.php/Glossary</a><br>
<p>
[3]: <a rel="nofollow" href="https://blogs.oracle.com/bonwick/en/entry/space_maps">https://blogs.oracle.com/bonwick/en/entry/space_maps</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611761/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor610523"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 11:33 UTC (Wed)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/610523/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Does anybody have comments about the fitting of PRAMFS with mmappable NVMs</font><br>
<p>
I've got a quote for you:<br>
<br>
| That's where we started about two years ago with that<br>
| horrible pramfs trainwreck.<br>
<p>
Bonus points for working out which village idiot said that and where it fits in the context of the discussion. ;)<br>
<br>
-Dave.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610523/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 11:50 UTC (Wed)
                               by <b>lpremoli</b> (guest, #94065)
                              [<a href="/Articles/610532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks Dave. I googled your quote and found the village person you mention and his comments ;)<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor611285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2014 11:41 UTC (Tue)
                               by <b>compudj</b> (subscriber, #43335)
                              [<a href="/Articles/611285/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
About PRAMFS: we tried using it to map the LTTng tracer ring buffer, so we could recover user-space and kernel traces after crash. Unfortunately, PRAMFS does not support a very useful and obvious use-case: memory mapping a file backed by persistent memory with MAP_SHARED; it only supports MAP_PRIVATE, which actually keeps the written pages in the page cache, which pretty much defeats the purpose of non-volatile memory.<br>
<p>
In the case of tracing, we really want to bypass the page cache. Moreover, we don't want the performance hit of going through a system call for each event.<br>
<p>
So this DAX patchset, assuming it supports MAP_SHARED memory maps, is really welcome from a tracing POV. Having the ability to associate struct page to those memory regions will be useful for kernel tracing too.<br>
<p>
Thanks!<br>
<p>
Mathieu<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor610547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 14:48 UTC (Wed)
                               by <b>markusw</b> (guest, #53024)
                              [<a href="/Articles/610547/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wait a second. When talking about "persistent memory", are we looking at (block) devices (speaking ATA or SCSI) or something closer to byte-addressable RAM?<br>
<p>
In the former case, I'm wondering if the page cache really is inefficient, as I think RAM is likely to keep some latency margin compared to any kind of sufficiently big NVM device. (Why else would you keep the RAM if NVM was available in "tens of TB" and equal latency?) In any case: sure, use a block based filesystem for what basically is a block device.<br>
<p>
In the latter case, I don't quite think a block based filesystem is a good fit. Nor a non-persistent one.<br>
<p>
(And no, with all its queue management and 64 byte long commands, I don't consider NVMe to be byte-addressable. Not efficiently. It may well "ensur[e] efficient small random I/O operation" [1] as long as you consider 4K a small I/O operation.)<br>
<p>
Markus<br>
<p>
[1]: <a href="http://www.nvmexpress.org/about/nvm-express-overview/">http://www.nvmexpress.org/about/nvm-express-overview/</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610564"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2014 16:01 UTC (Wed)
                               by <b>busterb</b> (subscriber, #560)
                              [<a href="/Articles/610564/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article mentions NVDIMMs, which are byte-addressable (well, as byte addressable as a DDR3 can be, if we're being pedantic). Current implementations are usually RAM + FLASH + some sort of backup power, but I assume there's something greater on the horizon.<br>
<p>
I think it'd be great to have a form of hibernation that would allow the DRAM refresh to be completely disabled. I've worked on embedded server systems whether or not to enable the memory controllers when the CPU was not in use was a real bone of contention between the software developers (who wanted to use more memory for the management processor cores) and the hardware guys (who wanted the lowest power consumption when the main processor cores were powered off.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610564/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor610685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2014 4:55 UTC (Thu)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/610685/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
persistent memory == cpu addressable memory that is persistent.<br>
<p>
That means PCIe based devices such as NVMe storage as well as NVDIMMs that you plug into normal ddr3/ddr4 slots. All "byte addressable" but the actual minimum read/write resolution is that of a CPU cacheline. i.e. any sub-cacheline size modification requires a RMW cycle by the CPU on that cacheline. So really there is no difference between NVMe devices or NVDIMMs apart from protocols and access latency.<br>
<p>
However, all this NVRAM is still *page based* due to requiring the physical memory to be virtually mapped. This means the "block sizes" for storage is the page sizes the hardware TLB  can support are. i.e. 4k or 2M for x86-64. IOWs, to optimise storage layout to minimise page faults we really need to allocate in page aligned chunks and not share pages between files. Which is exactly what a block based filesystem does ;).<br>
<p>
SO, really, when you look at persistent memory, it's really just a very fast block device where the block size is determined by the CPU TLB architecture rather than the sector size used by traditional storage.<br>
<p>
Like flash based SSDs before NVRAM, the architectural structure is not very different to storage we've been using for 50 years. The speeds and feeds are faster, but the same access and optimisation algorithms  apply to the problem. We don't need to completely redesign the wheel to take advantage of the new technology - we only need to do that if we want to eek every last bit of performance out of it.<br>
<p>
As for the question of "why do we need RAM if we have tens of TB of NVRAM" I'll just say this: most of the information the kernel keeps for running the machine is volatile. It's not designed to be persistent. If you just want a machine to have persistent memory, the OS needs to be designed from the ground up to be stateless and to *never corrupt itself*. When everything is persistent, rebooting does not fix problems...<br>
<p>
-Dave.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2014 13:23 UTC (Thu)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/610719/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  SO, really, when you look at persistent memory, it's really just a very fast block device where the block size is determined by the CPU TLB architecture rather than the sector size used by traditional storage.</font><br>
<p>
Does that means that a particular device will only be readable on some hardware and not some others ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2014 3:00 UTC (Fri)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/610843/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup, nothing new there. We already have to deal with that with filesystems made on a 64k page architecture with a 64k block sizw. They can't be mounted and used on an architecture with a 4k page size, because the linux kernel does not support block size &gt; page size.<br>
<p>
-Dave.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610874"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2014 9:47 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/610874/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; because the linux kernel does not support block size &gt; page size</font><br>
<p>
FAT filesystems can have a "cluster size" bigger than page size, Linux probably only reject "device minimum access block size" &gt; page size<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610874/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor675187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 14:15 UTC (Thu)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/675187/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What does one do in that situation? <br>
<p>
This is not an idle question; I have inherited an apparently-Linux-based hard disk video recorder (now deceased) which seems to have created an ext3 file system with 8k blocks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2016 2:19 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/675459/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
mount it on something that has larger than 4K block size. IIRC this can be done with powerpc, sparc, and I think even AMD64 systems<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor610753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2014 14:26 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/610753/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That means PCIe based devices such as NVMe storage as well as NVDIMMs that you plug into normal ddr3/ddr4 slots.</font><br>
<p>
I am not sure both types can be treated the same way.<br>
- PCIe devices are hot-plug with sufficiently good hardware.<br>
- PCIe devices are better accessed with DMA, because then the length of the transfer is clearly known by the hardware before the start of the PCIe transaction (one PCIe transaction to transfer 4096 bytes versus a lot of transactions, one per cacheline or one per assembly instruction)<br>
- I am not sure memory caching is easy to enable on PCIe mapped memory, there is plenty of small details there...<br>
<p>
Also, are there conditions where a modification of the page-cache are not sent to the media, for instance a modified memory mapped file receiving a revoke system call?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2014 13:32 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/610896/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I am not sure memory caching is easy to enable on PCIe mapped memory, there is plenty of small details there...</font><br>
<p>
Like for instance? I naively thought it was MTRR and done.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor611138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2014 10:43 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/611138/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; I am not sure memory caching is easy to enable on PCIe mapped memory, there is plenty of small details there...</font><br>
&gt;<br>
<font class="QuotedText">&gt; Like for instance? I naively thought it was MTRR and done.</font><br>
<p>
If your processor support MTRR (most of them, but maybe do not crash if not), then you can use them - problem is their number is limited and their size/alignment is a bit strict.<br>
On newer processor you shall use PATs (<a href="http://en.wikipedia.org/wiki/Page_attribute_table">http://en.wikipedia.org/wiki/Page_attribute_table</a>).<br>
But the problem I was thinking of is that the PCIe connection to your persistent memory device may include PCIe bridges, and that bridge may have a different "Cache Line Size", its memory base address may not include the "Prefetchable" bit (see PCI specs) and few other stuff like that (like error recovery) due to PCI history...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor610758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2014 18:35 UTC (Thu)
                               by <b>markusw</b> (guest, #53024)
                              [<a href="/Articles/610758/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Granted, I omitted the cacheline size. However, the CPU/MMU happily writes individual cachelines to RAM, despite the VM mapping. I'd also argue that the VM page size barely has an influence on the block size of block devices (otherwise, moving from 512B to 4K sectors would have a noticeable impact; let alone the 2M pages).<br>
<p>
To me, the "architectural structure" of a NAND based SSD looks very different from magnetic tapes or disks. It's not that we're lucky to not have to modify our designs because the architecture didn't change. It did. A lot. It's our existing designs that force new technology to immitate something we already have, know and designed for.<br>
<p>
I certainly agree that it makes sense to use a file-system that was designed with block devices in mind on anything that resembles a block device. It also seems logical that a filesystem not designed for persistency is an utterly bad fit for NVM. And I can imagine getting quick results with a block device based filesystem on NVM. However, if the NVM device can write individual cachelines (and assuming that's not a lot less efficient than 4K block writes, as I would expect from something I connect to the CPU's memory bus), then a filesystem that assumes it needs to write a sector at a time doesn't feel like the right thing to me.<br>
<p>
I don't follow your last argument, either. By definition, volatile information doesn't need to persist across a reboot (unlike an FS on NVM, where your argument holds). If NVM would be cheaper than RAM (at the same capacity and latency), you could simply wipe the device (or relevant portions) upon boot to make it behave like RAM.<br>
<p>
However, persistence clearly is an additional feature (when compared to RAM). And I bet we continue to have to pay for that. Either with higher latency or higher price.<br>
<p>
Markus<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor611599"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2014 14:45 UTC (Thu)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/611599/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However, if the NVM device can write individual cachelines (and assuming that's not a lot less efficient than 4K block writes, as I would expect from something I connect to the CPU's memory bus), then a filesystem that assumes it needs to write a sector at a time doesn't feel like the right thing to me.</font><br>
<p>
That's the point of this DAX work, though - when a filesystem supports direct access, the NVM page *is* the page cache page, and at least for file data there's no writing of sectors at all.  A write() of 64 bytes will just result in a 64 byte copy_from_user() directly into the NVM.<br>
<p>
(The sticking point is that there will still be an in-memory inode structure and an "on-disk" inode structure stored in the NVM, which will probably mean that the entire NVM copy of the inode gets rewritten whenever an attribute like mtime changes).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611599/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor612680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2014 22:13 UTC (Sat)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/612680/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"If NVM would be cheaper than RAM .., you could simply wipe the device .. upon boot to make it behave like RAM."<br>
<p>
The security community is going to laugh at that if you don't have some kind of policy around not writing private keys to NVM. Which will probably not work. Existing applications don't have any concept of different kinds of memory for holding keys so you'd need to modify all of them ?<br>
<p>
The security community isn't even happy with keeping keys in RAM as it is. As a simple can of compressed air can prevent your RAM from being wiped already:<br>
<p>
<a href="http://en.wikipedia.org/wiki/Cold_boot_attack">http://en.wikipedia.org/wiki/Cold_boot_attack</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/612680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor612833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2014 20:09 UTC (Mon)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/612833/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  The security community isn't even happy with keeping keys in RAM as it is.</font><br>
<p>
And then the invent things like TPM chips and "secure element" chips. But then they make them so impossible to use that programmers have no choice except to store encryption keys in RAM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/612833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor610894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2014 13:24 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/610894/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Like flash based SSDs before NVRAM, the architectural structure is not very different to storage we've been using for 50 years.</font><br>
<p>
... except SSDs and flash memory generally speaking are all elaborated smoke and mirrors especially designed to maintain backward compatibility. Very fast smoke and mirrors in the case of SSDs but still. So, probably not a great example :-)<br>
<p>
<a href="http://arstechnica.com/information-technology/2012/06/inside-the-ssd-revolution-how-solid-state-disks-really-work/">http://arstechnica.com/information-technology/2012/06/ins...</a><br>
<p>
<a href="http://www.bunniestudios.com/blog/?p=3554">http://www.bunniestudios.com/blog/?p=3554</a>  (On Hacking MicroSD Cards)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor645014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2015 14:22 UTC (Tue)
                               by <b>Aissen</b> (subscriber, #59976)
                              [<a href="/Articles/645014/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is changing. PCIe and NVMe SSDs are already on the market without all the cruft of backward compatibility. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/645014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor610895"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2014 13:29 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/610895/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As for the question of "why do we need RAM if we have tens of TB of NVRAM" I'll just say this: most of the information the kernel keeps for running the machine is volatile. It's not designed to be persistent. If you just want a machine to have persistent memory, the OS needs to be designed from the ground up to be stateless and to *never corrupt itself*. When everything is persistent, rebooting does not fix problems...</font><br>
<p>
Well, you can always do less with more. Name a partition of your NVRAM as volatile and ignore its former content when you boot, job done?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610895/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor611029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2014 22:04 UTC (Sat)
                               by <b>pedrocr</b> (guest, #57415)
                              [<a href="/Articles/611029/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the OS needs to be designed from the ground up to be stateless and to *never corrupt itself*. When everything is persistent, rebooting does not fix problems...</font><br>
<p>
You'd just need to clearly mark the parts of the NVRAM that are persistent filesystem structures and the parts that are kernel structures. The filesystem parts are read just as today and the kernel structure parts ignored and created from scratch. That doesn't seem too hard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor610716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2014 12:59 UTC (Thu)
                               by <b>martin.langhoff</b> (subscriber, #61417)
                              [<a href="/Articles/610716/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The first use I can think of is speeding up writes to traditional rotational media. An outsize, kernel-controlled write back cache; or a "data-writeback" journal.<br>
<p>
Can these NVM devices be used for that workload easily today?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor610902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2014 14:32 UTC (Fri)
                               by <b>pkern</b> (subscriber, #32883)
                              [<a href="/Articles/610902/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
XIP was designed for readonly blobs of memory on mainframes shared by multiple VMs. It needed a persistable structure, so ext2 was picked. I'm not sure why you'd try to port it to ext4 instead. You do not need the journaling of ext4 and extents are probably also not all that useful if you are mapping in page sized hunks anyway (huge pages aside).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2014 17:20 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/610997/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, the ext2-XIP design was for that purpose, but the infrastructure that it put in looked suitable as a basis for supporting persistent memory with a modern filesystem like ext4/XFS.  It turned out that the -&gt;direct_access() block device API was close, needing minor improvements, but the -&gt;get_xip_mem() filesystem API was all wrong and needed to be replaced.  We ought not have support for two direct access APIs in Linux, so my patchset migrates ext2 from XIP to DAX as the appropriate pieces of DAX are added.<br>
<p>
One of the ext* maintainers/developers told me that having XIP support in ext2 and not in ext4 was one of the few remaining reasons not to remove ext2 from the Linux codebase, so we may see ext2-XIP deprecated in favour of ext4-DAX soon.  That wasn't particularly my intent, but if it happens to help others, then that's just gravy.<br>
<p>
Speaking of huge pages, I'm currently working on support for those.  I haven't finished debugging them yet, but I've definitely seen them inserted into the user's address space and removed again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor611113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2014 1:18 UTC (Mon)
                               by <b>mithro</b> (subscriber, #50469)
                              [<a href="/Articles/611113/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Anyone know where you can actually by a NVM device as a home consumer? It seems like a really cool thing to experiment with, even if its doesn't deliver on the 100TB of fast storage for less than DDR cost. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor611406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2014 14:28 UTC (Wed)
                               by <b>reubenhwk</b> (guest, #75803)
                              [<a href="/Articles/611406/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect this is going to be another vaporware.  Even if somebody does produce a storage device which is as fast as ram, somebody else will build on that technology by making it much faster and more volatile.<br>
<p>
Volatile storage has always been considerably faster, smaller in capacity and far more expensive and we've seen how a tiny bit of cache (compared to the size of RAM) can massively improve performance.  A tiny bit of RAM (compared to HDD storage space) can greatly improve the performance of disk access (using the page cache).  I see no reason why that will change now.  If we suddenly have 100 TB of VNM which cost maybe $100, the MOBO will undoubtedly have a slot for 8-16 TB of even faster volatile memory which is going to do exactly was RAM does today and will also cost about $100.  In other words, nothing will change, but everything will be faster and larger.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor611545"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2014 9:01 UTC (Thu)
                               by <b>dakas</b> (guest, #88146)
                              [<a href="/Articles/611545/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Volatile storage has always been considerably faster, smaller in capacity and far more expensive[...]</blockquote>
"Always" is such a strong word.  There were literally decades where core memory was persistent because, well, consisting of magnetic cores.
<p/>
HP at the current point of time appears to be betting a significant part of its assets on memristor technology.  It does not look feasible to make it "much faster and more volatile": they want to move the CPUs to that technology as well, so there will be no issue of "better fit/worse fit" as there is with static RAM vs dynamic RAM vs block devices.
<p/>
I'd like to see them pull this off and make computing more exciting again than the "more of the same, just more so" developments of the last 30+ years.
      
          <div class="CommentReplyButton">
            <form action="/Articles/611545/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2016 9:24 UTC (Fri)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/675302/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And as one of the links in article explains, core memory was not only slower than RAM, but the persistence was only 80% reliable, frequently a colder style boot was required.<br>
<p>
Fast memory has needed to be closer to the core, for example modern L1 cache, technologies which include RAM inside the CPU package (EDRAM/HBM2) are intended for high bandwidith whilst providing low latency.  A device on the end of some bus, that's plugged in, can NEVER compete with the short physical connections of on chip RAM, so there's very good reason to believe the miracle people want to believe, will prove to have engineering tradeoffs (for example the EROS persistent RAM store, was disk backed therefore with log write throughput is FAR lower than RAM and it's performance relied on cache and the hot checkpoint area of disk reducing seeks for "85%" of accesses).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor611601"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2014 15:02 UTC (Thu)
                               by <b>rrcsraghu</b> (guest, #87071)
                              [<a href="/Articles/611601/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"RAM-based filesystems are designed for RAM; it turns out that they are not all that well suited to the NVM case"<br>
<p>
In this context, I'd like to point out to some of the work folks at Lawrence Livermore National Laboratory, and us at The Ohio State University, have done in designing a highly-scalable in-memory file system designed to handle persistent memory devices.<br>
<p>
<a rel="nofollow" href="http://go.osu.edu/cruise-paper">http://go.osu.edu/cruise-paper</a><br>
<p>
Some of you might be familiar with the IBM BlueGene/Q supercomputer's persistent memory capability. We used that as our playground when prototyping CRUISE. While the file system was designed for checkpoint-restart workloads, the design allows extension for typical file system workloads as well.<br>
<p>
Our prototype is up on github for those who want to look around:<br>
<a rel="nofollow" href="https://github.com/hpc/cruise">https://github.com/hpc/cruise</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611601/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor611679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2014 3:37 UTC (Fri)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/611679/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thinking a bit about NVM, it seems like NVM that is directly addressable by the entire kernel vastly increases the probability that write through a wild pointer by $RANDOM_DODGY_DRIVER will corrupt data on your "disk".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor611902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting filesystems in persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2014 21:40 UTC (Sun)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/611902/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Its possible. But its also possible for the kernel to write to a random position on your SATA drive. Granted, this isn't as likely to happen by accident. Although it could drop random bytes into file cache which would result in corrupted data...<br>
<p>
Also, I was under the impression that the kernel switches memory maps in kernel mode, locking itself into a 1 or 2 gigabyte range. Writes outside that range that don't go through copy_to_user result in a BUG. Although maybe that was only done in 32-bit 4G/4G mode...Hmm.<br>
<p>
If it doesn't do that currently, it certainly could do it in the future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
