        <!DOCTYPE html>
        <html lang="en">
        <head><title>Shrinking the kernel with link-time optimization [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/744507/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/744717/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/744507/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Shrinking the kernel with link-time optimization</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>January 18, 2018</p>
           <p>This article was contributed by Nicolas Pitre</p>
           </div>
<p>This is the second article of a series discussing various methods of
reducing the size of the Linux kernel to make it suitable for small
environments.

The <a href="/Articles/741494/">first article</a>
provided a short rationale for this topic, and covered the link-time
garbage collection, also called the <tt>ld --gc-sections</tt> method. We've seen
that, though it is pretty straightforward, link-time garbage collection has
issues of its own when applied to the kernel, making achieving optimal
results more 
difficult than it is worth.  In this article we'll have a look at what the
compiler itself can do using link-time optimization.</p>

<p>Please note that most examples presented here were produced using the
ARM architecture, however the principles themselves are architecture-independent.</p>

<h4>Dead-code elimination</h4>

<p>Kernel developers often rely on a compiler feature called
"dead-code elimination". This is an important optimization that results
in unreachable code simply being dropped from the final binary. Unlike
the linker garbage-collection feature, dead-code elimination can be
performed by the compiler both within and across functions inside a
compilation unit or file.</p>

<p>Let's reuse the example code we used previously as <tt>test.c</tt> to
illustrate it:</p>

<p>
<pre>
    int foo(void)  { return 1; }

    int bar(void)  { return foo() + 2; }

    int main(void) { return foo() + 4; }
</pre>

<p>Again, the compiler generates the following (simplified) assembly output
for that code:</p>

<p>
<pre>
        .text

        .type   foo, %function
    foo:
        mov     r0, #1
        bx      lr

        .type   bar, %function
    bar:
        push    {r3, lr}
        bl      foo
        adds    r0, r0, #2
        pop     {r3, pc}

        .type   main, %function
    main:
        push    {r3, lr}
        bl      foo
        adds    r0, r0, #4
        pop     {r3, pc}
</pre>

<p>Despite <tt>bar()</tt> not being called, it is still part of the
compiled output because there is no way for the compiler to actually know
whether code in some other file might call it. But the author of that code
often knows
that, and can tell the compiler about it with the <tt>static</tt>
qualifier as follows:</p>

<p>
<pre>
    static int foo(void) { return 1; }

    static int bar(void) { return foo() + 2; }

    int main(void)       { return foo() + 4; }
</pre>

<p>By marking <tt>foo()</tt> and <tt>bar()</tt> static, the developer
renders them no
longer reachable from other source files. The compiler is then free to
perform more optimizations on the compiled code. Of course the entry point
(<tt>main()</tt>) must remain externally accessible and therefore
cannot be static.</p>

<p>The above compiles to this:</p>
<p>
<pre>
        .text

        .type   main, %function
    main:
        mov     r0, #5
        bx      lr
</pre>

<p>Boom! Not only did the compiler get rid of the unused <tt>bar()</tt> with
dead-code elimination, but it also merged <tt>foo()</tt> directly into
<tt>main()</tt> due to automatic inlining.  In addition, it performed the
arithmetic operation up front since all of the operands are constants, so that all
we have left in the compiled code is the load of the resulting value and
the return instruction. Instant code-size reduction that already works
better than link-time garbage collection!</p>

<p>As mentioned, this dead-code elimination is heavily relied upon in the
Linux kernel source 
tree, so that large portions of the code can be optimized away at compile time.
For example, let's consider the following from
<a
href="http://elixir.free-electrons.com/linux/v4.14.13/source/include/linux/mmzone.h#L864"><tt>include/linux/mmzone.h</tt></a>:</p>

<p>
<pre>
    static inline int is_highmem_idx(enum zone_type idx)
    {
    #ifdef CONFIG_HIGHMEM
            return (idx == ZONE_HIGHMEM ||
                    (idx == ZONE_MOVABLE &amp;&amp; zone_movable_is_highmem()));
    #else
            return 0;
    #endif
   }
</pre>

<p>When <tt>CONFIG_HIGHMEM</tt> is not defined, 
<tt>is_highmem_idx()</tt> (and <tt>PageHighMem()</tt> derived from it)
return zero unconditionally. Any code within functions that follows the
"<tt>if&nbsp;(PageHighMem(page))</tt>" pattern will be automatically optimized away
as dead code.</p>

<p>But this works only because <tt>is_highmem_idx()</tt> is marked
<tt>static</tt>; to avoid duplication of that function everywhere
<tt>mmzone.h</tt> is included  it has to be marked <tt>inline</tt> too. Those
optimizations only work within a single compilation unit, missing out on
opportunistic dead code elimination across different compilation units. So,
what can we do short of concatenating all source files into a single one
and making everything static to achieve the full benefit?</p>

<p>As mentioned previously, the core-kernel APIs are split into different C
files for ease of maintenance.  Those files may provide functions that are
not called when some unwanted feature is configured out. It could be argued
that the unused core functions should be <tt>#ifdef</tt>'d in or out along
with their 
call sites, but this gets hairy when multiple features sharing the same core API
may be configured in and out independently. To complicate things further,
those core functions might be called within
"<tt>if&nbsp;(PageHighMem(page))</tt>" blocks showing no directly visible
relationship 
with a configuration option.
So there are limits to how much unused code can be removed by the compiler;
doing a more thorough job requires a tool like link-time optimization.

<h4>Link-time optimization (LTO)</h4>

<p>What is it? LTO is a compilation mode that instructs the compiler to
parse the code into an abstract internal representation as usual, and
store that representation directly into the resulting object file <em>without</em> any
optimization, rather than optimizing and assembling it into final machine
instructions. Then, at link time when all the different object files are
gathered together, the compiler intercepts the link process to reload that
internal representation from all of the object files at once; only then
will it
perform its optimization passes — on the whole program — before the actual
link. So it is basically just like if it concatenated all source files into
a single one and made everything static. Great, that is exactly what we wished
for.</p>

<p>Let's see how this works in practice with our little example program by
having each function in its own file:</p>
<p>
<pre>
   $ gcc -O2 -flto -c foo.c
   $ gcc -O2 -flto -c bar.c
   $ gcc -O2 -flto -c main.c
   $ gcc -O2 -flto -o test foo.o bar.o main.o

   $ nm test | grep "foo\|bar\|main"
   000102c0 T main
   $ objdump -d test
   [...]
   000102c0 &lt;main&gt;:
      102c0:       e3a00005        mov     r0, #5
      102c4:       e12fff1e        bx      lr
</pre>

<p>As expected, the result is the same as our earlier test despite having
separate source files containing non-static functions.</p>

<h4>LTO and the kernel</h4>

<p>LWN <a href="/Articles/512548/">first covered LTO for the
kernel</a> more than five years ago. Since then, things have improved a lot. LTO
still isn't supported in the mainline, but Andi Kleen's <a
href="https://github.com/andikleen/linux-misc/tree/lto-415-2">kernel
LTO patchset</a> has become much simpler as basic code correctness issues,
which LTO is pickier about, have been merged upstream, and many LTO bugs in
GCC have been fixed.</p>

<p>One of the biggest LTO showstoppers for the kernel had to do with the
fact that a special version of <a
href="https://www.gnu.org/software/binutils/">binutils</a> was
required. The kernel used to
rely solely on partial linking (<tt>ld&nbsp;-r</tt>) when recursively
gathering subdirectory build results, however <tt>ld&nbsp;-r</tt> doesn't
support objects with LTO data unless binutils is patched to do so. And it
was <a
href="http://sourceware.org/ml/binutils/2011-04/msg00433.html">rather
unlikely</a> that the necessary patch would ever be merged in the upstream
binutils tree. Nowadays the kernel build system can use <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a5967db9af51a84f">thin
archives</a> instead of <tt>ld&nbsp;-r</tt>, making LTO of the kernel possible
with the upstream tools that most distributions ship.</p>

<p>LTO also has a big advantage over link-time garbage collection given
that it does not require separate linker sections for each exception
table entry and does not suffer from the "backward reference" and
"missing forward reference" problems described in the previous article.
When the compiler optimizes code away, those exception table entries
instantiated by that code are simply dropped automatically with it.</p>

<h4>Numbers please!</h4>

<p>Let's not forget that our end goal is to fit Linux into tiny systems. So it is
about time we looked at actual kernel-size numbers. Let's pick the <a
href="https://en.wikipedia.org/wiki/STM32">STM32</a> target which
represents the kind of tiny systems we're aiming for. The advantage here is
that mainline Linux already runs on most STM32 microcontrollers, albeit with
external RAM. The baseline kernel version is v4.15-rc1 plus the LTO
patches.</p>

<p>First, with LTO disabled:</p>

<p>
<pre>
    $ make stm32_defconfig
    $ make vmlinux
    $ size vmlinux
       text    data     bss     dec     hex filename
    1704024  144732  117660 1966416  1e0150 vmlinux
</pre>

<p>And with LTO enabled:</p>
<p>
<pre>
    $ ./scripts/config --enable CONFIG_LTO_MENU
    $ make vmlinux
    $ size vmlinux
       text    data     bss     dec     hex filename
    1281644  142492  112985 1537121  177461 vmlinux
</pre>

<p>This is a 22% size reduction right there. For completeness, let's see
how link-time garbage collection as described in the previous article
fares:</p>
<p>
<pre>
    $ [hacks for CONFIG_LD_DEAD_CODE_DATA_ELIMINATION]
    $ make vmlinux
    $ size vmlinux
       text    data     bss     dec     hex filename
    1304516  141672  113108 1559296  17cb00 vmlinux
</pre>

<p>Here we get a 21% size reduction. However, this comes with a big
disclaimer due to the following hacks:</p>
<ul>
<li>
<p>
No <tt>KEEP()</tt> statements were added to the ARM linker file as required.
Worse: the <tt>ASSERT()</tt> statements about missing processor and
architecture tables have been disabled for the sake of successful
compilation. This means important pieces of code and data are missing
from this kernel.
</p>
</li>
<li>
<p>
The ARM unwinding facility needed for function backtraces has been
forcefully disabled as it also contained a reference to every
function, making garbage collection ineffective. So, unlike the
LTO-built kernel, this one would lack an important debugging facility.
</p>
</li>
</ul>

<p>Of course those hacks produce a non-functional kernel. Still, the size
reduction is slightly lower than what LTO produces, and it would be even
less if proper link-time garbage collection support was implemented.
And optimal link-time garbage collection as described in the previous
article is way more invasive than LTO. We therefore have a clear winner
here.</p>

<p>One could wonder if size reduction could improve further by combining
both link-time optimization and link-time garbage collection. The answer
is no since, once LTO has removed every piece of dead code, there is simply
nothing left to garbage-collect.</p>

<h4>More numbers</h4>

<p>So LTO seems to be the best thing since sliced bread, right? Well, it
has drawbacks of its own. The most significant is build time. Let's
repeat the above kernel compilation sequence to see what we get.</p>

<p>First with LTO disabled:</p>
<p>
<pre>
    $ make clean
    $ make stm32_defconfig
    $ time make -j8 vmlinux

    real    0m36.645s
    user    3m59.252s
    sys     0m21.026s
</pre>

<p>And with LTO enabled:</p>
<p>
<pre>
    $ make clean
    $ ./scripts/config --enable CONFIG_LTO_MENU
    $ time make -j8 vmlinux

    real    1m24.774s
    user    8m4.143s
    sys     0m31.902s
</pre>

<p>LTO requires 1.9x more CPU time and 2.3x more wall-clock time to build
the kernel. Having code optimizations performed at the very end creates
a bigger serialization point, unlike traditional builds where individual
source files are
compiled and optimized concurrently without LTO.</p>

<p>But the most annoying case, at least for a kernel developer, is partial
rebuild time after some source-code modifications. Without LTO we get:</p>

<p>
<pre>
    $ touch init/main.c
    $ time make -j8 vmlinux

    real    0m3.686s
    user    0m5.803s
    sys     0m1.819s
</pre>

<p>And with LTO enabled this becomes:</p>
<p>
<pre>
    $ touch init/main.c
    $ time make -j8 vmlinux

    real    0m58.283s
    user    5m6.089s
    sys     0m12.732s
</pre>

<p>A partial build with LTO is about 15x longer than the non-LTO case, and
not very far from the full build time. So LTO is clearly not something
suitable during frequent debug/rebuild/test cycles.</p>

<p>And for completeness:</p>
<p>
<pre>
    $ make clean
    $ [hacks for CONFIG_LD_DEAD_CODE_DATA_ELIMINATION]
    $ time make -j8 vmlinux

    real    0m37.572s
    user    3m58.826s
    sys     0m21.616s
</pre>

<p>More or less the same result as our initial build. Clearly link-time
garbage collection is basically free in terms of build time which is its
biggest (perhaps only) advantage.</p>
<dl>
<dt>
Test-build environment details
</dt>
<dd>
<p>
GCC version 6.3.1 20170404 (Linaro GCC 6.3-2017.05)<br>
Intel&#174; Core&#8482; i7-4770R CPU @ 3.20GHz<br>
Samsung SSD 850 EVO 500GB
</p>
</dd>
</dl>
<h4>Conclusion</h4>

<p>We have two approaches for automatic kernel-size reduction at our
disposal, each with a different set of compromises. However the
advantage is clearly on the LTO side when considering maintenance costs
and intrusiveness. And build time becomes tolerable when building
very small kernels anyway.

But, did we manage to get a "very small kernel"? Kernels that cross
the one-megabyte range cannot realistically be qualified as "very small" or
even "tiny" yet. Clearly automatic size reduction alone won't be sufficient,
so more assertive approaches will be required to achieve our goal. That
will be the subject of the next article.</p>
<p>
Meanwhile, anybody wanting to play with LTO with their own kernel in the
short term should
start with <a
href="https://github.com/andikleen/linux-misc/blob/lto-415-2/Documentation/lto-build">these
instructions</a> found in Kleen's patch set.
<p>
The next article in this series is <a href="/Articles/746780/">Shrinking
the kernel with an axe</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Build_system">Build system</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Optimization_tools">Optimization tools</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Pitre_Nicolas">Pitre, Nicolas</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/744507/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor744744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2018 21:18 UTC (Thu)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/744744/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A partial build with LTO is about 15x longer than the non-LTO case, and not very far from the full build time. So LTO is clearly not something suitable during frequent debug/rebuild/test cycles.</font><br>
<p>
How much less bad does this get when parallelizing LTO like new-ish GCCs can? Or is this already with parallelization enabled?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744747"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2018 22:18 UTC (Thu)
                               by <b>npitre</b> (subscriber, #5680)
                              [<a href="/Articles/744747/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is already enabled with -flto=jobserver i.e. 8 threads in this case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744747/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2018 22:25 UTC (Thu)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/744748/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  This is already enabled with -flto=jobserver i.e. 8 threads in this case.</font><br>
<p>
Too bad. Would be interesting, but I definitely see why you wouldn't necessarily want to measure given it's yet another patchset, how that compares to LLVM's thinlto implementation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor744745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2018 21:25 UTC (Thu)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/744745/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about performance? That should be another big advantage of LTO. Does LTO make the system significantly faster?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2018 2:38 UTC (Fri)
                               by <b>gutschke</b> (subscriber, #27910)
                              [<a href="/Articles/744758/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Linux kernel already does all sorts of tricks to encourage the compiler to inline code where it makes sense and to compute static expressions at compile time. So, I would suspect the main performance benefit is going to be from the smaller binary size. That's nothing to sneer at. More memory that is available for other uses is always a benefit. And more compact code is going to help with better utilization of the instruction cache.<br>
<p>
In other words, there almost certainly will be a performance improvement. But my gut feeling is that the numbers are going to be so small, most users would not be able to notice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor744763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2018 12:11 UTC (Fri)
                               by <b>AnimeLife</b> (guest, #116014)
                              [<a href="/Articles/744763/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This will be good for IOT / embedded devices, but for desktops, the kernel is already tiny compared to size of root partition. It is may not be useful for desktop users who build it from scratch or debug it, but it can be used in distros that distribute prebuilt kernels.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2018 12:22 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/744764/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's also good for cloud companies.  5% smaller system =&gt; 5% more tenants per rack.<br>
There are of course other optimisations for squeezing more systems into the same amount of hardware, but tinification is one tool.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor744830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2018 6:55 UTC (Sat)
                               by <b>ndesaulniers</b> (subscriber, #110768)
                              [<a href="/Articles/744830/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sami Tolvanen @ Google was just trying to upstream a separate working patch set for LTO as well.<br>
<a href="https://lkml.org/lkml/2017/11/15/772">https://lkml.org/lkml/2017/11/15/772</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor744867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAM footprint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2018 14:30 UTC (Sun)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/744867/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It may be worth mentioning how much RAM the build occupies while doing LTO on the whole freakin' kernel.  It hasn't been long, in absolute time, that mere mortals have had access to enough RAM to complete the job. <br>
<p>
(Just recalling how happy three of us programming on an LSI-11 were when we got a 20M "Winchester" disk. We had 128K RAM, plus (significantly) 4K in each terminal.)<br>
<p>
It probably is also worth mentioning that, in a terrifyingly short time, every ordinary machine will have multiple TB of non-volatile RAM, and no disk or SSD, and all performance-tuned code will be obsolete.  Any network packet propagation latency will suddenly become an eternity, and the only remaining performance bottleneck masking inefficiencies in query processing code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAM footprint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2018 14:32 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/745093/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's actually not that much. I managed to build chromium with LTO on my puny personal machine. Whole freakin' chromium. The kernel is tiny in comparison. And gcc's memory use improved immensely since the time LTO was introduced.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745446"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAM footprint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2018 22:21 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/745446/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
I managed to build chromium with LTO on my puny personal machine
</blockquote>
<p>
How puny?  (Real memory, swap space)
<p>
Probably bigger than the server I usually use to build kernels.

      
          <div class="CommentReplyButton">
            <form action="/Articles/745446/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAM footprint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2018 17:11 UTC (Mon)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/745670/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
16 GB RAM might not be "puny", I agree, but that was enough to build chromium without touching swap. Swapping would be murdering performance (and probably hardware) so I made sure to avoid it :) But nothing drastic, I could still comfortably work on it on other stuff.<br>
<p>
Building gcc itself, on the other hand...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor744955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2018 15:01 UTC (Mon)
                               by <b>ehiggs</b> (subscriber, #90713)
                              [<a href="/Articles/744955/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As there is sometimes talk about using C++ in the kernel, maybe this is a good place to ask whether dead code elimination works in C++. <br>
<p>
If I understand correctly, dead code elimination is hindered by C++. For example, any virtual function will automatically be referred to in the vtable and it is not possible to strip any virtual methods from the final executable. Or any virtual methods in derived types regardless of use if any part of the type hierarchy is referred to at all. I suppose it might be possible for a linker to rewrite vtables to drop the functions (or maybe leave a dangling pointer in the vtable...) but as I understand it, this isn't done unless the compiler has all the information - e.g. when writing basic examples where everything is in a single module. <br>
<p>
So when I run basic examples using -O3 the aggressive inlining seems to handle it fine (e.g. <a href="https://godbolt.org/g/Rn8GH1">https://godbolt.org/g/Rn8GH1</a>). It's not clear if this is working ok in the small cases but wouldn't be expected to work in the larger case - or if my mental model is just incorrect.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745064"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2018 1:43 UTC (Tue)
                               by <b>inphi</b> (guest, #120554)
                              [<a href="/Articles/745064/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This should automatically happen during LTO. Since the entire class hierarchy will be known at that time, the compiler will be able to de-virtualize whenever possible, thus trivializing dead code elimination. There might be a few cases where the optimizer may decide/unable to infer whether de-virtualization is worth it. But with judicious usage of class sealing (i.e. final) the optimizer shouldn't be inhibited.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745064/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor746239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2018 4:27 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/746239/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
vtables are used in C as well, except you have to write them manually instead of having the compiler doing it for you (e. g. struct file_operations). So C++ doesn't really add any new problems here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/746239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor745095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2018 15:14 UTC (Tue)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/745095/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Now if GCC developers would actually care about LTO and not break it every other version… mksh’s regression testsuite picks up miscompilations fairly well, and since GCC 6 it’s constantly broken *again*, and I don’t even bother reporting this any more because they don’t care, and it’s so bad I’m disabling LTO support in the mksh build script because distros blindly use it then complain, instead of fixing their compilers (what fix?).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2018 17:03 UTC (Tue)
                               by <b>peter-b</b> (subscriber, #66996)
                              [<a href="/Articles/745103/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe you should ask for your money back?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2018 16:15 UTC (Wed)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/745204/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Congratulations on entirely missing the point.<br>
<p>
It is a matter of respect. When one person puts in substantial efforts to improve the kernel in a way that is important to them and to many other users, a trivial effort not to massively break those improvements would hint that you have something better than contempt for the people who do the work.<br>
<p>
To complain that LTO doesn't work would be to demand people work for you for free.  Making LTO work is contributing. Improvements of any kind typically take far more effort than it is worth to the individual, who is doing the rest of us that favor.  Minimal effort not to break others' work is necessary to a healthy project.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2018 12:58 UTC (Thu)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/745292/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is great. One replyer misses the point completely, the other assumes I’m not contributing enough and asks me to fix it myself.<br>
<p>
Look up my contributions, if you so desire… if you find them all, I know I personally *don’t* even know all places I’ve had my fingers in over the last decades.<br>
<p>
It’s just, compilers isn’t what I do well. I’ve patched bootloaders, I’ve got fixes in all Linux libcs except musl (dalias does a great enough job for me to not find any bugs in musl so far), and I’ve been doing tons of other work, and I’m even now expanding to other stuff.<br>
<p>
There’s just not enough hours in a day, considering I have a regular, boring $dayjob. Do you wish to sponsor me for a year so I can take a sabbatical and work only on OSS?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2018 22:20 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/745448/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>
<b>ncm</b> didn't say you don't contribute enough.  He said at most that it would be preferable for you to fix GCC (repeatedly, apparently) than to complain that it keeps breaking. (And that's not saying you should fix GCC).
<p>
And even that is based on some reading between the lines about the moral value of demanding versus contributing, and the idea that complaining about something is demanding that someone fix it.  I don't view complaining that way; for example, I complain about the weather all the time without meaning to criticize anyone or demand that someone fix it.  I complain about the presence of ads on Youtube the same way.

      
          <div class="CommentReplyButton">
            <form action="/Articles/745448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2018 22:46 UTC (Fri)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/745449/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem isn’t even about fixing vs. not fixing; the problem is that<br>
GCC developers seem to be disinterested in LTO bugs, and for its antecessor<br>
(-fwhole-program --combine) they outright said it won’t get fixed.<br>
<p>
I actually find the idea of using LTO to eliminate dead code, in the<br>
Linux kernel or elsewhere, great — I just wanted to point out that GCC<br>
might, with its current bugs, history of bugs, and history of attitude<br>
towards said bugs¹, be a tad too unreliable to do so without excessive<br>
tests that point out miscompiled builds.<br>
<p>
① I read “low-hanging fruits” in an LWN article today. One of these,<br>
  for the GCC/LTO problem, would be to make building mksh part of the<br>
  usual pre-release tests; mksh has a history of spotting compiler,<br>
  toolchain, libc, etc. bugs via its testsuite.<br>
<p>
Now, with both the footnote #1 and the first paragraph, let’s get to<br>
something: isolating the issue is *hard*. The mksh testsuite is a<br>
bunch of shell scripts together with flags and expected output, with<br>
a Perl driver, ran through the shell compiled with the to-be-tested<br>
compiler/toolchain/libc. That’s a few levels of indirection. The latest<br>
LTO bug occurs in only one testcase: arith-ternary-prec-1, which is:<br>
<p>
$ mksh -c 'typeset -i x=2; y=$((1 ? 20 : x+=2))'<br>
mksh: 1 ? 20 : x+=2: += requires lvalue<br>
<p>
Basically, ?: binds more than +=, so this is '(1 ? 20 : x) += 2',<br>
and a miscompiled shell silently accepts this. This is *very* hard<br>
to isolate.<br>
<p>
GCC developers prefer isolated small test cases. Now, with LTO,<br>
isolating gets even more complicated. I can accept that not having<br>
a small isolated test case is not desirable.<br>
<p>
On the other hand, a change in testsuite output between two different<br>
versions of the same compiler, ceteris paribus (i.e. you try the same<br>
version of the testsuite, shell, toolchain, libc, …), *does* indicate<br>
a problem (not necessarily in the compiler, but it’s a prime suspect),<br>
and in the time of “git bisect” it’s at least often possible, for someone<br>
with enough beefy hardware to actually build GCC that often, to figure<br>
out which compiler change introduced the breakage. (Then, it’s still a<br>
matter of deciding whether the bug is actually in the compiler or else‐<br>
where, but the GCC developers at least know their compiler, and each<br>
other on the development team.)<br>
<p>
Oh, and: the Linux kernel does not have such a testsuite. Several GNU<br>
distributions’ mksh package maintainers have come to me, independently,<br>
with a testsuite failure report about the above test, and the advice<br>
found after the first analysis (LTO is at fault, GCC miscompiled mksh)<br>
made them compile mksh without LTO, preventing their users from getting<br>
a faulty binary that might misbehave in other situations as well. Now,<br>
the Linux kernel, not so much.<br>
<p>
Food for thought?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor746857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2018 10:49 UTC (Thu)
                               by <b>dharding</b> (subscriber, #6509)
                              [<a href="/Articles/746857/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Idle curiosity: I'm wondering (though I'm not expecting anyone in this thread to have a ready answer) how many of the problems in LTO builds are specific to LTO, and how many are generic optimization bugs exposed because LTO provides more opportunity for optimization.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/746857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor746929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2018 20:03 UTC (Thu)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/746929/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That’s an extremely interesting point.<br>
<p>
And, yes, sorry, I don’t have even the beginning of an answer for you,<br>
but someone with enough horsepower machine could certainly bisect this<br>
between GCC 5 and 6 I think…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/746929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor745628"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about unused struct members?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2018 14:32 UTC (Mon)
                               by <b>jezz</b> (subscriber, #59547)
                              [<a href="/Articles/745628/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder how many function are only referenced by structures and finally nobody reference these members. As far as I understand, LTO is not able to detect/optimize them.<br>
<p>
I wrote a script few years ago to detect unused struct members. I extracted information from debug symbols. Unfortunately, this script seems lost. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/745628/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor746369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about unused struct members?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2018 18:51 UTC (Fri)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/746369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The LibreOffice project has a clang compiler plugin for that. It's the "unusedfields" plugin at <a href="https://cgit.freedesktop.org/libreoffice/core/tree/compilerplugins/clang">https://cgit.freedesktop.org/libreoffice/core/tree/compil...</a> (there are many other useful compiler plugins there).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/746369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor780709"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the kernel with link-time optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2019 20:05 UTC (Mon)
                               by <b>praveenv98</b> (guest, #116175)
                              [<a href="/Articles/780709/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi Great Article! <br>
<p>
In this passage : <br>
<p>
"When CONFIG_HIGHMEM is not defined, is_highmem_idx() (and PageHighMem() derived from it) return zero unconditionally. Any code within functions that follows the "if (PageHighMem(page))" pattern will be automatically optimized away as dead code.<br>
<p>
But this works only because is_highmem_idx() is marked static; ". <br>
<p>
Why this works only for static functions ? Static keyword implies only about the internal linkage right? <br>
<p>
Thanks <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/780709/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
