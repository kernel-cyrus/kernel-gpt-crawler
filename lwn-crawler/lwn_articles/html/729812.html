        <!DOCTYPE html>
        <html lang="en">
        <head><title>The NOVA filesystem [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/729812/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/729755/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/729812/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The NOVA filesystem</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 4, 2017</br>
           </div>
Nonvolatile memory offers the promise of fast, byte-addressable storage
that persists over power cycles.  Taking advantage of that promise
requires the imposition of some sort of directory structure so that the
persistent data can be found.  There are a few approaches to the
implementation of such structures, but the usual answer is to employ a
filesystem, since managing access to persistent data is what filesystems
were created to do.  But traditional filesystems are not a perfect match to
nonvolatile memory, so there is a natural interest in new filesystems that
were designed for this media from the beginning.  The recently posted <a
href="/Articles/729770/">NOVA filesystem</a> is a new entry in this race.
<p>
The filesystems that are currently in use were designed with a specific set
of assumptions in mind.  Storage is slow, so it is worth expending a
considerable amount of CPU power and memory to minimize accesses to the
underlying device.  Rotational storage imposes a huge performance penalty
on non-sequential operations, so there is great value in laying out data
consecutively.  Sector I/O is atomic; either an entire sector will be
written, or it will be unchanged.  All of these assumptions (and more) are
wired deeply into most filesystems, but they are all incorrect for
nonvolatile memory devices.  As a result, while filesystems like XFS or
ext4 can be sped up considerably on such devices, the chances are good that
a filesystem designed from the beginning with nonvolatile memory in mind
will perform better and be more resistant to data corruption.
<p>
NOVA is intended to be such a filesystem.  It is not just unsuited for
regular block devices, it cannot use them at all, since it does not use the
kernel's block layer.  Instead, it works directly with storage
mapped into the kernel's address space.  A filesystem implementation gives
up a lot if it avoids the block layer: request coalescing, queue
management, prioritization of requests, and more.  On the other hand, it
saves the overhead imposed by the block layer and, when it comes to
nonvolatile memory performance, cutting down on CPU overhead is a key part
of performing well.
<p>
<h4>NOVA filesystem structure</h4>
<p>
Like most filesystems, NOVA starts with a superblock — the top-level data
structure that describes the filesystem and provides the locations of the
other data structures.  One of those is the inode table, an inode being the
internal representation of a file (or directory) within the filesystem.
The NOVA inode table is set up as a set of per-CPU arrays, allowing any CPU
to allocate new inodes without having to take cross-processor locks.
<p>
Free space is also split across a system's CPUs; it is managed in a <a
href="/Articles/184495/">red-black tree</a> on each processor to facilitate
coalescing of free regions.  Unlike the inode tables, the free lists are
maintained in normal RAM, not nonvolatile memory.  They are written back
when the filesystem is unmounted; if the filesystem is not unmounted
properly, the free list will be rebuilt with a scan of the filesystem as a whole.
<p>
Perhaps the most interesting aspect of NOVA is how the inodes are stored.
On a filesystem like ext4, the on-disk inode is <a
href="http://elixir.free-electrons.com/linux/v4.12/source/fs/ext4/ext4.h#L716">a
well-defined structure</a> 
containing much of a file's metadata.  To make things fast, NOVA took a
different approach based on log-structured filesystems.  The result is that
an inode in the table is just a pair of pointers to a data structure that
looks something like this:
<p>
<blockquote>
<img src="https://static.lwn.net/images/2017/nova-inode.png" class="photo" alt="[inode log]">
</blockquote>
<p>
Each active inode consists of a log describing the changes that have been
made to the file; all that is found in the inode structure itself is a pair
of pointers indicating the first and last valid log entries.  Those entries
are stored (in nonvolatile memory) in chunks of at least 4KB, organized as
a linked list.  Each log entry will indicate an event like:
<p>
<ul>
<li> The attributes of the file have been changed — a change in the
     permission bits, for example.
<p>
<li> An entry has been added to a directory (for directory inodes,
     obviously).
<p>
<li> A link to the file was added.
<p>
<li> Data has been written to the file.
</ul>
<p>
The case of writing data is worth looking at a bit more closely.  If a
process writes to an empty file, there will be no data pages already
allocated.  The NOVA implementation will allocate the needed memory from
the per-CPU free list and copy the data into that space.  It will then
append an entry to the inode log indicating the new length of the file and
pointing to the location in the array where the data was written.  Finally,
an atomic update of the inode's tail pointer will complete the operation
and make it visible globally.
<p>
If, instead, a write operation overwrites existing data, things are done a
little differently.  NOVA is a copy-on-write (COW) filesystem, so the first
step is, once again, to allocate new (nonvolatile) memory for the new
data.  Data is copied from the old pages into the new if necessary, then
the new data is added.  A new entry is added to the log pointing to the new
pages, the tail pointer is updated, and the old log entry for those pages
is invalidated.  At that point, the operation is complete and the old data
pages can be freed for reuse.  
<p>
Thus, the "on-disk" inode in NOVA isn't really a straightforward
description of the file it represents.  It is perhaps better thought of as
a set of instructions that, when followed in order (and skipping the
invalidated ones) will yield a complete description of the file and its
layout in memory.  This structure has the advantage of being quite fast to
update when the file changes, with minimal locking required.  It will
obviously be a bit slower when it comes to accessing an existing file.
NOVA addresses that by assembling a compact description of the file in RAM
when the file is opened.

Even that act of assembly should not be all that slow.  Remember that the
whole linked-list structure is directly addressable by the CPU.  Storing
this type of structure on a rotating disk, or even on a solid-state disk
accessed as a normal block device, would be prohibitively slow, but direct
addressability changes things.
<p>
There is another interesting feature enabled by this log structure.  Each
entry in the log contains an "epoch number" that is set when the entry is
created.  That makes it possible to create snapshots by incrementing the
global epoch number, and associating the previous number with a pointer to
the snapshot.  When the snapshot is mounted, any log entries with an epoch
number greater than the snapshot's number can be simply ignored to give a
view of the file as it existed when the snapshot was taken.  There are some
details to manage, of course: entries associated with snapshots cannot be
invalidated, and those entries have to be passed over when the snapshot is
not in use.  But it is still an elegant solution to the problem.
<p>
<h4>DAX and beyond</h4>
<p>
Readers may be wondering about how NOVA interacts with the kernel's DAX
interface, which exists to allow applications to directly map files in
nonvolatile memory into their address space, bypassing the kernel entirely
for future accesses.  It can be hard to make direct mapping work well with
a COW-based write mechanism.  In <a
href="http://cseweb.ucsd.edu/~swanson/papers/FAST2016NOVA.pdf">this 2016
paper describing NOVA [PDF]</a>, the authors say they don't even try.
Rather than support DAX, NOVA supports an alternative mechanism called
"atomic mmap" which copies data into "replica pages" and maps those
instead.  In a sense, atomic mmap reimplements a part of the page cache.
<p>
One can imagine that this approach was seen as being suboptimal; direct
access to nonvolatile memory is one of that technology's most compelling
features.  Happily, the posted patch set does claim to support DAX.  As far
as your editor can tell from the documentation and the code, NOVA disables
COW for the portions of a file that have been mapped into a process's
address space, so changes are made in place.  One significant shortcoming
is that pages that have been mapped into a process's address space cannot
be written to with <tt>write()</tt>.  There is some relatively
complex logic (described in <a
href="http://cseweb.ucsd.edu/~swanson/papers/TechReport2017HardenedNOVA.pdf">this
other paper [PDF]</a>) to ensure that the filesystem does the right thing
when taking a snapshot of a file that is currently directly mapped into
some process's address space.
<p>
There are a number of self-protection measures built into NOVA, including
checksumming for data and metadata.  One of the more interesting mechanisms
seems likely to prove controversial, though.  One possible hazard of having
your entire storage array mapped into the kernel's address space is that
writing to a stray pointer can directly corrupt persistent data.  That
would not be a concern in a bug-free kernel but, well, that is not
the world we live in.  In an attempt to prevent inadvertent
overwriting of data, NOVA can keep the entire array mapped read-only.  When
a change must be made, the processor's write-protect bit is temporarily
cleared, allowing the kernel to bypass the memory permissions.  Disabling
write protection has been <a href="/Articles/724319/">deemed too
dangerous</a> in the past; it seems unlikely that the idea will get a
better reception now.  Protection against stray writes is a valuable
feature, though, so hopefully another way to implement it can be found.
<p>
There are a few other things that will need to be fixed before NOVA can be
seriously considered for merging upstream.  For example, it only works on
the x86-64 architecture and, due to the per-CPU inode table structure, it
is impossible to move a NOVA filesystem from one system to another if the
two machines do not have the same number of CPUs.  NOVA doesn't support
access control lists or disk quotas.  There is no filesystem checker tool.
And so on.  The developers are aware of these issues and expect to deal with them.
<p>
The fact that the developers do want to take care of those details and get
the filesystem upstream is generally encouraging, but it is especially so
given that NOVA comes from the academic world (from the University of
California at San Diego in particular).  Academic work has a discouraging
tendency to stop when the papers are published and the grant money runs
out, so the free-software world in general gets far less code from
universities than one might expect.  With luck, NOVA will be one
development that escapes academia and becomes useful to the wider world.

<p>
There are, of course, many other aspects of this filesystem that cannot be
covered in such a short article.  See the two papers referenced above and
<a href="/Articles/729920/">the documentation in the patch itself</a> for
more information.  This appears to be a project to keep an eye on; if all
goes well, it will show the way forward for getting full performance out of
the huge, fast nonvolatile memory arrays that, we're told, we'll all be
able to get sometime soon.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Nonvolatile_memory">Filesystems/Nonvolatile memory</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/729812/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor729954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 5:41 UTC (Sat)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/729954/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We can all look forward to the day when userspace borks itself, and we reboot to find that userspace is still borked.  Perhaps then there will be some kind of intelligent interface allowing operators to go back one snapshot so that the system comes up all the way?   I know that some existing FSs have snapshotting features, but don't know how people use them, beyond transferring data between VMs.<br>
<p>
Why not just keep a read-only filesystem in the NVM and then bind- or overlay-mount over it?  The start-up time while the overlay was read into memory would be longer, but after that, the performance should be great, with little risk of data loss for some applications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 17:45 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/729980/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
We can all look forward to the day when userspace borks itself, and we reboot to find that userspace is still borked.
</blockquote>
Well, that's exactly what we have in the present day: bork the filesystem, reboot, and it's still going to be borked. NOVA's just another filesystem. Sure, the storage is directly addressable and probably insanely fast, but it's not some fundamentally new abstraction, and the 'bork an important filesystem and reboot will not save you' properly is just the same as it is on present-day filesystems.
      
          <div class="CommentReplyButton">
            <form action="/Articles/729980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 5:05 UTC (Mon)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/730041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;bork the filesystem, reboot, and it's still going to be borked.</font><br>
<p>
Sorry for being unclear.   I was thinking more that having 'memory' and 'storage on filesystems' as distinct advantages and disadvantages.  Blurring the distinction between them will have many consequences, some of which are unpleasant and perhaps unanticipated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor729960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 12:09 UTC (Sat)
                               by <b>eSyr</b> (guest, #112051)
                              [<a href="/Articles/729960/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it better than tmpfs? If so, can tmpfs be transparently replaced with nova?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 13:32 UTC (Sat)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/729964/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>My understanding is that tmpfs will spill into swap space if necessary.  That's clearly not something NOVA would want to do.  So if you need that feature, then NOVA cannot replace tmpfs.
      
          <div class="CommentReplyButton">
            <form action="/Articles/729964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 12:17 UTC (Sun)
                               by <b>idra</b> (guest, #36289)
                              [<a href="/Articles/730003/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would you ever touch swap? I already have to regularly systemctl mask tmp.mount to avoid useless tmp data sucking away precious RAM...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 21:25 UTC (Sun)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/730032/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>tmpfs data doesn't suck away precious RAM.  It uses the cache to store data and that memory is reclaimed if needed.
      
          <div class="CommentReplyButton">
            <form action="/Articles/730032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2017 15:23 UTC (Thu)
                               by <b>krakensden</b> (subscriber, #72039)
                              [<a href="/Articles/730493/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know how it's implemented, but my first bad experience with tmpfs /tmp was discovering that Vagrant wrote machine images there, and everything started behaving super poorly. Is it safe to use now with large files?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2017 15:31 UTC (Thu)
                               by <b>bof</b> (subscriber, #110741)
                              [<a href="/Articles/730494/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
tmpfs is totally usable with large files - as long as you have enough RAM to spare and don't have it go to swap.<br>
<p>
I use tmpfs continuously on server VMs, with multi GB files and/or up to 80 GB in smaller files (precomputed mysql tables...) - always worked without any issues. However, these VMs don't have any swap configured (or even swap support in the kernel), so YMMV.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor729966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 14:14 UTC (Sat)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/729966/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What kind of hardware is available to run this on? Anything affordable?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 4:44 UTC (Sun)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/729996/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Intel Xpoint storage should come out in DIMM form factor soon, which should work this this.  <a href="https://en.wikipedia.org/wiki/3D_XPoint">https://en.wikipedia.org/wiki/3D_XPoint</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor729969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 14:55 UTC (Sat)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/729969/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Tying a filesystem to a particular storage technology and thus losing the ability to move the filesystem between storage devices doesn't seem to be a desirable feature in any filesystem from a user perspective.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Technology-specific</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 15:57 UTC (Sat)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/729976/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Tying it to the technology can make sense if your whole purpose is to exploit that technology to its fullest.  If you later decide you want to move the filesystem back to your floppy disk array, you'll need to do a copy anyway, so changing the filesystem type shouldn't be a big deal.  How often do you move a filesystem image between different media types?
<p>
Now the inability to move to another system with a different number of processors...<i>that</i> seems like a problem...
      
          <div class="CommentReplyButton">
            <form action="/Articles/729976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Technology-specific</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 17:59 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/729981/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Particularly given that we support dynamic CPU plugging/unplugging...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor730140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Technology-specific</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2017 5:37 UTC (Tue)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/730140/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Corbet, what RAID levels does your floppy-array support?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor731361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Technology-specific</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2017 11:13 UTC (Fri)
                               by <b>mips</b> (guest, #105013)
                              [<a href="/Articles/731361/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would imagine it can do RAID 5 but you may be occasionally prompted to insert disc 2.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/731361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor729970"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 15:09 UTC (Sat)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/729970/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What I don't quite get is ... it's memory.  Why not just treat it as memory?  Shift the processor into 64-bit address space mode and just call it allllll memory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729970/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729975"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 15:55 UTC (Sat)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/729975/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      It's not just memory, it's <i>persistent</i> memory.  But persistence is only useful if you can find stuff later.  As mentioned in the article, that means you need some sort of directory structure.
      
          <div class="CommentReplyButton">
            <form action="/Articles/729975/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 19:20 UTC (Sun)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/730024/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But I thought the point of persistent memory is that it is *just* memory - when you shut the machine down, the CPU quits incrementing the instruction pointer and the system shuts down.  When you hit the power button, the instruction pointer picks right back up and the machine keeps running.  The memory is managed by the standard memory manager, I would expect - programs know where their memory is supposed to be.  The image I'm getting here is that "persistent memory" is nothing but marketing speak - it's actually just a SSD.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 19:38 UTC (Sun)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/730026/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; When you hit the power button, the instruction pointer picks right back up and the machine keeps running.</font><br>
<p>
That's an eventual goal, but for compatibility with existing software, that doesn't happen yet.  And the rest of the hardware on the system doesn't work without power, either, so it's more like suspend-to-RAM but with zero power usage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor730027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The point</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 19:42 UTC (Sun)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/730027/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Many years ago, I worked with a Data General Nova machine that had core memory.  It worked that way: turn it off at the end of the day, and it would pick up where it left off in the morning.  Most of the time.
<p>
Persistent memory is not core memory, though, and it's not a replacement for DRAM, at least not now; it has rather different performance characteristics.  So systems will have both types of memory for the foreseeable future.  It differs rather significantly from an SSD, though, in that it is byte-addressable by the CPU.  <i>That</i> changes a lot of the calculations and is why filesystems like NOVA may make sense.
      
          <div class="CommentReplyButton">
            <form action="/Articles/730027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The point</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2017 13:24 UTC (Wed)
                               by <b>JFlorian</b> (guest, #49650)
                              [<a href="/Articles/730280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You and I share a common history there.  A DG Nova was my first experience with a larger system.  I'm always amazed at how far technology has advanced, but this reminder was rather jarring (in a good way).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor730044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 6:24 UTC (Mon)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/730044/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; When you hit the power button, the instruction pointer picks right back up and the machine keeps running.</font><br>
<p>
For that you need not only persistent memory, but also a persistent CPU.<br>
<p>
<font class="QuotedText">&gt;  The image I'm getting here is that "persistent memory" is nothing but marketing speak - it's actually just a SSD.</font><br>
<p>
The big conceptual difference is that the CPU can address the memory directly. The CPU is able to store and load data, and execute code just like with ordinary RAM. That's not possible with today's SSDs.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730791"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2017 21:30 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/730791/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
<blockquote>
When you hit the power button, the instruction pointer picks right back up and the machine keeps running.
</blockquote>
For that you need not only persistent memory, but also a persistent CPU.
</blockquote>

<P>You need persistent a lot more than that.  Main memory is only one of myriad holders of state in a computer.  Look at how hard suspend/resume is.  You can't just store the contents of main memory, power down, then restore that memory upon power up and keep going.  Every device in the computer has some volatile memory in it (disk controllers, for example).  And since you can't keep the time of day persistent, there is some difficulty there too.

<blockquote>
<blockquote>
The image I'm getting here is that "persistent memory" is nothing but marketing speak - it's actually just a SSD.
</blockquote>
The big conceptual difference is that the CPU can address the memory directly.
</blockquote>

<p>This misses Tara_Li's point.  This difference affects only what kernel code you write to use it.  The user still sees persistent storage that works at solid state speeds, that you could use to store data, which is exactly what SSDs are all about.
<p>But Jon points out one difference between persistent memory and SSD that could actually make a difference in its application: persistent memory is byte-addressable.

      
          <div class="CommentReplyButton">
            <form action="/Articles/730791/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor731114"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2017 13:56 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/731114/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Software has problems like memory leaks and bugs that make process persistence less practical than it may appear at first.

<p>E.g., some earlier version of Microsoft Word exhibited many of the disadvantages of trying to work with process persistence only: When the user saved the document, it produced more or less a dump of its memory, and when loading the document, the memory dump was restored.  The document contained a lot of stuff that had been deleted by the user (which led to various interesting findings), and if the memory was corrupted in some way (that would lead to a crash on certain operations), that corruption would end up in the saved document, persisting the crash across the save.  Letting a new version of Word load an old document was probably a major programming feat, and the other way was not possible at all.

<p>Saving data in a well-defined format instead of just keeping it in persistent process memory or saving it as a memory dump is more work at first, but it pays off.

<p>We have had persistent OSs like EROS for decades (they saved the changed pages to disk every 30s or so, so you would lose up to that amount of work on a crash, much like with file systems), but they did not catch on, nor did mainstream OSs acquire process persistence features (well, there's hibernation, but the OS is still not designed to let processes live forever).  Maybe now, with containers.

<p>So when we have a persistent variant of RAM, we still need to save data from processes, so we still need a file system.

The choice of  having a log-structured base for such a file system surprised me, though.
      
          <div class="CommentReplyButton">
            <form action="/Articles/731114/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor729982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 18:05 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/729982/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In addition to what Corbet noted, most of the proposed tech sits between flash and true RAM in terms of performance.  10x-1000x slower than RAM, depending on tech and what you're measuring (and whose claims of future performance you believe).  One could end up quite sad from expecting truly RAM like performance from some persistent memory solutions.<br>
<p>
(The above leaves out battery backed DIMMs, I suppose.  But they don't seem like a tech with broad applicability.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 3:03 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/729992/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The current tech is basically a mock-up of future persistent RAM. It's expected to be within the usual DRAM performance range, if not that durable. It'll certainly be faster than flash.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 17:54 UTC (Sun)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/730020/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Really?  Is it?  Intel's marketing of 3D xpoint (available now) sort of suggests it will be RAM level, but the actual numbers are well off.  They're faster than flash, but they live between flash and RAM.<br>
<p>
They're claiming they'll be ~0.5 microsecond latency, but current 3D xpoint stuff is more like 5 microseconds.  Flash is more like 100 microseconds, DRAM is 5-30 nanoseconds.  So another 100x faster than 3D xpoint, 1000x if you use the latencies of what you can buy today.<br>
<p>
Those numbers are from memory mostly, but I'm pretty sure they're broadly correct.   Maybe there's other tech or I've got the #s off a bit...?<br>
<p>
So it creates another (fascinating) stopping point in the storage/memory/cache hierarchy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 2:23 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/730040/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can not buy 3D xpoint on the open market right now (I tried to buy one), apparently it's sold only to Intel partners under heavy NDAs for evaluation purposes only.<br>
<p>
All I was able to find were battery-backed DRAMs with flash for longer-term storage, which is kinda disappointing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 12:52 UTC (Mon)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/730058/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, sorry.  I'm drawing my info from public sources, and I thought the reviews meant it was generally available.<br>
<p>
That IS disappointing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor730372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2017 18:47 UTC (Wed)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/730372/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fundamental thing is that emacs communicates to gcc and git by doing one side of a particular set of system calls, and the other ends of this one-to-many-over-time interaction expect to use another set of system calls to retrieve it. Additionally, the system calls have some defined semantics for what the acceptable intermediate states in the source program's sequence to make visible to other programs, including the case where the source program crashes for some reason (not necessarily a power failure).<br>
<p>
If you think about the IPC properties of filesystems, it's clear that you need one, even if memory isn't at particular risk from losing power.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor730399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2017 22:06 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/730399/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can do that if you want. Take a file and mmap it. If NOVA works like tmpfs then writing to the mmap is writing directly into RAM. I haven't checked but I don't see why it would do anything else. Double buffering it would just be silly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor729990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2017 22:42 UTC (Sat)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/729990/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">it is impossible to move a NOVA filesystem from one system to another if the two machines do not have the same number of CPUs.</font></blockquote>

<p>Do you suppose that an option to  limit the number of per-CPU arrays of inodes when creating a NOVA filesystem can be implemented?</p>

<p>For example: <tt>% mknovafs -O cpu=4 /dev/nvramdevice1</tt> (or similar) such that the number of <tt>cpu</tt>s may be less than how many CPUs that computer has.</p>

<p>Setting <tt>cpu=1</tt> could make a filesystem capable of being exported to <em>any</em> computer.  Of course, that would <b>not</b> <font class="QuotedText">make sense if your whole purpose is to exploit that technology to its fullest</font> (quoting our Editor).</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 7:50 UTC (Sun)
                               by <b>swanson</b> (guest, #116493)
                              [<a href="/Articles/730001/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We don't need anything so complicated as a separate utility.<br>
<p>
The origin of the CPU-count dependence is that NOVA divides PMEM into per-CPU allocation regions.  We use the current CPU ID as a hint about which region to use and avoid contention on the locks that protect it.  <br>
<p>
So moving from a smaller number of CPUs to a larger number of CPUs just means more contention for the locks.  Moving from a larger number to a smaller number is no problem at all.  So, our current plan is to set the CPU count very high (like 256) when the file system is created.<br>
<p>
-steve<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730012"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 14:42 UTC (Sun)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/730012/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is vaguely similar to XFS' allocation groups?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730012/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor730047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Number of CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 7:49 UTC (Mon)
                               by <b>skitching</b> (guest, #36856)
                              [<a href="/Articles/730047/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds to me like "bucketing" as used in NoSQL databases or "consistent hashing" algorithms.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor730052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 8:50 UTC (Mon)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/730052/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Does this mean some memory cannot be allocated unless you have all 256 CPUs?
      
          <div class="CommentReplyButton">
            <form action="/Articles/730052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 9:20 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/730054/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would imagine that each CPU will have several partitions assigned to it. If the number of CPUs is less than the number of partitions then some CPUs will have multiple partitions, if the reverse is true then some partitions will be shared across several CPUs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor729999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2017 7:43 UTC (Sun)
                               by <b>swanson</b> (guest, #116493)
                              [<a href="/Articles/729999/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm one of NOVA's designers, and I wanted to clarify one point in the (very nice) article:<br>
<p>
NOVA does support DAX mmap.   The original paper focused on the atomic mmap mechanism because it was novel (such is the way of research), but normal DAX mmap is fully supported.  We received some useful (and not very positive) feedback about atomic mmap from several people, so I'm not sure that atomic mmap is likely to remain a feature.<br>
<p>
-steve<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730064"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mmap() + checksum = ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 13:54 UTC (Mon)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/730064/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; NOVA disables COW for the portions of a file that have been mapped into a process's address space, so changes are made in place.</font><br>
<p>
<font class="QuotedText">&gt; There are a number of self-protection measures built into NOVA, including checksumming for data and metadata.</font><br>
<p>
If you mmap() the storage as memory and write to it in-place from the CPU, that would invalidate the data checksum.  If the system crashes at that point, what happens to the file with invalid checksum after the system reboots?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730064/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor731050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mmap() + checksum = ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2017 17:58 UTC (Tue)
                               by <b>swanson</b> (guest, #116493)
                              [<a href="/Articles/731050/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is an interesting problem.<br>
<p>
The approach that NOVA takes is to disable parity/checksum protection while data is mmap'd and re-enable it when the mapping is finished.  We track overlapping maps etc., and we have log mmap operations so we can re-enable protection after reboot.<br>
<p>
The reasoning for this approach is that when you use DAX-mmap() you take responsibility for your data.  This includes responsibility for updating it consistently and responsibility for protecting it from media errors, etc.   As you point out, the file system really can't fill this role (at least not without a significant performance penalty), so it must fall to the application.<br>
<p>
-steve<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/731050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor730050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How about ubifs and friends?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 8:28 UTC (Mon)
                               by <b>giggls</b> (subscriber, #48434)
                              [<a href="/Articles/730050/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Reading the Article I was wondering about the differences of this approach compared to ubifs/mtd.<br>
<p>
Am I right in the assumption that the devices targeted by ubifs/mtd can not be written in a byte-wise manner while the devices targeted by NOVA filesystem can?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor730103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 16:13 UTC (Mon)
                               by <b>sasha</b> (guest, #16070)
                              [<a href="/Articles/730103/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Academic work has a discouraging tendency to stop when the papers are published and the grant money runs out"<br>
<p>
As BFQ I/O scheduler (2008: <a href="https://lkml.org/lkml/2008/4/1/234">https://lkml.org/lkml/2008/4/1/234</a> 2014: <a href="https://lwn.net/Articles/600366/">https://lwn.net/Articles/600366/</a> 2016: <a href="https://lwn.net/Articles/709202/">https://lwn.net/Articles/709202/</a>) shows, academic work has a discouraging tendency to be ignored by kernel community for years, because there is no "BIG CORP" behind it.  Google or Facebook can say "we already use this patch, please accept it" and kernel community accepts even imperfect patch.  It is not so easy for patches from academic community; at least it was not so easy for Paolo Valente.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 17:12 UTC (Mon)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/730107/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It takes ongoing work to get something merged into the kernel, and that work falls outside the scope of typical academic funding/manpower.  Meanwhile, Google/Facebook/etc employs full-time kernel folks, and getting stuff mainlined is part of their job description.<br>
<p>
So it's less about $BIGCORP and more to do with the realities of academia being somewhat different from the real world.  (Or at least the realities of the kernel development process..)<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2017 2:36 UTC (Tue)
                               by <b>smckay</b> (guest, #103253)
                              [<a href="/Articles/730134/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm very much an outsider, but it definitely does seem like contributions from large companies have an easier time getting merged. I'm sure a lot of it is down to having people experienced with kernel development getting paid to do the work, but I think justifying the change is easier too. Like, is this patch worth the effort? Will it be used? If it's already running on umpty-million Android handsets or a jillion cloud servers or a thousand enterprise customers are slavering to buy the hardware that goes with this driver, the usefulness is already there. Whereas something coming out of academia, probably not production quality yet, without a significant installed base, is going to be harder to justify.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor730357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2017 17:03 UTC (Wed)
                               by <b>mfuzzey</b> (subscriber, #57966)
                              [<a href="/Articles/730357/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not sure about big companies having an easier time due to it being easier to justify changes.<br>
<p>
I think the justification is far more linked to the technical merits, maintenance load and the impact on the kernel than the number of devices using it.<br>
<p>
For example the android "wake lock" stuff took years before being merged (and it wasn't merged "as is" but in a significantly modified form).<br>
<p>
There are drivers for very niche devices, driver submissions are accepted, even from "unknown" individuals, provided they respect the license and coding style rules and pass review. I've never seen any questions about how many of the devices are out there for it to be "worth the effort"...<br>
For this reason, contrary to popular belief, Linux actually supports *more* devices than Windows (particularly true for older devices).<br>
<p>
Getting non trivial code into the core kernel though, is significantly more difficult since the potential for breakage is much higher.<br>
<p>
But yes, corporate developpers do have the advantage of having more time, by virtue of being paid to work on the kernel, and often in house peer review before anything even gets submitted to the public mailing lists.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor733177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem/Patches from large companies</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2017 19:22 UTC (Thu)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/733177/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The biggest reasons why contributions from large companies have an easier time getting merged is that they tend to approach the kernel community with complete implementations that have been run for months on a large number of systems, and they often have benchmarks to show performance, memory, etc. improvements over a range of configurations. Compare that with someone who has a notion that they've tested a few times and seems to work for them.<br>
<p>
Additionally, large companies tend to have the resources to hire people and keep them working on the kernel. This allows a level of familiarity and comfort with their work to grow. This is very useful when evaluating the likelihood that someone's work is correct, though the same factors risk a sense of complacency.<br>
<p>
Note that that large companies do not always get it right. For example, multiple features Google created were too narrowly focused on Android and did not work as the larger community would have wished. It's taken years to remedy the ones that could be remedied. A large part of this was a failure to openly and frequently engage with the kernel community up front.<br>
<p>
I would, however, hope that nobody is discouraged if they don't work for a large company. Those companies, economic powerhouses though they may be, tend towards group think and hold no monopolies on creativity. It's a lot of work to get something into the kernel but it still remains well within the abilities of lone developers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/733177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor730106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The NOVA filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2017 17:07 UTC (Mon)
                               by <b>sperl</b> (subscriber, #5657)
                              [<a href="/Articles/730106/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still wonder why no  implementation of shared memory that uses  nvram and which persists accross reboots/power outage has appeared yet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/730106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
