        <!DOCTYPE html>
        <html lang="en">
        <head><title>Linux Filesystem, Storage, and Memory Management Summit, Day 2 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/437066/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/436764/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/437066/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Linux Filesystem, Storage, and Memory Management Summit, Day 2</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 6, 2011</br>
           </div>
This article covers the second day of the 2011 Linux Filesystem, Storage,
and Memory Management Summit, held on April&nbsp;5, 2011 in San Francisco,
California.  Those who have not yet seen the <a
href="/Articles/436871/">first day coverage</a> may want to have a look
before continuing here. 
<p>
The opening plenary session was led by Michael Cornwall, the global
director for technology standards at <a
href="http://www.idema.org/">IDEMA</a>, a standards organization for disk
drive manufacturers.  His talk, which was discussed <a
href="/Articles/437014/">in a separate article</a>, covered the changes
that are coming in the storage industry and how the Linux community can get
involved to make things work better.
<p>
<h4>I/O resource management</h4>
<p>
The main theme of the memory management track often appeared to be "control
groups"; for one session, though, the entire gathering got to share the control
group fun as Vivek Goyal, Fernando Cao, and Chad Talbott led a discussion on
I/O bandwidth management.  There are two I/O bandwidth controllers in the
kernel now: the throttling controller (which can limit control groups to an
absolute bandwidth value) and the proportional controller (which divides up
the available bandwidth between groups according to an administrator-set
policy).  Vivek was there to talk about the throttling controller, which is
in the kernel and working, but which still has a few open issues.
<p>
One of those is that the throttling controller does not play entirely well
with journaling filesystems.  I/O ordering requirements will not allow the
journal to be committed before other operations have made it to disk; if
some of those other operations have been throttled by the controller, the
journal commit stalls and the 
whole filesystem slows down.  Another is that the controller can only
manage synchronous writes; writes which have been buffered through the page
cache have lost their association with the originating control group and
cannot be charged against that group's quota.  There are <a
href="/Articles/429295/">patches</a> to perform throttling of buffered
writes, but that is complicated and intrusive work.
<p>
Another problem was pointed out by Ted Ts'o: the throttling controller
applies bandwidth limits on a per-device basis.  If a btrfs filesystem is
in use, there may be multiple devices which make up that filesystem.  The
administrator would almost certainly want limits to apply to the volume
group as a whole, but the controller cannot do that now.  A related problem
is that some users want to be able to apply global limits - limits on the
amount of bandwidth used on all devices put together.  The throttling
controller also does not work with NFS-mounted filesystems; they have no
underlying device at all, so there is no place to put a limit.<p>
<p>
Chad Talbott talked about the proportional bandwidth controller; it works
well with readers and synchronous writers, but, like the throttling
controller, it is unable to deal with asynchronous writes.  Fixing that
will require putting some control group awareness into the per-block-device
flushing threads.  The system currently maintains a set of per-device lists
containing inodes with dirty pages; those lists need to be further
subdivided into per-control-group lists to enable the flusher threads to
write out data according to the set policy.  This controller also does not
yet properly implement hierarchical group scheduling, though there are <a
href="/Articles/427961/">patches</a> out there to add that functionality.
<p>
The following discussion focused mostly on whether the system is
accumulating too many control groups.  Rather than a lot of per-subsystem
controllers, we should really have a cross-subsystem controller mechanism.
At this point, though, we have the control groups (and their associated
user-space API which cannot be broken) that are in the kernel.  So, while
some (like James Bottomley) suggested that we should maybe dump the
existing control groups in favor of something new which gets it right, that
will be a tall order.  Beyond that, as Mike Rubin pointed out, we don't
really know how control groups should look even now.  There has been a lack
of "taste and style" people to help design this interface.
<p>
<h4>Working set estimation</h4>
<p>
Back in the memory management track, Michel Lespinasse discussed Google's
working set estimation code.  Google has used this mechanism for some time
as a way of optimally placing new jobs in its massive cluster.  By getting
a good idea of how much memory each job is really using, they can find the
machines with the most idle pages and send new work in that direction.
Working set estimation, in other words, helps Google to make better
decisions on how to overcommit its systems.
<p>
The implementation is a simple kernel thread which scans through the
physical pages on the system, every two minutes by default.  It looks at
each page to determine whether it has been touched by user space or not and
remembers that state.  The whole idea is to try to figure out how many
pages could be taken away from the system without causing undue memory
pressure on the jobs running there.
<p>
The kernel thread works by setting a new "idle" flag on each page which
looks like it has not been referenced.  That bit is cleared whenever an
actual reference happens (as determined by looking at whether the VM
subsystem has cleared the "young" bit).  Pages which are still marked idle
on the successive scan are deemed to be unused.  The estimation code does
not take any action to reclaim those pages; it simply exports statistics
on how many unused pages there are through a control group file.  The
numbers are split up into clean, swap-backed dirty, and file-backed dirty
pages.  It's then up to code in user space to decide what to do with that
information.
<p>
There were questions about the overhead of the page scanning; Michel said
that scanning every two minutes required about 1% of the available CPU
time.  There were also questions about the daemon's use of two additional
page flags; those flags are a limited resource on 32-bit systems.  It was
suggested that a separate bitmap outside of the <tt>page</tt> structure
could be used.  Google runs everything in 64-bit mode, though, so there has
been little reason to care about page flag exhaustion so far.  Rik van Riel
suggested that the feature could simply not be supported on 32-bit
systems.  He also suggested that the feature might be useful in other
contexts; systems running KVM-virtualized guests could use it to control
the allocation of memory with the balloon driver, for example.
<p>
<h4>Virtual machine sizing</h4>
<p>
Rik then led a discussion on a related topic: allocating the right amount
of memory to virtual machines.  As with many problems, there are two
distinct aspects: policy (figuring out what the right size is for any given
virtual machine) and mechanism (actually implementing the policy
decisions).  There are challenges on both sides.
<p>
There are a number of mechanisms available for controlling the memory
available to a virtual machine.  "Balloon drivers" can be used to allocate
memory in guests and make it available to the host; when a guest needs to
get smaller, the balloon "inflates," forcing the guest to give up some
pages.  <a href="/Articles/198380/">Page hinting</a> is a mechanism by
which the guest can inform the host that certain pages do not contain
useful data (for example, they are on the guest's free list).  The host can
then reclaim memory used for so-hinted pages without the need to write them
out to backing store.  The host can also simply swap the guest's pages out
without involving the guest operating system at all.  The <a
href="/Articles/330589/">KSM</a> mechanism allows the kernel to recover
pages which contain duplicated contents.  Compression can be used to cram
data into a smaller number of pages.  Page contents can also simply be
moved around between systems or stashed into some sort of transcendent
memory scheme.
<p>
There seem to be fewer options on the policy side.  The working set
estimation patches are certainly one possibility.  One can control memory
usage simply through decisions on the placement of virtual machines.  The
transcendent memory mechanism also allows the host to make policy decisions
on how to allocate its memory between guests.
<p>
One interesting possibility raised by Rik was to make the balloon mechanism
better.  Current balloon drivers tend to force the release of random pages
from the guest; that leads to fragmentation in the host, thwarting attempts
to use huge pages.  A better approach might be to use page hinting,
allowing the guest to communicate to the host which pages are free.  The
balloon driver could then work by increasing the free memory thresholds
instead of grabbing pages itself; that would force the guest to keep more
pages free.  Even better, memory compaction would come into play, so the
guest would be driven to free up contiguous ranges of pages.  Since those
pages are marked free, the host can grab them (hopefully as huge pages) and
use them elsewhere.  With this approach, there is no need to pass pages
directly to the host; the hinting is sufficient.
<p>
There are other reasons to avoid the direct allocation of pages in balloon
drivers; as Pavel Emelyanov pointed out, that approach can lead to
out-of-memory situations in the guest.  Andrea Arcangeli stated that, when
balloon drivers are in use, the guest must be configured with enough swap
space to avoid that kind of problem; otherwise things will not be stable.
The policy implemented by current balloon drivers is also entirely
determined by the host system; it's not currently possible to let the guest
decide when it needs to grow.
<p>
There is also a simple problem of communication; the host has no
comprehensive view of the memory needs of its guest systems.  Fixing that
problem will not be easy; any sort of intrusive monitoring of guest memory
usage will fail to scale well.  And most monitoring tends to fall down when
a guest's memory usage pattern changes - which happens frequently.
<p>
Few conclusions resulted from this session.  There will be a new set of
page hinting patches from Rik in the next few weeks; after that, thought
can be put into doing ballooning entirely through hinting without having to
call back to the host.
<p>
<h4>Dirty limits and writeback</h4>
<p>

The memory management track had been able to talk for nearly a full hour
without getting into control groups, but that was never meant to last; Greg
Thelen brought the subject back during his session on the management of
dirty limits within control groups.  He made the claim that keeping track
of dirty memory within control groups is relatively easy, but then spent
the bulk of his session talking about the subtleties involved in that
tracking.
<p>
The main problem with dirty page tracking is a more general memory
controller issue: the first control group to touch a specific page
gets charged for it, even if other groups make use of that page later.
Dirty page tracking makes that problem worse; if control group "A" dirties
a page which is charged to control group "B", it will be B which is charged
with the dirty page as well.  This behavior seems inherently unfair; it
could also perhaps facilitate denial of service attacks if one control
group deliberately dirties pages that are charged to another group.
<p>
One possible solution might be to change the ownership of a page when it is
dirtied - the control group which is writing to the page would then be
charged for it thereafter.  The problem with that approach is pages which
are repeatedly dirtied by multiple groups; that could lead to the page
bouncing back and forth.  One could try a "charge on first dirty" approach,
but Greg was not sure that it's all worth it.  He does not expect that
there will be a lot of sharing of writable pages between control groups in
the real world.
<p>
The bigger problem is what to do about control groups which hit their dirty
limits.  Presumably they will be put to sleep until their dirty page counts
go below the limit, but that will only work well if the writeback code
makes a point of writing back pages which are associated with those control
groups.  Greg had three possible ways of making that happen.
<p>
The first of those involved creating a new <tt>memcg_mapping</tt> structure
which would take the place of the <tt>address_space</tt> structure used to
describe a particular mapping.  Each control group would have one of these
structures for every mapping in which it has pages.  The writeout code
could then find these mappings to find specific pages which need to be
written back to disk.  This solution would work, but is arguably more
complex than is really needed.
<p>
An approach which is "a little dumber" would have the system associating
control groups with inodes representing pages which have been dirtied by
those control groups.  When a control group goes over its limit, the system
could just queue writeback on the inodes where that group's dirty pages
reside.  The problem here is that this scheme does not handle sharing of
inodes well; it can't put an inode on more than one group's list.  One
could come up with a many-to-one mechanism allowing the inode to be
associated with multiple control groups, but that code does not exist now.
<p>
Finally, the simplest approach is to put a pointer to a memory control
group into each inode structure.  When the writeback code scans through the
list of dirty inodes, it could simply skip those which are not associated
with control groups that have exceeded their dirty limit.  This approach,
too, does not do sharing well; it also suffers from the disadvantage that
it causes the inode structure to grow.
<p>
Few conclusions were reached in this session; it seems clear that this code
will need some work yet.
<p>
<h4>Kernel memory accounting and soft limits</h4>
<p>
The kernel's memory control group mechanism is concerned with limiting
user-space memory use, but kernel memory can matter too.  Pavel Emelyanov
talked briefly about why kernel memory is important and how it can be
tracked and limited.  The "why" is easy; processes can easily use
significant amounts of kernel memory.  That usage can impact the system in
general; it can also be a vector for denial of service attacks.  For
example, filling the directory entry (dentry) cache is just a matter of
writing a loop running "<tt>mkdir&nbsp;x; cd&nbsp;x</tt>".  For as long as
that loop runs, the entire chain of dentries representing the path to the
bottommost directory will be pinned in the cache; as the chain grows, it
will fill the cache and prevent anything else from performing path
lookups. 
<p>
Tracking every bit of kernel data used by a control group is a difficult
job; it also becomes an example of diminishing returns after a while.  Much
of the problem can be solved by looking at just a few data structures.
Pavel's work has focused on three structures in particular: the dentry
cache, networking buffers, and page tables.  The dentry cache controller is
relatively straightforward; it can either be integrated into the memory
controller or made into a separate control group of its own.
<p>
Tracking network buffers is harder due to the complexities of the TCP
protocol.  The networking code already does a fair amount of tracking,
though, so the right solution here is to integrate with that code to create
a separate controller.
<p>
Page tables can occupy large amounts of kernel memory; they present some
challenges of their own, especially when a control group hits its limit.
There are two ways a process can grow its page tables; one is via system
calls like <tt>fork()</tt> or <tt>mmap()</tt>.  If a limit is hit there,
the kernel can simply return <tt>ENOMEM</tt> and let the process respond as
it will.  The other way, though, is in the page fault handler; there is no
way to return a failure status there.  The best the controller can do is to
send a segmentation fault signal; that usually just results in the
unexpected death of the program which incurred the page fault.  The only
alternative would be to invoke the out-of-memory killer, but that may not
even help: the OOM killer is designed to free user-space memory, not kernel
memory.
<p>
Pavel plans to integrate the page table tracking into the memory
controller; patches are forthcoming.
<p>
Ying Han got a few minutes to discuss the implementation of soft limits in
the memory controller.  As had been mentioned on the first day, soft limits
differ from the existing (hard) limits in that they can be exceeded if the
system is not under global memory pressure.  Once memory gets tight, the
soft limits will be enforced.
<p>
That enforcement is currently suboptimal, though.  The code maintains a
red-black tree in each zone containing the control groups which are over
their soft limits, even though some of those groups may not have
significant amounts of memory in that specific zone.  So the system needs
to be taught to be more aware of allocations in each zone.  
<p>
The response to memory pressure is also not perfect; the code picks the
control group which has exceeded its soft limit by the largest amount and
beats on it until it goes below the soft limit entirely.  It would probably
be better to add some fairness to the algorithm and spread the pain among
all of the control groups which have gone over their limits.  Some sort of
round-robin algorithm which would cycle through those groups would probably
be a better way to go.
<p>
There was clearly more to discuss on this topic, but time ran out and the
discussion had to end.
<p>

<h4>Transparent huge page improvements</h4>
<p>
Andrea Arcangeli had presented the transparent huge page (THP) patch set at the
2010 Summit and gotten some valuable feedback in return.  By the 2011
event, that code had been merged for the 2.6.38 kernel; it still had a
number of glitches, but those have since been fixed up.  Since then, THP
has gained some improved statistics support under <tt>/proc</tt>; there is
also an out-of-tree patch to add some useful information to
<tt>/proc/vmstat</tt>.  Some thought has been put into optimizing libraries
and applications for THP, but there is rarely any need to do that;
applications can make good use of the feature with no changes at all.
<p>
There are a number of future optimizations on Andrea's list, though he made
it clear that he does not plan to implement them all himself.  The first
item, though - adding THP support to the <tt>mremap()</tt> system call -
has been completed.  Beyond that, he would like to see the process of
splitting huge pages optimized to remove some unneeded TLB flush
operations.  The <tt>migrate_pages()</tt> and <tt>move_pages()</tt> system
calls are not yet THP-aware, so they split up any huge pages they are asked
to move.  Adding a bit of THP awareness to glibc could improve performance
slightly.
<p>
The big item on the list is THP support for pages in the page cache;
currently only anonymous pages are supported.  There would be some big
benefits beyond another reduction in TLB pressure; huge pages in the page
cache would greatly reduce the number of pages which need to be scanned by
the reclaim code.  It is, however, a huge job which would require changes
in all filesystems.  Andrea does not seem to be in a hurry to jump into
that task.  What might happen first is the addition of huge page support to
the tmpfs filesystem; that, at least, would allow huge pages to be used in
shared memory applications.
<p>
Currently THP only works with one size of huge pages - 2MB in most
configurations.  What about adding support for 1GB pages as well?  That
seems unlikely to happen anytime soon.  Working with those pages would be
expensive - a copy-on-write fault on a 1GB page would take a long time to
satisfy.  The code changes would not be trivial; the buddy allocator cannot
handle 1GB pages, and increasing <tt>MAX_ORDER</tt> (which determines the
largest chunk managed by the buddy allocator) would not be easy to do.
And, importantly, the 
benefits would be small to the point that they would be difficult to
measure.  2MB pages are enough to gain almost all of the performance
benefits which are available, so supporting larger page sizes is almost
certainly not worth the effort.  The only situation in which is might
happen is if 2MB pages become the basic page size for the rest of the
system.
<p>
Might a change in the primary page size happen?  Not anytime soon.  Andrea
actually tried it some years ago and ran into a number of problems.  Among
other things, a larger page size would change a number of system call
interfaces in ways which would break applications.  Kernel stacks would
become far more expensive; their implementation would probably have to
change.  A lot of memory would be wasted in internal fragmentation.  And a
lot of code would have to change.  One should not expect a page size change
to happen in the foreseeable future.
<p>
<h4>NUMA migration</h4>
<p>
Non-uniform memory access systems are characterized by the fact that some
memory is more expensive to access than the rest.  For any given node in
the system, memory which is local to that node will be faster than memory
found elsewhere in the system.  So there is a real advantage to keeping
processes and their memory together.  Rik van Riel made the claim that this
is often not happening.  Long-running processes, in particular, can have
their memory distributed across the system; that can result in a 20-30%
performance loss.  He would like to get that performance back.
<p>
His suggestion was to give each process a "home node" where it would run if
at all possible.  The home node differs from CPU affinity in that the
scheduler is not required to observe it; processes can be migrated away
from their home node if necessary.  But, when the scheduler performs load
balancing, it would move processes back to their homes whenever possible.
Meanwhile, the process's memory allocations would be performed on the home
node regardless of where the process is running at the time.  The end
result should be processes running with local memory most of the time.
<p>
There are some practical difficulties with this scheme, of course.  The
system may end up with a mix of processes which all got assigned to the
same home node; there may then be no way to keep them all there.  It's not
clear what should happen if a process creates more threads than can be
comfortably run on the home node.  There were also concerns about
predictability; the "home node" scheme might create wider variability
between identical runs of a program.  The consensus, though, was that speed
beats predictability and that this idea is worth experimenting with.
<p>

<h4>Stable pages</h4>
<p>
What happens if a process (or the kernel) modifies the contents of a page
in the time between when that page is queued for writing to persistent
storage and when the hardware actually performs the write?  Normally, the
result would be that the newer data is written, and that is not usually a
problem.  If, however, something depends on the older contents, the result
could be problematic.  Examples which have come up include checksums used
for integrity checking or pages which have been compressed or encrypted.
Changing those pages before the I/O completes could result in an I/O
operation failure or corrupted data - neither of which is desirable.
<p>
The answer to this problem is "stable pages" - a rule that pages which are
in flight cannot be changed.  Implementing stable pages is relatively easy
(with one exception - see below).  Pages which are written to persistent
storage are already marked read-only by the kernel; if a process tries to
write to the page, the kernel will catch the fault, mark the page 
(once again) dirty, then allow the write to proceed.  To implement stable
pages, the kernel need only force that process to block until any
outstanding I/O operations have completed.
<p>
The btrfs filesystem implements stable pages now; it needs them for a number
of reasons.  Other filesystems do not have stable pages, though; xfs and
OCFS implement them for metadata only, and the rest have no concept of
stable pages at all.  There has been some resistance to the idea of adding
stable pages because there is some fear that performance could suffer;
processes which could immediately write to pages under I/O would slow down
if they are forced to wait.
<p>
The truth of the matter seems to be that most of the performance worries
are overblown; in the absence of a deliberate attempt to show problems, the
performance degradation is not measurable.  There are a few exceptions;
applications using the Berkeley database manager seem to be one example.
It was agreed that it would be good to have some better measurements of
potential performance issues; a tracepoint may be placed to allow
developers to see how often processes are actually blocked waiting for
pages under I/O.
<p>
It turns out that there is one place where implementing stable pages is
difficult.  The kernel's <tt>get_user_pages()</tt> function makes a range
of user-space pages accessible to the kernel.  If write access is
requested, the pages are made writable at the time of the call.  Some time
may pass, though, before the kernel actually writes to those pages; in the
meantime, some of them may be placed under I/O.  There is currently no way
to catch this particular race; it is, as Nick Piggin put it, a real
correctness issue.
<p>
There was some talk of alternatives to stable pages.  One is to use bounce
buffers for I/O - essentially copying the page's contents elsewhere and
using the copy for the I/O operation.  That would be expensive, though, so
the idea was not popular.  A related approach would be to use
copy-on-write: if a process tries to modify a page which is being written,
the page would be copied at that time and the process would operate on the
copy.  This solution may eventually be implemented, but only after stable
pages have been shown to be a real performance problem.  Meanwhile, stable
pages will likely be added to a few other filesystems, possibly controlled
by a mount-time option.
<p>

<h4>Closing sessions</h4>
<p>
Toward the end of the day, Qian Cai discussed the problem of sustainable
testing.  There are a number of ways in which our testing is not as good as
it could be.  Companies all have their own test suites; they duplicate a
lot of effort and tend not to collaborate in the development of the tests
or sharing of the results.  There are some public test suites (such as
xfstests and the Linux Testing Project), but they don't work together and
each have their own approach to things.  Some tests need specific hardware
which may not be generally available.  Other tests need to be run manually,
reducing the frequency with which they are run.  
<p>
The subsequent discussion ranged over a number of issues without resulting
in any real action items.  There was some talk of error injection; that was
seen as a useful feature, but a hard thing to implement well.  It was said
that our correctness tests are in reasonably good shape, but that there are
fewer stress tests out there.  The xfstests suite does some stress testing,
but it runs for a relatively short period of time so it cannot catch memory
leaks; xfstests is also not very useful for catching data corruption
problems. 
<p>
The biggest problem, though, is one which has been raised a number of times
before: we are not very good at catching performance regressions.  Ted Ts'o
stated that the "dirty secret" is that kernel developers do not normally
stress filesystems very much, so they tend not to notice performance
problems. 
<p>
In the final set of lightning talks, Aneesh Kumar and Venkateswararao
Jujjuri talked about work which is being done with the 9p filesystem.  Your
editor has long wondered why people are working on this filesystem, which
originally comes from the Plan9 operating system.  The answer was revealed
here: 9p makes it possible to export filesystems to virtualized guests in a
highly efficient way.  Improvements to 9p have been aimed at that use case;
it now integrates better with the page cache, uses the virtio framework to
communicate with guests, can do zero-copy I/O to guests running under QEMU,
and supports access control lists.  The code for all this is upstream and
will be shipping in some distributions shortly.
<p>
Amir Goldstein talked about his <a href="/Articles/387231/">snapshot
code</a>, which now works with the ext4 filesystem.  The presentation
consisted mostly of benchmark results, almost all of which showed no
significant performance costs associated with the snapshot capability.  The
one exception appears to be the postmark benchmark, which performs a lot of
file deletes.
<p>
Mike Snitzer went back to the "advanced format" discussion from the
morning's session on future technology.  "Advanced format" currently means
4k sectors, but might the sector size grow again in the future?  How much
pain would it take for Linux to support sector sizes which are larger than
the processor's page size?  Would the page size have to grow too?
<p>
The answer to the latter question seems to be "no"; there is no need or
desire to expand the system page size to support larger disk sectors.
Instead, it would be necessary to change the mapping between pages in
memory and sectors on the disk; in many filesystems, this mapping is still
done with the buffer head structure.  There are some pitfalls, including
proper handling of sparse files and efficient handling of page faults, but
that is just a matter of programming.  It was agreed that it would be nice
to do this programming in the core system instead of having each filesystem
solve the problems in its own way.
<p>
The summit concluded with an agreement that things had gone well, and that
the size of the event (just over 70 people) was just about right.  The
summit, it said, should be considered mandatory for all maintainers working
in this area.  It was also agreed that the memory management developers
(who have only been included in the summit for the last couple of meetings)
should continue to be invited.  That seems inevitable for the next summit;
the head of the program committee, it was announced, will be memory
management  hacker Andrea Arcangeli.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer">Block layer</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Workshops">Filesystems/Workshops</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Conference_sessions">Memory management/Conference sessions</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_and_Memory-Management_Summit-2011">Storage, Filesystem, and Memory-Management Summit/2011</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/437066/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor437173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Filesystem, Storage, and Memory Management Summit, Day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 16:56 UTC (Wed)
                               by <b>scotthall</b> (guest, #73671)
                              [<a href="/Articles/437173/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about mmap_sem scalability which Nick discussed last time? Is he still working on it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor437287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Filesystem, Storage, and Memory Management Summit, Day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 23:18 UTC (Wed)
                               by <b>walken</b> (subscriber, #7089)
                              [<a href="/Articles/437287/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There were a couple aspects to that work. One is to reduce mmap_sem hold times - I have done some work in that area, which got in 2.6.37 and 2.6.38. There are still a few situations where mmap_sem is held while we want for a disk access, but it's much less common than it was last year.<br>
<p>
The other direction Nick proposed last year was to have smaller granularity for the mmap_sem - AFAIK there has been no major work in that direction.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor437188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Home nodes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 17:46 UTC (Wed)
                               by <b>andikleen2</b> (guest, #52506)
                              [<a href="/Articles/437188/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I already tried home nodes in 2.4. They didn't work.<br>
There was also another implementation from NEC. They saw some success<br>
on very large systems -- with large numa factors -- but they did<br>
poorly on the more common low NUMA factor two and four socket servers.<br>
<p>
The reason is that on these systems not using a core is always much<br>
worse than using remote memory. And if you give the scheduler too<br>
many conflicting inputs it will become schizo and schedule poorly and <br>
not use all cores well anymore.<br>
<p>
This is worst on dynamic workloads, for more static workloads it's<br>
not quite as bad.<br>
<p>
A better approach is some form of automatic migration, e.g. as <br>
implemented by Lee Schermerhorn: <br>
<a href="http://permalink.gmane.org/gmane.linux.kernel.numa/590">http://permalink.gmane.org/gmane.linux.kernel.numa/590</a><br>
This can actually fix up imbalances and also allow some other <br>
optimizations. Unfortunately it also doesn't work for all workloads,<br>
so it would need to be an optional knob.<br>
<p>
-Andi<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor437250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Home nodes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 20:45 UTC (Wed)
                               by <b>riel</b> (subscriber, #3142)
                              [<a href="/Articles/437250/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The solutions we tried in the past seem to be "big hammer" style solutions, that try to be fairly rigid in what the kernel is allowed to do.<br>
<p>
I want to see how little change we can get away with, and still get a decent performance improvement.  A home node would only be the node that memory allocations start on, and that the process is preferentially run on - the CPU scheduler does need to be able to run processes elsewhere temporarily.<br>
<p>
Only when a node is permanently overloaded, is it time to move some tasks elsewhere and eventually migrate over some of their memory (maybe with Lee's patches, or something based on them).<br>
<p>
My plan is to start small and only add things as needed, trying to stay away from a large, complete &amp; heavy plan.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor437285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Home nodes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 23:13 UTC (Wed)
                               by <b>andikleen2</b> (guest, #52506)
                              [<a href="/Articles/437285/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually the home nodes patches were quite simple. <br>
<p>
Good luck reinventing the flat tire.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor437294"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Home nodes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 23:51 UTC (Wed)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/437294/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I have no idea if you are right or not, don't you think that attempting to improve where other's have failed is potentially worthy of many tries?  Especially if there is no fundamental proof that something won't work?  And even more when a real unsolved problem is attempting to be solved?<br>
<p>
The analogy to reinventing the wheel is inappropriate, since in the case of a working solution, it is a waste of time to reinvent it.  But, in the case of failures, "reinventing it" (and potentially no longer failing), should be praised, not ridiculed, no? (again, with the proof caveat above, and even then some... proofs can sometimes be disproved)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437294/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor437433"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Home nodes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2011 20:49 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/437433/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are there any tools out there to show Linux programmers a timeline of when their threads have been migrated between CPUs?<br>
<p>
I know that valgrind can show you cache misses, but I'm not really aware of any tools that can display where the scehduler has put your threads over time. Maybe LTT-ng?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437433/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor437449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tools</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2011 23:02 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/437449/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <a rel="nofollow" href="http://blog.fenrus.org/?p=5">perf timechart</a> can generate some nice output which shows thread migration.
      
          <div class="CommentReplyButton">
            <form action="/Articles/437449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor437532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tools</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2011 14:01 UTC (Fri)
                               by <b>sbohrer</b> (guest, #61058)
                              [<a href="/Articles/437532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I personally much prefer to use <a href="http://lwn.net/Articles/425583/">kernelshark</a> for this.
      
          <div class="CommentReplyButton">
            <form action="/Articles/437532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor437283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Stable pages at Linux Filesystem, Storage, and Memory Management Summit, Day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 23:01 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/437283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Examples which have come up include checksums used for integrity checking or pages which have been compressed or encrypted.</font><br>
<p>
Checksums are an obvious need, but I don't understand the reference to compressed or encrypted pages.<br>
Surely if the kernel is compressing or encrypting it has to do it to a bounce buffer (or maybe extract the page from the page-cache completely before transforming it).  So I don't see what this has to do with stable pages...<br>
<p>
Of course RAID5 has always used bounce buffers to get the stability needed for xor calculations.  If an incoming dirty page was known to be stable already, I could avoid the copy operation!!  So a bio flag saying "these pages are stable" would be good.<br>
<p>
And I think this is an amusing juxtaposition:<br>
<p>
<font class="QuotedText">&gt; The truth of the matter seems to be that most of the performance worries are overblown; in the absence of a deliberate attempt to show problems, the performance degradation is not measurable.</font><br>
<p>
<font class="QuotedText">&gt; Ted Ts'o stated that the "dirty secret" is that kernel developers do not normally stress filesystems very much, so they tend not to notice performance problems. </font><br>
<p>
The performance issue caused by stable pages would be increased latency for a 'write' system call when there  is lots of free memory.  With delayed allocation this should not normally need to wait for IO at all, so occasionally having to wait for IO could cause unwelcome latency spikes in some applications.  However I suspect most current filesystems already have latency spikes for write for one reason or another, so I suspect it would be hard to notice a regression here.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor437721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Filesystem, Storage, and Memory Management Summit, Day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2011 16:08 UTC (Sun)
                               by <b>ccurtis</b> (guest, #49713)
                              [<a href="/Articles/437721/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Page tables can occupy large amounts of kernel memory; [...] when a control group hits its limit. [...] The other way, though, is in the page fault handler; there is no way to return a failure status there. The best the controller can do is to send a segmentation fault signal; [...]
</blockquote>

<p>As an application programmer I'd hate to see a SEGV if the system was unable to page in memory.  I think most people equate SEGV with a wild pointer and chances seem good that a debugger would show a pointer access somewhere nearby in an application backtrace.

<p>Wouldn't SIGBUS be a more appropriate signal to send in this case?
      
          <div class="CommentReplyButton">
            <form action="/Articles/437721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor437912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Filesystem, Storage, and Memory Management Summit, Day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2011 17:35 UTC (Mon)
                               by <b>jospoortvliet</b> (guest, #33164)
                              [<a href="/Articles/437912/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Despite my lack of deep technical knowledge, it is articles like these which make me a happy paid subscriber. Awesome, mr C!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor438829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Filesystem, Storage, and Memory Management Summit, Day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2011 22:01 UTC (Fri)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/438829/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Greg was not sure that it's all worth it. He does not expect that there will be a lot of sharing of writable pages between control groups in the real world."<br>
<p>
On a typical desktop Linux computer most of that is probably GL buffers / memory shared between application, X server and compositor...  X &amp; compositor might be in separate group from applications.  But I don't think the amounts are normally that significant compared to the whole memory in the computer.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/438829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor441854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Filesystem, Storage, and Memory Management Summit, Day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2011 23:15 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/441854/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not sure if it is still true with more recent Firefoxes but I remember that the Firefox web browser around version 2 would easily use over 300 MB of X memory on heavy image sites. On a 512 MB machine this was more than 50%.<br>
<p>
I wasn't using control groups back then of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/441854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
