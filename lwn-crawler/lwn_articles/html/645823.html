        <!DOCTYPE html>
        <html lang="en">
        <head><title>Firmware signing [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/645823/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/645410/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/645823/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Firmware signing</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>May 27, 2015</br>
           </div>
The kernel has had <a href="/Articles/525592/">the ability</a> to enforce
signature requirements on loadable modules for a few years now.  But there are
other types of code loaded by the kernel that are not, yet, subject to such
checks; firmware loaded into controllers via the kernel is perhaps the
primary example.  Work is being done to add the ability to enforce
signature requirements for
firmware blobs, but not everybody is convinced that there is a need for
this feature.
<p>
Luis Rodriguez <a href="/Articles/645824/">described</a> his plan on
various kernel mailing lists.  The kernel's module loader is currently
being <a href="/Articles/644649/">reworked</a> (by David Howells) to move
away from its home-built module-signing mechanism toward the <a
href="https://tools.ietf.org/html/rfc2315">PKCS#7</a> standard.  This is,
Luis said, a good time to adopt the same standard for the signing of other
files loaded into the kernel â€” firmware files in particular.
<p>
In this plan, the enforcement of signatures on firmware would be (like
enforcement of module signatures) optional; one could build a kernel
without this capability.  Most firmware loaded by Linux drivers is kept in
the <a
href="https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git">linux-firmware
repository</a>; those blobs would be signed by the firmware maintainer, and
would, thus, be loadable by default.  To make that scheme work, Luis has
proposed that the Linux Foundation create an <a
href="https://en.wikipedia.org/wiki/X.509">X.509</a> key that would be
embedded in the kernel source and would be used, in turn, to sign the
firmware maintainer's key.  The topic of firmware for out-of-tree modules
was not brought up; if nothing else, it should always be possible to add
other keys to the kernel's keyring to enable loading that firmware.
<p>
Andy Lutomirski quickly <a href="/Articles/645825/">raised some
concerns</a> about how these keys would be handled.  In particular, he
would like to ensure that the applicability of any given key is as limited
as possible.  Keys used for module signing should not work for firmware
signing, for example.  Signatures should also spell out where a firmware
blob is meant to be used in order to avoid attacks where firmware is sent to the
wrong device.
<p>
The more general question, though, as asked by <a
href="/Articles/645828/">Alan Cox</a> and <a href="/Articles/645829/">Greg
Kroah-Hartman</a>, was: why bother signing firmware files in the first
place?  As Greg put it:
<P>
<div class="BigQuote">
	I too don't understand this need to sign something that you don't
	really know what it is from some other company, just to send it to
	a separate device that is going to do whatever it wants with it if
	it is signed or not.
</div>
<p>
Both asserted that, if firmware signatures are to be checked, that checking
should be done by the actual device receiving the firmware.  Anything else
puts the kernel in the position of attesting to the validity of a firmware
image that it can't know much about.
<p>
The problem with checking signatures in the device, as David Woodhouse <a
href="/Articles/645830/">pointed out</a>, is that loadable firmware is
often used as a way to reduce the cost of the hardware.  Putting that sort
of cryptographic capability into a device (one which doesn't have its
operating software loaded yet, at that) would, instead, add expense and defeat the
original purpose.  Greg <a href="/Articles/645831/">disagreed</a> with the
idea that adding signature checking would be prohibitively expensive, but
the fact of the matter seems to be that hardware lacking firmware
signature-checking capability is not going away anytime soon.
<p>
David also <a href="/Articles/645832/">made the point</a> that, in the
absence of an I/O memory management unit, a rogue device can do anything it
wants to the running system.  Thus, compromised firmware might indeed be an
attractive way to attack a system.  Firmware signing, he said, is a way of
protecting the operating system; it is not just a service for hardware
vendors.
<p>
There is another reason for wanting this capability, though; it can be used
to verify the provenance of other files loaded into the kernel as well.
Luis, in particular, is concerned with the Linux "central regulatory domain
agent" (CRDA) subsystem.  CRDA describes the legal operating parameters for
wireless network interfaces in various jurisdictions worldwide.  Different
countries have different rules about which frequencies can be used, maximum
power levels, and more.  The CRDA subsystem ensures that Linux systems play
by the rules wherever they may end up.
<p>
Luis credits CRDA with having gotten us out of the situation where
manufacturers of wireless adapters refused to provide free drivers for
their hardware.  With CRDA in place, those manufacturers can be confident
that their hardware will be operated in a compliant fashion.  But that
confidence is only merited if the CRDA database cannot be trivially
modified by users.  To that end, the database is currently signed; that
signature is, on some distributions at least, verified in user space before
being loaded into the kernel.
<p>
The use of subsystem-specific cryptographic code seems like a sure path to
problems at some point; getting such code right is not easy, and the number
of eyeballs on, say, the CRDA signature-checking code is probably fairly
low.  So Luis would like to move the checking into the kernel and have it
use the same code that the module loader is using.  That should reduce the
amount of signature-checking code in use and increase confidence that said
code is actually working as planned.
<p>
In this case, there is no device to offload the responsibility for checking
a signature to; this is data
that is used directly by the kernel.  If the kernel is going to protect
itself from 
a corrupted CRDA database, it needs to do the checking itself.  Code that
does this checking can check firmware just as easily.  So it makes some
sense to introduce the feature as a firmware-validation mechanism that can
also check the integrity of other files loaded into the kernel.
<p>
The end result is that this feature will probably not have too much trouble
getting into the kernel once it's clear that the code works as intended.
The kernel community as a whole is generally receptive to the addition of
this sort of integrity-verification mechanism, as long as the policy
choices remain in the hands of the user.  Distributions may or may not
choose to enable firmware signature checking, but the option will be there
for those who want it.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Device_drivers-Firmware_loading">Device drivers/Firmware loading</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Firmware">Firmware</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Signing_code">Signing code</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/645823/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor646459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 2:04 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/646459/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
encouraging vendors to sign their firmware and only load 'approved' firmware is a step backwards for user freedom. The freedom to modify devices to do things their manufacturers never imagined should be preserved.<br>
<p>
As for the danger of bad firmware, anyone who can get the kernel to load "bad" firmware can also modify the kernel itself to do "bad" things.<br>
<p>
having the kernel sign/hash the firmware just like it does modules isn't attesting to the 'correctness' or 'safety' of that firmware, but just the fact that it is the firmware provided at build time (for those people who want to lock out any ability to use upgraded firmware with that kernel)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 6:57 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/646474/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I never really understood the use case for signed kernel modules(*), but if you can configure the kernel to refuse to load unsigned modules then consistency suggests doing the same for firmware images.<br>
<p>
(*) apart from the usual "secure boot" stuff where if you allow Linux to boot a trojaned version of Windows, the signing key for the Linux kernel itself might be revoked by Microsoft.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2015 18:39 UTC (Mon)
                               by <b>asaz989</b> (guest, #67798)
                              [<a href="/Articles/646907/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The use case for signed kernel modules is the same as secure boot - there is a set of attacks that involves replacing disk contents (specifically - the software images that resides on disk) with malicious versions, and you want a chain of signature verifications leading from the hardware's TPM (which is hard to replace or corrupt without some serious hardware) to any software that can compromise the security of the system. Loadable kernel modules are a very clear attack surface - if one of them is malicious, it can do literally anything.<br>
<p>
This is definitely a big thing for embedded device manufacturers (e.g. you want your networking infrastructure running Linux to refuse to boot if an attacker tries to subvert it by messing with its boot process), but it seems fairly reasonable to me that in general a desktop computer user also wants to be assured that the system they're running is the same one they decided to install.<br>
<p>
For example, a great attack against my disk encryption would be to just replace my boot kernel with one that pops up my password prompt, and then in addition to decrypting my disk would also send the key to a third party. To make this hard, the bootloader needs to verify that the software up to the unlock screen is valid, and I am quite certain that this involves loading at least one kernel module.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2015 7:51 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/646953/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with this approach of signing code is that exploits involve *2* things:<br>
<p>
* code<br>
* state<br>
<p>
Flaws in code are exploited using state.<br>
<p>
Signing code says nothing about it being secure. Signing code does nothing to stop the state, the attack vector, being modified by the attacker.<br>
<p>
If you want to boot to a known state, you must boot from *fully* *RO* media and in a RO environment.<br>
<p>
Then your problem becomes how to update that RO state in a secure way to another known good RO state. This problem is likely *more* tractable than solving security by signing just the code.<br>
<p>
Signing code, with firmware support, is not about providing security for you and me - or at least, it adds nothing over much simpler techniques. It's about providing *control* over the majority of users to a small federation of corporates.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2015 8:02 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/646956/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, and to claim that code signing gives you a boot to a known secure state is to sell snake-oil.<br>
<p>
Note further that a RO state+code boot of old, known-flawed, code is *more* secure and robust than booting signed, updated code. The former can guarantee a boot to a known "good" state, despite the flaws. The signed-code boot gives you no guarantees at all  - unless you have omniscience about all possible flaws.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor646993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2015 15:44 UTC (Tue)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/646993/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Then your problem becomes how to update that RO state in a secure way to another known good RO state. This problem is likely *more* tractable than solving security by signing just the code.</font><br>
<p>
I'm not sure this problem is tractable at all because almost by definition the boot will depend on state which is accessible with unattended RW by the computer in normal operation and  there is no way to differentiate between authorized and unauthorized changes.  Even if you could differentiate them the firmware would still need to parse and validate the state just the same as if there were no authentication at all. <br>
<p>
I guess if I had to design something to deal with firmware configuration variables that I'd have them only be editable during early boot by a locally present user, maybe signed with a locally generated key for consistency, or remotely if you establish a key pair for your configuration management system to sign config changes so the firmware can validate they came from an authorized source.  That would allow you to validate that both code and config were unmodified and came from a known source.<br>
<p>
That still doesn't do anything to validate activity from subsystems which have their own independent computers such as GPUs or Disks or Network but every new validation step pushes the attacker further out into the margins, all these validation steps will be designed and deployed one at a time building on the work done before.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor647068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2015 7:48 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/647068/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's still a hard problem sure.<br>
<p>
However, to start from a point of RO state and carefully open up only the smallest possible, controlled amount of external state needed to update is surely more tractable than *completely ignoring* the issue of the modifiable state being the attack vector (as the current code-signing efforts do).<br>
<p>
E.g., you can boot from RO state to a *guaranteed* secure point. At which point you could verify the signature on an update image (of the RO secure boot env, e.g.). A simple block-based reading of state + signature, and signature verification is of course a risk, but it's a much smaller risk than reading complicated filesystems and running code with access to a wide range of syscalls.<br>
<p>
Just signing huge swathes of code, and then leaving it exposed to vast amount of complex, attacker modifiable state, doesn't buy much in the way of security against those who design attacks against systems (though, it can buy those who control the keys control over the code, and over the vast majority of those who own the computers).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor647073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2015 9:30 UTC (Wed)
                               by <b>Limdi</b> (guest, #100500)
                              [<a href="/Articles/647073/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; to start from a point of RO state</font><br>
RO state from the computer's point of view or just mounted ro from initrd?<br>
<p>
There is a difference between hardware preventing writes and kernel preventing writes. What do you mean here?<br>
<p>
ps: Never seen a harddrive with a ro switch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor647076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2015 12:37 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/647076/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not thinking of specific implementation details. <br>
<p>
I'm just stating a design principle. The ideal for security is to start from code + state that could never have been modified by an attacker.<br>
<p>
Obviously, for the real world you have to find ways to relax that, particularly on state. That's where the details come in, and I'd agree there are tough problems here.<br>
<p>
Taking a code-only approach however relaxes things to a near meaningless point, if the goal is security at least.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor647330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2015 23:54 UTC (Fri)
                               by <b>Limdi</b> (guest, #100500)
                              [<a href="/Articles/647330/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An example implementation would be os/tails burned on cd, right?<br>
<p>
Did they solve this?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor646480"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 7:19 UTC (Fri)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/646480/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note though that the suggested solution, having the linux-firmware maintainer sign and it all be optional is far less restricting than the, to some people evidently more desirable, option of having the *hardware* check the signature.<br>
<p>
(Although I believe for certain classes of devices, e.g. using licensed spectrum, the latter is bound to happen sooner rather than later)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646480/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 8:45 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/646501/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (Although I believe for certain classes of devices, e.g. using licensed spectrum, the latter is bound to happen sooner rather than later)</font><br>
<p>
The problem is that the hardware doesn't have any way of knowing what _your_ license allows you to do.<br>
<p>
Even for something like what wifi channels are you allowed to use, the problem is that the hardware can't know where in the world it is, so if you lie to it and tell it the wrong country, it will believe you and allow you to use channels that are licensed differently where you actually are.<br>
<p>
Given that they tolerate the sale of handheld radios at $30/ea that can broadcast on pretty much any frequency from 100-500MHz, I doubt that they will go crazy trying to lock down computer equipment.<br>
<p>
I believe that there will be proposals to have such requirements. I just doubt that they will be effective.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor646503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 8:44 UTC (Fri)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/646503/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nobody is proposing that the owner of a system should not be permitted to load whatever firmware they wish to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 8:48 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/646506/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If they are saying that the hardware should be checking signatures, they are saying that it should be able to prevent me from loading firmware of my choice..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646667"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 1:27 UTC (Sat)
                               by <b>lsl</b> (subscriber, #86508)
                              [<a href="/Articles/646667/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In a perfect world the hardware would be checking signatures *and* allow the owner of the device to decide which ones are considered ok. But I agree that, in the world we have, it's terribly unlikely that a peripheral device vendor adding a signature checking capability to their devices would simultaneously add a mechanism for the owner to change the set of trusted keys.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646667/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 10:53 UTC (Sat)
                               by <b>Limdi</b> (guest, #100500)
                              [<a href="/Articles/646690/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But I agree that, in the world we have, it's terribly unlikely that a peripheral device vendor adding a signature checking capability to their devices would simultaneously add a mechanism for the owner to change the set of trusted keys.</font><br>
<p>
Cause they might want one day create lock-in or cause of some other incentives not to do so?<br>
<p>
Or would it cost too much to add a secure usb storage reader?<br>
<p>
Or cause it would make the system less trustable cause anyone could insert new keys? Could be prevented by some system rules. A new key only once a day or something similar.<br>
Or hardware could transmit used keys so &lt;responsible person&gt; gets notified immediately.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 11:15 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/646692/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there's no incentive for them to go to the effort to add the capability.<br>
<p>
<font class="QuotedText">&gt;  Or would it cost too much to add a secure usb storage reader?</font><br>
<p>
how many different USB readers do you want in your system? if everything that has firmware uploaded to it had it's own reader, that would add to a lot of readers<br>
<p>
and then when you consider that having the firmware loaded by the OS is a cost cutting measure in most cases, the chances of support for user keys become nill.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 13:14 UTC (Sat)
                               by <b>Limdi</b> (guest, #100500)
                              [<a href="/Articles/646694/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; how many different USB readers do you want in your system? if everything that has firmware uploaded to it had it's own reader, that would add to a lot of readers</font><br>
<p>
Choose to embedd differing keys from vendors everywhere where any of these can choose to disable signed keys or choose not to sign firmware for certain versions.<br>
<p>
Or add for every device that would need keys a reading system.<br>
<p>
Or use a central device for reading and cables(whith its required infrastructure ofc) for distribution to devices.<br>
<p>
Are there other alternatives?<br>
<p>
<font class="QuotedText">&gt; and then when you consider that having the firmware loaded by the OS is a cost cutting measure in most cases, the chances of support for user keys become nill.</font><br>
<p>
<font class="QuotedText">&gt; there's no incentive for them to go to the effort to add the capability.</font><br>
<p>
People choosing money and convenience(until now) over the freedom to control their devices is quite common I agree. Why is another story.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 22:05 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/646720/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
so you you are saying that all the different vendors who produce devices are going to somehow cooperate to share infrastructure in a system? even those who sell USB or PCI-e connected devices that have no idea what system they are going to be connected to?<br>
<p>
That's even more of a pipe dream.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 23:12 UTC (Sat)
                               by <b>Limdi</b> (guest, #100500)
                              [<a href="/Articles/646724/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no monetary incentive to try, hence it did not happen yet. I totally agree that if this does not change this will not happen.<br>
<p>
What would an alternative of yours look like where the os or a go-by attacker is not able to install a rootkit undetected and the user can still fully control his device?<br>
<p>
Do you have an alternative which has monetary incentives for device vendors and still preserves user's freedom of control what is running on a device?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 23:52 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/646725/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
firmware loading only enables a rootkit if the results of loading the firmware persist past a power cycle. If the firmware is always loaded by the OS and doesn't depend on what was loaded there before, the whole problem devolves down to "is the OS that you are booting what you think you are booting" If the firmware blobs the OS loads can be changed without the OS noticing, then the OS itself can be changed without it noticing, and you have the exact same issue either way.<br>
<p>
Firmware only becomes a "rootkit" type problem when it is stored on the device through power cycles, but can be replaced by some method. Then you can change the firmware and ti can do unexpected things in the future.<br>
<p>
But the firmware loading by the kernel is not the second category. The firmware loaded by the kernel is getting loaded because the device doesn't work without it. And the firmware need to be provided every time the system boots.<br>
<p>
If you are worried about someone tampering with the contents of your hard drive, then you need t have controls in place to check those contents. Optional signing of the firmware by the build system to say that this kernel knows that this firmware is what the operator of the build system provided is a very legitimate thing to do. You just need to recognize that the signature says "this is the firmware provided by the build systems" not "this is safe firmware to use". There is a subtle, but very important difference between these two.<br>
<p>
<p>
Now, If you are worried about someone tampering with the firmware of devices in your system that store their firmware on the device across reboots, then you have a MUCH more significant problem to deal with. I believe that this problem is unsolvable as a general problem for anyone short of a megacorp [1] or First-World State (if they can even manage it). How can you be sure that the hard drive or network card that you received wasn't tampered with at the factory (either due to hostile government action or just malware getting into the factory system, we've seen enough USB drives shipped with malware on them to know this isn't a false fear). In these cases even signing doesn't hemp much because you have to trust that the people who signed things did so appropriately, and you have very little ability to figure out if the device is really behaving the way that it should. In fact, having the device enforce signatures just means that it's impossible for you to replace what the manufacturer says to trust with something that you decide to trust.<br>
<p>
<p>
And if this is the threat that you are worried about, what keeps the hostile party from tampering with the list of signatures, or the signature checking/reporting code in your system so make you thin everything is good even while they have their own version of thigns in place?<br>
<p>
It really is turtles for such a huge depth that it's "all the way down" for all practical purposes. You have to accept the fact that there are some things you can't verify and if you care enough, you setup additional layers of protection (firewalls, faraday cages, etc) to limit the damage that the stuff you can't verify can do.<br>
<p>
[1] Google, who has systems manufactured to their specs to run their firmware _may_ be big enough to be safe from these threats in their datacenter, but they use normal' laptops, etc for their employees, so they are only somewhat protected by this. And even with their level of customization, I have doubts that they muck with the firmware on their hard drives.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 31, 2015 15:25 UTC (Sun)
                               by <b>Limdi</b> (guest, #100500)
                              [<a href="/Articles/646752/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; firmware loading only enables a rootkit if the results of loading the firmware persist past a power cycle. If the firmware is always loaded by the OS and doesn't depend on what was loaded there before, the whole problem devolves down to "is the OS that you are booting what you think you are booting" If the firmware blobs the OS loads can be changed without the OS noticing, then the OS itself can be changed without it noticing, and you have the exact same issue either way.</font><br>
<p>
<font class="QuotedText">&gt; Firmware only becomes a "rootkit" type problem when it is stored on the device through power cycles, but can be replaced by some method. Then you can change the firmware and ti can do unexpected things in the future.</font><br>
<p>
<font class="QuotedText">&gt; But the firmware loading by the kernel is not the second category. The firmware loaded by the kernel is getting loaded because the device doesn't work without it. And the firmware need to be provided every time the system boots.</font><br>
<p>
Thanks for clarification! Seems like I only had the persistent firmware in devices problem in mind while the discussion was about a build-option which would only allow firmware getting loaded which is present at build-time.<br>
<p>
I agree with the reasoning for the build option.<br>
<p>
<font class="QuotedText">&gt; If you are worried about someone tampering with the contents of your hard drive, then you need t have controls in place to check those contents. Optional signing of the firmware by the build system to say that this kernel knows that this firmware is what the operator of the build system provided is a very legitimate thing to do. You just need to recognize that the signature says "this is the firmware provided by the build systems" not "this is safe firmware to use". There is a subtle, but very important difference between these two.</font><br>
<p>
<font class="QuotedText">&gt; Now, If you are worried about someone tampering with the firmware of devices in your system that store their firmware on the device across reboots, then you have a MUCH more significant problem to deal with. I believe that this problem is unsolvable as a general problem for anyone short of a megacorp [1] or First-World State (if they can even manage it). How can you be sure that the hard drive or network card that you received wasn't tampered with at the factory (either due to hostile government action or just malware getting into the factory system, we've seen enough USB drives shipped with malware on them to know this isn't a false fear). In these cases even signing doesn't hemp much because you have to trust that the people who signed things did so appropriately, and you have very little ability to figure out if the device is really behaving the way that it should.</font><br>
<p>
<p>
<p>
<font class="QuotedText">&gt; In fact, having the device enforce signatures just means that it's impossible for you to replace what the manufacturer says to trust with something that you decide to trust.</font><br>
<p>
<font class="QuotedText">&gt; And if this is the threat that you are worried about, what keeps the hostile party from tampering with the list of signatures, or the signature checking/reporting code in your system so make you thin everything is good even while they have their own version of thigns in place?</font><br>
<p>
There came my idea "have a second line into the device" from, to give the device the hashes or the public keys(whatever one uses for verification).<br>
<p>
To disallow persistent firmware I did not sign. This way malware would would not be able to hide there after it took over the os.<br>
<p>
Hence it would be possible to replace a os harddrive with another without having to fear a persistent malware could take over the new harddrive.<br>
<p>
Now assuming above proposal would work and would have monetary incentives.<br>
<p>
There is still the os problem and the factory-bad-actor problem you are right.<br>
<p>
<font class="QuotedText">&gt; It really is turtles for such a huge depth that it's "all the way down" for all practical purposes. You have to accept the fact that there are some things you can't verify and if you care enough, you setup additional layers of protection (firewalls, faraday cages, etc) to limit the damage that the stuff you can't verify can do.</font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 31, 2015 20:21 UTC (Sun)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/646781/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  There came my idea "have a second line into the device" from, to give the device the hashes or the public keys(whatever one uses for verification).</font><br>
<p>
<font class="QuotedText">&gt; To disallow persistent firmware I did not sign. This way malware would would not be able to hide there after it took over the os.</font><br>
<p>
The problem with trying to do this on the device is the complexity and cost involved. If a manufacturer is going to have the device check firmware at all (which most don't, thus the "bad USB"scare of a few months ago), where is the incentive for them to develop, test, document, and support any signatures other than their own? After all, if you are trying to load firmware on their other than what they provide, you must be trying to do something nefarious, right? After all, you can't possibly know enough about the system to do better than the manufacturer, and there is no reason not to trust their firmware (in whatever version)<br>
<p>
Even if such a mechanism is implemented, it's going to be done differently for every single manufacturer. See the example of keys for "secure boot" on x86 systems. If they can't do it right and sanely, what makes you think the manufacturers of network cards, sound cards, video cards, USB devices, etc are going to do it right?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2015 16:40 UTC (Mon)
                               by <b>Limdi</b> (guest, #100500)
                              [<a href="/Articles/646899/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The problem with trying to do this on the device is the complexity and cost involved. If a manufacturer is going to have the device check firmware at all (which most don't, thus the "bad USB"scare of a few months ago), where is the incentive for them to develop, test, document, and support any signatures other than their own? After all, if you are trying to load firmware on their other than what they provide, you must be trying to do something nefarious, right? After all, you can't possibly know enough about the system to do better than the manufacturer, and there is no reason not to trust their firmware (in whatever version)</font><br>
<p>
Yep what costs too much and has no monetary incentive will not be implemented. Quite logic, another strategy would cost people jobs or someone else revenues.<br>
<p>
<font class="QuotedText">&gt; If they can't do it right and sanely, what makes you think the manufacturers of network cards, sound cards, video cards, USB devices, etc are going to do it right?</font><br>
<p>
History tells that it will not be done right at first(if enough will ever try anyway) I agree.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor647274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2015 11:19 UTC (Fri)
                               by <b>oldtomas</b> (guest, #72579)
                              [<a href="/Articles/647274/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; how many different USB readers do you want in your system?</font><br>
<p>
Any piece of hardware with a minimum of complexity (and a hardware capable of receiving firmware would qualify, IMHO) has a JTAG these days. So no, I think adding the possibility to manage trusted keys via JTAG doesn't look terribly costly.<br>
<p>
Of course, if the "Industry" goes together on an Enting and produces something like ACPI (shudder) or (no I won't name that one, sorry :), then it might be expensive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor646706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 17:47 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/646706/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the other hand, this would make the linux-libre project's job much simpler - instead of patching out all the blob-loading points in the kernel, all they'll need to do is force firmware signing to on and ship random bytes as the key.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor646486"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 7:40 UTC (Fri)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/646486/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about distributions who build firmware from source, how will signing work in that circumstance?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646486/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646507"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 8:51 UTC (Fri)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/646507/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Same as if you build kernel modules from source - install your signing key such that your kernel trusts it, or build a kernel doesn't enforce the restrictions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646507/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor646585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware signing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 17:16 UTC (Fri)
                               by <b>martin.langhoff</b> (subscriber, #61417)
                              [<a href="/Articles/646585/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What scenarios is this meant for? Firmware blobs and signature dbs reside in root-owned directories.<br>
<p>
Is this for trusted boot scenarios? In that case it's already possible to embed the firmware in the kernel or in a signed initrd...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
