        <!DOCTYPE html>
        <html lang="en">
        <head><title>LCA: A new approach to asynchronous I/O [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/316806/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/316193/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/316806/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>LCA: A new approach to asynchronous I/O</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 27, 2009</br>
           </div>
Asynchronous I/O has been a problematic issue for the Linux kernel for many
years.  The current implementation is difficult to use, incomplete in its
coverage, and hard to support within the kernel.  More recently, there has
been an attempt to resolve the problem with the <a
href="http://lwn.net/Articles/236206/">syslet concept</a>, wherein kernel
threads would be used to make almost any system call potentially
asynchronous.  Syslets have their own problems, though, not the least of
which being that their use can cause a user-space process to change its
process ID over time.  Work on this area has slowed, with few updates being
seen since mid-2007.
<p>
Zach Brown is still working on the asynchronous I/O problem, though; he
used his linux.conf.au talk to discuss his current approach.  The new

<a href="/Articles/316844/"><img
src="https://static.lwn.net/images/conf/lca2009/ZachBrown-sm.jpg" width=125 height=149 alt="[Zach
Brown]" border=0 align="right"></a>

"acall" interface has the potential to resolve many of the problems which
have been seen in this area, but it is early-stage work which is likely to
evolve somewhat before it is seriously considered for mainline inclusion.
<p>
One of the big challenges with asynchronous kernel operations is that the
kernel's idea of how to access task state is limited.  For the most part,
system calls expect the "<tt>current</tt>" variable to point to the relevant
task structure.  That proves to be a problem when things are running
asynchronously, and, potentially, no longer have direct access to the
originating process's state.  The current AIO interface resolves this
problem by splitting things into two phases: submission and execution.  The
submission phase has access to <tt>current</tt> and is able to block, but
the execution phase is detached from all that.  The end result is that AIO
support requires a duplicate set of system call handlers and a separate I/O
path.  That, says Zach, is "why our AIO support still sucks after ten years
of work."
<p>
The fibril or syslet idea replaces that approach with one which is
conceptually different: system call handlers remain synchronous, and kernel
threads are used to add asynchronous operation on top.  This work has taken
the form of some tricky scheduler hacks; if an operation which is meant to
be asynchronous blocks, the scheduler quickly shifts over to another thread and
returns to user space in that thread.  That allows the preservation of the
state built up to the blocking point and it avoids the cost of bringing in
a new thread if the operation never has to block.  But these benefits at
the cost of changing the calling process's ID - a change which is sure to
cause confusion.
<p>
When Zach inherited this work, he decided to take a fresh look at it with
the explicit short-term goal of making it easy to implement the POSIX AIO
specification.  Other features, such as syslets (which allow a process to
load a simple program into the kernel for asynchronous execution) can come
later if it seems like a good idea.  The end result is the "acall" API;
this code has not yet been posted to the lists for review, but it is <a
href="http://oss.oracle.com/~zab/acall/">available from Zach's web
site</a>.
<p>
With this interface, a user-space process specifies an asynchronous
operation with a structure like this:
<P>
<pre>
    struct acall_submission {
	u32 nr;
	u32 flags;
	u64 cookie;
	u64 completion_ring_pointer;
	u64 completion_pointer;
	u64 id_pointer;
	u64 args[6];
    };
</pre>
<p>
In this structure, <tt>nr</tt> identifies which system call is to be
invoked asynchronously, while <tt>args</tt> is the list of arguments to
pass to that system call.  The <tt>cookie</tt> field is a value used by the
calling program to identify the operation; it should be non-zero if it is
to be used.  The <tt>flags</tt> and various <tt>_pointer</tt> fields will
be described shortly.
<p>
To submit one or more asynchronous requests, the application will call:
<p>
<pre>
    long acall_submit(struct acall_submission **submissions,
                      unsigned long nr);
</pre>
<p>
<tt>submissions</tt> is a list of pointers to requests, and <tt>nr</tt> is
the length of that list.  The return value will be the number of operations
actually submitted.  If something goes wrong in the submission process, the
current implementation will return a value less than <tt>nr</tt>, but the
error code saying exactly what went wrong will be lost if any operations
were submitted successfully.
<p>
By default, <tt>acall_submit()</tt> will create a new kernel thread for
each submitted operation.  If the <tt>flags</tt> field for any request
contains <tt>ACALL_SUBMIT_THREAD_POOL</tt>, that request will, instead, be
submitted to a pool of waiting threads.  Those threads are specific to the
calling process, and they will only sit idle for 200ms before exiting.  So
submission to the thread pool may make sense if the application is
submitting a steady stream of asynchronous operations; otherwise the kernel
will still end up creating individual threads for each operation.  Threads
in the pool do not update their task state before each request, so they
might be behind the current state of the calling process.
<p>
If the <tt>id_pointer</tt> field is non-<tt>NULL</tt>,
<tt>acall_submit()</tt> will treat it as a pointer to an <tt>acall_id</tt>
structure:
<p>
<pre>
    struct acall_id {
	unsigned char opaque[16];
    };
</pre>
<p>
This is a special value used by the application to identify this operation
to the kernel.  Internally it looks like this:
<p>
<pre>
    struct acall_kernel_id {
	u64 cpu;
	u64 counter;
    };
</pre>
<p>
It is, essentially, a key used to look up the operation in a red/black
tree.
<p>
The <tt>completion_pointer</tt> field, instead (if non-<tt>NULL</tt>),
points to a structure like:
<p>
<pre>
    struct acall_completion {
	u64 return_code;
	u64 cookie;
    };
</pre>
<p>
The final status of the operation can be found in <tt>return_code</tt>,
while <tt>cookie</tt> is the caller-supplied cookie value.  Once that
cookie has a non-zero value, the return code will be valid.
<p>
The application can wait for the completion of specific operations with a
call to:
<p>
<pre>
    long acall_comp_pwait(struct acall_id **uids,
			  unsigned long nr,
			  struct timespec  *utime,
			  const sigset_t *sigmask,
			  size_t sigsetsize);
</pre>
<p>
The <tt>uids</tt> array contains pointers to <tt>acall_id</tt> structures
identifying the operations of interest; <tt>nr</tt> is the length of that
array.  If <tt>utime</tt> is not <tt>NULL</tt>, it points to a
<tt>timespec</tt> structure specifying how long <tt>acall_comp_pwait()</tt>
should wait before giving up.  A set of signals to be masked during the
operation can be given with <tt>sigmask</tt> and <tt>sigsetsize</tt>.  A
return value of one indicates that at least one operation actually
completed.
<p>
An application submitting vast numbers of asynchronous operations may want
to avoid making another system call to get the status of completed
operations.  Such applications can set up one or more completion rings,
into which the status of completed operations will be written.  A
completion ring looks like:
<p>
<pre>
    struct acall_completion_ring {
	uint32_t head;
	uint32_t nr;
	struct acall_completion comps[0];
    };
</pre>
<p>
Initially, <tt>head</tt> should be zero, and <tt>nr</tt> should be the real
length of the <tt>comps</tt> array.  When the kernel is ready to store the
results of an operation, it will first increment <tt>head</tt>, then put
the results into <tt>comps[head&nbsp;%&nbsp;nr]</tt>.  So a specific entry
in the ring is only valid once the <tt>cookie</tt> field becomes non-zero.
The kernel makes no attempt to avoid overwriting completion entries which
have not yet been consumed by the application; it is assumed that the
application will not submit more operations than will fit into a ring.
<p>
The actual ring to use is indicated by the <tt>completion_ring_pointer</tt>
value in the initial submission.  Among other things, that means that
different operations can go into different rings, or that the application
can switch to a differently-sized ring at any time.  In theory, it also
means that multiple processes could use the same ring, though waiting for
completion will not work properly in that case.
<p>
If the application needs to wait until the ring contains at least one valid
entry, it can call:
<p>
<pre>
    long acall_ring_pwait(struct acall_completion_ring *ring,
			  u32 tail, u32 min,
			  struct timespec  *utime,
			  const sigset_t *sigmask,
			  size_t sigsetsize);
</pre>
<p>
This call will wait until the given <tt>ring</tt> contains at least
<tt>min</tt> events since the one written at index <tt>tail</tt>.  The
<tt>utime</tt>, <tt>sigmask</tt>, and <tt>sigsetsize</tt> arguments have
the same meaning as with <tt>acall_comp_pwait()</tt>.
<p>
Finally, an outstanding operation can be canceled with:
<p>
<pre>
    long acall_cancel(struct acall_id *uid);
</pre>
<p>
Cancellation works by sending a KILL signal to the thread executing the
operation.  Depending on what was being done, that could result in partial
execution of the request.
<p>
This API is probably subject to change in a number of ways.  There is, for
example, no limit to the size of the thread pool other than the 
general limit on the number of processes.  Every request is assigned to a
thread immediately, with threads created as needed; there is no way to
queue a request until a thread becomes available in the future.  The
ability to load programs into the kernel for asynchronous execution
("syslets") could be added as well, though Zach gave the impression that he
sees syslets as a relatively low-priority feature.
<p>
Beyond the new API, this asynchronous operation implementation differs from
its predecessors in a couple of ways.  Requests will always be handed off
to threads for execution; there is no concept of executing synchronously
until something blocks.  That may increase the overhead in cases where the
request could have been satisfied without blocking, though the use of the
thread pool should minimize that cost.  But the big benefit is that the
calling process no longer changes its ID when things do block.  That
results in a more straightforward user-space API with minimal surprises -
certainly a good thing to do.
<p>
Linus was at the presentation, and seemed to think that the proposed API
was not completely unreasonable.  So it may well be that, before too long,
we'll see a version of the acall API proposed for the mainline.  And that
could lead to a proper solution to the asynchronous I/O problem at last.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Asynchronous_IO">Asynchronous I/O</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Syslets">Syslets</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#linux.conf.au-2009">linux.conf.au/2009</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/316806/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor317074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LCA: A new approach to asynchronous I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2009 3:06 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/317074/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I honestly fail to see a need for this.  In fact I bristle at the thought of this or any other "we're too cool for syscalls so lets have yet another  event ring" going in.  And Yet Another Wait mechanism that doesn't look epoll compatible.<br>
<p>
I'd rather manage my own thread pools in user space than figuring out this crazy api which essentially does the same thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/317074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor318698"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LCA: A new approach to asynchronous I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2009 21:03 UTC (Tue)
                               by <b>ddaa</b> (guest, #5338)
                              [<a href="/Articles/318698/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Seconded.

<p>According to <a href="http://mailinator.blogspot.com/2008/02/kill-myth-please-nio-is-not-faster-than.html">the mailinator blog</a>, blocking I/O wrapped in threads using <a href="http://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">NPTL</a> smokes non-blocking I/O in terms of performance. It is also fairly straightforward to implement at the application level.

<p>There are certainly reasons to implement the POSIX standard, mostly political I guess. But for pragmatic application development on operating systems that have good threading, non-blocking I/O seems like more trouble to use than it's worth.
      
          <div class="CommentReplyButton">
            <form action="/Articles/318698/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor317082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Buffered AIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2009 5:08 UTC (Thu)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/317082/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also worth reading: Jens Axboe's work on Buffered async IO:<br>
<a href="http://axboe.livejournal.com/1718.html">http://axboe.livejournal.com/1718.html</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/317082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor317156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just an in-kernel thread pool</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2009 15:41 UTC (Thu)
                               by <b>aliguori</b> (subscriber, #30636)
                              [<a href="/Articles/317156/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm skeptical of this approach because it's simply an in-kernel thread pool.  There's nothing about it that cannot be implemented today in userspace.<br>
<p>
Yes, one can argue that in the future, we could do smarter things about thread scheduling in the kernel but one could also argue that we could equally well expose those knobs down to userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/317156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor317214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LCA: A new approach to asynchronous I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2009 19:48 UTC (Thu)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/317214/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A wild curiosity question. Would syslets have avoided changing the process ID if M:N threading had been adopted? I'm thinking here that if you return on a different kernel thread via M:N threading, it can still map to the same userspace thread, whereas 1:1 mapping obviously couldn't.<br>
<p>
I remember the arguments against M:N - added complexity, it's not as optimal, etc - but should I actually not be so totally out in left-field on this, syslets + M:N might be more efficient than other AIO solutions.<br>
<p>
(Of course, if it were that simple, it would have already been done. The core kernel crew catch chaotic coding quirks like that. It follows I'm likely not just out on left-field but about to step off the edge of the world. I'll let you know if there any elephants holding it up.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/317214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor318008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2009 2:15 UTC (Thu)
                               by <b>ldo</b> (guest, #40946)
                              [<a href="/Articles/318008/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <P>Funny how every time I hear about a proposal for adding asynchronous I/O to Linux, I think about VMS. In that system, <I>all</I> time-consuming operations (I/O, getting information from another process etc) were asynchronous; the supposedly synchronous syscalls were just user-space glue that did nothing but make the asynchronous call, and then wait for it to complete before returning. So as far as the kernel was concerned, there was no synchronous/asynchronous distinction.
<P>Seems to me we keep taking baby steps in that direction while trying to avoid admitting that itÂ’s the right idea.
      
          <div class="CommentReplyButton">
            <form action="/Articles/318008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor318148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2009 14:50 UTC (Thu)
                               by <b>donbarry</b> (guest, #10485)
                              [<a href="/Articles/318148/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, it's much, much older.  Control Data mainframes of the 60s had even<br>
*system calls* made asynchronously.  The CPUs had no I/O capabilities, and<br>
one would write a system request into the first word of memory of the <br>
process.  Peripheral processors would periodically scan process memory<br>
beginnings, see the request, and set a bit to acknowledge reception.  <br>
I/O would begin, and later the word would be written to again to acknowledge<br>
completion, with a toggle bit as semaphore between PP and CPU.  <br>
Meanwhile, your faultlessly brilliant code would hopefully continue doing<br>
nuclear bomb calculations, cryptographic decrypts, or payroll, waiting <br>
for the washing-machine disks to do their deeds and the PPs to propagate<br>
their transfers back into central memory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/318148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor653979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2015 17:24 UTC (Sun)
                               by <b>trent</b> (guest, #101635)
                              [<a href="/Articles/653979/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a great comment.  In coming up with PyParallel, I spent a lot of time getting familiar with the dirty details of asynchronous I/O implementation on Windows.  The more I learned about it, the more I appreciated the correctness of the design.  That got me interested in heritage, so after consuming all the NT details I could find... I ended up buying a VAX/VMS book to learn more ("VAX/VMS: Internals and Data Structures").  The whole notion of a kernel oriented around waitable "completion" events (VMS) rather than the readiness orientation afforded by UNIX is pretty fascinating when you take a look at modern hardware and programming techniques.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/653979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2015 22:44 UTC (Thu)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/654450/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yep. A lot of Linux users are down on Windows. And they may be right about some of the user space. But the Windows NT kernel is really great. Asynchronous and a monolithic / micro-kernel hybrid depending on what makes sense where. A nice HAL for portability.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 3:49 UTC (Fri)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/654472/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not just userspace: NTFS is very slow, missing useful capabilities, and difficult to work with.  Also two words: drive letters!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 5:10 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/654474/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
NTFS is almost 25 years old and its basis has changed very little. And it actually contains features like multiple file streams (not useful now, but it was important back in the Mac OS era).<br>
<p>
Driver letters were a legacy of DOS, the original VAX allowed to address filesystem on named drives (identified by actual names, not letters).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654499"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 12:39 UTC (Fri)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/654499/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Drive letters are a bad design in general, but they're made even worse because many programs don't handle them properly.  You could say that this isn't Microsoft's fault except that it includes Windows itself.  When my son got a new computer that came pre-installed with Windows 7, I had a 2T drive I wasn't using.  He plays a lot of games with a lot of content so I wanted to install this second drive and have his home directory on that drive so all his games, etc. would have lots of space.  Yeah, no.  That never, ever worked.  Many crazy, inscrutable errors, program failures, etc. later we just created a new account for him on C:.  Now everything works fine but he has to manage his disk space carefully and the 2T drive sits there virtually unused.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654499/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654511"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 14:29 UTC (Fri)
                               by <b>trent</b> (guest, #101635)
                              [<a href="/Articles/654511/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you saying the games were expected to install somewhere under C:\Users\Joe and wouldn't work anywhere else?  I highly doubt that, but even if it was the case, you could simply use a junction to redirect the game's root folder to a location on the second drive.<br>
<p>
I'm not sure if you're saying Windows doesn't support home drives anywhere else other than C:\, too.  That's nonsense, you can customize everything.  Enterprise Windows deployments do this all the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654511/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654516"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 15:12 UTC (Fri)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/654516/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, a number of programs want to install into the user's home directory and aren't easy to install anywhere else.  Of course after you've installed each one you can go back and try to move them by hand, and hope it works.  What a hassle.  We didn't want to bother: we just wanted his home directory on a large drive and everything would install there normally, and his sister's home directory with her schoolwork etc. would be on the smaller drive but they wouldn't have to fight over disk space.  This should not require an MCSE certificate to accomplish.
<p>
Oh yes, I'm sure it's possible to put all home directories on other drives, if you're an enterprise Windows user.  Here's <a href="http://answers.microsoft.com/en-us/windows/forum/windows_7-files/win7-how-do-i-move-user-folder-to-a-different/565f16a5-e5ed-43c9-8422-4f56aebb296e?auth=1">a lovely article</a> from microsoft themselves explaining how to do it... <i>only during a clean install of Windows</i> and even then it's not something any normal person would want to undertake.  Or here's <a href="http://lifehacker.com/5467758/move-the-users-directory-in-windows-7">a LifeHacker article</a> admitting it's "quite an undertaking" and showing an "utterly flawless" method that involves booting into system recovery mode.  It's far beyond anything any normal person should have to do, and when we tried to follow one of these guides the resulting account was always dodgy and had weird quirks: files showed up in Explorer but couldn't be opened, or showed up twice, or whatever.  When we went back to a normal C: home directory all those weird issues stopped.
      
          <div class="CommentReplyButton">
            <form action="/Articles/654516/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor654571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2015 2:48 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/654571/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, there are a lot of programs that insist on being installed in c: (or at least large chunks of them)<br>
<p>
On android we see a bunch of apps that refuse to install on the sd card, same sort of mess<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor654757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2015 16:54 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/654757/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Heh. Back when I reinstalled XP on a machine, it insisted on using D: as the main drive (C: was the Fedora Core 5 install). Lots of things were unhappy with that situation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor654537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 15:26 UTC (Fri)
                               by <b>cebewee</b> (guest, #94775)
                              [<a href="/Articles/654537/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could just mount the 2TB drive as (or in) his home directory. Even in Windows, a drive does not need to be mapped to a drive letter.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor654510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 14:18 UTC (Fri)
                               by <b>trent</b> (guest, #101635)
                              [<a href="/Articles/654510/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can you cite some examples of it being slow, missing useful capabilities and being difficult to work with?<br>
<p>
The tight integration between the cache manager, I/O manager and file system driver actually makes NTFS incredibly performant when used correctly.  What works well on Linux/UNIX rarely performs well on Windows; whereas what performs best on Windows isn't even possible on UNIX.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654512"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 15:48 UTC (Fri)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/654512/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      Well, if you can't use a filesystem in a normal way but instead have create special and non-obvious patterns to use it "correctly", I'd say that's a problem with the filesystem.  But maybe that's just me.  I have absolutely no interest in writing Windows-only software so saying that "<i>what performs best on Windows isn't even possible on UNIX</i>" is <b>not</b> a selling point for Windows!  If it's not possible to do portably why would I ever do it at all?  90+% of the users of software I work on deploy it on UNIX: only a small minority use it on Windows.
<p>
Some software I work on uses standard C/C++ IO.  It stores 20+G of data in a directory hierarchy of files averaging about 50K each.  Every single aspect of this is worse on NTFS than Linux filesystems: it's slower to unpack zip files, to copy using Windows operations, to create, read, and update the files themselves.  The fact that Windows locks files while they're open means that to do atomic replacements of files you have to loop and retry in case the rename step fails, you can't replace running programs then restart them, etc.  Also every aspect of our build is slower: it's slower to clone Git repos and check out.  Compilation is slower.  Deployment is slower.
<p>
My wife and son are collaborating on writing a game using Unreal on Windows and storing it in Git.  They were both cloning from a directory on my wife's system using shared partitions (not a protocol like ssh, etc.)  That repo was constantly getting corrupted somehow and I would have to go in and fix it by making a bare copy of one of their good repos and replacing the shared one with that.  So we moved the repo to my Linux system exported with Samba, so they're both still simply using a direct shared partition path to clone from, and now it works perfectly every time.
<p>
For other missing features, NTFS has multiple ways to do things "sort of" like a simple UNIX symbolic link but nothing that is really equivalent: either they have permissions restrictions or are not transparent.  This ain't rocket science!
      
          <div class="CommentReplyButton">
            <form action="/Articles/654512/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 19:24 UTC (Fri)
                               by <b>trent</b> (guest, #101635)
                              [<a href="/Articles/654552/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, yes, but everything you've said describes UNIX biases.  There's nothing wrong with that, it's a product of your experience.  The C/UNIX stdio model will work just fine on Windows, but it will be slower than Linux, because that's not what it does best.  Keep in mind the thread we're in -- discussing the plight of poor asynchronous I/O support on Linux/UNIX.  That's an area that Windows utterly dominates, and the reasons for which can be traced back to VMS.<br>
<p>
The locking of files is an interesting one because Linux/UNIX people interpret the inability to just blow away existing file content on Windows as a deficiency.  It's actually a side-effect of a much more sophisticated and integrated cache manager, memory manager, object manager and I/O manager.  What's actually happening here behind the scenes is *exactly* what facilitates Windows' ability to achieve thread-agnostic completion-oriented asynchronous I/O irrespective of the underlying device (disk, network or other).  You pay a higher up-front cost for process startup and creation of all the underlying section objects, but allows optimal multi-threaded access once established.  You can achieve much higher performance and better hardware utilization with these facilities than you'd ever be able to on Linux/UNIX.<br>
<p>
And yeah, git feels like a dog on Windows, because it's inherently designed around UNIX I/O primitives, which are the least optimal way of doing things on Windows.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654560"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 21:24 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/654560/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Windows has nice async IO model, but the filesystem layer itself is beyond atrocious. And async model based on IRPs also causes a lot of fundamental problems - most of IO is synchronous and layering it on top of asynchronous layer causes unnecessary slowdowns. <br>
<p>
So Linux filesystem call quickly goes into the kernel and there it's quickly dispatched by the VFS layer and in most cases immediately returns the data from the metadata cache. No memory allocations or generic translation layers involved.<br>
<p>
In Windows a system call has to construct an IRP and dispatch it. It goes through intermediate layers (which can filter and/or mutilate it) and then target FS driver has to parse the request back into a usable form. It's all very generic and flexible - you can write a lot of functionality (like virus filters) in a completely generic way. <br>
<p>
Except... It's slow! The layered model was unusably slow in the NT3.5 era, so Microsoft added FastIO which short-circuited all of that layered stuff (  <a rel="nofollow" href="http://www.osronline.com/article.cfm?id=166">http://www.osronline.com/article.cfm?id=166</a> ) with a simple function pointer table. Of course, asynchronous IO was emulated using (guess it!) thread pools.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654560/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654572"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2015 2:50 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/654572/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ever tried using windows filesystems over a high-latency connection? it's horrific. There's a whole market segment that produces boxes to do MITM for the protocol and lie to each end about what's going on to make things faster.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654572/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654579"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2015 6:40 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/654579/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SMBv3 is perfectly fine over high-latency links. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654579/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor654624"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2015 19:11 UTC (Sat)
                               by <b>trent</b> (guest, #101635)
                              [<a href="/Articles/654624/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That OSR article is great, I hadn't seen it before, thanks for the link!  I definitely agree that if you can issue an I/O call without blocking, then synchronous is faster than asynchronous as you avoid a lot of overhead.  I discuss that a bit here: <a href="https://speakerdeck.com/trent/pyparallel-how-we-removed-the-gil-and-exploited-all-cores?slide=115">https://speakerdeck.com/trent/pyparallel-how-we-removed-t...</a><br>
<p>
What I would disagree with is this part:<br>
<p>
<font class="QuotedText">&gt; And async model based on IRPs also causes a lot of fundamental problems - most of IO is synchronous and layering it on top of asynchronous layer causes unnecessary slowdowns.</font><br>
<p>
The NT kernel defers that decision to device drivers.  They can decide whether or not they can complete a call synchronously or if it needs to be handled asynchronously.  It adds a lot of complexity to the driver model, but it's exactly that complexity that facilitates the superior asynchronous I/O performance.<br>
<p>
With PyParallel, I implemented support for dynamically switching between synchronous and asynchronous calls based on system load and protocol hints -- it works very well and basically gives you the best possible performance by using synchronous non-blocking calls if it won't impede concurrency, then switching to async calls as necessary.  This gives you very, very low latency when you've got a few clients connected, or very fair latency when you have many (see <a href="http://pyparallel.org">http://pyparallel.org</a>).<br>
<p>
<font class="QuotedText">&gt; So Linux filesystem call quickly goes into the kernel and there it's quickly dispatched by the VFS layer and in most cases immediately returns the data from the metadata cache. No memory allocations or generic translation layers involved.</font><br>
<p>
Well the key to being faster is always to do less, and Linux does less, so, yeah, this particular code path is probably faster if you're just dealing with memory buffers and not Irp setup/teardown (although Irps are typically re-used and allocated from lookaside lists and whatnot, amortizing the overhead).<br>
<p>
But keep in mind what we're talking about here -- the ability for Linux to do non-blocking file I/O.  Or rather, the fact that all file I/O in Linux is blocking becomes problematic in two situations: a) you've got a single-threaded event loop and use non-blocking socket I/O to achieve concurrency -- blocking for file I/O in this situation impacts your ability to serve other clients' requests, or b) you've got a pool of processes or threads doing work -- in this case you'll typically size your pool to equal ncpu, but if you've got 8 procs/threads and 8 cores and they all issue blocking I/O, you're not optimally using your hardware because there is nothing for those cores to do until the IO returns (or if they're serving network clients, all network clients associated with that process/thread's epoll set will be affected).<br>
<p>
That is where the complexity of the Windows I/O model shines -- because you can do everything asynchronously, it's much easier to a) provide much fairer service to clients (lower jitter, reduced stddev), and b) make better use of underlying hardware (either keeping all CPU cores saturated, or I/O channels saturated (depending on your application)).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654624/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654643"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2015 8:28 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/654643/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The NT kernel defers that decision to device drivers. They can decide whether or not they can complete a call synchronously or if it needs to be handled asynchronously. It adds a lot of complexity to the driver model, but it's exactly that complexity that facilitates the superior asynchronous I/O performance.</font><br>
Not really. The drivers themselves are (almost) always called using an IRP, which can be submitted in any way. If a driver needs to make a further call to another layer, then it also must create an IRP and send it to the destination. <br>
<p>
And at this point there's really little difference between synchronous and asynchronous calls (as was intended!). But synchronous calls still suffer the overhead of this generic system. It's not a large hit (Microsoft went to great lengths to speed up IRP processing), but it's there.<br>
<p>
Ultimately, there's little reason to use asynchronous processing in most cases. Pretty much the only case where it matters is network (it is often high-throughput and massively-parallel), but almost every other usual hardware is not very parallel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654643/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654645"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2015 8:37 UTC (Sun)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/654645/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Ultimately, there's little reason to use asynchronous processing in most cases. Pretty much the only case where it matters is network (it is often high-throughput and massively-parallel), but almost every other usual hardware is not very parallel.</font><br>
<p>
I am surprised that you would say that. It is only true about simple, single spinning hard disks. And those are quickly going away.<br>
<p>
SSDs work best at high queue depths and SSDs (of whichever type) are the future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654645/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor654646"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2015 8:47 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/654646/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SSDs are not very different from the classic drives, it turns out. Even fast SATA/SCSI don't have more than 1-8 hardware queues with about 32-command depth. They just execute commands very fast.<br>
<p>
NMVe are different, but we're likely to skip straight to NV-RAM which is _completely_ different again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654646/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor654548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VMS All Over Again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2015 17:29 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/654548/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; whereas what performs best on Windows isn't even possible on UNIX.</font><br>
The _only_ operation that works faster on Windows is deletion, just because it's very cheap due to NTFS design.<br>
<p>
Everything else is slow as molasses. The filesystem layer in Windows scales badly, far worse than Linux's. A directory with a million files works OK on Linux but is impossible on Windows. It's not unusual to find 1000x difference between them on metadata-heavy tests, of course in Linux's favor.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor318558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LCA: A new approach to asynchronous I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2009 11:43 UTC (Mon)
                               by <b>muwlgr</b> (guest, #35359)
                              [<a href="/Articles/318558/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This stuff strongly resembles me the "delayed evaluation" mechanism popular in some high-level non-C languages. Like, functional objects, closures, continuations (in Scheme) or promises (in E-Rights). Too bad that functions are not 1st-class objects in C so they could not be made asynchronous in unified way (by wrapping, decoration, or whatever).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/318558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
