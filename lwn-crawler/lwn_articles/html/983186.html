        <!DOCTYPE html>
        <html lang="en">
        <head><title>What became of getrandom() in the vDSO [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/983186/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/983268/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/983186/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>What became of getrandom() in the vDSO</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 25, 2024</br>
           </div>
In <a href="/Articles/980447/">the previous episode</a> of the
<tt>vgetrandom()</tt> story, Jason Donenfeld had put together a version of
the <a
href="https://man7.org/linux/man-pages/man2/getrandom.2.html"><tt>getrandom()</tt></a>
system call that ran in user space, significantly improving performance for
applications that need a lot of random data while retaining all of the
guarantees provided by the system call.  At that time, it seemed that a
consensus had built around the implementation and that it was headed toward
the mainline in that form.  A few milliseconds after that article was
posted, though, a Linus-Torvalds-shaped obstacle appeared in its path.
That obstacle has been overcome and this work has now been merged for the
6.11 kernel, but its form has changed somewhat.
<p>
Torvalds initially <a
href="/ml/all/CAHk-=wiGk+1eNy4Vk6QsEgM=Ru3jE40qrDwgq_CSKgqwLgMdRg@mail.gmail.com">rejected</a>
the idea of a vDSO implementation entirely, saying that there was no clear
use case for it.  At most, he <a
href="/ml/all/CAHk-=wh47WSNQYuSWqdu_8XeRzfpWbozzTDL6KtkGbSmLrWU4g@mail.gmail.com">said</a>,
the kernel should export a generation counter to inform user-space
random-number generators that they should reseed themselves; anything
beyond that, he said, was more than the kernel needed to provide.  After a
fair amount of back-and-forth with Donenfeld, who made the point that he
did not want to expose the internal functioning of the kernel's
random-number generator to user space, Torvalds reluctantly
<a
href="/ml/all/CAHk-=wjCmw1L42W-o=pW7_i=nJK5r0_HFQTWD_agKWGt4hE7JQ@mail.gmail.com">agreed</a>
to take another look and reconsider.
<p>
When <a
href="/ml/all/CAHk-=win2mesMNEfL-KZQ_jk1YH8N8dL9r=7XOLp28_WMazpVg@mail.gmail.com">he
came back</a> a couple of hours later, his biggest complaint centered
around the new <tt>vgetrandom_alloc()</tt> system call, which was added to
allocate the special memory needed to hold the per-thread state used by
<tt>vgetrandom()</tt>.  The ability to allocate memory that could be
dropped by the kernel if needed had been requested before, he said, and
could be useful in other settings.  But it had been made available in a
specialized form that was only suitable for <tt>vgetrandom()</tt>; that
would lead developers to misuse that system call to allocate memory for
other purposes.  "<q>And that nightmare has to be avoided</q>".
<p>
His suggestion was that <tt>vgetrandom_alloc()</tt> should go away, and
that the ability to allocate droppable memory should, instead, become just
another <a
href="https://man7.org/linux/man-pages/man2/mmap.2.html"><tt>mmap()</tt></a>
flag.  Donenfeld made that change, with the result that <tt>mmap()</tt> in
6.11 will support the <tt>MAP_DROPPABLE</tt> flag; that flag will be
mandatory for memory allocated for use with <tt>vgetrandom()</tt>.
Developers will be able to allocate droppable memory for other purposes, if
desired, without having to use a special-purpose system call.
<p>
Allocating memory was only one of the reasons to call
<tt>vgetrandom_alloc()</tt>, though; that call also informed the caller
about how much memory was needed to hold the per-thread state.  That
information is now obtained with a special call to <tt>vgetrandom()</tt>,
which retains the same prototype from previous attempts:
<p>
<pre>
    ssize_t vgetrandom(void *buffer, size_t len, unsigned int flags,
                       void *opaque_state, size_t opaque_len);
</pre>
<p>
If this function is called with the <tt>buffer</tt>, <tt>len</tt>, and
<tt>flags</tt> parameters all set to zero and <tt>opaque_len</tt> set to
<tt>~0UL</tt> then, rather than generating random data,
<tt>vgetrandom()</tt> will fill the memory pointed to by
<tt>opaque_state</tt> with this structure:
<p>
<pre>
    struct vgetrandom_opaque_params {
	__u32 size_of_opaque_state;
	__u32 mmap_prot;
	__u32 mmap_flags;
	__u32 reserved[13];
    };
</pre>
<p>
The caller can then allocate the needed memory to store the per-thread
state for as many threads as might be needed, passing the provided
<tt>mmap_prot</tt> and <tt>mmap_flags</tt> values directly to
<tt>mmap()</tt>.  It is the caller's responsibility to ensure that the
allocated memory does not cross a page boundary.
<p>
Once this memory has been allocated, user space can use
<tt>vgetrandom()</tt> as described in the previous article — essentially as
a drop-in replacement for the <tt>getrandom()</tt> system call.  This
should happen with no action needed by most developers, since it is
expected that the C libraries will handle the allocation of the state
memory and calls to the vDSO implementation.  Application developers should
get the newer, faster <tt>getrandom()</tt> for free with a library upgrade.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Random_number_generation">Security/Random number generation</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/983186/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor983382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Buried the lede</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2024 21:05 UTC (Thu)
                               by <b>eatnumber1</b> (subscriber, #136670)
                              [<a href="/Articles/983382/">Link</a>] (41 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Buried the lede here. Droppable memory would be extremely useful in some applications!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Buried the lede</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2024 21:27 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/983384/">Link</a>] (40 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would love to know more about what "droppable" means in practice!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2024 21:33 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/983385/">Link</a>] (38 responses)
      </p>
      
      </div>
      </summary>
      The previous article describes the semantics of droppable memory.  In short, it is anonymous (data) memory that can be dropped by the kernel when memory gets tight.  So, rather than writing its contents to swap, the kernel will just forget about it.  That will cause the next access to the memory to map in the zero page.  This memory can be used as a sort of cache as long as the application recognizes when it has been reset.



      
          <div class="CommentReplyButton">
            <form action="/Articles/983385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2024 22:58 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/983395/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, thank you for the summary!  Interesting…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 0:38 UTC (Fri)
                               by <b>rywang014</b> (subscriber, #167182)
                              [<a href="/Articles/983400/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How do the application know if the map is dropped, or the data it's accessing is indeed zero?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 0:55 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/983403/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Set up a variable at the start of the page and initialize it to 1. At the end of the reading, check that it's still 1.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 3:21 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/983415/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How long till the compiler writers declare any use of MAP_DROPPABLE to be UB?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 4:49 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/983421/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It already will be, unless it's behind a volatile pointer. But you should already be using volatile for any mmap pointer, unless you passed the appropriate flags to make mmap behave like malloc (at which point, you should probably just let your malloc implementation handle that detail for you, since nearly all nontrivial mallocs will use mmap in some capacity).<br>
<p>
OTOH, if it is behind volatile, it's very unlikely that compilers will fiddle with it, because the whole point of volatile is to declare a "safe space" where compilers are not allowed to assume that memory behaves sanely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 12:30 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/983457/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; the whole point of volatile is to declare a "safe space" where compilers are not allowed to assume that memory behaves sanely.</span><br>
<p>
..."sanely" in the "spherical cow" sense.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 17:02 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/983558/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wouldn't say that. The standard is quite thorough. It basically says that memory accesses to volatile objects should be treated as I/O. That means no dead store elimination, redundant load elimination, reordering, or anything else that would change the observed sequence of memory loads and stores (for the same reason that the compiler is not allowed to optimize out multiple reads or writes at the same offset in some file). Just about the only guarantee it doesn't provide is atomicity (which is of course important, if you're writing multithreaded code, but it would be unreasonable overhead for something like single-threaded mmap, if we had to constantly emit full memory barriers everywhere).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More volatile.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 19:57 UTC (Fri)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/983574/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Assuming the following object definitions:<br>
<p>
volatile int a, b;<br>
int c;<br>
<p>
and this statement:<br>
<p>
c = a + b;<br>
<p>
it's perfectly acceptable for the compiler to generate the loads accessing the values of a and b in any order. There's no sequence point inside this expression and hence, there's no ordering requirement for accces to a versus access to b. The only requirement is that all side effects happen (access a, access b, store to c) and will be completed at the end of the statement (which is a sequence point).<br>
<p>
If a and b hadn't been declared as volatile, access to either a or b or both, ie, loads from the memory holding these objects, could be omitted if the corresponding values can be determined in another way, eg, reuse something already loaded into a register at an earlier time. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More volatile.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 1:50 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/983617/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's not reordering. That's "you didn't ask for any ordering in the first place." C is not e.g. C# (which does specify that expressions are evaluated from left to right).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More volatile.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2024 14:55 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/983937/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry to be nitpicking but the compiler can only reorder evaluation of subexpressions if the order of evalutation of subexpression isn't defined. Otherwise, it must not do so. C doesn't define a subexpression evaluation order for most operators and declaring objects as volatile doesn't change that. It just demands that the number of object accesses at runtime must be same as the number of object accesses a naive translation the source code would require.<br>
<p>
To use another example, assuming<br>
<p>
volatile unsigned a;<br>
unsigned b;<br>
<p>
b = a + a;<br>
<p>
then, the generated code must actually load a twice instead of employing the arithmetically equivalent and probably faster alternative to load a once, shift the value left by one and store the result in b.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 23:00 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/983608/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW atomicity and memory barriers are orthogonal.<br>
<p>
Making volatile memory accesses relaxed-atomic would actually make some amount of sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983740"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 15:36 UTC (Sun)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/983740/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It might make some sense, but one difference between relaxed atomic and volatile is that if a volatile access is too large or not appropriately aligned (such that it cannot be executed atomically on the hardware), it will be split up into multiple accesses, and executed non-atomically.<br>
<p>
You might say volatile accesses which cannot be a compiled to a single memory operation ought to be forbidden. That is a reasonable position, but would break lots of software which is doing it.<br>
<p>
On the other hand, for a relaxed atomic in those circumstances, the compiler will add a lock around the memory accesses to ensure atomicity is retained despite the multiple operations. But note that a lock will only make it atomic w.r.t. other atomic accesses in other threads of the same process -- NOT cross process, NOT to memory mapped devices, and NOT safe w.r.t. asynchronous signal handlers.<br>
<p>
So, adding locks to currently-non-atomic volatile accesses would break anyone using it in a signal handler, and be at best useless when using volatile for it's intended purpose of communicating with hardware. So that doesn't seem like a good idea either.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983740/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor983548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 17:09 UTC (Fri)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/983548/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The only defined meaning of volatile is that accessing an object labelled as volatile is to be regarded as producing a required side effect  as opposed to only writing to an object.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983576"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 19:59 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/983576/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But that's enough to block nearly all optimizations involving memory operations. The memory operations are strongly bundled together with the required side effect, so the compiler is not allowed to disentangle them and reason separately about what the memory is doing. You could, for example, mark the memory as non-accessible and manually emulate reads and writes in the fault handler (producing and consuming the values in whatever manner you like, regardless of whether it fits the usual semantics of memory, or even makes any logical sense whatsoever), and volatile provides the necessary guarantees for such a setup.<br>
<p>
Yes, that's a stupid and non-performant thing to do, but the point is that the compiler is not allowed to meddle with it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983576/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor983428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 7:48 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/983428/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That’s kind of annoying though. You can store only 4095 usable bytes in each 4096 byte page. It would be nicer to have a way to check (without race conditions) that it’s still mapped. Or have access to a disappeared page generate some kind of signal, less severe than the normal segmentation fault, which the process can catch. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983437"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 9:18 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/983437/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Losing one byte (or bit) out of every page doesn't seem like the biggest problem. I think a bigger problem is that you can't *directly* store pointers in them to memory you don't have pointers to elsewhere. So, for instance, it'd be an interesting challenge to design a hash bucket around this that doesn't leak memory; you could use this for pointed-to values quite easily, but it'd be harder to use this for the pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983437/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983637"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 9:51 UTC (Sat)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/983637/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think losing one bit every 4k limits the usefulness a lot. Suppose you have a 100 kilobyte temporary object you want to cache (but don’t mind losing it if memory is tight). You have to carefully split it into chunks of just under 4096 bytes and reconstruct it, if you want to use the first bit of each page as a flag. <br>
<p>
You could instead check for constant zero pages, but then you can’t cache things that contain a large expanse of zeroes. <br>
<p>
And in any case you’d need to copy the memory first before you check. You can’t check first and then use it, since it might be freed meanwhile. <br>
<p>
Signals are racy, but might be the less bad option. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983637/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 8:47 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/983718/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most objects tend to not have all-zero records. It's easy enough to e.g. set up an enum to start with 1 instead of zero, thus you lose at most 1/2^8'th bit.<br>
<p>
I do wonder whether this droppable page thing shouldn't be a droppable folio instead, i.e. all-or-nothing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983754"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 19:29 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/983754/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I meant when the object does not fit in a single page. It’s a pain to make sure that every 4096th byte is nonzero, or whatever. Your suggestion of dropping a whole folio would fix this. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983754/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor983578"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 20:16 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/983578/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Signals are always going to be racy, so it's not a solution. But dropping all the mmap() allocation at once seems to be a good compromise that requires only a handful of lines of code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983578/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983609"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 23:05 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/983609/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What would be really nice is to make the first word of the droppable region be a futex and the kernel does a try-lock on the futex before dropping the memory. If the try-lock fails the memory is not dropped, otherwise the kernel drops the memory and finally drops the first page, releasing the futex and waking any waiters.<br>
<p>
That gives user-space an efficient way to avoid having to deal with "any value in memory can become zero at any time".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983609/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2024 2:46 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/983774/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can do that with MADV_FREE right now. It's moderately more work, but it is definitely possible to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2024 3:15 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/983777/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
MADV_FREE is pretty slow (because it has to grab a very hot mmap semaphore), if you have to do it often. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor983539"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 14:26 UTC (Fri)
                               by <b>IAmLiterallyABee</b> (subscriber, #144892)
                              [<a href="/Articles/983539/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Android used to have a kernel feature called ASHMEM. Similar to memfd, you get a file descriptor referring to anonymous memory.<br>
Except ASHMEM had the concept of "pinning" and unpinning. You could unpin memory, and the kernel could drop it whenever there was memory pressure. When you want to use the memory, you pin it via ioctl, and the kernel returns a flag saying if the page is still intact. While the page is pinned you can use it without fear of it disappearing beneath your feet (like I believe it could with VM_DROPPABLE)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983539/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 15:59 UTC (Fri)
                               by <b>KJ7RRV</b> (guest, #153595)
                              [<a href="/Articles/983552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is, or at least used to be, possible to use ASHMEM on regular Linux too; Waydroid (<a href="https://lwn.net/Articles/901459/">https://lwn.net/Articles/901459/</a>) required it in the past.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 1:01 UTC (Fri)
                               by <b>ms-tg</b> (subscriber, #89231)
                              [<a href="/Articles/983405/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry if this obvious but just to make sure I understand: the user space caller is obligated to detect that the droppable memory has been dropped and the zero page mapped in.<br>
<p>
In practice, what does this look like? Every allocated structure in droppable memory must have a test bit, which is 1 unless the kernel has dropped the memory? And at the beginning of every block of code which access the structure, one must check that bit, and re-initialize if the bit is zero?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 1:02 UTC (Fri)
                               by <b>ms-tg</b> (subscriber, #89231)
                              [<a href="/Articles/983406/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Never mind, I see you responded above that one must check for the 1 and both the beginning and end of an interaction with the memory, or else presumably retry after re-initializing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 4:53 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/983422/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Technically, checking at the beginning is both unnecessary and unhelpful, because you still race with the drop. Your thread can get preempted at any time, and the memory paged out from under you, even after you have checked that the memory is valid (but before you have finished consuming it). You just have to write robust code and check for failure at the end.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983424"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 5:35 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/983424/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The grandparent probably meant that checking at the beginning is a nice optimization, so you won't waste time trying to read a zero page.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983424/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 8:25 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/983431/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or you temporarily mark it as in-droppable before you use it and put it back when you’re done. The kernel could provide a kind of handle which indicates you will reference a certain range of memory. The pages in that range can’t be dropped while the handle is held, even if they are marked droppable. Later you release the handle. This wouldn’t help much for random number generation (where the aim is to have close to zero system calls) but it would be a race-free way for applications to use “cache” memory for other purposes. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983467"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 13:00 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/983467/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In practice, what does this look like? Every allocated structure in droppable memory must have a test bit, which is 1 unless the kernel has dropped the memory?</span><br>
<p>
THINK OUTSIDE THE BOX!<br>
<p>
Didn't it say, if the memory gets dropped, it gets replaced by an all-zeros page on the next access?<br>
<p>
So while you're parsing the memory, if you get an unexpected zero the memory has been dropped.<br>
<p>
If there's an area of memory that cannot be 0s, just check when you've finished that it's still non-zero. Provided you know, that somewhere in that region, there's an area that must have valid data (a version structure for example), just check that that data is still there.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983467/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor983445"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 10:53 UTC (Fri)
                               by <b>fweimer</b> (guest, #111581)
                              [<a href="/Articles/983445/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still quite don't see how this is different from MADV_FREE. Is the difference that it's sticky and is preserved after writes? MADV_FREE memory reverts to regular memory upon write.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983445/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 11:13 UTC (Fri)
                               by <b>david.hildenbrand</b> (subscriber, #108299)
                              [<a href="/Articles/983448/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, it's sticky. After re-dirtying the page (IOW writing to it) you won't have to call MADV_FREE again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 11:31 UTC (Fri)
                               by <b>fweimer</b> (guest, #111581)
                              [<a href="/Articles/983450/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And VM_DROPPABLE is not? If it's sticky as well, I really don't see the difference …<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 13:11 UTC (Fri)
                               by <b>barryascott</b> (subscriber, #80640)
                              [<a href="/Articles/983470/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And VM_DROPPABLE is not? If it's sticky as well, I really don't see the difference …</span><br>
<p>
The advantage is that the kernel can reclaim the memory when it’s under memory pressure.<br>
The page does not need to be written to backing store swap etc.<br>
So the reclaim is instant.<br>
<p>
Any cached data will just be recached when the app detects the cache is zeroed.<br>
<p>
For the vgetrandom use case the kernel drops the page anytime the slow path must be used to get random data.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory vs MADV_FREE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 13:18 UTC (Fri)
                               by <b>fweimer</b> (guest, #111581)
                              [<a href="/Articles/983475/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still don't get how this is different from MADV_FREE. As far as I know, it has all the same properties.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory vs MADV_FREE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 13:32 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/983483/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Droppable memory can be dropped at any time. <tt>MADV_FREE</tt>d memory can be dropped up until the next time the page is written to; writing to a page cancels out the effect of <tt>MADV_FREE</tt>.
<p>Semantically, droppable memory is the same as calling <tt>MADV_FREE</tt> on a page after every write to that page, but without the overhead of a syscall after each write.


      
          <div class="CommentReplyButton">
            <form action="/Articles/983483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983527"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Droppable memory vs MADV_FREE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 13:58 UTC (Fri)
                               by <b>fweimer</b> (guest, #111581)
                              [<a href="/Articles/983527/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Got it now, thanks. My initial question confused me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983527/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor985758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Buried the lede</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2024 7:44 UTC (Thu)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/985758/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It means userspace memory that the kernel may replace by losing data, like clean page cache pages. This could be useful in e.g. userspace caches of remote cluster resources, which might more efficiently ride the kernel's replacement policy for the latter's privileged access to page table a/d bits and doing better system-wide replacement already. Unilateral zeroing can be detected by storing the position of the last nonzero byte and checking it nonzero after copying out.<br>
<p>
It'd also be an architectural mistake to use kernel replacement in this way for anything that's more expensive to recompute than, or shaped differently from, block data. Preemption would further limit such a feature's usage to VMs, databases, and other system software that caches raw storage under a non-POSIX abstraction.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/985758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Sentinel location</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2024 22:48 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/983394/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It'd be nice if it were possible to associate a location with a set of pages, so that location is zeroed out if any of the pages is dropped.<br>
<p>
This will make it easy to detect if any of the cached data is invalidated. It's possible with the current semantics, but you have to put a sentinel into each page. Not optimal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Sentinel location</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 0:08 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/983399/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One way to solve that would be a flag for "if you want to drop any of these pages, you must drop the first page".<br>
<p>
That said, for most applications I want to use this for, I don't want it to be all-or-nothing, and it doesn't seem like too much of an imposition to have a flag in each page.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Sentinel location</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 0:46 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/983402/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's actually a pretty good solution. And apps can create multiple mappings, so it's not such a big limitation. But it'll allow caching of objects that are larger than the page size.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Sentinel location</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 3:31 UTC (Fri)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/983416/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't "not all-or-nothing" the same as multiple droppable allocations?  I guess the latter doesn't guarantee contiguity, but maybe that's the price you pay to get granular droppability.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">use case?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 3:03 UTC (Fri)
                               by <b>lwnuser573</b> (subscriber, #134940)
                              [<a href="/Articles/983413/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did we discover the use case(s) for the really high speed random?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983438"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">use case?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 9:21 UTC (Fri)
                               by <b>LondonPrentice</b> (guest, #172410)
                              [<a href="/Articles/983438/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The use case is to prevent C libraries (specifically the GNU one) from implementing an another random number generator in the user space just because someone might complain that 'but getrandom is too slow'.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983438/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">use case?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 10:14 UTC (Fri)
                               by <b>fishface60</b> (subscriber, #88700)
                              [<a href="/Articles/983439/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From my reading of the discussion I don't remember exactly which use-cases require frequently calculating random numbers, but the existence of a range of high performance userland random number generators implies the use-case exists.<br>
<p>
The need for kernel intervention is that the kernel is best positioned to know when it has been hibernated or is a resumed VM snapshot, and communicating this to userland is tricky (and I think attempts to get an interface for this merged met resistance).<br>
<p>
I think one of the reasons why the original had its own special mmap interface was so that the page could be dropped for any future circumstances where you'd want to reset random number generation too, which is distinct from just being safe to drop, but Linus objected because people would misuse it for droppable mmaps in the absence of that feature being merged, so it was reworked to depend on that feature instead.<br>
<p>
This potentially leaves it with an inconvenient API that conflates "it's safe to drop this" with "I want you to drop this when the random number generator must be reseeded" but I suppose it's working on the assumption that every time random numbers must be reseeded is also a good opportunity to drop nonessential memory.<br>
<p>
As for why it has to be getrandom(), I think the argument is that while userspace RNGs could make use of the droppable mmap to identify when to reseed it's apparently asking a lot for every RNG implementation to get that right, and the kernel can evolve when it needs to know when to reseed independently, and there's apparently interest in having something able to use the same algorithm as the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983615"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">use case?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 0:49 UTC (Sat)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/983615/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The use case is any application that needs cryptographic random number generator. But can’t they seed a CPRNG once and use that? Normally they could except in case of virtual machine cloning and migrations where two copies of the process could end up with the same random state. vDSO getrandom guarantees that the application reseeds the CPRNG whenever this happens.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983615/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983619"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">use case?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 2:42 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/983619/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For example, we're using hash maps with random seeds to make sure they can't be used for a DDoS. We need almost a million seeds per second for some cases, and the syscall overhead is significant. So we have a userspace RNG, seeded with the kernel's entropy source. With this patch, we'll be able to remove all of it and just use the regular libc for random numbers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983619/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor983436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Een bussie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 9:13 UTC (Fri)
                               by <b>LondonPrentice</b> (guest, #172410)
                              [<a href="/Articles/983436/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; A few milliseconds after that article was posted, though, a Linus-Torvalds-shaped obstacle appeared in its path. That obstacle has been overcome and this work has now been merged for the 6.11 kernel, but its form has changed somewhat.</span><br>
<p>
Where is that bus everybody is talking about?<br>
<p>
Because an absurd overloading of the 'vgetrandom' system call with some special semantics doesn't strike me as an improvement over a dedicated system call for the same purpose. It's the reverse.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983482"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Politeness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 13:29 UTC (Fri)
                               by <b>daroc</b> (editor, #160859)
                              [<a href="/Articles/983482/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think joking about the death of an open-source maintainer (the bus from a project's "bus factor") is something we want to encourage in the LWN comments. Discussing the potential problems with a project's leadership structure is on topic, joking about their deaths is not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983482/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983588"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Politeness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 21:02 UTC (Fri)
                               by <b>LondonPrentice</b> (guest, #172410)
                              [<a href="/Articles/983588/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Discussing the potential problems with a project's leadership structure is on topic, joking about their deaths is not.</span><br>
<p>
I just think Torvalds should just trust his maintainers more. Because the whole situation felt like less competent superior lecturing a subordinate who has much more expertise than him. And Donenfeld is not some random person that got into the Linux development just because of his enthusiasm, he's somebody who was apparently the sole person that realised how much half-baked idea 'arc4random' was and prevented its inclusion (in its original form, unfortunately not completely) in glibc at the last minute!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983588/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor983485"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 13:37 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/983485/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <tt>vgetrandom()</tt> has been overloaded with a special mode that tells callers how to use <tt>vgetrandom()</tt>.  It's mildly strange but is quite focused.
<p>
<tt>vgetrandom_alloc()</tt> was a special-purpose memory-allocation system call that had a high potential to be used in unintended ways.  It is not the same thing at all.  Moving the memory allocation back into <tt>mmap()</tt>, which is how processes allocate memory in general, makes a lot more sense.


      
          <div class="CommentReplyButton">
            <form action="/Articles/983485/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983586"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 20:48 UTC (Fri)
                               by <b>LondonPrentice</b> (guest, #172410)
                              [<a href="/Articles/983586/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It is not the same thing at all.</span><br>
<p>
Oh, right, I've just re-read the article more closely, and it is way worse. Instead of allocating the memory itself, the call just... returns the parameters that you have to call 'mmap' with. I guess somebody read 'teach man how to fish' and got wrong conclusions from that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983586/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2024 10:24 UTC (Mon)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/983786/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not sure what you mean here. When you have a function that does some computation and writes to an output buffer, it is a very common technique to have a special mode that means "don't do the actual computation, just tell me how big the output buffer needs to be".  There is no point bloating the API with a separate function to query the buffer size, and because almost all of the parameters are going to be the same between the two calls it is fairly robust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983562"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Een bussie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 17:19 UTC (Fri)
                               by <b>brchrisman</b> (subscriber, #71769)
                              [<a href="/Articles/983562/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the comment played on the joke in the article and meant "It's an inanimate object in the shape of a person.... we need a bus to remove it."  I don't think the comment intended to suggest harm to a person.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983562/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor983962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">glibc patch posted</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2024 14:55 UTC (Tue)
                               by <b>zx2c4</b> (subscriber, #82519)
                              [<a href="/Articles/983962/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
v1: <a href="https://inbox.sourceware.org/libc-alpha/20240730132440.1181819-1-Jason@zx2c4.com/">https://inbox.sourceware.org/libc-alpha/20240730132440.11...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
