        <!DOCTYPE html>
        <html lang="en">
        <head><title>Notes from the Intelpocalypse [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/742702/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/742058/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/742702/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Notes from the Intelpocalypse</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 4, 2018</br>
           </div>
Rumors of an undisclosed CPU security issue have been circulating since
before LWN first <a href="/Articles/738975/">covered</a> the kernel
page-table isolation patch set in November 2017.  Now, finally, <a
href="https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html">the
information is out</a> — and the problem is even worse than had been
expected. Read on for a summary of these issues and what has to be
done to respond to them in the kernel.
<p>
All three disclosed vulnerabilities take advantage of the CPU's speculative
execution mechanism.  In a simple view, a CPU is a deterministic machine
executing a set of instructions in sequence in a predictable manner.
Real-world CPUs are more complex, and that complexity has opened the door
to some unpleasant attacks.
<p>
A CPU is typically working on the execution of multiple instructions at
once, for performance reasons.  Executing instructions in parallel allows
the processor to keep more of its subunits busy at once, which speeds
things up.  But parallel execution is also driven by the slowness of access
to main memory.  A cache miss requiring a fetch from RAM can stall the
execution of an instruction for hundreds of processor cycles, with a clear
impact on performance.  To minimize the amount of time it spends waiting
for data, the CPU will, to the extent it can, execute instructions
<i>after</i> the stalled one, essentially reordering the code in the
program.  That reordering is often invisible, but it occasionally leads to
the sort of fun that caused <a
href="http://elixir.free-electrons.com/linux/latest/source/Documentation/memory-barriers.txt">Documentation/memory-barriers.txt</a>
to be written.
<p>
Out-of-order execution runs into a challenge whenever the code branches,
though.  The processor may not yet be able to tell which branch will be
taken, so it doesn't know where to go to execute ahead of the stalled
instruction(s).  The answer here is "branch prediction".  The processor
will make a guess based on past experience with the branch in question and,
possibly, explicit guidance from the code (the <tt>unlikely()</tt>
directive used in kernel code, for example).  Once the actual branch
condition can be evaluated, the processor will determine whether it guessed
right.  If not, the "speculatively" executed instructions after the branch
will be unwound, and everything will proceed as if they had never been run.
<p>
A branch-prediction failure should really only lead to slower execution,
with no visible side effects.  That turns out to not be the case, though,
leading to a set of severe information-disclosure vulnerabilities.  In
particular, speculative instruction execution can cause data to be loaded
into the CPU memory cache; timing attacks can then be used to learn which
instructions were executed.  If speculative execution of kernel code can be
controlled by 
an attacker, the contents of the cache can be used as a covert channel to
get data out of the kernel.

<p>
<h4>Getting around boundary checks</h4>
<p>
Perhaps the nastiest of the vulnerabilities, in terms of the cost of
defending against them, allows the circumvention of normal boundary checks
in the kernel.  Imagine kernel code that looks like this:
<p>
<pre>
    if (offset &lt; array1-&gt;length) {
        unsigned char value = array1-&gt;data[offset];
      	unsigned long index = ((value&amp;1)*0x100)+0x200;
      	if (index &lt; array2-&gt;length) // length is &lt; 0x300
            unsigned char value2 = array2-&gt;data[index];
     }
</pre>
<p>
If <tt>offset</tt> is greater than the length of <tt>array1</tt>, the
reference into <tt>array1-&gt;data</tt> should never happen.  But if
<tt>array1-&gt;length</tt> is not cached, the processor will stall on the
test.  It may, while waiting, predict that <tt>offset</tt> is within bounds
(since it almost always is) and execute forward far enough to at least
begin the fetch of the value from <tt>array2</tt>.  Once it's clear that
<tt>offset</tt> is too large, all of that speculatively done work will be
discarded.
<p>
Except that <tt>array2-&gt;data[index]</tt> will be present in the CPU
cache.  An exploit can fetch the data at both <tt>0x200</tt> and
<tt>0x300</tt> and compare the timings.  If one is far faster than the
other, then the faster one was cached.  That means that the inner branch
was speculatively executed and that, in particular, the lowest bit of
<tt>value</tt> was not set.  That leaks one bit of kernel memory under attacker
control; a more sophisticated approach could, of course, obtain more than a
lowest-order bit.
<p>
If a code pattern like the above exists in the kernel and <tt>offset</tt>
is under user-space control, this kind of attack can be used to leak
arbitrary data from the kernel to a user-space attacker.  It would seem
that such patterns exist, and that they can be used to read out kernel data
at a relatively high rate.  It is also possible to create the needed
pattern with a BPF program — some types of which can be loaded and run
without privilege.  The attack is tricky to carry out, requires
careful preparation of the CPU cache, and is processor-dependent, but it
can be done.  Intel, AMD, and ARM processors are all vulnerable (in varying
degrees) to this
attack. 
<p>
There is no straightforward defense to this attack, and nothing has been
merged to date.  The only known
technique, it would seem, is to prevent speculative execution of code
within branches when the branch condition is under an attacker's control.
That requires putting in a barrier after every test that is potentially
vulnerable.  Some <a href="/Articles/742754/">preliminary patches</a> have
been posted to add a new API for sensitive pointer references:
<p>
<pre>
    value = nospec_load(pointer, lower, upper);
</pre>
<p>
This macro will return the value pointed to by <tt>pointer</tt>, but only
if it falls within the given <tt>lower</tt> and <tt>upper</tt> bounds;
otherwise zero is returned.  There are a number of variants on this macro;
see <a href="/Articles/742757/">the documentation</a> for the full set.

This approach is problematic on a couple of counts: it hurts performance,
and somebody has to <i>find</i> the vulnerable code patterns in the first
place.  Current vulnerabilities may be fixed, but there can be no doubt
that new vulnerabilities of this type will be introduced on a regular basis.
<p>

<h4>Messing with indirect jumps</h4>
<p>
The kernel uses indirect jumps (calling a function through a pointer, for
example) frequently.  Branch prediction for indirect jumps uses cached
results in a separate buffer that only keys on 31&nbsp;bits of the address
of interest.  The resulting aliasing can be exploited to poison this cache
and cause speculative execution to jump to the wrong location.
Once again, the CPU will figure out that it
got things wrong and unwind the results of the bad jump, but that
speculative execution will leave traces in the memory cache.  This issue
can be exploited to cause the speculative execution of arbitrary code that
will, once again, allow the exfiltration of data from the kernel.
<p>
One rather frightening aspect of this vulnerability is that an attacker
running inside a virtualized
guest can use it to leak data accessible to the hypervisor — all the data
in the host system, in other words.
That has all kinds of highly unpleasant implications for cloud providers.
One can only hope that those providers have taken advantage of whatever
early disclosure they got to update their systems.

<p>

There are two possible defenses in this case.  One would be a
microcode update from Intel that fixes the issue, for some
processors at least.  In the absence of this update, indirect calls must be
replaced by a <a href="/Articles/742756/">two-stage trampoline</a> that
will block further speculative execution.  The performance cost of the
trampoline will be notable, which is why Linus Torvalds has <a
href="/Articles/742764/">complained</a> that the current patches seem to
assume that the CPUs will never be fixed.  There is a set of GCC patches
forthcoming to 
add a flag (<tt>-mindirect-branch=thunk-extern</tt>) to automatically
generate the trampolines in cases where that's necessary.
As of this writing, no defenses have actually been merged into the mainline
kernel. 
<p>

<h4>Forcing direct cache loads</h4>
<p>
The final vulnerability runs entirely in user space, without the
involvement of the kernel at all.  Imagine a variant of the above code:
<p>
<pre>
    if (slow_condition) {
        unsigned char value = kernel_data[offset];
      	unsigned long index = ((value&amp;1)*0x100)+0x200;
      	if (index &lt; length) 
            unsigned char value2 = array[index];
     }
</pre>
<p>
Here, <tt>kernel_data</tt> is a kernel-space pointer that should be
entirely inaccessible to a user-space program.  The same
speculative-execution issues, though, may cause the body of the outer
<tt>if</tt> block (and possibly the inner block if the low bit of
<tt>value</tt> is clear) to be executed on a
speculative basis.  By checking
access timings, an attacker can determine the value of one bit of
<tt>kernel_data[offset]</tt>.  Of course, the attacker needs to find a
useful kernel pointer in the first place, but a variant of this attack can
be used to find the placement of the kernel in virtual memory.
<p>
The answer here is <a href="/Articles/741878/">kernel page-table
isolation</a>, making the kernel-space 
data completely invisible to user space so that it cannot be used in
speculative execution.  This is the only one of the three issues that is
addressed by page-table isolation; it alone imposes a performance cost of
5-30% or so.  Intel and ARM processors seem to be vulnerable to this issue;
AMD processors evidently are not.
<p>
<h4>The end result</h4>
<p>
What emerges is a picture of unintended processor functionality that can be
exploited to leak arbitrary information from the kernel, and perhaps from
other guests in a virtualized setting.  If these vulnerabilities are
already known to some attackers, they could have been using them to attack
cloud providers for some time now.  It seems fair to say that this is one
of the most severe vulnerabilities to surface in some time.
<p>

The fact that it is based in hardware makes things significantly worse.  We
will all be paying the performance penalties associated with working around
these problems for the indefinite future.  For the owners of vast numbers
of systems that cannot be updated, the consequences will be worse: they
will remain vulnerable to
a set of vulnerabilities with known exploits.  This is not a happy time for
the computing industry.
<p>

It is, to put it lightly, unlikely that this is the last vulnerability
hiding within the processors at the heart of our systems.  Like the Linux
kernel, these processors are highly complex devices that are subject to
constant change.  And like the kernel, they probably have a number of
unpleasant issues lurking within them.  Given that, it's worthwhile to look
at how these vulnerabilities were handled; there seems to be some
unhappiness on that topic which might affect how future issues are
disclosed.  It's important to get this right, since we'll almost certainly
be doing it again.
<p>
See also: the <a href="https://spectreattack.com/">Meltdown and Spectre
attacks page</a>, which has a detailed and academic look at these
vulnerabilities.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Meltdown_and_Spectre">Security/Meltdown and Spectre</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Hardware_vulnerabilities">Hardware vulnerabilities</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Meltdown_and_Spectre">Meltdown and Spectre</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/742702/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor742783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 0:53 UTC (Thu)
                               by <b>vbabka</b> (subscriber, #91706)
                              [<a href="/Articles/742783/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Such a detailed and spot-on writeup within few hours from disclosure. Great job, Jon!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 14:57 UTC (Thu)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/742900/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm awed at this. Jon is superhuman. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 1:28 UTC (Wed)
                               by <b>ThinkRob</b> (guest, #64513)
                              [<a href="/Articles/743781/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the many examples that our subs support a vanishingly rare resource nowadays: actual journalism.<br>
<p>
Seriously, well done LWN!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor742794"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 2:30 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/742794/">Link</a>] (50 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Intel and ARM processors seem to be vulnerable to this issue; AMD processors evidently are not.</font><br>
<p>
ARM's information at <a href="https://developer.arm.com/support/security-update">https://developer.arm.com/support/security-update</a> says the Meltdown issue ("variant 3") only affects Cortex-A75 (which is very new - I'm not sure it's in any shipping devices yet). Some more common ones (A15/A57/A72) are affected by "variant 3a", where you speculatively read a supposedly-inaccessible system register instead of memory, which is a less serious problem since system registers don't contain as much sensitive information as memory. I think that means most Android phone users don't need to worry much about it.<br>
<p>
(But it looks like all the out-of-order ARMs are vulnerable to Spectre.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742794/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742804"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 3:15 UTC (Thu)
                               by <b>ariagolliver</b> (subscriber, #85520)
                              [<a href="/Articles/742804/">Link</a>] (49 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't all out-of-order chips are vulnerable to Spectre? I'd be interested to read how speculation and caching could coexist on the same chip without it being vulnerable to some kind of side-channel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742804/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742806"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 3:25 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/742806/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you'd have to leave enough cache empty to satisfy likely ongoing speculation, evict material read into the cache to satisfy speculation iff the speculation fails, and *not* evict anything merely to free up cache to satisfy speculations (i.e. evict at retirement time, to keep a bit of space free).<br>
<p>
Definitely a major change from the way caches work internally now, but not in any way impossible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742806/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 7:53 UTC (Thu)
                               by <b>kentonv</b> (subscriber, #92073)
                              [<a href="/Articles/742835/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As noted in the paper, cache effects are not the only side effect of speculative execution. Other effects, like the amount of time spent speculating, seem difficult to hide...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742870"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 11:36 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/742870/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I just babbled about possible high-res-timer-related mitigations here: &lt;<a href="https://lwn.net/Articles/742867/">https://lwn.net/Articles/742867/</a>&gt;. All a bit painful (and with user-visible consequences if you actually *need* accurate high-res times many times a second) but a lot less painful than the reported KPTI slowdown, ISTM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742870/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 19:40 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/743033/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It won't work, unless you also disable multi-threading totally. You can cobble up a high-resolution timer by having one thread do N writes to a buffer and the other thread observing a value at a fixed offset within this buffer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 20:19 UTC (Thu)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/743040/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you have enough time to perform the attack, it won't work period.  Even if I'm only allowed a very low resolution timer, I can compensate by performing lots of operations and running some statistics.<br>
<p>
(In addition to being extremely well known for crypto timing attacks, it's how LIGO can measure 1/1000th of the width of a proton.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 20:37 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/743050/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Performing lots of operations and running some statistics" probably slows the attack from a 500KiB/s flood down to a trickle, though. It seems a useful amelioration, at least.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 21:44 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743069/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But the multithreading approach Cyberax noted is a showstopper. Note that it also works with multiple single-threaded processes that share memory. It could even be made to work without shared memory, just with one process writing a counter to a file and another process reading it.<br>
<p>
Even if you think you can fix all those (I don't see how), it's difficult to be confident people aren't going to come up with new ways to estimate time. And each mitigation you introduce degrades the user experience.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:55 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/743082/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another one I've heard is to submit an asynchronous disk request and time its completion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 17:26 UTC (Fri)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/743257/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
One important observation with covert channels is that in general, covert channels cannot be removed completely. Insisting that a system be 100% free of all conceivable covert channels is therefore not reasonable.
</p>
<p>
People doing security evaluations are usually satisfied when the covert channels that do inevitably exist provide such little bandwidth that they are, in practice, no longer useful to attackers.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/743257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor742818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 5:22 UTC (Thu)
                               by <b>jimzhong</b> (subscriber, #112928)
                              [<a href="/Articles/742818/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think one way is to redesign branch prediction so that when a misprediction occurs, in addition to flushing instructions in the mispredicted branch, the cache is also restored to the state before taking the branch. But this fix might be expensive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 5:37 UTC (Thu)
                               by <b>sfeam</b> (subscriber, #2841)
                              [<a href="/Articles/742819/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      That might narrow the timing window but I don't think it would be sufficient to prevent the attack. The analysis of Spectre shows that hundreds of instructions may be executed speculatively before the misprediction is recognized, so snooping on the cache contents would still be possible during that interval. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/742819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742827"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 7:22 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/742827/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And so the ways to snoop on the cache contents should be curtailed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742827/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742890"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 14:15 UTC (Thu)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/742890/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, I wonder about the possibility of separate speculative caches. Sounds terribly expensive, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742890/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 21:50 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743074/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The only reasonable and watertight way to do that that I can think of is to partition the cache by protection domain. So cache lines would have owners: the kernel, specific user-space processes, and even within processes you'd want separate cache lines for JS vs the browser. A cache lookup would have to find a line owned by the current protection domain; if it did not, that has to be treated as a miss, and you would only be allowed to evict cache lines owned by  the current domain.<br>
<p>
It would hurt performance but what else would really work?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:28 UTC (Thu)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/743087/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds like a fix that would destroy cache effectiveness, you'd probably also enable a DOS attack that causes the cache to be partitioned until there isn't any cache left and things start locking up. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:40 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743090/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are probably ways to avoid lockup. I agree the performance impact would be bad. But what else really works?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 1:46 UTC (Fri)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/743134/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And we all thought heart-bleed was the worst thing ever, kinda pales in comparison to this. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:51 UTC (Thu)
                               by <b>sfeam</b> (subscriber, #2841)
                              [<a href="/Articles/743088/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      It's worse than you think. The use of cache as a side-channel was convenient for the proof-of-concept exploits but was not necessary. Mitigation that focuses on the cache rather than the speculative execution of invalid code is necessarily incomplete. The Spectre report notes: <i>potential countermeasures limited to the memoryu cache are likely to be insufficient, since there are other ways that that speculative execution can leak information. For example, timing effects  from memory bus contention, DRAM row address selection status, availability of virtual registers, ALU activity, [...] power and EM.</i>
      
          <div class="CommentReplyButton">
            <form action="/Articles/743088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:00 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743100/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I read the paper. Just addressing the cache question since it was raised.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor743097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:57 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/743097/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Switchable caches (by PCID), perhaps?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:01 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743101/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's basically the same as partitioning the cache, isn't it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor743120"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 0:03 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/743120/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rather than restricting each domain to a tiny partition of the cache (which sounds painful for L1), perhaps you could let each domain use the whole cache (like now) but flush it every time you switch domain.<br>
<p>
Then you'd want to rearchitect software to minimise the amount of domain-switching. E.g. instead of a syscall accessing protected data from the same core as the application, it would just be a stub that sends a message to a dedicated kernel core. Neither core would have to flush their own cache, and they couldn't influence each other's cache. Obviously you'd have to get rid of cache coherence (I don't see how your proposal would be compatible with coherence either), and split shared L2/L3 caches into dynamically-adjustable per-domain partitions, and no hyperthreading, etc.<br>
<p>
Then maybe someone will notice that DRAM chips remember the last row that was accessed, so a core can touch one of two rows and another core can detect which one responds faster, and leak information that way. Then we'll have to partition DRAM by domain too.<br>
<p>
Eventually we might essentially have a network of tiny PCs, each with its own CPU and RAM and disk and dedicated to a single protection domain, completely isolated from each other except for an Ethernet link.<br>
<p>
Hmm, I'm not sure that will be good enough either: Spectre gets code in one domain (e.g. the kernel) to leak data into cache that affects the timing of a memory read in another domain (e.g. userspace), but couldn't it work with a purely kernel-only cache, if you simply find an easily-timeable kernel call that performs the memory read for you? Then it doesn't matter how far removed the attacker is from the target.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743120/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 13:44 UTC (Fri)
                               by <b>welinder</b> (guest, #4699)
                              [<a href="/Articles/743185/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even that might not be enough.  If any information based on speculation has left<br>
the cpu chip -- memory reads that reach the main memory -- then you might get<br>
caching effects there.<br>
<p>
I don't see tagging every memory location with an owner as a viable option.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor742853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 9:46 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/742853/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the third example I was surprised that the access through the kernel pointer didn't generate a memory protection fault.  But then I remembered that it never really 'happened' because the if-condition is always false (but mispredicted as true).  The issue is surely that speculative execution ignores the memory protection.  The fix would be to limit speculative execution to memory that's definitely permitted (even if that means a few odd cases now get slower).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742861"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 11:08 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/742861/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think it's fair to say it ignores the memory protection - it fetches the value (from L1$) and just predicts that there won't be a fault, carries on speculatively executing as if there wasn't a fault, and then eventually checks the memory protection and unwinds (most of) the CPU state when it realises it predicted wrong. The problem is that the CPU's behaviour during the speculative part is subtly observable, and so the fetched value is observable.<br>
<p>
The Meltdown PoC puts the memory read itself inside a speculative execution path, but I assume that's not strictly needed - it just makes the attack quicker/easier since you don't need to deal with a real page fault handler (because the fault gets unwound by the outer level of speculation).<br>
<p>
Apparently the protection bits are stored alongside the data in L1$, so it seems like it shouldn't be expensive for the CPU to check those bits simultaneously with fetching the value, and then it can immediately replace the value with 0 or pretend it was a cache miss or whatever, so that it doesn't continue executing with the protected value. (But maybe it's more complicated than that in reality.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742861/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 11:27 UTC (Thu)
                               by <b>MarcB</b> (subscriber, #101804)
                              [<a href="/Articles/742865/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The last paragraph is basically what seems to be the difference between Intel and AMD, and why AMD is not affected by Meltdown: AMD checks permissions - and aborts, if permissions would be violated - before measurable side-effects occur, Intel afterwards.<br>
<p>
But this has no effect on Spectre, which is based on speculative execution without crossing security boundaries.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743096"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:56 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/743096/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But this has no effect on Spectre, which is based on speculative execution without crossing security boundaries.</font><br>
<p>
I don't understand: array1-&gt;data[offset] is out of boundaries. If it were not then what information would be leaked?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743096/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:18 UTC (Thu)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/743110/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That it was in boundary. The point is you can find the boundaries I believe. Once you know the boundaries you can start extracting data beyond the boundaries a bit at a time after a number of cycles you've extracted something potentially valuable like login credentials or encryption keys. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:26 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/743113/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I kept missing one of the main differences between meltdown and spectre: spectre runs in kernel space, meltdown doesn't. Sorry for the noise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:52 UTC (Thu)
                               by <b>sfeam</b> (subscriber, #2841)
                              [<a href="/Articles/743117/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Spectre is particularly nasty if the target code runs in kernel space, hence the concern about user-supplied BPF code. But that is a special case.  The general case is that Spectre snoops information from any process you can persuade to execute the leaking code. The snooping is easiest if that is another thread in the same process (e.g. an un-sandboxed browser window).  No kernel space is involved there.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:17 UTC (Thu)
                               by <b>samiam95124</b> (guest, #120873)
                              [<a href="/Articles/743111/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, that is just not true. You are mixing speculative and non-speculative execution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 16:25 UTC (Fri)
                               by <b>MarcB</b> (subscriber, #101804)
                              [<a href="/Articles/743244/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What do you mean?<br>
<p>
My understanding of Meltdown is that it uses the limited speculative execution caused by classic pipelining+out-of-order execution (it does not use the advanced speculative execution that is used by Spectre). Or does it just use the reordering of stages, i.e. "read" before "check"?<br>
<p>
It boldly accesses memory it is not allowed to access and then "defuses" the exception by forking beforehand and sacrificing the child process. Or it avoids exceptions by using TSX and rolling back. It then checks if a given address was loaded into cache or not by the forbidden access.<br>
<p>
And apparently this does not work on AMD - and AMD claimed to never make speculative accesses to forbidden addresses - i.e. they must be checking earlier or never reorder "read" before "check".<br>
<p>
However, I do not see, how AMD could do this with TSX; there allowing this forbidden access seems to be part of the spec. Or does Ryzen not have TSX?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 17:34 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/743258/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
TSX isn't supposed to allow you to access memory you don't have permission to access, it just triggers a different response if you try – instead of a sigsegv, you get a transaction abort.<br>
<p>
(Also, no, AMD doesn't implement it)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 14:58 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/743360/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
It boldly accesses memory it is not allowed to access and then "defuses" the exception by forking beforehand and sacrificing the child process. Or it avoids exceptions by using TSX and rolling back. It then checks if a given address was loaded into cache or not by the forbidden access.
</blockquote>
Nope. It boldly accesses memory and then uses the value read from that memory to read one of a variety of bits of memory it shares with the attacker, but it does all of that *behind a check which will fail*, so the reads are only ever done speculatively, and no exception is raised. Unfortunately the cache-loading done by that read still happens, and the hot cache is easily detectable by having the attacker time its own reads of the possible locations. (With more than two locations, you can exfiltrate more than one bit at once, possibly much more.)
<p>
Needless to say, if you have a way to exfiltrate the data other than a shared memory region, you can use it: the basic attack (relying on side-effects of speculations bound to fail) is the same.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor743108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:15 UTC (Thu)
                               by <b>samiam95124</b> (guest, #120873)
                              [<a href="/Articles/743108/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Its not that speculative exec "ignores memory protection", but that you can't cause exceptions based on what might not even happen. Go down that road and you would be causing faults everywhere.<br>
<p>
The key to speculative execution is that it has to cause no side effects that would not be there if the processor didn't speculatively execute at all. Obviously there is one the CPU designers didn't think of, which is access time. That's what makes this exploit a really, really clever one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 6:52 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/743148/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Sure, it can't cause a memory exception based on something that might not happen -- but ideally it shouldn't speculate accesses to memory which isn't accessible.  Currently, I think it is fair to say that speculative execution 'ignores' the memory protection, in this example at least.  The accessibility of the memory doesn't have any impact on what speculative execution does.
<p>
I suggest that if practical, speculative execution should take memory protection into account, and if it gets to the point where an exception would be triggered, just stop speculating at that point and don't actually fetch the value from memory.

<blockquote>The key to speculative execution is that it has to cause no side effects that would not be there if the processor didn't speculatively execute at all.</blockquote>I think that is an impossible goal, at least if the purpose of speculation is to improve performance.  The whole point of it is for the speedup side effects.  So the effect of speculative execution will always be observable; what matters is to not speculatively execute (and make observable) operations which you would not be allowed to do in non-speculative execution.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 7:03 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/743150/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AMD checks permissions before speculatively executing stuff. But this doesn't protect against Spectre.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 11:35 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/743818/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are right, I believe I was only talking about Meltdown, not Spectre.<br>
<p>
The thought occurs that a processor could have two active permission modes: one for normal execution and one for speculation.  So even though the processor is executing in kernel mode (Ring 0), speculative accesses still get the memory permissions associated with user space.  So the transition from user to kernel space would be broken into two steps: first the processor switches to kernel mode but leaves speculative accesses unprivileged; later, once deep inside the kernel, an explicit instruction could enable speculative fetches to kernel memory too.<br>
<p>
(That might still let you snoop on another userspace process, of course.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2018 19:00 UTC (Mon)
                               by <b>ttonino</b> (guest, #4073)
                              [<a href="/Articles/744412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm afraid that all execution is speculative, but it is not rolled back afterwards.<br>
Otherwise it would be easy to load cache lines with an extra bit 'speculative=1' and if non-speculative execution encountered such a line, regard it as invalid.<br>
Sadly, that does not work: all execution is speculative, and most (?) of it is just not rolled back.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor743105"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:10 UTC (Thu)
                               by <b>samiam95124</b> (guest, #120873)
                              [<a href="/Articles/743105/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect the final hardware fix would be blinding the spec exec unit from unpermissioned pages. IE., you can't cause a fault from a speculative execution from a non-permissioned page, because that would give a fault where none would actually occur. But the CPU knows that the memory accessed is not in the user ring. Without redesigning the entire spec unit, you blind the data fetch by replacing it with, say, 0s. Then the side effects are not useful.<br>
<p>
I suspect with time we will see several hardware fixes, but obviously with brand new CPUs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743105/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 11:01 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/743172/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or indeed you could change the way memory protection works altogether such that any access to a forbidden address returns zero and sets a processor flag to be checked asynchronously.  (Speculative access would not set the flag.)  The kernel could then kill the process a short while later if the flag is set.  This would obviously make things less robust by allowing processes to continue blithely past bad pointer accesses, at least for a short while.<br>
<p>
I think your proposal of returning zeroes only for speculative loads and faulting on the normal ones is preferable, if it can be implemented efficiently.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor742904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 15:19 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/742904/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To be vulnerable to branch predictor abuse, you need to be able to train the predictor. If you (correctly) index your predictor using all of the bits of the VA, as opposed to the low order bits, you remove the most obvious route of attack. It's great we can finally talk about these problems together!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 16:36 UTC (Thu)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/742995/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could you elaborate? (More specifically, what is the 'VA' here?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 18:12 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743017/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At some point. Let's give this all time to settle down :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743075"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 21:51 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743075/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
VA = Virtual Address<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743075/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor743077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 21:54 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743077/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seems like that would help user -&gt; kernel attacks but not user -&gt; user attacks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:52 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743093/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nah, it's VA+ASID/PCID. It's actually very simple to have a branch predictor that is safe against variant 2. You just need to have your index completely disambiguate against other live contexts. The only problem with this is it's more bits to compare, but as compared to not having any branch prediction within one of the contexts, or flushing the predictor, I know which I prefer. I expect all of the vendors to make this relatively trivial fix in future silicon and then apply CONFIG_MARKETING to over hype it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:02 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743102/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That makes sense, although in my defense you did say "all the bits of the VA" :-).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 15:26 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/743848/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Normally branch predictors don't tag (and check) their entries at all, they just use a bunch of bits (possibly after mixing them in a non-cryptographic way) to index into the table and use whatever prediction they find there (no prediction is just as bad for performance as misprediction, so they don't bother checking).  Having the ASID as tag would be enough to avoid getting the predictor primed by an attacking process (won't help against an attack from untrusted code within the same process (e.g., JavaScript code), though).

<p>Other approaches for fixing the hardware without throwing out the baby with the bathwater could be to <a href="http://al.howardknight.net/msgid.cgi?ID=151559737200">put any loaded cache lines in an enhanced version of the store buffer until speculation is resolved</a>; and to <a href="http://al.howardknight.net/msgid.cgi?ID=151559780500">(weakly) encrypt the address bits when accessing various shared hardware structures, combined with changing the secret frequently</a>.  I guess there are others, too.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor742795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 2:34 UTC (Thu)
                               by <b>jimzhong</b> (subscriber, #112928)
                              [<a href="/Articles/742795/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Branch prediction, speculative execution, caches are all in classic computer architecture textbooks. Whoever came up with these exploits are brilliant. I think people will find more vulnerabilities like these.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 15:21 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/742905/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See page B-37 of both the current and previous editions of Computer Architecture, where it explicitly says you should perform the permission check during speculation. I've been keeping that reference ready to point folks at ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742961"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 15:45 UTC (Thu)
                               by <b>jimzhong</b> (subscriber, #112928)
                              [<a href="/Articles/742961/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Checking permissions can prevent the Meltdown attack which is specific to Intel processors. I doubts whether it can prevent Spectre.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742961/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 15:56 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/742968/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, but as I said elsewhere in the thread, you can mitigate branch predictor abuse if you correctly index your predictor based upon the full address space (including ASID/PCID/etc.). The hardware fix for variant 2 isn't actually as bad as people claim.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:39 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743079/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's only part of the Spectre attack though.<br>
<p>
Even if vendors manage to plug all the stuff in the Spectre paper, a big question is whether there are more big "leaking secrets through hidden CPU state using side channel" attacks that will be found soon, now that everyone's looking. I wouldn't bet against it. In which case we could be in for a long period of scrambling, patching, and performance-eroding mitigations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:54 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743094/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed. I co-lead the mitigation team within Red Hat for some time on this issue. It's allowed for a few productive conversations around potential future research. I've already spoken with those involved in this research, and similar related efforts. Red Hat turned up to MICRO50 last year, which wasn't on accident. I'm trying to drive more direct engagement with the architecture community, and especially now that we can work with the vendors and researchers to help find the next one. I'd really like it to be RH finding it next time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:07 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743103/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope you and your colleagues in the early-disclosure zone are reflecting on whether the "patch and pray" approach to stopping these leaks is sustainable long-term. For example, it was pointed out that retpolines break Intel's CET, i.e. one mitigation stomps on another. Each mitigation makes the system more complex and fragile ... and a lot of them make it slower, too.<br>
<p>
I realize you have to do these mitigations for now, but I think some serious long-term thinking needs to be going on alongside the stop-gap work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:20 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743112/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Er, retract that CET point. Apparently it is possible to have a CET-compatible reptoline.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor743106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">more vulnerabilities to be found</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:14 UTC (Thu)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/743106/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But the hardware fix is not a quick fix and the concern is of course about permutations of this attack that exploit similar functions. <br>
<p>
Spectre appears to lie at the heart of CPU design assumptions and will likely be around causing problems for a very long time as people figure out new ways to do the same thing using various other similar assumptions. As someone else said the person that came up with this was brilliant and it's going to have very far reaching consequences. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor742802"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 3:08 UTC (Thu)
                               by <b>vstinner</b> (subscriber, #42675)
                              [<a href="/Articles/742802/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article title is misleading. The article says "Intel, AMD, and ARM processors are all vulnerable (in varying degrees) to this attack." Why focusing only on Intel? The bug affects multiple CPU vendors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742802/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 6:51 UTC (Thu)
                               by <b>comicfans</b> (subscriber, #117233)
                              [<a href="/Articles/742826/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://meltdownattack.com/meltdown.pdf">https://meltdownattack.com/meltdown.pdf</a>  <br>
takes intel cpu as attack target and successfully leak kernel information.  it can also use Intel TSX to get higher channel capacity .for AMD and ARM, "We also tried to reproduce the Meltdown bug on several<br>
ARM and AMD CPUs. However, we did not manage<br>
to successfully leak kernel memory with the attack described<br>
in Section 5, neither on ARM nor on AMD." ... "However, for both ARM and AMD, the toy<br>
example as described in Section 3 works reliably"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor742833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 7:42 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/742833/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I think the title is a bit harsh. Meltdown may be Intel-specific, but the underlying issues certainly aren't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 9:23 UTC (Thu)
                               by <b>valberg</b> (guest, #83862)
                              [<a href="/Articles/742848/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree. The title is very misleading (and actually unfair) and should be corrected.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor742807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 3:34 UTC (Thu)
                               by <b>atelszewski</b> (guest, #111673)
                              [<a href="/Articles/742807/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
<p>
I would love to hear an authoritative statement,<br>
how all of this affect single-user desktops?<br>
<p>
What is the attack channel?<br>
For example, JavaScript in a browser?<br>
If so, how long would it take to extract useful data?<br>
<p>
No doubt it is serious thing, because many (most?) of the services we<br>
relay on, are somewhere out there, in multi-user (server) environments.<br>
<p>
But, how safe are my locally kept passwords?<br>
(Except for those I transmit to my banks website ;-)).<br>
<p>
--<br>
Best regards,<br>
Andrzej Telszewski<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742813"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 4:27 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/742813/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      There is, for example, <a href="https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/">this advisory from Mozilla</a> on how it could be used to access information in a web browser.
      
          <div class="CommentReplyButton">
            <form action="/Articles/742813/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 4:43 UTC (Thu)
                               by <b>atelszewski</b> (guest, #111673)
                              [<a href="/Articles/742815/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
<p>
Wow, I wouldn't have ever thought that browsers allow for sub 1-ms time measurements.<br>
Well, with the current state of affairs, everything is possible (vide WebUSB).<br>
<p>
Thanks.<br>
<p>
--<br>
Best regards,<br>
Andrzej Telszewski<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 17:13 UTC (Thu)
                               by <b>mtanski</b> (guest, #56423)
                              [<a href="/Articles/743002/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you're generating live audio in the browser you need sub ms precision. After all 44.1kHz is ~44 samples per ms.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 18:20 UTC (Thu)
                               by <b>atelszewski</b> (guest, #111673)
                              [<a href="/Articles/743018/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
<p>
I wouldn't dare to think that you can build audio samples in JavaScript.<br>
What about latency? Are the browsers using some real-time scheduling?<br>
<p>
My assumption is that performance.now() is a JavaScript thing,<br>
but I haven't verified this.<br>
<p>
--<br>
Best regards,<br>
Andrzej Telszewski<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743116"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 23:41 UTC (Thu)
                               by <b>mtanski</b> (guest, #56423)
                              [<a href="/Articles/743116/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it can be done somebody has done it in JS. There's even a browser audio API: <a href="http://papers.traustikristjansson.info/?p=486">http://papers.traustikristjansson.info/?p=486</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743116/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor742845"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Separate privileges, separate caches</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 9:07 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/742845/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since cache timing will always be visible to code (unless you mandate a restricted programming language that cannot precisely measure its own time taken) the only way to fix this in general is to have separate caches for each separate privilege level.  As a minimum one for kernel mode and one for user mode.  As a small improvement, kernel mode could read the userspace cache (but not write to it) while userspace would have no access to the kernel cache at all.<br>
<p>
Since CPUs don't currently support this, the way to emulate it is to flush the cache on each context switch from kernel to user space.  This would slow things down.  It might require rewriting some kernel APIs to be 'fatter' so that a single call does more work before returning, and you don't need as many context switches.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742845/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Separate privileges, separate caches</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 11:28 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/742866/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
These attacks are using the cache as a side channel to leak data from the speculatively-executed instructions to the non-speculative world, but I don't think that's the only possible side channel. E.g. maybe you could use a variable-speed instruction like division ("1 / (v &amp; 1)" etc) and use another hyperthread to measure how long the execution unit is busy for. Or maybe you could use a constant-speed expensive SIMD instruction where certain input values cause lots of transistors to flip between 0s and 1s repeatedly, generating more heat, so you run it in a loop then measure the temperature of the CPU core. (Maybe that one is less plausible). The cache is completely irrelevant in those cases, so you can't fix it by changing the cache design.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Separate privileges, separate caches</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 16:06 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/742972/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wasn't there already a known information leak with hyperthreading, leading the OpenBSD developers to recommend that you disable it?<br>
<p>
Perhaps the cache is not the only thing that lets you snoop but it is certainly a major one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Separate privileges, separate caches</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 21:45 UTC (Thu)
                               by <b>emaste</b> (guest, #121005)
                              [<a href="/Articles/743052/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You may be thinking of the hyperthreading cache side-channel reported by Colin Percival, with a mitigation first in FreeBSD back in 2005. Those details are at <a rel="nofollow" href="http://www.daemonology.net/hyperthreading-considered-harmful/">http://www.daemonology.net/hyperthreading-considered-harm...</a>, and the paper is at <a rel="nofollow" href="http://www.daemonology.net/papers/htt.pdf">http://www.daemonology.net/papers/htt.pdf</a>.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor742844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 9:09 UTC (Thu)
                               by <b>olivlwn</b> (guest, #100387)
                              [<a href="/Articles/742844/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well done ! <br>
<p>
Regarding pti, based on articles on Phoronix it seems that the  performance cost is not so bad. TBC.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 11:50 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/742873/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Typical Phoronix article though. Video encoding and compiling aren't much affected: well, of course not, they hardly transition to kernel space at all! FSMark drops by more than 50% in some tests. 50%! From a single mitigation!<br>
<p>
Sorry, if you do anything with the fs the performance cost is clearly appalling, since FSMark isn't *that* synthetic: things like big find(1)s are fairly similar to FSMark in that all they really do is ask the kernel for things lots and lots of times. (Of course, they are also disk-bound operations, so maybe the performance cost is only visible once you have a hot cache, or if you use an SSD.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 12:15 UTC (Thu)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/742877/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I remember correctly, these figures are similar to what grsecurity was getting with du -s. Pretty scary to think that some things may take twice the time, but that seems to be the reality...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 16:32 UTC (Thu)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/742989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why scary? It depends. For example, I would love to see the duration between my birth and my death take twice the time. than originally specified...<br>
But joke aside, this performance penalty has to be balanced against the actual security needs - and you may try alternative implementations (e.g. with another CPU, another software configuration, etc.).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor742880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 13:45 UTC (Thu)
                               by <b>MarcB</b> (subscriber, #101804)
                              [<a href="/Articles/742880/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In general, any workload in which fixed costs of syscalls are a significant share, will be impacted strongly.<br>
<p>
This can be filesystem, but also socket operation, or - as it turns out - mprotect.<br>
<p>
On one system I am observing about 10 millionen calls to mprotect per minute (not sure, if this is sane). The workload should theoretically be low on syscalls, but it is not. mprotext is followed by futex, nanosleep and then the expected read at around 160k/minute.<br>
<p>
Perhaps, a good thing that will come of this is a review of some applications use of syscalls.<br>
<p>
The following can give you an idea. It will sample for 60 seconds:<br>
perf stat -e 'syscalls:sys_enter_*' -a sleep 60 2&gt;&amp;1 &gt;/dev/null | sort -n<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 17:20 UTC (Thu)
                               by <b>mtanski</b> (guest, #56423)
                              [<a href="/Articles/743005/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Video/audio encoding, gaming other mostly CPU bound applications will be minimally impacted. Applications that do a lot of syscalls will be impacted quite a bit.<br>
<p>
My estimate is about 10% to 15% in real world OLTP database workloads. Databases end up doing a mixture of network / disk IO. Most OLTP queries are getting / returning a handful of tuples so execute time is not dominated by CPU by disk IO. There's usually also a random read pattern (btrees, index indirection). The faster the disk device (100k+ IOPS device) the more impact this will have.<br>
<p>
To make this into a one-two punch the KPTI mitigation requires flushing of the TLB. Databases often end doing quite a bit of caching in userspace again with non-ideal locality (random placement) so this will further impact it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 19:07 UTC (Sat)
                               by <b>JanC_</b> (guest, #34940)
                              [<a href="/Articles/743388/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This looks pretty bad too:<br>
<a href="https://www.epicgames.com/fortnite/forums/news/announcements/132642-epic-services-stability-update">https://www.epicgames.com/fortnite/forums/news/announceme...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor742846"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 9:17 UTC (Thu)
                               by <b>jtaylor</b> (subscriber, #91739)
                              [<a href="/Articles/742846/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speculative execution has been around in cpus for more than a decade and timing attacks on cpu caches are not new either. I wonder why it took so long to figure this flaw out. Is there something else new involved in these attacks?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742846/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742855"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 9:53 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/742855/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is there something else new involved in these attacks?</font><br>
<p>
Attention to security issues and funding of research grew from basically zero to almost measurable?<br>
<p>
Even today old and unsafe programming languages are still the most popular and closed source software is still king.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742855/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor742888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 14:25 UTC (Thu)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/742888/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p><i>Is there something else new involved...</i></p>

<p>What's new is the people. When crypto instructions arrived in CPUs cryptography researchers bought their concerns with side-channels with them when analysing the CPU's crypto implementations (eg, CacheBleed). They then applied those side-channel concerns to other aspects of CPU security. What's new here is using speculative execution as the side-channel (and discovering a more severe flaw in Intel CPUs whilst doing that work).</p>

<p>As usual there's a small number of academic cryptographers and computer scientists at the beginning of the trouble. A good start would be the papers <a href="https://www.adelaide.edu.au/directory/yuval.yarom">here</a>. On the plus side, they've reclaimed the phrase "industry disruption" from its misuse by venture capitalists.</p>

<p>Those researchers are of the view that microarchitecture design lacks design rigour, which is the usual approach taken by cryptographic semiconductor designers to limit side channels. Re-engineering semiconductor design processes to add such rigour after the fact isn't going to be a fast or fun ride.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/742888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 15:09 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/742902/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What's new here is using speculative execution as the side-channel</font><br>
<p>
It seems to me like the side channel is simply the cache, which was already well known as a way for two malicious processes to communicate, and as a way for a malicious process to spy on the memory-access behaviour of an innocent process.<br>
<p>
What's new is that an innocent process can be tricked into (speculatively) fetching sensitive data then revealing that data through some side channel, because the CPU's speculative execution will happily ignore the innocent code's validity checks that should have restricted what data it can fetch, or will happily ignore the innocent code's intended control flow and start executing arbitrary instructions. A similar attack could (in theory) work with other non-cache-related side channels to leak the data once it's been fetched.<br>
<p>
Also what's new is someone doing the proof-of-concept work to demonstrate it's a real problem, rather than just expressing vague suspicions about how dodgy the whole thing feels.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 16:07 UTC (Thu)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/742967/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's probably covert channel then here, as in J. K. Millen, “Covert Channel Capacity”, in IEEE Symposium on Security and Privacy, Oakland, 1987.<br>
Covert channels identification and control was already in the TCSEC security evaluation criteria in the 80s (the so-called "Orange Book") for multilevel security operating system, so, even if the present concerns are indeed new - the whole problem does sound in fact very old to me.<br>
In secure multiuser (or more precisely multiprogramming IIRC) systems, covert channels may exist wherever a shared resource exists between programs running at different security levels. Obviously, current systems have much more shared resources between processes (at much higher frequencies) than in the past: cpus, threads, caches (multiple levels), etc. so the opportunity for covert channels existence is very high. And virtualization systems only widen the possibility for untrusted code to demand code execution in more privileged context.<br>
<p>
Finally, the biggest security concern for me is not the existence of these vulnerabilities but  another question: why in the hell have these old security requirements been put aside deliberately for 2 decades? Only really young people should have an excuse for ignoring those unwillingly (and they have none anymore ;-).<br>
<p>
As an added comment, note these issue surface and gain traction because exploits are implemented. Why not put more effort into protecting our systems from covert channels instead of, once again, starting by investing time into breaking them with tricky low level programming?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 19:12 UTC (Thu)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/743026/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I recall, the only way to get a B1 rating was to disable networking entirely. Even C2 was hard - and it was so long ago (90?) for me that I cannot remember the requirements or differences between these levels. Though I think this year might be a good time to re-read them.<br>
<p>
I do seem to recall that databases had to have *row-level* security labels... but my opinion then, as now, was that orange book was unimplementable for usable systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 9:38 UTC (Fri)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/743162/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think your summary is too negative. Admittedly, the Orange book (and the general requirements of academic) security requirement have always been high and ambitious ; but the primary reason they appear today to be unachievable is because so many people lowered their own security requirements so low in the meantime that decades old objectives sound impossible.<br>
B1 (or ITSEC E5+ or CC EAL5+) systems is achievable with networking - of course. Orange book et al. requirements are too old to be used as-is but the way they have been built and designed should not have been thrown away carelessly as, IMHO, they were much more pertinent to computer security than many recent useless recipes. E.g. I keep on repeating that vulnerability analysis is only the last ten percent of the security work and the most effort should be spent on protection design, not breaking thing. Yes, I know, I said it once again - it must be senility luring. (or is it disinformation?:-)<br>
And sometimes the tools are even already here. The main difference between B and C levels is the multilevel mandatory policy. Mandatory policy mechanisms have come back in mainstream Linux systems. Row level  security mechanisms are available in mainstream PostgreSQL, etc. And  eveyone sees that they are not so easy to use as is, so more work would needed to make them usable. But in fact, very logically given the technology improvements, some implementations have already advanced much further than what these decades old standards were proposing.<br>
What is misleading is the way the general objective of computer security has been twisted. The end user should trust the system. Several lines of defense should be installed. Security kernels (TCBs) and their properties should be well defined (and realistic). Security documentation should be available (including for the vulnerabilities). These objectives were present in the old books. Hopefully they are still present in many works but they do not seem to gather the most valuable effort (typically money). Maybe they were not as well defined as their writers thought - but I also think too few people fought for them.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 21:56 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/743070/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; because the CPU's speculative execution will happily ignore the innocent code's validity checks that should have restricted what data it can fetch, or will happily ignore the innocent code's intended control flow and start executing arbitrary instructions.</font><br>
<p>
The most fascinating part is that this is an "impossible execution": you have code which can never read out of bounds, since every possible flow into it checks the bounds; yet, in some imaginary world dreamed by the CPU's pipeline, the out of bounds read actually happens.<br>
<p>
That reminds me of undefined behavior, which is also something which by its definition cannot ever happen (and compilers optimize accordingly), yet sometimes happens, leading to bizarre results following some sort of dream logic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 9:51 UTC (Fri)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/743166/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is fascinating until the associated CPU starts to talk about driving the car, landing the plane, counting the ballots, talking to the kids in their bedroom, policing the street and more generally acting on your behalf all the time. Then the fascination turns into fear. Not of the CPU itself by the way - but of the way other humans could take advantage of this undefined behaviour.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor743157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 8:12 UTC (Fri)
                               by <b>Yenya</b> (subscriber, #52846)
                              [<a href="/Articles/743157/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is there something else new involved in these attacks?</font><br>
<p>
Two things:<br>
<p>
- widespread use of virtualization ("cloud computing"), i.e. running someone else's native code on our CPUs.<br>
- widespread use of JIT engines in Javascript and other languages, in which - again - someone else's code is run on our CPUs.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 23:41 UTC (Fri)
                               by <b>kiko</b> (guest, #69905)
                              [<a href="/Articles/743306/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C'mon, our CPUs are always running somebody else's code. Do you think third-party code was safer in the DOS days? That's not the issue at hand. The problem is that CPUs and software have gotten so complex that our established security patterns -- for instance userspace/kernel  separation -- are becoming increasingly insufficient to provide a reasonably secure computing environment.<br>
<p>
And yeah, having so many computers and services addressable on the Internet provides scale for making complex or expensive attacks realistic to the point of being trivial.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor742859"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 10:47 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/742859/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Time to re-re-re-relearn an important lesson: letting random strangers run arbitrary code on Someone Else's Computer is dangerous. Especially if that someone else is you, and you're not aware it's happening.<br>
<p>
For browser authors: you went out of your way to make life exceptionally difficult for people who don't want to be involuntarily opted in to this kind of blind trust, and kept digging this hole after Rowhammer. Is it worth it for this kind of fallout? Will it be worth whatever comes next?<br>
Would be poetic justice if one of the first uses of this exploit was to leak EME private keys.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742859/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 11:20 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/742864/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not exceptionally difficult to disable Javascript.<br>
<p>
Even if removing Javascript from the browser entirely was a good idea in the abstract, there are a couple of problems. One is that all users would immediately switch to a competitor browser, possibly an earlier version from the same vendor.<br>
<p>
Another, even deeper problem is that the only alternative to run-by-default execution of untrusted code is some kind of trusted gatekeeper like the app stores have. (Don't say users should decide; they mostly can't.) But those gatekeepers don't work very well, and they put too much power in the hands of Google and Apple.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 18:52 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/743384/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I know a JS-free web will never happen, it's too impractical, it's some people's dayjob, etc. The sky is falling, I don't have a good answer and I don't expect anyone does right now.<br>
<p>
Maybe we could, for a start, treat CPU-hungry webpages with a bit more paranoia than passive event-driven ones? There's sufficient fine-grained security for the latter group but all we've had for the former is sledgehammers like NoScript, or whack-a-mole solutions like that one coinhive blocking extension. Enumerating badness isn't sustainable, there has to be a better way.<br>
<p>
I wouldn't mind having less reasons to allow JavaScript in the first place though. Google should be busy restoring their MathML support after this week, for one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor742885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 13:35 UTC (Thu)
                               by <b>freemars</b> (subscriber, #4235)
                              [<a href="/Articles/742885/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>
Jon, I'm glad you (and the kernel crew) are on this.  <i>Someone</i> needs to care about security... even if Intel doesn't.
</p><p>
Could paranoid applications (i.e. all of Tails) take advantage of the <code>unlikely()</code> directive to force the CPU to take the longer route every time and stop timing attacks?
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/742885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742893"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 14:25 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/742893/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, most obviously because that directive is optional and is ignored (or compiled out, I think) when it suits the CPU.<br>
<p>
Also, I don’t think that would work anyway - you could force the speculative execution down a particular path but it isn’t necessarily the right one.  Someone could still exploit that.  Right...?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742893/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor742898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 14:47 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/742898/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
unlikely()/__builtin_expect() doesn't force anything - it's just a hint to the compiler, which might arrange code more efficiently and might emit instructions with hints for the CPU (which the CPU might use or ignore).<br>
<p>
The "variant 1" attack seems to rely on the target process(/kernel) containing code that reads memory from an attacker-controlled address, after checking the address for validity. The CPU might speculatively perform the read and process that data in an observable way, even if the validity check fails and it's reading sensitive data. To prevent that, I guess you need to put something between the validity check and the read to prevent speculation, like a "cpuid" instruction on x86. But that can be very expensive (hundreds of cycles), and I don't know how you'd find all the places you need to put it.<br>
<p>
The "variant 2" attack seems to rely on the target process(/kernel) containing an indirect jump instruction, which can be tricked into predicting an attacker-controlled location and speculatively executing dangerous code. It sounds like the -mindirect-branch=thunk-extern GCC patches could be enough to prevent that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor742892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">We need alternate approaches</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 14:37 UTC (Thu)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/742892/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have been saying for many years now, that the system is rotten to its cores, and lines of research that we'd had in the 90s (like capabilities architectures) needed to be resumed, tools for creating hardware made more robust and open, and critical systems protected by diversity in the ecosystem.<br>
<p>
Last night, after reading the relevant papers on these new attacks, I started<br>
reminiscing fondly of the days when I used to use an old DEC alpha as<br>
a firewall merely because I had more confidence it would be harder to<br>
exploit than anything else, just by being different.<br>
<p>
I can't help but reflect on my favorite (sadly, still slidewire) alternate cpu's characteristics, the mill cpu.<br>
<p>
It's a single address space in the first place (no aliasing), protection of memory<br>
is to the byte, not the page (and done in a separate unit than the TLB) - and the cache is virtual, not physical.<br>
<p>
There are no syscalls, per se', instead an explicit (and fine grained) capability gaining<br>
(or dropping) portal call almost exactly like a subroutine.<br>
<p>
The stack is protected from ROP. Stack and registers have no rubble left behind<br>
(there are few registers, as we know them, either) that can be peered<br>
at on call or return, and further malloc and free can be jiggered to not reuse memory quickly, or always return zeroed memory, at a usable and very low cost.<br>
<p>
The mill equivalent of speculative execution is an intrinsic, well<br>
documented part of the exposed processor pipeline: an explicit value<br>
(NAR = not a result) is dropped on "the belt" there is the equivalent of<br>
failed speculative execution. There isn't a conventional BTB, either (branch<br>
exits are predicted via an undefined mechanism). <br>
<p>
In short, I think the mill, as the closest thing to a pure capabilities arch that exists<br>
today, could have (at least on paper) been invulnerable to this string<br>
of attacks. (but of course, vulnerable to other things not yet thunk up).<br>
<p>
There are of course many other possible arches and ideas out there, the important thing is to recognize that it's long past time to try building them rather than endlessly patching warts on top of warts.<br>
<p>
PS:<br>
<p>
And I'm hating the workarounds posted thus far, because, latencies<br>
are going to jump once again on servicing interrupts, and<br>
that breaks a lot of assumptions in (for example) the virtualized<br>
networking space, and interrupt handling and context switches were already orders of<br>
magnitude too slow for my taste and favorite user facing applications.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor742963"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 15:49 UTC (Thu)
                               by <b>JFlorian</b> (guest, #49650)
                              [<a href="/Articles/742963/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not going to claim I understand any of this all that well, but it is clearly going to prove a significant disruption.  It's also clear that complexity got the better of us and I fear it will be "resolved" through ever more complexity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742963/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 16:21 UTC (Thu)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/742974/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am not sure this will disrupt much in the near term. So many users are so used to seeing their computing devices security compromised that they do not even complain anymore.<br>
Plus the fact that hardware vendors do not seem to me as the biggest culprits here. Why was speculative execution introduced in the first place? Because software programmers did not want to use complex compilation techniques (involving, e.g. data profiling or variants programming) and the software industry did not want to pay for advanced devleopment tools (and possibly new languages, new compilers, etc.). Hardware-level runtime optimization was seen as good enough. Well, it may be, but maybe you lose more in the process than you think (especially predictability). <br>
<p>
"Good enough" has always been a very problematic strategy for security-critical computing. But why would such a state of fact be perturbed? (I hope it will be, but I do not see why unless all users finally start to see some kind of new light and put actual money on it - or more probably out of not good enough systems and teams.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 16:30 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/742990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Intel did have a good try at removing speculative execution from the processor: with Itanium, as I understand it, any speculative load instructions have to be put in by the compiler explicitly.  As you say, it didn't take off because nobody could be bothered to switch to the advanced compiler technology needed.  (Well, there may be other reasons why Itanic sank, and in some ways we are better off not having an Intel-proprietary instruction set, but certainly industry inertia was part of it.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 17:23 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/743008/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Because software programmers did not want to use complex compilation techniques (involving, e.g. data profiling or variants programming) and the software industry did not want to pay for advanced devleopment tools (and possibly new languages, new compilers, etc.).</font><br>
<p>
That's disingenuous.<br>
<p>
The simple fact of the matter that those "complex compilation techniques" didn't exist at the time, and still don't exist today.  And it's not for the lack of trying.  Intel spent many billions of dollars trying to make this work, and made some progress -- but it turned out that the hardware could do a better job at runtime than the compilers could at compile-time -- because, as it turns out, at runtime one has the advantage of knowing the *data* the software is dealing with, while at compile-time one doesn't.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2018 22:57 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743091/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is completely right.<br>
<p>
Also, Itanium would not have been immune to Spectre. Itanium included speculative load operations, and in the "Spectre variant 1" attack, the compiler might well have hoisted the problematic loads above the bounds check precisely to get the performance benefit that an out-of-order CPU gets by speculatively executing those loads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 6:59 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/743149/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right - but on Itanium it would be more straightforward to fix, since you could set a compiler flag to just remove speculative load instructions from the kernel (as a quick fix), adding them back where they are proven safe.  Indeed, the compiler could be taught not to speculatively lift loads outside bounds checks.<br>
<p>
In user space, I imagine that the explicit speculative load instruction used on Itanium does do all the same memory access checking as an ordinary non-speculative load, so it can't be used to snoop in the same way as the hidden speculative execution on x86_64.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 10:12 UTC (Fri)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/743168/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, maybe I am a somehow disingenuous, admittedly back then the hardware-based solutions looked better, but I have to question everything, including the fact that the most prominent hardware vendor of that time really did try to favor software development tools rather than its own silicon-oriented intellectual property, don't you think?<br>
Anyway, I would love to be proven wrong and see some of this past research resurrect into a nice powerfull-enough deterministic processor and the associated innovative software development environment for current and near-future critical systems. In my opinion, it is the right time now and many would certainly consider helping it (in good faith I assure you ;-).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 11:16 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743173/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your second paragraph seems to be talking about Meltdown, but Spectre 1 is still a problem for user-space applications. It is probable that Meltdown wouldn't have worked on Itanium.<br>
<p>
FWIW in C I don't think it's easy to tell what is a bounds check and which loads are guarded by which checks.<br>
<p>
I agree that it would be a bit easier to fix these specific issues in Itanium. I don't think that makes this a "Itanium should have won!" moment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 16:02 UTC (Sun)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/743436/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The discussions over at comp.arch have been quite informative,(<a href="https://groups.google.com/forum/#!forum/comp.arch">https://groups.google.com/forum/#!forum/comp.arch</a>)<br>
<p>
And it does look like the mill was invulnerable by design to spectre/meltdown. They did find and fix a bug where the compiler could lift a memory access ahead of its guard, but near as I can tell that would have caused a segfault rather than a permissions violation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor743133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does Red Hat's updates fix everything?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 1:50 UTC (Fri)
                               by <b>dowdle</b> (subscriber, #659)
                              [<a href="/Articles/743133/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Red Hat mentions three CVEs that are fixed.  The three issues they talk about are very similar to those mentioned by Jon.  I can't say I did a really good comparison but I skimmed it well enough hopefully.<br>
<p>
Anyway, Jon said:<br>
<p>
Getting around boundary checks - "There is no straightforward defense to this attack, and nothing has been merged to date."<br>
<p>
Messing with indirect jumps - "As of this writing, no defenses have actually been merged into the mainline kernel."<br>
<p>
Forcing direct cache loads - "The answer here is kernel page-table isolation"<br>
<p>
So... given Red Hat's updates and their reported fixing everything (although saying that software isn't a complete fix for the hardware issues)... has Red Hat come up with their own fixes?  Are they using something that was submited but not yet accepted by upstream?  What?  Do these fixes actually work for the first two or not?  I guess the proper folks to ask would be Red Hat but I'm sure there are plenty of people here who would like to know the answers too.  Hopefully someone can elaborate because there is a lot of confusion going around... and lots of articles and whatnot... but not sure what is accurate signal and what is noise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does Red Hat's updates fix everything?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 4:43 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743143/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The situation is incredibly confusing even if you spend significant time trying to follow the details.<br>
<p>
You've got Intel releasing microcode updates (when?) and basically saying "we've fixed everything", various Linux kernel patches in flight, and Amazon and Google saying "we've fixed all our stuff", yet it's completely unclear what mitigations are actually being deployed, which bugs they think they're fixing, and what they're assuming everyone else has to do. Meanwhile it's very clear from the Spectre paper that the attacks they and Project Zero identified are probably just the tip of an iceberg. What's being done about the iceberg?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does Red Hat's updates fix everything?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:09 UTC (Sat)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/743322/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>What's being done about the iceberg?</blockquote>

The first mates (there is no captain) are panicking and trying to figure out where the iceberg is and how big it is but understand it's the middle of a night in a fog bank and they might not know for quote a while, the Barrelman saw the iceberg and wrote a report about it but wasn't quite sure if they saw the whole thing or even if there is more than one, the sailors are trying to patch the hole dumping water into the boat from the first strike but all they've got to fix the hole is some leftover bread, the engineer in the engine room claimed he already avoided the iceberg and has issued a full steam ahead order and the 200 helmsmen are busy steering in some direction they think the iceberg isn't. <br><br>

Meanwhile the half the press is running up and down the deck yelling that everyone is dead, the other half is telling everyone there is nothing to worry about and the passengers are in the dining room without a care in the world. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/743322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does Red Hat's updates fix everything?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 18:38 UTC (Sat)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/743385/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And there may be one iceberg or there may be hundreds -- we can't tell now.  These icebergs are catastrophic for some boats but pretty much irrelevant for others.  And the proposed solutions will cut the top speed of all boats by 7 to 30%.  Or 2 to 12%, or 10 to 50, or something.  Depends on when you ask, the numbers are changing daily.<br>
<p>
We don't even know if the icebergs have their own power and can hunt down boats on their own.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor743160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 8:31 UTC (Fri)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/743160/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent article, thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor744572"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2018 15:28 UTC (Wed)
                               by <b>mopcua</b> (guest, #121648)
                              [<a href="/Articles/744572/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"An exploit can fetch the data at both 0x200 and 0x300 and compare the timings."<br>
<p>
How can the exploit fetch this data? Is it in user space or is he doing it via some getter provided by the kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744572/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744576"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2018 15:48 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/744576/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You wouldn't want to really use 0x200 - that's just a simplified example of the concept. You'd use an address that is mapped into the attacker's userspace process, so the attacker can trivially read it. The Project Zero example does an eBPF array access with a bogus index that points to a massively-out-of-bounds element at a userspace address.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744576/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor744772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Notes from the Intelpocalypse</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2018 14:40 UTC (Fri)
                               by <b>brokenstapler</b> (guest, #121720)
                              [<a href="/Articles/744772/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The Meltdown fix is not nearly going as well as expected. <a rel="nofollow" href="https://newsroom.intel.com/news/firmware-updates-and-initial-performance-data-for-data-center-systems/">Intel made a comment</a> that explained a bit about what's going on and how the fix isn't going as smoothly as one might have hoped. 

<a rel="nofollow" href="https://www.58mmtamper.com">Further reading</a> is available if you want (Ars, HN, etc) but it's just going to make you sad.
      
          <div class="CommentReplyButton">
            <form action="/Articles/744772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
