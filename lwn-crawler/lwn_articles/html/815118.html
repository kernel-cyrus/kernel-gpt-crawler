        <!DOCTYPE html>
        <html lang="en">
        <head><title>Filesystem-oriented flags: sad, messy and not going away [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/815118/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/814704/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/815118/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Filesystem-oriented flags: sad, messy and not going away</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 16, 2020</br>
           </div>
Over the last decade, the addition of <a href="/Articles/585415/">a "flags"
argument</a> to all new system calls, even if no flags are actually needed
at the
outset, has been widely adopted as a best practice.  The result has
certainly been greater API extensibility, but we have also seen a proliferation of
various types of flags for related system calls.  For calls related to
files and filesystems, in particular, the available flags have reached a
point where some calls will need as many as <i>three</i> arguments for them
rather than just one.
<p>
One set of filesystem-oriented flags will be familiar to almost anybody who
has worked with the Unix system-call API: the <tt>O_</tt> flags supported
by calls like <tt><a
href="http://man7.org/linux/man-pages/man2/openat.2.html">open()</a></tt>.
These flags affect how the call operates in a number of ways;
<tt>O_CREAT</tt> will cause the named file to be opened if it does not
already exist, <tt>O_NOFOLLOW</tt> causes the open to fail if the final
component in the name is a symbolic link, <tt>O_NONBLOCK</tt> requests
non-blocking operation, and so on.  Some of those flags affect the lookup
process (<tt>O_NOFOLLOW</tt>, for example) while others, like
<tt>O_NONBLOCK</tt>, affect how the file descriptor created by the call
will behave.  All are part of one flag namespace that is recognized by all
of the <tt>open()</tt> family of system calls.
<p>
<tt>open()</tt> is one way to create a new entry in a directory; <tt><a
href="http://man7.org/linux/man-pages/man2/link.2.html">link()</a></tt> is
another.  When the time came to add flags to <tt>link()</tt>, the
<tt>linkat()</tt> system call was born; this system call also follows the
other relatively new pattern of accepting a file descriptor for the
directory in which the operation is to be performed.  <tt>linkat()</tt> has
a separate flag namespace (the "<tt>AT_</tt> flags") with flags like
<tt>AT_SYMLINK_FOLLOW</tt>, which is the opposite of
<tt>O_NOFOLLOW</tt>.  There is also an
<tt>AT_SYMLINK_<b>NO</b>FOLLOW</tt> that is <i>not</i> recognized by
<tt>linkat()</tt>, but which is understood by calls like <a
href="http://man7.org/linux/man-pages/man2/chmod.2.html"><tt>fchmodat()</tt></a>
and <a
href="http://man7.org/linux/man-pages/man2/execveat.2.html"><tt>execveat()</tt></a>.
There are more <tt>AT_</tt> flags, such as <tt>AT_NO_AUTOMOUNT</tt>,
supported by the relatively new <a
href="http://man7.org/linux/man-pages/man2/statx.2.html"><tt>statx()</tt></a>
system call.
<p>
<a href="/Articles/796868/">Then there is <tt>openat2()</tt></a>, which is
coming with the 5.6 kernel.  Rather than having a separate argument for
flags, this system call requires a pointer to an <tt>open_how</tt>
structure:
<p>
<pre>
    struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
    };
</pre>
<p>
Here, <tt>flags</tt> contains the <tt>O_</tt> flags common to the
<tt>open()</tt> family, while <tt>resolve</tt> contains yet another set of
flags (the "<tt>RESOLVE_</tt> flags").  These include
<tt>RESOLVE_BENEATH</tt> to limit the lookup to files below the provided
directory and <tt>RESOLVE_NO_SYMLINKS</tt>, which is kind of like
<tt>O_NOFOLLOW</tt> or <tt>AT_SYMLINK_NOFOLLOW</tt> but different: it
blocks symbolic-link traversal at all stages of pathname traversal, rather
than just for the final component.
<p>
LWN has occasionally covered the ongoing story of the <a
href="/Articles/813172/">proposed <tt>fsinfo()</tt> system call</a>, which
provides information about mounted filesystems.  This new API also includes
a structure pointer as one of its parameters:
<p>
<pre>
    struct fsinfo_params {
	__u32	at_flags;
	__u32	flags;
	__u32	request;
	__u32	Nth;
	__u32	Mth;
	__u64	__reserved[3];
    };
</pre>
<p>
Here, <tt>at_flags</tt> is, as one would expect, a set of <tt>AT_</tt>
flags, while <tt>flags</tt> is yet another set of flags specific to this
system call.  Recently, though, <tt>fsinfo()</tt> author David Howells <a
href="/ml/linux-fsdevel/96563.1582901612@warthog.procyon.org.uk/">noted</a>
that he had been told that <tt>RESOLVE_</tt> flags should be used in
preference to <tt>AT_</tt> flags in all new system calls, and asked whether
the <tt>AT_</tt> flags should be considered deprecated.  He followed up
with <a
href="/ml/linux-fsdevel/3774367.1583430213@warthog.procyon.org.uk/">a
patch</a> marking the <tt>AT_</tt> flags as being deprecated and adding
new <tt>RESOLVE_</tt> flags to cover behaviors that can currently only be
requested by <tt>AT_</tt> flags.  So, for example, he added
<tt>RESOLVE_NO_TERMINAL_SYMLINKS</tt> (later renamed
<tt>RESOLVE_NO_TRAILING_SYMLINKS</tt>) to request the same semantics as
<tt>AT_SYMLINK_NOFOLLOW</tt>.
<p>
Christian Brauner <a
href="/ml/linux-fsdevel/20200228152427.rv3crd7akwdhta2r@wittgenstein/">argued
in favor</a> of moving to <tt>RESOLVE_</tt> flags, noting that some of the
semantics that are only available via those flags may be of use in settings
beyond <tt>openat()</tt>.  He did allow, though, that "<q>we might end
up causing more confusion for userspace due to yet another set of
flags</q>" â€” though others might argue that it's a bit late to worry
about that at this point.
<p>
Linus Torvalds, though, <a
href="/ml/linux-fsdevel/CAHk-=wiEBNFJ0_riJnpuUXTO7+_HByVo-R3pGoB_84qv3LzHxA@mail.gmail.com/">is
not a fan</a> of the plan to deprecate the <tt>AT_</tt> flags; he noted
that software will continue to use flags like <tt>O_NOFOLLOW</tt> or
<tt>AT_SYMLINK_NOFOLLOW</tt>, so they can't go away.  
He <a
href="/ml/linux-fsdevel/CAHk-=wiaL6zznNtCHKg6+MJuCqDxO=yVfms3qR9A0czjKuSSiA@mail.gmail.com/">added</a>:
<p>
<div class="BigQuote">
	And yes, the fact that we then have three different user-visible
	namespaces (O_xyz flags for open(), AT_xyz flags for linkat(), and
	now RESOLVE_xyz flags for openat2()) is sad and messy. But it's an
	inherent messiness from just how the world works. We can't get rid
	of it.
</div>
<p>
Adding multiple flags that do the same thing leads to complexity and
confusion, he said; one might thus conclude that any such patch is unlikely
to make it into the mainline.  He later <a
href="/ml/linux-fsdevel/CAHk-=wgu3Wo_xcjXnwski7JZTwQFaMmKD0hoTZ=hqQv3-YojSg@mail.gmail.com/">said</a>
that, if <tt>fsinfo()</tt> needs features controlled by both <tt>AT_</tt>
and <tt>RESOLVE_</tt> flags, it should accept both; that, along with the
flags specific to that system call, adds up to three different sets of
flags for one call.  One could reasonably conclude that if, for example,
<tt>openat2()</tt> were to implement a feature controlled by an
<tt>AT_</tt> flag, it would have to accept a third set of flags as well.
<p>
So the situation may indeed be "<q>sad and messy</q>", but it doesn't
appear that it will be getting any less messy anytime soon.  Perhaps one of
the messiest aspects of this API is that there is no type checking for any
of these flags fields.  Nothing but due care prevents a developer from
setting a flag in the wrong field.  That one may be hard to correct in a
backward-compatible way, even if somebody were to be motivated to do it.
It is not the biggest mess to be found in our APIs; we'll continue to
muddle on with things as they are.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls">System calls</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/815118/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor815139"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 1:15 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815139/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No doubt this sort of conflicting accretion of symbols and functionality is why Solaris eventually isolated its syscall interface with a shared library: possibility exists to support old code with compatibility versions while keeping kernel APIs flexible and cruft free.  Not that I've ever looked at the Solaris kernel APIs to see if cruft was actually reduced.<br>
<p>
Notionally also why the BSD executable versioning mechanism was introduced, although I don't know that that has ever been used as a mechanism to "tidy up" or unify older syscalls, rather than just providing OS emulation capabilities.  The possibility exists though.<br>
<p>
I like the way that the Rust (scheme) system handles language features and backwards compatibility: language version is an explicit part of the code preamble, which allows new code to link against old libraries without requiring the old libraries to be modified to match the current-version syntax or semantics.  Something that neither C++ or python have managed during their history.  All such a system requires is that whatever the new interfaces are, they must be capable of providing the original semantics somehow, so that the interface shim layer can re-implement the old API in terms of the new.  Clearly you want a modicum of stability too, to minimize the number of old shims that you have to maintain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815139/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 1:56 UTC (Tue)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/815140/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust also only supports static linking (simple C ABI interfaces notwithstanding), so as compared to C++ it's an easier problem space.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 2:19 UTC (Tue)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/815142/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust does dynamic linking (and not just C), the caveat I think is that the ABI is not stable between compiler releases.<br>
This is notably more unstable than the C++ ABI, which (visual studio excepted) only breaks for major events like the C++11 release.<br>
<p>
Afaik, Debian ships rust programs, and if I know anything about Debian packaging, static linking is not even close to being an option =]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 2:34 UTC (Tue)
                               by <b>Conan_Kudo</b> (subscriber, #103240)
                              [<a href="/Articles/815143/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Afaik, Debian ships rust programs, and if I know anything about Debian packaging, static linking is not even close to being an option =]</blockquote>

<p>Unfortunately, you'd be wrong. Debian ships packages with piles of source code, just as Fedora does. Applications statically link everything, because otherwise <i>every</i> rebuild of the compiler would necessitate rebuilding <i>everything</i>. It's just not practical. Maybe one day, the Rust community will care about us and <a href="https://github.com/rust-lang/rfcs/issues/600">work toward defining a native stable ABI</a>. But I won't hold my breath. The Rust community thinks it's okay to have to constantly build everything for every change, despite <a href="http://nibblestew.blogspot.com/2017/03/is-static-linking-solution-to-all-of.html">the <i>huge</i> downsides</a>.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/815143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 10:25 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/815166/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The stability of the C++ ABI also has massive downsides: <a href="https://cor3ntin.github.io/posts/abi/">https://cor3ntin.github.io/posts/abi/</a><br>
<p>
In theory we could escape the dilemma by creating a stable ABI for shared libraries that you opt into at build time that would mostly be only for Linux distros. But even that would constrain language and library evolution as well as being a ton of work that no-one is really motivated to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 11:53 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/815169/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is too many developers only develop to solve the immediate problem. Spend a bit of time to define the *general* problem, define a state table and design the API to solve said state table, and then by all means just solve your bit of it.<br>
<p>
That way, you can extend the function to fill the state table as and when, without having to redesign the interface.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor815245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 21:21 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/815245/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In theory we could escape the dilemma by creating a stable ABI for shared libraries </font><br>
<p>
COM solved that problem decades ago. We should seriously consider adopting something a lot like it. A stable object ABI that allows for both efficient intraprocess calling and extensible interprocess remoting is extremely powerful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 18, 2020 8:53 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/815275/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Lowest-common-denominator ABIs like COM are awful to work with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 18, 2020 11:07 UTC (Wed)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/815281/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We could manage versioning with a request broker*.<br>
"Do you speak the ABI of versions in this range?"<br>
"Not all of them, I can fall back to v.A.B.C as most recent. Is that OK?"<br>
"Confirmed OK."<br>
<p>
*: common object request broker isn't a model, it's an architecture ;-)<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor815247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 21:33 UTC (Tue)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/815247/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That "huge downsides" article is not entirely fair perhaps.<br>
<p>
Rust does link dynamically to libc, and many Rust programs link to e.g. OpenSSL because Rust has good support for using dynamically linked C libraries. In fact, there are dynamic libraries with a C ABI that are implemented in Rust (librsvg comes to mind).<br>
<p>
Rust has really good support for dynamic linking! It just doesn't have good support for dynamic linking using its *native ABI*. You could look at this as discouraging dynamic linking, but you can also look at it as encouraging dynamic linking that integrates well with the rest of the open source ecosystem by using the C ABI as a universal interface.<br>
<p>
Also, a ton of Rust code is just not desirable to dynamically link, ever. We could do a cute experiment and compile some popular Rust programs while absolutely forbidding the compiler to inline functions between different crates (i.e. "libraries"). Pretty sure that will cause a code size explosion and speed reduction that will make people scream a lot louder than using a couple more kb of disk space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 21:44 UTC (Tue)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/815248/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To clarify my point a bit more: the way native Rust APIs are written is just very different from how C APIs are written. Due to the rich type system you can have a lot more back-and-forth between a library and its consumers than you would have in a C API.<br>
<p>
Consider for example the Iterator trait in Rust. People expect code written using iterators to compile down to something that you would find hard to distinguish from a C for loop in disassembly, which requires the compiler to inline a whole bunch of calls to tiny functions and remove some intermediate values. And not all those tiny functions have to come from the same library, they can come from many different ones, and many will have generic arguments or callbacks with generic arguments from still other libraries.<br>
<p>
And it's not just Iterator, the same goes for asynchronous I/O using Futures, and probably more absolutely core functionality that I'm forgetting about right now. As soon as parts of that become dynamically linked, you start having to make some really tough calls about what the compiler can statically assume and optimize out.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 21:47 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815251/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agree completely.  You just beat me to it!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor815543"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2020 10:15 UTC (Fri)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/815543/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The rich type system also means that there are a lot of generic functions taking traits as inputs, which are not "real" types. So either you have a lot of monomorphization ("instantiation" in terms of C++ templates) where you substitute real types for the parameters, or you have dynamic dispatch, which is, well, akin to uncoditional surrender. Forcing dynamic linking also forces the latter, and this has huge impact on performance, maybe as much as impeded inlining has.<br>
<p>
(Disclaimer: I speak from theory, not practice, so I may be more than a little wrong :) )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815543/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor815249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 21:45 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815249/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In these days of flatpack and image-based application distribution, where applications ship with private versions of all of the shared libraries that they use, it's easy to argue that the days of shared libraries being particularly useful, at least for supposed benefits of disk space or memory space savings, are long gone.  From a language point of view, the model of separately compiled object files is too restrictive, and too much of a barrier to efficient abstraction.  Most modern languages have a whole-program compilation model, and that includes C++, except for the cases where modules effectively isolate themselves behind a C API.  (Go, rust, julia, haskell, all of the lisps...)<br>
I view this trend as a good thing, btw.  The modern languages have a lot going for them, and shared libraries really don't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor815147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 5:53 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/815147/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that these particular flags mirror the userspace. You will inevitably have the same mess _somewhere_, be it libc or the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 6:00 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815148/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, at the moment, but API versioning is the tool that you need in order to rationalize and tidy-up down the track, without breaking the code that will inevitably have been built against the current, messy set.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 6:18 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/815149/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is doable in Linux.<br>
<p>
You can create a set of new syscalls with sane flags: openat_rational, link_rational, open_I_really_mean_it's_not_broken_this_time and so on. You then expose these new syscalls with their wonderful flags through libc, libc can also provide their emulation for the older kernels that lack the new syscalls.<br>
<p>
Then after 20 years or so you can remove the old flags from libc, so that new code will be able to use the new flags. Then after another 10 years or so, the old syscalls can be removed from the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 6:29 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815150/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, but the Solaris and BSD versioned syscall approach allows you to remove the old syscalls and their messy flags immediately, reducing complexity, size and technical debt in the kernel.  For the extra win, the piece of libc code that has to provide the old API in terms of the new becomes a nice modular piece of API history that documents the change.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 6:33 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/815151/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yes, but the Solaris and BSD versioned syscall approach allows you to remove the old syscalls and their messy flags immediately</font><br>
How? There will still be software that uses old flags, for the foreseeable future. You'll have to provide their emulation _somewhere_.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 6:37 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/815152/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On BSD, the syscall interface is subject to change, while the libc interface is stable. So it'd be libc's job to implement the old interface in terms of the new one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 9:51 UTC (Tue)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/815162/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This means that BSD's libc is tied to the kernel. Linux' libc is not.<br>
<p>
A corollary is that statically-linked programs may or may not continue to work when you update your kernel, a notion which Linus emphatically rejects.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 10:25 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/815165/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree, and I prefer the Linux approach.<br>
<p>
That said, it'd be interesting if we had a slightly more extensible syscall layer that could tell when an argument was passed or not passed, which would allow existing existing syscalls without having to create new ones.<br>
<p>
It's looking increasingly like io_uring might be that extensible syscall layer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor815495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2020 20:55 UTC (Thu)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/815495/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, there is no such thing as "Linux's libc". There's glibc, bionic, uclibc, musl, klibc, and at least one language run-time (Go) that doesn't depend on a C library.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815803"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2020 15:27 UTC (Mon)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/815803/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; least one language run-time (Go) that doesn't depend on a C library.</font><br>
<p>
sometimes... would be nice if it never did but that is sadly not the case :/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815803/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor815153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 6:47 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815153/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The solaris model is that the syscall API is a shared object (along with the rest of libc).  User-space code doesn't get to make syscalls at all.  The libc shared library can be versioned and indeed multiple, so you can (theoretically) keep older cruftier ones only as long as you have any executables that need them, on an install-by-install basis.  I believe that OpenBSD is considering a similar scheme in order to have some sort of protection about where syscalls can come from, to prevent trampoline and gadget-style malware, perhaps.<br>
<p>
The BSD versioned syscalls are in the kernel (so you can still have static executables), but they can be supplied by loadable kernel modules (as the linux and SCO syscalls are/were), which can eventually be deprecated or not loaded as suits the use-case, without getting (too much) in the way of the "fresh" syscall API.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 6:53 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/815155/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The solaris model is that the syscall API is a shared object</font><br>
<p>
How does Solaris provide that to userspace? Similar to the VDSO, or via a library provided on the filesystem that calls an unstable kernel interface?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 7:41 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815158/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm afraid that I don't know.  I had always assumed that it was a specially-blessed user-space library provided by the filesystem.  I'm sure there are readers who know more about Solaris than I do (it wouldn't be hard).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 18, 2020 21:37 UTC (Wed)
                               by <b>justincormack</b> (subscriber, #70439)
                              [<a href="/Articles/815360/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes it was just a normal library - you could make syscalls elsewhere but they were neither documented or stable.<br>
<p>
OpenBSD has been taking this model to a more modern design, where libc is blessed, and only it can make syscalls, by having a special attribute set. This is designed as a security measure, to stop arbitrary code using syscalls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor815156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 7:02 UTC (Tue)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/815156/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was wondering why commenters were talking about rust but then I noticed that I mis-typed.  Rust isn't a (scheme)!  I meant racket of course.  Sorry for the confusion!<br>
<p>
I know that rust is versioning its releases too, but I don't know whether that actually allows for the linking and use of code written against different language versions, the way racket does.  Racket code can import and use r5rs or r6rs or experimental-dialect code, which is cool.  I suppose that C++ can do similarly for separately compiled object files, but it can't include old headers into new code, and python3 can't import python2 modules, which IMO is a terrible shame.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 15:15 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/815205/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>The equivalent in Rust is Editions; you can freely link code between different editions (currently only 2015 and 2018), but the compiler will translate each translation unit (crate in Rust) according to the edition you have specified for that crate.
<p>Nothing, however, stops a Rust 2015 crate using a Rust 2018 crate as a dependency, or vice-versa, and you can freely share data types between the two editions. The only problem is that you might have to use r#identifier syntax if one crate uses a reserved word as an identifier.
      
          <div class="CommentReplyButton">
            <form action="/Articles/815205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor815167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 10:42 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/815167/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW rr benefits enormously from the "stable kernel ABI" being the syscall interface. The same is true for strace and other tools that monitor and manipulate the user/kernel interface.<br>
<p>
If stability guarantees applied at a shared library boundary like Solaris and Windows, then rr would have to choose between manipulating the unstable syscall interface or manipulating the shared library interface. The former would increase the rr maintenance burden considerably since we'd have to support every version of the syscall interface. The latter is difficult to do in a watertight way. Similar considerations would apply to strace etc.<br>
<p>
I think it's also a great feature to have your stable ABI boundary enforced by hardware. On Windows people reverse engineer the syscalls and sometimes call them directly, bypassing the "stable ABI"; it's great that on Linux you simply *can't* bypass it.<br>
<p>
Hardware being aware of the ABI boundary has other more esoteric benefits. For example rr needs to count performance events happening outside "the kernel"; on Linux the CPU supports us doing that, but on Windows/Solaris it doesn't if you consider that shared library to be "the kernel".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 21:21 UTC (Tue)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/815244/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I heard kernel can inject some code into userspace. I don't know the details, but the keyword is vdso -- I think kernel hackers here know much more about it than I do.<br>
<p>
Wouldn't presence of vdso pose the same problem as the stability guarantee applied at shared library boundary?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 18, 2020 8:54 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/815276/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
rr patches the VDSO to just do direct syscalls. It's as if the VDSO wasn't there.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor815228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 18:42 UTC (Tue)
                               by <b>ale2018</b> (guest, #128727)
                              [<a href="/Articles/815228/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I would have said that the situation would look less messy if similar flags were set at the same bit.  Having 64-bit flags seems to allow it.  Hmm...

<pre>
/usr/include/linux/fcntl.h:#define AT_SYMLINK_NOFOLLOW	0x100   /* Do not follow symbolic links.  */
/usr/include/asm-generic/fcntl.h:#define O_NOFOLLOW	00400000	/* don't follow links */
/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h:# define AT_SYMLINK_NOFOLLOW	0x100	/* Do not follow symbolic links.  */
/usr/include/x86_64-linux-gnu/sys/mount.h:  UMOUNT_NOFOLLOW = 8		/* Don't follow symlink on umount.  */
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/815228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem-oriented flags: sad, messy and not going away</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2020 12:43 UTC (Fri)
                               by <b>draco</b> (subscriber, #1792)
                              [<a href="/Articles/815554/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If they weren't done that way from the start, then that's an ABI change, which isn't allowed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
