        <!DOCTYPE html>
        <html lang="en">
        <head><title>Introducing io_uring_spawn [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/908268/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/908081/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/908268/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Introducing io_uring_spawn</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jake Edge</b><br>September 20, 2022</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2022-Linux_Plumbers_Conference">LPC</a>
</div>
<p>
The traditional mechanism for launching a program in a new process on Unix
systems—forking and execing—has been with us for decades, but it is not
really the most efficient of operations.  Various alternatives have been
tried along the way but have not supplanted the traditional approach.  A new
mechanism created by Josh Triplett adds process creation
to the <a href="/Articles/776703/">io_uring asynchronous I/O API</a> and
shows great promise; he came to the <a href="https://lpc.events/">2022
Linux Plumbers Conference</a> (LPC) to introduce io_uring_spawn.
</p>

<p>
Triplett works in a variety of areas these days, much of it using the Rust
language, though he has also been working on the kernel some of late.  He 
is currently working on build systems as well.  Build systems are notorious
for spawning lots of processes as part of their job, "so I care about
launching processes quickly".   As with others at this year's LPC, Triplett
said that he
was happy to see a return to in-person conferences.
</p>

<h4>Spawning a process</h4>

<p>
He began with a description of how a Unix process gets started.  There are
a number of setup tasks that need to be handled before a new process gets
executed; these are things like setting up file descriptors and
redirection, setting process 
priority and CPU affinities, dealing with signals and masks, setting user
and group IDs, 
handling namespaces, and so on.  There needs to be code to do that setup,
but where 
does it come from?
</p>

<a href="/Articles/908815/">
<img src="https://static.lwn.net/images/2022/lpc-triplett-sm.png" border=0 hspace=5 align="right"
alt="[Josh Triplett]" title="Josh Triplett" width=236 height=280>
</a>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
The setup code for the traditional <a
href="https://man7.org/linux/man-pages/man2/fork.2.html"><tt>fork()</tt></a>
and exec (e.g. <a
href="https://man7.org/linux/man-pages/man2/execve.2.html"><tt>execve()</tt></a>)
approach must be placed in 
the existing process.  <tt>fork()</tt> duplicates
the current process into a second process that is a
copy-on-write version of the original; it does not copy the memory of the
process, just the page metadata.  Then exec "will promptly throw away that
copy and replace it with a new program; if that sounds slightly wasteful,
that's because it's slightly wasteful".
</p>

<p>
He wanted to measure how expensive the fork-and-exec mechanism actually is;
he described the benchmarking tool that he would be using for the tests in
the talk.  The test creates a pipe, reads the start time from the system,
then spawns a child process using 
whichever mechanism is under test; the exec of the child uses a path
search to find the binary in order to make it 
more realistic.  The child simply writes the end time to the pipe and
exits, using a small bit of optimized assembly code.  
</p>

<p>
The parent blocks waiting to read the end time from the pipe, then
calculates the time spent.  It does that 2000 times and reports the lowest
value; the minimum is used because anything higher than that is in some
fashion overhead that he wants to eliminate from his comparison.
The intent is to
capture the amount time between the start of the spawn
operation and the first instruction in the new process.  Using that, he
found that <tt>fork()</tt> and exec used 52µs on his laptop.
</p>

<p>
But that is just a baseline for a process without much memory.  If the
parent allocates 1GB, the cost goes up a little bit to 56.4µs.  But it
turns out that Linux has some "clever optimizations" to handle the common
case where processes allocate a lot more memory than they actually use. If
the parent process touches all of the 1GB that it allocated, things get
much worse, though: over 7500µs (or 7.5ms)
</p>

<p>
There are more problems with <tt>fork()</tt> beyond just performance,
however.  For example, "<tt>fork()</tt> interacts <i>really</i> badly with
threads"; any locks held by other threads will remain held in the child
forever.  The <tt>fork()</tt> only copies the current thread, but copies
all of the memory, which could contain locked locks; calling almost any C
library function could then simply deadlock, he said.
</p>

<p>
There is a list of safe
C library functions in the <a
href="https://man7.org/linux/man-pages/man7/signal-safety.7.html"><tt>signal-safety</tt>
man page</a>, but it lacks some expected functions such as <a
href="https://man7.org/linux/man-pages/man2/chroot.2.html"><tt>chroot()</tt></a>
and <a
href="https://man7.org/linux/man-pages/man3/setpriority.3p.html"><tt>setpriority()</tt></a>.
So if you fork a multi-threaded process, you cannot safely change its root
directory or set its priority; "let alone things like setting up
namespaces", he said.  Using <tt>fork()</tt> is just not a good option for 
multi-threaded code.
</p>

<p>
"As long as we are talking about  things that are terribly broken, let's
talk about <a
href="https://man7.org/linux/man-pages/man2/vfork.2.html"><tt>vfork()</tt></a>".
Unlike <tt>fork()</tt>, <tt>vfork()</tt> does not copy the current process
to the child process, instead it "borrows" the current process.  It is,
effectively creating an unsynchronized thread as the child, which runs
using the same stack as the parent.
</p>

<p>
After the <tt>vfork()</tt>
call, the child can do almost nothing: it can exec or exit—"that's the
entire list".  It cannot write to any memory, including the local stack
(except for single process ID value),
and cannot return or call anything.  He rhetorically wondered what happens
if the child happens to receive a signal; that is "among the many things
that can go horribly wrong".  Meanwhile, it does not provide
any means for doing the kind of setup that might be needed for a new process.
</p>

<p>
So given that <tt>vfork()</tt> is broken, he said, 
"let's at least hope it's broken and fast".  His benchmark shows that it
is, in fact,
fast, coming in at 31.5µs for the base test and there is only a tiny
increase, to 31.9µs, for allocating and accessing 1GB.  That makes sense
because <tt>vfork()</tt> is not copying any of the process memory or metadata.
</p>

<p>
Another option is <a
href="https://man7.org/linux/man-pages/man3/posix_spawn.3.html"><tt>posix_spawn()</tt></a>,
which is kind of like a safer <tt>vfork()</tt> that combines process
creation and exec all in one call.  It does provide a set of
parameters to create a new process with certain attributes, but
programmers are limited to that set; if there are other setup options
needed, <tt>posix_spawn()</tt> is not the right choice.  It has performance
in between <tt>vfork()</tt> and <tt>fork()</tt> (44.5µs base); as with
<tt>vfork()</tt>, there is almost no penalty for allocating and accessing
1GB (44.9µs). 
</p>

<p>
The main need for a copy of the original process is to have a place where
the configuration code for the new process can live.  <tt>fork()</tt>,
<tt>vfork()</tt>, and <tt>posix_spawn()</tt> allow varying amounts of
configuration for the new process.  But a more recent kernel development
provides even more flexibility—and vastly better performance—than any of
the other options.
</p>

<h4>Enter io_uring</h4>

<p>
The io_uring facility provides a mechanism for user space to communicate
with the kernel through two shared-memory ring buffers, one for submission
and another 
for completion.  It is similar to the
<a href="https://en.wikipedia.org/wiki/NVM_Express">NVMe</a> and <a
href="https://www.linux-kvm.org/page/Virtio">Virtio</a> protocols. Io_uring 
avoids the overhead of entering and exiting the kernel for every operation
as a system-call-based approach would require; that's always been a
benefit, but the additional cost imposed by  speculative-execution
mitigations makes avoiding system calls even more attractive.  
</p>

<p>
In addition, io_uring
supports linked operations, so that the outcome of one operation can affect
further operations in the submission queue.  For example, a read operation
might depend on a successful file-open operation. These links form chains
in 
the submission queue, which serialize the operations in each chain.  There
are two kinds of 
links that can be established, a regular link where the next operation (and
any subsequent operations in the chain) will not be performed if the
current operation fails, or a "hard" link that will continue performing
operations in the chain, even when there are failures. 
</p>

<p>
So, he asked, what if we used io_uring for process setup and launch?  A
ring of linked operations to all be performed by the kernel—in the
kernel—could take care of the process configuration and then launch the new
process.  When the new process is ready, the kernel does not need to return
to the user-space process that initiated the creation, thus it does not
need to throw away a bunch of stuff that it had to copy as it would with
<tt>fork()</tt>. 
</p>

<p>
To that end, he has added two new io_uring
operations. <tt>IORING_OP_CLONE</tt> creates a new task, then runs a series
of linked operations in that new task in order to configure it;
<tt>IORING_OP_EXEC</tt> will exec a new program in the task and if that is
successful it skips any subsequent operations in the ring.  The two
operations are independent, one can clone without doing an exec, or replace
the current program by doing an exec without first performing a clone.  But
they are meant to be used together.
</p>

<p>
If the chain following an <tt>IORING_OP_CLONE</tt> runs out of ring
operations to perform, the process is killed 
with <tt>SIGKILL</tt> since there is nothing for that process to do at that
point.  It is important to stop processing any further
operations after a successful exec, Triplett said, or a trivial security
hole can be created; if there are operations on the ring after an exec of a
setuid-root program, for example, they would be performed with elevated
privileges. If the exec operation fails, though, hard links will still be
processed; doing a path search for an executable is likely to result in
several failures of this sort, for example.
</p>

<h4>Beyond performance</h4>

<p>
There are advantages to this beyond just performance.  Since there is no
user space involved, the mechanism bypasses the C library wrappers and
avoids the 
"user-space complexity, and it is considerable", especially for
<tt>vfork()</tt>. Meanwhile, the problems with spawning from multi-threaded
programs 
largely disappear. He showed a snippet of code that uses <a
href="https://github.com/axboe/liburing">liburing</a> to demonstrate that
the combination "makes this remarkably simple to do".  That example can be
seen on slide&nbsp;55 of his <a
href="https://lpc.events/event/16/contributions/1213/attachments/1012/1945/io-uring-spawn.pdf">slides</a>,
or in the <a href="https://youtu.be/_h-kV8AYYqM?t=4104">YouTube video</a>
of the talk.
</p>

<p>
Because he had been touting the non-performance benefits of using io_uring
to spawn new programs, perhaps some in the audience might be thinking that
the performance was not particularly good, he said.  That is emphatically
not the 
case; "actually it turns out that it is faster across the board".  What he
is calling "io_uring_spawn" took 29.5µs in the base case, 30.2µs with 1GB
allocated, and 28.6µs with 1GB allocated and accessed.
</p>

<p>
That is 6-10% faster than <tt>vfork()</tt> and 30+% faster than
<tt>posix_spawn()</tt>, while being much safer, easier to use, and allowing
arbitrary 
configuration of the new process. "This is the fastest available way to
launch a process now."
</p>

<p>
"Now" should perhaps be in quotes, at least the moment, as he is working
with io_uring creator Jens Axboe to get the feature upstream.  Triplett
still needs to clean up the code some and they need to decide where the
right stopping point, between making it faster and getting it upstream,
lies.  The development of the feature is just getting started at this
point, he said; there are multiple opportunities for optimization that
should provide even better performance down the road.
</p>

<h4>Next steps</h4>

<p>
He has some plans for further work, naturally, including implementing
<tt>posix_spawn()</tt> using io_uring_spawn.  That way, existing
applications could get a 30% boost on their spawning speed for free.  He
and Axboe are working on a pre-spawned process-pool feature that would be
useful for applications that will be spawning at least a few processes over
their lifetime.  The pool would contain "warmed up" processes that could be
quickly used for an exec operation.
</p>

<p>
The clone operation could also be optimized further, Triplett thinks.
Right now, it uses all of the same code that other kernel clone operations
use, but a more-specialized version may be in order; it may make sense to
reduce the amount of user-space context that is being created since it is
about to be thrown away anyway.  He would also like to experiment with
creating a process from scratch, rather than copying various pieces from
the existing process; the io_uring pre-registered file descriptors could be
used to initialize the file table, for example.
</p>

<p>
Triplett closed his talk with a shout-out to Axboe "who has been incredibly
enthusiastic about this".  Axboe has been "chomping at the bit to poke at it
and make it faster".  At some point, Triplett had to push back so that he
had time to write the talk; since that is now complete, he expects to get
right back into improving io_uring_spawn.  He is currently being <a
href="https://github.com/sponsors/joshtriplett">sponsored on GitHub</a> for
io_uring_spawn, Rust, and build systems; he encouraged anyone interested in
this work to get in touch.
</p>

<p>
After a loud round of applause, he took questions.  Christian Brauner said
that systemd is planning to use io_uring more and this would fit in well;
he wondered if there was a plan to add support in io_uring for additional
system calls that would be needed for configuring processes.  Triplett said
that he was in favor of adding any system call needed to io_uring, but he
is not the one who makes that decision. "I will happily go on record as
saying I would love to see a kernel that has exactly two system calls:
<tt>io_uring_setup()</tt> and <tt>io_uring_submit()</tt>."
</p>

<p>
Kees Cook asked how Triplett envisioned io_uring_spawn interacting with Linux
security modules (LSMs) and <a
href="https://man7.org/linux/man-pages/man2/seccomp.2.html"><tt>seccomp()</tt></a>.
Triplett said that it would work as well as io_uring works with those
security technologies today; if the hooks are there and do not slow down
io_uring, he would expect them to keep working. Paul Moore noted some of
the <a href="/Articles/902466/">friction</a> that occurred when the
command-passthrough feature was added to io_uring; he asked that the LSM mailing
list be copied on the patches.
</p>

<p>
A remote attendee asked about io_uring support for <a
href="https://criu.org/Main_Page">Checkpoint/Restore in Userspace</a>
(CRIU).  Axboe said that there is currently no way for CRIU to gather up
in-progress io_uring buffers so that they can be restored; that is not a
problem specific to io_uring_spawn, though, Triplett said.
Brauner noted
that there is a Google Summer of Code project to add support for io_uring
to CRIU if anyone is
interested in working on it.
</p>

<p>
Brauner asked about whether the benchmarks included the time needed to set
up the 
ring buffers; Triplett said that they did not, but it is something that is
on his radar for the upstream submission.  It is not likely to be a big win
(or, maybe, a win at all) for a process that is just spawning one other
process, but for programs like <tt>make</tt>, which spawn a huge number of
other 
programs, the ring-buffer-creation overhead will fade into the noise.
</p>

<p>
[I would like to thank LWN subscribers for supporting my travel to Dublin
for Linux Plumbers Conference.]
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2022">Linux Plumbers Conference/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/908268/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor908819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2022 22:15 UTC (Tue)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/908819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aha! Sounds bloody good and interesting! Thank you so much for putting the extra mile to make life easy for others. Kudo Josh ...keep it rolling, man.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2022 22:30 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/908821/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Kees Cook asked how Triplett envisioned io_uring_spawn interacting with Linux security modules (LSMs) and seccomp().</font><br>
<p>
Following up on this more concretely, there were several more conversations at LPC about how seccomp and io_uring can interact. io_uring already has a mechanism for self-imposed restrictions on an io_uring; a first pass would be to externally impose those restrictions on a process. That would provide maximum performance for the common cases. Then, on top of that, we could use seccomp to further restrict specific operations, such as opening files or execing processes.<br>
<p>
In that regard, I hope that io_uring can do *better* with seccomp than existing syscalls do. Traditionally in seccomp it has been difficult to enforce restrictions on userspace pointers, without providing userspace helpers. But io_uring normally copies arguments from userspace to the kernel when preparing to run an operation, *before* actually running the operation. That would make it easier for a seccomp filter to filter those arguments in a race-free manner.<br>
<p>
I&#x27;m hopeful that we can build a robust and comprehensive security solution for io_uring without sacrificing performance to do so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 2:05 UTC (Wed)
                               by <b>gutschke</b> (subscriber, #27910)
                              [<a href="/Articles/908830/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am so excited about this work. In a previous life, I had to write code that provided a library function to reliably spawn subprocesses from arbitrary user space contexts and allowed for a lot more complex initialization than what posix_spawn() can do. And the more I looked into things, the more painful it got.<br>
<p>
Race conditions with regards to file handles are of course a well-understood problem. They can result in pipes accidentally being kept open when the application expects them to be closed; and that can break event loops in surprising ways. This can happen if two parts of the application try to spawn at the same time, and in principle that&#x27;s possible even without having threads. All it takes is a signal handler. And you never know when those are present, as libraries can set their own signal handlers. CLOEXEC can partially mitigate this situation, but isn&#x27;t a complete solution.<br>
<p>
But fortunately, by creating pipes in the child and then passing only one end back to the parent, this issue can generally be avoided. Tricky. Subtle. But solvable without having to resort to black magic.<br>
<p>
Maybe, forking from a signal context is crazy talk and shouldn&#x27;t be supported, but that still leaves threads. And annoyingly, there was simply no way to avoid the presence of threads; and those potentially result in even more subtle issues. Even if you fork&#x27;d a helper process early on, a constructor in a randomly loaded dependency could very well have started threads already. This means, you don&#x27;t get around dealing with the whole mess of orphaned thread locks in the child. Glibc tries to do the right thing, but I couldn&#x27;t convince myself that it would always work 100%.<br>
<p>
So, direct system calls it is. By avoiding all calls into Glibc, we can avoid accidentally blocking on a stale thread lock. Writing this type of code is tedious, but since all that nastiness is hidden in a library, hopefully it isn&#x27;t too offensive. Only, closer inspection of Glibc shows that a bunch of system calls have wrappers, and some of these wrappers can cause issues too. That means, we are now committed to maintaining our own system call library, avoiding Glibc&#x27;s implementation altogether.<br>
<p>
And just when we think we are finally done, the dynamic linker rears its ugly head. A lot of symbols won&#x27;t get resolved until needed, and of course the dynamic linker has its own set of locks and file descriptors that we don&#x27;t control. So, now we need to worry about not invoking the linker from the fork&#x27;d process.<br>
<p>
These are just the major pain points that I remember from working on this code some 10 years ago. I am sure there is more and I have suppressed the memory. Spawning a process with 99% reliability is easy and a lot of the complexity in my code was very rarely needed; but 100% reliable spawning is tough. Fork()/exec() was a great model in the early days of UNIX, but it all came crashing down when threads showed up. Posix_spawn() is a fine alternative, if you don&#x27;t need particularly complex initialization of the child&#x27;s environment. But unfortunately, that wasn&#x27;t an option for us.<br>
<p>
I so love the idea of side-stepping all the problems that are caused by undefined global state in the child; moving processing out of user space and into the kernel is brilliant. That&#x27;s such an elegant solution that gets rid of the entire class of potential problems.<br>
<p>
So, while the performance benefits are very welcome, the improvements in reliability and reduction in API complexity has me the most excited. Can&#x27;t wait to follow progress on this API and see what other system calls will be made available from within io_uring.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 15:04 UTC (Wed)
                               by <b>wilevers</b> (subscriber, #110407)
                              [<a href="/Articles/908920/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent summary confirming my experience... Thanks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor910494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2022 13:25 UTC (Thu)
                               by <b>Shabbyx</b> (guest, #104730)
                              [<a href="/Articles/910494/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I sure hope you had turned all those issues you had found into tests that continue to run somewhere.<br>
<p>
Otherwise, there&#x27;s no guarantee the new implementation isn&#x27;t secretly suffering from some of the same problems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 15:30 UTC (Wed)
                               by <b>kees</b> (subscriber, #27264)
                              [<a href="/Articles/908922/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the performance side, Josh and I also carved off like 20% start time for path searches by moving the &quot;open&quot; during execve(2) earlier:<br>
<a href="https://lore.kernel.org/lkml/202209161637.9EDAF6B18@keescook/">https://lore.kernel.org/lkml/202209161637.9EDAF6B18@keesc...</a><br>
<p>
I&#x27;m hoping we can do some more perf examination to check &quot;normal&quot; workloads too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2022 22:37 UTC (Tue)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908823/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is so cool! Everything about io_uring (including the name) just brings a big smile to my face. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vfork is not so encumbered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 2:22 UTC (Wed)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/908829/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      &gt; <tt>After the vfork() call, the child can do almost nothing: it can exec or exit—"that's the entire list". It cannot write to any memory, including the local stack (except for single process ID value), and cannot return or call anything.</tt>
<p>That is an exaggeration.  Counterexample: this works on fedora 5.17.12-100.fc34.x86_64, at least if stderr (fd 2) is a tty:
<pre>
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
    if (0==vfork()) {
        char msg[]= "hello\n";
        exit(write(2, msg, -1+ sizeof(msg)));
    }
    else {
        char msg[] = "goodbye\n";
        exit(write(2, msg, -1+ sizeof(msg)));
    }
}
</pre>
and <tt>strace -f</tt> proves:
<pre>
vfork(strace: Process 119381 attached
 &lt;unfinished ...&gt;
[pid 119381] write(2, "hello\n", 6hello
)     = 6
[pid 119381] exit_group(6)              = ?
[pid 119380] &lt;... vfork resumed&gt;)       = 119381
[pid 119381] +++ exited with 6 +++
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=119381, si_uid=1000, si_status=6, si_utime=0, si_stime=0} ---
write(2, "goodbye\n", 8goodbye
)                = 8
exit_group(8)                           = ?
</pre>
<p>The child of <tt>vfork()</tt> can do anything as long as it recognizes that side effects (in both user and kernel space) affect both child and parent.


      
          <div class="CommentReplyButton">
            <form action="/Articles/908829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vfork is not so encumbered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 22:45 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/908945/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not about what strace sees, it&#x27;s about what happens entirely within userspace. Because both processes share the same memory, including the stack, if your compiler decides to spill any registers to the stack or modify memory for any other reason, it will corrupt the parent process. In this relatively simple example, the compiler likely has no need to write to memory before calling the syscalls you specify.<br>
<p>
I believe it is accurate to say that the child of vfork can make any (raw) syscalls, modify registers, and read from memory, as long as it does not write to memory in a way incompatible with the parent process. But this is an impossible constraint to express in C.<br>
<p>
(Relatedly, the list of async-signal-safe functions is a list of async-signal-safe C library functions, not syscalls. All raw syscalls are async-signal-safe, because they are atomic and reentrant from the point of view of userspace; you just might struggle to actually call them.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vfork is not so encumbered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2022 10:35 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/908987/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; if your compiler decides to spill any registers to the stack or modify memory for any other reason, it will corrupt the parent process.</font><br>
<p>
Why do you think that?  The child is free to do whatever it likes below the initial stack pointer (just like a signal handler might).  It can even modify any other memory providing that it it leaves it in a consistent state.  So printf() should be fine.<br>
<p>
This line in the article:<br>
<p>
<font class="QuotedText">&gt; It is, effectively creating an unsynchronized thread as the child</font><br>
<p>
is incorrect.  The child IS synchronised.  To quote from the fine man page:<br>
<p>
<font class="QuotedText">&gt;       vfork() differs from fork(2) in that the calling  thread  is  suspended</font><br>
<font class="QuotedText">&gt;       until  the  child  terminates (either normally, by calling _exit(2), or</font><br>
<font class="QuotedText">&gt;       abnormally, after delivery of a fatal signal), or it makes  a  call  to</font><br>
<font class="QuotedText">&gt;       execve(2)</font><br>
<p>
&quot;suspended&quot; is a form of synchronisation and ensures, for example, and the caller doesn&#x27;t do anything to any of the stack below the stack pointer.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vfork is not so encumbered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2022 14:44 UTC (Thu)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/909083/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think theoretically compiler could potentially see that in if(vfork()==0){} branch that if it were to not return (say, it would eventually call either exec or exit()), it could reuse stack variables of something that the function would use later (outside that if())<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vfork is not so encumbered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2022 21:48 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/909380/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If that is the case, it would be hard to argue that doing *anything* after vfork()==0 is safe.<br>
Maybe the best advice is to put such code into a separate .c file, and build that file with &#x27;-O0&#x27;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor910676"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vfork is not so encumbered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2022 7:55 UTC (Sun)
                               by <b>izbyshev</b> (subscriber, #107996)
                              [<a href="/Articles/910676/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with clobbering local variables is solved by special-casing vfork() (and setjmp(), which has similar issues) in compilers. GCC and Clang have __attribute__(( returns_twice)) to express that[1].<br>
<p>
[1] <a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attrib...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910676/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">remember debugging</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 2:31 UTC (Wed)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/908831/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <tt>strace -f</tt>, which follows all descendant processes, must give meaningful output.  Similarly, <tt>(gdb) set follow-fork-mode child</tt> must allow interception in the context of a descendant, but before the first instruction is executed.


      
          <div class="CommentReplyButton">
            <form action="/Articles/908831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor910680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">remember debugging</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2022 12:47 UTC (Sun)
                               by <b>izbyshev</b> (subscriber, #107996)
                              [<a href="/Articles/910680/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I second this. ptrace() has a synchronous interface for clone() notifications (used by strace, debuggers, etc.) consisting of two parts:<br>
<p>
* PTRACE_EVENT_CLONE is reported for the parent thread after the child process has been waken up. Given that IORING_OP_CLONE is executed asynchronously, who reports it, if at all? The kernel worker thread instead of the real parent thread? If so, is there a simple way to get the real parent (without looking in /proc, if it has been filled at this point at all)?<br>
<p>
* The child process starts with either SIGSTOP or PTRACE_EVENT_STOP, depending on the ptrace mode. Given that the process created by IORING_OP_CLONE never returns to userspace before IORING_OP_EXEC, what happens to this notification? <br>
<p>
I couldn't find io_uring_spawn patches on the net to check any of this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908846"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 8:09 UTC (Wed)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/908846/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Anyone recall this <a href="https://lwn.net/Articles/785430/">Microsoft Research: A fork() in the road</a>? 
<br>
The conclusions aren't the same but neither are the motivations (IMHO), and it's still interesting to note the parallels. 




      
          <div class="CommentReplyButton">
            <form action="/Articles/908846/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 16:12 UTC (Wed)
                               by <b>ma4ris5</b> (guest, #151140)
                              [<a href="/Articles/908924/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The comments in the lwn mention are still relevant:<br>
<p>
epa suggests, that launching other process should provide mechanism to close unlisted file descriptors.<br>
mm7323 mentions then, that opening /proc/self/fd (after vfork()) would enable efficient way of doing that. Also valgrind fds are mentioned.<br>
<p>
With threads, all kinds of unknown things happen, including race conditions with open() and &quot;CLOEXEC&quot;, so posix_spawn() lacks flag to prevent those race conditions by closing the unrelated fds before exec.<br>
<p>
io_uring implementation would need similar implementation to be robust,<br>
so that intermediate process, which does the file descriptor clean up after exec(), wouldn&#x27;t be needed.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor910677"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2022 8:23 UTC (Sun)
                               by <b>izbyshev</b> (subscriber, #107996)
                              [<a href="/Articles/910677/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; With threads, all kinds of unknown things happen, including race conditions with open() and "CLOEXEC", so posix_spawn() lacks flag to prevent those race conditions by closing the unrelated fds before exec.</font><br>
<p>
Modern glibc has posix_spawn_file_actions_addclosefrom_np().<br>
<p>
See also the thread at <a href="https://www.openwall.com/lists/libc-coord/2022/01/24/7">https://www.openwall.com/lists/libc-coord/2022/01/24/7</a> <br>
<p>
AFAIK POSIX resists standardization of such functionality because it could interfere with "private" descriptors used by the implementation.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910677/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor912080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2022 2:34 UTC (Sun)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/912080/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; launching other process should provide mechanism to close unlisted file descriptors</span><br>
<p>
I can see the utility of this if you're trying to set up a constrained environment like a sandbox or container, but IMHO closing file descriptors your process didn't open would be a mistake in the general case. You can't be certain the subprocess won't need them. Even if you control the subprocess and know exactly which paths it accesses (so you can rule out a user-specified reference to /dev/fd/N), consider the possibility of something like an LD_PRELOAD library making use of an inherited file descriptor identified through an environment variable you know nothing about.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/912080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor909175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 10:24 UTC (Fri)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/909175/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m starting to feel like this is one possible future:<br>
<p>
<a href="https://medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e">https://medium.com/wasmer/running-webassembly-on-the-kern...</a><br>
<p>
Also this presentation might be relevant: <a href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript">https://www.destroyallsoftware.com/talks/the-birth-and-de...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">glibc implementation of posix_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2022 14:34 UTC (Wed)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/908915/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some references on problems glibc had with vfork() for posix_spawn():<br>
<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=14750">https://sourceware.org/bugzilla/show_bug.cgi?id=14750</a><br>
<a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=9ff72da471a509a8c19791efe469f47fa6977410">https://sourceware.org/git/?p=glibc.git;a=commit;h=9ff72d...</a><br>
<a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=ccfb2964726512f6669fea99a43afa714e2e6a80">https://sourceware.org/git/?p=glibc.git;a=commit;h=ccfb29...</a><br>
<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/spawni.c;hb=HEAD#l31">https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/...</a><br>
<p>
The tl;dr is that glibc switched from using vfork() internally for posix_spawn() to using clone(CLONE_VM | CLONE_VFORK) with a separate stack allocated for the child and masking signals.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor910678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">glibc implementation of posix_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2022 8:34 UTC (Sun)
                               by <b>izbyshev</b> (subscriber, #107996)
                              [<a href="/Articles/910678/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
clone(CLONE_VM | CLONE_VFORK) is exactly equivalent to vfork(), except that it allows the caller to provide a separate stack instead of borrowing the stack of the parent thread. So the only problem the vfork-to-clone migration supposedly solved is compiler bugs with handling local variables across vfork().<br>
<p>
The need for blocking signals applies to both clone(CLONE_VM | CLONE_VFORK) and vfork().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2022 10:57 UTC (Thu)
                               by <b>jpfrancois</b> (subscriber, #65948)
                              [<a href="/Articles/908990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
About that fork with threads thing. The proposed feature is fine for fork + play with fd + exec, but for a classic fork (ie same semantic, but implemented using io_uring_spawn) the issue stays the same, or am I missing something ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor909340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2022 23:43 UTC (Sat)
                               by <b>tullmann</b> (subscriber, #20149)
                              [<a href="/Articles/909340/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another use case for a spawn-without-fork approach is when you need to spawn a new process from a very large parent process.  If the parent (say a large multi-media authoring app) is a significant fraction of system memory, a fork can fail (because the clone also has a significant memory/filedescriptor footprint), even if you just mean to spawn a tiny application with exec immediately after the fork.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909356"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2022 10:41 UTC (Sun)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/909356/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can normally just use vfork. <br>
<p>
If vfork is unsuitable for some reason it is still possible to avoid this issue with CLONE_VM, but it is somewhat annoying. <br>
<p>
E.g: <br>
<p>
void target_function() {<br>
  exec(...) <br>
}<br>
<p>
char *stack = malloc(65536)<br>
int pid = clone(target_function, stack, CLONE_VM, 0);<br>
<p>
You can free or reuse the stack after target_function has called exec, but the annoyance is knowing when exactly that has happened. <br>
<p>
Probably the easiest is to set up a pipe and set the filedescriptor to close-on-exec in the child and check for this in the parent. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909356/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor910679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2022 9:02 UTC (Sun)
                               by <b>izbyshev</b> (subscriber, #107996)
                              [<a href="/Articles/910679/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Using clone(CLONE_VM) is much more dangerous than vfork(). If you do that, you are completely on your own.<br>
<p>
* In older glibc it would trash the parent pid/tid cache (while vfork() wouldn't)[1].<br>
* You need to care about the direction of stack growth, and you code example is actually wrong because of that (the stack grows down on all currently alive arches).<br>
* You need to care about whether the stack pointer is aligned according to the ABI[2].<br>
* You might discover that clone() doesn't exists anymore, but you need to use clone3(), as almost happened for LoongArch[2].<br>
<p>
[1] <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=19957">https://sourceware.org/bugzilla/show_bug.cgi?id=19957</a><br>
[2] <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=27902">https://sourceware.org/bugzilla/show_bug.cgi?id=27902</a><br>
[3] <a href="https://www.openwall.com/lists/musl/2022/05/12/1">https://www.openwall.com/lists/musl/2022/05/12/1</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor919401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Introducing io_uring_spawn</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 11:58 UTC (Mon)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/919401/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does anyone know if this change got merged yet?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
