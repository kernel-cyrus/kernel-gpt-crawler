        <!DOCTYPE html>
        <html lang="en">
        <head><title>Bcache: Caching beyond just RAM [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/394672/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/394402/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/394672/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Bcache: Caching beyond just RAM</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="GAByline">
           <p>July 2, 2010</p>
           <p>By William Stearns and Kent Overstreet</p>
           </div>
<p>Kent Overstreet has been working on <a
href="http://lwn.net/Articles/394905/">bcache</a>, which is a Linux kernel
module intended to improve the performance of block devices.
Instead of using just memory to cache hard drives, he proposes 
to use one or more solid-state storage devices (SSDs) to cache block data
(hence bcache, a <b>b</b>lock device <b>cache</b>).

	<p>The code is largely filesystem agnostic as long as the
filesystem has an embedded UUID (which includes the standard Linux
filesystems and swap devices).  When data is read from the hard drive, a
copy is saved to the SSD.  Later, when one of those sectors needs to be
retrieved again, the kernel checks to see if it's still in page cache.  If so,
the read comes from RAM just like it always has on Linux.  If it's not
in RAM but it is on the SSD, it's read from there.  It's like we've added
64GB or more of - slower - RAM to the system and devoted it to
caching.</p>

	<p>The design of bcache allows the use of more than one SSD to
perform caching.  It is also possible to cache more than one existing
filesystem, 
or choose instead to just cache a small number of performance-critical
filesystems.  It would be perfectly reasonable to cache a partition used
by a database manager, but not cache a large filesystem holding archives of old
projects.  The standard Linux page cache can be wiped out
by copying a few large (near the size of your system RAM) files.  Large
file copies on that project archive partition won't wipe out an SSD-based cache
using bcache.</p>

	<p>Another potential use is using local media to cache remote
disks.  You could use an existing partition/drive/loopback device to
cache any of the following: AOE (ATA-over-Ethernet) drive, SAN LUN, DRBD
or NBD remote drives, iSCSI drives, local CD, or local (slow) USB thumb
drives.  The local cache wouldn't have to be an SSD, it would just have
to be faster than the media you're caching.</p>

	<p>Note that this type of caching is only for block devices
(anything that shows up as a block device in <tt>/dev/</tt>).  It isn't for
network <i>filesystems</i> like NFS, CIFS, and so on (see the <a
href="http://lwn.net/Articles/312708/">FS-cache module</a> for the
ability to cache individual files on an NFS or AFS client).</p>




<h4>Implementation</h4>

	<p>To intercept filesystem operations, bcache hooks into the top
of the block layer, in <tt>__generic_make_request()</tt>. It thus works
entirely in terms of BIO structures.

By hooking into the sole function through which all disk
requests pass, bcache doesn't need to make any changes to block device naming
or filesystem mounting.  If <tt>/dev/md5</tt> was originally mounted on
<tt>/usr/</tt>, it 
continues to show up as <tt>/dev/md5</tt> mounted on <tt>/usr/</tt> after
bcache is 
enabled for it.  Because the caching is transparent, there are no
changes to the boot process; in fact, bcache could be turned on long
after the system is up and running.  This approach of intercepting bio
requests in the background allows us to start and stop caching on the
fly, to add and remove cache devices, and to boot with or without
bcache.</p>

	<p>bcache's design focuses on avoiding random writes and playing
to SSD's strengths.  Roughly, a cache device is divided up into buckets,
which are intended to match the physical disk's erase blocks. Each
bucket has an eight-bit generation number which is maintained in a separate
array 
on the SSD just past the superblock.  Pointers (both to btree buckets
and to cached data) contain the generation number of the bucket they
point to; thus to free and reuse a bucket, it is sufficient to increment
the generation number.</p> 

	<p>This mechanism allows bcache keep the cache device completely
full; when it wants to write some new data, it just picks a bucket,
increments its generation number, invalidating all the existing pointers to
it.  Garbage collection will remove the actual pointers eventually; there
is no need for backpointers or any other infrastructure.</p>

	<p>For each bucket, bcache remembers the generation number from
the last time it had a full garbage collection performed.  Once the
difference between the current generation number and the remembered number
reaches&nbsp;64, it's time for
another garbage collection.  Since the generation number has no chance to
wrap, an 8-bit generation number is sufficient.</p>

	<p>Unlike standard btrees, bcache's btrees aren't kept fully
sorted, so if you want to insert a key you don't have to rebalance the
whole thing.  Rather, they're kept sorted according to when they were
written out; if the first ten pages are already on disk, bcache will insert into
the 11th page, in sorted order, until it's full.  During garbage
collection (and, in the future, during insertion if there are too many sets)
it'll re-sort the whole bucket.  This means bcache
doesn't have much of the index pinned in memory, but it also doesn't have to do
much work to keep the index written out.  Compare that to a hash table of ten
million or so entries and the advantages are obvious.</p>




<h4>State of the code</h4>

<p>
Currently, the code is looking fairly stable; it's survived overnight torture
tests. Production is still a ways away, and there are some corner cases and IO
error handling to flesh out, but more testing would be very welcome
at this point.

<p>
There's a long list of planned features:
<p>
<b>IO tracking</b>: By keeping a hash of the most recent IOs, it's possible to track
sequential IO and bypass the cache - large file copies, backups, and raid
resyncs will all bypass the cache. This one's mostly implemented.
<p>
<b>Write behind caching</b>: Synchronous writes are becoming more and more of a
problem for many workloads, but with bcache random writes become sequential
writes. If you've got the ability to buffer 50 or 100GB of writes, many
might never hit your RAID array before being rewritten.
<p>
The initial write behind caching implementation isn't far off, but at first
it'll work by flushing out new btree pages to disk quicker, before they fill
up - journaling won't be required because the only metadata to write out in
order is a single index. Since we have garbage collection, we can mark
buckets as in-use before we use them and leaking free space is a non issue.
(This is analogous to <a href="http://lwn.net/Articles/339337/">soft updates</a> - only much more practical). However, journaling
would still be advantageous so that all new keys can be flushed out sequentially;
then updates to the btree can happen as pages fill up, versus many smaller
writes so that synchronous writes can be completed quickly. Since bcache's btree
is very flat, this won't be much of an issue for most workloads, but should
still be worthwhile.
<p>
<b>Multiple cache devices</b> have been planned from the start, and mostly
implemented. Suppose you had multiple SSDs to use - you could stripe them, but
then you have no redundancy, which is a problem for writeback caching. Or you
could mirror them, but then you're pointlessly duplicating data that's present
elsewhere.  Bcache will be able to mirror only the dirty data, and then drop
one of the copies when it's flushed out.
<p>
<b>Checksumming</b> is a ways off, but definitely planned; it'll keep checksums of
all the cached data in the btree, analogous to what Btrfs does. If a
checksum doesn't match, that data can be simply tossed, the error 
logged, and the data read from the backing device or redundant copy.

<p>There's also a lot of room for experimentation and potential improvement
in the various heuristics. Right now the cache functions in a
least-recently-used (LRU) mode, but
it's flexible enough to allow for other schemes. Potentially, we can retain
data based on how much real time it saves the backing device, calculated
from both the seek time and bandwidth.




<h4>Sample performance numbers</h4>

<p>
Of course, performance is the only reason to use bcache, so benchmarks 
matter. Unfortunately there's still an odd bug affecting buffered IO so 
the current benchmarks don't yet fully reflect bcache's potential, but 
are more a measure of current progress. <a href="http://www.coker.com.au/bonnie++/">Bonnie</a> isn't particularly 
indicative of real world performance, but has the advantage of 
familiarity and being easy to interpret; here is the bonnie output:

<p>
Uncached: SATA 2 TB Western Digital Green hard drive
<pre>
Version  1.96       ------Sequential Output------ --Sequential Input- --Random-
Concurrency   1     -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
utumno          16G   672  91 68156   7 36398   4  2837  98 102864   5 269.3   2
Latency             14400us    2014ms   12486ms   18666us     549ms     460ms
</pre>
<p>
And now cached with a 64 gb Corsair Nova:
<pre>
Version  1.96       ------Sequential Output------ --Sequential Input- --Random-
Concurrency   1     -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
utumno          16G   536  92 70825   7 53352   7  2785  99 181433  11  1756  15
Latency             14773us    1826ms    3153ms    3918us    2212us   12480us
</pre>

<p>
In these numbers, the per character columns are mostly irrelevant 
for our purposes, as they're affected by other parts of the kernel. The 
write and rewrite numbers are only interesting in that they don't go 
down, since bcache isn't doing write behind caching yet. The sequential 
input is reading data bonnie previously wrote, and thus should all be 
coming from the SSD. That's where bcache is lacking, the SSD is capable 
of about 235 mb/sec. The random IO numbers are actually about 90% reads, 
10% writes of 4k each; without write behind caching bonnie is actually 
bottlenecked on the writes hitting the spinning metal disk, and bcache 
isn't that far off from the theoretical maximum.

<h4>For more information</h4>

	<p>The <a href="http://bcache.evilpiepirate.org/">bcache
wiki</a> holds more details about the software, more formal benchmark
numbers, and sample commands for getting started.

	<p>The git repository for the kernel code is available at
<tt>git://evilpiepirate.org/~kent/linux-bcache.git</tt>.  The userspace tools
are in a separate repository:
<tt>git://evilpiepirate.org/~kent/bcache-tools.git</tt>.  Both are viewable with
a web browser at the <a href="http://evilpiepirate.org/gitweb">gitweb
site</a>.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer-Caching">Block layer/Caching</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Stearns_William">Stearns, William</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/394672/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor395285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 3:09 UTC (Thu)
                               by <b>NightMonkey</b> (subscriber, #23051)
                              [<a href="/Articles/395285/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could this be used to make caches out of magnetic platter drives, or tmpfs, or any block device?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 3:23 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395289/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aside from tmpfs not being a block device, yes. I don't know that using hard drives as cache would ever be worthwhile - it's written with the assumption that random reads are fast, if you were to try that you'd want it to try to have it cache decent sized chunks of contiguous data (on cache miss, always read 64 kb or so in at a time). But it would certainly work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 3:35 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/395295/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
a local magnetic drive may be faster than a network drive<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 11:13 UTC (Thu)
                               by <b>ewan</b> (guest, #5533)
                              [<a href="/Articles/395367/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And a small fast disk system (e.g. striped 15k SAS disks) may be a useful cache over a big slow one (e.g. a huge RAID of 5400rpm SATA disks).<br>
<p>
I wonder if bcache can be stacked? So you could have an SSD over some SAS disks over a SATA RAID?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 11:24 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's no way to do that now - all the cache devices in the system are pooled together and used symmetrically - but it is something I've been considering down the road. It might not be all that much more work, I'm just curious if the performance would justify it. Most people's working set just isn't all that huge, and also the big problem with your big slow raid6 is random writes, which bcache should be able to mostly eliminate. But we'll see.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor395293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 3:42 UTC (Thu)
                               by <b>NightMonkey</b> (subscriber, #23051)
                              [<a href="/Articles/395293/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see. It might be interesting to use with a hard drive (or RAID 0 set) as a write-behind cache, once that is implemented. Or perhaps in front of a high-latency DRBD device. Some interesting possibilities! :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395437"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 15:40 UTC (Thu)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/395437/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would you want it in front of a DRBD device?  If you really want to sacrifice reliability for performance with a DRBD device, simply use protocol B or C, it will likely be more reliable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395437/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor395291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 3:43 UTC (Thu)
                               by <b>wstearns</b> (subscriber, #4102)
                              [<a href="/Articles/395291/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To add to Kent's answer, you could use a traditional (non-tmpfs) ramdisk as it's a full block device.  In a sense you're overriding the cache strategy by devoting the ramdisk's memory to caching one or more performance critical filesystems.  It might be useful in some situations even though the system as a whole has less efficient use of memory.  Using a hard drive as cache might actually be useful if the block device/filesystem you're caching is over a slow link or significantly slower than the cache device.  If your local drive hard drive is at least as large as the remote drive, you also have the option of using raid 1 and setting the remote drive to "write-mostly" (so that all reads come from the local drive except in case of drive failure; see "man mdadm").<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 14:20 UTC (Thu)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/395415/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"In a sense you're overriding the cache strategy by devoting the ramdisk's memory to caching one or more performance critical filesystems."<br>
<p>
I imagine that Bcache caches O_DIRECT reads and writes, which could give a caching advantage even where an application has elected to bypass the ordinary buffer cache.<br>
<p>
Bcache seems ideal for use in NFS servers, and iSCSI and FCoE targets.  NFS servers are supposed to do synchronous writes, right? (Reliable, crash resistant) write behind caching would be outstanding.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 14:57 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/395422/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I imagine that Bcache caches O_DIRECT reads and writes, which could give a caching advantage even where an application has elected to bypass the ordinary buffer cache.</font><br>
<p>
An application like a boot-loader installation/upgrade which tries to tell which disk sectors to load from the MBR?<br>
I hope there is a sync() to write to (the real destination) disk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 23:19 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bootloaders are a special situation - the most practical thing to do would be to just not enable write behind caching for /boot. For everything else, sync happens when you switch off write behind caching, and sync without switching it off doesn't really make any sense, the cached device is going to be inconsistent as long as write behind caching is on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 23:26 UTC (Thu)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/395535/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; NFS servers are supposed to do synchronous writes, right? (Reliable, crash resistant) write behind caching would be outstanding.</font><br>
<p>
Not since NFSv3 was implemented. That gave the ability to do safe asynchronous writes. The client sends a bunch of WRITEs to the server and then issues a COMMIT. If the server crashes, the client will reissue uncommitted writes.<br>
<p>
With NFSv2 however, you're correct that the server is supposed to do sync writes (and most do these days, at least by default).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396602"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2010 11:38 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/396602/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, NFSv3 helps with writing large files.  But metadata operations (create, unlink, chmod, mv) still need to be synchronous and some workloads can be very metadata-heavy (untar is a good example, 'make' on a big project tends to delete and create lots of relatively small files too).<br>
So a low-latency cache can definitely improve the performance of an NFS server.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396602/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397061"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2010 20:59 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/397061/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unfortunately if you want to spot cache invalidations, the lack of leases on NFSv3 is a killer, because you still have to roundtrip to the server to see if your cache is stale, and roundtrips are the slow part :( fs-cache slows NFS *down* quite considerably in my experience, for exactly this reason.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397061/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor395537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ramdisks and hard drives as cache devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 23:32 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395537/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (Reliable, crash resistant)</font><br>
<p>
That's what I've been working towards :)<br>
<p>
Safe write behind caching really is a large step up in terms of the guarantees the cache has to be able to make - with writethrough caching, you just have to make sure you return good data, or nothing. And btree code is hard enough, so I've been working on getting the easy cases rock solid first - but safe write behind caching is absolutely happening. I've got some of the preliminary stuff out of the way and I'm hoping to have a rough initial version before too long, depending on how debugging the new stuff goes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor395413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 14:05 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/395413/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; as long as the filesystem has an embedded UUID</font><br>
<p>
This sounds problematic to me. There is no guarantee that the UUID is unique. It might have been unique when it was *created*, but as soon as you duplicate a partition (with dd to another disk, a RAID 1 which is later split, or anything else), it ceases being unique. You could change the UUID of the copy, but who will remember to do that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 14:52 UTC (Thu)
                               by <b>sync</b> (guest, #39669)
                              [<a href="/Articles/395421/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
XFS refuses to mount a filesystem with a duplicate UUID.<br>
I think other filesystems should follow.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor395424"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 14:57 UTC (Thu)
                               by <b>faramir</b> (subscriber, #2327)
                              [<a href="/Articles/395424/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given that many distributions now use UUIDs rather then device names in /etc/fstab, not having unique UUIDs is already a recipe for disaster.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395424/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor395447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unique UUIDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 16:19 UTC (Thu)
                               by <b>wstearns</b> (subscriber, #4102)
                              [<a href="/Articles/395447/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're correct; at least in the case of RAID 1 mdadm, the md device and the underlying partitions all share the exact same UUID.  When I use bcache on a raid array, I don't cache the underlying partitions, I cache the raid device itself.  That lets the raid code handle a missing component partition, raid resync, and any other raid issues internally.<br>
If you copy a filesystem with dd or raid split as you mention, you still have to tell bcache both what UUID and what block device to cache, letting you specify the original partition or the new copy, whichever you want cached.  So bcache shouldn't introduce new problems; a non-bcache linux system will have problems already if you have 2 different filesystems with the same UUID as others have mentioned.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache and filesystem recovery</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 16:54 UTC (Thu)
                               by <b>abacus</b> (guest, #49001)
                              [<a href="/Articles/395453/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An important issue has not been discussed in the above article, and that is how file system recovery works when using Bcache. Does Bcache honor the write ordering requirements communicated by filesystems such that e.g. journal-based filesystem recovery still works ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache and filesystem recovery</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 2:15 UTC (Fri)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It doesn't handle barriers just yet. That's coming soon, it's needed for write behind caching.<br>
<p>
This isn't a correctness issue, if you don't have barriers you just have to wait for writes to complete before you start another to guarantee ordering. Barriers have historically taken awhile to add to things like raid, lvm and drbd, bcache is nothing special.<br>
<p>
There is a bug in that if you're running bcache on something that supports barriers, bcache won't indicated that they're no longer supported... I haven't worried much about that since you can disable them in the filesystem and it's only till I get barriers implemented in bcache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 17:34 UTC (Thu)
                               by <b>sflintham</b> (guest, #47422)
                              [<a href="/Articles/395462/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>This approach of intercepting bio requests in the background allows us to start and stop caching on the fly, to add and remove cache devices, and to boot with or without bcache</blockquote>

Am I right in thinking this will only be possible once the checksumming feature mentioned at the bottom of the article is in place? Otherwise, what would stop the cache returning an out-of-date copy of a block modified while it was offline?
      
          <div class="CommentReplyButton">
            <form action="/Articles/395462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395527"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 23:16 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395527/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Checksumming won't save you here - what's it supposed to compared the checksum against? If you fill up your cache, turn of caching, write some data, and then turn caching back on without telling bcache about it... well, computers can't always save you from rm -rf either.<br>
<p>
I am looking into invalidating the cache contents if a filesystem was already opened read write, or perhaps checking if the first page or so matches what it previously had - this would catch it provided the filesystem superblock changed. But the real performance gains are to be had with write behind caching, and none of this really matters there, since the cached device is now inconsistent if you use it without the cache. By the time bcache saw the cache was out of date it'd be too late to do anything.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395527/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395540"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 0:08 UTC (Fri)
                               by <b>akumria</b> (guest, #7773)
                              [<a href="/Articles/395540/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
Perhaps I'm not understanding everything.<br>
<p>
But it seems to me, that you could move the bcache functionality into the filesystem.<br>
<p>
i.e. Why can't btrfs store all writes on that faster medium and them replicate them back to the slower one?<br>
<p>
Also, isn't this akin to storing the journal of a filesystem externally (I've never done it). i.e. Why not point the ext3/ext4 journal at the SSD?<br>
<p>
Would you get the same (or better) benefit?<br>
<p>
It seem bcache is useful is the underlying filesystem doesn't do it, but in the above two cases, is there much benefit?<br>
<p>
Insight appreciated.<br>
<p>
Thanks,<br>
Anand<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395540/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 1:21 UTC (Fri)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395548/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could stuff everything into a filesystem, sure, but what would be the point? Caching really is doing something else, it wouldn't really be able to share any filesystem code, and it'd be tied to that one filesystem.<br>
<p>
The main thing is the allocation strategy you want for caching is _completely_ different than for filesystems. Fragmentation isn't a real problem in the cache, since we can free fixed sized chunks regardless of what's in them. This means we're free to write data to the cache however we want to get the best performance. A filesystem has to retain data for an arbitrary amount of time, and thus needs to pay a lot of attention to making sure free space doesn't fragment too much.<br>
<p>
Putting an external journal on an SSD gets you a bit of what bcache is after, but it'll only help with writes, and not to the extent bcache can. How would you effectively use an 80 gb journal? With bcache, you'll be able to fill up your caches with almost all dirty writes, and then write them out to your RAID6 with no restrictions on ordering - potentially turning a huge portion of random writes into mostly sequential ones, and even more will get overwritten in the cache before the raid ever sees them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bcache and cluster filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 2:56 UTC (Fri)
                               by <b>skissane</b> (subscriber, #38675)
                              [<a href="/Articles/395556/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How would this interact with a cluster file system such as OCFS?<br>
I assume it wouldn't work, unless the cluster file system was aware of the<br>
bcache, and had some way to do cache invalidation of the blocks which had<br>
been changed by other nodes in the cluster....<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395557"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bcache and cluster filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 3:28 UTC (Fri)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395557/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, it'd quickly explode. Probably be fun to watch, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395557/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bcache and cluster filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2010 11:20 UTC (Sat)
                               by <b>skissane</b> (subscriber, #38675)
                              [<a href="/Articles/395674/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it would be interesting to work out, what extra features would bcache need to provide so that a clustered filesystem could use it without issue... i assume just some API to tell bcache to invalidate some block...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bcache and cluster filesystems?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2010 3:22 UTC (Sun)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395705/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, nothing more complicated than that. Make a new bio flag to invalidate a region of cache, and make sure everything that isn't a cache ignores it. Making bcache handle it would be trivial, it'd just be a matter of making sure ocfs2 always invalidates what it needs to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor395558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 3:36 UTC (Fri)
                               by <b>mwalls</b> (guest, #6268)
                              [<a href="/Articles/395558/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't this substantially duplicating Facebook's flashcache, so are they related?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395559"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 3:52 UTC (Fri)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395559/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Completely different design and completely unrelated. I started bcache a couple months before flashcache was announced. Flashcache is simpler and being used in production now. Bcache has, in my opinion, a lot more potential than flashcache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395559/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor396409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2010 3:55 UTC (Sat)
                               by <b>bill_mcgonigle</b> (guest, #60249)
                              [<a href="/Articles/396409/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was wondering the same thing.  As I understand it, the main difference is that with Flashcache you tell it, "here, you're in front of this device".  And then you mount the flashcache device. <br>
<p>
bcache uses a kernel feature that lets it hook in 'from the side'.  So, you still mount the regular device.  In theory you can insert/pull/insert bcache as much as you want and your apps would be fine to keep on running.  I think that makes it ultimately more powerful.<br>
<p>
You could even imagine a workload where you have a bazillion disks that receive sporadic heavy access (maybe remote disks where old data isn't useful), and you could have some sort of monitor that would keep a few SSD's busy by inserting them as bcaches on-demand.<br>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 8:03 UTC (Fri)
                               by <b>MisterIO</b> (guest, #36192)
                              [<a href="/Articles/395569/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it safe in the presence of kernel bugs(or similar problems) for writes? I mean, we've seen things link ext4 delaying writes for 30 secs, but that had obvious relayability problems. Let's say that bcache successfully caches a certain amount of writes(that is they are complete on the cache), but then the system freezes, so the cache isn't written back to the actual hd. At the next boot, does bcache remember to perform those writes?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2010 16:18 UTC (Sat)
                               by <b>MisterIO</b> (guest, #36192)
                              [<a href="/Articles/395682/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ooouuuh, it's so cold being alone in the shadow on winter!<br>
<p>
Was my previous question very retarded? I noticed it's the only comment in the thread which was completely ignored. So I thought that knowing to have said something really stupid is still more useful than nothing. Thus, this post was born.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor395693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2010 20:32 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/395693/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if the data isn't written to the bcache HD and you do not have battery backed cache on the system, the data will be lost. This is the same as with any storage/filesystem.<br>
<p>
however (once the write behind features are in bcache) once the data is written to the bcache storage it should push those changes back to the real device after the next boot. If it doesn't the write-behind feature can't be considered done and useable ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2010 3:20 UTC (Sun)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395704/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, that's all correct :)<br>
<p>
Kernel bugs are a different matter entirely though - if a program doesn't do what you think it does, it could be doing anything. If it's buggy it could be overwriting all your important data with Rick Astley songs, or opening the door the the velociraptor cages. There's just no way to tell at that point.<br>
<p>
You test everything as best you can, but software's complicated, there's always something lurking and no complete guarantees.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2010 0:14 UTC (Mon)
                               by <b>MisterIO</b> (guest, #36192)
                              [<a href="/Articles/395713/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, with kernel bugs I meant kernel bugs not affecting this code and which by no means start writing random songs of some unknown guy(yeah, sorry, I don't know him) over your data, but still freeze the system. At that point basically the only real problem you could have is losing data on your hd(either just the data that didn't make it to the hd or the whole file you were writing at the time of the failure. The second case happened to me frequently with ext4 and I lost many normal data files because of it, while I was able instead to save some sources I was coding simply because I used git and I committed quite often).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor395590"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 12:27 UTC (Fri)
                               by <b>eludias</b> (guest, #4058)
                              [<a href="/Articles/395590/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How will O_DIRECT be handled? I need this to circumvent any caching layer to keep my hardware healthy.<br>
<p>
Background: I've also got one of those nasty WD Caviar Green (1Tb) drives, and there is a feature in the firmware of the drives which auto-parks the heads after 8 seconds of inactivity. This interacts quite badly with an OS which saves its data once per 30 seconds, resulting in a drive worn down in about 6 months.<br>
<p>
Now the way to circumvent this behaviour is to read something from the drive, say once per 5 seconds. And the most efficient way to do so is to read from the cache of the drive, so we re-read sector 0 over and over again. With O_DIRECT we can bypass the disk cache of Linux traditionally, but will this also be the case when using bcache?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395590/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395606"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">O_DIRECT read of sector 0</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 15:37 UTC (Fri)
                               by <b>wstearns</b> (subscriber, #4102)
                              [<a href="/Articles/395606/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since bcache can only cache individual filesystems and I assume your actual filesystems are on partitions (as opposed to a single filesystem covering the entire drive), bcache won't be caching sector 0 as that's not part of a filesystem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395606/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">O_DIRECT read of sector 0</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2010 10:45 UTC (Sat)
                               by <b>eludias</b> (guest, #4058)
                              [<a href="/Articles/395673/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was under the impression that bcache cached block devices (hence the name ), and not filesystems. But you have a good point: if I would cache the partition and not the whole device, I might be able to circumvent it by reading outside the partition.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">O_DIRECT read of sector 0</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2010 21:13 UTC (Sat)
                               by <b>wstearns</b> (subscriber, #4102)
                              [<a href="/Articles/395695/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're correct; bcache does cache block devices.  I phrased it poorly; the idea I failed to get across was that the filesystems we'd normally submit to bcache to cache are on individual partitions (which linux treats as block devices) as opposed to the entire drive, allowing you to bypass bcache on sector 0 and still cache the partitions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor395724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2010 9:16 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/395724/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; there is a feature in the firmware of the drives which auto-parks the heads after 8 seconds of inactivity</font><br>
<p>
Probably maximum power saving more, you can usually see/adjust (and save the setup) using hdparm.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2010 3:20 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/395662/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Is it persistent across reboots?  I.e. will my frequently accessed data still be available from the SSD after a reboot?

      
          <div class="CommentReplyButton">
            <form action="/Articles/395662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2010 8:59 UTC (Sat)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/395669/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is. Currently if you shut down uncleanly it'll invalidate the cache as it'll be inconsistent, but handling that is part of safe write behind caching on, which I'm working on now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2010 14:39 UTC (Sun)
                               by <b>alankila</b> (guest, #47141)
                              [<a href="/Articles/395710/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent news. I look forwards to using this technology.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor395792"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2010 19:50 UTC (Mon)
                               by <b>rilder</b> (guest, #59804)
                              [<a href="/Articles/395792/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting project. However, I wonder how this will work with something like cleancache(<a href="http://lwn.net/Articles/389873/">http://lwn.net/Articles/389873/</a>). Cleancache works in the realm of VM. So is bcache supposed to complement cleancache or is a replacement for it.<br>
<p>
The transparency of bcache is quite nice. Is bcache available as module(so that it can be built out of tree and used) ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395792/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor395797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2010 20:30 UTC (Mon)
                               by <b>rilder</b> (guest, #59804)
                              [<a href="/Articles/395797/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I recently came across L2ARC caching used in Solaris with ZFS + SSD. Is there any improvement or difference between that and bcache ? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 22:59 UTC (Thu)
                               by <b>bill_mcgonigle</b> (guest, #60249)
                              [<a href="/Articles/396226/">Link</a>] 
      </p>
      
      </div>
      </summary>
      There's quite a bit of similarity.  L2ARC is read-only, for wide random accesses.  bcache aims to be read/write.  ZFS also separates out its ZIL for writes.  If I'm building a ZFS box I'd use a big MLC drive for the L2ARC and a smaller SLC drive for the ZIL as the workloads differ.  You could probably set bcache to be read-only and put a filesystem's journal on a different drive if you wanted a more-like-ZFS segregation.  bcache has the nice attribute of just being able to pull it and keep running - ZFS isn't usually set up that way.  The L2ARC and ZIL have the checksumming today whereas bcache will get to that.  Of course, bcache is much more general and useful in situations where ZFS has no relevance.  It's good to have chisels <i>and</i> screwdrivers.
      
          <div class="CommentReplyButton">
            <form action="/Articles/396226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor396428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcache: Caching beyond just RAM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2010 16:10 UTC (Sat)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/396428/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How are you planning to protect file systems from being mounted if it has a write-back cache that is not activated or not available? Sounds like there is no infrastructure for this currently, but could badly corrupt data if not recognized.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Generation number</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2013 8:55 UTC (Fri)
                               by <b>wiza</b> (guest, #91017)
                              [<a href="/Articles/551003/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't quite understand the effect of maintaining the generation number. Since FTL has used some algorithm to avoid wearing out, what good is the generation number?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
