        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rethinking the futex API [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/823513/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/823501/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/823513/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rethinking the futex API</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 18, 2020</br>
           </div>
The Linux <a
href="https://www.man7.org/linux/man-pages/man2/futex.2.html"><tt>futex()</tt></a>
system call is a bit of a strange beast.  It is widely used to provide
low-level synchronization support in user space, but there is no wrapper
for it in the GNU C Library.  Its implementation was meant to be simple,
but kernel developers have despaired at the complex beast that it has
become, and few dare to venture into that code.  Recently, though, a new
effort has begun to rework futexes; it is limited to a new system-call
interface for now, but the plans go far beyond that.
<p>
There is a wide range of synchronization options within the kernel, but
there have always been fewer options in user space.  For years, the only
real option was <a
href="https://www.man7.org/linux/man-pages/man7/sysvipc.7.html">System&nbsp;V
semaphores</a>, but it is fair to say that they have never been universally
loved.  Developers have long wanted a mutex-like option for user space that
does not kill performance.
<p>
Back in 2002, Rusty Russell proposed a <a
href="https://lore.kernel.org/lkml/E16gRe3-0006ak-00@wagner.rustcorp.com.au/">fast
user-space mutex mechanism</a> that quickly became known as a "futex"; this
feature was present in the 2.6.0 kernel release at the end of 2003 and
immediately used to control concurrency for POSIX threads.  The
initial implementation was just a few hundred lines of code.  At its core,
a futex is a 32-bit word of memory shared between cooperating processes; a
value of one indicates that the futex is available, while anything else
marks it as unavailable.  A process wishing to acquire a futex will issue a
locked decrement instruction, then verify that the resulting value was
zero; if so, the acquisition was successful and execution can continue.
Releasing the futex is a simple matter of incrementing its value again.
<p>
The nice thing about futexes as described so far is that the kernel is not
involved in their operation at all; futexes can be acquired and released
without the need to make system calls.  That cannot be sustained if there
is contention for the futex, though; at that point, a task will have to
block to wait for the futex to become available.  That is where the
<tt>futex()</tt> system call comes in:
<p>
<pre>
    int futex(int *uaddr, int futex_op, int val,
              const struct timespec *timeout,   /* or: uint32_t val2 */
              int *uaddr2, int val3);
</pre>
<p>
The initial <tt>futex()</tt> implementation had only two arguments:
<tt>uaddr</tt> (the address of the futex) and <tt>futex_op</tt>, which
would be either <tt>+1</tt> to increment the futex, or <tt>-1</tt> to
decrement it.  The modern equivalents for <tt>futex_op</tt> are
<tt>FUTEX_WAKE</tt> (to signal 
that the futex has been freed and wake task(s) waiting for it) or
<tt>FUTEX_WAIT</tt> to block until the futex becomes available.
<p>
Many other
operations also exist at this point.
Over time, the futex interface has gained complexity, including "<a
href="/Articles/172149/">robust futexes</a>", <a
href="/Articles/387246/">adaptive spinning</a>, <a
href="/Articles/178253/">priority inheritance</a>, and much more.  See <a
href="/Articles/360699/">this article</a> for a (somewhat dated) overview,
the above-linked man page, or <a
href="https://www.man7.org/linux/man-pages/man7/futex.7.html">this
low-level description</a> for more information.
<p>
The current effort to rework futexes appears to be driven by a couple of
concerns.  One that goes mostly unstated is the desire to create a
system-call interface that makes a bit more sense than <tt>futex()</tt>,
which is a complex, multiplexed API with wildly varying arguments and a
number of special cases.  Whenever a system call is documented in terms
like this:
<p>
<div class="BigQuote">
	For several blocking operations, the timeout argument is a pointer
       	to a timespec structure that specifies a timeout for the operation.
       	However, notwithstanding the prototype shown above, for some
       	operations, the least significant four bytes of this argument are
       	instead used as an integer whose meaning is determined by the
       	operation.
</div>
<p>
One can conclude with a fair degree of certainty that the API design is not
as great as it could be.
<p>
In past years, when C-library developers have <a
href="/Articles/655044/">discussed</a> exposing <tt>futex()</tt>, they have
proposed splitting it into a set of simpler wrapper functions; that work
has never been merged.  Now, though, the <a
href="/ml/linux-kernel/20200612185122.327860-1-andrealmeid@collabora.com/"><tt>futex2()</tt>
proposal</a> from Andr√© Almeida does the same thing, adding three new system
calls:
<p>
<pre>
    int futex_wait(void *uaddr, unsigned long val, unsigned long flags, ktime_t *timeout);
    int futex_wait_time32(void *uaddr, unsigned long val, unsigned long flags, 
			  old_time32_t *timeout);
    int futex_wake(void *uaddr, unsigned long nr_wake, unsigned long flags);
</pre>
<p>
It is a rare patch set that includes a question like: "<q>Has anyone
started worked on a implementation of this interface?</q>".  Almeida's
patch set adds no new functionality; indeed, it is currently rather less
functional than the existing <tt>futex()</tt> API, lacking support for
features like priority inheritance.  Basic futex functionality is
implemented, though, by calling into the existing <tt>futex()</tt> code.
<p>
The purpose of this patch set is clearly not to show off new features at
this point; instead, the hope is to nail down what a new futex API should
look like, with the new features to be added after that is done.  That
said, there are some enhancements that the developers have in mind and
would like to get into place.
<p>
One of those is the ability to wait on multiple futexes at once and be
awakened when any one of them becomes available.  Gabriel Krisman Bertazi <a
href="/ml/linux-kernel/20190730220602.28781-2-krisman%40collabora.com/">posted
an implementation of this functionality</a> (for <tt>futex()</tt>) in July
2019; it is driven in particular by the needs of <a
href="https://www.winehq.org/">Wine</a>, which is emulating a similar
Windows feature.  In a discussion sparked by another posting of this patch
set in March, Thomas Gleixner <a
href="/ml/linux-kernel/87tv3aflqm.fsf%40nanos.tec.linutronix.de/">gently
suggested</a> that perhaps the time had come to design a new futex
interface where features like this could be added (and used) more easily.
The current proposal is a direct result of that suggestion.
<p>
That said, the proposed API doesn't handle multiple futexes, but the cover letter from
the current series describes a planned addition:
<p>
<pre>
    struct futex_wait {
	void *uaddr;
	unsigned long val;
	unsigned long flags;
    };

    int futex_waitv(struct futex_wait *waiters, unsigned int nr_waiters,
		    unsigned long flags, ktime_t *timeout);
</pre>
<p>

Another upcoming feature is the ability to handle futexes in a number of
common sizes, not just the 32-bit ones supported today.
<p>
Then, there is the issue of performance on <a
href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a>
systems.  The kernel must
maintain internal data structures describing the futexes that are currently
being waited on; if those structures are kept on the wrong NUMA node, futex
operations can sustain a lot of remote-node cache misses, which slows them
down considerably.  See <a href="/Articles/685769/">this article</a> for
details. Futexes are often used by threaded processes that are
all running on the same NUMA node; their performance would be improved if
the kernel kept its data structures on the same node.  Thus, there is a
"NUMA hint" functionality planned for the new API that would suggest that
the kernel keep its associated data structures on a specific node.
<p>
While the thinking about how to improve futex functionality in the kernel
has clearly entered a new phase, users should not hold their collective
breath waiting for new futex features to enter production kernels.  The
complexity of this subsystem makes developers reluctant to push through
quick changes; they have learned the hard way that it's easy for things to
go wrong with futexes.  So the new API and the implementation of any new
features are likely to go through an extended period of review and
revision.  The "F" in "futex" may stand for "fast", but the implementation
of new futex features may not be.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Futex">Futex</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/823513/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor823579"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2020 23:31 UTC (Thu)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823579/">Link</a>] (33 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sometimes I think developers lose focus on the problem being solved.  futex started life because user space needed a fast mutex.  It solves the problem by avoiding a syscall kernel, which boils down do "no syscall" unless you have to block.<br>
<p>
Here I see a whole pile of candy that has nothing to do "keep it simple and fast".  It can all be done with judicious combination of libatomic , a simple futex and some data structure in shared memory, wrapped in a userspace library because can be difficult to get right.  Why someone would need something other than 32 bits is beyond me.  Waiting on multiple values can be done in user space.  Association with a fd can be done with a userspace library writing a byte to a fifo on wakeup.  The thundering herd is already avoided by waking up a limited number of sleepers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823579/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 0:24 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/823591/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Waiting on multiple values can be done in user space. </font><br>
Not efficiently.<br>
<p>
<font class="QuotedText">&gt; Association with a fd can be done with a userspace library writing a byte to a fifo on wakeup.</font><br>
Not in all environments.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823597"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 0:59 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823597/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; Waiting on multiple values can be done in user space.</font><br>
<font class="QuotedText">&gt;Not efficiently.</font><br>
<p>
Why not efficiently?  Can you give me an example?<br>
<p>
<font class="QuotedText">&gt;&gt; Association with a fd can be done with a userspace library writing a byte to a fifo on wakeup.</font><br>
<font class="QuotedText">&gt;Not in all environments.</font><br>
<p>
Again, what environments?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823597/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823605"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 1:25 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/823605/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How would you wait on multiple futexes effeciently in userspace? You would have to busy wait and spinkle in some sleep(0)/sched_yield() nonsense calls here and there to not waste cpu cycles if none of the futexes are not triggered instead of just having the kernel put your thread to sleep until any of them gets triggered.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823605/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823606"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 2:32 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823606/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You do it the same way you do it in kernel space.  Maybe its a user space library that uses futex's to create user space mutexes, perhaps known as a utex_t.  The library stores it's utex_t implementation in memory shared between the threads / processing doing the waiting.  To cater for a waitv, it associates a pointer with each utex_t that says "utex_wake has to wake a whole pile of utex_t's".  The code isn't going to look much different regardless of whether it is in kernel space or user space.<br>
<p>
Yes, it's complex, racy and horrible to debug.  Putting it in the kernel doesn't solve that.  User space RCU (and yes, there is such a thing) is no more or less complex the kernel version.  The complexity has to be somewhere - hiding it in the kernel  may seem neater, but it binds it to an unchanging ABI so support and maintainability wise it's worse than putting it in a user space library.<br>
<p>
Putting stuff in the kernel is often a win because it can roll up multiple syscalls into one, but mutex's are peculiar because if they are not contested there is no need for a syscall.  That peculiarity was the primary driving force behind futex's - the fast mutex.  It's not like the kernel didn't  already provide user space multiple other mechanisms to do the same thing - they were just all slower because they involved one or more syscalls for the fast path.  And yet here we are with a proposal for futex_waitv() that must always make a syscall, which could be avoid in the uncontested case if it was implemented in user space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823606/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823620"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 4:55 UTC (Fri)
                               by <b>krisman</b> (subscriber, #102057)
                              [<a href="/Articles/823620/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You do it the same way you do it in kernel space. Maybe its a user space library that uses futex's to </font><br>
<font class="QuotedText">&gt; create user space mutexes, perhaps known as a utex_t. The library stores it's utex_t implementation in </font><br>
<font class="QuotedText">&gt; memory shared between the threads / processing doing the waiting. To cater for a waitv, it associates </font><br>
<font class="QuotedText">&gt; a pointer with each utex_t that says "utex_wake has to wake a whole pile of utex_t's". The code isn't </font><br>
<font class="QuotedText">&gt; going to look much different regardless of whether it is in kernel space or user space.</font><br>
<p>
How do you wake up multiple threads from your producer  (1) without issuing multiple syscalls to wake each futex, (2) avoiding spurious wakeups of unrelated threads, or relying on (3) poll (which we've shown is not fast enough); while (4) not relying in your waiters spinning (which throws cpu utilization through the roof)?  One of the main motivations of the patchset, which might have been lost in the article, is to reduce cpu utilization.<br>
<p>
Can you better describe what your model would look like in memory? One of my use cases is a producer-consumer scenario where each consumers wait on a subset of events triggered by different producers.  Each consumer waits on a different subset, but there are intersection between subsets for different consumers.  One or more consumers are waken up when any of their events trigger.  How do you represent this design in your model?  <br>
<p>
<font class="QuotedText">&gt;And yet here we are with a proposal for futex_waitv() that must always make a syscall</font><br>
<p>
That is not true.  For the uncontested case, a waiter can grab a futex without going into the kernel.  The semantics for FWM are "any of the futexes in the list" so if the consumer acquires any futex, it doesn't call futex_waitv. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823620/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823623"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 6:42 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823623/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  How do you wake up multiple threads from your producer (1) without issuing multiple syscalls to wake each futex,</font><br>
<p>
If they are waiting on the same futex, one call will suffice.  If they are waiting on multiple calls, multiple wakes will be needed of course.  But remember, futex's optimised for the fast path.  The fast path is when the lock is uncontested.  In that case there no one is waiting, and no one has to be woken up, and so no syscalls at all.  If you do have to wake another thread up, you've already incurred the overhead on one syscall: the FUTEX_WAIT that put it to sleep, so it's not an untenable additional penalty.<br>
<p>
<font class="QuotedText">&gt; (2) avoiding spurious wakeups of unrelated threads,</font><br>
<p>
Why are there wakeups on unrelated threads?  This wonderful utex library has recorded what utex_t's each thread is willing to be woken up in its shared memory, and wakes up as many as needed.  It's not like the kernel can do it differently: it also will have to look up what user space threads are waiting on the futex, and wake some up.  The basic algorithm and code doesn't change when it moves from kernel space to user space.<br>
<p>
<font class="QuotedText">&gt; (4) not relying in your waiters spinning (which throws cpu utilization through the roof)</font><br>
<p>
Why is anybody spinning - kernel or user space? Well OK - the kernel might spin because your critical section isn't long and so it's faster than mutex_lock().  But that's just a speed optimisation - you could always just use a mutex_lock().  In user space spinning always requires a syscall - perhaps many if you end up spinning for a while, so you are always better off with the user space mutex_lock() equivalent, which is futex(), and hope it is uncontested.  If it is uncontested there are no syscalls, and remember, if the kernel is spinning, then someone must has done a syscall to the kernel already, which is another way of saying futex_waitv() takes the syscall hit every time.<br>
<p>
<font class="QuotedText">&gt; Can you better describe what your model would look like in memory?</font><br>
<p>
Ahh, that is a long answer.  And you're stretching my memory because I was 30 years ago I did it for an OS I developed and sold.  It's too long to go into it in detail, but briefly it was based on two primitives: one that looked like utex_waitv().  The second primitive was based on a new trick: every utex allowed you to attach an arbitrary number of child utex's on them.  Waking up such a child transparently woke up the parent instead of the child, so a utex_waitv() on a child would never succeed.  utex_waitv() returned the utex that woke up, which might be a child utex of one of the utex‚Äôs in the top level utex_waitv() vector.<br>
<p>
utex_wake() becomes more complex of course: it has to check if the child had a parent, and indeed if the parent had a parent in order to wake up the right utex. I put the woken up utex‚Äôs in a queue list attached to the parent because I wanted to preserve the order of wakeups, but simply setting a flag in the child utex then having utex_wake() go looking for it would also work.<br>
<p>
I actually had a 3rd feature which would probably be frowned upon today: you could attach a function to a utex and instead of waking it up, utex_wake() would call that function, effectively turning the utex into an interrupt like thingy.  That was how the parent / child feature was actually implemented - the child had a function attached that woke up the parent.  This feature has the interesting property of letting a utex transparently defer to some other mutex / condition mechanism.  For example, instead of waking up a parent, you could write a byte to a fifo, or signal a semop().  The person calling the utex_wake() is none the wiser.<br>
<p>
In the general case you have to lock a lot of things when you are altering the resulting tree of mutex's.  In my case I can't remember that happening.  Instead one thread, the one that the parent mutex added and deleted children and since the children can only be attached to one parent there is no contention.<br>
<p>
BTW, I've never found a use for waking up more than one thread at a time.  It obviously has it's uses if you really want to release a thundering herd, but a mutex usually guards a shared volatile resource that only one thread can change at a time, so there is no point waking more than one.  If it discovers it doesn't want it, it can always wake someone else up.<br>
<p>
This all requires a bit of work.  You aren't dolling up futex's with a thin wrapper, you are implementing a new thing that uses futex's where the kernel would use spinlocks, IRQ masking or mutex_lock().  It is duplicating the existing code and data structures in the kernel.  And there are more complexities I haven't mentioned, like when a wake calls a function that does a wait.  However, because of that remarkable property of mutex that most code isn't executed unless there is contention, it doesn't matter speed wise because none of it is touched in the fast path.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823623/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor823786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 19:35 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/823786/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; How do you wake up multiple threads from your producer </font><br>
<font class="QuotedText">&gt; (1) without issuing multiple syscalls to wake each futex, </font><br>
<font class="QuotedText">&gt; (2) avoiding spurious wakeups of unrelated threads, or relying on </font><br>
<font class="QuotedText">&gt; (3) poll (which we've shown is not fast enough); while </font><br>
<font class="QuotedText">&gt; (4) not relying in your waiters spinning (which throws cpu utilization through the roof)? </font><br>
<font class="QuotedText">&gt; One of the main motivations of the patchset, which might have been lost in the article, is to reduce cpu utilization.</font><br>
<p>
I agree with the posters who say wait-multiple can be implemented efficiently in user space using the existing Futex API.<br>
<p>
Re (1): It might makes sense to add a wake-multiple call (as opposed to a wait-multiple) since that doesn't require copying dynamic lists into the kernel.<br>
This would be much, much simpler.<br>
Re (2): You can protect against spurious wakeups by re-checking atomic variables after wake up. However what are "unrelated threads"?<br>
Re (3): A user space implementation doesn't require polling (except once which is good for peformance).<br>
Re (4): You have the same general options implementing this as you do when implementing locks.<br>
<p>
<font class="QuotedText">&gt; Can you better describe what your model would look like in memory? </font><br>
<font class="QuotedText">&gt; One of my use cases is a producer-consumer scenario where each consumers wait on a subset of events triggered by different producers.</font><br>
<p>
When necessary, you associate a list of consumers with each event producer, each list entry containing a pointer to the waiters futex and/or atomic guard variable.<br>
Depending on the type of producer, you mark and/or wake one or all consumers. Why is that a question, did you try and have problems with this approach?<br>
<p>
The kernel would have to do the same or similar processing otherwise, however in my understanding it is to be avoided for the kernel, for example, to copy and maintain dynamic memory lists. It is better to do in user space, also for performance (and to avoid impacting the performance of other applications). At least I know this works well in my own use cases.<br>
<p>
Additionally, in use cases where the same "subset" is used repeatedly, these associations don't have to be re-established for each call. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2020 2:54 UTC (Sat)
                               by <b>krisman</b> (subscriber, #102057)
                              [<a href="/Articles/823837/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; When necessary, you associate a list of consumers with each event producer, each list entry containing </font><br>
<font class="QuotedText">&gt; a pointer to the waiters futex and/or atomic guard variable.</font><br>
<p>
So, your design has one futex per consumer.  This means that when a producer signals, in order to wake all of the entries in its waitqueue, it walks the list and does a FUTEX_WAKE syscall per entry.  That's much worse than FWM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823840"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2020 3:38 UTC (Sat)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823840/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So, your design has one futex per consumer.</font><br>
<p>
At this point I'm lost.  You obviously have some specific use case in mind none of this fits.  Could you post a link / explain what it is?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823840/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor823841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2020 3:58 UTC (Sat)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/823841/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So, your design has one futex per consumer. This means that when a producer signals, </font><br>
<font class="QuotedText">&gt; in order to wake all of the entries in its waitqueue, it walks the list and does a FUTEX_WAKE syscall per entry. That's much worse than FWM.</font><br>
<p>
Almost, but not with that disadvantage. As I indicated, "in my design" there is (optionally) a FUTEX_WAKE_MULTIPLE (not wait_multiple) kernel API which is much simpler to implement, also because it doesn't need to copy and maintain the list internally in the kernel. It does multiple FUTEX_WAKE operations in a single syscall. And this can be added later on, as an optimization, if and when such a call becomes available in the kernel, while the rest can already be implemented, tested and tuned with the kernel as is.<br>
<p>
Since a FUTEX_WAKE is only needed for futexes that actually have thread(s) waiting, and the waiting itself is already a time consuming kernel call, one non-blocking WAKE call per waiting futex shouldn't be that bad, although it will be better to have a wake_multiple call, which solves that problem (if it is one) completely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2020 4:05 UTC (Sat)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/823843/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(Also, for example, the FUTEX_WAKE calls can offloaded to a worker thread, if the callers are high priority.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor823621"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 4:58 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/823621/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And yet here we are with a proposal for futex_waitv() that must always make a syscall, which could be avoid in the uncontested case if it was implemented in user space.</font><br>
<p>
Why must it make a syscall in the uncontested case? It seems to me that it could first try to lock each of the futexes in user space and only make the syscall if none of them were available‚Äîmuch like the current implementation does for a single futex.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823621/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823624"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 5:31 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/823624/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly! In Krismans patch to LKML he specifically wrote:<br>
<p>
"Before calling the syscall again, userspace should traverse the list, trying to re-acquire any of the other futexes, to prevent an immediate -EWOULDBLOCK return code from the kernel."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823624/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor823631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 6:58 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823631/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why must it make a syscall in the uncontested case?</font><br>
<p>
It doesn't have to be.  But this isn't just a simple compare and swap.  You are checking a vector, which requires many steps.  These steps have to be done atomically along with the following futex_waitv() if needed.  How are you going to do it?<br>
<p>
I've been programming long enough to be very confident you can' trust your average programmer to get that sort of thing right.  Hell, I'm pretty confident I won't get it right on the first try.  That in itself isn't a problem: you wrap it in a user space library so they can't get it wrong.<br>
<p>
But then, if you are implementing a user space library anyway, and the library could implement the futex_waitv() in user space  and it would be faster to boot in the uncontested case, what have you gained by doing it in the kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor823625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 5:36 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/823625/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But this call is not about the uncontested case, it's so that the kernel can put a thread to sleep that is waiting for one (or more) of the contested futexes to no longer be contested. That you cannot do from userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor823610"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 2:31 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/823610/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Again, what environments?</font><br>
For example, if you can't open new files (not enough FDs or to not mess up the file descriptor numbers).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823610/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823611"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 2:50 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823611/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What's that got to do with futex's?  They don't use an FD.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823611/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823614"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 3:08 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/823614/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Uhh... You stated that futex functionality can be implemented in userspace: <a href="https://lwn.net/Articles/823579/">https://lwn.net/Articles/823579/</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823614/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 3:50 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823617/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it reads that way I've written it badly.<br>
<p>
I did not mean current futex's could be implemented in userspace.   I meant the candy being proposed here could be implemented in user space, candy such as futex_waitv() and allowing different sized int's for the uaddr argument.  You need something fast, simple and small to base that on, and that something is  futex's.  That was the whole point of futex's - the existing alternatives like semop()'s were not fast or simple.  If we aren't careful, futex's will go the same way.<br>
<p>
One of the complaints about the current futex implementation is the code is hard to follow.  One reason for that is it's been expanded to do stuff that could have been done in user space.  FUTEX_FD is one such thing.  I suspect that FUTEX_REQUEUE is another - it could be done in user space with no more syscalls than are used now.  futex_waitv() is definitely in the same class.  You don't fix complexity by adding more features.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823622"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 5:14 UTC (Fri)
                               by <b>krisman</b> (subscriber, #102057)
                              [<a href="/Articles/823622/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One of the complaints about the current futex implementation is the code is hard to follow. One reason </font><br>
<font class="QuotedText">&gt; for that is it's been expanded to do stuff that could have been done in user space. FUTEX_FD is one </font><br>
<font class="QuotedText">&gt; such thing. I suspect that FUTEX_REQUEUE is another - it could be done in user space with no more </font><br>
<font class="QuotedText">&gt; syscalls than are used now. futex_waitv() is definitely in the same class. You don't fix complexity by </font><br>
<font class="QuotedText">&gt; adding more features.</font><br>
<p>
For what is worth, yes, the futex interface has grown out of hand with deprecated features.  FUTEX_FD was dropped long ago, so that is not a big deal.  And yes,  most futex features can be implemented in userspace with the WAKE/WAIT pair with additional cost.  <br>
<p>
REQUEUE/CMP_REQUEUE exist to reduce system calls and unnecessary wakes.  How would you requeue in userspace without more syscalls and unnecessary awakes?  I don't see how it is possible, in fact,  CMP_REQUEUE is planned to exist in a future API. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823622/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823630"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 6:50 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/823630/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  REQUEUE/CMP_REQUEUE exist to reduce system calls and unnecessary wakes. How would you requeue in userspace without more syscalls and unnecessary awakes? I don't see how it is possible, in fact, CMP_REQUEUE is planned to exist in a future API. </font><br>
<p>
You couldn't.<br>
<p>
I was querying whether the added extra syscall complexity is worth the cost.  It's not like you can't do it in user space - it's just more expensive.  You've already incurred one syscall, so the orders of magnitude speed improvement the futex fast path got you is gone.  You are now trying to gain a factor of 2 or 3 or something.  If it was a very frequent use case, then perhaps - but it looks esoteric to me.  If complexity is an issue esoteric should be shown the door.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823630/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2020 20:56 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/824289/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is a frequent use case: POSIX condition variables. These are associated with a mutex. A thread calling pthread_cond_wait must do so while owning the mutex associated with the condition variable. The mutex is then released and the thread put to sleep until the condition is signalled. On wakeup, the mutex must be reacquired by the thread prior to the function call returning. If more than one thread is woken up because the condition is signalled, they would thus all race to exit the kernel, most of them would find the mutex locked and enter the kernel again in order to block on that.<br>
<p>
With REQUEUE/ CMP_REQUEUE, it&#x27;s possible to ask the kernel to wake up one thread which then acquires the mutex and (presumably) does something useful while the others are moved from the condvar futex to the mutex futex without waking them up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2020 22:01 UTC (Tue)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/824299/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for that.<br>
<p>
My point wasn&#x27;t that thundering herd isn&#x27;t a problem.  It clearly is.<br>
<p>
My point was that it is already solved by the current futex() API.  You get to decide how many of those syscall(SYS_futex, &amp;futex, FUTEX_WAIT)&#x27;s you wake up.  It can be anywhere from 1 to all.  The others just sit around, waiting for another FUTEX_WAKE.<br>
<p>
To solve the pthread_cond_wait() case you just wake up one, so it could have been done without REQUEUE now.  I&#x27;ll grant you that not all that REQUEUE does, it also prevents the futex from seeing any future wakeups.  But that could equally well be done from userspace using more futex&#x27;s.  Perhaps it&#x27;s a speed optimisation (I do hope they benchmarked it), or more likely arranging or everyone to share information the kernel already had was hard so they took the easy way out.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824342"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2020 14:54 UTC (Wed)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/824342/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The library implementation doesn&#x27;t get to decide this: Application code can either use pthread_cond_signal to wake exactly on thread or pthread_cond_broadcast to wake all threads. With the naive implementation, the kernel goes through a linked list and wakes everything while tearing the list apart. All the awoken threads exit the kernel and compete for ownership of the same mutex. One of these threads will end up getting the mutex, the others all do system calls in order to enter the kernel again where kernel code than builds a new linked list of them which is attached to a different futex.<br>
<p>
That&#x27;s an insanely complicated way to transfer a linked list from a head pointer a in the kernel to another head pointer b in the kernel. It&#x27;s much simpler if the kernel just wakes one thread and transfers the existing list to the other futex.<br>
<p>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824342/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2020 19:17 UTC (Wed)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/824390/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That&#x27;s an insanely complicated way to transfer a linked list from a head pointer a in the kernel to another head pointer b in the kernel. It&#x27;s much simpler if the kernel just wakes one thread and transfers the existing list to the other futex.</font><br>
<p>
I&#x27;m not sure if you are discussing a more specific question, but just to point it out, for example a user space implementation of the producer/consumer model can (if so designed) just move a waiting entry from one producer&#x27;s list to another producer&#x27;s list without any wake ups or even kernel calls. (Except a wake call in the case one is ready.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor823656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 10:43 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/823656/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; REQUEUE/CMP_REQUEUE exist to reduce system calls and unnecessary wakes. How would you requeue in userspace without more syscalls and unnecessary awakes?</font><br>
<p>
You would just do things differently. A model that is relatively common is the "parking lot" where each thread has a single binary semaphore attached to it. The primitives in this model are "parking" yourself (consuming the token in the semaphore, or waiting for one and consuming it immediately if it's not there) and "unparking" another thread (placing a token on its semaphore). The parking lot itself is an associative array from addresses to waitqueues, similar to what the kernel does for futexes, so that you can "park" yourself on a list and "unpark" the head of a list.<br>
<p>
By moving waitqueue handling to userspace, you don't need a system call anymore for either requeueing or multiple-futex wait. On the other hand it makes the implementation of pthread_barrier_t less efficient because every slow-path wakeup needs a separate system call.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2020 17:44 UTC (Sun)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/824013/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; On the other hand it makes the implementation of pthread_barrier_t less efficient because every slow-path wakeup needs a separate system call.</font><br>
<p>
Again a reason to add a "FUTEX_WAKE_MULTIPLE" kernel API, or "futex_wakev" ("wake" not "wait"), that takes a vector of multiple futex addresses as parameter.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor823594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 0:58 UTC (Fri)
                               by <b>krisman</b> (subscriber, #102057)
                              [<a href="/Articles/823594/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Waiting on multiple values can be done in user space. </font><br>
<p>
Yes,  it can be done in userspace, as mentioned in my original submission of Futex Wait Multiple last year.  Still, we experimented with all that, and the performance of a userspace solution or even of a solution based on eventfd (which would be the most obvious way to implement these semantics in userspace with the existing kernel support), is a bottleneck on our real-world scenarios of emulation of windows applications over Wine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 19:48 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/823790/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe your idea to use futexes is far better than using eventfd for dealing with a large number of calls or events.<br>
<p>
However I think the existing Futex API allows implementing wait-for-multiple-events with great performance. I have good experience implementing such functionality with existing APIs, and know of no conceptual restrictions there. See also my slightly more detailed comment above.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor823650"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 9:58 UTC (Fri)
                               by <b>bno1</b> (guest, #138051)
                              [<a href="/Articles/823650/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Waiting on multiple values can be done in user space. Association with a fd can be done with a userspace library writing a byte to a fifo on wakeup.</font><br>
<p>
Wine already has this. The esync patchset uses eventfd to wait on multiple winapi mutexes [1]. But some Windows programs run out of file descriptors because they leak mutexes. File descriptors are a much more limited resource than memory. Also, the patch for wait for multiple futexes (called fsync in the wine community) has slightly better performance [2].<br>
<p>
[1] <a href="https://github.com/zfigura/wine/blob/esync/README.esync">https://github.com/zfigura/wine/blob/esync/README.esync</a><br>
[2] <a href="https://github.com/ValveSoftware/Proton/issues/2966">https://github.com/ValveSoftware/Proton/issues/2966</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823650/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2020 7:04 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/824199/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; "But some Windows programs run out of file descriptors because they leak mutexes."</font><br>
<p>
See, this is why W(in)e can't have nice things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor823756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 14:57 UTC (Fri)
                               by <b>sbaugh</b> (guest, #103291)
                              [<a href="/Articles/823756/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Association with a fd can be done with a userspace library writing a byte to a fifo on wakeup.</font><br>
<p>
As far as I'm aware, this can only be done by dedicating a thread to each futex you want to wait on - not exactly cheap.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823791"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 19:59 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/823791/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As far as I'm aware, this can only be done by dedicating a thread to each futex you want to wait on - not exactly cheap.</font><br>
<p>
Conceptually, a futex is not something you wait on. It is something that you use to wait. It is a consumer, not a producer. The wake call is the producer.<br>
<p>
You can use a single futex to wait for many things at the same time (using user space utility functions to establish the necessary connections).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823791/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor823807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2020 23:43 UTC (Fri)
                               by <b>glenn</b> (subscriber, #102223)
                              [<a href="/Articles/823807/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One of those is the ability to wait on multiple futexes at once and be awakened when any one of them becomes available.</font><br>
Has any thought been given to waiting until _all_ the futexes are available?  Some sorting of mutexes could be imparted to avoid deadlock issues.  Yes, these locks can be obtained serially in userspace, but this may result in as many as N-1 pointless wake-ups of N futexes are needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2020 1:12 UTC (Sat)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/823821/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Has any thought been given to waiting until _all_ the futexes are available? </font><br>
<font class="QuotedText">&gt; Some sorting of mutexes could be imparted to avoid deadlock issues. </font><br>
<font class="QuotedText">&gt; Yes, these locks can be obtained serially in userspace, but this may result in as many as N-1 pointless wake-ups of N futexes are needed.</font><br>
<p>
This problem relates to a specific approach, not to user space solutions in general. The goal is to determine contention without any kernel call at all.<br>
<p>
The way you ask this question suggests that your life doesn't depend on the answer.<br>
My suggestion: keep it that way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor823856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2020 7:25 UTC (Sat)
                               by <b>glenn</b> (subscriber, #102223)
                              [<a href="/Articles/823856/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps I need to rephrase my question: What can the kernel do to reduce the system overheads associated with nested locking?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/823856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2020 7:12 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/824201/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See, if your life has taken you to a place where you are thinking about ways to reduce what it costs to do nested locking, you have gone astray, and need to find your way back.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2020 8:39 UTC (Thu)
                               by <b>glenn</b> (subscriber, #102223)
                              [<a href="/Articles/824440/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The way you ask this question suggests that your life doesn&#x27;t depend on the answer.</font><br>
<p>
<font class="QuotedText">&gt; See, if your life has taken you to a place where you are thinking about ways to reduce what it costs to do nested locking, you have gone astray, and need to find your way back.</font><br>
<p>
Thanks for the life advice.  I‚Äôll bring it up with my therapist.  Shall we get back to science and engineering?<br>
<p>
Let me talk about some challenges I‚Äôve run into developing a pipelined real-time task-graph runtime where I used the futex API directly to manage thread waiting and signalling.  My workload is modeled by a set of nodes connected by directed edges.  A node is a consumer of input edges, and it is a producer on output edges.  Each node encapsulates a unit of work that is backed by a dedicated thread.  This thread is ready to run when data is available on _all_ of its input edges.<br>
<p>
Being a task-graph system, some nodes are join/fan-in points.  These nodes consume data from several edges.  How does a producer determine when it should wake the consumer?  One method is to use a futex for each edge.  The consumer can loop over these futexes until all inputs are satisfied.  This may work, but it‚Äôs not particularly efficient: it doesn‚Äôt scale well (suppose your node has 10s or even 100s of inputs) as a thread may wake up many times before it does any real work.  Recall that this is a runtime for a real-time application.  These trivial wakeups can preempt other real-time work (e.g., active threads of other nodes) and induce threads to migrate to other CPUs (Linux is very aggressive about migrating preempted real-time threads to available CPUs), inducing cache affinity loss and additional context switch overheads.  Also, this wakeup pattern is _very_ problematic for SCHED_DEADLINE.  This scheduler allocates budget assuming that the thread in question exhibits a periodic/sporadic execution pattern.  Our consumer thread does _not_ exhibit this pattern because it is constantly dealing with trivial wakeups.  A SCHED_DEADLINE consumer can exhaust its budget dealing with trivial wakeups before the thread is ready to do any real work!  This is due to SCHED_DEADLINE&#x27;s budget reclaiming algorithm (see ‚Äú2.2 Bandwidth reclaiming‚Äù in Documentation/scheduler/sched-deadline.txt).<br>
<p>
An alternative approach is to have the consumer wait on a single futex.  Now each producer is responsible for evaluating whether all of the inputs of the consumer have been satisfied.  The last producer to satisfy these inputs wakes the consumer.  This leads to a more efficient solution, but it is not without its trade-offs.  A producer needs insight into the availability of data on the other edges of its consumer.  This implies that the producers must run within the same process or share some state in shared memory.  This makes for a cross-cutting software architecture where a composable one would feel much more natural.  The lifetime of shared memory is not fun to manage.  There are also security implications.<br>
<p>
My task-graph framework would have been simpler if the futex API let my consumer wait on a set of futexes and wake only when all inputs had been satisfied.<br>
<p>
In my runtime, I also explored the use of eventfd and epoll.  I encountered the same problem: select, poll, and epoll all wake the caller when any one file descriptor is ready, not when all are ready.  I am unaware of any synchronization or IPC mechanism in Linux that would let me design my software in a composable way while simultaneously avoiding the problems of trivial wakeups.  I haven‚Äôt revisited my problem since io_uring landed--perhaps there‚Äôs a solution for me there.  Does anyone have a suggestion?  No need to suggest a therapist.  I already have one. ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2020 11:22 UTC (Thu)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/824454/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; An alternative approach is to have the consumer wait on a single futex. Now each producer is responsible for evaluating whether all of the inputs of the consumer have been satisfied. The last producer to satisfy these inputs wakes the consumer. This leads to a more efficient solution, but it is not without its trade-offs. A producer needs insight into the availability of data on the other edges of its consumer.</font><br>
<p>
Your situation may have specifics that I am not aware of, so I can only hope that this is going to make sense:<br>
<p>
Each producer keeps track of if a consumer has already been informed about the availability of data, in that consumer&#x27;s list entry. That list entry of course also has a reference to the consumer. The consumer itself has an atomic counter for how many inputs it is still missing. When a producer is able to provide a new input, it reduces the consumer&#x27;s (atomic) counter by 1. In case it reaches zero at that point, it wakes the consumer.<br>
<p>
Instead of a counter, for example an atomic bitset can be used. Then the consumer&#x27;s list entry contains the specific bit that this producer should set. When a producer sees that it has set the last necessary bit, it wakes the consumer (or just sets that flag if the consumer isn&#x27;t waiting). This is what I have used in some cases. In my case, the consumer is often doing other work while the flag is set, so that it often does not have to wait, and the whole process takes place in user space.<br>
<p>
<font class="QuotedText">&gt; This implies that the producers must run within the same process or share some state in shared memory. This makes for a cross-cutting software architecture where a composable one would feel much more natural. The lifetime of shared memory is not fun to manage. There are also security implications.</font><br>
<p>
As far as I know, using futexes between processes always requires shared memory, one way or the other. That probably makes them fastest solution when blocking threads is required on the slow path. <br>
<p>
(Of course futexes should only be used on the slow path.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 30, 2020 15:42 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/824823/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I endorse the above. For nodes with a large number of inputs, each bit can represent another bitmap, recursively, until there are enough bits for all the inputs. When any bitmap is filled, the producer sets the bit representing it at the next level up. When the topmost bitmap is filled, the producer that filled it wakes the thread.<br>
<p>
Bits are set by compare-and-swap. atomically, with no system call needed.<br>
<p>
To do it with a counter, the producer atomically decrements a counter, and wakes the thread when it sees the transition to zero. <br>
<p>
Waking the thread might mean writing a byte to a pipe it is sleeping on. <br>
<p>
Or, the producer&#x27;s thread might just add the consumer to a scoreboard of runnable tasks, and some already-running thread will get to it. That way, the kernel is never involved at all. You keep exactly as many threads as you have cores on the job, and they spin when there is no work. Isolate those cores (isolcpus, nohz_full, rcu_nocbs) so the kernel does not steal them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor824635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wait until all futexes are available?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2020 7:49 UTC (Sat)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/824635/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; An alternative approach is to have the consumer wait on a single futex.</font><br>
<p>
Waking up precisely one waiter if always the fastest choice.<br>
<p>
<font class="QuotedText">&gt; This implies that the producers must run within the same process or share some state in shared memory.</font><br>
<p>
Yes, but futex&#x27;s only work with shared memory.  Communicating via shared memory is orders of magnitude faster than another other method.  That&#x27;s where futex&#x27;s get their speed from.  So if you want speed shared memory unavoidable.<br>
<p>
If speed is not such a big issue there are as you say lots of choices, including epoll(), pipes, semop()&#x27;s ...<br>
<p>
<font class="QuotedText">&gt; My task-graph framework would have been simpler if the futex API let my consumer wait on a set of futexes and wake only when all inputs had been satisfied.</font><br>
<p>
Of course it would be.  Things are always simpler when there is a pre-existing library that does exactly what you want.   What triggered my interest here is the claim that library should be in the kernel.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor824198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API - why change the type that uaddr points to?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2020 4:00 UTC (Tue)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/824198/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>From the <a href="https://www.man7.org/linux/man-pages/man2/futex.2.html">futex(2) man page</a>:</p>
<pre>    int futex(int *uaddr, [...]
</pre>

<p>And from the proposed patch set mentioned below:</p>

<pre>
    int futex_wait(void *uaddr, [...]
    int futex_wait_time32(void *uaddr, [...]
    int futex_wake(void *uaddr, [...]
</pre>

<p>Just curious, and I couldn't find in our editor's article, nor in the comments: why is <tt>uaddr</tt> being changed from an <tt>int *</tt> to a <tt>void *</tt>?</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API - why change the type that uaddr points to?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2020 13:02 UTC (Tue)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/824211/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I would guess that it has to do with the desire to support different sizes of futexes.  Once that's in place, the type of that pointer will vary, so it pretty much has to be <tt>void&nbsp;*</tt>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/824211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor824269"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking the futex API - why change the type that uaddr points to?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2020 17:46 UTC (Tue)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/824269/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I would guess that it has to do with the desire to support different sizes of futexes. Once that&#x27;s in place, the type of that pointer will vary, so it pretty much has to be void *.</font><br>
<p>
Is it worth the effort and cost of a larger kernel API, though? An application level feature can easily use another atomic variable (which it might like to do anyway), it doesn&#x27;t have to use the futex value itself, except on the slow path. Not every convenience requires its own kernel API.<br>
<p>
The use of futexes requires specialized understanding *and* experience, and application writers are usually better off using higher level library functions like semaphores and mutexes. Leave the support of multiple sizes to the libraries. Or add a Linux-specific C library directly supported by the kernel developers (which can then perhaps also be used by the kernel to communicate with user space processes).<br>
<p>
My suggestion is to (first) add a kernel API that can actually make a performance difference: a WAKE-multiple-futexes-with-one-call API. (&quot;Wake&quot; not &quot;wait&quot;). Should be easy to implement (for a kernel developer) and not interfere with the existing functionality and concepts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/824269/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
