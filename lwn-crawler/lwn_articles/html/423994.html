        <!DOCTYPE html>
        <html lang="en">
        <head><title>Concurrent code and expensive instructions [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/423994/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/423905/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/423994/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Concurrent code and expensive instructions</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>January 26, 2011</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<h4>Introduction</h4>

<p>Symmetric multiprocessing (SMP) code often requires expensive
instructions, including atomic 
operations and memory barriers, and often causes expensive cache
misses.
Yet some SMP code can be extremely cheap and fast, using no expensive
instructions at all.
Examples of cheap SMP code
include per-CPU counters and RCU read-side critical sections.
So why can't <i>all</i> SMP code be cheap?
Is it just that we aren't smart enough to spot clever ways of implementing
other algorithms, for example, concurrent stacks and queues?
Is it that we might be able to implement concurrent stacks and queues
without expensive instructions, but only at the cost of mind-bending
complexity?
Or is it simply impossible to implement concurrent stacks and queues
without using expensive instructions?

</p><p>My traditional approach has been to place my faith
in two observations: (1)&nbsp;if you beat your head against a wall long
enough, one of two things is bound to happen, and (2)&nbsp;I
have a hard head.
Although this approach has worked well, something less painful would
be quite welcome.
And so it was with great interest that I read a paper
entitled "<a href="http://infoscience.epfl.ch/record/161286">Laws of
Order: Expensive Synchronization in 
Concurrent Algorithms Cannot be Eliminated</a>" by Attiya et al., with
the &ldquo;et al.&rdquo; including Maged Michael, whom I have had
the privilege of working with for quite some time.

</p><p>It is important to note that the title overstates the paper's
case somewhat.
Yes, the paper does present some laws requiring that many concurrent
algorithms use expensive instructions,
however, all laws have their loopholes,
including the Laws of Order.
So while we do need to understand the Laws of Order, we most especially
need to understand how to fully exploit their loopholes.

</p><p>To arrive at the Laws of Order, this paper first expands
the definition of commutativity to include
sequential composition, which in the C language can best be thought
of as the &ldquo;;&rdquo; operator.
In this case, commutativity depends not just on the operator, but on
the operands, which for our purposes can be thought of as calls
to arbitrary C functions.
For example, the statements:
<p>
<pre>
    atomic_inc(&amp;x); 
    atomic_inc(&amp;y);
</pre>
<p>
are commutative:  the values of <code>x</code> and <code>y</code> are
the same regardless of the order of execution.
In contrast:
<p>
<pre>
    atomic_set(&amp;x, 1); 
    atomic_set(&amp;x, 2);
</pre>
<p>
are non-commutative:
the value of <code>x</code> will be either 1 or 2, depending on which
executes first.

</p><p>These examples execute sequentially, but the paper considers
concurrent execution.
To see this, consider a concurrent set that has these operations:
<p>
<ul>
<li>  a set-member-addition
      function (call it <code>set_add()</code>)
      that returns an indication of whether the element to be
      added was already in the set,
<p>
<li> a set-member-test function (call it <code>set_member()</code>), and
<p>
<li> a set-member-removal function (call it <code>set_remove()</code>)
     that returns an indication of whether anything had actually been
     removed.
</ul>
<p>
Then concurrently testing two distinct members is commutative: the
order in which <code>set_member(&amp;s, 1)</code> and
<code>set_member(&amp;s, 2)</code>
execute will not affect the return values from either, and the final
value of set <code>s</code> will be the same in either case.
Therefore, it is not necessary for the two invocations to
coordinate with each other.
The fact that coordination is not required means that there is some hope
that expensive instructions are not needed to implement
<code>set_member()</code>.

</p><p>In contrast, concurrent invocation of <code>set_add(&amp;s,&nbsp;1)</code>
and <code>set_member(&amp;s,&nbsp;1)</code>
would <i>not</i> be commutative if the set <code>s</code> initially
did not contain the value&nbsp;1.
The <code>set_member()</code> invocation would return true only if it
executed after the <code>set_add()</code>.
Some coordination between the two functions is clearly required.

</p><p>The most important results of the paper rely on a strong form
of non-commutativity, which is strangely enough termed
&ldquo;strong non-commutativity&rdquo;, which we can abbreviate
to &ldquo;SNC&rdquo;.
The example in the previous paragraph is not SNC because, while
<code>set_add()</code> can affect <code>set_member()</code>,
the reverse is not the case.
In contrast, an SNC pair of functions would each affect the other's
result.
For example, consider <code>set_add(&amp;s,&nbsp;1)</code> and
<code>set_remove(&amp;s,&nbsp;1)</code>, where the set <code>s</code> is initially
empty.
If <code>set_add(&amp;s,&nbsp;1)</code> executes first, then both functions
will indicate success, and set <code>s</code> will be empty.
On the other hand, if <code>set_remove(&amp;s,&nbsp;1)</code> executes first,
then only the <code>set_add(&amp;s,&nbsp;1)</code> will indicate success
and the set <code>s</code> will contain&nbsp;1.
In this case, the return value of <code>set_remove()</code> is affected
by the order of execution.
On the other hand, if the set <code>s</code> initially contains&nbsp;1, 
it will be <code>set_add(&amp;s,&nbsp;1)</code> whose return value is affected.
Therefore, the order of execution can affect the return value of both
functions, and these functions are therefore SNC.


<p><a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
Is <code>atomic_add_return()</code> SNC?  In other words, are multiple
concurrent calls to this function SNC? 
<br><a href="#qq1answer">Answer</a>

</p><p>The key result of the paper is that under certain conditions,
the implementation of
a pair of SNC functions must contain a heavyweight instruction,
where a &ldquo;heavyweight instruction&rdquo; can either be an
atomic read-modify-write instruction or a heavyweight memory barrier.
In the Linux kernel, only <code>smp_mb()</code> qualifies as
a heavyweight memory barrier.

</p><p>The &ldquo;certain conditions&rdquo; are:

</p><ol>
<li>	Both functions in the pair must be
	<a href="http://en.wikipedia.org/wiki/Deterministic_algorithm">deterministic</a>, in other words,
	the final state (including return values) must be a strict
	function of the initial state and order of execution.
<p>
<li>	The functions must be
	<a href="http://en.wikipedia.org/wiki/Linearizability">linearizable</a>.
</ol>

Interestingly enough, although the paper requires that the implementation
of an SNC, deterministic, and linearizable pair of functions each
contain at least one heavyweight instruction, it does <i>not</i> require that
this instruction be executed on each invocation.

<p><a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
Imagine an increment function that is not permitted to lose counts
even when multiple invocations execute concurrently, and that does
not return the value of the counter.
Must the implementation of such a function contain an
atomic read-modify-write instruction or a heavyweight memory barrier?
<br><a href="#qq2answer">Answer</a>

</p><p>So if we want our code to run fast, we have four ways to avoid
heavyweight instructions:

</p><ol>
<li>	Formulate the API to be non-SNC.
<p>
<li>	Design the implementation so that any required heavyweight
	instructions almost never need to actually be executed.
<p>
<li>	Accept non-determinism.
<p>
<li>	Accept non-linearizability.  The paper ignores
	this possibility, possibly due to the common academic
	view that non-linearizable algorithms are by
	definition faulty.
</ol>

<p>Interestingly enough,
<a href="http://wiki.cs.pdx.edu/rp/">relativistic programming</a>
has long suggested use of several of these approaches to attain
good performance and scalability.
The &ldquo;Laws of Order&rdquo; therefore provides a good theoretical
basis for understanding why relativistic programming is both
desirable and necessary.

</p><p>Let's take a look at some examples, starting with a memory allocator.
Given that concurrent calls to <code>kmalloc()</code> are not supposed
to return a pointer to the same block of memory, we have to conclude that
<code>kmalloc()</code> is SNC and thus might need heavyweight instructions
in its implementation.

<p><a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
How can we avoid the use of heavyweight instructions in the implementation
of <code>kmalloc</code>?
If it turns out to be impossible to completely avoid their use, how can
we reduce the frequency of their execution?
<br><a href="#qq3answer">Answer</a>

</p><p>The second example is of course RCU.
Let's focus on the <code>rcu_read_lock()</code>,
<code>rcu_read_unlock()</code>,
<code>synchronize_rcu()</code>,
<code>rcu_dereference()</code> and
<code>rcu_assign_pointer()</code> API members.
The <code>rcu_read_lock()</code> function is unaffected by any of the
other members, so any pair that includes <code>rcu_read_lock()</code>
is non-SNC, which is why this function need not include any heavyweight
instructions.
The same is true of <code>rcu_read_unlock()</code>.

</p><p>Interestingly enough, <code>synchronize_rcu()</code> is affected
by both <code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>,
in that the former can prevent <code>synchronize_rcu()</code> from
returning and the latter can enable it to return.
However, neither <code>rcu_read_lock()</code> nor
<code>rcu_read_unlock()</code> is affected by <code>synchronize_rcu()</code>.
This means that <code>synchronize_rcu()</code> is non-SNC and might therefore
have an implementation that does not use heavyweight instructions.
However, such an implementation seems quite implausible if you include
the actions of the updater both before and after the call to
<code>synchronize_rcu()</code> in conjunction with the RCU
read-side critical section.
The paper, though, considers only data flowing via
those function's arguments and return value.
It would be interesting to see a generalization of this work that
includes side effects.

</p><p>My guess is that for a given code fragment to be non-SNC, any conceivable
API would need to be non-SNC.
If my guess is correct, then the full RCU update is non-SNC with respect
to any RCU read-side critical section containing <code>rcu_dereference()</code>.
The reasoning is that the return value from <code>rcu_dereference()</code> can
be affected by the RCU update, and the duration for which
<code>synchronize_rcu()</code> blocks can be affected by
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>.

<p><a name="Quick Quiz 4"><b>Quick Quiz 4</b>:</a>
Are there any conditions in which <code>rcu_read_unlock()</code> will
be SNC with respect to <code>synchronize_rcu()</code>?
<br><a href="#qq4answer">Answer</a>

</p><p>Finally, let us look at the set implementation that includes
<code>set_add()</code>,
<code>set_member()</code>, and
<code>set_remove()</code>.
We saw that <code>set_add()</code> and <code>set_remove()</code>
were SNC.

<p><a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Is there any way to implement <code>set_add()</code> and
<code>set_remove()</code> without using heavyweight instructions?
<br><a href="#qq5answer">Answer</a>

</p><p>Of course, this paper does have a few shortcomings, many of
which fall under the rubric of &ldquo;future work&rdquo;:

</p><ol>
<li>	The paper describes the theoretical limitations at great length,
	but does not describe many ways of avoiding them.
	However, I am quite confident that the Linux kernel community will be
	more than able to produce good
	software engineering solutions that work around
	these limitations.
	In fact, there is a lot to be said for letting the theoreticians
	worry about limitations and letting us hackers worry about
	solving problems in spite of those limitations.<p>
<li>	The paper focuses almost exclusively on reordering carried out
	by the CPU.
	It turns out that reordering due to compiler optimizations can be
	at least as &ldquo;interesting&rdquo; as CPU reordering.
	These sorts of compiler optimizations are allowed by the
	current C-language standard, which permits the
	<a href="http://www.hpl.hp.com/techreports/2004/HPL-2004-209.html">compiler to
	assume that there is only one thread in the address space.</a>
	Within the Linux kernel, the <code>barrier()</code> directive
	restricts the compiler's ability to move code, and this
	directive (or its open-coded equivalent) is used in locking
	primitives, atomic operations, and memory barriers.<p>
<li>	There is some uncertainty about exactly what properties of code
	must be SNC for this paper's results to hold.
	The paper focuses almost exclusively on function arguments and return
	values, but
	my guess is that the list of properties is quite general.
	For example, an unconditional lock-acquisition primitive certainly
	seems like it should be covered by this paper's result,
	but such primitives do not return a value.
	Can the fact that the second of two concurrent acquisitions
	simply fails to return be considered to be evidence of the
	SNC nature of lock acquisition?
	If not, exactly why not?
	If so, exactly what is the set of effects that must be
	taken into account when judging whether or not this code fragment
	is SNC?<p>
	This seems to be a future-work topic.<p>
<li>	A bit of thought about the results of this paper
	give clear reasons why it is
	<a href="http://paulmck.livejournal.com/16478.html">often so hard to
	parallelize existing sequential code</a>.
	Sequential code inflicts no penalties for the use of SNC
	APIs, so SNC APIs can be expected to appear in sequential
	code even when a non-SNC API might have served just as well.
	After all, what programmer could resist the
	temptation to make <code>set_add()</code> return an indication
	of whether the element was already in the set?
	The paper would have done well to state this point clearly.<p>
<li>	The paper fails to call out non-linearizability as a valid
	loophole to its laws of order.<p>
<li>	An interesting open question: What are the consequences of
	using one of the loopholes of the laws of order?
	In my limited personal experience, leveraging non-linearizability
	and privatization permits full generality (for example,
	parallel memory allocators), while leveraging non-SNC and
	non-determinism results in specialized algorithms
	(for example, RCU).
	It would be quite interesting to better understand any
	theoretical and software-engineering limitations imposed
	by these loopholes.<p>
<li>	The paper overreaches a bit when it states that:
	<p>
	<div class="BigQuote">
		For synthesis and verification of concurrent algorithms,
		our result is potentially useful in the sense that a
		synthesizer or a verifier need not generate or attempt
		to verify algorithms that do not use RAW
		[<tt>smp_mb()</tt>] 
		and AWAR [atomic read-modify-write operations] for
		they are certainly incorrect.
	</div><p>
	As we have seen, it is perfectly legal for a concurrent algorithm
	to avoid use of these operations as long as that algorithm is either:
	(1)&nbsp;non-SNC, (2)&nbsp;non-deterministic, or (3)&nbsp;non-linearizable.
	There are a few other places where the limitations on the
	main result are not stated as carefully as they should be.
	Given that the rest of the paper seems quite accurate and
	on-point, I would guess that this sentence is simply an
	honest error that slipped through the peer-review process.
	We all make mistakes.
</ol>

</p><p>Although I hope that these shortcomings will be addressed, I
hasten to add that they are insignificant compared to the huge
step forward that this paper represents.

</p><p>In summary, the &ldquo;Laws of Order&rdquo; paper shines some
much-needed
light on the question of whether heavyweight instructions are needed to
implement a given concurrent algorithm.
Although I am not going to say that this paper fully captures my
parallel-programming intuition, I am quite happy that it does
land within a timezone or two, which represents a great improvement
over previous academic papers.
But the really good news is that the limitations called out in this
paper have some interesting
loopholes that can be exploited in many cases.
If the Linux kernel community pays careful attention to both the
limitations and the loopholes called out in this paper,
I am confident that the community's
already-impressive parallel-programming capabilities will
become even more formidable.

<h4><a name="Acknowledgments">
Acknowledgments</a></h4>

I owe thanks to Maged Michael, Josh Triplett, and Jon Walpole for illuminating
discussions and for their review of this paper, and to Jim Wasko
for his support of this effort.

<h4><a name="Legal Statement">
Legal Statement</a></h4>

</p><p>This work represents the view of the author and does not necessarily
represent the view of IBM.

</p><p>Linux is a registered trademark of Linus Torvalds.

</p><p>Other company, product, and service names may be trademarks or
service marks of others.


<h4><a name="Answers to Quick Quizzes">
Answers to Quick Quizzes</a></h4>

<a name="qq1answer"></a>
<p><b>Quick Quiz 1</b>:
Is <code>atomic_add_return()</code> SNC?  In other words, are multiple
concurrent calls to this function SNC? 


</p><p><b>Answer</b>: Yes.
Suppose that an <code>atomic_t</code> variable named <code>a</code>
is initially zero
and that a pair of concurrent <code>atomic_add_return(1,&nbsp;&amp;a)</code>
functions execute.
The first one to execute will return zero, and the second one will
return one.
Each instance's return value is therefore affected by the order of
execution, which indicates strong non-commutativity.

</p><p>This may seem strange, given that addition is commutative.
And in fact the final value of <code>a</code> will be two
regardless of order of execution.

</p><p>To see the reasoning behind the definition of SNC,
consider <code>atomic_inc(&amp;a)</code>,
which also adds one to <code>a</code> but does not return the
initial value.
In this case, because there are no return values, the invocations
of <code>atomic_inc(&amp;a)</code> cannot possibly affect each others'
return values.

</p><p>Therefore, <code>atomic_inc(&amp;a)</code> is non-SNC.

</p><p>It is interesting to note that the designers of the Linux
kernel's suite of atomic operations had an intuitive understanding
of the results of this paper.
The atomic operations that return a value (and thus are more likely
to be SNC) are the ones that are required to provide
full memory ordering.

</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

<a name="qq2answer"></a>
</p><p><b>Quick Quiz 2</b>:
Imagine an increment function that is not permitted to lose counts
even when multiple invocations execute concurrently, and that does
not return the value of the counter.
Must the implementation of such a function contain an
atomic read-modify-write instruction or a heavyweight memory barrier?

</p><p><b>Answer</b>: 
No.
Although this function is deterministic and linearizable, it is non-SNC.
And in fact such a function could be implemented via a &ldquo;split
counter&rdquo; that uses per-CPU non-atomic variables.
Because each CPU increments only its own variable, counts are never
lost.
To get the aggregate value of the counter, simply sum up the individual
per-CPU variables.

</p><p>Of course, it might be necessary to disable preemption and/or
interrupts across the increments, but such disabling requires
neither atomic read-modify-write instructions nor heavyweight memory
barriers.

</p><p>However, the linearizability of this function depends
on the counter always being incremented by the value 1.
To see this, imagine a counter with an initial value of zero
to which three CPUs are concurrently adding the
values 3, 5, and 7, and that meanwhile three other CPUs are
reading out the counter's value.
Because there are no ordering guarantees, these three other CPUs
might see the additions in any order.
One of these CPUs might add the per-CPU variables and obtain a sum
of 3, another might obtain a sum of 5, and the third might obtain
a sum of 7.
These three results are not consistent with any possible ordering
of the additions, so this counter is not linearizable.

</p><p>However, for a great many uses, this lack of linearizability
is not a problem.

</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

<a name="qq3answer"></a>
</p><p><b>Quick Quiz 3</b>:
How can we avoid the use of heavyweight instructions in the implementation
of <code>kmalloc()</code>?
If it turns out to be impossible to completely avoid their use, how can
we reduce the frequency of their execution?

</p><p><b>Answer</b>:
The usual approach is to observe that a given pair of invocations of
<code>kmalloc()</code> invocations will be SNC only if it is possible
for them to be satisfied by the same block of memory.
The usual way to greatly reduce the probability of a pair of
<code>kmalloc()</code> invocations fighting over the same block of
memory is to maintain per-CPU pools of memory blocks, which is what
the Linux kernel's implementation of <code>kmalloc()</code> actually
does.
Heavyweight instructions are executed only if a given CPU's pool either
becomes exhausted or overflows.
This approach is related to the paper's suggestion of using
&ldquo;single-owner&rdquo; algorithms.

</p><p>It might be possible to avoid heavyweight instructions by
introducing non-determinism, for example, by making <code>kmalloc()</code>
randomly fail.
This can certainly be accomplished by making <code>kmalloc()</code>
unconditionally return <code>NULL</code> if the CPU's pool was
exhausted, but such an implementation might not prove to be fully
satisfactory to its users.
Coming up with a reasonable implementation that uses non-determinism
to avoid heavyweight instructions is left as an exercise for the
adventurous reader.

</p><p>Similarly, eliminating heavyweight instructions by introducing
non-linearizability is left as an exercise for the adventurous reader.

</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

<a name="qq4answer"></a>
</p><p><b>Quick Quiz 4</b>:
Are there any conditions in which <code>rcu_read_unlock()</code> will
be SNC with respect to <code>synchronize_rcu()</code>?

</p><p><b>Answer</b>:
In some implementations of RCU, <code>synchronize_rcu()</code> can
interact directly with <code>rcu_read_unlock()</code> when the
grace period has extended too long, either via
<a href="http://lwn.net/Articles/305782/"><code>force_quiescent_state()</code></a>
machinations our via
<a href="http://lwn.net/Articles/220677/">RCU priority boosting</a>.
In these implementations, <code>rcu_read_unlock()</code> will
be SNC with respect to <code>synchronize_rcu()</code>.  The
Linux kernel's Preemptible Tree RCU
is an example of such an implementation, as can be seen by examining
the <code>rcu_read_unlock_special()</code> function in
<code>kernel/rcutree_plugin.h</code>.
This code executes rarely, thus using the second loophole called out
above (&ldquo;Design the implementation so that any required heavyweight
instructions almost never need to actually be executed&rdquo;).


</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>

<a name="qq5answer"></a>
</p><p><a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Is there any way to implement <code>set_add()</code> and
<code>set_remove()</code> without using heavyweight instructions?

</p><p><b>Answer</b>:
This can be done easily for sets containing small integers if
there is no linearizability requirement.
The set is represented as a dense array of bytes so that each potential
member of the set maps to a specific byte.
The <code>set_add()</code> function would set the corresponding byte to
one, the <code>set_remove()</code> function would clear the corresponding
byte to zero, and the <code>set_member()</code> function would
test the corresponding byte for non-zero.

</p><p>This implementation is non-linearizable because different CPUs
might well disagree on the order that members were added to and removed
from the set.

<p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_barriers">Memory barriers</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/423994/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor424994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kmalloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2011 4:41 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/424994/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <i>a given pair of invocations of kmalloc() invocations will be SNC only if it is possible for them to be satisfied by the same block of memory</i>
<p>
If the number of bytes requested is different for the two calls, they are not SNC.  This seems to argue for providing a different allocator for each size, or anyway for a collection of useful sizes, on the assumption that with enough sizes in play, two requests for the same amount will be rare.  <p>
A reliable kmalloc can be constructed from an unreliable kmalloc and a loop.  If the unreliable kmalloc can be made just reliable enough, that's almost as good.
      
          <div class="CommentReplyButton">
            <form action="/Articles/424994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor425230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kmalloc and SNC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2011 22:35 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/425230/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Even for allocators that segregate memory on a per-request-size basis, different-sized calls can be SNC &mdash; especially if the allocator can recycle memory that was of one size to satisfy future requests of another size.  However, SNC behavior can occur even in the absence of such recycling.  To see this, consider an initially empty allocator in which the first pair of requests arrive concurrently and have different request sizes.  It is then quite possible that the two requests might be satisfied by the same block of memory, given that the initial request will normally allocate a large block (e.g., a page) and break it up into blocks of the requested size.

<p>All that aside, it is true that per-size caching is an example of privatization that further reduces the probability that a given allocation/free request will need to execute an expensive instruction.

<p>Your point about calling an unreliable kmalloc() in a loop is a good one (real-time heartburn notwithstanding), although given my scenario it would loop forever &mdash; or until an interrupt handler running on that same CPU happened to free a block of the desired size.
      
          <div class="CommentReplyButton">
            <form action="/Articles/425230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor425156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2011 18:32 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/425156/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The usual way for theory to take into account side effects is to have the function accept and return a big structure that has everything that could change in it. That is "lock()" implicitly takes the memory that its argument is a pointer to, and implicitly returns it with a new value. Of course, the architecture's calling conventions don't have to arrange for these exchanges because the universe takes care of it (that is, when a function returns, it doesn't have to report its changes to its caller in order for the RAM to give the updated values); on the other hand, this is why values read from memory and stored in callee-saved registers have to be reloaded after function calls.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/425156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor425232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2011 22:36 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/425232/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds sort of like Haskell monads.  ;-)  I pointed one of the authors at your comment, perhaps it will be helpful to them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/425232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor425383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2011 16:15 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/425383/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds almost exactly like Haskell monads, if 'everything that could change' is set equal to 'the entire world'. (Of course monads were invented precisely to transform those annoying side-effects into nice clean function parameters, so this is not at all surprising.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/425383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor425165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2011 18:40 UTC (Thu)
                               by <b>jeremiah</b> (subscriber, #1221)
                              [<a href="/Articles/425165/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thoroughly enjoyable article.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/425165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor425378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2011 15:52 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/425378/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite so. The term 'linearizable' rather than 'atomic' threw me at first, but once I grasped it, the rest was a very readable elucidation of an intricate topic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/425378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor427447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2011 22:24 UTC (Thu)
                               by <b>Julie</b> (guest, #66693)
                              [<a href="/Articles/427447/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      A really absorbing article. <br>
I find Paul's Quick Quiz feature incredibly useful too by helping the points he's making sink in more thoroughly, particularly as I read LWN mostly late at night when my mental acuity is past its best ;-/ <br> It would be great if more technical articles or discussions included this.
One tiny niggling point with Quick Quiz 1 though: 

<i><p>Is atomic_add_return() SNC? In other words, are multiple concurrent calls to this function SNC? <br><br>

Answer: Yes. Suppose that an atomic_t variable named a is initially zero and that a pair of concurrent atomic_add_return(1, &amp;a) functions execute. The first one to execute will return zero, and the second one will return one.</p></i>

I think atomic_add_return() returns the result not the initial value, so the first one to execute will return one, and the second one will return two, right? :-)

      
          <div class="CommentReplyButton">
            <form action="/Articles/427447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor435388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2011 3:10 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/435388/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are quite correct.  I was confusing atomic_add_return() with the x86 xadd instruction.  Not quite the same!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/435388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor585627"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2014 11:16 UTC (Wed)
                               by <b>ego360</b> (subscriber, #39650)
                              [<a href="/Articles/585627/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Nice article Paul. 

<br>
In the answer to Quick quiz 2, you say:

<p>
<i>However, the linearizability of this function depends on the counter always being incremented by the value 1</i>
</p>

<p>
If the counter is always incremented by some constant value <i>k</i>, that would also guarantee linearizability, no ?
</p>

<p>
It is interesting that you mention the split counter approach to implement a counter that doesn't lose counts and yet doesn't use any heavyweight instructions. The G-Counters implemented in RIAK as a part of their <a href="https://github.com/aphyr/meangirls"> Conflict Free Replicated Datatypes (CRDT) suite</a> use a similar approach. It is another story that these data structures have been implemented for the distributed systems world. But then considering that on modern multiprocessor systems, the data is cached at so many levels, should we not model these systems as distributed systems since different processing units might not have the same view of the state of the system? We could then use alternate weaker notions of consistency such as eventual consistency to argue about the correctness about our implementations instead of ignoring concurrent algorithms that are not linearizable.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/585627/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor614538"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Concurrent code and expensive instructions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2014 6:00 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/614538/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are quite right, incrementing by any constant (and especially the constant zero!) guarantees linearizability.<br>
<p>
And I agree that it can make a lot of sense to apply distributed-system algorithms to shared-memory systems, especially to the fastpath portions of shared-memory systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/614538/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
