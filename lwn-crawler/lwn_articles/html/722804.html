        <!DOCTYPE html>
        <html lang="en">
        <head><title>IPv6 segment routing [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/722804/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/722566/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/722804/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>IPv6 segment routing</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="GAByline">
           <p>May 17, 2017</p>
           <p>This article was contributed by David Lebrun</p>
           </div>
<p>In November 2016, a new networking feature, IPv6 segment
routing (also known as "IPv6 SR" or "SRv6"), was <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next.git/commit/
?id=5db5b395150186d4a177ebfa563894af302ab3ad">merged</a> into net-next and
subsequently included in Linux 4.10. In
this article, we explain this new feature, describe key elements of its
implementation, and present a few performance measurements.</p>

<h4>Routing at the source</h4>

<p>Segment routing is a modern source-routing architecture that is being

<a href="https://tools.ietf.org/html/draft-ietf-spring-segment-routing-11">developed</a>

within the IETF. Traditional IP routing uses destination-based hop-by-hop
forwarding. Each intermediate router decides where to forward packets using its
local routing table. This table is usually computed according to a
shortest-path algorithm. As such, packets traverse networks following the
shortest 
path toward their destination. This behavior is not always optimal, as the
shortest path can have undesirable properties, such as congestion.
<p>
Existing
traffic-engineering techniques enable coarse-grained control over a packet's
path by tuning parameters, such as link weights, to adjust the shortest
path algorithm. However, these techniques cannot control traffic on a 
per-flow basis. Segment routing, instead, can forward packets along
non-shortest paths 
toward their destination by specifying a list of detours or waypoints called
"segments". This list is specified within the packet itself. Packets are
forwarded along the shortest path from the source to the first segment, then
through the shortest path from the first segment to the second segment, and
so on. The source of the packet can thus specify its path with an arbitrary
precision. Segment routing defines two main types of segments representing
topological instructions. A "node" segment is used to steer packets through
a specific network node, while an "adjacency" segment steers packets
through a particular link.</p>

<p>The segment routing architecture has been
instantiated in two different data planes:
<a
href="https://en.wikipedia.org/wiki/Multiprotocol_Label_Switching">Multiprotocol
Label Switching</a> (<a
href="https://tools.ietf.org/html/draft-ietf-spring-segment-routing-mpls-07">MPLS</a>)
and 
<a href="https://tools.ietf.org/html/draft-ietf-6man-segment-routing-header-06">IPv6</a>.
The MPLS variant of SR is already implemented by network vendors and deployed by operators.</p>

<p>SRv6 is implemented with an IPv6 extension header, the <a
href="https://tools.ietf.org/html/rfc2460#section-4.4">routing
header</a>. The <a
href="https://tools.ietf.org/html/draft-ietf-6man-segment-routing-header-06#sect
ion-3">segment routing header</a> (SRH) contains a list of segments, encoded
as IPv6 addresses. A segment represents a topological instruction (node or
link traversal) or any operator-defined instruction (e.g., a virtual function).
An SRH can be used to steer packets through paths with given properties
(e.g., bandwidth or latency) and through various network functions (such as a
firewall). The list of segments present in the SRH thus specifies the network
policy that applies to the packet. Each SRH contains at least a list of segments
and a "segments left" pointer that references the current active segment
(a value of zero refers to the last segment). In addition, an SRH can optionally
include extended information encoded as type-length-value (TLV) fields.
One example is the optional HMAC TLV, used for authenticity and integrity
checks.</p>

<p>When a router must impose an SRH on a forwarded packet, the packet is
encapsulated in an outer IPv6 header containing the SRH. The original packet is
left unmodified as the payload. The router is called the "SR ingress node".
The destination address of the outer IPv6 header is set to the first segment
of the list and the packet is forwarded to the corresponding node following
the shortest path. This node (called a "segment endpoint") then processes
the packet by updating the destination address to the next segment. The last
segment of the list is the "SR egress node". It decapsulates the inner
packet and forwards it to its original destination.
<p>
<h4>Data-plane implementation</h4>

<p>The core of the SRv6 implementation is the SRH processing capability. It enables
a Linux node to act as both a segment endpoint and an SR egress node. When a
segment endpoint receives an IPv6 packet containing an SRH, the destination
address of the packet is local to the segment endpoint. To process this packet,
a new <tt>ipv6_srh_rcv()</tt> function is called whenever the IPv6 input
function encounters an SRH in the header chain. An SRH is defined by the
following structure:</p>

<pre>
    struct ipv6_sr_hdr {
    	__u8    nexthdr;
    	__u8    hdrlen;
    	__u8    type;
   	__u8    segments_left;
    	__u8    first_segment;
    	__u8    flags;
    	__u16   reserved;
    	struct in6_addr segments[0];
    };
</pre>

<p>The <tt>ipv6_srh_rcv()</tt> function performs several operations.
First, it checks that the node is allowed to act as a segment
endpoint for SR-enabled packets coming from the ingress interface
(<tt>skb-&gt;dev</tt>). This policy is configured through the sysctl boolean
<tt>net.ipv6.conf.&lt;interface&gt;.seg6_enabled</tt>. If it is set to 
0, then the packet is discarded. Otherwise, the processing continues.
<p>
The packet then goes through an optional HMAC validation, controlled with
the sysctl knob
<tt>net.ipv6.conf.&lt;interface&gt;.seg6_hmac_require</tt>. This parameter can
take three different values.  If <tt>seg6_hmac_require</tt> is set to -1,
the node accepts all SR packets, regardless of the status (absent/present,
valid/invalid) of the HMAC TLV.  When it is set to zero, the node must
accept packets that contain an SRH and either present a valid HMAC TLV or
do not include an HMAC TLV at all.  Finally, a setting of&nbsp;1 means that the
node accepts only the SR packets that include a valid HMAC. 


<p>The next operations depend on the value of the "segments left" counter. If
it is greater than zero, then the packet must be forwarded to the
next segment. The field is decremented and the destination address of
the packet is updated to the next segment. A route lookup is performed
and the packet is forwarded.</p>

<p>If, instead, there are no segment left, the operation will depend on the
next header. 
If it is another extension header or a final payload such as TCP or UDP, then
the kernel assumes that the packet must be delivered to a local application.
The packet processing then continues as normal. On the other hand, if the next
header is another IPv6 header, then the kernel assumes that the packet is an
encapsulation. The inner packet is then decapsulated and reinjected in the
ingress interface using <tt>netif_rx()</tt>.</p>

<h4>Control plane implementation</h4>

<p>To support SRH encapsulation, the SRv6 implementation uses the
<a href="https://lwn.net/Articles/651497/">lightweight tunnels</a> (LWT)
infrastructure. LWTs can associate custom <tt>input</tt> and
<tt>output</tt> function pointers (in
<tt>struct dst_entry</tt>) to route objects. Those functions are called when
a packet is 
forwarded by the kernel (input) and generated by a local
application (output). A per-route stateful data structure (the "tunnel state")
is also maintained.
<p>
For SRv6, the function pointers are set to 
<tt>seg6_input()</tt> and <tt>seg6_output()</tt>. Those functions encapsulate
a packet within an outer IPv6 header that contains a
pre-configured SRH. The SRH is stored as the tunnel state, along with a
<tt>struct dst_cache</tt>. This structure stores the route associated
with the first segment of the SRH. Indeed, all packets that receive an SRH will
be immediately forwarded to their first segment. Using a cache thus prevents an
unnecessary route lookup for each processed packet.</p>

<p>To configure the routes, the <tt>iproute2</tt> tool has been extended. An
SRv6 encapsulation route can be defined as follows:</p>

<pre>
    # ip -6 route add fc42::/64 encap seg6 mode encap \
         segs fc00::1,2001:db8::1,fc10::7 dev eth0
</pre>

<p>This command inserts a route for the prefix <tt>fc42::/64</tt>. Each matching
packet receives an SRH with three segments. Note that it is mandatory to specify
a non-loopback interface.</p>

<p>The routes configured by <tt>iproute2</tt> are namespace-wide. To support 
finer-grained control of the SRH insertion, the SRv6 implementation also supports
a per-socket interface, using the <tt>setsockopt()</tt> system call. This interface
enables an application to specify its own per-socket SRH. The following
piece of code shows how an application can use this feature:</p>

<pre>
    struct ipv6_sr_hdr *srh;
    int srh_len;

    srh_len = build_srh(&amp;srh);
    fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    setsockopt(fd, IPPROTO_IPV6, IPV6_RTHDR, srh, srh_len);
</pre>
<p>
<h4>HMAC</h4>

<p>The authenticity and integrity of an SRH can be ensured using an HMAC TLV.
This HMAC covers the source address of the packet and the full SRH (excluding
TLVs). The HMAC TLV contains an opaque, operator-defined key ID. In the Linux
SRv6 implementation, this identifier refers to a hashing algorithm (currently,
SHA-1 and SHA-256 are supported) and to the HMAC secret.</p>

<p>The HMAC support is implemented using static per-CPU ring buffers to store
the input data and pre-allocated, per-CPU algorithm descriptors to store the
auxiliary buffer/context of the hashing algorithms. Pre-allocation prevents
doing expensive dynamic memory allocation for each processed packet, and per-CPU
data prevents lock contention.</p>

<p>To associate an HMAC with an SRv6 route, the <tt>iproute2</tt> tool provides
an <tt>hmac</tt> keyword. The command <tt>ip&nbsp;sr</tt> enables
configuration of the
hashing algorithm and secret associated with a given key ID.</p>

<h4>Performance</h4>

<p>An evaluation shows that the SRH encapsulation performance is within 12% of
plain IPv6 forwarding. The following figure summarizes the results, performed
on Xeon X3440 machines with Intel 82599 10 Gbps interface cards:</p>

<blockquote>
<img src="https://static.lwn.net/images/2017/srv6-perf.png" alt="Performance chart" class="photo">
</blockquote>

<p>In red is shown the performance for a single flow, processed by a single
CPU. The blue bars show the performance for an arbitrarily large number of
flows, with the receive-side scaling feature enabled (i.e., the flows are
evenly processed by all the CPUs). With the multi-flow measurements, plain
IPv6 forwarding peaks at about 4.9Mpps, while SRv6 encapsulation reaches
4.3Mpps. The HMAC computation (using the SHA-256 algorithm) performance
reaches 
only 1.2Mpps. Profiling shows that most of the CPU cycles are used in the
<tt>sha256_transform()</tt> function, which is the main processing function for the
hashing algorithm.</p>

<p>The multi-flows measurements are about four times better than the single-flow
measurements. This is explained by the fact that the test machine actually
has four physical cores with HyperThreading enabled. Considering this, the SRv6
encapsulation performance seems to scale linearly with respect to the available
CPU power.</p>
<p>
SRv6 is a promising new source-routing technique. For obvious security
reasons, it is intended to run within the bounds of an administrative
domain. As such, it provides network operators with a powerful traffic
engineering and flow management tool. With the help of a central
controller, segment routing can implement a software-defined network
paradigm, providing an alternative to <a
href="https://en.wikipedia.org/wiki/OpenFlow">OpenFlow</a>-based networks. 
Currently, multiple service providers are exploring the potential of
SRv6. Enterprise networks may also benefit from this technique, as IPv6
deployments increase in this kind of environment.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-IPv6">Networking/IPv6</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Lebrun_David">Lebrun, David</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/722804/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor723146"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2017 6:51 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/723146/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Am I reading that iproute2 example right? It looks like this makes it possible to bridge site-local private networks over the public internet without any extra software. I can see that being extremely useful but I'm also going to have to be extra-clever with firewall rules from now on...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723146/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor723148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2017 7:12 UTC (Thu)
                               by <b>dalebrun</b> (subscriber, #105802)
                              [<a href="/Articles/723148/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's right ! By default, Linux drops packets that contain an SRH, but in case you enable this feature in your network, you need to make sure to filter such packets at the edge.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor723232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2017 18:44 UTC (Thu)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/723232/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think this will work on the public internet as the provider would have no reason to trust your packet markings and should be dropping them at their border.  You can't self-subscribe to the providers MPLS network or IGP or QoS either, but this could be a useful tool inside of an administrative domain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor723348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 20, 2017 7:44 UTC (Sat)
                               by <b>obonaventure</b> (guest, #108715)
                              [<a href="/Articles/723348/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The HMAC provides some security feature and it is possible for a provider to give SRH that are linked to some specific services or features to some of its customers and use the HMAC to ensure that only those users benefit from the service.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor723498"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2017 6:23 UTC (Tue)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/723498/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Actually this is really useful for cross-boundary applications. You can't use MPLS for that effectively, as implementations usually carry too much access into the interior forwarding plane of the neighbour, and MPLS ACLing is next to non-existent. So you end up having to signal per-flow information using the DSCP markings, which you then flick into a particular MPLS tag at your network edge. There's simply not enough QoS tags to ennumerate features beyond simplistic features like "worst effort".</p>

<p>What SRH allows is the user's application to select routing features for each flow. You can them impose a further SRH on that to fully enumerate the route within your network, or flip them into a MPLS virtual router, or select a different routing table, etc. This allows ISPs to move towards per-application routing, which is an attractive place to be for CDNs (which are currently hacked-up using DNS resolver addresses to determine the CDN node to use). As noted, the HMAC can be used for access control, although in the CDN case, only being able to reach particular CDN nodes is probably punishment enough to limit abuse.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/723498/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor723177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2017 15:06 UTC (Thu)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/723177/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is fun to see that IPv4 features that has been removed in IPv6 as "deprecated" are coming back.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor723436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2017 11:56 UTC (Mon)
                               by <b>niner</b> (subscriber, #26151)
                              [<a href="/Articles/723436/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Only that this is a comeback without the security nightmare, i.e. it's actually useful in practice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor723326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2017 18:50 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/723326/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Each intermediate router decides where to forward packets using its local routing table. This table is usually computed according to a shortest-path algorithm. As such, packets traverse networks following the shortest path toward their destination.</font><br>
<p>
Not particularly relevant but it might be worth noting that that only really applies within smallish networks, not across the global internet or very large intranets that use BGP.<br>
<p>
If I remember correctly, BGP's primary consideration when choosing routes is simply to avoid loops; its secondary considerations are often commercial and only locally optimal, e.g. it's usually best to send traffic to your customers (who are paying you for traffic) if they'll accept it, else to peers (who you've agreed to exchange traffic with for free), and only to providers (who you have to pay) if unavoidable, without caring how far the traffic goes once it's off your own network. It's also common to prefer or filter routes based on arbitrary tags set by your neighbours to get all kinds of complicated behaviour, e.g. only advertising routes to peers in a particular continent.<br>
<p>
Once BGP has done all that (and more) and still has no preference between two or more possible routes, then it finally bothers to look at which path is 'shortest' (based on number of ASes it passes through; of course people often put their AS into the route's AS list multiple times to make it 'longer' and less preferred, which is okay until so many people do it that the list length reaches 256 and some routers treat it as a fatal error and disconnect from their neighbours and the internet breaks).<br>
<p>
One consequence of not simply computing shortest paths is that shortest-path algorithms don't work. BGP tries to use one anyway, so you can break the algorithm and get instability or get permanently stuck in incorrect states if you're unlucky, which is fun.<br>
<p>
Source routing seems to fundamentally rely on the source being trusted by the network operators that the route crosses (because you don't want to accept a packet that asks to be sent back and forth across the Atlantic a hundred times) so I guess it's never going to work across the internet. But it's useful within a trusted network, since most of your routers can use a simple dumb routing algorithm and don't need a million-entry IP forwarding table, and the complex policy is only needed at the edges. (I think this is what large networks have always done, using MPLS; Segment Routing sounds like basically a better (and more IPv6-friendly) way of assigning MPLS labels, and the SRH sounds like basically an alternative to MPLS for forwarding.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor723328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2017 19:31 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/723328/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      The usual problem with BGP is that it only has the distance information. So if you have something like this:<br>
<pre>
AS0 -  AS1 - AS2 - AS3 (1GBps) - AS7 (1GBps) - AS4
          |- AS5 - AS6 (1kbps) ----------------|
</pre>
Then there's no way for AS0 to prefer the first route to the second one (without administrative intervention). And this is OK with global Internet - you are not administrative authority for AS1 and you shouldn't be able influence it (directly).<br>
<br>
However, you can have similar problems within one organization and you should be able to solve them. OSPF and IS-IS allow you to do weighted paths but that's not always enough in the current world. <br>
<br>
For example, you might want to have different networks paths for low-latency traffic and high-bandwidth flows. Managing two topologies on top of OSPF is... challenging. <br>
<br>
And in some situations you might also want to send out traffic across all your links, not just the lowest cost ones. But this can easily lead to routing loops with distance-based protocols. So you really need to have an "eagle eye" view of the topology for that, you can't make it work with routing decisions based only on local connectivity information.<br>
<br>
You still can kinda make it work by using the regular source-based routing by uploading decision tables into every router on the path, but this just doesn't scale.<br>
<br>
MPLS (and ipv6sr) allows to work around that - you can have a central "route planning" system that uploads the full routing information into your edge routers and they basically encode it in every packet and the rest of the network can stay dumb and stateless.
      
          <div class="CommentReplyButton">
            <form action="/Articles/723328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor723352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 20, 2017 9:22 UTC (Sat)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/723352/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <i><blockquote>MPLS (and ipv6sr) allows to work around that - you can have a central "route planning" system that uploads the full routing information into your edge routers and they basically encode it in every packet and the rest of the network can stay dumb and stateless.</blockquote></i>
<p>
The rest of the network can't stay stateless though. In order for the transmitting node to specify exactly the route it wants, it needs to have have a lot of information on the state network (there's not much source routing to do otherwise). The state of the network must be gathered and communicated around, by the network - which requires holding state. The network can never abstract that information either, if source routing is to be useful, so the bigger the network the worse this scales.
<p>
Source routing is powerful, but it comes with its own set of problems. As is often the case in networking and computer systems, we tend to oscillate back and forth and re-visit things. What is old becomes hot again. Distributed routing! Centralised! Next-hop routing! Source-routing! This has been going on for many decades... ;)
<p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/723352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor741997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2017 3:16 UTC (Thu)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/741997/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly... the *rest* of the network (i.e. not the edge) can stay stateless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/741997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor840688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2020 12:20 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/840688/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How does the network communicate the information about its state - as required to compute source-specified routes through it - to the edges, without holding state?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/840688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor840774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2020 20:38 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/840774/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In MPLS you have a stack of labels attached to every packet. Every router pops a label from the stack and does some action based on that.<br>
<p>
You can literally encode all the route information in labels that are interpreted like this: &quot;send the packet to port 8, pop label, send the packet to port 2, pop label, ...&quot;. And all this encoding can be done on the edge router so the inner routers don&#x27;t have to know anything.<br>
<p>
As you said, the problem is that &quot;port 2&quot; might not actually be working, so all the traffic is going to be blackholed. This is typically solved by having a separate control plane network that is used to communicate the state of individual routers. It can physically run on top of the same media, just with special labels that instruct the routers to do something like &quot;decapsulate packet, and punt it to the CPU&quot;. The CPU then runs a classic IS-IS/OSPF stack and marks the outgoing packets with the same &quot;decapsulate and punt&quot; label.<br>
<p>
One large cloud provider has a fully separate network for the control plane, it&#x27;s not even using the same physical hardware to avoid any possibility of interference of customer data flows with the control plane.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/840774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor840777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2020 22:43 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/840777/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I&#x27;m familiar with the forwarding plane.<br>
<p>
How do you build a distributed control-plane for it that can allow the &#x27;core&#x27; to be dumb and at least scale well (i.e., the state grows at a less-than-linear rate, relative to growth in the number of nodes), if not stateless (which to my thinking, implies constant state at each node, regardless of the size of the node).<br>
<p>
OSPF/IS-IS don&#x27;t scale up arbitrarily. They need O(N . LogN + M) entries in each flooding domain, for N nodes with M links, and a further O(N.logN) amount of state for vectored destinations outside of flooding domains. RSVP-TE scales much worse again.<br>
<p>
If you know how to make source-routing scale well, you should write a Ph.D. on it - or start a company.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/840777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor840779"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2020 23:04 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/840779/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; How do you build a distributed control-plane for it that can allow the &#x27;core&#x27; to be dumb and at least scale well (i.e., the state grows at a less-than-linear rate, relative to growth in the number of nodes), if not stateless (which to my thinking, implies constant state at each node, regardless of the size of the node).</font><br>
Individual data-plane routers just need a handful of rules (in the extreme, equal to the number of ports).<br>
<p>
<font class="QuotedText">&gt;  OSPF/IS-IS don&#x27;t scale up arbitrarily. They need O(N . LogN + M) entries in each flooding domain, for N nodes with M links, and a further O(N.logN) amount of state for vectored destinations outside of flooding domains. RSVP-TE scales much worse again.</font><br>
You need OSPF/ISIS only for the control plane nodes, and you don&#x27;t need many of them. Perhaps tens of thousands even for  the extremely large networks (e.g. an Amazon AWS region). This amount of state can be easily managed through OSPF/ISIS flooding over gigabit-range links.<br>
<p>
You also don&#x27;t need to do that in hardware (so no worries about TCAM capacity), purely software routing is fine.<br>
<p>
<font class="QuotedText">&gt;  If you know how to make source-routing scale well, you should write a Ph.D. on it - or start a company.</font><br>
I did look into it, but it&#x27;s hard. You might have maybe several dozens of very large potential customers and it&#x27;s a very hard market to get into. Every customer will require a lot of custom integration with their system, and for a startup it&#x27;s just not feasible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/840779/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor723349"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 20, 2017 7:48 UTC (Sat)
                               by <b>obonaventure</b> (guest, #108715)
                              [<a href="/Articles/723349/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IPv6 Segment Routing has much interesting use cases than MPLS becomes the endhost can also select the path with a specific segment list. MPLS is mainly controlled by routers. See <a href="https://tools.ietf.org/html/draft-ietf-spring-ipv6-use-cases-10">https://tools.ietf.org/html/draft-ietf-spring-ipv6-use-ca...</a> for some use cases <br>
<p>
The recent SRv6 programming draft also provide additional use cases and benefits for IPv6 SR that cannot easily be realised with MPLS<br>
<a href="https://tools.ietf.org/html/draft-filsfils-spring-srv6-network-programming-00">https://tools.ietf.org/html/draft-filsfils-spring-srv6-ne...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723349/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor723631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPv6 segment routing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2017 9:34 UTC (Wed)
                               by <b>stevenc</b> (guest, #114573)
                              [<a href="/Articles/723631/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There could be some interesting applications of this, especially in peer-to-peer and mesh networking.  It reminds me of onion routing (e.g. Tor circuits that pick 3 hops to another endpoint), but unfortunately in this case without decryption at each hop.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/723631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
