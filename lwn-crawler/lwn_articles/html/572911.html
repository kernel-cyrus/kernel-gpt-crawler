        <!DOCTYPE html>
        <html lang="en">
        <head><title>The pernicious USB-stick stall problem [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/572911/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/572507/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/572911/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The pernicious USB-stick stall problem</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 6, 2013</br>
           </div>
Artem S. Tashkinov recently <a href="/Articles/572919/">encountered</a> a
problem that will be familiar to at least some LWN readers.  Plug a slow
storage device (a USB stick, say, or a media player) into a Linux machine
and write a lot of data to it.  The entire system proceeds to just hang,
possibly for minutes.  Things eventually come back, but, by then, the user
may well have given up in disgust and gone for a beer or two; by the time
the system is usable again, that user may well have lost interest.
<p>
This time around, though, Artem made an interesting observation: the system
would stall when running with a 64-bit kernel, but no such problem was
experienced when using a 32-bit kernel on the same hardware.  One might
normally expect the block I/O subsystem to be reasonably well isolated from
details like the word length of the processor, but, in this case, one would
be surprised.
<p>
<h4>The problem</h4>
<p>
Linus was quick to <a href="/Articles/572921/">understand</a> what was
going on here.  It all comes down to the problem of matching the rate at
which a process creates dirty memory to the rate at which that memory can be
written to the underlying storage device.  If a process is allowed to dirty
a large amount of memory, the kernel will find itself committed to writing
a chunk of data that 
might take minutes to transfer to persistent storage.  All that data clogs
up the I/O queues, possibly delaying other operations.  And, as soon as
somebody calls <tt>sync()</tt>, things stop until that entire queue is
written.  It's a storage equivalent to the bufferbloat problem.
<p>
The developers responsible for the memory management and block I/O
subsystems are not entirely unaware of this problem.  To prevent it from
happening, they have created a set of tweakable knobs under
<tt>/proc/sys/vm</tt> to control what happens when processes create a lot
of dirty pages.  These knobs are:
<p>
<ul>
<li> <tt><b>dirty_background_ratio</b></tt> specifies a percentage of memory; when
     at least that percentage is dirty, the kernel will start writing those
     dirty pages back to the backing device.  So, if a system has 1000
     pages of memory and <tt>dirty_background_ratio</tt> is set to 10% (the
     default), writeback will begin when 100 pages have been dirtied.
<p>
<li> <tt><b>dirty_ratio</b></tt> specifies the percentage at which processes that
     are dirtying pages are made to wait for writeback.  If it is set to
     20% (again, the default) on that 1000-page system, a process dirtying
     pages will be made to wait once the 200th page is dirtied.  This
     mechanism will, thus, slow the dirtying of pages while the system
     catches up.
<p>
<li> <tt><b>dirty_background_bytes</b></tt> works like
     <tt>dirty_background_ratio</tt> except that the limit is specified as
     an absolute number of bytes.
<p>
<li> <tt><b>dirty_bytes</b></tt> is the equivalent of <tt>dirty_ratio</tt> except
     that, once again, it is specified in bytes rather than as a percentage
     of total memory.
</ul>
<p>
Setting these limits too low can affect performance: temporary files that
will be deleted immediately will end up being written to persistent
storage, and smaller I/O operations can lead to lower I/O bandwidth and
worse on-disk placement.  Setting the limits too high, instead, can lead to
the sort of overbuffering described above.
<p>
The attentive reader may well be wondering: what happens if the
administrator sets both <tt>dirty_ratio</tt> and <tt>dirty_bytes</tt>,
especially if the values don't agree?  The way things work is that either
the percentage-based or byte-based limit applies, but not both.  The one
that applies is simply the one that was set last; so, for example, setting
<tt>dirty_background_bytes</tt> to some value will cause
<tt>dirty_background_ratio</tt> to be set to zero and ignored.
<p>
Two other details are key to understanding the behavior described by
Artem: (1)&nbsp;by default, the percentage-based policy applies, and
(2)&nbsp;on 32-bit systems, that ratio is calculated relative to the 
amount of low memory â€” the memory directly addressable by the kernel, not
the full amount of memory in the system.  In almost all 32-bit systems,
only the first ~900MB of memory fall into the low-memory region.  So on any
current system with a reasonable amount of memory, a 64-bit kernel will
implement <tt>dirty_background_ratio</tt> and <tt>dirty_ratio</tt>
differently than a 32-bit system will.  For Artem's 16GB system, the 64-bit
<tt>dirty_ratio</tt> limit would be 3.2GB; the 32-bit system, instead, sets
the limit at about 180MB.
<p>
The (huge) difference between these two limits is immediately evident when
writing 
a lot of data to a slow storage device.  The lower limit does not allow
anywhere near as much dirty data to accumulate before throttling the
process doing the writing, with much better results for the user of the
system (unless said user <i>wanted</i> to give up in disgust and go for
beer, of course).
<p>
<h4>Workarounds and fixes</h4>
<p>
When the problem is that clearly understood, one can start to talk about
solutions.  Linus suggested that anybody running into this kind of problem
can work around it now by setting <tt>dirty_background_bytes</tt> and
<tt>dirty_bytes</tt> to reasonable values.  But it is generally agreed
that the default values on 64-bit systems just don't make much
sense on contemporary systems.  In fact, <a
href="/Articles/572928/">according to Linus</a>, the percentage-based
limits have outlived their usefulness in general:
<p>
<div class="BigQuote">
	The percentage notion really goes back to the days when we
	typically had 8-64 *megabytes* of memory So if you had a 8MB
	machine you wouldn't want to have more than one megabyte of dirty
	data, but if you were "Mr Moneybags" and could afford 64MB, you
	might want to have up to 8MB dirty!!
<p>
	Things have changed.
</div>
<p>
Thus, he suggested, the defaults should be changed to use the byte-based
limits; either that, or the percentage-based limits could be deemed to
apply only to the first 1GB of memory.
<p>
Of course, it would be nicer to have smarter behavior in the kernel.  The
limit that applies to a slow USB device may not be appropriate for a
high-speed storage array.  The kernel has logic now that tries to estimate
the actual writeback speeds achievable with each attached device; with that
information, one could try to limit dirty pages based on the amount of time
required to write them all out.  But, as Mel Gorman <a
href="/Articles/572929/">noted</a>, this approach is "<q>not that trivial
to implement</q>".
<p>
Andreas Dilger <a href="/Articles/572930/">argued</a> that the whole idea
of building up large amounts of dirty data before starting I/O is no longer
useful.  The Lustre filesystem, he said, will start I/O with 8MB or so of
dirty data; he thinks that kind of policy (applied on a per-file basis)
could solve a lot of problems with minimal complexity.  Dave Chinner,
however, <a href="/Articles/572931/">sees a more complex world</a> where
that kind of policy will not work for a wide range of workloads.
<p>
Dave, instead, suggests that the kernel focus on implementing two
fundamental policies: "writeback caching" (essentially how things work now)
and "writethrough caching," where much lower limits apply and I/O starts
sooner.  Writeback would be used for most workloads, but writethrough makes
sense for slow devices or sequential streaming I/O patterns.  The key, of
course, is enabling the kernel to figure out which policy should apply in
each case without the need for user intervention.  There are some obvious
indications, including various <tt>fadvise()</tt> calls or high-bandwidth
sequential I/O, but, doubtless, there would be details to be worked out.
<p>
In the short term, though, we're most likely to see relatively simple
fixes.  Linus has posted <a href="/Articles/572933/">a patch</a> limiting
the percentage-based calculations to the first 1GB of memory.  This kind of
change could conceivably be merged for 3.13; fancier solutions, obviously,
will take longer.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Writeback">Memory management/Writeback</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/572911/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor573158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 8:04 UTC (Thu)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/573158/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>but writethrough makes sense for slow devices </i>
<p>
And also for all removable devices, because with them it is common you want to flush all pending writes and unmount.

      
          <div class="CommentReplyButton">
            <form action="/Articles/573158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 13:38 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/573184/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt;but writethrough makes sense for slow devices</font><br>
&gt;<br>
<font class="QuotedText">&gt; And also for all removable devices, because with them it is common you want to flush all pending writes and unmount.</font><br>
<p>
*all* removable devices?? What you describe is common for USB key, sure, but what about USB HDD?<br>
I'm sure that some users have such an HDD plugged in all the time and they would object to the performance degradation..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573288"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2013 3:39 UTC (Fri)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/573288/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>I'm sure that some users have such an HDD plugged in all the time and they would object to the performance degradation.</i>
<p>
I am myself one of those, finding that the easiest way to expand storage on my old home PC. But I think that is still exceptional, and could be solved by passing a parameter when mounting (in fstab? I have those drives mounted the traditional way, instead of hot-plugging), or later via some tuning command.

      
          <div class="CommentReplyButton">
            <form action="/Articles/573288/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor573162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 8:34 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/573162/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Using writeback rate estimation is not that trivial to get right *for all situations*, particularly when the writeback rate can change on the fly.<br>
<p>
But... compare it to what we have now, which is *catastrophically* wrong by default, easily giving you a situation where you can have an amount of data that can take ten minutes to write out and jamming the entire system into a stall until it's done. In order to be as bad as what we have now, a rate-estimation-based system would have to be hit with a device which goes from above-SSD speeds to USB-key speeds on the fly -- and how likely is that?<br>
<p>
In this case, I'd say, the perfect is the enemy of the good. What we have now is bad: simpleminded rate-estimation would be better, even if not perfect. Go for that first, pile in the complexity later, and throw away those horrible old knobs. (Whichever was written to last wins?! Ugh!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 14:48 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/573200/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>a device which goes from above-SSD speeds to USB-key speeds on the fly</I></BLOCKQUOTE>
<P>I guess it depends on whether there are devices that have their own in-built caching and can absorb quite a few writes until they slow down dramatically.  They could exhibit rather bimodal behavior based on the size of the incoming writes.  Also, where does NFS fit in the picture?  There, performance may fluctuate quite a bit as well, although I don't know if it's affected by this particular set of knobs.  (Seems like it ought to be.)  With NFS, you have the combined effects of the buffering on the NFS server as well as all the other people on the network vying for the same bandwidth.</P>
<P>My gut feel tells me any simple-minded rate estimator should also have a fairly quick adaptation rate so it tracks any workload-dependent behavior and other variations in media performance.  ie. it should probably represent recent history (the last several seconds), more than long-term history.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor573164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 8:43 UTC (Thu)
                               by <b>johannbg</b> (guest, #65743)
                              [<a href="/Articles/573164/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cant the tuning be based on the detected device? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor573236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 16:17 UTC (Thu)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/573236/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>The one that applies is simply the one that was set last; so, for example, setting dirty_background_bytes to some value will cause dirty_background_ratio to be set to zero and ignored.</blockquote>

Seriously?  I bet that no one (especially the sysctl tool) gets this right.
      
          <div class="CommentReplyButton">
            <form action="/Articles/573236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 21:43 UTC (Thu)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/573260/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly. I would have expected that both limits apply, with the actual limit determined by whichever is lower. In that case the fix would be easy: set a sensible default for the byte limit for large-memory systems, and a sensible percentage for small-memory ones.<br>
<p>
In any case the percentage should be based on the same numbers--total RAM, not low memory--regardless of the word size.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor573290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2013 6:42 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/573290/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Seriously? I bet that no one (especially the sysctl tool) gets this right. </font><br>
<p>
Guess what.  The kernel doesn't even get it right!!  Almost but not quite.<br>
<p>
There is a global variable "ratelimit_pages" which is effectively a granularity - we only do the expensive tests every "ratelimit_pages" pages.<br>
<p>
This gets updated whenever you set dirty_ratio or dirty_bytes. It is set to   dirty_thresh / (num_online_cpus() * 32)<br>
<p>
However if you set "dirty_bytes" and then "dirty_ratio", the second calculation of ratelimit_pages will be based on the old "dirty_bytes" value, not the new "dirty_ratio" value.<br>
<p>
It's a minor bug, but it confirms your assertion that this is an easy interface to get wrong.<br>
<p>
[dirty_ratio_handler() should set "vm_dirty_bytes = 0" *before* the call to writeback_set_ratelimit()]<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor573280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">COW filesystems and the stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2013 23:43 UTC (Thu)
                               by <b>jhhaller</b> (guest, #56103)
                              [<a href="/Articles/573280/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This change may have interesting affects on COW filesystems like btrfs. I have been playing with an interesting combination of mythtv and btrfs. When recording HDTV, mythtv writes about 6GB of data per hour per channel being recorded, or about 16MB/s. Because of the cache/stall effects, mythtv calls fsync once per second, to avoid filling the cache and causing the problems mentioned in the article. While watching live TV, the program is written to disk by one process, and read by another, in a multimedia version of less+tail -f. On some occasions, when fsync runs, there is more than just a little bit of disk I/O, my guess is that the COW semantics are causing more than just the recently written data to be written. I wouldn't otherwise notice this, but the reading process hangs (causing the displayed TV program to hang) until the fsync completes, which can take seconds.<br>
<p>
My question is whether writing dirty pages back more quickly will have a big effect on COW filesystem performance. Copying a large file to a COW filesystem may trigger more COW actions than before.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">COW filesystems and the stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2013 0:45 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/573450/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      fsync is a rather primitive way to cause the system not to keep memory needlessly dirty.
<P>
Lots of fadvise and madvise flags have been developed over the years; doesn't one of them get the writeback happening immediately?  I created a TV recorder based on a ca 2004 Linux kernel that used msync(MS_ASYNC) for that purpose (yes, I made it write the file via mmap just so I could use msync).
<p>
Of course, if the issue is that you think the recorder might not actually be able to keep up with the data arriving, and want to make sure when that happens it just drops TV data and doesn't cripple the rest of the system too, then you do need something synchronous like fsync.

      
          <div class="CommentReplyButton">
            <form action="/Articles/573450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573451"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">COW filesystems and the stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2013 1:59 UTC (Mon)
                               by <b>jhhaller</b> (guest, #56103)
                              [<a href="/Articles/573451/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point was not how mythtv handles this, but that using more aggressive memory pressure may cause COW filesystems to have lower performance, by forcing large files writes to be flushed sooner than they currently do, with consequent COW filesystem behaviors to create copies of at least the tree data and last group of blocks originally written when the next memory pressure forces another write. For my case, I could adjust the configuration of the directory holding the video files to disable the COW behavior, but that's harder to do for the general case. I suspect msync would cause the same problem for a COW filesystem as fsync.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573451/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">COW filesystems and the stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2013 4:16 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/573454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, I was not responding to the point.
<p>
The actual point lost me, because I don't see the connection between the high-volume writing and reading you described and copy-on-write and the stalling of the playback.  But I also don't know anything about mythtv or btrfs specifically.
<p>
I don't think there's anything inherent in COW that means if you flush a large file write sooner that you make more copies of tree data or some group of blocks, but I may have just totally missed the scenario you have in mind.

      
          <div class="CommentReplyButton">
            <form action="/Articles/573454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor573315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2013 16:12 UTC (Fri)
                               by <b>ssam</b> (guest, #46587)
                              [<a href="/Articles/573315/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So does this mean if you have the issue of everything being slow and laggy while writing large files to USB you should look at the values in<br>
<p>
cat /proc/sys/vm/dirty_background_ratio<br>
cat /proc/sys/vm/dirty_ratio<br>
<p>
(I get 10 and 20 on fedora), and then change them to smaller numbers with something like<br>
<p>
echo 2 &gt; /proc/sys/vm/dirty_background_ratio<br>
echo 5 &gt; /proc/sys/vm/dirty_ratio<br>
<p>
in your /etc/rc.d/rc.local<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2013 4:07 UTC (Sat)
                               by <b>naptastic</b> (guest, #60139)
                              [<a href="/Articles/573363/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Close! Put the values in /etc/sysctl.conf.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor573449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2013 0:34 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/573449/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I don't see how that will make things noticeably better.  In fact, it will probably make it worse.
<p>
With the defaults, your system can write up to .2M (where M is the size of your memory) to the USB stick before the system slows to a crawl.  Remember that not just the process writing to the stick must wait for writeback before it can dirty more pages - all processes must.  With your proposed numbers, the crawl happens for writes to the stick as small as .05M.
<p>
Lowering dirty_background_ratio will give your system a probably imperceptible head start (and thus earlier finish) on writing all that data to the USB stick.  The headstart will be the amount of time it takes to buffer .08M of writes (10% - 2%).
<p>
These workarounds using global parameters can help only in carefully constructed cases.  To prevent a slow write to USB from affecting non-USB-writing processes, the kernel would need some kind of memory allocation scheme that distinguishes processes or distinguishes write speed of backing devices.

      
          <div class="CommentReplyButton">
            <form action="/Articles/573449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor573364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2013 4:25 UTC (Sat)
                               by <b>naptastic</b> (guest, #60139)
                              [<a href="/Articles/573364/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a "good" and not "perfect" solution, why not make dirty_background_ratio and dirty_ratio a percentage of some fixed value, and allow arbitrarily large* percentages?<br>
<p>
* - dirty_background_ratio is a signed 32-bit value. If our "fixed value" were 1MiB, you could specify up to 2TiB of buffer space in the future. When we get to 128-bit architectures, we might want to increase the size of dirty_background_ratio to accommodate larger buffers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor573369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2013 6:58 UTC (Sat)
                               by <b>Nagilum</b> (guest, #93411)
                              [<a href="/Articles/573369/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This has been bugging me for years and my solution has almost always been:<br>
vm.dirty_background_ratio=0<br>
or some other very low number (0..5). Personally I see no reason to delay starting to write dirty data out other than power saving. There is usually only a very slim chance that data will be written that will be deleted right away again so delaying starting to flush the data to disk makes very little sense to me.<br>
If you have multiple writers it may also help with the performance if you have a higher value here but high for me is something like 5.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2013 13:40 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/573917/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There is usually only a very slim chance that data will be written that will be deleted right away again</font><br>
<p>
You're obviously not a developer (or gentoo user). I have a huge (20/30Gb ramdisk) for temp precisely because I quite often have gigs of data that gets created and deleted pretty quick. What's the point of writing it to disk when my system has plenty of ram?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573919"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2013 14:03 UTC (Fri)
                               by <b>Nagilum</b> (guest, #93411)
                              [<a href="/Articles/573919/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's right I'm not a full time developer.<br>
Anyway if nothing else is waiting for IO on that disk then it still wouldn't bother you very much since it won't block anything.<br>
Anyhow you have your use-case solved.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573919/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor573375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2013 8:54 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/573375/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's a storage equivalent to the bufferbloat problem.</font><br>
<p>
Good analogy. It stops at the cure though: with TCP/IP it's all about dropping packets! Back-pressure is extremely rare in networking because of Head Of Line blocking.<br>
<p>
Speaking of Head Of Line blocking, I suspect the queues involved in this article don't make the difference between users, do they? In other words, someone writing a lot to a slow device will considerably slow other users, correct?<br>
<p>
(Yes, I do realize USB sticks don't tend to have a lot of concurrent users :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2013 15:30 UTC (Sat)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/573388/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This has become one of my new pet points, queuing theory as it applies to IO has a ton of overlap between Disk IO and Net IO and there should be frequent reminders to make sure that new research and techniques cross pollinate between the two different communities.  Storage doesn't have the option to just drop requests and return IO errors like IP does to indicate contention but it can certainly block writers until latencies improve.  The same algorithms with different tunables might be useful across subsystems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2013 5:32 UTC (Mon)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/573459/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It turns out that bufferbloat also applies to on-chip switch fabrics and the buffering you can find there. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor573766"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2013 10:02 UTC (Thu)
                               by <b>callegar</b> (guest, #16148)
                              [<a href="/Articles/573766/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if this can be the reason why linux software raid occasionally fails external usb disks are used for the raid and large data transfers are started.  Any clue?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573766/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor573832"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2013 19:29 UTC (Thu)
                               by <b>chojrak11</b> (guest, #52056)
                              [<a href="/Articles/573832/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is this problem really *that* hard to solve? Does it need tweaking instead of proper solving? Well... then how is it possible that Windows doesn't experience it *at all*? One time I had 5 different USB sticks plugged into my laptop and copied things all over in various directions, while working with other programs at the same time with no noticeable slowdowns? When reading about such simple problems (the other example is mtime update for mmap'ed files), it is obvious that Windows is still light years ahead...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573832/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2013 19:34 UTC (Thu)
                               by <b>apoelstra</b> (subscriber, #75205)
                              [<a href="/Articles/573833/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding is that Windows basically commits everything to disk ASAP under the assumption that the user may pull the drive at any second and expect all the transferred data to be in place. (At least, all the data that the GUI says was transferred successfully.)<br>
<p>
One result of this is that average-case data transfer on Windows is noticeably slower than on Linux, which is probably why the kernel folks are loath to copy such a solution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573836"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2013 19:51 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/573836/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      This is classic case of "perfect is the enemy of good". Yes, Windows commits everything to USB stick right away, yes it's slow and inefficient, but it also means that you can actually use USB sticks without worry! With Linux small operations are extremely fast, but try to copy few gigs of data to USB stick and be ready to use a different computer for a few minutes (or hours) because system will be totally hosed.
      
          <div class="CommentReplyButton">
            <form action="/Articles/573836/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor573849"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2013 21:48 UTC (Thu)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/573849/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem here is "the knob works well, but the default value is not good for desktops", the solution being "when installing a desktop, remember to set the knob value to something saner" and you get the perfect case (as I have) that is fast USB copies without hogging the CPU.<br>
<p>
Ah, and in my job I see hundreds of USB drives becoming totally hosed every year, by way users writing them on a windows machine and removing without unmounting. Don't do that, even on Windows.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573849/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor573908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2013 11:09 UTC (Fri)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/573908/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My question is this: why is writing to one slow device blocking the entire system and not just the process that is doing the writing?<br>
<p>
I remember there was an issue with page locking, I think, some time ago that was solved with stable pages. But it still doesn't make much sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor579580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2014 10:26 UTC (Wed)
                               by <b>jospoortvliet</b> (guest, #33164)
                              [<a href="/Articles/579580/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
because when the IO subsystem gets clogged, other processes don't get anything either. It just becomes a huge mess with everything stalling.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/579580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor573976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2013 21:02 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/573976/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if this also can be responsible for the problems that I see with XTerm+SSH when lots and lots of lines of text are sent from a server to my ssh client. When that happens (often due to a grep done wrong) my whole machine freezes until all rows have been transferred.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/573976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor574087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2013 4:25 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/574087/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Two other situations I've seen which may be related:<br>
<p>
  - Heavy output on any local terminal (switching workspaces or to another tmux window makes it work better, so closer to the X side of the I/O pipeline; the switch might not take effect for 20â€“30 seconds though)<br>
  - rdesktop (I have to hide Windows' TTY window(s) during a build since its speed affects my local machine even when on another, hidden, desktop locally)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/574087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor648060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2015 20:41 UTC (Fri)
                               by <b>evultrole</b> (guest, #103116)
                              [<a href="/Articles/648060/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've been fighting with this problem for the last year, and I had no luck with changing any of these. Came across this article many times while seeking an answer, so thought I'd leave what eventually worked for me. <br>
<p>
Got the problem fixed with a custom udev rule.<br>
<p>
/usr/lib/udev/rules.d/81-udisks_maxsect.rules<br>
<p>
SUBSYSTEMS=="scsi", ATTR{max_sectors}=="240", ATTR{max_sectors}="32678"<br>
<p>
My hangs disappeared after a reboot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/648060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor648079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2015 8:04 UTC (Sat)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/648079/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How does that work?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/648079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor771011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 21:11 UTC (Wed)
                               by <b>sourcejedi</b> (guest, #45153)
                              [<a href="/Articles/771011/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>"The entire system proceeds to just hang" - I think this is misleading :-(.  Artem didn't report this, and I don't see any other evidence presented for it.

<p>I am hopeful that it is prevented, or at least mitigated, by the <a rel="nofollow" href="https://lwn.net/Articles/456904/">"No-I/O dirty throttling" code</a> that you reported on in 2011 :-). This throttles write() calls to control both the size of the overall writeback cache, and the amount of writeback cache *for the specific backing device*.

<p>Artem did not report the entire system hanging while it flushes cached writes to a USB stick.  His report only complained the "sync" command could take up to "dozens of minutes".

<p>In his followup message, Artem reported "the server almost stalls and other IO requests take a lot more time to complete even though `mysqldump` is run with `ionice -c3`".  But this was not the USB-stick problem.  It happened after creating a 10GB file on an *internal* disk.

<p>I'm not saying there isn't a bufferbloat-style problem.  But I cant find any evidence here, that excessive writeback cache on one BDI is delaying writes to other BDIs.  At least in the simple case you described.

<p>I wrote a StackExchange post about this <a rel="nofollow" href="https://unix.stackexchange.com/questions/480399/why-were-usb-stick-stall-problems-reported-in-2013-why-wasnt-this-problem-al/">here</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/771011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 5, 2020 16:10 UTC (Sun)
                               by <b>abdulla95</b> (guest, #138076)
                              [<a href="/Articles/816833/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Running the lines:<br>
<p>
    echo $((16*1024*1024)) &gt; /proc/sys/vm/dirty_background_bytes<br>
    echo $((48*1024*1024)) &gt; /proc/sys/vm/dirty_bytes<br>
<p>
Didn't help me. The performance did improve but it would still lag. (I have a 1TB HDD and 8GB RAM)<br>
<p>
My question is, is using a hack to go around this a good thing? Like `ionice`, `rsync`, `pv`? I have seen these being thrown around in the internet. And I have used rsync and it works.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor848264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 14:23 UTC (Fri)
                               by <b>kolay.ne</b> (guest, #145247)
                              [<a href="/Articles/848264/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hello from 2021, lol<br>
Still having this issue<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2021 13:19 UTC (Sun)
                               by <b>LaurentD</b> (guest, #151713)
                              [<a href="/Articles/853226/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for sharing the issue and all the information.<br>
<p>
That said, I concur. 2021 already and still seeing the issue here as well. The below does not seem to help much.<br>
<p>
echo $((16*1024*1024)) &gt; /proc/sys/vm/dirty_background_bytes<br>
echo $((48*1024*1024)) &gt; /proc/sys/vm/dirty_bytes<br>
<p>
I wonder: how have other OSs addressed the issue?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853500"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2021 0:42 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/853500/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Windows neatly sidesteps the entire problem by making file IO CPU-bound via malware scanners.<br>
<p>
More serious answer: has anyone benchmarked the bufferbloat in writing directly to a USB stick compared to spinning up a VM, handing the USB device to that, exposing the stick as an NFS share and writing that way? I honestly wouldn&#x27;t be surprised if the latter works better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853500/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor866944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2021 20:10 UTC (Fri)
                               by <b>xmready</b> (guest, #153808)
                              [<a href="/Articles/866944/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
8 years later this is still an issue. Do I have to become a Linux Dev so I can fix this?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/866944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor866970"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2021 1:25 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/866970/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Do I have to become a Linux Dev so I can fix this?</font><br>
<p>
Patches welcome!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/866970/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor938015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The pernicious USB-stick stall problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2023 19:43 UTC (Wed)
                               by <b>juliano_vs</b> (guest, #166031)
                              [<a href="/Articles/938015/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
10 years later, this is still causing headaches for many users<br>
I keep imagining a new user going to linux and facing this problem, having to wait 2 hours to unmount his usb stick 2.0 and having to go out looking for a manual solution on google<br>
In my case i am not a new user but i had this problem and i ended up finding a solution and now i can unmount the pendrive as soon as the copy progress bar ends (just like it is in windows)<br>
correction:<br>
create the file: <br>
/etc/udev/rules.d/60-usb-dirty-pages-udev.rules<br>
<p>
with the following content:<br>
ACTION=="add", KERNEL=="sd[a-z]", SUBSYSTEM=="block", ENV{ID_USB_TYPE}=="disk", RUN+="/usr/bin/bash -c 'echo 1 &gt; /sys/block/%k/bdi/strict_limit; echo 16777216 &gt; /sys/block/%k/bdi/max_bytes'"<br>
<p>
then restart your machine !<br>
<p>
After so many years this should already have a definitive solution in the kernel and not need manual intervention by the user.<br>
It's this kind of thing that keeps new users away from the system<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/938015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
