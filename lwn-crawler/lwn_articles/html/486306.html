        <!DOCTYPE html>
        <html lang="en">
        <head><title>CAP_SYS_ADMIN: the new root [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/486306/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/485887/">Return to the Security page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/486306/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>CAP_SYS_ADMIN: the new root</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="GAByline">
           <p>March 14, 2012</p>
           <p>This article was contributed by <a href="http://man7.org/">Michael Kerrisk</a>.</p>
           </div>
<p>
Capabilities are&mdash;at least in theory&mdash;a nice idea: divide the privileges of root (user ID 0) 
into small pieces so that a process can be granted just enough power to perform specific privileged tasks. 
If the pieces are small enough, and well chosen, then, 
even if a privileged program is compromised (e.g., by a buffer overrun), 
the damage that can be done is limited by the set of capabilities that are available to the process. 
Good examples of the use of such fine-grained privileges are <tt>CAP_KILL</tt>, 
which permits sending signals to arbitrary processes, and <tt>CAP_SYS_TIME</tt>, 
which permits setting the system clock.</p>
<p>
As of Linux 3.2, there are 36 capabilities. You can see a list of 
them, along with some of the main powers they each grant, in 
the <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><i>capabilities(7)</i></a> manual page. 
Capabilities can (since Linux 2.6.24) be attached to an executable file, 
to create the capabilities equivalent of a set-user-ID-root program: when the executable is run, 
the resulting process starts with a limited set of capabilities 
(instead of the full power of root, as is the case for set-user-ID-root programs).</p>
<p>
The key point from the beginning of this article is <i>small pieces</i>, 
and it's here that the Linux capabilities implementation has gone astray.</p>
<p>
When a kernel developer adds a new feature that should require privilege, 
what capability should they use, or should they perhaps even create a new capability? 
Although parceling root privileges into small pieces is useful from a security perspective, 
we don't want too many pieces, 
since then the task of administering capabilities would become unwieldy. 
Thus, it usually makes sense to employ an appropriate existing capability 
to control access to a new privileged kernel feature.</p>
<p>
And this is where the problem begins. First, there is&mdash;unsurprisingly, 
given the Linux development model&mdash;no central authority determining 
how capabilities should be assigned to privileged operations. 
Second, there is very little guidance on what capability to choose. 
(Probably the best existing guide is to look at the 
<i>capabilities(7)</i> man page. 
By comparing with existing uses in that page, 
we can get some guidance on choosing the capability that best matches a new use case.)</p>
<p>
So in practice, what happens? 
A kernel developer looks at the list of available capabilities in the kernel 
<a href="http://lxr.linux.no/#linux/include/linux/capability.h"><tt>include/linux/capability.h</tt></a> header file, 
and is likely left bewildered wondering which capability to choose. 
(It appears that the original intent was that this header file
would be updated with comments for all of the usages of each 
capability, so as to give an overview of capability usage, 
but in practice those comments have been updated only sporadically.) 
But the developer does know one thing: their feature will likely be administered by system administrators, 
and, helpfully, there is a capability called <tt>CAP_SYS_ADMIN</tt>. 
So, lacking sufficient information for a decision, 
the developer chooses <tt>CAP_SYS_ADMIN</tt> for their new feature.</p>
<p>
Which brings us to where we are today: 
of the 1167 uses of capabilities in C files in the Linux 3.2 source code, 
451 of those uses are <tt>CAP_SYS_ADMIN</tt>. 
That's rather more than a third of all capability checks. 
We might wonder if <tt>CAP_SYS_ADMIN</tt> is overrepresented because of 
duplications of similar operations in the kernel <tt>arch/</tt> trees, 
or because <tt>CAP_SYS_ADMIN</tt> is commonly assigned as the 
capability governing administrative functions on device drivers. 
However, even after eliminating <tt>drivers/</tt> and architectures other than x86, 
<tt>CAP_SYS_ADMIN</tt> still accounts for 167&mdash;about 30%&mdash;of the 552 uses of capabilities. 
(Fuller details about usage of capabilities in current and earlier kernels can be found 
<a href="http://blog.man7.org/2012/03/kernel-capability-usage-statistics.html">here</a>.)</p>
<p>
So, on the one hand, the powers granted by <tt>CAP_SYS_ADMIN</tt> are so numerous and wide ranging that, 
armed with that capability, 
there are several avenues of attack by which a rogue process could gain all of the other capabilities. 
(As has been <a href="http://forums.grsecurity.net/viewtopic.php?f=7&t=2522">summarized by Brad Spengler</a>, 
the ability to be leveraged for full root privileges is a
weakness of many existing capabilities; 
<tt>CAP_SYS_ADMIN</tt> is just the most egregious example.) 
On the other hand, so many privileged operations require <tt>CAP_SYS_ADMIN</tt> 
that it is the capability most likely to be assigned to a privileged program.</p>
<p>
To summarize: <tt>CAP_SYS_ADMIN</tt> has become the new root. 
If the goal of capabilities is to limit the power of privileged programs to be less than root, 
then once we give a program <tt>CAP_SYS_ADMIN</tt> the game is more or less
over. That is the manifest problem revealed from the above analysis. 
However, if we look further, there is evidence of an additional problem, 
one that lies in the Linux development model.</p>
<p>
As noted above, if we eliminate <tt>drivers/</tt> and architectures other than x86, 
<tt>CAP_SYS_ADMIN</tt> accounts for 30% of the uses of capabilities. 
However, when capabilities were first introduced in Linux 2.2, 
the corresponding figures were 23 of 147 uses (16%). 
This supports a hypothesis that when random kernel developers are faced with the question 
"What capability should I use to govern access to the privileged feature that I'm adding to the kernel?",
the answer often goes "I'm not sure&hellip; maybe <tt>CAP_SYS_ADMIN</tt>?". 
In other words, the Linux kernel development model 
(where, for example, there is no overall coordination of the use of capabilities) 
appears not to scale well when multiple developers face questions of this sort. 
(In retrospect, it also seems clear that the choice 
of the name <tt>CAP_SYS_ADMIN</tt> was rather unfortunate. 
The name conveys no real information about what operations the capability should govern, 
and it's an easy choice that looks safe to kernel developers 
who are uncertain of what capability to use.)</p>
<p>
What could be done to improve matters? 
There's no quick and easy way out of the existing situation, 
but there are some steps that could be taken:<br />
<ul>
<li>Avoid new kinds of uses of <tt>CAP_SYS_ADMIN</tt>. 
(As this article was being written, Linux 3.3-rc is adding 13 new uses of capabilities. 
Most of them are <tt>CAP_SYS_ADMIN</tt>, 
and at least some of them may be new kinds of uses of that capability. One
such use has <a href="/Articles/486334/">been averted</a>, however.)</li>
<p>
<li>Rename <tt>CAP_SYS_ADMIN</tt> to <tt>CAP_AS_GOOD_AS_ROOT</tt>. 
Well, maybe not.
But such a change would help get the point across to kernel developers 
looking to choose a capability for their new feature.</li>
<p>
<li>Publish better guidelines on the use of capabilities. 
Past attempts to do this (the <i>capabilities(7)</i> man page
and comments in <tt>include/linux/capability.h</tt>) 
have only had limited success 
(the guidelines are incomplete, and haven't done much to alleviate the problem).
However, some more explicit guidelines, 
coupled with some measurements of the kernel source (see next point), 
might achieve better results.</li>
<p>
<li>Regularly publish statistics on the use of capabilities in the 
kernel source and monitor new uses of capabilities in each kernel release 
(e.g., employ some scripting to look at capability-related changes in the 
<i>diff</i> for the current <i>-rc</i> release).</li>
<p>
<li>Existing uses of <tt>CAP_SYS_ADMIN</tt> could be divided out into other existing capabilities, 
and possibly some new capabilities. 
Those capabilities could then be assigned to privileged programs instead of <tt>CAP_SYS_ADMIN</tt>. 
(For application backward-compatibility, 
the kernel capability checks wouldn't <i>remove</i> <tt>CAP_SYS_ADMIN</tt>, 
but rather would check for <tt>CAP_SYS_ADMIN</tt> <i>or</i> its replacement. 
This would allow old binaries that have the <tt>CAP_SYS_ADMIN</tt> capability to continue to work, 
while new binaries would be assigned the replacement capability.) 
One or two steps in this direction have already been made, for example, with 
<a href="/Articles/417489/">the addition of the <tt>CAP_SYSLOG</tt> capability</a> 
in Linux 2.6.37. 
An obvious first point of focus would be non-generic uses of <tt>CAP_SYS_ADMIN</tt> 
in areas other than drivers and the file-system trees. 
Next points of focus could be generic uses of <tt>CAP_SYS_ADMIN</tt>
in the <tt>drivers/</tt> and <tt>fs/</tt> trees.</li>
<p>
<li>Do a similar analysis of other heavily used capabilities,
especially <tt>CAP_NET_ADMIN</tt>, 
to see whether splitting would be useful for those capabilities. 
(<tt>CAP_NET_ADMIN</tt> has 395 uses in Linux 3.2. 
However, all of those uses are restricted to code in the 
<tt>drivers/net/</tt> and <tt>net/</tt> subdirectories. 
If we remove <tt>CAP_NET_ADMIN</tt> from the discussion, 
then there are more uses of <tt>CAP_SYS_ADMIN</tt> in the 
kernel source than all of the remaining capabilities combined.)</li>
</ul>
As well as the above, of course the problem outlined by Brad Spengler 
that many capabilities can be leveraged to gain full root access remains to be addressed. 
(Ongoing work on namespaces will help improve this situation 
for some capabilities when used in conjunction with containers.)</p>
<p>
In summary, capabilities go some way toward improving application security, 
but there's still further work needed before they can deliver 
on their early promise of being a mechanism for providing 
discrete, non-elevatable privileges to applications. 
Furthermore, as the example of the ever-widening scope of <tt>CAP_SYS_ADMIN</tt> shows, 
some questions requiring coordinated answers 
are currently not well addressed by the distributed Linux development model.</p>
<p>
[Acknowledgment: Thanks to <a href="http://s3hh.wordpress.com/">Serge Hallyn</a>
for comments on an early draft of this article.]
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Capabilities">Capabilities</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Capabilities">Capabilities</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-LinuxPOSIX_capabilities">Linux kernel/Linux/POSIX capabilities</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Kerrisk_Michael">Kerrisk, Michael</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/486306/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor486442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 17:29 UTC (Wed)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486442/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's unclear to me why Serge isn't listed as the maintainer for the capabilities subsystem. He is the main proponent of Linux capabilities (at least the last time I paid attention to them). I would say anything having to do with capabilities should be run past Serge first. We don't let people introduce new security features without them being put through the security subsystem maintainer so I don't know why we let uses of the capability system slide.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor487082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2012 2:20 UTC (Mon)
                               by <b>jamesmorris</b> (subscriber, #82698)
                              [<a href="/Articles/487082/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What do you mean?  He is the maintainer :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/487082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor487223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2012 19:04 UTC (Mon)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/487223/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I looked in the MAINTAINERS file and didn't see his name anywhere. If it were there people might be more inclined to make sure they CC him on any capabilities related code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/487223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor487224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2012 19:08 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/487224/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      You were probably looking at an inexcusably ancient kernel, like 3.3-rc7 or something.  The MAINTAINERS file addition went in just before the 3.3 release.
      
          <div class="CommentReplyButton">
            <form action="/Articles/487224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor487238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2012 20:09 UTC (Mon)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/487238/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It was even more inexcusable than 3.3-rc7 I hadn't done a pull since February 28th. The shame. I see that he is listed now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/487238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor486459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 17:56 UTC (Wed)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/486459/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Suggestion: determine which capabilities are "as good as root" and either eliminate those capabilities or eliminate the ability for a program with that capability to obtain all the others.  Programs that previously relied on eliminated capabilities would then have to run as root.
<p>
To do otherwise gives a false sense of security and just adds complexity.

      
          <div class="CommentReplyButton">
            <form action="/Articles/486459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 18:25 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/486469/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's tricky, if you look at Brad's sample escalations you can see there are lots of assumptions involved. Some seem fairly clear (bind mounting a filesystem you control over the root is probably going to get attackers what they want or near enough) while others demand expert knowledge of the system being compromised (is there a root process treating information received over IPC as trusted? No? Too bad then, CAP_IPC_OWNER doesn't buy attackers root equivalence by that route)<br>
<p>
The kernel is not in charge of local system policy. If the underlying block device on which your root filesystem is written is read-only then a kernel privilege to write to the device is no use to attackers, for example. But if they also have a device driver privilege that lets them flip the read-write switch on the hardware then suddenly they're in business...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor486455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 18:15 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/486455/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Splitting privileges that are each equal to root into their own capability doesn't seem to achieve much, at least from a security point of view. Forty capabilities that are root equivalent isn't better than ten, or indeed one.<br>
<p>
So it seems the main target should be those privileges or groups of privileges controlled by CAP_SYS_ADMIN which, after thorough examination, are useful separately without being root-equivalent in common systems. These could be given a new capability bit or added to an appropriate existing one.<br>
<p>
Doing that "thorough examination" first is necessary I think, particularly for capabilities that already exist. Mistakenly adding some root-equivalent privilege to a capability because it "looked appropriate" superficially would be almost as bad as accidentally removing the capability checks from something vital. Having a new privilege temporarily in the CAP_SYS_ADMIN catch-all is much less awful.<br>
<p>
Of course as with any bug, exactly how much a capability buys you will vary from one system to another. Snooping old-fashioned telnet was usually a goldmine. Snooping SSH is much less so (but far from completely useless). On some systems reading /etc/shadow is a big coup, on others not so much (e.g. there may be nothing in there but a (hash of the) local root password which can only be used on a physical console...). For this reason I don't much like Brad's classification of some escalations as "generic" but the idea of figuring out what attackers _might_ do with a privilege is definitely something to be left to white or grey hats and not the people doing routine Linux kernel development.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486560"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 2:54 UTC (Thu)
                               by <b>lutchann</b> (subscriber, #8872)
                              [<a href="/Articles/486560/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Mistakenly adding some root-equivalent privilege to a capability because it "looked appropriate" superficially would be almost as bad as accidentally removing the capability checks from something vital.</font><br>
<p>
Yes, exactly.  I don't want to have to grep every new kernel for CAP_.* to see if my containers are suddenly going to gain privileges that I didn't want them to have.  I'm much happier with everything new going under CAP_SYS_ADMIN, which is already widely known to be a root equivalent.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486560/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor486669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new BKL (;-))</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 15:21 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/486669/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 I suspect we need to treat CAP_SYS_ADMIN the same way as we did the big kernel lock: carefully break it up into the small locks that we actually needed, and create a mechanism for allowing drivers to be kept in sync with specific locks they needed.<br>
<p>
This is harder when one is breaking up a "lock" that is accessible from user-land, but once we've paid the price of no longer having the equivalent of the BKL, it gets *way* easier.<br>
<p>
If asked, I can write a rant on how we migrating an equivalent problem out of existence for the GCOS C compiler (;-))<br>
<p>
--dave<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor487012"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2012 17:55 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/487012/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Splitting privileges that are each equal to root into their own capability doesn't seem to achieve much, at least from a security point of view.
</blockquote>
<p>
I agree, but the non-security point of view is also important, which is why I like the present situation.
<p>
I use capabilities mainly to prevent a process from accidentally exercising privilege I never meant it to have.  For example, it's extremely useful to have a process forbidden to update a file owned by someone else even if the process has the ability to change its UID to the owner's.

      
          <div class="CommentReplyButton">
            <form action="/Articles/487012/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor487873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2012 9:11 UTC (Thu)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/487873/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Absolutely agreed.<br>
<p>
There will always be many operations which fundamentally are equivalent to root, because they can be used to subvert the kernel itself.  Splitting these dangerous operations up into many different capabilities is counter-productive - they should all be under one "root-equivalent" capability.  It doesn't much matter whether you call that capability CAP_SYS_ADMIN, CAP_RAWIO or CAP_AS_GOOD_AS_ROOT.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/487873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor486480"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 19:11 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486480/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't PolicyKit a handier alternative to capabilities?  You can define a capability pretty precisely (and like anything else security-like it is as good or as bad as its auditing from a compromise point of view) and have decent control over who can use it and who not.  And as a bonus - as far as I am aware at least - it only uses standard POSIX mechanisms.  (And yes, I am afraid I am one of those rare people who rather likes DBus.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486480/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 19:38 UTC (Wed)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486488/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that policykit is a security mechanism implemented in userspace. In addition to that you need your application to be policykit aware. It does nothing to actually provide the capability to stop your program from doing something bad. You still need a kernel level mechanism to enforce actual access control whether that be capabilities, SELinux, or GRSecurity RBAC.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 20:01 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486492/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You still need a kernel level mechanism to enforce actual access control whether that be capabilities, SELinux, or GRSecurity RBAC.</font><br>
<p>
Perhaps I am seeing something wrong here.  My thinking is that the enforcing is done by auditing the code to make sure it won't do anything you don't want it to.  And the system administrator only installs policy modules which are known to be properly audited.  Surely capabilities, SELinux, or GRSecurity RBAC are also only as good as the auditing which has been done on them, and the rights they provide are in fact analogous to PolicyKit modules but lower down the stack?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 20:53 UTC (Wed)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486503/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe I just don't understand where the actual enforcement of policykit policy is. What makes the yes no decision? Is it just this library that's linked into your application? Is there a policykitd somewhere that makes these decisions (it seems there is)? What stops the program from just sending a message to the service it wants without having to deal with policykit? Does this require you to put all sorts of policykit calls into both the client and the privileged service? Thats a lot of work to get protection on objects that policykit doesn't even own. In the end the kernel still needs to provide actual protection over kernel object. It doesn't matter if policykit says no you can't do this if I can though an exploit in your program run my code to do it anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 6:17 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/486574/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
from freedesktop.org:<br>
<p>
<font class="QuotedText">&gt; PolicyKit is an application-level toolkit for defining and handling</font><br>
<font class="QuotedText">&gt; the policy that allows unprivileged processes to speak to privileged</font><br>
<font class="QuotedText">&gt; processes: It is a framework for centralizing the decision making process</font><br>
<font class="QuotedText">&gt; with respect to granting access to privileged operations for unprivileged</font><br>
<font class="QuotedText">&gt; applications. PolicyKit is specifically targeting applications in rich</font><br>
<font class="QuotedText">&gt; desktop environments on multi-user UNIX-like operating systems. It</font><br>
<font class="QuotedText">&gt; does not imply or rely on any exotic kernel features.</font><br>
<p>
The basic idea, if I understand it correctly, is to reduce the number of processes that need to run with root permissions by switching to a message passing model where a small set of privileged daemons do things on behalf of other processes.  Android did something similar with their security model.<br>
<p>
In fact, I have to ask who is actually using Linux's fine-grained capabilities that were discussed in this article?  Nearly every programmer knows what root is, but mention CAP_SYS_ADMIN and you are likely to get a blank stare.  Is all this complexity really necessary for something that people are not going to actually use?<br>
<p>
If you're a userspace programmer writing a daemon that needs root permissions, you would be better off spending your time rewriting the code to use privilege separation-- which works on any OS. Openssh did this.  Or you could just audit the code, or invest in writing an selinux policy.  Why on earth would you waste your time with capabilities, which don't seem to be as stable as some of the other ABIs, and are mostly root-equivalent anyway?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486588"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 9:03 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486588/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
cmcabe wrote:<br>
<font class="QuotedText">&gt;The basic idea, if I understand it correctly, is to reduce the number of processes that need to run with root permissions by switching to a message passing model where a small set of privileged daemons do things on behalf of other processes. Android did something similar with their security model.</font><br>
<p>
In fact they are not daemons but executables which are started on demand by DBus (the only running daemon required by the framework) with root privilege to perform an action.  PolicyKit itself is a framework in the form of library APIs which the privileged modules can use to check whether the user who triggered them has the privileges to perform the action.<br>
<p>
As far as I recall this is a pretty simple process - DBus starts the executables and passes them a cookie of some sort, and the new process makes a single API call, passing in the cookie, which reads in the PolicyKit configuration files from /etc and where ever else and returns a boolean "allowed" or "not".<br>
<p>
PolicyKit configuration is a set of rules like "user michael is allowed to execute module 'setdate'", "group network is allowed to execute module 'setipaddress'", "local (non-ssh) users are allowed to execute module 'shutdown'".  (I wonder how reliable the check for local users is!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486588/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486602"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 11:27 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486602/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So I read the policykit documentation last night and mechanisms can be either daemons or normal executables. DBUS activatable daemons are still daemons. This page explains a typical policykit interaction complete with client, mechanism, and authorization agent[1]. There are more than just allow and not allowed responses from policykit. There is also an authorize return which kicks things off to an authorization agent which handles the 8 or so different authorization modes that can be specified by policy kit. Going back to your earlier statement yesterday it seems your argument boils down to we should write code properly and rely on userspace to police itself. It also ignored the fact that the set of actions that policykit is policing and the objects it is protecting are completely disjoint from the objects that the kernel protects. policykit isn't going to provide you any sort of access control to the things under the hood. The way I read it policykit is more of an authentication mechanism than an access control mechanism.<br>
<p>
As a side note its unfortunate that people aren't using the SELinux extensions to DBUS which would make policykit more effective. From what I can tell any "client" can send any message that a user is allowed to a policykit enabled "mechanism". The information transmitted with a DBUS message for policykit is uid and pid(and potentially an SELinux context). So in theory I could exploit an application and have the user think he's typing in his password to say change the system time but instead send a DBUS message to perform some other action. James Carter a long time ago extended DBUS to be a userspace object manager for SELinux and its a shame we don't see distros using that to ensure that certain clients are only allowed to talk to certain mechanisms. If it is restricted in some other way I'd like to be proven wrong but the documentation doesn't seem to mention anything about that. <br>
<p>
<p>
[1]<a href="http://www.manpagez.com/html/PolicyKit/PolicyKit-0.9/model-theory-of-operation.php">http://www.manpagez.com/html/PolicyKit/PolicyKit-0.9/mode...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486602/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486606"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 11:54 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486606/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
dpquigl wrote:<br>
<font class="QuotedText">&gt; Going back to your earlier statement yesterday it seems your argument boils down to we should write code properly and rely on userspace to police itself.</font><br>
<p>
I think I could go along with that summary.  Badly written code can be exploited whether it is in the kernel (including SELinux, as Brad Spengler has shown) or in user space.  And the system administrator is responsible for installing both kernel and user space, and (it seems to me) should worry more about whether the mechanisms work and are well audited than exactly at what level they are implemented.  (Speaking as someone who often writes non-security-related code which can live on either or both sides of the kernel/user space dividing line.)<br>
<p>
<font class="QuotedText">&gt;It also ignored the fact that the set of actions that policykit is policing and the objects it is protecting are completely disjoint from the objects that the kernel protects. policykit isn't going to provide you any sort of access control to the things under the hood.</font><br>
<p>
Could you please give an example of what you mean there?<br>
<p>
<font class="QuotedText">&gt; From what I can tell any "client" can send any message that a user is allowed to a policykit enabled "mechanism".</font><br>
<p>
I thought there was a school of thought that claimed that associating privileged actions with users, not with applications was a sound thing to do, but I am not knowledgeable about the subject to have an opinion about whether you or they are right.<br>
<p>
<font class="QuotedText">&gt; So in theory I could exploit an application and have the user think he's typing in his password to say change the system time but instead send a DBUS message to perform some other action.</font><br>
<p>
Surely anti-spoofing password entry mechanisms are an orthogonal problem?  For example, just an example, when requesting the password the privileged module could require some unspoof-able sequence (like Ctrl-Alt-Del in Windows) which brings up the password box, complete with a description of the action.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486606/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 12:12 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486608/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What Brad has proven is that you can't reliably protect a level of the system at that level. That if you have access to the kernel address space that anything in the kernel is fair game and you need a protection at a lower level to help address that (hardware for example). With that same reasoning you can't protect an application layer framework solely at that layer. If you think that the way to secure usespace is by properly auditing all userspace code to make sure its all ok then we'll have to disagree.<br>
<p>
For an example to the second part of your response. The only thing policy kit will get you is a yes, no, authorize answer. It will not protect you if there is a fault in the "mechanism" that is using policy kit. If you find a way to send a bad DBUS message which allows you to hop the policy kit check through some exploitable code then you can still run. As a matter of fact there was a race condition in one of the policykit authentication agents which allowed you to exhaust the pid space and run any policykit action as root a while back. This is just skipping the authentication. In a similarly crafted situation above if I can get some sort of arbitrary code execution by this privileged mechanism I now have the ability to do whatever I want. Without one of the security mechanisms I mentioned above you're relying on the correctness of the userspace code to enforce access control on other things in the system. That's just not acceptable.<br>
<p>
To address your third question. Restricting access control based on users has long been debunked as an acceptable mechanism. Whether it be SELinux, or SMACK, or Tomoyo, or GRSecurity RBAC, or any number of other mechanisms people have said time and time again that binding permissions to executing code is much more effective than binding it to a particular user. For example if you bind it to the user anything that user can do can be done by any application the user runs. So an exploit in the web browser can read out the users SSH keys if it wants.<br>
<p>
To respond to the last part of your response. Its not a question of anti-spoofing. Trusted path is an important area where Linux is lacking but it still falls to a problem that actions are not bound to specific applications. If you bind an action to a user any policykit enabled program can authenticate and send a related message to a mechanism regardless on whether or not it is supposed to send that message type. I would really like to be proven wrong here because if I am not wrong this is a large hole which from what I can tell is only mitigated by putting in an SELinux dbus policy.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486642"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 14:09 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486642/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
dpquigl wrote:<br>
<font class="QuotedText">&gt; With that same reasoning you can't protect an application layer framework solely at that layer. If you think that the way to secure usespace is by properly auditing all userspace code to make sure its all ok then we'll have to disagree.</font><br>
<p>
Perhaps you did misunderstand me then.  I certainly wasn't talking about auditing all of user space.  The whole point of PolicyKit is to restrict the trusted code base which needs to be audited to a minimum, particularly by sharing a lot of code which is typically duplicated in e.g. setuid applications.  And it uses kernel protection mechanisms to achieve that - like user separation, with the user the module is run as privileged and the other not.  However these are standard POSIX mechanisms, not "homebrew" Linux ones.<br>
<p>
<font class="QuotedText">&gt; It will not protect you if there is a fault in the "mechanism" that is using policy kit. If you find a way to send a bad DBUS message which allows you to hop the policy kit check through some exploitable code then you can still run.</font><br>
<p>
Perhaps it is simpler to talk about a malicious user of the PolicyKit mechanism?  But how does this differ from a malicious user space binary gaining privileges by exploiting a hole in SELinux code in the kernel?<br>
<p>
<font class="QuotedText">&gt; If you bind an action to a user any policykit enabled program can authenticate and send a related message to a mechanism regardless on whether or not it is supposed to send that message type.</font><br>
<p>
Indeed - my thought regarding spoofing and the trusted path was that this is somewhat mitigated if the policy module can unspoofably communicate back to the user what it is proposing to do at the same time as it asks for the password, so that if a malicious application running as the user has requested "overwrite /etc/passwd" the user will be reliably told that by entering their password they will cause /etc/passwd to be overwritten.  I don't think that PolicyKit can currently do this in an unspoofable way, though I think it is designed in such a way that it can be added.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486642/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486651"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 14:25 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486651/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I didn't misunderstand you but you don't seem to understand the size of the TCB on a modern Linux system. Its massive and relying on proper auditing of the code is unreasonable. Some even argue that the kernel itself shouldn't be contained in the TCB.<br>
<p>
If a malicious userspace binary can expoit a kernel vulnerability it doesn't matter what you do because its game over. You still seem to be missing the idea that protections at a given level can't protect that level reliably. SELinux doesn't claim to protect against kernel vulnerabilities. It claims to contain the accesses made by userspace programs and at best mitigates damage caused by an exploited application by confining the actions the application may take to only what it requires to run (assuming your policy is configured correctly). I'm talking about an exploit in a userspace framework allowing for attacks on other userspace applications. This is entirely reasonable considering its how attacks work today on systems that use simple DAC protections. Own a process running as root and do whatever you want including poke into the address space of other processes. You're trying to argue here that DAC protections are sufficient. This has been shown time and time again to be false. You might want to read up on the MAC vs DAC discussion to see exactly why they are insufficient. POSIX does not provide sufficient access control protections for any modern system.<br>
<p>
Also with the exception of the mmap_minaddr bug which Brad found (and was subsequently fixed) SELinux does not grant permissions over your existing permissions. The LSM framework is designed to provide further restrictions not to act as a priviledge granting mechanism. So unless you've found an exploit in SELinux code which allows for arbitrary code execution or memory manipulation in the kernel I'm not sure what kind of buggy SELinux code you'd be referring to.<br>
<p>
With respect to trusted path again there is currently no way to do this and relying on userspace to provide a mechanism for trusted path won't work. The fact that any number of components can be overwritten to trick you into typing a password in for an action that isn't the one you think you're authorizing makes that not possible today.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486651/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 14:54 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486654/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Replying to dpquigl:<br>
<p>
Just to start with, thanks for your patience here, given that I am no security expert.  I won't be offended when you decide to give up, but I am sure that I will learn something in-between.  That said...!<br>
<p>
<font class="QuotedText">&gt; You still seem to be missing the idea that protections at a given level can't protect that level reliably.</font><br>
<p>
I am probably misunderstanding you here somewhere, but I get the feeling that you lump all of user space as one "level".  Surely the whole point here is that we have (at least) two levels, a small privileged subset of user space binaries which is the set of policy modules which DBus is configured to start and the set of binaries which a given user is allowed to execute, with DBus and PolicyKit the bridge and the communication mechanism between the two.  I suppose I am slightly tainted here by experience of QNX where a lot of what is done in the kernel in e.g. Linux takes place in user space.  (And of virtualisation development for that matter.)<br>
<p>
<font class="QuotedText">&gt; You might want to read up on the MAC vs DAC discussion to see exactly why they are insufficient.</font><br>
<p>
I must admit that my grasp of MAC and DAC is very limited.  As far as I can see, DAC is roughly allocating permission to access resources on a per-user basis, whereas MAC is more fine-grained permission to carry out particular actions.  But that is also exactly what PolicyKit manages.<br>
<p>
<font class="QuotedText">&gt; With respect to trusted path again there is currently no way to do this and relying on userspace to provide a mechanism for trusted path won't work. The fact that any number of components can be overwritten to trick you into typing a password in for an action that isn't the one you think you're authorizing makes that not possible today.</font><br>
<p>
The last I heard, the idea for doing that based on today's Linux/X11 systems was to have a second X server which only PolicyKit (that is, the policy modules) has access to and putting up the password prompt along with the clear message about what action was about to be taken there.  I'm not sure what the plan was for proving to the user that this was indeed the "privileged" X server (Ctrl-Alt-Fx could verify that, but of course no one will do that every time).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 15:35 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486670/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Replying to myself:<br>
<font class="QuotedText">&gt; I must admit that my grasp of MAC and DAC is very limited. As far as I can see, DAC is roughly allocating permission to access resources on a per-user basis, whereas MAC is more fine-grained permission to carry out particular actions. But that is also exactly what PolicyKit manages.</font><br>
<p>
Taking a look at the CentOS documentation[1] to get an idea of what can be done with SELinux which can't be easily done in other ways, I see examples of things like forbidding a user from making their .ssh keys world-readable.  I presume that in practice one would also restrict the set of applications able to read them even as that user.  To achieve the same using PolicyKit one would have to have the keys stored in a file to which the user has no access at all and provide a policy module to access the keys.  Clearly the SELinux approach has the advantage of being easier to retro-fit.  On the other SELinux has something of the feel of a retro-fitted solution.<br>
<p>
Basically though if I get it right MAC vs DAC means separating rights to access a file from rights to control its access rights.<br>
<p>
[1] <a href="http://wiki.centos.org/HowTos/SELinux#head-01f53a6fa1f203301fae0a19b6193e839067db71">http://wiki.centos.org/HowTos/SELinux#head-01f53a6fa1f203...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 16:00 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486682/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Central administration of security policy is just one property of MAC. The other more important one in SELinux is binding permissions to code and not user identity. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486683"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 16:12 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486683/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
dpquigl wrote:<br>
<font class="QuotedText">&gt; Central administration of security policy is just one property of MAC. The other more important one in SELinux is binding permissions to code and not user identity.</font><br>
<p>
So you are saying that the key feature of MAC in SELinux which PolicyKit is lacking is that it allows you to say "this action can only be performed by this user or set of users in combination with this binary or set of binaries", rather than just the first part of that?  I realise of course that you will wince at the way I formulated that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486683/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 17:19 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486707/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Its a different level of abstraction. Policy kit makes high level abstractions of what a program does. Like do this privileged operation. SELinux and MAC policies say this program performs these actions on these specific object in the system. These objects can be files or sockets or whatever you like. Its different concept because Policykit really doesn't map policy to system objects. It just maps it to high level concepts exposed by the mechanism. A policykit rule could be that to read my addressbook provided by some other dbus service I need to authenticate myself again. This has nothing to do with how the address book is stored on disk or any of the other resources the address book service needs to function. They are disjoint sets of permissions. Now DBUS has SELinux extensions in it. Where you can say that a process running with a certain SELinux label can contact a "mechanism" aka another service running with a different SELinux label. That's baked into DBUS however no one uses it(To the best of my knowledge). It would strengthen the use of policykit because you couldn't have arbitrary applications contact arbitrary mechanisms and requesting authorization. I guess the point that I haven't made very well in all of this is policykit isn't an access control mechanism. It more resembles an authentication mechanism and access control is still left to the underlying security mechanisms which protect the individual policykit "mechanisms". I really don't like that policy kit called their service providers mechanisms it makes the terminology confusing. Client, service provider, authentication agent make much more sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 17:25 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486711/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be nice if LWN had an edit button that tracked the edit history of the comment. That way you can fix stupid grammatical mistakes and because you kept the history you can make sure people don't white wash their comments. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2012 0:17 UTC (Fri)
                               by <b>filteredperception</b> (guest, #5692)
                              [<a href="/Articles/486799/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"It would be nice if LWN had an edit button that tracked the edit history of the comment. That way you can fix stupid grammatical mistakes and because you kept the history you can make sure people don't white wash their comments."<br>
<p>
+1.  Yeah yeah yeah I should proofread more before hitting submit, but still...  (Not saying that on a tight budget that LWN probably has they should dedicated a lot of resources.  Just saying, if somebody has that itch, +1 more person would be gratified)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor486819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2012 5:18 UTC (Fri)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486819/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This has strayed pretty far from the original question of what practical things one can accomplish with *capabilities* that PolicyKit can't do, but since we are here... I found the first example (the sshd one) in this posting[1] interesting and educational as to what SELinux MAC is useful for.  Obviously one couldn't use PolicyKit to accomplish anything like this, as it is more for controlling privilege escalation than preventing it.  And unlike the other person in the discussion, I don't think that privsep is the answer here, as that won't prevent the unprivileged person logged in through ssh from escalating their privileges afterwards through some buggy setuid binary.  (Note that SELinux would not protect from a buggy PolicyKit module in the example either, as that would potentially allow the ssh user to trigger an escalation in a different process, though it would be harder to exploit than if it were in the same one.)<br>
<p>
[1] <a href="http://lwn.net/Articles/103705/">http://lwn.net/Articles/103705/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2012 9:11 UTC (Fri)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/486825/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To continue off-track and start on the old song - I think that one of the things that irks me most about SELinux is that I have so much trouble nailing down what it is and does, which I think is down to the fact that it doesn't try to solve a precise problem but more to be a general solution to all security issues.  As an example, it covers both forbidding people to change the permissions on sensitive files they own, but also forbids binaries from modifying their own executable code without express permission (actually, to add to the confusion, I think there is an official workaround for that involving having two mappings for the memory, one writeable and one executable).  Both laudable goals, but perhaps they should be a bit more clearly separated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor488330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">DAC vs MAC, and Posix Capabilities</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2012 5:32 UTC (Sat)
                               by <b>gmatht</b> (subscriber, #58961)
                              [<a href="/Articles/488330/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 The fundamental difference between MAC and DAC that in MAC the administrator/system decides whether a right is shared while in DAC each object that holds a right makes the choice as to whether to delegate it.  Traditional capability operating system such as GNOSIS [1] from 1979 are all about being able to delegate only the rights you want to a particular applications, and those applications in turn being able to delegate rights to modules. But they aren't MAC as such, though you could implement MAC on top of them.  <br>
 <br>
 The broad concensus at cap-talk is that MAC is usually a liability, as what you really need is finely divisible rights and the overhead of having to change a central security policy  means that MAC systems rarely have finely divisible rights (they also agree that POSIX "capabilities" give true capability systems a bad name). Compare the "capabilities" in POSIX to a traditional DAC Capability system such as GNOSIS/KeyKOS. Most capabilities in KeyKOS aren't equivalent to root, or even the user "nobody". Indeed in KeyKOS a process running with the rights of "nobody" would be considered highly privileged, as it has a huge number of rights. For example, it has direct access to the filesystem which is a highly complex, sensitive and hence exploitable piece of code. <br>
 <br>
 The real argument for MAC is that it stops users delegating rights, the first example given was stopping users sharing their maildir. In general malicious users and objects can bypass this by proxying the right, over a side channel if need be. In practice, the benfit of MAC is stopping users from accidentally doing something stupid. But in MAC there is always a trade off between functionality and security. Maybe the user is going away and wants to allow their friend to access their mail to deal with any important issues that crop up. Pathologically, this may encourage the user to give their friend their password, resulting in even worse security.<br>
 <br>
 In true capability systems, objects can delegate precisely those rights required. So, if an object calls "compress(a,b)" compress gets the right to a and b, but does not even know whether a "c" exists. This doesn't come at the cost of functionality as a well written program should never access variables that are out-of-scope, indeed such a program shouldn't even compile. This makes security an "Inexpensive lunch" [2] because you get it for free with a well decomposed object oriented design. Likewise the progam "gedit" would get the right to modify ~/.bashrc if and only if the user selected .bashrc in the file open dialog box; this can be retrofitted to existing POSIX applications, often without even a recompile [3]. In a traditional MAC system the admin would have to decide which rights gedit should have, and would probably just decide to give it rights to the whole home directory.<br>
 <br>
 [1] <a rel="nofollow" href="http://www.cis.upenn.edu/~KeyKOS/Gnosis/Gnosis.html">http://www.cis.upenn.edu/~KeyKOS/Gnosis/Gnosis.html</a><br>
 [2] <a rel="nofollow" href="http://wiki.erights.org/wiki/Walnut/Secure_Distributed_Computing/E_Capabilities#Security_as_an_inexpensive_lunch">http://wiki.erights.org/wiki/Walnut/Secure_Distributed_Co...</a><br>
 [3] <a rel="nofollow" href="http://plash.beasts.org/powerbox.html">http://plash.beasts.org/powerbox.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/488330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor486604"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 11:38 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/486604/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are correct. Binder plus the userspace security policy framework in android is very much like policykit/dbus. The major difference is that Android makes use of their own special IPC mechanism (Binder) because of what they saw as deficiencies in DBUS at the time.<br>
<p>
I don't know of many people using Linux capabilities currently (although I don't claim to be an expert on it.) Dan Walsh and others at Red Hat are working on using file capabilities to remove the need for suid on binaries in Fedora. If you're going to make a capabilities system you need to make sure you do it right otherwise you miss the benefits of having it in the first place. That's why they really need to be auditing what actions go under what capabilities and breaking them out as necessary. People say the same thing about the complexity of SELinux. I personally find capabilities and all of their semantics far more complicated than any SELinux concepts and I was introduced to both at the same time.<br>
<p>
I think the solution here is to go over all the calls to capabilities and make sure that 1) they are the correct capability, and 2) if they are not that there is the appropriate granularity present for those capabilities. The way that LSM is setup currently is that the capabilities module is the default security model unless something else is specified and then it is chained together with whatever LSM is loaded. So it is there regardless of what you do so we should do it right.<br>
<p>
I personally would use SELinux instead of capabilities but I do see a benefit to making use of capabilities to remove suid behavior in the system for when someone decides to not use SELinux. In general I'd say SELinux is a superior solution because it actually controls access to specific objects in the system where capabilities give you access to entire classes of objects. For example with SELinux I can limit an application to binding to a specific port. With capabilities from my understanding the only thing I can do is say whether or not a program can bind to ports.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486604/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor486497"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 21:22 UTC (Wed)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/486497/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe an extra level of indirection would help:<br>
Linux developers would create new virtual capabilities for each new usages,<br>
and the capabilities maintainer would associate them to real capabilities<br>
in separate patches.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486497/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 20:05 UTC (Thu)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/486745/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That might help but I'd be afraid that it opens another attack surface.  A virtual capability may appear safe, but mapping it to a real capability could cause rather nonobvious holes to appear.  Especially if multiple virtual capabilities get mapped into a single real one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor486660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2012 16:11 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/486660/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I absolutely loathe the capabilities. Their current implementation is braindead and their pushers should be put up against the wall and shot.<br>
<p>
First, in the good old times I could just look at an executable and see if it's a setuid executable. Which means "it may be dangerous, beware".<br>
<p>
Right now we have tons of capabilities with quite a lot of them equivalent to root access, which are hidden away in extended attributes. And people somehow think it's a GOOD thing.<br>
<p>
Then there's a question of braindead el-dumbo capability inheritance. I have not been able after literally hours of trying to grant my Java program access to restricted ports. Should be easy, right? There definitely should be a program which you can run as root, and which will drop excessive capabilities and set uid to another user. Right? Well, think again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor487241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2012 20:34 UTC (Mon)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/487241/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <a href="http://0pointer.de/blog/projects/security.html">systemd apparently is that program</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/487241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor487286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2012 2:07 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/487286/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Systemd is indeed quite nice. Alas, it's not supported in Debian Stable. And it'll probably won't be integrated properly in Wheeze as well. So the earliest date I can use it is around 2016. Oh well...<br>
<p>
BTW, I see that Wheeze now supports AppArmor ( <a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=598408">http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=598408</a> ). <br>
<p>
Some time ago ( <a href="http://lwn.net/Articles/459460/">http://lwn.net/Articles/459460/</a> ) I promised to send you a case of beer or a yearly subscription to LWN in that case. So what do you choose? :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/487286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor487290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2012 2:33 UTC (Tue)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/487290/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It looks most likely that it'll be a supported alternative init system in Wheezy, although not the default. Which is already pretty sweet, although being default would of course be better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/487290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor486820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2012 5:40 UTC (Fri)
                               by <b>Arach</b> (guest, #58847)
                              [<a href="/Articles/486820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's another problem that should be considered in this context. The kernel code restricted with capabilities might be written with relaxed sense of security and/or without due audit, because of a false assumption that capable processes are more trusted than unprivileged ones.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor486922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2012 22:51 UTC (Fri)
                               by <b>hallyn</b> (subscriber, #22558)
                              [<a href="/Articles/486922/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks very much, Michael, for writing this article.  A few notes below,<br>
some of which we discussed in email:<br>
<p>
1. Besides their finer-grained nature, capabilities have another<br>
advantage over setuid root: you lose the cap after exec.  So shellcode<br>
for execve(/bin/bash) doesn't grant a root shell by itself.<br>
<p>
Put another way, your blog post starts with:<br>
<p>
"The idea of capabilities is to break the power of root (user ID 0) into<br>
independently assigned pieces governing specific privileged operations"<br>
<p>
But the other fundamental property of capabilities is intended to be<br>
that programs, not people, wield privilege, so that privilege is granted<br>
to a combination of the logged in user and the program being execute.<br>
Note that to fully achieve this programs ought to also lock themselves<br>
into a noroot|nosuid_fixup securelevel.<br>
<p>
2. Regarding breaking up some of the courser capabilities, I had<br>
suggested making what we implicitly did with CAP_SYSLOG explicit, namely<br>
introducing a hierarchy.  At the top level, there is CAP_ALL_CAPS.  This<br>
is not quite the same as being root since after exec you can lose this<br>
privilege.  But of course it's enough power to let you ensure you can<br>
keep your privilege.  Then come most of the current ones, CAP_SYS_ADMIN,<br>
CAP_NET_ADMIN, etc.  Then come newer fine grained ones, like CAP_SYSLOG<br>
and CAP_IPC_ADMIN.<br>
<p>
Perhaps we can introduce through capability.h, through the use of some<br>
annotations, a graph of the hierarchy, and a hierarchical way to refer<br>
to the capabilities in the code.  The point here is to let userspace<br>
decide how fine grained to get.  It can use CAP_SYS_ADMIN, or, over<br>
time, choose CAP_SYSLOG.  I think if we guarantee that a given<br>
capability will never become insufficient privilege for what it could<br>
previously achieve, that helps userspace.<br>
<p>
Some privileges need to be reconsidered.  For instance, it's been<br>
pointed out that mount is dangerous because you can overmount /.<br>
But really, there are several issues with mount:<br>
<p>
	1. Unprivileged mounts patches have been out there for years,<br>
	   and apart from the issue of unpriv users preventing admins<br>
	   from deleting files using mounts in unreachable namespaces,<br>
	   it's understood hwo to allow many mount actions safely.<br>
	2. Mounting to targets which you don't own is obviously one<br>
	   dangerous aspect to mount, as you can overwrite "trusted<br>
	   paths" like /sbin or /etc.<br>
	3. Lack of trust in the in-kernel filesystem (and especially<br>
	   super block) parsers is another, separate concern.  You may<br>
	   be able to write garbage to a file, mount it loopback, and<br>
	   cause ext2's read_super to crash the kernel (or worse).<br>
<p>
3. Analysis.  Thanks for the great ideas.  I've somewhat lost track of<br>
kernel dev cycles, but your idea to analyze changes to capabilities at<br>
rcs is a great one, and I should act on it.  I also should reproduce and<br>
expand on the analysis of the current capability checks that you've<br>
done.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor487013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2012 18:00 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/487013/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
The article seems to imply that many of the things that today require CAP_SYS_ADMIN could instead require some other existing capability.  But that's not my impression.
<p>
I see CAP_SYS_ADMIN as the miscellaneous category, for things that don't  merit their own capability.  When I've added privileged operations, I have always scanned all the existing categories and almost never found any more fitting than CAP_SYS_ADMIN.

      
          <div class="CommentReplyButton">
            <form action="/Articles/487013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor487814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History Repeats</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2012 2:20 UTC (Thu)
                               by <b>ldo</b> (guest, #40946)
                              [<a href="/Articles/487814/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>I saw much the same thing play out in the 1980s with VMS, and its “privileges” system (of which Linux capabilities are a very close copy in principle). Even with a (presumably) centrally-managed design and implementation, you still get overlaps and odd divisions.

<P>And have you figured out what you’re trying to achieve, anyway? Are you trying to guard against accidents, or malice? Guarding against malice means trying to ensure that <B>none</B> of the privileges/capabilities is on its own effectively equivalent to full root access—a task which seems hopeless.
      
          <div class="CommentReplyButton">
            <form action="/Articles/487814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor490297"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2012 23:14 UTC (Mon)
                               by <b>nwmcsween</b> (guest, #62367)
                              [<a href="/Articles/490297/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please stop with posix 'capabilities' adopt something that isn't garbage maybe capsicum or finish seccomp2? Actual capability based security could be so much better...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/490297/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CAP_SYS_ADMIN: the new root</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 16:29 UTC (Fri)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/795235/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And an update: back in Linux 3.2, CAP_SYS_ADMIN was 38% of uses in the kernel. I checked Linux 5.2 today. Now it's just over 45%.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
