        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rust heads into the kernel? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/853423/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/852730/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/853423/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rust heads into the kernel?</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>April 21, 2021</br>
           </div>
<p>
In a <a
href="/ml/linux-kernel/20210414184604.23473-1-ojeda@kernel.org/">lengthy
message</a> to the linux-kernel mailing list, Miguel Ojeda "introduced" the
<a href="https://github.com/Rust-for-Linux">Rust for Linux</a> project.  It
was likely not the first time that most kernel developers had heard of the
effort; there was an <a href="/Articles/829858/">extensive discussion</a>
of the project at the <a
href="https://www.linuxplumbersconf.org/event/7/">2020 Linux Plumbers
Conference</a>, for example. It has also been <a
href="/ml/linux-kernel/CAKwvOdmuYc8rW_H4aQG4DsJzho=F+djd68fp7mzmBp3-wY--Uw@mail.gmail.com/">raised
before</a> on the list. Now, the project is looking for feedback from
the kernel community about its plans, thus the RFC posting on April&nbsp;14.
</p>

<h4>Adding Rust</h4>

<p>
Ojeda started by acknowledging that adding another implementation language
to the kernel will be at least somewhat disruptive, so there need to be good reasons
to do so.  The kernel is already a highly complex body of code to
understand and work with, adding a second language into the mix, with all
of its complexities, only makes that worse. "<q>Nevertheless, we believe
that, even today, the advantages of using 
Rust outweighs the cost.</q>"
</p>

<p>
Those benefits mainly stem from the <a href="https://en.wikipedia.org/wiki/Memory_safety">memory-safety</a> features of the Rust
language.  The hope is that the number of bugs in the kernel can be reduced
by eliminating these kinds of problems, at least for the pieces that get
implemented in Rust.  For now, those pieces are envisioned to be
well away from the core kernel code:
<blockquote class="bq">
Please note that the Rust support is intended to enable writing
drivers and similar "leaf" modules in Rust, at least for the
foreseeable future. In particular, we do not intend to rewrite
the kernel core nor the major kernel subsystems (e.g. `kernel/`,
`mm/`, `sched/`...). Instead, the Rust support is built on top
of those.
</blockquote>
</p>

<p>
There are lots of impedance mismatches between kernel C code and Rust that
need to be handled—one way or another.  In order to get the most benefit
from Rust's safety features, the amount of  kernel support code in <a
href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"><tt>unsafe</tt>
blocks</a> 
needs to be minimized—and carefully documented.  One of the stated goals is
that the documentation guidelines be automatically enforced:
<blockquote class="bq">
By taking advantage of Rust tooling, we keep enforcing the
    documentation guidelines we have established so far in the
    project. For instance, we require having all public APIs, safety
    preconditions, `unsafe` blocks and type invariants documented.
</blockquote>
</p>

<p>
The work so far has focused on making the building blocks and starting to
implement wrappers for kernel APIs and abstractions, but there is lots more
to do: "<q>Covering the entire API
surface of the kernel will take a long time to develop and mature.</q>"
The RFC further acknowledges the task ahead, but notes that there is
tooling available to help that process:
<blockquote class="bq">
[...] modules written in Rust should never use the C kernel APIs
directly. The whole point of using Rust in the kernel is that
we develop safe abstractions so that modules are easier to reason
about and, therefore, to review, refactor, etc.
<p>
Furthermore, the bindings to the C side of the kernel are generated
on-the-fly via `bindgen` (an official Rust tool). Using it allows us
to avoid the need to update the bindings on the Rust side.
</blockquote>
</p>

<p>
In a <a
href="https://security.googleblog.com/2021/04/rust-in-linux-kernel.html">Google
security blog post</a>, which led to a
lengthy comment stream when posted <a href="/Articles/852704/">here at LWN</a>,
one of the Rust for Linux maintainers, Wedson Almeida Filho, gave a
detailed description of one of the
example drivers that are part of Ojeda's RFC.  It is a <a
href="https://github.com/Rust-for-Linux/linux/blob/e2382072517dd0b6b65d4e179e322f392efb9676/samples/rust/rust_semaphore.rs">character 
device that implements a semaphore</a>, mostly for
demonstration purposes.  The RFC also has
a reimplementation of the <a
href="https://elinux.org/Android_Binder">Android Binder</a> interprocess
communication mechanism.  While the latter is not yet complete, it gives a
further look at what would be possible with Rust in the kernel:
<blockquote class="bq">
At the moment we have nearly all generic kernel functionality needed by
Binder neatly wrapped in safe Rust abstractions [...]
<p>
We also continue to make progress on our Binder prototype, implement
additional abstractions, and smooth out some rough edges. This is an
exciting time and a rare opportunity to potentially influence how the Linux
kernel is developed, as well as inform the evolution of the Rust language. 
</blockquote>
</p>

<p>
The RFC notes that, currently, the Rust support adds a fair amount of code to
the built kernel, but that there are plans to reduce that over time.  The kernel
size for "<q>small x86_64 config we use in the CI</q>" increased by
around 4% with full Rust support.  The Rust version of the semaphore driver
is around 50% bigger than its C counterpart, while the Binder driver is
roughly equivalent in size.  However, "<q>note that while the Rust version is
not equivalent to the C original module yet, it is close enough to
provide a rough estimation</q>".
</p>

<p>
</p>

<h4>Reaction</h4>

<p>
Overall, the reception to the RFC was favorable, though there are some
exceptions, and, of course, there are questions and concerns with the
existing code.  Linus Torvalds seemed to focus in on the <tt>BUG()</tt>
calls in the support code and was predictably unhappy to see them.
The kernel tries hard to continue even in the face of errors, but calling
<tt>BUG()</tt> simply gives up and crashes the kernel with a backtrace.
<a
href="/ml/linux-kernel/CAHk-=wgJvJJtd2mpYpx5+zn_hPrSOqGqi-Pxb7e+h+anhsLnQg@mail.gmail.com/">In
one case</a>, there are intrinsic operations ("<q>panicking
intrinsics</q>") included in the Rust standard
library that are not supported for the 
kernel; calling them effectively crashes the kernel by calling
<tt>BUG()</tt>.  Torvalds suggested making calls to those fail at build
time; Ojeda <a
href="/ml/linux-kernel/CANiq72=PakH-25ZAhC-TKNq7ti76cKt-coS4UahUjsGxNVWRAQ@mail.gmail.com/">agreed</a>
that would be a better approach, but also noted that more of the standard
library will be removed over time, which may largely eliminate the problem.
</p>

<p>
Torvalds also <a
href="/ml/linux-kernel/CAHk-=wiVY56LzwV_G075NEFwsdf-p7GOTy_cB7-UU9b=49rB1g@mail.gmail.com/">pointed</a>
to the <tt>panic!()</tt> calls in the memory allocation code, which seemed
"<q>fundamentally wrong</q>" to him:
<blockquote class="bq">
If the Rust compiler ends up doing hidden allocations, and they then
cause panics, then one of the main *points* of Rustification is
entirely broken. That's 100% the opposite of being memory-safe at
build time.
<p>
An allocation failure in some random driver must never ever be
something that the compiler just turns into a panic. It must be
something that is caught and handled synchronously and results in an
ENOMEM error return.
</blockquote>
</p>

<p>
Again, Ojeda <a
href="/ml/linux-kernel/CANiq72=VnWEdh2uuwH2JM6ZhrEVDiQisnNBQGX-qwPnTitcR=g@mail.gmail.com/">agreed</a>;
he noted that there is work to do to adapt Rust's standard library for use
by the kernel:
<blockquote class="bq">
What happens here is that we use, for the moment, `alloc`,
which is part of the Rust standard library. However, we will be
customizing/rewriting `alloc` as needed to customize its types (things
like `Box`, `Vec`, etc.) so that we can do things like pass allocation
flags, ensure we always have fallible allocations, perhaps reuse some
of the kernel data structures, etc.
</blockquote>
</p>

<p>
Using the Binder driver as an example was <a
href="/ml/linux-kernel/CAHk-=wjdZ1KksHHHuekeAx9kKFXEyt+rg0P=yRD1Bia_01wucg@mail.gmail.com/">another
area of concern for Torvalds</a>; he would like to see an "<q>example of
a real piece of code that actually does something 
meaningful</q>".  Ojeda <a
href="/ml/linux-kernel/CANiq72mpjQh01QovUPCjdHDS-zVHroxymet67GOHvotW8wGdVg@mail.gmail.com/">said</a>
there are plans to add a few drivers that talk to real hardware;  Matthew
Wilcox had an <a
href="/ml/linux-kernel/20210414194946.GW2531743@casper.infradead.org/">idea 
for where to start</a>:
<blockquote class="bq">
I'd suggest NVMe as a target.  It's readily available, both as real
hardware and in (eg) qemu.  The spec is freely available, and most devices
come pretty close to conforming to the spec until you start to push hard
at the edges.  Also then you can do performance tests and see where you
might want to focus performance efforts.
</blockquote>
</p>

<p>
Greg Kroah-Hartman <a
href="/ml/linux-kernel/YHfm+tCYp+I1C5I%2F@kroah.com/">agreed with
Torvalds</a> that Binder did not make a particularly good example driver, but was
duly impressed with what the project had accomplished so far:
<blockquote class="bq">
[...] this patchset is a great start that
provides the core "here's how to build rust in the kernel build system",
which was a non-trivial engineering effort.  Hats off to them that "all"
I had to do was successfully install the proper rust compiler on my
system (not these developers fault), and then building the kernel code
here did "just work".  That's a major achievement.
</blockquote>
</p>

<p>
He also thought that NVMe might make a good choice, but had other
thoughts "<q>for 
some of the basics that driver authors deal with on a daily basis
(platform driver, gpio driver, pcspkr driver, /dev/zero
replacement)</q>".  It would seem that the Rust for Linux project will
be working on one or more of these kinds of "real" drivers before long.
</p>

<p>
While he reiterated the complaints he had for some of the individual
patches, Torvalds <a
href="/ml/linux-kernel/CAHk-=wh_sNLoz84AUUzuqXEsYH35u=8HV3vK-jbRbJ_B-JjGrg@mail.gmail.com/">said</a>:
"<q>on the whole I don't hate it</q>".  On the other hand, though,
Peter Zijlstra seemed to <a
href="/ml/linux-kernel/YHiMyE4E1ViDcVPi@hirez.programming.kicks-ass.net/">fundamentally
object</a> to the idea of adding a second implementation language to the
kernel.  The RFC
noted that the kernel tooling has been focused on C, "<q>including
compiler plugins, sanitizers, Coccinelle, lockdep,  sparse</q>", but
that tooling for Rust will "<q>likely improve if Rust usage in the
kernel grows over time</q>".  Zijlstra zeroed in on that and asked:
<blockquote class="bq">
This; can we mercilessly break the .rs bits when refactoring? What
happens the moment we cannot boot x86_64 without Rust crap on?
<p>
We can ignore this as a future problem, but I think it's only fair to
discuss now. I really don't care for that future, and IMO adding this
Rust or any other second language is a fail.
</blockquote>
</p>

<p>
Perhaps unsurprisingly, he has strong opinions against the documentation
format used by the project (Markdown in the code that gets converted <a
href="https://rust-for-linux.github.io/docs/kernel/">to HTML</a>).  He was
also unhappy with the code formatting used, which follows, at least for now, "<q>Rust's
idiomatic style</q>", according the RFC, but is "<q>really *really*
hard to read</q>".  Beyond those, he wondered about what memory model
Rust follows and how it "<q>aligns (or not)</q>" with the <a
href="/Articles/718628/">Linux kernel memory model</a> (LKMM).
</p>

<h4>Memory model</h4>

<p>
Rust currently uses the C11 memory model, Boqun Feng <a
href="/ml/linux-kernel/YHkSO3TUktyPs4Nz@boqun-archlinux/">said</a>, mostly
because the LLVM compiler supports it by default, but there is interest in
ensuring that its memory model works well with the kernel's. Right now, 
"<q>there is no code requiring
synchronization between C side and Rust side, so we are currently
fine</q>", but that will change eventually, so
there are plans to put the right Rust and kernel people together to discuss
the issue.  Almeida <a
href="/ml/linux-kernel/YHj02M3jMSweoP4l@google.com/">noted</a> that the
plan is for most Rust code in the kernel to only need to be concerned with
the Rust memory model:
<blockquote class="bq">
We don't intend to directly expose C data structures to Rust code (outside the
kernel crate). Instead, we intend to provide wrappers that expose safe
interfaces even though the implementation may use unsafe blocks. So we expect
the vast majority of Rust code to just care about the Rust memory model.
<p>
We admittedly don't have a huge number of wrappers yet, but we do have enough to
implement most of Binder and so far it's been ok. We do intend to eventually
cover other classes of drivers that may unveil unforeseen difficulties, we'll
see.
</blockquote>
</p>

<p>
Almeida disagreed with Zijlstra's characterization of HTML as being an invalid
documentation format, writing that off as a personal
preference.  For the code formatting, he is not opposed to moving away from
the Rust style if there are good reasons to do so, but found Zijlstra's
criticism unconvincing: "<q>'Not having parentheses around the if-clause
expression is complete rubbish' 
doesn't sound like a good reason to me.</q>"
</p>

<p>
Al Viro <a
href="/ml/linux-kernel/YHkRvhIeO2794f7v@zeniv-ca.linux.org.uk/">tried to
explain</a> the aversion to HTML documentation, in characteristically blunt fashion,
which sent things briefly off the rails.  Zijlstra <a
href="/ml/linux-kernel/YHk4DZE1ZWTiBB1f@hirez.programming.kicks-ass.net/">said</a>
that there is no real way to look at HTML documentation in ASCII;
"<q>Nothing beats a sane ASCII document with possibly, where really
needed 
some ASCII art.</q>"  He also explained why his seemingly arbitrary
complaints about the formatting actually matter:
<blockquote class="bq">
Of course it does; my internal lexer keeps screaming syntax error at me;
how am I going to understand code when I can't sanely read it?
<p>
The more you make it look like (Kernel) C, the easier it is for us C
people to actually read. My eyes have been reading C for almost 30 years
by now, they have a lexer built in the optical nerve; reading something
that looks vaguely like C but is definitely not C is an utterly painful
experience.
<p>
You're asking to join us, not the other way around. I'm fine in a world
without Rust.
</blockquote>
</p>

<p>
Zijlstra also <a
href="/ml/linux-kernel/YHlz54rd1YQHsOA%2F@hirez.programming.kicks-ass.net/">suggested</a>
that many of the Rust features being touted could be implemented in C.
Almeida <a href="/ml/linux-kernel/YHmMJWmzz2vZ3qQH@google.com/">agreed</a>
that they could be, but that Rust makes it impossible to mistakenly fail to
use them, unlike C (at least without compiler changes):
<blockquote class="bq">
In Rust, this isn't possible: the data protected by a lock is only accessible
when the lock is locked. So developers cannot accidentally make mistakes of this
kind. And since the enforcement happens at compile time, there is no runtime
cost.
</blockquote>
</p>

<p>
He also raised the problem of ownership in C: there is no way to transfer
an object's ownership in C, but it is straightforward to do in Rust:
<blockquote class="bq">
 In Rust,
there is a clean idiomatic way of transferring ownership of a guard (or any
other object) such that the previous owner cannot continue to use it after
ownership is transferred. Again, this is enforced at compile time.
</blockquote>
</p>

<p>
But Zijlstra would <a
href="/ml/linux-kernel/YHmc2+bKQJ%2FXAATF@hirez.programming.kicks-ass.net/">rather
see a C extension</a> that supported ownership, instead of adding Rust to
the kernel.
<blockquote class="bq">
This would mean a far more aggressive push for newer C compilers than
we've ever done before, but at least it would all still be a single
language. Conversion to the new stuff can be done gradually and where
it makes sense and new extensions can be evaluated on performance impact
etc.
</blockquote>
</p>

<p>
Almeida <a href="/ml/linux-kernel/YHmuX1NA5RF7C7XS@google.com/">was not
opposed</a> to that idea, quite the reverse, in fact:
<blockquote class="bq">
I encourage you to pursue this. We'd all benefit from better C. I'd be happy to
review and provide feedback on proposed extensions that are deemed
equivalent/better than what Rust offers.
<p>
My background is also in C. I'm no Rust fanboy, I'm just taking what I think is
a pragmatic view of the available options.
</blockquote>
</p>

<p>
It is a little hard to imagine the kernel switching to a C extension that
does not yet exist in order to avoid further investigating adding Rust into
the mix, however.   But there is still plenty of work that needs to be
done by Rust for Linux, some of which seems likely to be needed before
Torvalds would be willing to merge the support.  For example, more "real" driver
examples and removing the paths that lead to <tt>BUG()</tt> calls seem
needed.  But Rust for Linux is clearly getting closer to being a reality.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/853423/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor853664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 1:57 UTC (Wed)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/853664/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is already work on a JSON backend for RustDoc, which could be the basis for a non-html CLI viewer: <a href="https://github.com/rust-lang/rust/issues/76578">https://github.com/rust-lang/rust/issues/76578</a><br>
<p>
Since Zijlstra also described the kernel rst docs as &quot;crap&quot; and &quot;unreadable garbage&quot; I&#x27;m not sure anything except hand-written ASCII would satisfy him, but perhaps others would be happy with that.<br>
<p>
Replacing Rust&#x27;s alloc library with different code more suited to the Linux kernel seems like a good step, and it&#x27;s something supported by the language just fine and is used in various situations already, it doesn&#x27;t make the code any less Rust. I do hope they will not listen to the comments asking for Rust to be made to look exactly like C. Rust is a different language, and it&#x27;s been designed by people well aware that a new language has a &quot;novelty budget&quot; and didn&#x27;t go out of their way to do things differently for the fun of it.<br>
<p>
Seeing if statements without parentheses around the condition was weird for me at first too, but it makes a lot more sense when you consider that an if statement is also an expression in Rust, which means it can be used the way the ternary operator is used in C. I can&#x27;t quite put a finger on why, but adding the extra parentheses around the condition in such &quot;expression if statements&quot; makes it look a lot noisier and harder to parse for me, even back when I had very little experience with Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 2:36 UTC (Wed)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/853668/">Link</a>] (55 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t regularly read lkml but when I saw multiple people linking to especially Peter&#x27;s messages with something to the effect of &quot;why I&#x27;m not touching linux kernel dev&quot; I was intrigued and decided to follow the thread.<br>
I must say, I&#x27;m extremely disappointed that this is apparently the level of discourse you can have on the lkml without fearing, at minimum, a loss of reputation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 3:08 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/853670/">Link</a>] (52 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is part of, I think, the ‘social debt’ built up over years of Linus acting like this periodically.  It became accepted.<br>
<p>
I do have a pretty basic fear that the maintenance required for this may be overwhelming and the rewards not great enough to maintain the effort over time... but gosh, as someone who has written kernel C for my whole career, it would probably be good if we could work out another option.  Rust looks really compelling.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853675"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 4:58 UTC (Wed)
                               by <b>xinitrc</b> (subscriber, #126452)
                              [<a href="/Articles/853675/">Link</a>] (51 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that there are lots of discussions about how rust is amazing and why it should be in kernel but not a single driver has been written yet.<br>
While this is the whole point of operating system to control the hardware.<br>
And this is why people have chosen C previously.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853675/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 5:55 UTC (Wed)
                               by <b>kunitz</b> (subscriber, #3965)
                              [<a href="/Articles/853679/">Link</a>] (49 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree with that statement. Write code that works, does something useful, and allows users to achieve a goal that is otherwise not possible. Instead of writing announcements, the Rust people should rewrite three drivers from different areas and prove that their statements about better safety are justified.<br>
<p>
I&#x27;m skeptical because of statements like this:<br>
<p>
Secondly, modules written in Rust should never use the C kernel APIs directly. The whole point of using Rust in the kernel is that we develop safe abstractions so that modules are easier to reason about and, therefore, to review, refactor, etc.<br>
<p>
This sounds not very kernel-like. Creating abstractions in such a way that they bear no costs will be hard. Giving the tendency of internal kernel APIs to change over time, there must be automation to support them. All of that will become clear if one would try to write actual drivers in Rust.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 7:19 UTC (Wed)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/853687/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I agree with that statement. Write code that works, does something useful, and allows users to achieve a goal that is otherwise not possible. </font><br>
<p>
Definitely.<br>
<p>
<font class="QuotedText">&gt; Instead of writing announcements, the Rust people should rewrite three drivers from different areas and prove that their statements about better safety are justified.</font><br>
<p>
On the other hand, getting feedback early is not bad. If the only complaints are: there are no drivers, yet. The Rust people can continue and write some drivers. If there would have been big complaints about the interface and the way they try to integrate Rust into the kernel, then having already implemented some drivers would have been a waste of time.<br>
<p>
<font class="QuotedText">&gt; I&#x27;m skeptical because of statements like this:</font><br>
<font class="QuotedText">&gt; Secondly, modules written in Rust should never use the C kernel APIs directly. The whole point of using Rust in the kernel is that we develop safe abstractions so that modules are easier to reason about and, therefore, to review, refactor, etc.</font><br>
<font class="QuotedText">&gt; This sounds not very kernel-like. Creating abstractions in such a way that they bear no costs will be hard. </font><br>
Nobody said that kernel development would be easy. On the other hand, getting all users of some kernel API to be correct in C is also not easy. In fact it is so hard, that people usually do not even try to prove things like memory-safety.<br>
<font class="QuotedText">&gt; Giving the tendency of internal kernel APIs to change over time, there must be automation to support them. </font><br>
The Rust safe abstraction will be one user of an API like every other user. And it will have to be adapted when an API changes just like every other user of the API. In some cases, it might be enough to change the implementation of the safe abstraction. In other cases, also the Rust interface of the abstraction will have to be changed and therefore Rust code using the interface will also have to be refactored. But this would also be true for any C code using the interface.<br>
<p>
<font class="QuotedText">&gt; All of that will become clear if one would try to write actual drivers in Rust.</font><br>
<p>
And this is just what should happen now, after there was no clear objection to the way Rust will be integrated into the kernel.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 8:34 UTC (Wed)
                               by <b>mkubecek</b> (guest, #130791)
                              [<a href="/Articles/853693/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The Rust safe abstraction will be one user of an API like every other user. And it will have to be adapted when an API changes just like every other user of the API. In some cases, it might be enough to change the implementation of the safe abstraction. In other cases, also the Rust interface of the abstraction will have to be changed and therefore Rust code using the interface will also have to be refactored. But this would also be true for any C code using the interface.</font><br>
<p>
But &quot;will have to be adapted&quot; says nothing about who is going to be responsible for that. As of now, the practice is that if you want to change internal API, you are responsible for adapting all its in tree users. This is fine as long as all of kernel is written in C. But when another language is added, it is a natural question if you still expect anyone who would touch any internal API to also update your abstractions - which also means learning rust to a level sufficient for such work. Or if we can simply break the rust stuff at will and you will fix it later. Or if anyone who wants to touch the internal API has to find (in advance) someone who will take care of the rust dependants. Neither of the options looks very appealing to me.<br>
<p>
It is very unfortunate that while rust people were very active in other parts of all the LKML and LWN discussions, nobody cared to reply to these concerns raised by Peter (and me). For some of us, this is really a fundamental question and we would like to have an idea where this path is heading before taking the first step. So I&#x27;m asking again: do you expect that anyone seriously involved in kernel development will have to get proficient (also) in rust? If not, how do you plan the coexistence to work?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 10:36 UTC (Wed)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/853700/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the Rust side does go ahead with its plan of building wrappers around C APIs vs. allowing Rust drivers to directly interract with C, you at least avoid a scenario where a C refactor patch has to touch hundreds of Rust callers written in idiomatic style that can be very much unreadable to pure C people.<br>
<p>
I imagine the wrappers will restrict themselves to very simple, easily understood code. Not only for the sake of people who should not have to read TRPL cover to cover, but also because unsafe wrappers ought to prioritize readability and &#x27;obviously correct&#x27;ness.<br>
<p>
Now would we still need dedicated people to take your C patches and write the corresponding Rust part?  <br>
Maybe. I&#x27;d like to hope not!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor853688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 7:28 UTC (Wed)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/853688/">Link</a>] (43 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At the very least I would expect Rust wrappers around kernel APIs to get rid of that error-prone C inline error reporting with negative numbers that is so common in C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 7:48 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/853690/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, you can expect that at some point the Result&lt;T, E&gt; will be converted to a Result&lt;(), Errno&gt; or Result&lt;&amp;SomeStruct, Errno&gt;, and then unsafe code will convert that to a negative errno.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 7:56 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/853692/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Long-term, we&#x27;re hoping to teach Rust that inside the kernel a valid reference will never have a value less than 4096 (carving out a &quot;niche&quot; in Rust terms), so that a Result&lt;&amp;T, Errno&gt; (or a Result with any success type that uses the space of valid pointers, such as Box) will be exactly one machine word in size and have the same layout as a C ERR_PTR.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 12:50 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/853710/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You still probably want to use other error enums than errno in Rust code, so that should be well into diminishing returns area though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 22:59 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/853812/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Won&#x27;t you also want to make Result&lt;T, Errno&gt; a single machine word where T is u32 or even u63?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 8:31 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/853889/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be a bit more complicated by Rust being much more strict on integer casts. It means that you&#x27;d use usize in many places where C would use unsigned (or more likely, use an int that would always be positive).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 19:03 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/854029/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s theoretically possible but would take either some more language work or some library work, beyond the language work we&#x27;d need to do to allow storing enums in the 0-4095 niche of pointers.<br>
<p>
I&#x27;m assuming that you mean &quot;a single machine word&quot; on a 64-bit system, because on a 32-bit system you can&#x27;t store a general u32 and something else in the same 32-bit word.<br>
<p>
Rust, today, has the property that a type is always stored the same way no matter where you put it, even when taking advantage of niches and similar. That&#x27;s important because if you have a Result&lt;T, Errno&gt;, if it&#x27;s an Ok you can get a &amp;T from it, and if it&#x27;s an Err you can get a &amp;Errno from it. So, that &amp;Errno needs to actually reference a thing that looks like an Errno in memory, not something that&#x27;s been tweaked to use different enum values.<br>
<p>
That works fine for a reference or box or other type that cannot have a value in the range 0-4095 (once we have the ability to declare that &quot;not in the first page of memory&quot; niche). An Errno can use that niche.<br>
<p>
However, if you have some type T that has a niche that isn&#x27;t 0-4095 (random example: a &quot;userspace pointer&quot; that can&#x27;t point into kernel memory but *can* potentially be 0-4095), such that T&#x27;s valid values and Errno&#x27;s valid values would overlap, you can&#x27;t tweak the Errno&#x27;s values to store them in T&#x27;s niche. That would mean you couldn&#x27;t get a valid reference to an Errno, because it needs translation before extracting it.<br>
<p>
In the specific case of a u32, the easiest solution is just to let Rust store the u32 and the Errno alongside each other, and they should take up no more than a 64-bit word.<br>
<p>
To solve the general case of niches that would require transforming the values of Errno when storing/extracting them, we could handle that in two ways, one at the library level or one at the language level:<br>
<p>
At a library level, we could just have a dedicated type (not Result) that stores an Errno and another type, which *doesn&#x27;t* let you get a &amp;Errno from it, and instead only lets you get an Errno. (Errno itself is smaller than a machine word, so we might as well just use its value.) We could then teach that dedicated type to store the errno in the niche of the T, and re-extract it later. That would solve the specific problem, with some effort, but would require writing code specifically to handle that transformation.<br>
<p>
Or, at a language level, we can add a concept of &quot;types that you can&#x27;t have a direct reference to&quot;, make a version of Errno with that attribute, and then allow such types to take advantage of arbitrary niches in other types. Because you can&#x27;t have a reference to those types, they don&#x27;t have to be stored in a way that looks exactly like they&#x27;d be stored if standalone. You&#x27;d typically use it for types that are so cheap to copy (because they&#x27;re smaller than a machine word) that the inability to reference them isn&#x27;t an issue.<br>
<p>
That language-level approach is the kind of thing that you can teach the Rust language to do *once*, and then it can automatically do the kinds of optimizations that in C you&#x27;d have to manually manage in each data structure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 0:43 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/854088/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think there&#x27;s actually a conundrum here. Someone is going to have to decide how much language and compiler work to do before you really push on Rust being used in the Linux kernel --- because before you do the latter, you will need to settle once and hopefully for all the idiomatic way to handle Errno results for various common T types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor853764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 15:44 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/853764/">Link</a>] (35 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s not necessarily more error-prone than having to check a composite result. It&#x27;s trivial to return composite results in C, it&#x27;s just rarely used because most of the time it brings little value and brings its own class of bugs as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 18:48 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/853786/">Link</a>] (34 responses)
      </p>
      
      </div>
      </summary>
      The difference is having language-level support for the goto-based error-checking idioms that Linux uses. For example something like

<pre>  r = func();
  if (r &lt; 0)
    goto some_label;
  ...
some_label:
  // chain of kfree and unlocks here
  return r;
</pre>

would be just

<pre>func()?;</pre>

Likewise, this

<pre>  r = -EINVAL;
  if (func() &lt; 0)
    goto some_label;
</pre>

would be

<pre>func().map_err(|_| errno::EINVAL)?;</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/853786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 20:18 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854040/">Link</a>] (33 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And there are really people who can parse such horrors ?<br>
<p>
Also not being able to figure exactly what that function is doing in my back after the question mark bothers me. How do you decide to atomically increment an error counter on the return path with that method ? How do you increment different counters depending on the case you&#x27;ve met ? I.e. oversized_frame or undersized_frame ?<br>
<p>
This looks like eye-candy for dummies to me, just to attract beginners by claiming they&#x27;ll write easier code but it&#x27;s hard to imagine it can ever be useful outside of school books.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854045"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 20:34 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854045/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
`?` is an early return in the error case. If you want to increase an error counter before returning, I would match and on the `Err` arm increment and return. Same thing with the different counters case.<br>
<p>
You might call it eye candy, but my eyes can&#x27;t follow goto spaghetti and match up allocation location/free call pairings on a whim. the RAII makes early returns in-place doable. If you have other things to do, don&#x27;t use `?`, but do your thing and return there.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854045/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 22:04 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/854063/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are there people who can parse C function pointer casts or ternary operator? Sure, they just have to study the language. <br>
<p>
Why should it be a surprise that not all of Rust can be guessed without studying the language?<br>
<p>
Honestly, the last time I heard this kind of complaint I was teaching first year university students.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 9:02 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/854140/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Weren&#x27;t C - and POSIX - originally designed as a glorified assembler for writing a games machine to run on a PDP-11?<br>
<p>
So it wasn&#x27;t even designed as a language to write an OS in! As those of us who can remember the - WELL DESIGNED - commercial systems that came before, to us C and *nix are basically crap. The problem is they were &quot;good enough, and cheap enough&quot; to sweep aside the opposition. And now all this extra stuff is being bolted on to get round design decisions that made sense for a single-user games machine, but are rubbish for actually writing real software, but can&#x27;t actually be designed away because so much old software relies on them!<br>
<p>
Whereas Rust has been designed as a language for writing low level systems. The first OS I used was originally written in FORTRAN. Then they wrote chunks of it in PL/1, both the official and their own unofficial versions. It worked pretty well. Then they re-wrote it in C and I think it was one of the major reasons the company tanked.<br>
<p>
Rule 0 of health and safety - MAKE DOING THE RIGHT THING EASY. That&#x27;s a design goal of Rust, which C appears never even to have heard of!<br>
<p>
You know I&#x27;m on the raid mailing list, and the number of bugs and lockups and whatever that seem to be creeping out of the woodwork because memory safety, spinlock, and the similar assorted mistakes have been made seems awful. Okay, they only seem to hit when users are doing esoteric things - just running a raid array is very well tested - but it would be nice if the language made those sort of bugs HARD, rather than trying to guarantee they will lurk in pretty much any poorly-tested error path.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:04 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854160/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sincerely I&#x27;m not seeing any difference between the examples above and my old horrible memories of Perl, where everything was written as awful regex matches, that was well-known for being a &quot;write only language&quot;, and that resulted in massive vulnerabilities everywhere since it was so difficult to figure what was *really* going to happen behind the curtains.<br>
<p>
Memory safety is the argument circling in loops all the time about this language. I&#x27;d like *CONTROL* safety. By obfuscating controls, I hardly see how someone may assess what is really going to be done. A number of issues come from compilers moving code around to optimize it while it reads fine on the screen, forcing us to add compiler barriers, READ_ONCE() and so on. You can add all the amount of &quot;memory safety&quot; you want, if that results in a totally mangled non-sequential syntax, you can be certain that such issues will be even harder to spot, especially with the the arrogant attitude I&#x27;ve seen from some people around the language constantly claiming &quot;bugs are C, we can&#x27;t make bugs in rust&quot;. Bugs are human. Humans need to understand what is being done. C is far from being perfect, we all know it, but it translates to instructions and does not add magic everywhere to make the developer feel proud of writing code using smileys. This is essential to me and way more than &quot;memory safety at compile time&quot; and &quot;panic in unexpected situations&quot;.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:21 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854167/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, but the whole &quot;Perl is a write-only language&quot; reads to me like &quot;I can&#x27;t read Perl, how can people be so mean writing in a language that uses symbols!!! Sigils!!! They are programming with smileys!!!&quot;<br>
<p>
Yes. I understand that some people have problems with a highly symbolic language. But the &quot;I am in control if I can see every GOTO&quot; is just an illusion. Many parts of the kernel code will be data-driven. And just like the regular expressions you seem to abhor, there are many, many ways to write correct programs that are perfectly readable... by those who can read the language. Even if those programs are as succint as possible.<br>
<p>
The fact is that whenever you force kernel devs to trace each and every exception that they will have to redirect flow (goto) to some place where the exact amount of resource acquisition you did up to now can be undone, you are just introducing opportunities for bugs to creep in.<br>
<p>
Memory safety is ONE of the concerns -- resource freeing/ RAII is a bigger concern that is addressed by higher-level languages like Rust and C++.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854218"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 14:13 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854218/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  And just like the regular expressions you seem to abhor, there are many, many ways to write correct programs that are perfectly readable... by those who can read the language.</font><br>
<p>
Yes, they&#x27;re all listed on cve.mitre.org<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854218/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 18:15 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854267/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yes, they&#x27;re all listed on cve.mitre.org</font><br>
<p>
PLEASE PRETTY PLEASE show me ONE example of a CVE caused by a regular expression. Let me make some popcorn while I wait for you to try.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 19:02 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854283/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Now, even if I am charitable and see that what you meant was &quot;oh ultra-terse, symbolic code causes CVEs&quot;, this is provably false, also.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 19:47 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/854292/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
J (or APL), anyone :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2021 16:58 UTC (Thu)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/854912/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I learned APL2 in high school.  I learned Perl 4 from the man page.  I find these discussions curious.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor854285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 19:02 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/854285/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here you go!<br>
<p>
<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23354">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23354</a><br>
<p>
&quot;The package printf before 0.6.1 are vulnerable to Regular Expression Denial of Service (ReDoS) via the regex string /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/g in lib/printf.js. The vulnerable regular expression has cubic worst-case time complexity. &quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 19:59 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854295/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Point conceded! Oh man, I've been proven wrong TWICE already on this thread! I must be turning into a Real Boy&trade;!

      
          <div class="CommentReplyButton">
            <form action="/Articles/854295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2021 23:28 UTC (Tue)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/854679/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I realise this is just a bit of fun, but I&#x27;d say that is not the regex&#x27;s fault.  It&#x27;s the fault of the underlying re library using an NFA to recognise it.   I&#x27;ve been bitten by NFA&#x27;s going rouge of some input so many times now, I&#x27;d say a regex library using a NFA is a bug that leads to CVE&#x27;s like the one you found.<br>
<p>
DFA&#x27;s might occasionally take exponential space for their compiled form and you have to incur the expense of compiling the entire thing, but you get to find out about your bug the first time the regex is compiled, not some at some random time later in production.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor854169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:23 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854169/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Sincerely I&#x27;m not seeing any difference between the examples above and my old horrible memories of Perl, where everything was written as awful regex matches, that was well-known for being a &quot;write only language&quot;, and that resulted in massive vulnerabilities everywhere since it was so difficult to figure what was *really* going to happen behind the curtains.</font><br>
<p>
The new syntax is the lambda parameter bit (`|_| expr` is a lambda that takes one argument, names it `_` to ignore it, then evaluates to `expr`) and the `?` which is the &quot;if an error occurred, return it from the current function, otherwise evaluate to its success value.<br>
<p>
The other bit you need to remember is:<br>
<p>
<font class="QuotedText">&gt; I&#x27;d like *CONTROL* safety</font><br>
<p>
RAII is what you want then. You don&#x27;t have to thread your own cleanup-on-error cases together based on where they can occur from within the function. If you allocate a lock in Rust, it has two destinies: passing it off to another function or unlocking when the function returns. There&#x27;s no other choice[1].<br>
<p>
<font class="QuotedText">&gt; but it translates to instructions and does not add magic everywhere to make the developer feel proud of writing code using smileys.</font><br>
<p>
Rust does the same thing. I feel like saying &quot;?&quot; hides control flow is like saying &quot;?: hides lazy evaluation&quot; or &quot;how can I see short-circuiting boolean operator logic&quot; in C. It&#x27;s part of the language. If you don&#x27;t want to learn it, fine. But why does your resistance to learning something new block others from using what they know?<br>
<p>
[1] Well, I suppose you could manually drop it, but that is such an oddity that it&#x27;d be like seeing &quot;// intentionally don&#x27;t unlock here; it will be done in $foobar later in the logic that uses this function&quot; except you *have* to spell it out instead of being lucky someone was kind enough to leave a comment for you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:25 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854172/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If you allocate a lock in Rust</font><br>
<p>
Sorry, this should read &quot;take a lock&quot; (was thinking lock guard, but then edited around it).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:40 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854173/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; I&#x27;d like *CONTROL* safety</font><br>
<p>
This person does not want control safety, they want safety control. They want to SEE the &quot;if condition bail out thru such and such path&quot; because they are under the impression that they can do better than the compiler in determining which &quot;such and such path&quot; is appropriate.<br>
<p>
As you said (and I also did, in another comment), it&#x27;s ok to like &quot;things written as words&quot; in software. And it&#x27;s ok if a person likes C, knows C, and has no interest in learning C++ or Rust. But it&#x27;s just silly to block others from using what they already know.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 17:24 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/854254/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And I get the impression he is also assuming that the language ENFORCES &quot;bail on error&quot;. I don&#x27;t have any knowledge of Rust but I can&#x27;t believe that the designers would be so stupid as to stop you identifying, handling, and cleaning up errors manually.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2021 20:29 UTC (Sat)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/854364/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Rust indeed does not enforce bail on error. The core library uses a Rust <tt>enum</tt> called <tt>Result&lt;T, E&gt;</tt> (where <tt>T</tt> is a type parameter for the "happy" path, and <tt>E</tt> is a type parameter for the "failure" path) to handle errors. It has two variants: <tt>Ok(T)</tt> for the happy path, and <tt>Err(E)</tt> for the failure path; you can use Rust's <tt>match</tt> or <tt>if let</tt> primitives to dissect an error manually, if you wish.
<p>To return a "happy" value, you return <tt>Ok(value)</tt>, where <tt>value</tt> has to be of type <tt>T</tt>; similarly, to return a failure, you return <tt>Err(error)</tt> where <tt>error</tt> has to be of type <tt>E</tt>. There is a special operator, previously spelt <tt>try!(...)</tt> and now spelt <tt>...?</tt> which for <tt>Result</tt> is equivalent to the following Rust:
<p><tt><pre>
match ... {
    Ok(v) =&gt; v,
    Err(e) =&gt; return Err(e.into()),
}
</pre></tt>
<p>Of course, if you write it out in full, you don't have to return the error, or do the conversion (<tt>.into()</tt> uses the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into trait</a> to convert from one type to another, allowing you to convert errors in this case <em>if</em> a suitable conversion is implemented. In the kernel, you might use this to convert from a driver-specific error to a KernelError type, for example, so that you can retain semantic details of your error while in Rust). You can implement a different pattern match that does whatever you want with the Result type - maybe not bailing at all, but doing something different.
<p>That said, you do still end up with Rust doing some work when you exit a scope, beyond just deallocating the stack frame. If a type implements the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>, the code in there is run when the object is deallocated.
      
          <div class="CommentReplyButton">
            <form action="/Articles/854364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor854219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 14:21 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854219/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  The new syntax is the lambda parameter bit (`|_| expr` is a lambda that takes one argument, names it `_` to ignore it, then evaluates to `expr`) and the `?` which is the &quot;if an error occurred, return it from the current function, otherwise evaluate to its success value.</font><br>
<p>
Thanks for explaining. I find this overly complicated to add an argument that must be ignored.<br>
<p>
<font class="QuotedText">&gt; The other bit you need to remember is:</font><br>
<font class="QuotedText">&gt; &gt; I&#x27;d like *CONTROL* safety</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; RAII is what you want then. You don&#x27;t have to thread your own cleanup-on-error cases together based on where they can occur from within the function.</font><br>
<p>
No, please no, that the worst horror of modern languages in my opinion. As I explained, it encourages in *not* handling abnormal conditions and letting someone else deal with them. Abnormal conditions are best handled *where* they occur, not by lazily returning to the caller which will do the same.<br>
<p>
<font class="QuotedText">&gt; If you allocate a lock in Rust, it has two destinies: passing it off to another function or unlocking when the function returns. There&#x27;s no other choice[1].</font><br>
<p>
While most of the time I do prefer locks to be symmetric, I&#x27;ve already entered into situations where it was needed *not* to unlock, and yes, that requires clean code and a big fat comment above the function (and if possible a name that suggests it).<br>
<p>
<font class="QuotedText">&gt; but it translates to instructions and does not add magic everywhere to make the developer feel proud of writing code using smileys.</font><br>
<p>
Fortunately another member here showed how to handle errors with if/else that allows to properly take care of them instead of ignoring them.<br>
<p>
<font class="QuotedText">&gt; Rust does the same thing. I feel like saying &quot;?&quot; hides control flow is like saying &quot;?: hides lazy evaluation&quot; or &quot;how can I see short-circuiting boolean operator logic&quot; in C. It&#x27;s part of the language. If you don&#x27;t want to learn it, fine. But why does your resistance to learning something new block others from using what they know?</font><br>
<p>
It&#x27;s not a matter of me refusing to learn, it&#x27;s that the arguments that are presented to defend it are exactly those which I take as counter-arguments: let&#x27;s encourage developers not to care about anything anymore and ignore who will process their errors since the compiler will surely know better.<br>
<p>
<font class="QuotedText">&gt; [1] Well, I suppose you could manually drop it, but that is such an oddity that it&#x27;d be like seeing &quot;// intentionally don&#x27;t unlock here; it will be done in $foobar later in the logic that uses this function&quot; except you *have* to spell it out instead of being lucky someone was kind enough to leave a comment for you.</font><br>
<p>
Comments are precisely made to document non-obvious stuff like this. Someone who writes a function that plays with non-obvious locks or locks in a non-obvious way and doesn&#x27;t mention it is looking for trouble anyway.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 14:51 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854230/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
I find this overly complicated to add an argument that must be ignored.
</blockquote>

It's not "add[ing] an argument that must be ignored". The .map_err passes the function the error. If you want to ignore it, you use `|_|`. If you want to handle it, give it a name. It's not like C where a N-ary function can be passed to a callback passing M arguments as log as M &lt; N. The arity must match, so the passed closure must take an argument (here, ignored).

<blockquote>
No, please no, that the worst horror of modern languages in my opinion. As I explained, it encourages in *not* handling abnormal conditions and letting someone else deal with them. Abnormal conditions are best handled *where* they occur, not by lazily returning to the caller which will do the same.
</blockquote>

I think we agree, but we're talking on different levels of abstraction. Of course, where to *best* handle an error depends on the error itself. Bad flags? Caller's fault. Lock contention? Probably my issue. Can't open a file? Do I have a contract to retry? Maybe the kernel *is* different, but most of the time I can wrap up an error like this:

<pre>
let output = process::Command("git") // the executable
  .arg("--version") // build up an argument list
  .output() // I want the output of the command
  .map_err(|err| MyErr::GitExec("--version", err))?;
if output.status.success() {
  return Err(MyErr::Git("--version", output.status.code()));
}
</pre>

where `MyErr::GitExec` indicates:

  - `git` failed to *launch*
  - the "--version" describes what was being done
  - the err contains the error that occurred

`MyErr::Git` indicates:

  - `git` executed, but returned failure
  - "--version" acts largely the same
  - it contains the exit code as well

My code doesn't particularly care *why* it failed, but it can annotate why it was trying to do what it was doing when the error happened.

<blockquote>
Fortunately another member here showed how to handle errors with if/else that allows to properly take care of them instead of ignoring them.
</blockquote>

Sure. When it calls for it, expand it out. I think I still usually prefer a closure for Result&lt;&gt; handoffs like above, but it's a style difference. The code is basically the same (in fact, I *think* that you can use cargo-expand to see what `?` desugars to in your code as well, but maybe that was when it was spelled `try!()`).
      
          <div class="CommentReplyButton">
            <form action="/Articles/854230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor854311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 23:19 UTC (Fri)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/854311/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><em>Weren't C - and POSIX - originally designed as a glorified assembler for writing a games machine to run on a PDP-11?</em></blockquote>
<p>
Nope. You may wish to read up on the
<a href="https://www.bell-labs.com/usr/dmr/www/hist.html">early
history of Unix</a>.
</p>
<p>
In a nutshell, the game was written in assembly language for the PDP-7 (using a cross-assembler on the GE 635) and preceded Unix. Unix came along later as a rudimentary operating system for software development on the PDP-7. The early Unix hackers around Ken Thompson only got access to a PDP-11 in 1970 when they promised to produce a system for editing and typesetting text. This was eventually used by the Bell Labs patent department and gradually evolved into what we would think of as Unix. Various higher-level programming languages were tried and discarded, and eventually the Unix kernel was rewritten in C in 1973.
</p>
<p>
Unix was actually quite innovative in its time (especially the file system was miles ahead of the competition as far as versatility was concerned), and the fact that Unix was written in C did a lot to make it portable to many of the evolving computer architectures of the 1970s and 1980s. It is safe to say that without Unix and C, the computing landscape today would look a lot different and – in view of the various clunky manufacturer-specific systems that Unix eventually replaced – not necessarily better. Ken Thompson and Dennis Ritchie didn't receive their Turing award for their awesome beards.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/854311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 11:52 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854157/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, but for me, even with a lot of good faith and mind stretching, I cannot figure how something spelled &quot;func().map_err(|_| errno::EINVAL)?;&quot; could translate to &quot;if (func() &lt; 0) goto leave;&quot;. Using smileys to write expressions will sooner or later either strike you in the back when you&#x27;re tired late at night, or result in something different being done to &quot;help&quot; you.<br>
<p>
Ultimately you *want* the processor to emit a test and a branch to a place where some things are undone. Why would you force yourself to express it in a totally different way ? I could also take a pencil, draw animals and expect the compiler to figure what I&#x27;m trying to do and emit code, and there will possibly be fans of this, but I&#x27;m not one of them, I&#x27;m sorry.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:10 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854163/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Seriously? You can't read "call <tt>func()</tt>, and if it returns any error (the less than zero C status code), map this error to <tt>errno::EINVAL</tt> and return <em>that</em> <tt>EINVAL</tt> error instead, unwinding any initializations that had been done up to now -- which includes potentially releasing locks, file handles, and other resources that if I forget to release manually will cause a leak?" I don't like Rust very much, but even I can read that <pre>
  func()?
</pre> is much less error-prone than <pre>
  r = func();
  if( r &lt; 0 )
    goto UNWIND_EXACTLY_WHAT_HAS_BEEN_DONE_TILL_NOW;
</pre> where you have to manually sprinkle your function with a dozen <tt>UNWIND1</tt>, <tt>UNWIND2</tt>, etc...
      
          <div class="CommentReplyButton">
            <form action="/Articles/854163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 14:32 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854220/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Seriously? You can&#x27;t read &quot;call func(), and if it returns any error (the less than zero C status code),</font><br>
<p>
No, sorry, I can&#x27;t parse that this smiley &quot;|_|&quot; means &quot;less than zero&quot;.<br>
<p>
<font class="QuotedText">&gt; I don&#x27;t like Rust very much, but even I can read that </font><br>
<font class="QuotedText">&gt;  func()?</font><br>
<font class="QuotedText">&gt; is much less error-prone than</font><br>
<font class="QuotedText">&gt;  r = func();</font><br>
<font class="QuotedText">&gt;  if( r &lt; 0 )</font><br>
<font class="QuotedText">&gt;    goto UNWIND_EXACTLY_WHAT_HAS_BEEN_DONE_TILL_NOW;</font><br>
<font class="QuotedText">&gt; where you have to manually sprinkle your function with a dozen UNWIND1, UNWIND2, etc... </font><br>
<p>
And the simple fact that you write that is *exactly* what worries me about such practices. Just getting rid of abnormal failures seems to be the default way of developing. With the example involving the &quot;goto&quot; above it&#x27;s simple to add an error counter for the specific type of condition that was met there, and possibly call other stuff to propagate that.<br>
<p>
With the default &quot;unwind&quot; practice, well, it&#x27;s just that. &quot;OK got an error, let&#x27;s report above that something happened, surely someone will figure what it was&quot;. When reading data from a NIC for example you can face a number of different &quot;errors&quot; (which are in fact abnormal but totally expected conditions) for which you have to write code to increase their respective counters and certainly not just &quot;unwind exactly what has been done&quot;. In some circumstances you&#x27;ll even need *not* to unwind everything, because for example you&#x27;d have pre-allocated and initialized a buffer and will prefer to keep it around for the next use instead of putting it back into the dirty pool so that it gets initialized again on next call. This is just an example of course, but you probably understand what I mean. And if not, anyway, I sense that we&#x27;ll never agree because we don&#x27;t have the same expectations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 18:14 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854261/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <cite>No, sorry, I can't parse that this smiley "|_|" means "less than zero".</cite>

It doesn't. The "less than zero" part is the C construct where you use positive return values to indicate that func did its job ok (and return some useful result, e.g., number of bytes written etc)

<p>Just FYI: The "smiley" <tt>|_|</tt> is the equivalent to <tt>lambda x:</tt> in python (where <tt>x</tt> will be ignored from now on) and <tt>map_error</tt> just substitutes the error part of a <tt>Result</tt> for the evaluation of said lambda.</p>

As for the rest of your argument, you are still sustaining that you and all other devs are better in knowing what has to be unwound than the compiler is. So, I'll refer to my other answer at <a href="https://lwn.net/Articles/854194/">this other comment.</a>
      
          <div class="CommentReplyButton">
            <form action="/Articles/854261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor854097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 1:03 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/854097/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>And there are really people who can parse such horrors ?</blockquote>

Yes. It's far less "horrifying" than, say, C type syntax.

<blockquote>How do you decide to atomically increment an error counter on the return path with that method ?</blockquote>

You can always manually write out

<pre>  if func().is_err() {
    increment_error_count();
    return Err(errno::EINVAL);
  }</pre>

or

<pre>  if let Err(e) = func() {
    if ... something involving e ... {
      increment_oversized_frame_count();
    } else if ... something involving e ... {
      increment_undersized_frame_count();
    }
    return Err(errno::EINVAL);
  }</pre>

<blockquote>This looks like eye-candy for dummies to me, just to attract beginners by claiming they'll write easier code but it's hard to imagine it can ever be useful outside of school books.</blockquote>

People write lots of real code using Rust, including Rust "Result" and "?". I have a product with 200K lines of Rust code written over the last 5 years and we use these features everywhere. I also have 30 years experience writing C and C++ code if that matters to you.
      
          <div class="CommentReplyButton">
            <form action="/Articles/854097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:07 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854165/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well at least your examples look more readable in terms of control.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:30 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854170/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      The problem is exactly that. You are arguing that the kernel shouldn't have <pre>
  long x = input &amp; SOME_FLAG ?
    (input &amp; SOME_MASK) + SOME_INITIAL_VALUE :
   other_input &amp; SOME_OTHER_FLAG || OTHER_INITIAL_VALUE;
</pre> because idiomatic C is "too terse" and "hides control flow". After all, how can you see the two <tt>if</tt> that are lurking in this smiley-laden code?
      
          <div class="CommentReplyButton">
            <form action="/Articles/854170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854216"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 14:01 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854216/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not to mention with that particular code, I have to dredge up my C operator precedence to figure out if that `|| OTHER_INITIAL_VALUE` is a bug or not. Is it supposed to be `|`? Is it supposed to be with the false branch or the whole conditional expression?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854216/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 14:34 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854223/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I totally agree with you and am not writing C code like this either, just like I don&#x27;t like seeing assignments inside conditions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 18:09 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854264/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      The short-circuiting logical-or operator <tt>||</tt> is defined as "evaluate LHS, if it's a truth value (none of false, 0, '\0', nullptr) return that, else return RHS". It binds more tightly than the <tt>?:</tt> ternary conditional. The whole statement, explicitly written, would be:<pre>
  long x;
  if( input &amp; SOME_FLAG ) {
    x = (input &amp; SOME_MASK) + SOME_INITIAL_VALUE;
  } else {
    x = other_input &amp; SOME_OTHER_FLAG;
    if( !x ) {
      x = OTHER_INITIAL_VALUE;
    }
  }
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/854264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 18:30 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854271/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This makes me think it&#x27;s a typo because `expr || OTHER_INITIAL_VALUE` always returns 0 or 1, not `OTHER_INITIAL_VALUE`.<br>
<p>
#include &lt;stdio.h&gt;<br>
<p>
#define p(x) printf(#x &quot; = %d\n&quot;, x)<br>
<p>
int main() {<br>
    p(0 || 2);<br>
    return 0;<br>
}<br>
<p>
outputs:<br>
<p>
0 || 2 = 1<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 18:37 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854274/">Link</a>] 
      </p>
      
      </div>
      </summary>
      That one was MY mistake. Wrong language. It's not a typo, it's an honest-to-god mistake and I would have introduced a kernel bug, if the code review didn't see it. The <tt>||</tt> operator always return a bool and it's zero or one.
      
          <div class="CommentReplyButton">
            <form action="/Articles/854274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor853689"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 7:38 UTC (Wed)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/853689/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well since this seems pushed by google. They have all the interest in having the kernel not change API so that the android vendors can easily port their drivers across versions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853689/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 20:08 UTC (Wed)
                               by <b>tbelaire</b> (subscriber, #141140)
                              [<a href="/Articles/853790/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I  was just a undergrad student and I worked wiht a grad student to re-write  (maybe translate would be a better word) a block device driver into Rust 4 years ago, and gave a talk at Linux con.<br>
<p>
<p>
So we&#x27;ve been working on it for a while now, including writing drivers.<br>
<p>
(Turns out Rust wasn&#x27;t quite ready back then, but the hard part is definitely the safe abstraction layer.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor853725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 14:30 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/853725/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There’s a huge chicken and egg problem here, though.  They’ve been asked to, so let’s give them a little time - I think the sincerity of the effort merits at least that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor853682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 6:04 UTC (Wed)
                               by <b>motk</b> (subscriber, #51120)
                              [<a href="/Articles/853682/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
He&#x27;s been like this for decades. Nothing ever happens.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 13:47 UTC (Wed)
                               by <b>ms-tg</b> (subscriber, #89231)
                              [<a href="/Articles/853716/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have a suspicion that this is the moment. Learn to communicate appropriately before the “next generation” of developers, who have concrete expectations in this area, and are likely to be the fastest uptake group of Rust, encounter this behavior.<br>
<p>
If not, I can’t help but expect more defenestration drama.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor853683"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 6:49 UTC (Wed)
                               by <b>rahix</b> (guest, #136292)
                              [<a href="/Articles/853683/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I want to comment on this statement in particular:<br>
<p>
<font class="QuotedText">&gt; If the Rust compiler ends up doing hidden allocations, and they then cause panics [...]</font><br>
<p>
In contrast to C++, Rust does not have such a thing as a core-language allocation primitive (like C++&#x27;s `new` operator).  As long as you don&#x27;t link in the `alloc` crate, the is zero possibility for any kind of heap allocation to happen, much less a hidden one.  If I understood correctly, this is the route Rust-for-Linux eventually wants to take:  The standard `alloc` crate is not used and instead similar APIs are built for the kernel, where all allocating functions are fallible (= they return a Result&lt;Value, AllocationFailure&gt;).  This will then mean a caller must consider what their code should do in case of an allocation failure, and no panics are possible or needed.  Even better:  Due to Rust&#x27;s Result type you cannot even forget to deal with this possibility, because you cannot access the returned value until you dealt with potential errors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853683/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 15:54 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/853765/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      &gt;<i> As long as you don't link in the `alloc` crate, the is zero possibility for any kind of heap allocation to happen, much less a hidden one.</i>
<br/>
Then how do you explain that this simple test instantly runs out of memory ? And how should I test for the allocation since it seems to do it in my back during the concatenation without me having any handle on it ?
<pre>
   fn main() {
        let mut str1 = "A".to_string();
        let mut str2 = "B".to_string();

        loop {
                str1 = str1 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2 + &amp;str2;
                str2 = str1.to_string();
        }
   }
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/853765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 16:10 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/853769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you&#x27;re linking to `alloc` there, so that&#x27;d be why. You&#x27;d need to remove `alloc` (which removes many of the stdlib containers/types, including probably String) which depend on it. That&#x27;s the point of the kernel-specific stdlib (much as the kernel has its own libc).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853766"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 16:14 UTC (Wed)
                               by <b>rahix</b> (guest, #136292)
                              [<a href="/Articles/853766/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The to_string() method is part of the `alloc` crate: <a href="https://doc.rust-lang.org/alloc/string/trait.ToString.html">https://doc.rust-lang.org/alloc/string/trait.ToString.html</a> It won&#x27;t be available when `alloc` is not linked.<br>
<p>
I agree that _with_ liballoc it is sometimes hard to see where allocations happen, but that is no different from medium complex C libraries in userspace.  Rust-for-Linux uses Rust in no_std mode which means libstd and liballoc are not linked in by default.  Only by explicitly defining a global_allocator (<a href="https://github.com/Rust-for-Linux/linux/blob/9e6e67e06bdc64babe392366222cfe5f8b0a61fa/rust/kernel/allocator.rs#L13-L23">https://github.com/Rust-for-Linux/linux/blob/9e6e67e06bdc...</a>) are they making use of liballoc right now and AFAIK this is to be removed in favor of custom, fallible allocation APIs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853766/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 16:23 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/853772/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK so at the same time it will remove some of the eye-candy stuff that make such modern languages appealing to newcomers, such as &quot;look how strings are much easier to handle than in C&quot;. C has no problem with strings, they do not exist. Only the functions of the stdlib which use pointers to arrays of chars as strings are a total mess, but it&#x27;s possible to write alternatives that provide checks and that will result in similar code as in other languages once controls are enabled :-/  It&#x27;s just less convenient for the day-to-day work.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 18:03 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/853781/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The purpose of Rust-in-the-kernel is not eye candy. It is improving memory and thread safety.<br>
<p>
(Besides, concatenating strings in C requires sacrificing a goat to the kmalloc gods; I don&#x27;t see how no-alloc Rust could possibly be any *worse* than that.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853782"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 18:07 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/853782/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; OK so at the same time it will remove some of the eye-candy stuff that make such modern languages appealing to newcomers</font><br>
I&#x27;m not sure about being able to easily concatenate strings with a &quot;+&quot; operator, but pretty much everything else is going to work fine. String algorithms either don&#x27;t allocate or can be modified to accept an explicit allocator policy. This is simply a matter of writing the kernel stdlib.<br>
<p>
You&#x27;ll certainly be able to:<br>
- Statically check the format string parameters.<br>
- Pre-compile formatting into a fast bytecode.<br>
- Compile regexes into Rust code (during compilation).<br>
- Use the regular split/find/replace/prefix operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853782/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 1:47 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/854099/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The overloadable operators in Rust are implemented as Traits.<br>
<p>
So things you can Add have an implementation of add() such that the result of the function is the same type as the left hand side - and Rust will call that when you use the + operator. String implements add (using the allocator implicitly). Because the result must be the same type, you can&#x27;t get a Result back and so we can&#x27;t have allocation which might fail.<br>
<p>
Presumably we should not like to have this implicit allocation in the Linux kernel, and so any hypothetical Rust KernelString won&#x27;t implement Add and you won&#x27;t be able to use the + operator on it. Whereas if some other KernelThing can reasonably have something added without implicit allocation then it can implement Add for whatever that is. The Traits used for overloading don&#x27;t require that the left and right hand sides are the same type, so adding a_kernel_thing + 4 is allowed, if KernelThing feels it makes sense to implement Add&lt;u8&gt; or whatever type of integer the compiler can reasonably choose to believe 4 is.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 12:47 UTC (Mon)
                               by <b>Jonno</b> (subscriber, #49613)
                              [<a href="/Articles/854442/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Because the result must be the same type, you can't get a Result back and so we can't have allocation which might fail.</font>
<p>
It doesn't, so you can. The following code would implement <i>String + &amp;str -&gt; Result&lt;String, AllocError&gt;</i>, just replace ... with the gnarly details:<br>
<p>
<pre>
impl Add&lt;&amp;str&gt; for String {
    type Output = Result&lt;String, AllocError&gt;;

    fn add(mut self, other: &amp;str) -&gt; Result&lt;String, AllocError&gt; { ... }
}
</pre>
<p>
However, <i>AddAssign</i> <b>does</b> require that the output type is the same left hand side, so you can't implement <b>+=</b> fallibly, but I would think it is obvious why.
      
          <div class="CommentReplyButton">
            <form action="/Articles/854442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2021 3:04 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/854693/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oops, I clearly don&#x27;t understand Rust even as well as I thought I did, I had read Self::Output as implying you can&#x27;t change this, when in fact as you say it specifically allows the implementer to pick any type for Output. Thank you for pointing that out.<br>
<p>
So, at risk of being wrong again, surely with AddAssign the problem isn&#x27;t so much that the output type is the same as the left hand side as that Rust itself enforces the assumption that AddAssign just directly changes the left hand side, rather than having any &quot;output&quot; at all ?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2021 8:00 UTC (Wed)
                               by <b>micka</b> (subscriber, #38720)
                              [<a href="/Articles/854701/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you can change the object operated on, Addassign can do if.<br>
Strings (for example) is immutable and ’self’ cannot be changed so AddAssign will return a new object instead (common impl <a href="https://doc.rust-lang.org/src/core/ops/arith.rs.html#725">https://doc.rust-lang.org/src/core/ops/arith.rs.html#725</a> for many base types like i32 etc)<br>
See <a href="https://doc.rust-lang.org/src/alloc/string.rs.html#2029-2034">https://doc.rust-lang.org/src/alloc/string.rs.html#2029-2034</a> (and push_str uses <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.extend_from_slice">https://doc.rust-lang.org/std/vec/struct.Vec.html#method....</a> which clones the String underlying Vec).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2021 8:04 UTC (Wed)
                               by <b>micka</b> (subscriber, #38720)
                              [<a href="/Articles/854704/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note that the rust library documentation <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a> is (in my opinion) very complete and the [src] links go to the implementation  (same version as the doc you are reading).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor855069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2021 0:01 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/855069/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess I still don&#x27;t understand. How is the code you pointed to _returning_ a new object? The function is clearly defined without a return type, and indeed doesn&#x27;t return anything [technically it returns the empty tuple], it just alters self to achieve its purpose.<br>
<p>
In some languages the add-assign operator has a result type such that if you write a = (b+= 1) then both a, and b become b + 1. But in Rust that type is always the empty tuple, I just checked and as expected Rust allows me to do this, but not to any sort of integer variable a since (b+= 1) is an empty tuple and thus incompatible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/855069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor855088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2021 11:14 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/855088/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think there was some confusion. I don&#x27;t think `AddAssign` can be used where allocation is a failure on types which may need to allocate. I guess one could define it for `Result&lt;String, AllocationError&gt;` where if it fails, it turns into the Err variant, but that doesn&#x27;t sound great. I think String just loses AddAssign in a fallible allocation world. Which I think is fine, but I am also fine with explicit error checking everywhere it is needed. I feel like the kernel would prefer calculating a single buffer size then allocating it all at once rather than building up a string piecemeal, but I don&#x27;t know.<br>
<p>
And yes, it appears as though assignment does not return a reference to the object as it does in C and C++. One could write a small function which worked that way, but then you lose the `=` spelling of assignment. With lifetime tracking, getting it to work in practice is probably not that easy anyways outside of Copy types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/855088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor855108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2021 5:47 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/855108/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK great, I think we&#x27;re both on the same page now, *phew*. I learned some things about Rust and how to interpret Trait definitions, which was valuable.<br>
<p>
I&#x27;m excited to see kernel Rust once it does have its own alloc implementation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/855108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor853785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 19:11 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/853785/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <p>I think the significant difference is that Rust (like C++) lets you define a new string type with compile-time-constant capacity, which doesn't use the heap and can be allocated on the stack or as part of a larger object. Then you can define methods to make it almost as convenient as a dynamically-allocated string, with your preferred error-handling behaviour when the capacity is exceeded. And it's guaranteed to be correctly bounds-checked.</p>

<p>E.g. someone on crates.io wrote an "arraystring" crate which allows code like:</p>

<pre>
type MyString = ArrayString&lt;U20&gt;;
fn test() -&gt; Result&lt;MyString, arraystring::Error&gt; {
    let mut s = MyString::try_from_str("Hello")?;
    s.try_push_str(" world!")?;
    let t = MyString::from_str_truncate("1234");
    s = s + &amp;t + "56789";
    Ok(s)
}
</pre>

<p>The "try_" functions return a Result type that can indicate an overflow error, and the "?" will propagate the error (and the caller can handle it or propagate it again). The from_str_truncate and "+" can't fail, they are defined to truncate. All the storage is allocated on the stack (but you can't accidentally use a dangling pointer to an old stack frame, because the compiler will notice and complain; in this case it's returning by value so it's safe). Or if you want to save stack space you could let the caller pass in a mutable reference to a string object that was allocated elsewhere.</p>

<p>If I understand it correctly, you can also use s.as_str() to get a 'string slice' referring to the ArrayString's bytes, and most of Rust's string-using libraries will happily work with that string slice, exactly the same as if it came from a normal heap-allocated String. (In C terms a string slice is basically a char* plus a size, so it works anywhere that doesn't need to resize the string, which is most places.)</p>

<p>So there's some unavoidable inconvenience from having to think about how you're going to handle overflow, and you might have to implement the string library yourself if nobody else has made a suitable one yet, but it's still much simpler (and much safer) than string manipulation in C.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/853785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 23:03 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/853814/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is basically right, but one issue is that Rust strings are always valid UTF8, and it&#x27;s not clear to me how often kernel strings are guaranteed to be valid UTF8. Maybe you&#x27;ll end up using something like the `bstr` crate instead where strings don&#x27;t have to be valid UTF8, in which case actual Rust `str` in the kernel might end up being rare.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 12:24 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854166/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The &quot;try_&quot; functions return a Result type that can indicate an overflow error, and the &quot;?&quot; will propagate the error (and the caller can handle it or propagate it again).</font><br>
<p>
I must say I really don&#x27;t like that at all, it reminds me the horribly broken concept of exceptions in certain languages that is responsible for the vast majority of backtraces produced all over the world every single second.<br>
<p>
Errors don&#x27;t exist, and as such they must not be propagated. What people often call errors are in fact the undersirable outcome of some operations, and very often there are valid alternatives to handle them. But some languages or framework like to make it easier to hire newbie developers by asking them to &quot;only code what&#x27;s on the diagram and not worry about errors as they will be caught&quot; (heard many times in web development). In this case there&#x27;s no attempt at falling back to a sane situation, you just pass the &quot;error&quot; to the caller so that your problem become someone else&#x27;s.<br>
<p>
And the farther you are from the failure the harder it is to try to gracefully address it. That&#x27;s the segfault or the python calltrace basically.<br>
<p>
One important principle in computer safety is to always reject the slightest piece of code which contains exception handling or too generic error handling, because it then becomes very hard to figure if some errors were not specifically handled. Each failure to do something needs to be addressed, if possible, gracefully.<br>
<p>
I know it probably means nothing to a number of people who will find me obsessed with reliability and trustable control, but the day your father&#x27;s pacemaker spends its time rebooting because its battery&#x27;s voltage reads too low a value due to environmental conditions instead of just slowing down the valve to preserve resources, you may think again about this &quot;propagate error&quot; vs &quot;deal with the error right here&quot; discussion. And once code starts to be written with exceptions instead of error handling, it&#x27;s impossible to fix it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854192"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 13:20 UTC (Fri)
                               by <b>jpfrancois</b> (subscriber, #65948)
                              [<a href="/Articles/854192/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But handling error in C code is not mandatory, so failing to handle error can happen also in C.<br>
Ignoring error or Ignoring excpetion can be equally bad.<br>
<p>
Error Handling code is easier to write and read if all you have to do is actually handling the error, instead of handling the error + adding code to handle the resource deallocation.<br>
<p>
Error handling in the kernel happens because of code being reviewed or being written by skilled persons. I can&#x27;t see why the same think would not happen in rust.<br>
I also remeber reading an article here on LWN about how a lot of the error path are broken. Maybe because having to write both an error handling code + a resource management code is more prone to failure...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854192/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 14:48 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854226/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But handling error in C code is not mandatory, so failing to handle error can happen also in C.</font><br>
<font class="QuotedText">&gt; Ignoring error or Ignoring excpetion can be equally bad.</font><br>
<p>
I totally agree and these are indeed among the sources of bugs.<br>
<p>
<font class="QuotedText">&gt; Error Handling code is easier to write and read if all you have to do is actually handling the error, instead of handling the error + adding code to handle the resource deallocation.</font><br>
<p>
Except when you do not want to just fall back to a default &quot;unwind&quot; and provide more info instead. You know, the typical problem that plagues most applications that cannot report clean logs and instead lazily dump kilometers of backtraces.<br>
<p>
<font class="QuotedText">&gt; Error handling in the kernel happens because of code being reviewed or being written by skilled persons. I can&#x27;t see why the same think would not happen in rust.</font><br>
<p>
I&#x27;m not saying it could not happen, I&#x27;m saying that most of the benefits that are expressed in favor of Rust regularly end up as &quot;we could indeed avoid doing this in the kernel&quot;. In the end what&#x27;s the real benefit if 50% of the code runs under &quot;unsafe&quot;, unwinding is not used because we want clean error handling, automatic allocations are not possible, etc ? I&#x27;m *not* saying it&#x27;s a bad language, I personally find it particularly complex to learn and do see the claimed benefits as inconvenients. It&#x27;s just that I find that a number of the fantastic benefits to expect from such a migration will very likely not be met in the end and that the only result is that we&#x27;ll have even more complexity and less maintainable code.<br>
<p>
<font class="QuotedText">&gt; I also remeber reading an article here on LWN about how a lot of the error path are broken. Maybe because having to write both an error handling code + a resource management code is more prone to failure...</font><br>
<p>
But don&#x27;t you find it shocking as a developer to decide allocate resources if you&#x27;re not certain you&#x27;ll be able to release them ? I mean, I&#x27;m not saying it&#x27;s trivial, I&#x27;m saying it has to be expected to deal with abnormal conditions. Writing code takes time. For sure if your boss asks to cut the development time in half it&#x27;s possible by getting rid of error handling. But that&#x27;s generally not the approach that goes into the kernel.<br>
<p>
Last, error handling in low-level code may require very special conditions that a compiler will not magically guess. For example when failing to allocate some memory, you generally don&#x27;t want to lazily fail. You want to look around, try to flush some buffers etc before retrying. You may even prefer to postpone processing and wait until the expected resources are available. It may also be possible that some of the half-initialized stuff cannot be restored by just undoing the init code. You may have to respect a certain sequence. For example the zlib always performs exactly 5 calls to its allocator, whether they&#x27;re successful or not. This way you can implement your own using pools of fixed sizes. In case of allocation failure you must not at all change anything in this sequence and you want it to continue to allocate till the end of the sequence because otherwise you will desynchronize the allocator by freeing in the middle of a sequence.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 16:32 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854243/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In the end what&#x27;s the real benefit if 50% of the code runs under &quot;unsafe&quot;</font><br>
<p>
While the amount is non-zero, I&#x27;d be surprised if it was that high. Actual experiments will be needed to not have us just be slinging gut-check numbers around.<br>
<p>
<font class="QuotedText">&gt; unwinding is not used because we want clean error handling</font><br>
<p>
Unwinding is always used (because RAII). But since error handling is *explicit* in Rust, each call site can decide whether &quot;this can go up -&gt; use `?`&quot; to &quot;this is complicated -&gt; match and handle&quot;. You&#x27;ll never need to worry about an uncaught exception ripping through your stack frame in Rust (well, panics, but that is analogous to BUG_ON() and undefined behavior on the C side). Either you can *see* the handoff of the error or you can *see* the explicit error handling. Which is more useful where is subject to review, as is any other use of &quot;fancy&quot; language constructs.<br>
<p>
<font class="QuotedText">&gt; automatic allocations are not possible</font><br>
<p>
Sure, the stdlib has bits that aren&#x27;t useful in the kernel. I don&#x27;t think anyone would be surprised about that. Same thing with C++: std::string is basically unusable in the kernel too due to its reallocation behaviors.<br>
<p>
<font class="QuotedText">&gt; error handling in low-level code may require very special conditions that a compiler will not magically guess. For example when failing to allocate some memory, you generally don&#x27;t want to lazily fail.</font><br>
<p>
In this code, yes, handle the error explicitly. If you&#x27;re in a driver? it&#x27;s not usually your problem at that layer and you can hand it off to the parent (with annotations if suitable). Maybe your driver *is* important to the memory allocation pipeline though. Then you handle it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 17:35 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/854258/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In the end what&#x27;s the real benefit if 50% of the code runs under &quot;unsafe&quot;, </font><br>
<p>
Well, if you translate C to Rust, and have to put 50% of it it inside &quot;unsafe{}&quot; blocks to get it to compile, it&#x27;s a big improvement on the C where it&#x27;s 100% unsafe.<br>
<p>
And as others have pointed out. most of that unsafe code will consist of &quot;unsafe{ call C function }&quot;. Which again is an improvement on the 100% unsafe C code. I think it&#x27;s a pretty safe bet that 99% of the *Rust* code will not be unsafe{} blocks. So migrating to Rust will get rid of loads of bugs, as all the unsafe blocks are reviewed and made safe.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor854194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 13:23 UTC (Fri)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/854194/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I know it probably means nothing to a number of people who will find me obsessed with reliability and trustable control, but the day your father&#x27;s pacemaker spends its time rebooting because its battery&#x27;s voltage reads too low a value due to environmental conditions instead of just slowing down the valve to preserve resources, you may think again about this &quot;propagate error&quot; vs &quot;deal with the error right here&quot; discussion. And once code starts to be written with exceptions instead of error handling, it&#x27;s impossible to fix it.</font><br>
<p>
There is absolutely NOTHING in &quot;do it explicitly with ifs and gotos&quot; that would prevent the pacemaker from keep rebooting. I would even argue that if the dev put his &quot;if less than zero, goto unwind&quot; blindly (as some of us are wont to do, just being human and all) your bug is even HARDER to find. Ah, and there is a &quot;slippery slope&quot; fallacy at the end of your argument.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 13:57 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      One idiom that is popular in Rust (and I use myself) is to have a specific error type for a given class or group of operations. This way, if an error comes through, it must be transformed into the set of errors that the operations declare. If there is an easy automatic transformation available, that can happen still and is wrapped up with evidence of the cause. This can include "something happened with a path" and the error representation requires that the path be injected into the error type as well. You can't forget to add it because it's a compile error to do so. So yes, the example given is not idiomatic Rust. I would instead have something like:

<pre>
enum OpErr {
  InvalidFlag { mask: u32 },
  ConflictingFlags { /* something to tell about conflicting flags */ },
  RequiredDriverNotLoaded,
}

impl OpErr {
  fn as_errno(&amp;self) -&gt; Errno {
    match self {
      Self::InvalidFlag { .. } =&gt; Errno::EINVAL,
      Self::ConflictingFlags { .. } =&gt; Errno::EINVAL,
      Self::RequiredDriverNotLoaded =&gt; Errno::ENOTSUP,
    }
  }
}
</pre>

This way the caller can have code that reads well ("oh, invalid flag, let's make a better error message because we got that from our caller") versus the oh-so-useful "invalid value" and you need to guess which one it means today.
      
          <div class="CommentReplyButton">
            <form action="/Articles/854198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor853839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 1:01 UTC (Thu)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/853839/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://en.cppreference.com/w/cpp/freestanding">https://en.cppreference.com/w/cpp/freestanding</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor853696"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 9:30 UTC (Wed)
                               by <b>fenncruz</b> (subscriber, #81417)
                              [<a href="/Articles/853696/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; /dev/zero replacement</font><br>
<p>
I am not a kernel developer but is there alot going on behind-the-scenes for something that only needs to return null and thus would benefit from being in rust? Or was this suggested as it is something very simple and could be used as a demonstration of rust&#x27;s abilities?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853696/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor855044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2021 14:31 UTC (Fri)
                               by <b>alexander.batischev</b> (guest, #122369)
                              [<a href="/Articles/855044/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I'm not a "real" kernel developer either, but from what I understand, <code>/dev/zero</code> was mentioned because it's simple yet touches a few subsystems. If you look at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/mem.c?h=v5.12&id=9f4ad9e425a1d3b6a34617b8ea226d56a119a717#n719">the function that serves a <code>read()</code></a>, you'll find that it uses:

<ul>
<li>data structures associated with character devices (for which there are Rust wrappers already, since the RFC contains an example of a chardev implementing a semaphore);</li>
<li>a <code>min_t</code> macro that'll have to be re-written in Rust;</li>
<li>a <code>clear_user</code> call which is implemented differently on each architecture, so bindings are needed. This is also an opportunity to introduce some safety, e.g. checking that the pointer is a userspace pointer (C code seem to have this already, since it annotates the pointer with <code>__user</code>);</li>
<li>calls to <code>signal_pending</code> and <code>cond_resched</code> functions which are part of the scheduler — again requiring more bindings.</li>
</ul>

I wrote a couple simple kernel drivers (proprietary, so any real kernel developer will rightfully call me a leech), and I can attest that chardev stuff and some access to the scheduler are the pretty common things to use; they come in handy in many simpler drivers. Adding Rust wrappers for those facilities will simultaneously demonstrate how wrappers look, and pave a path for many, many simple-yet-useful drivers to be written in Rust.
      
          <div class="CommentReplyButton">
            <form action="/Articles/855044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor855047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2021 15:14 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/855047/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; a min_t macro that&#x27;ll have to be re-written in Rust;</font><br>
<p>
Is there a reason that Rust&#x27;s built-in `min` function wouldn&#x27;t be sufficient?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/855047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor855048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2021 15:35 UTC (Fri)
                               by <b>alexander.batischev</b> (guest, #122369)
                              [<a href="/Articles/855048/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <code>min</code> in Rust requires arguments of the same type, so it can only replace <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/minmax.h?h=v5.12&id=9f4ad9e425a1d3b6a34617b8ea226d56a119a717#n51">the <code>min</code> macro</a>. The <code>min_t</code> macro <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/minmax.h?h=v5.12&id=9f4ad9e425a1d3b6a34617b8ea226d56a119a717#n110">casts its arguments to the given type</a>, so Rust will need a similar macro as well.
      
          <div class="CommentReplyButton">
            <form action="/Articles/855048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor853711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 12:54 UTC (Wed)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/853711/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would make a lot of sense to do this the way ALSA replaced OSS - port a few drivers at a time, but leave the originals there for the 15 years or so grace period that got...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 16:17 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/853768/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  It would make a lot of sense to do this the way ALSA replaced OSS - port a few drivers at a time, but leave the originals there for the 15 years or so grace period that got...</font><br>
<p>
Indeed, and this also leaves the benefit that in 15 years, after the language has been completely abandonned due to becoming too tricky to use with all the necessary tricks added to make it suitable for the task, the original code will still be there to serve as a reference to be reimplemented in the new $language_of_the_year.<br>
<p>
All languages are good... until you try to expand them to areas they were not initially designed for. Design a language to write a browser, it will probably shine there. If you want to write operating systems, use a language designed for this, not the one designed to write browsers. It just happens C was designed for this purpose and it should not be a surprise that it still rules in this area 50 years later despite its numerous shortcomings.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 17:57 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/853778/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust isn&#x27;t &quot;designed to write browsers&quot;. Rust is designed to be a general-purpose systems language for everything from kernels/firmware/embedded to browsers to WebAssembly. There is, by design, no &quot;gap&quot; between assembly and Rust.<br>
<p>
In any case, one of the critical values of the Linux kernel is that it evolves over time. If Rust continues to fit well as a powerful safe language for systems programming, as I and many others hope it will, it&#x27;ll make sense to have increasing parts of the kernel written in it. If some other language replaced Rust and became seen as a preferable language for writing systems code like the Linux kernel in, it would be because that language came up with a way to solve kernel problems substantially better than Rust.<br>
<p>
Only time will tell what actually happens. But I don&#x27;t think &quot;another language might hypothetically come along in the future that&#x27;s even better&quot; is a good argument against adopting a language that&#x27;s a substantial improvement over the current state, assuming people agree that it&#x27;s a substantial improvement.<br>
<p>
I also don&#x27;t think there&#x27;s value in maintaining parallel versions of the same code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 19:07 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/853789/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Only time will tell what actually happens.</font><br>
<p>
I agree on this.<br>
<p>
<font class="QuotedText">&gt; But I don&#x27;t think &quot;another language might hypothetically come along in the future that&#x27;s even better&quot; is a good argument against adopting a language that&#x27;s a substantial improvement over the current state, assuming people agree that it&#x27;s a substantial improvement.</font><br>
<p>
That&#x27;s not my point. My point is I suspect that a few years from now it will have changed so much to adapt to the real needs that it will be abandonned (except by a few fanboys) and will end up like plenty of previous languages that lasted only a decade.<br>
<p>
<font class="QuotedText">&gt; I also don&#x27;t think there&#x27;s value in maintaining parallel versions of the same code.</font><br>
<p>
If that&#x27;s the only way to keep people who understand some code parts that could end up being abandoned, there definitely is some value. If it takes a decade to reach the same level of stability or performance as the original ones, it makes sense. If the required toolchains end up being a total mess to deploy in field, it makes sense as well. The new IDE driver probably took a decade to replace the old one and there&#x27;s nothing wrong with this. As you said, time will tell.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 22:07 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/853799/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; My point is I suspect that a few years from now it will have changed so much to adapt to the real needs that it will be abandonned (except by a few fanboys)</font><br>
<p>
That&#x27;s certainly a viewpoint one could hold. I can understand where that assumption would come from, given that there have been a large number of languages that thought they could replace C, many of which don&#x27;t exist anymore. I think Rust specifically fits in a way all of those languages didn&#x27;t, but rather than try to argue the case for that here, I&#x27;ll stick with &quot;time will tell&quot;, and continue working to make sure the language adapts to the needs of various real users, including kernel developers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 23:18 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/853821/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust 1.0 came out nearly six years ago so we&#x27;re only four years away from a decade. It seems implausible to me that Rust adoption is going to turn from &quot;rapidly increasing&quot; to &quot;abandoned&quot; in the next four years.<br>
<p>
<font class="QuotedText">&gt; becoming too tricky to use with all the necessary tricks added to make it suitable for the task</font><br>
<p>
I wonder what you have in mind here. I can&#x27;t think of any examples of this over the last several years. In fact Rust has become less tricky to use, for example supporting non-lexical lifetimes. Rust community commitment to backwards compatibility is high so even if some new features (const generics, generic associated types?) make the language more complex, you don&#x27;t have to use them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 2:54 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/853856/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; becoming too tricky to use with all the necessary tricks added to make it suitable for the task</font><br>
<p>
<font class="QuotedText">&gt; I wonder what you have in mind here. I can&#x27;t think of any examples of this over the last several years. </font><br>
<p>
I mean that gcc and even C evolved when facing the reality of the linux kernel. When 1 out of 10 lines was in fact an inline function calling an asm statement it shows there were some limitations. I don&#x27;t see how Rust will avoid this. There will be tons of &quot;unsafe&quot; blocks everywhere making the code very hard to read and preventing the compiler from holding its promises, and I suspect some new constructs will have to be invented to improve this situation, and that the language will be less appealing to newcomers.<br>
<p>
Quite frankly, look at Linux&#x27;s C code. There area tons of READ_ONCE(), likely(), atomic_inc(), smp_rmb(), readb(), iowrite{8,16,32}(), div64_* etc everywhere that rely on asm and need to be applied not directly because of the language but because of the underlying hardware constraints, that make C code less easy to write. I don&#x27;t see why it wouldn&#x27;t be the case in another language since it&#x27;s not a matter of expressing code, but a matter of semantics. What Rust proponents complain about in C will quickly arrive in their language.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 3:55 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/853863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Quite frankly, look at Linux&#x27;s C code. There area tons of READ_ONCE(), likely(), atomic_inc(), smp_rmb(), readb(), iowrite{8,16,32}(), div64_* etc everywhere that rely on asm and need to be applied not directly because of the language but because of the underlying hardware constraints, that make C code less easy to write.</font><br>
<p>
And if Rust forces programmers to step back, and think about their code, and NOT FORGET all of this stuff, then that makes it the better language.<br>
<p>
And how much of that stuff, also, is not there because C can&#x27;t do it natively, but because given the chance the C optimiser will screw things up? How much of that stuff is there to get round undefined or implementation-defined behaviour?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 11:53 UTC (Thu)
                               by <b>moltonel</b> (guest, #45207)
                              [<a href="/Articles/853914/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fact that kernel Rust will probably also need to handle similar READ_ONCE complications as kernel C doesn&#x27;t make Rust less appealing. Rust will retain its borrow checker, sum types, safe/unsafe split, and other features that make it desirable. It already handles some very low-level hardware weirdness, and it&#x27;s well equipped to accommodate whatever weirdness the kernel needs without turning the language into an unrecognizable mess.<br>
<p>
It seems likely that initial kernel Rust code will have more &#x27;unsafe&#x27; and less convenience than we can hope for 10 years down the line. If 10% of kernel &quot;C functions&quot; were initially asm, we can expect similar growing pains with Rust. So what ? Nobody is claiming that enabling Rust in the kernel will enable all Rust developers to become kernel developers. The main goal of Rust in the kernel is to make the kernel code better, not to attract Rust fans and newcomers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 20:11 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854039/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Nobody is claiming that enabling Rust in the kernel will enable all Rust developers to become kernel developers.</font><br>
<p>
Sorry but this is exactly how I understood it: make it easier to write drivers (implicit &quot;for rust developers&quot; as not everyone is fluent in it and even those used to it say the learning curve is pretty steep).<br>
<p>
<font class="QuotedText">&gt; The main goal of Rust in the kernel is to make the kernel code better, not to attract Rust fans and newcomers.</font><br>
<p>
Better in terms of what ? Maintainability, with only 1% of kernel developers being able to review and fix that code instead of the previous 100% ? Ease of use, with everyone having to install two separate toolchains, some combinations of which will possibly cause trouble that will have to be detected and rejected ? Portability, with a number of existing architectures not even being implemented by the language ? Fame and ego for rust fanboys for having won a victory over Linux, maybe.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 20:36 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/854041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You seem to be going out of your way to find the *least charitable interpretation possible* for everything. &quot;fame and ego&quot;, really?<br>
<p>
We wouldn&#x27;t be working to enable Rust in the kernel if we didn&#x27;t think it was an improvement *for the kernel*. The goal is to provide safety and productivity improvements. If you believe that Rust isn&#x27;t actually achieving those goals, or that it does but that there are other factors outweighing that, by all means you&#x27;re welcome to make the case for that.<br>
<p>
Half your arguments would apply to *any* non-C language, no matter how much of an improvement it would otherwise be. Those arguments would effectively say that the kernel can never consider anything but C, and that &quot;it isn&#x27;t C&quot; is a factor outweighing other considerations in any language evaluation.<br>
<p>
Yes, a new toolchain and a new language has a baseline cost; the only reason Rust is being seriously considered is because *despite* that cost many people still think it&#x27;d be an improvement. I have confidence that kernel developers are quite *capable* of using something new, if it&#x27;s deemed worthwhile. That evaluation, of whether it&#x27;s actually worthwhile, will be an ongoing process. I&#x27;m certain that one of many factors in that evaluation will be &quot;is this not just better, but substantially better, to the point that it&#x27;s worth the expectation that kernel developers will have to deal with it in the kernel tree&quot;. That&#x27;s a very reasonable question, and it&#x27;s not one with a pre-determined answer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor854047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 20:38 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/854047/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Maintainability, with only 1% of kernel developers being able to review and fix that code instead of the previous 100% ?</font><br>
<p>
Please don&#x27;t just make up numbers. I wouldn&#x27;t trust 100% of kernel developers reviewing sched, mm, rcu, or arch code because those domains are way more specific than just &quot;it&#x27;s C code, I&#x27;m a C programmer, I&#x27;ll be fine&quot;. If maintainers of a domain don&#x27;t want to learn Rust, then don&#x27;t let it into your corner. Right now, it appears as though it will just be for device drivers. Over time, sure, maybe it&#x27;ll do more. I don&#x27;t forsee the wisdom of subsystem maintainers to all of a sudden being untrustworthy if introducing Rust into a corner is not actually ready (no different than any other patch that shows up).<br>
<p>
<font class="QuotedText">&gt; Portability, with a number of existing architectures not even being implemented by the language ?</font><br>
<p>
The language supports it. The prevailing toolchain doesn&#x27;t support every arch. There are those working on getting GCC to compile Rust which should resolve this issue.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 22:23 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/854071/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There are those working on getting GCC to compile Rust which should resolve this issue.</font><br>
<p>
There&#x27;s also a project to use GCC as the code-generation backend for the existing frontend (which will avoid code duplication and divergence), as well as efforts to add LLVM backends for more architectures that people care about (there&#x27;s now an m68k backend, so props to the m68k people for putting forth that effort).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 1:18 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/854100/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Maintainability, with only 1% of kernel developers being able to review and fix that code instead of the previous 100% ?</font><br>
<p>
If you think 99% of kernel developers will be unable or uninterested in learning Rust then you have dimmer view of kernel devs than I do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor853960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 13:55 UTC (Thu)
                               by <b>mss</b> (subscriber, #138799)
                              [<a href="/Articles/853960/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What Rust proponents complain about in C will quickly arrive in their language.</font><br>
<p>
Full agreement on that.<br>
It looks like even basic Rust standard library can&#x27;t be reasonably implemented without a lot of &quot;unsafe&quot; blocks.<br>
<p>
Which resulted in a hilarious number of recent memory-corruption CVEs for a language that has memory safety as its biggest selling point:<br>
<font class="QuotedText">&gt; CVE-2020-36317:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.49.0, String::retain() function has a panic safety problem. It allows creation of a non-UTF-8 Rust string when the provided closure panics. This bug could result in a memory safety violation when other string APIs assume that UTF-8 encoding is used on the same string.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; CVE-2021-36318:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.49.0, VecDeque::make_contiguous has a bug that pops the same element more than once under certain condition. This bug could result in a use-after-free or double free.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; CVE-2021-28875:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.50.0, read_to_end() does not validate the return value from Read in an unsafe context. This bug could lead to a buffer overflow.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; CVE-2021-28877:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.51.0, the Zip implementation calls __iterator_get_unchecked() for the same index more than once when nested. This bug can lead to a memory safety violation due to an unmet safety requirement for the TrustedRandomAccess trait.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; CVE-2021-28876:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.52.0, the Zip implementation has a panic safety issue. It calls __iterator_get_unchecked() more than once for the same index when the underlying iterator panics (in certain conditions). This bug could lead to a memory safety violation due to an unmet safety requirement for the TrustedRandomAccess trait.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; CVE-2021-28878:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.52.0, the Zip implementation calls __iterator_get_unchecked() more than once for the same index (under certain conditions) when next_back() and next() are used together. This bug could lead to a memory safety violation due to an unmet safety requirement for the TrustedRandomAccess trait.</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; CVE-2021-28879:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.52.0, the Zip implementation can report an incorrect size due to an integer overflow. This bug can lead to a buffer overflow when a consumed Zip iterator is used again.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; CVE-2021-31162:</font><br>
<font class="QuotedText">&gt; In the standard library in Rust before 1.53.0, a double free can occur in the Vec::from_iter function if freeing the element panics.</font><br>
<p>
For extra fun try to find mentions of them in the Rust release notes page:<br>
<a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md">https://github.com/rust-lang/rust/blob/master/RELEASES.md</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 16:22 UTC (Thu)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/854005/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It looks like even basic Rust standard library can&#x27;t be reasonably implemented without a lot of &quot;unsafe&quot; blocks.</font><br>
<p>
That&#x27;s to be expected though. The standard library provides the abstractions so that the programs using them don&#x27;t need any unsafe blocks. This works quite well in practice.<br>
<p>
I would expect the kernel implementation to be the same. There would be a core that provides the abstractions (containing many unsafe blocks) and the drivers using these abstractions would be without any unsafe blocks. That would be ideal, the question is how close they can get to this goal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 20:06 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/854038/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So that&#x27;s great, instead of having 5% of the drivers which are vulnerable to certain bugs, we&#x27;d have 100% of the rust ones because the libs themselves will not be safer than the example above and will not be audited by those who area used to deal with operating system issues.<br>
<p>
It could very well be that Linux is the last project adopting rust in the end... That&#x27;s a dangerous move for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor856381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2021 9:06 UTC (Mon)
                               by <b>tao</b> (subscriber, #17563)
                              [<a href="/Articles/856381/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So in essence you&#x27;re arguing that it&#x27;d better to have every C driver implement their own versions of kmalloc, printk, etc. because that&#x27;d only make 5% of the drivers vulnerable to certain bugs instead of 100% of them if those functions were to have issues?<br>
<p>
To answer your question, yes, it&#x27;s a lot better to have 100% of the Rust drivers vulnerable because they all use the same function if that means that  100% of the drivers are simultaneously fixed when an issue is remedied in the common library, rather than having each driver have its own implementation.<br>
<p>
I know there are people who think static linking and bundling is a good idea, but I certainly don&#x27;t belong to that  camp.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/856381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor854101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 1:25 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/854101/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Rust community issues a CVE whenever they find that an API not marked &quot;unsafe&quot; can be (ab)used to do something unsafe. In practice, though, you usually have to write very specific code to trigger than unsafe behavior. It hardly ever affects the behavior of real programs. In 5 years of full-time work on Rust code I can think of only one or two cases where such a CVE actually affected our program.<br>
<p>
This is a much higher bar than C even attempts to reach. The answer to &quot;which C library APIs can be used to do something unsafe if I write malicious code that uses them?&quot; is &quot;pretty much all of them&quot;. It&#x27;s hardly even a well-formed question.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor854098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 1:16 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/854098/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There area tons of READ_ONCE(), likely(), atomic_inc(), smp_rmb(), readb(), iowrite{8,16,32}(), div64_* etc everywhere that rely on asm and need to be applied not directly because of the language but because of the underlying hardware constraints,</font><br>
<p>
These are either already available in Rust or can mostly be added as library APIs. No real increase in language complexity or difficulty of writing Rust code.<br>
<p>
<font class="QuotedText">&gt; What Rust proponents complain about in C will quickly arrive in their language.</font><br>
<p>
The existence of these features is not what &quot;Rust proponents complain about in C&quot;.<br>
<p>
But atomics and memory-mapped I/O do provide good examples of the deficiencies of C. Rust defines specific types for atomic variables (e.g. AtomicU32) and you *cannot* read or write them with non-atomic operations (without explicitly writing &quot;unsafe&quot;). That eliminates the class of &quot;forgot to use an atomic operation&quot; bugs. Something very similar can be done for memory-mapped I/O registers (and I assume has been for embedded Rust already).<br>
<p>
Unfortunately C doesn&#x27;t provide these guarantees.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 8:31 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/854137/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Suitable tricks for MMIO have indeed been implemented by the <a href="https://docs.rust-embedded.org/book/peripherals/index.html">Rust Embedded people</a> - these tricks exploit the borrow checker to confirm invariants are met. For peripherals with access requirements (e.g. GPIOs, where output drive level is nonsense in input mode), there's also a <a href="https://docs.rust-embedded.org/book/static-guarantees/index.html">common state machine pattern</a> in Rust. <a href="https://github.com/rust-embedded/awesome-embedded-rust#readme">There's a collection of interesting crates to look at</a> if you want to see what embedded Rust people have done to maximise the benefit from using Rust.
<p>And note that with <tt>unsafe</tt> you can still write code that has as few guarantees as C - it's just that Rust style encourages you to use a compile-time abstraction (no runtime cost) that turns access mistakes into compile failures.
      
          <div class="CommentReplyButton">
            <form action="/Articles/854137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor853805"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 22:44 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/853805/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; All languages are good... until you try to expand them to areas they were not initially designed for</font><br>
<p>
C is no exception here. It was designed to write operating systems and it is still usable to write operating systems.<br>
<p>
But even though C has evolved in these 40 years, so have operating systems, and I have serious doubts that C is still the best tool for an entire OS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853805/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853874"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 6:30 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/853874/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; C is no exception here. It was designed to write operating systems and it is still usable to write operating systems.</font><br>
<p>
C was designed to write operating systems, but on architectures where pointers are weird (e.g. segmented), you don&#x27;t know how negative numbers are represented (e.g. one&#x27;s complement), and you can&#x27;t even assume that bytes have 8 bits.<br>
<p>
For some godforsaken reason, the C standards committee slapped &quot;it&#x27;s not a bug, it&#x27;s a feature!&quot; labels on all of those things, and now we can&#x27;t take them away or else the optimizer will get 2% worse.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853874/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 8:28 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/853888/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s much more than 2%. Sure you can write your code in such a way that the optimizer doesn&#x27;t need it, but there are very low-level optimizations such as addressing mode selection that *rely* on some kinds of undefined behavior.<br>
<p>
Others are completely asinine, such as undefined behavior on left-shift overflow (which includes left-shift of negative numbers, of course).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2021 16:57 UTC (Sun)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/854400/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
It's much more than 2%.
</blockquote>

As usual, without any empirical data to back it up.

<p>Wang et al (2012) actually have measured the "benefit" of assuming that undefined behaviour does not happen, on SPECint, resulting in SPECint score improvements of 1.1% for GCC and 1.7% for Clang.  The same benefit could be gotten by changing the source code in two places in the whole benchmark suite.

<p>[Wang et al 2012] Xi Wang, Haogang Chen, Alvin Cheung, Zhihao Jia, Nickolai Zeldovich, and M. Frans Kaashoek. Undefined behavior: What happened to my code?
In Asia-Pacific Workshop on Systems (APSYS'12), 2012.

      
          <div class="CommentReplyButton">
            <form action="/Articles/854400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor853908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 10:33 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/853908/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Technically pre-89 C can support even ternary arithmetic. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 23:37 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/854081/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To the best of my understanding, pre-89 C is a euphemism for &quot;We read the K&amp;R book and hacked a compiler together without following a formal standard of any kind.&quot; I&#x27;m not aware of anybody using it other than the NetHack dev team,[1] although I would not be surprised if it was also in use by various financial institutions and/or IBM, because the use of software created after 1985 or thereabouts would appear to violate their religious beliefs.<br>
<p>
[1]: <a href="https://nethack.org/devel/deprecation.html#361">https://nethack.org/devel/deprecation.html#361</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor853783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 18:25 UTC (Wed)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/853783/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wuffs [1] is more appropriate for the kernel. It is much safer than Rust. For example, compiler ensures that there is no integer overflow or out-of-bounds array access. This is in addition to ensuring that pointer manipulations are safe. Plus it compiles to plain C so there is no issue with unsupported architecture.<br>
<p>
[1] <a href="https://github.com/google/wuffs">https://github.com/google/wuffs</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 18:59 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/853787/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I dare say it would be, if it was production-ready.<br>
<p>
When the latest version tag in the git tree is v0.3.0-beta.1, I feel it&#x27;s safe to presume that the people responsible for developing it don&#x27;t think it&#x27;s production-ready.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 23:07 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/853817/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think so.<br>
<p>
<font class="QuotedText">&gt; Wuffs programs take longer for a programmer to write, as they have to explicitly annotate their programs with proofs of safety.</font><br>
<p>
<font class="QuotedText">&gt; The idea isn&#x27;t to write your whole program in Wuffs, only the parts that are both performance-conscious and security-conscious.</font><br>
<p>
A lot of driver code is boring. That code needs to be easy to write. In Rust it can be easy, in Wuffs not so easy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2021 23:09 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/853819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also<br>
<p>
<font class="QuotedText">&gt; No way to dynamically allocate or free memory.</font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor853913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 11:00 UTC (Thu)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/853913/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Still with Rust one gets panics on out-of-band access plus there is no check for overflow in release builds. Which suggest that maybe for drivers the whole code should be sandboxed using Wasm or similar. Then one can continue to write borring code in C or Rust with all bugs contained.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2021 16:31 UTC (Thu)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/854006/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The overflow and other debug checks can be enabled in Rust release builds if you want it.<br>
<p>
As I understand it the Rust panic will be wired into a kernel BUG call. Which is what it ought to be. If the code somehow avoids the explicit range checks and still executes an array[out_of_bounds] operation then that really is a BUG, unlike a memory allocation failure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor854103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wuffs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2021 3:01 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/854103/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wuffs will cheerfully provide you with C, and presumably in the future if you wanted it could be altered to provide Rust although in most cases I can&#x27;t see why you&#x27;d care since if you&#x27;re just compiling it then C is easier, and if you _alter_ the code then the guarantees from Wuffs expire.<br>
<p>
But Wuffs is a special purpose language whereas Rust isn&#x27;t. For example when you ask Cargo for a new Rust program, the one you get says &quot;Hello, World!&quot;. But Wuffs can&#x27;t do that. Because that would involve I/O and Wuffs deliberately doesn&#x27;t have I/O at all, it considers that to be orthogonal to its concerns entirely.<br>
<p>
It is good for these special purpose languages to exist, particularly when they address some difficult and interesting problem such as &quot;Wrangling Untrusted File Formats Safely&quot;. I should like to do this sometimes, and apparently Wuffs would help. But if my current problem is that my USB Foozle doesn&#x27;t work, an &quot;untrusted file format&quot; is only at best a tiny fraction of my problem and Wuffs isn&#x27;t interested in helping me with the rest of it. Whereas perhaps I can write a driver for the USB Foozle in Rust.<br>
<p>
Today I can write a _userspace_ USB driver in Rust. Maybe my Foozle can be driven that way. If Linux Rust becomes a thing then that opens up the possibility of writing a kernel USB driver in Rust which is viable even for higher performance gizmos and is also desirable if a Foozle is important/ low-level enough that people don&#x27;t really want to wait until the userspace spins up to have it working.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor855147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust heads into the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2021 9:32 UTC (Mon)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/855147/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;The more you make it look like (Kernel) C, the easier it is for us C people to actually read. My eyes have been reading C for almost 30 years by now, they have a lexer built in the optical nerve; reading something that looks vaguely like C but is definitely not C is an utterly painful experience.</font><br>
<p>
One point thusfar unmade is that the Linux Kernel Style is outdated whether compared to Rust or not. This is to be expected of a thirty year old code base started when ANSI C was still a tad moist behind the ears. Since then there have been two significant standard revisions, both introducing various syntax and library updates of which the kernel style has been slow to adopt the former and generally ignores the latter[0].<br>
<p>
It&#x27;s not reasonable to expect a hojillion-SLOC program to undergo style churn to any degree, and matters like whether switch-cases should be indented or not shall remain a matter of taste forevermore. However, the kernel style (henceforth LKS) has several issues that, mostly consequent to influence of other languages, appear silly today: for example, LKS bars oneliners of the form &quot;if((asdf, sdfg &lt; 666) || (qwer &amp;&amp; hjkl)) return PTR_ERR(EWOULDHORK);&quot;, instead preferring not even the Perl convention of extra curlies, but placing the return after the if and indenting it one level. Whether this is related to early-onset ergonomy trouble of the right thumb is anyone&#x27;s guess.<br>
<p>
Another example is LKS&#x27; propensity for spending vertical space willy-nilly instead of as a means to visually separate subprograms into a tripartite acquire-operate-release[1] form (or for telling apart subsections thereof), perhaps dating back from when text consoles had one or two fonts and no options for vertical spacing so programmers would compensate by adding spaces and linebreaks to improve superficial comprehensibility[2].<br>
<p>
Moreover some syntax updates introduced in C99 have gone by the wayside; even today there&#x27;s code being submitted that introduces variables at start-of-block when inline has been common preference for some 2/3rds of Linux being around, and (to my knowledge anyway) GCC 2.95 hasn&#x27;t been a supported compiler for a dog&#x27;s age. You&#x27;d also be hard pressed to find any use of struct literals or ephemeral dummies even as they improve both security and legibility by leaving no fields uninitialized as struct/union definitions grow and disallowing typo-based coding mistakes (i.e. the ones that bleary-eyed review misses) when the same pointer is dereferenced a bunch of times in sequence.<br>
<p>
So whether Rust[3] is adopted or not, I for one hope the experiment at least leads to some revision in the Linux Kernel Style.<br>
<p>
As for language extensions, that way lies the day when someone suggests adding an introspectable type system and deprecating implicit downcasts from void-pointers (we&#x27;ve all been down there, I hope) so that &quot;C&lt;&gt;&quot; can have Safe Iterators; and at that point you might as well follow the Ada rabbithole and start writing formal design proposals and other top-down necktie junk. That one proposal about scoped mutex unlocks is already incredibly horrible simply because tying mutex unlocks to scope exit is the smell of a function with another, smaller function in it, waiting to burst forth all over your breakfast spaghetti.<br>
<p>
(Also, the LKS block comment style sucks basketballs wrapped in barbed wire through a garden hose, then pleads for seconds in the ECHR. You&#x27;d have to be coming off Borland&#x27;s Turbo Space Crack to think it&#x27;s a good idea even in 1992.)<br>
<p>
[0] i.e. &lt;stdint.h&gt; types are ignored in favour of u8, u16, etc.; &lt;threads.h&gt; and &lt;stdatomic.h&gt; are right out; and who&#x27;s even heard about &lt;stdnoreturn.h&gt;?<br>
[1] read-compute-write, plan-setup-test-cleanup, disable-access-enable, etc.<br>
[2] which is quite important for recognizing patterns at a glance, and telling whether something unusual is going on that ought to have a closer look right away<br>
[3] or a future xon-of-Rust, or Ada, or ATS, or whatever floats your boaty mcboatface<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/855147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
