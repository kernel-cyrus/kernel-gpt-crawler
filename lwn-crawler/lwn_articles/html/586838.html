        <!DOCTYPE html>
        <html lang="en">
        <head><title>C11 atomic variables and the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/586838/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/586022/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/586838/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>C11 atomic variables and the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 18, 2014</br>
           </div>
The C11 standard added a number of new features for the C and C++
languages.  One of those features — built-in atomic types — seems like it
would naturally be of interest to the kernel development community; for the
first time, the language standard tries to address concurrent access to
data on contemporary hardware.
But, as recent discussions show, it may be a while before C11 atomics are
ready for use with the kernel — if they ever are — and the kernel community
may not feel any great need to switch.
<p>
The kernel provides a small set of atomic types now, along with a set of
operations to manipulate those types.  Kernel atomics are a useful way of
dealing with simple quantities in an atomic manner without the need for
explicit locking in the code.  C11 atomics should be useful for the
implementation of the kernel's atomic types, but their scope goes beyond
that application.  
<p>
In particular, each access to a C11 atomic variable has an explicit
"memory model" associated with it.  Memory models describe how accesses
to memory can be optimized by the processor or the compiler; the more
relaxed models can allow operations to be reordered or combined for
improved performance.  The default model ("sequentially consistent") is the
strictest; it does not allow any combining or reordering of operations in
any way that would be visible anywhere else in the program.  The problem
with this model is that it is quite expensive, and, most of the time, that
expense does not need to be incurred for correct operation.  The more
relaxed models exist to allow for optimizations to be performed in a
controlled manner while ensuring correct ordering when needed.
<p>
Thus, C11 atomic variables include features that, in the kernel, are
usually implemented with memory barriers.  So, for example, in current
kernel code, one could see something like:
<p>
<pre>
    smp_store_release(&amp;x, new_value);
</pre>
<p>
The <tt>smp_store_release()</tt> barrier (described in more detail in <a
href="/Articles/576486/">this article</a>) tells the processor to ensure
that any reads or writes executed before this assignment are visible on all
processors
before the assignment to <tt>x</tt> becomes visible.  Reordering of operations
that all occur before this barrier is still possible, as is the reordering
of operations that all occur afterward.  

In most code, quite a bit of reordering can take place without affecting
the correctness of the result.  The use of explicit barriers in places
where ordering <i>does</i> matter enables most accesses to be performed
without barriers, enabling optimization and improving performance
significantly. 
<p>
If, instead,
<tt>x</tt> were a C11 atomic type, one might write:
<p>
<pre>
    atomic_store(&amp;x, new_value, memory_order_release);
</pre>
<p>
Where <tt>memory_order_release</tt> specifies the same ordering
requirements as <tt>smp_store_release()</tt>.  (See <a
href="http://en.cppreference.com/w/cpp/atomic/memory_order">this page</a>
for a description of the C11 memory models).
<p>
If the <tt>memory_order_relaxed</tt>
model (which imposes no ordering requirements on the access) is used for
surrounding accesses to other atomic variables where 
ordering is not important, the end result
should be similar to that achieved with <tt>smp_store_release()</tt>.  
But the former version is implemented with tricky, architecture-specific code
within the kernel; the latter version, instead, causes the desired code to
be emitted directly by the compiler.

<p>
When the kernel first gained support for multiprocessor systems, the C
language had no concept of atomic types or memory barriers, so the kernel
developers naturally had to create their own.  Now that the language
standard has caught up, one might think that changing the kernel to make
use of the standard atomic types would make sense.  And, someday, it might,
but that transition is likely to be slow and fitful at best.
<p>
<h4>Optimization worries</h4>
<p>
The problem is that compilers tend to be judged on the speed of the code
they generate, so compiler developers have a strong incentive to optimize
code to the greatest extent possible.  Sometimes those optimizations can
break code that is not written with an attentive eye toward the standard;
the kernel developers' perspective is that compiler developers will often
rely on a legalistic reading of standards to justify "optimizations" that
(from the kernel developer's viewpoint) make no sense and break code
needlessly.  Highly concurrent code, as is found in the kernel, tends to be
more susceptible to optimization-caused problems than just about anything
else.  So kernel developers have learned to be careful.
<p>
One of the scariest potential problems is "speculative stores," where an
incorrect value becomes visible on a temporary basis.  A classic example
would be code like this:
<p>
<pre>
    if (x)
	y = 1;
    else
	y = 2;
</pre>
<p>
It would not be uncommon for a compiler to optimize this code by turning it
into something like this:
<p>
<pre>
    y = 2;
    if (x)
	y = 1;
</pre>
<p>
For sequential code operating in its own address space, the end result is
the same, and the latter version avoids one jump.  But if <tt>y</tt> is
visible elsewhere, the value stored speculatively before the test may be
seen by code that will proceed to do the wrong thing, causing things to go
off the rails.  Clearly, optimizations that cause incorrect values to
become visible to any running thread must be avoided if the system is to run
correctly. 

<p>
When David Howells recently <a href="/Articles/586850/">suggested</a> that
C11 atomic variables could be used in the kernel, speculative stores were
one of the first concerns to be raised.  The behavior of atomic variables
as described by the standard is complex, to put it lightly, and there were
real worries that the standard could allow compilers to generate speculative
writes. An extensive and sometimes colorful discussion put most of those
concerns to rest, but Paul McKenney, who has been representing the kernel's
interests within the standard committee, is <a
href="/Articles/586851/">still not completely sure</a>:
<p>
<div class="BigQuote">
	From what I can see at the moment, the standard -generally- avoids
	speculative stores, but there are a few corner cases where it might
	allow them.  I will be working with the committee to see exactly
	what the situation is.
</div>
<p>
Another area of concern is control dependencies: situations where atomic
variables and control flow interact.  Consider a simple bit of code:
<p>
<pre>
    x = atomic_load(&amp;a, memory_order_relaxed);
    if (x)
  	atomic_store(&amp;y, 42, memory_order_relaxed);
</pre>
<p>
The setting of <tt>y</tt> has a control dependency on the value of
<tt>x</tt>.  But the C11 standard does not currently address control
dependencies at all, meaning that the compiler or processor could play with
the order of the two atomic operations, or even try to optimize the branch
out altogether; see <a href="/Articles/586854/">this explanation from GCC
developer Torvald Riegel</a> for details.  Again, the results of this kind
of optimization in the kernel context could be disastrous.
<p>
For cases like this, Paul <a href="/Articles/586856/">suggested</a> that
some additional source-code markup and a new <tt>memory_order_control</tt>
memory model could be used in the kernel to make the
control dependency explicit:
<p>
<pre>
    x = atomic_load(&amp;a, memory_order_control);
    if (control_dependency(x))
  	atomic_store(&amp;b, 42, memory_order_relaxed);
</pre>
<p>
But this approach is unlikely to be taken, given <a
href="/Articles/586857/">just how unhappy</a> Linus was with the idea.
From his point of view, the control dependency should be obvious — the code
is testing the value of <tt>x</tt>, after all.  Any compiler that would
move the <tt>atomic_store()</tt> operation in an externally visible way, he
said, is simply broken.
<p>
There has also been some concern about "value speculation," wherein the
compiler guesses that a variable will have a specific value and inserts a
branch to fix things up if the guess is wrong.  The processor's branch
prediction hardware will then, hopefully, speed things up in cases where
the guess is correct.  See <a href="/Articles/586975/">this note from
Paul</a> for an example of how value speculation might work — and how it
might get things wrong.  The good news on this front is that it seems that
this kind of speculation will not be allowed.  But it is not 100% clear
that the current standard forbids it in all cases.

<p>
<h4>Non-local optimizations considered harmful</h4>
<p>
Yet another concern is global optimization.  Compiler developers are
increasingly trying to optimize programs at the level of entire source
files, or even larger groups of files.  This kind of optimization can work
well as long as the compiler truly understands how variables are used.  But
the compiler is not required to understand the real hardware that the
program is running on; it is, instead, required to prove its decisions
against a virtual machine defined by the standard.  If the real computer
behaves in ways that differ from the virtual machine, things can go wrong.
<p>

Consider <a href="/Articles/586957/">this example</a> raised by Linus: the
compiler might look at how the kernel accesses page table entries and
notice that no code ever sets the "page dirty" bit.  It might then conclude
that any tests against that bit could simply be optimized out.  But that
bit <i>can</i> change; it's just that the hardware makes the change, not
the kernel code.  So any optimizations made based on the notion that the
compiler can "prove" that bit will never be set will lead to bad things.  
Linus concluded: "<q>Any
optimization that tries to prove anything from more than local state is by
definition broken, because it assumes that everything is described by the
program.</q>"
<p>
Paul sent out <a href="/Articles/586962/">a list of other
situations</a> where the compiler's virtual machine model might not match what
is really happening.  His examples included assembly code, kernel modules
(which can access exported symbols, but which might not even exist when the
compiler is making its decisions), kernel-space memory mapped into user
space, <a href="/Articles/437981/">JIT-compiled BPF code</a>, and
"<q>probably other stuff as well</q>".  In
short, there is a lot going on inside a kernel that the compiler cannot be
expected to know about.
<p>
One solution to many of these non-local problems is to use
<tt>volatile</tt> with the affected variables.  Simply identifying such
variables would be an error-prone exercise, of course, but there is a worse
problem: using <tt>volatile</tt> turns off all optimization for the
affected variable, defeating the purpose of using atomic variables in the
first place.  If <tt>volatile</tt> must be used, the kernel is better off
staying with its current memory barrier scheme, which is designed to allow
as much compiler- and processor-level optimization as possible, but no more
than that.
<p>
Will it come to that?  Despite his worries, Linus has actually expressed
some confidence that real-world compilers will not break things badly:
<p>
<div class="BigQuote">
	In *practice*, I seriously doubt any reasonable compiler can
	actually make a mess of it. The kinds of optimizations that would
	actually defeat the dependency chain are simply not realistic. And
	I suspect that will end up being what we rely on - there being no
	actual sane sequence that a compiler would ever do, even if we
	wouldn't have guarantees for some of it.
</div>
<p>
But he has also been clear that his trust of compiler developers only goes
so far and that, if necessary, the kernel community is more than prepared
to stick with its current approach, which, he <a
href="/Articles/586974/">said</a>, is "<q>generally *fine*</q>". 
<p>
<h4>Does the kernel need C11 atomics?</h4>
<p>

Linus <a href="/Articles/586858/">went on</a> to make it clear that he is
serious about this; if atomic variables as found in the C11 standard and
its implementations do not 
provide what the kernel wants, the kernel will simply not use that
feature.  The kernel project, he said, is in a fairly strong bargaining
position when it comes to atomic variables:
<p>
<div class="BigQuote">
	And the thing is, I suspect that the Linux kernel is the most
	complete - and most serious - user of true atomics that the C11
	people can sell their solution to.
<p>
	If we don't buy it, they have no serious user. Sure, they'll have
	lots of random other one-off users for their atomics, where each
	user wants one particular thing, but I suspect that we'll have the
	only really unified portable code base that handles pretty much
	*all* the serious odd cases that the C11 atomics can actually talk
	about to each other.
</div>
<p>
On the other hand, he said, the solutions found in the kernel now work just
fine; there is no real need to move away from them if the kernel community
does not want to.
<p>
In truth, there may well be other serious users; the GNU C library <a
href="/Articles/586859/">is using C11 atomics</a> now for a few
architectures, for example.  And, while Torvald <a
href="/Articles/586860/">agreed</a> 
that the kernel could continue to use its own solution, he also pointed out
that there would be some advantages to using the standard mechanism.  The
widespread testing that this mechanism will receive was at the top of his
list.  One could also note that the kernel's tricky, architecture-specific
barrier code could 
conceivably go away, replaced by more widely used code maintained by the
compiler developers.  That code would also, hopefully, be less likely to
break when new releases of the compiler come out.
<p>
Beyond that, Torvald <a href="/Articles/586862/">pointed out</a>, C11
atomics can benefit from a fair amount of academic work that has been
done.  Some researchers at the University of Cambridge have <a
href="http://www.cl.cam.ac.uk/~mjb220/popl085ap-sewell.pdf">come up with a
formal description [PDF]</a> of how C11 concurrency should work.
Associated with that description is <a
href="http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/">an interactive memory
model simulator</a> that can test code snippets for race conditions.  And,
in the end, if a large number of programs make use of C11 atomics, that
should result in the quality of compiler implementations improving quickly.
<p>

Finally, if C11 atomic variables can be made to work in real-world
programs, they could go a long way toward the establishment of reliable
patterns for how C (and C++) can be used in concurrent environments.  At
the moment, there is no way for developers to know what is safe to do —
now, and in the future.  As Peter Sewell (one of the above-mentioned
Cambridge researchers) <a href="/Articles/586977/">put it</a>:
<p>
<div class="BigQuote">
	 There are too many compiler optimisations for people to reason
	 directly in terms of the set of all transformations that they do,
	 so we need some more concise and comprehensible envelope
	 identifying what is allowed, as an interface between compiler
	 writers and users.
</div>
<p>
The C11 standard is meant to be that "envelope," though, as Peter admitted,
it is "<q>not yet fully up to that task</q>".  But if the remaining
uncertainties and problems can be addressed, C11 atomics could become a
common language with which developers can reason about concurrency and
allowable optimizations.  Developers might come to understand the issues
better, and kernel code might become a bit more widely accessible to
developers who understand the standard.
<p>
So it might well benefit the kernel to make use of this relatively new
language feature.  Nobody has closed the door on that possibility, but any
transition in that direction will require a lot of time, testing, and
confidence building.  Bugs resulting from low-level concurrency management
problems can be among the hardest to find, reproduce, or diagnose; nobody
will be in a hurry to replace the kernel's atomics and memory barriers
without a high level of assurance that the change will not result in the
introduction of that kind of issue.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#C11_atomic_operations">C11 atomic operations</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/586838/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor587023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2014 23:25 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/587023/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article quotes Linus saying:<br>
<font class="QuotedText">&gt; In *practice*, I seriously doubt any reasonable compiler can actually make a mess of it. The kinds of optimizations that would actually defeat the dependency chain are simply not realistic. And I suspect that will end up being what we rely on - there being no actual sane sequence that a compiler would ever do, even if we wouldn't have guarantees for some of it. </font><br>
<p>
However, elsewhere in the thread (and in other threads), there have been discussions of real-world scenarios that compilers do *today*, most notably noticing common operations in both branches of a conditional and floating them before the actual conditional.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor587029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 0:05 UTC (Wed)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/587029/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The C11 standard added a number of new features for the C and C++ languages.</font><br>
<p>
Not really. The C++ core language is independent of C, and although the C++ standard library does include C's standard library by reference, it is still based on C99.<br>
<p>
The C11 atomics were almost copy'n'pasted from C++11. All the work was done for C++, and C (sensibly) incorporated it wholesale.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 4:04 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/587040/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <P>I remember hearing from somebody (either a Herb Sutter talk, or our OpenCL/OpenMP/etc. compiler guru at work) that C11 and C++11 differ in some subtle ways.  For most things, users wouldn't be able to tell the difference, but there were some important corner conditions.</P>
<P>Unfortunately, my GoogleFu on the topic is weak tonight.</P>
<P>You wouldn't happen to know off-hand what differs between C11 and C++11, would you?</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/587040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 5:57 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/587042/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C++11 basically refused to adopt most of the changes in C99, including named initializers and compound literals. C11 additions like _Generic and (IIRC) anonymous struct members also didn't get added to C++11.<br>
<p>
The relevant question isn't what C++11 didn't add, it's what it actually adopted from C99 and C11, which is very little. The languages have moved further apart with the latest standard.<br>
<p>
The atomics work was one area where everybody intentionally worked together to make sure there'd be compatibility. C11 didn't simply pull it in from C++11; the cooperation was very intentional and explicit.<br>
<p>
In any event, at this point I think it's safe to say that the C and C++ languages have pretty much parted ways. All the C++ committee cares about is that vendors can maintain ABI compatibility between C and C++ compiled units. C++ isn't interested in keeping up-to-date with C syntax. Some C syntax, like compound literals, I don't think even can be supported, given changes in C++11 regarding temporaries. (But I'm not a C++ programmer so I could be wrong on that last point.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 6:11 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/587044/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One adoption I forgot about is that C++11 added &lt;stdint.h&gt; and &lt;cstdint&gt;. Again, I think all C++ cares about is making ABI compatibility practical for vendors. So the memory-model (atomics) and primitive types (stdint.h) matter. Syntax changes, not so much.<br>
<p>
I just had to tweak a bunch of C headers at work to parse as C++. Very annoying, even though g++ and clang++ try hard to support C99 and C11 extensions in C++ code. But there remain considerable differences. The problem I ran into is that C99 added static inline routines, which means it's more common to encounter actual code blocks in C headers where you quickly run into, e.g., type casting issues like casting from const void * to const char *, which requires static_cast&lt;&gt; or reinterpret_cast&lt;&gt; in C++.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 7:11 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/587046/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compiler should have a single flag you can specify which gives an error if any code construct has different semantics between C and C++.  (In other words so you can write code in the intersection of both languages.)  Of if that's too ambitious, at least check the syntax is valid in both languages.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 8:12 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/587048/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <P>It's a bit late for me to find chapter and verse, but I seem to recall there are subtly different aliasing rules between the two.</P>
<P>Other areas where I was surprised—or at least dismayed and/or annoyed—by differences (at least in implementation):  C99<TT> _Bool </TT>vs. C++<TT> bool</TT>, complex numbers (beyond just syntax), enums...</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/587048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 9:59 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/587057/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Yes, many of these differences are quite pointless.  Stroustrup a few years ago wrote an article <a href="http://www.stroustrup.com/sibling_rivalry.pdf">C and C++ - sibling rivalry</a> about some of them.
<p>
While I wouldn't necessarily support merging C and C++ into a single language, or even requiring one to be a subset of the other, I do think the two standards committees should be merged into one group which looks after both languages.  That would piss them off a great deal, but better to piss off the committee than the programmers who have to cope with the needless differences.
      
          <div class="CommentReplyButton">
            <form action="/Articles/587057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 14:21 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/587087/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think they should be merged. You're basically firing any C standard member who doesn't know C++ already and with how complicated the language is, that'd be a lot of time to require. Personally, I'd prefer if they just say that C support in C++ was a dumb idea and make a formal split. Alas, backwards compatibility :/ .<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 23:40 UTC (Wed)
                               by <b>oshepherd</b> (guest, #90163)
                              [<a href="/Articles/587231/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps due to higher general interest, perhaps because there is more going on there - my impression and experience is that the C++ standards committee is a lot more active and quite a bit more rigorous.<br>
<p>
While the C++ standard has more bugs than the C standard - thats' not surprising, its' significantly larger - it also has less bugs per page, and the bugs it does have are more subtle (and thus harder to find)<br>
<p>
The C11 standard has some careless bugs which kind of give away the fact that the C committee is really quite small - perhaps too small.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor587097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 15:48 UTC (Wed)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/587097/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I wouldn't necessarily support merging Linux and FreeBSD into a single kernel, or even requiring one to be a subset of the other, I do think the two development communities should be merged into one group which looks after both kernels. That would piss them off a great deal, but better to piss off the kernel developers than the programmers who have to cope with the needless differences.<br>
<p>
(Because telling volunteers they should be donating their time to projects they don't care about is a great way to get good results, right?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 16:22 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/587106/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I imagined that the standards committees were staffed with paid employees of compiler vendors, e.g. Herb Sutter at Microsoft, but with the dominance of gcc and LLVM this view of the world must be out of date.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2014 14:55 UTC (Fri)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/588796/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Microsoft only started participating in the C++ standards effort relatively recently (ie, when Microsoft employed Herb to take over as head of the C++ compiler group).  Prior to then, Microsoft actively worked against standardization efforts.<br>
<p>
I think most of the C++ committee are allowed to work on standardization work as part of their employment, but most somewhat reluctantly, it isn't their core job.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/588796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor587299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2014 11:57 UTC (Thu)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/587299/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you want to influence standardization, there's a straight-forward way to do that: Get involved.  <a href="http://isocpp.org">http://isocpp.org</a> has useful information about the whole process, mailing lists, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor587050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 9:09 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/587050/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But the _effect_ of such a flag is that C++ programmers will insist that C programmers "ought" to use the flag so as to not interfere with their pretty notion that C is just a limited subset of C++ written by Neanderthals. Which is bogus. When something provides C, it means C, not "I'm sure you can just paste this into a C++ program and that'll be fine".<br>
<p>
If you add a Java component to a C program nobody expects that they'll just be able to import some.c.code; into the Java and have that work. If you need to access Perl from Python, or Ruby from PHP again, nobody insists that there should be some "easy" way to just mix them together as if they were merely dialects of the same language. In each case you're responsible for handling the adaptor layer. But somehow C++ programmers seem to think they shouldn't need to do this with C, let's not make this myth any easier to believe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 9:57 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/587056/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, they are different languages and anyone who says 'C/C++' usually doesn't know what they are talking about.  Nonetheless there are plenty of C programmers who choose to make their code also valid C++, not because they are bullied into it by heartless C++ programmers, but as a way of getting some additional compile-time checking and warnings for odd corners of the language.<br>
<p>
An 'intersection' compiler mode might also be useful when writing C wrappers for libraries implemented in C++.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor587085"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 14:18 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/587085/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a C++ developer for the most part, it has been my belief that C++'s greatest mistake has been C source compatibility (to the extent that it is even true). I firmly believe that having an FFI to C would have been much cleaner in the long run. Unfortunately, that ship sailed long ago. This further divide makes me even more sure of it though.<br>
<p>
<font class="QuotedText">&gt; compound literals</font><br>
<p>
Is this why I can't declare literals like 'char const* const* strarray[] = { { "a", "b", NULL }, NULL };' in C++?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587085/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 20:57 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/587188/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Pretty much, I guess. Although the valid syntax would be<br>
<p>
char const* const* strarray[] = { (char const* const[]){ "a", "b", NULL }, NULL };<br>
<p>
which the compiler effectively translates to<br>
<p>
char const* const tmp[] = { "a", "b", NULL };<br>
char const* const* strarray[] = { tmp, NULL };<br>
<p>
Correct me if I'm wrong, but I believe that the problem is that the construct (type){ initializer list } in C++ creates a temporary array which is destroyed when the expression goes out of scope (I dunno if this is C++11 syntax or a common extension to be adopted in the next version). Compound literals in C have block scope lifetime.<br>
<p>
Compound literals are a nice addition to C. It's clearly possible to live without them, but it's often convenient to be able to create small objects or buffers inline. For example, you can wrap something like strerror_r or strerror_l to behave like strerror, although you have to be careful about scoping. Very crude example: #define xstrerror(error) strerror_r((error), (char[256]){0}, 256).<br>
<p>
I presume C++ has more wholesome ways of doing stuff like this, which is why the committee wasn't interested in the extension.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2014 1:15 UTC (Thu)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/587243/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I dunno if this is C++11 syntax or a common extension to be adopted in the next version</font><br>
<p>
Neither. It's a common extension but very unlikely to be standardised.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2014 6:12 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/587272/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, the syntax was I was thinking of is called something like "list-initialized temporaries", which was added to C++11 to allow classes to accept initialization lists in the manner of plain aggregate types. The syntax is similar, just without the parentheses--type{ initialization-list}, or just { initialization-list } if the type can be inferred.<br>
<p>
GCC decided to give compound literals in C++ the same treatment as it does initializer lists. The temporary objects in the initializer lists are scoped to the expression. See <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53220">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53220</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor587275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2014 8:06 UTC (Thu)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/587275/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not sure if c++ has alloca(), but this looks neater to me:<br>
<p>
#define xstrerror(error) strerror_r((error), alloca(256), 256)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2014 13:29 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/587314/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Well, technically, <I>neither</I> C nor C++ has<TT> alloca()</TT>, although it's a common extension.  Or did C11 add this?</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/587314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor588549"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2014 8:02 UTC (Thu)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/588549/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Calling alloca() from a function argument is historically a very iffy thing to do - there were implementations where this crashed and burned very badly (alloca ended up fudging the stack pointer in the middle of the code pushing arguments onto the stack).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/588549/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588557"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2014 8:52 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/588557/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <P>Well, at least among the compiler folk I work with, they'd argue that<TT> alloca() </TT>is an ugly thing to do, full stop.<TT> ;-)</TT></P>
<P>Given that our own compiler doesn't support<TT> alloca()</TT>, and tries to figure out the total stack frame for the entire function (so that no matter what happens, the SP moves once on entry, once on exit), I can't say I entirely blame them for that opinion.  (Or, at least, that's what our compiler did the last time I dug into it at that level.)</P>
<P>Is it just me, or does<TT> alloca() </TT>mostly just feel like a hack to get around the lack of destructors or other unrolling mechanisms tied to leaving scopes?</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/588557/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588559"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2014 8:58 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/588559/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It also offers very fast allocation and deallocation of arbitrarily-sized arrays within a cache-local area. It's hard to beat that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/588559/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588646"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2014 17:15 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/588646/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <P>True, but if you already have to limit yourself to a certain maximum size allocation to effectively use<TT> alloca()</TT>, then declaring a local array gets you that same locality benefit.</P>
<P>I also saw elsewhere a horror story where a function call w/<TT>alloca()</TT> got inlined and turned into a stack overflow, because apparently the compiler deferred the implicit freeing of the buffer to the end of the parent function.  ie:
</P>
<PRE>
    void inlined_func(...)
    {
         ... 
         alloca( ... ); 
         ...
         /* implicit free() here */
    }

    void parent( ... )
    {
         for (i = 0; i &lt; 10000000; i++)
             inlined_func();
    }
</PRE>
<P>turned into:</P>

<PRE>
    void parent( ... )
    {
         for (i = 0; i &lt; 10000000; i++)
         {
             ...
             alloca( ... );
             ...
         }
         /* implicit free() here */
    }
</PRE>
<P>Oops.</P><P>I've never had that happen with local arrays, though. When the compiler inlines a function with a local array, the result looks more like an array local to the parent that it got inlined within, so it statically becomes part of the stack frame while you're in the parent.  That is, if you replace<TT> alloca() </TT>in the example above with<TT> char buf[MAXBUF];</TT>:</P>
<PRE>
    void parent( ... )
    {
         for (i = 0; i &lt; 10000000; i++)
         {
             char buf[MAXBUF]; /* becomes a static part of the stack frame */
             ...
             ...
         }
    }
</PRE>
<P>Sure, statically sized buffers have their own issues—buffer overflow attacks—but<TT> alloca() </TT>is no panacea if it can be used to overflow the stack and crash the app.  I guess what I'm saying is that the set of places where<TT> alloca() </TT>provides an advantage over a statically sized buffer are limited because the places where it's safe to use either have so much overlap, while the places where only one or the other is appropriate are fairly small.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/588646/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2014 18:00 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/588655/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Statically sized buffers are way too wasteful. For example, storing path would require MAXPATH of stackspace for all paths.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/588655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2014 5:58 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/588736/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <P>And yet, if you do encounter a series of paths that are at or near<TT> MAXPATH </TT>bytes, you'd still end up wasting that space <I>anyway</I> with<TT> alloca()</TT>.  If you're saying you can't handle so many<TT> MAXPATH </TT>pathnames, then you're broken if you use<TT> alloca()</TT>, since it doesn't offer a way to fail gracefully.</P>
<P>If you're manipulating many structures that have potential not to fit on the stack, another approach I've seen is to allocate a static buffer large enough to catch most common cases, and fall back to a<TT> malloc()</TT>'d buffer if you'd exceed that threshold.  It does require a conditional call to<TT> free()</TT>, but it's more robust than<TT> alloca() </TT>and avoids the unconditional bloat of overlarge local arrays.</P>
<P>(And, with the explicit<TT> malloc() </TT>and<TT> free()</TT>, it won't run afoul of the inlining gotcha I highlighted above.)</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/588736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2014 11:37 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/588771/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Yes, bugs in compilers exist and should be fixed. Just like any other types of bugs. We don't design our programs around old bugs in kernel or libc, why should we design them to support broken compilers?</p>

<p>The rest of discussion sounds so bizzare I can not even believe I hear it on LWN. <b>ALL</b> remaining arguments <b>only</b> make sense for address-space constrained system <b>without</b> overcommit.</p>

<p>On systems with overcommit enabled and with no shortage of the address space (and that's 99.99% of systems out there) <code>alloca</code> is as safe as <code>malloc</code>+<code>free</code> and much, <b>much</b> faster. End of discussion.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/588771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2014 15:56 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/588821/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't you argue that mobile devices are eating other form factor's lunches? They're all 32-bit last I checked where address space is at a premium.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/588821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2014 17:01 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/588828/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">Don't you argue that mobile devices are eating other form factor's lunches?</font></blockquote>

<p>Well, sure. </p>

<blockquote><font class="QuotedText">They're all 32-bit last I checked where address space is at a premium.</font></blockquote>

<p>It's good idea to check things more often than once per decade. Have you head about <a href="http://en.wikipedia.org/wiki/IPhone_5S">this</a> phone? How about <a href="http://www.pcmag.com/article2/0,2817,2453954,00.asp">this</a> CPU or <a href="http://www.pcworld.com/article/2100701/qualcomm-overtakes-apple-with-eightcore-64bit-mobile-processor.html">that</a> one?</p>

<p>And I don't see where you get the notion that 32-bit implies “address space is at a premium”: typical mobile OS does not use swap and keeps many applications in memory at the same time. Any given application can only use 128MB or so. You can easily give allocate 16MB or 32MB of address space for heavy worker threads - more then enough for <code>alloca</code>.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/588828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor588856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2014 17:34 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/588856/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>On platforms that support it.  Still, it's not portable, and doesn't seem to offer truly material advantages in my eyes.</P>
<P>One place I've run into<TT> alloca() </TT>was in some initialization code of g_doom, the "generic frame buffer" port of Doom.  That's pretty much the last place to make a "hot cache efficiency" or any other time-based argument for<TT> alloca() </TT>over<TT> malloc()</TT>.  It was there pretty much for the purpose of getting an automatic deallocation if it took an early exit from the function.</P>
<P>The system I was porting to, however, didn't (and <I>still</I> doesn't) support<TT> alloca()</TT>, so I had to convert it to<TT> malloc()</TT>/<TT>free()</TT>.  (And when I asked our compiler guys about it, they said "Just use<TT> malloc()</TT>" with the sort of tone that implied they thought<TT> alloca() </TT>was an abomination.)</P><P>Yes, the code was marginally cleaner looking with<TT> alloca()</TT>, but my point was that that benefit arises from the fact that C doesn't offer any other easy way to say "clean all this up when we leave this scope" other than to put things on the stack and rely on the stack frame unwinding.</P>
<P>Aside from non-portability,<TT> alloca() </TT>also pretty much requires you to use a frame pointer, since your stack frame size is now variable.  Again, not usually a big deal, although it can hurt on register-starved architectures like 32-bit x86.  And then there's all these fun comments in<TT> alloca()</TT>'s own manual page:</P>
<PRE>
BUGS
        The alloca() function is machine and compiler dependent.  On many sys-
        tems its implementation is buggy.  Its use is discouraged.

        On many systems alloca() cannot be used inside the list of arguments of
        a function call, because the stack space reserved by alloca() would
        appear on the stack in the middle of the space for the function argu-
        ments.
</PRE>
<P>I get it, you like<TT> alloca()</TT>.  I see enough things potentially wrong with it that its meager advantages don't seem worth it to me.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/588856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2014 18:06 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/588862/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">I get it, you like alloca(). I see enough things potentially wrong with it that its meager advantages don't seem worth it to me.</font></blockquote>

<p>I'm not a big <code>alloca</code> lover, but I just don't see what's the big hoopla is all about. I mean: <code>alloca</code> is just a minor syntaxic sugar on top of facilities you have anyway. Yes, it's not portable but it's an interface people are familiar with, so why not?</p>

<p>Before you'll raise the racket about frame pointers and stuff please recall that you compiler <b>must</b> compile, e.g. the following program (from 6.5.3.4 <i>The <code>sizeof</code> oprator</i> part of the C standard):<br /><br />
<code>#include &lt;stddef.h&gt;<br />
<br />
size_t fsize(int n)<br />
{<br />
&nbsp; char b[n+3];<br />
&nbsp; return sizeof b;<br />
}</code></p>

<p>It's a 100% standard program. It's included in standard. It's non-optional part of it. It <b>must</b> be supported.</p>

<p>Now on any system where it's supported <code>alloca</code> implementation is trivial, so why not just implement and use it where appropriate?</p>

<p>I'm yet to observe a system which supports the aforementioned program (from the official <b>15 years old standard - and included again in new C11 one, too</b>!) which does not support working and usable <code>alloca</code> and if you insist on using broken tools you deserve to receive broken programs.</p>

<p>P.S. Note that function in standard is called <code>fsize</code>—this gives you pretty strong hint where and how such facilities are supposed to be used, right?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/588862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor587034"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 1:42 UTC (Wed)
                               by <b>lutchann</b> (subscriber, #8872)
                              [<a href="/Articles/587034/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In skimming the article, I thought for a moment our editor had an appalling lapse of accuracy in spelling Linus's last name...but it turns out he was referring to Torvald Riegel instead.  Hopefully my pointing this out will avoid some mistaken "correction" emails!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587034/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 7:29 UTC (Wed)
                               by <b>billygout</b> (guest, #70918)
                              [<a href="/Articles/587047/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks, I experienced the same confusion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 15:18 UTC (Wed)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/587093/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some LWN authors refer to people by their first name, and some refer to people by their last name, which makes it even more confusing.  I suppose switching to email addresses is out of the question? :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor587041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thanks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 4:04 UTC (Wed)
                               by <b>bjacob</b> (guest, #58566)
                              [<a href="/Articles/587041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just when my subscription was expired and I was wondering whether to renew. My wallet doesn't thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor587049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 8:18 UTC (Wed)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/587049/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; "Any optimization that tries to prove anything from more than local state is by definition broken, because it assumes that everything is described by the program."</font><br>
<p>
I think Linus oversteps a bit here. For the kernel it might be true because the kernel has a very intimate relationship with the hardware. But for user-space code I think it's a different thing. The whole point of the kernelspace-userspace split is so that the latter can assume that nothing "magical" happens, and if it does, it's within the system calls. I may be wrong, of course, but I don't want my compiler to give up useful [global] optimizations like removing a variable that is never written to (and preferably warning me about it) just because it was told that some unknown entity from outer space may modify the memory behind my back ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 9:34 UTC (Wed)
                               by <b>alexl</b> (subscriber, #19068)
                              [<a href="/Articles/587053/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a lot of "magic" that can happen even in userspace, via e.g. shared memory (writes from other processes), dlopen/JIT (linker/compiler doesn't have full knowledge of code at runtime), etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587061"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 10:35 UTC (Wed)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/587061/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't see how memory shared with other processes is a problem.  You would need to synchronize properly for those (e.g., maintain data-race freedom), but the compiler is aware that this is shared with other threads because you did mmap() or similar on it; the compiler doesn't know about mmap() semantics, so it has to assume that mmap() might make the data visible to other stuff.  One thing to note is that your synchronization needs to be ready for cross-process; regarding atomics, the C++ standard guarantees that any lock-free operations will also be "address-free", meaning that it still works if the memory region is visible at another virtual address, like when mapped by another process.<br>
<p>
For dlopen, the compiler is aware of data escaping to unknown code because there will be function calls for functions the compiler hasn't analyzed (and it will thus *not* be able to make whole-program analysis and optimizations relying on that).  JIT is the same if JIT'ed functions are accessible through function interfaces, global variables accessible to other compilation units, etc.<br>
<p>
Thus, I think there's less "magic" than people might assume.  Of course, if you ask your JIT to modify code produced by the compiler, the JIT should better know what it's doing :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587061/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 12:03 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/587069/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">the compiler doesn't know about mmap() semantics, so it has to assume that mmap() might make the data visible to other stuff</font></blockquote>

<p>Citation needed. From what I'm seeing in the standard mmap() can do whatever it wants while it's running but when it returns compiler may assume that it knows everything about the program till you call mmap() again.</p>

<p>You don't even need another program to confuse compiler. You can just mmap the same region twice in your program then write to some atomic variable using one address while read it using different address. Naive compiler may decide that it have "proof" that variable is never modified.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/587069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587075"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 13:29 UTC (Wed)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/587075/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Citation needed. From what I'm seeing in the standard mmap() can do whatever it wants while it's running but when it returns compiler may assume that it knows everything about the program till you call mmap() again.</font><br>
<p>
Sorry, but *your* assertion needs a citation.  C11 is multi-threaded.  Where is mmap or any other function with unknown semantics forbidden to spawn a new thread and let the new thread access the data?<br>
<p>
<font class="QuotedText">&gt; You don't even need another program to confuse compiler. You can just mmap the same region twice in your program then write to some atomic variable using one address while read it using different address. Naive compiler may decide that it have "proof" that variable is never modified.</font><br>
<p>
Likewise.  You don't need to map it to other addresses.  A correct compiler will handle this just right.<br>
<p>
Note though that if the caller of mmap() uses the data as if it would not be shared with other threads, then the compiler can assume it isn't shared.  This follows from the data-race-freedom requirement in the C11/C++11 memory model.  For example, if you access the data using non-atomic stores (also note that the atomics are type, not plain data), then doing so while another thread may read the data is a data race, and is specified to result in undefined behavior.  IOW, any compiler transformations you didn't expected where caused by your program having a data race and thus undefined behavior.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587075/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor587054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 9:47 UTC (Wed)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/587054/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In multithreaded programs it is very much possible that an other entity (other thread) modifies the memory "behind your back".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 10:09 UTC (Wed)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/587059/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But another thread is still part of the same program. An optimizer that can prove a variable is never written to obviously has to see the code for the whole program, including code running in other threads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 12:05 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/587071/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Compiler can not see the code for the whole program because any program which never call any syscalls is pretty much useless. And even if you'll include kernel sources to the mix there are some things which CPU can do behind your back (as Linus pointed out).
      
          <div class="CommentReplyButton">
            <form action="/Articles/587071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587078"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 13:49 UTC (Wed)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/587078/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Compiler can not see the code for the whole program</font><br>
<p>
That's what jwakely is pointing out: If the compiler cannot see the whole program, it will be aware of that, will not to do a whole-program analysis, and thus will not attempt optimizations that need whole-program analysis.<br>
<p>
Also note that if you have a valid C program, then it follows the C semantics including its object model (ie, lifetime and accessibility of the objects that form program state).  If you access C objects with other means than defined by C, you better know what you are doing.  There's "volatile" for demarcating things where you talk to the outside world, which have much stricter semantics than normal code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587078/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor587074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 12:42 UTC (Wed)
                               by <b>alankila</b> (guest, #47141)
                              [<a href="/Articles/587074/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, it might be a shared with a whole *different* program, of course.<br>
<p>
No, the reality is that the mere use of synchronization primitives must tell the compiler to disable closed-world optimizations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 13:41 UTC (Wed)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/587076/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you share it with a different program (IOW, the external world not covered by the standard), this is what's "volatile" exists for.  This is orthogonal to synchronization.<br>
<p>
If you share with other programs that use the C11 memory model and ABI, you can just use the atomics and it will work fine because the compiler will see when you share stuff with other programs -- simply because it sees that state will be accessible to other entities that it cannot analyze.  (This does assume that you share via C facilities such as functions such as mmap(); it won't work with other things that magically hook into your C program, such as debuggers, of course.)<br>
<p>
If you share with other processes that use the C11 memory model and ABI, use lock-free atomics for that because they are "address-free" (see C++ 29.4p3).<br>
<p>
IOW, what you call closed-world optimizations are not a problem because the compiler will see for which variables/state the world is closed, or for which is isn't.  As I stated above, the only corner cases where this isn't the case is when program state objects are accessible through other means than defined by the C standard, and they are not explicitly shared.  For example, if you would allocate an object, and let another process mmap your heap (eg, after attaching) and walk your malloc data structures to find the object.  But that's outside of C; normal C programs without those custom quirks will just work fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor587191"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 21:04 UTC (Wed)
                               by <b>sionescu</b> (subscriber, #59410)
                              [<a href="/Articles/587191/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An external process can modify your program's memory via ptrace(2)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587191/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2014 0:32 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/587242/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent point!  I had forgotten about ptrace, and, by extension, debuggers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587681"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2014 20:16 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/587681/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it safe to say that no optimized program is compiled in the expectation of debuggers doing *anything* to it. Sure, debuggers can work as well as possible, but in general making that happen is up to the debugger and the DWARF generation code in the compiler, and the compiler can sensibly assume that anyone ptracing is looking at the DWARF: the compiler certainly isn't going to pessimize its code to make the job of people doing ptrace() without looking at the generated DWARF any easier!<br>
<p>
(sez a man who's written code in the last year that digs around in the guts of running programs without looking at the DWARF in any way shape or form. But I'm not modifying anything, so that's all right. Right? ... :} )<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587681/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2014 1:04 UTC (Sun)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/587700/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
;-) ;-) ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor587060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 10:27 UTC (Wed)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/587060/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think this is necessarily a userspace/kernel difference, although the corner cases are less likely for typical userspace programs.  The language itself has several notions of visibility/accessibility of variables built into it.  For example, a variable on the stack is just visible in it's owning function unless it's address is taken and the address value escapes the function. "volatile" can be used to designate state that is part of the visible output/input from the external world.<br>
<p>
The corner cases that we discuss further in the thread are when visibility/accessibility of variables is established through mechanisms outside of the language (e.g., accesses through magically known fixed addresses, linker script magic, ...).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2014 15:18 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/587092/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One key point on the userspace/kernel boundary is that we cannot let the kernel crash just because the userspace code had a data race.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor587679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2014 19:58 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/587679/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
btw, C compilers have been optimizing based on entire source files for many years (GCC started doing it in 3.something, I think, and the kernel adjusted: remember -funit-at-a-time?). Whole-program optimization, which is what was being discussed, is optimizing whole programs at once, so the compiler has a global view. This is, of course, often not possible, so there is also link-time optimization, which can optimize lots of translation units as a group without necessarily assuming that it knows about the whole program all at once.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor610218"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2014 0:41 UTC (Tue)
                               by <b>dalias</b> (guest, #95815)
                              [<a href="/Articles/610218/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The speculative store optimization cited in this article is at least blown out of proportion, in the sense that it's only visible in code with undefined behavior, if at all. Both the POSIX memory model (as lacking in detailed specification as it is, it's still a memory model) and the C11 memory model forbid any transformations that could cause an incorrect value to be ready by another thread which is performing a legal read. If you're reading a non-atomic object in a situation where another thread may be writing to it (this could apply to another thread reading y in the article's example, with the example code as the writer), then the behavior is undefined, and so reading an incorrect value (or crashing, or summoning nasal demons, or whatever) is acceptable behavior for the compiler to produce. But if there's proper synchronization (POSIX or C11) or memory ordering (C11) protecting the read, a compiler cannot make such a transformation.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610218/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor610225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C11 atomic variables and the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2014 1:19 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/610225/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's nice to be able to declare the real world "out of spec" and blame everything on using code with undefined behaviour<br>
<p>
but it doesn't actually do anyone any good.<br>
<p>
In the real world, the processor memory model don't match the C11 or POSIX memory models and such issues need to be addressed.<br>
<p>
One way of addressing them to to use atomic operations and/or memory barriers around all object access, that will make the standard happy, but the performance will plummet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/610225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
