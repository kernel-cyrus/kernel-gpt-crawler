        <!DOCTYPE html>
        <html lang="en">
        <head><title>Special file descriptors in BPF [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/933182/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/933415/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/933182/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Special file descriptors in BPF</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 5, 2023</br>
           </div>
Developers learning the Unix (or POSIX in general) system-call set will
quickly encounter file descriptors, which are used to represent open files
and more.  Developers also tend to learn early on that the first three file
descriptors are special, with file descriptor zero being the standard input
stream, one being standard output, and two being standard error.  The
kernel, though, does not normally attach any specific meaning to a given
descriptor number, so it was somewhat surprising when a recent BPF patch
series attempted to attach a special meaning to zero when used as a file
descriptor.
<p>
BPF objects (maps and such) normally go away when they are closed, usually
when the creating process exits.  They may be "pinned", though, which gives
them a name in the BPF filesystem (usually under <tt>/sys/fs/bpf</tt>) and
allows them to outlive the creating process.  The existing API for the
pinning of BPF objects is path-based, meaning that the caller provides a
string containing the full path name to be created for an object.
<p>
The <a href="/ml/bpf/20230516001348.286414-1-andrii@kernel.org/">series in
question</a>, posted by Andrii Nakryiko, adds a mechanism to pin BPF
objects using an open file descriptor instead of a path name to identify
the containing directory.  The feature itself is widely seen as a useful
addition and is not controversial, but one aspect of it was.  The patch
series expanded an anonymous structure in the impressively sprawling <a
href="https://elixir.bootlin.com/linux/v6.4-rc1/source/include/uapi/linux/bpf.h#L1319"><tt>bpf_attr</tt>
union</a> to contain a new <tt>path_fd</tt> field that would be used to
provide the file descriptor identifying the directory in which (or below
which) to pin the object.  If <tt>path_fd</tt> were provided as zero,
though, it would be interpreted to mean the calling process's current
working directory — the same as the <tt>AT_FDCWD</tt> argument to system
calls like <a
href="https://man7.org/linux/man-pages/man2/openat2.2.html"><tt>openat2()</tt></a>.
<p>
The motivation behind these semantics is not that hard to understand.  This
new field will have a value of zero by default if the calling process does
not provide it.  Interpreting that zero as "start from the current working
directory" allows for an easy, backward compatible expansion of the
interface, since programs that do not provide that file descriptor will
behave as they did before.  But this interpretation also means that no
process can use file descriptor zero as the starting directory for this
system call, and that was seen as a source of concern.
<p>
Christian Brauner quickly <a
href="/ml/bpf/20230516-briefe-blutzellen-0432957bdd15@brauner/">questioned
this decision</a>, calling it "<q>very counterintuitive to userspace and
pretty much guaranteed to cause subtle bugs</q>".  He also asked if similar
practices were to be found in other parts of the BPF subsystem.  Nakryiko
<a
href="/ml/bpf/CAEf4BzafCCeRm9M8pPzpwexadKy5OAEmrYcnVpKmqNJ2tnSVuw@mail.gmail.com/">answered
in the affirmative</a>:
<p>
<blockquote class="bq">
	Yes, it's a very bpf()-specific convention we've settled on a while
	ago. It allows a cleaner and simpler backwards compatibility story
	without having to introduce new flags every single time. Most of
	BPF UAPI by now dictates that (otherwise valid) FD 0 can't be used
	to pass it to bpf() syscall.
</blockquote>
<p>
He added that the libbpf library goes out of its way to hide this behavior
by reopening file descriptors that would otherwise be returned as zero.
<p>
Brauner <a
href="/ml/linux-fsdevel/20230517-allabendlich-umgekehrt-8cc81f8313ac@brauner/">did
not like</a> this convention:
<p>
<blockquote class="bq">
	I personally find this extremely weird to treat fd 0 as anything
	other than a random fd number as it goes against any userspace
	assumptions and drastically deviates from basically every file
	descriptor interface we have. I mean, you're not just saying fd 0
	is invalid you're even saying it means AT_FDCWD.
</blockquote>
<p>
There was <a
href="/ml/linux-fsdevel/CAADnVQKM3Jh7Sj7o9pz79Dme=kjinjsDPipE6MBUY-f=UfA+Tw@mail.gmail.com/">evidently</a>
some sort of off-list conversation, and Nakryiko later posted <a
href="/ml/linux-fsdevel/20230518215444.1418789-1-andrii@kernel.org/">an
updated patch set</a> that introduces a new flag to indicate whether a file
descriptor has been provided rather than checking for a zero value.  But it
seems clear that the BPF community is not entirely thrilled by this change,
and wants to continue to treat that value as special.  Alexei Starovoitov
<a
href="/ml/linux-fsdevel/CAADnVQLitLUc1SozzKjBgq6HGTchE1cO+e4j8eDgtE0zFn5VEw@mail.gmail.com/">said</a>
that the design of Unix includes two fundamental mistakes: allowing zero to
be a valid file-descriptor value, and assigning special meanings to the
first three descriptor values — a decision that he called "<q>just
awful</q>".  Those file descriptors, he said, are "<q>taken</q>" and should
not be used for any other purpose; the BPF developers decided to implement
part of that approach themselves:
<p>
<blockquote class="bq">
	Because of that, several years ago, we've decided to fix unix
	mistake #1 when it comes to bpf objects and started reserving fd=0
	as invalid.  This patch is proposing to do the same for path_fd
	(normal vfs fd) when it is passed to bpf syscall. I think it's a
	good trade-off and fits the rest of bpf uapi.
</blockquote>
<p>
Brauner <a
href="/ml/linux-fsdevel/20230518-erdkugel-komprimieren-16548ca2a39c@brauner/">reiterated</a>
that disallowing zero as a file descriptor seemed strange, but clarified
his bigger complaint with the first version of the patch set: it didn't
just disallow that file descriptor, but assigned a separate and
incompatible meaning to it.  If every kernel subsystem could attribute its
own meaning to specific file-descriptor numbers, he said, the results would
quickly spiral out of control.
<p>
Ted Ts'o <a href="/ml/linux-fsdevel/ZGY2eICf8Ndr3Xg5@mit.edu/">wondered</a>
if there could be security problems inherent in the BPF approach and
suggested that it should perhaps be changed even if ABI incompatibility
resulted.  Nobody else, though, has raised security concerns with regard to
this practice.
<p>
Linus Torvalds was <a
href="/ml/linux-fsdevel/CAHk-=wgmRTogGmR8E_SYOiHFpz8cY+0xj7nBpv9UwGU6k-UPAA@mail.gmail.com/">highly
critical</a> of any code that treats specific file descriptors specially:
<p>
<blockquote class="bq">
	But fd 0 is in absolutely no way special. Anything that thinks that
	a zero fd is invalid or in any way different from (say) fd 5 is
	completely and utterly buggy by definition. [...]
	<p>
	If bpf thinks that 0 is not a file descriptor, then bpf is simply
	wrong. No ifs, buts or maybes about it. It's like saying "1 is not a
	number". It's nonsensical garbage.
</blockquote>
<p>
Brauner <a
href="/ml/linux-fsdevel/20230518-gebrechen-tulpen-7be50e0f5b1a@brauner/">acknowledged</a>,
though, that is is probably too late to change the BPF subsystem's practice
of treating file descriptor zero as invalid.  That policy has been baked
into the code for years, so it would be surprising if no code in the wild
depended on it.  The patch assigning a more special meaning to that
descriptor number was intercepted in time, though, and it doesn't appear
that this practice exists anywhere else in the code.  So programs
interacting with BPF will be unable to use file descriptor zero as an
ordinary descriptor, but neither will they be expected to use it as a
special value.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF">BPF</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/933182/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor933913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 15:51 UTC (Mon)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/933913/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Reminds me of the billion dollar mistake story, which goes that, if something looks like a duck, quacks like a duck, but swims like a rooster, then we will see some casualty.  (I chose to avoid that word, but I believe you get me, that one could sound better, right?)<br>
<p>
IMO a particular choice of null value does not really matter, and both choices may be “wrong”; however it looks like we have two different “wrong” types that look like the same thing.  Bound by ABI constraints maybe we can’t change anything, but oh, this definitely contributes a few percent more confusions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor933927"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 18:52 UTC (Mon)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/933927/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BPF likes Fortran-Matlab-Julia convention of having array indexes to start with 1 with zero being a useful invalid index sentinel ;)<br>
<p>
C is inconsistent in this regard. Array indexes starts with 0 so one has to use (size_t)-1 as non-existing/invalid index. Yet 0 pointer is not a valid one. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933927/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 19:15 UTC (Mon)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/933929/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; C is inconsistent in this regard. Array indexes starts with 0 so one has to use (size_t)-1 as non-existing/invalid index. Yet 0 pointer is not a valid one. </span><br>
<p>
0 very much IS a valid pointer in C (that is why you can get segfaults, which are hardware detected and not software errors). In C it is very possible to write  code that uses data structs or code at address 0x0. It is the OS/kernel (and historical precedent) that require 0x0 be unmapped.<br>
<p>
In fact quite a bit of micro-controllers use 0x0 as boot ROM locations.<br>
<p>
Additionally array_variable[(size_t)-1] is ALSO valid C code. Actual use is rare, but it's very possible, especially in cases where array_variable is known to be pointing to somewhere inside a larger struct.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 20:46 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/933943/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; 0 very much IS a valid pointer in C (that is why you can get segfaults, which are hardware detected and not software errors). In C it is very possible to write code that uses data structs or code at address 0x0. It is the OS/kernel (and historical precedent) that require 0x0 be unmapped.</span><br>
<p>
I believe that is incorrect. In particular the C specification says:<br>
<p>
<span class="QuotedText">&gt; If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function</span><br>
<p>
which means (T*)0 cannot be a pointer to an object or function. Dereferencing is only defined for pointers to objects and pointers to functions; otherwise it's undefined behaviour. And then a footnote explicitly says it's invalid:<br>
<p>
<span class="QuotedText">&gt; Among the invalid values for dereferencing a pointer by the unary * operator are a null pointer, an address inappropriately aligned for the type of object pointed to, and the address of an object after the end of its lifetime.</span><br>
<p>
And compilers will exploit this - e.g. if you write:<br>
<p>
#define RESET_VECTOR 0x0<br>
void *get_initial_sp() {<br>
return *(void **)(RESET_VECTOR + 0);<br>
}<br>
<p>
then GCC -O2 will emit an undefined instruction (".inst 0xdeff" on ARM) because it knows the code dereferences null and therefore must be unreachable in a valid program.<br>
<p>
I think you can build with -fno-delete-null-pointer-checks to get the expected (but non-standard) behaviour here, on platforms where there is useful data at 0x0, though I suspect it's often easier to just write some assembly to read from 0x0 without having to worry about your compiler's poorly-documented interpretation of what C says is undefined behaviour. You need to be quite careful about this issue if you're writing a bootloader in C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2023 10:59 UTC (Tue)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/933981/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe the subtlelty is that your null pointer does not have to be the bit value 0. You can set your null pointer to correspond to underlying representation 0x55555555 and that would be a valid implementation of a C compiler.<br>
<p>
What it does say is that the literal 0 will create a null pointer no matter what, but its bit pattern representation may not be 0. Conversely can have a pointer with the runtime bit pattern 0, and that doesn't necessarily make it a null pointer (and then it may be OK to dereference it)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2023 12:59 UTC (Tue)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/934011/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      The other two replies rebutting this comment are correct. The null pointer, i.e., what you get when casting integer zero to a pointer, is defined to be invalid at the C level. Quoting the spec:
<p>
<font class="QuotedText">&gt; An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.</font>
<p>
Almost every implementation of C chooses to have the null pointer be actual address zero and set things up so that nothing gets stored at actual address zero. It is precisely because the null pointer cannot point to any actual object that the implementation can arrange for actual page zero to get trapped in hardware and so it can optimize the code it generates: it can simply treat dereferencing any pointer as an unchecked hardware access. If it points to a real object, you get the real object. If it doesn't point to a real object, you must have violated the C standard at some point, and so the implementation is under no constraints. Perhaps you get a segfault, perhaps you don't, perhaps you dox some dissidents to a repressive government.
<p>
(On a side note, I think we should use this last example instead of the traditional "demons fly out of your nose," because this actually happens when people trigger undefined behavior.)
<p>
It would also be perfectly conformant for a C implementation to check every access to a pointer to see if it's null and generate a software exception at that point. It doesn't have to, but it can, because it's under no particular requirements once you dereference a null pointer, so it can choose to be helpful.
<p>
It can also choose to be particularly unhelpful. The whole reason the Linux kernel had a bunch of vulnerable code of the form
<pre>
    int foo(struct something *s) {
        int count = s-&gt;count;
        if (s == NULL)
            return -EINVAL;
        ...
    }
</pre>
is that the C compiler is under no particular requirements once you dereference a null pointer, so it can infer that because you dereferenced it on the first line, it can't possibly be null on the second line, and it can eliminate this check as dead code. So if there's indeed something mapped at page zero such that the first line doesn't fault, your explicit check for that case is gone. See <a href="https://lwn.net/Articles/342330/">this 2009 LWN discussion on this problem.</a>
<p>
Anyone writing C needs to be extremely aware of the language they write and should not make assumptions about what the C spec says based on what their compiler does today. Your compiler might do something else tomorrow. (This is why I prefer not writing C/C++ whenever possible: I understand C well enough to know that I don't understand it well enough.)
<p>
If you're on a platform where something interesting happens at address zero, you have two choices. Either you use something other than standard C (perhaps assembly, perhaps nonstandard C with some compiler extensions/flags that give you the guarantees you want), or your implementation can use some other address as the "null" pointer. At the C level it's still (void*) 0, but that doesn't have to be represented by pointer address zero.


      
          <div class="CommentReplyButton">
            <form action="/Articles/934011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2023 19:20 UTC (Tue)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/934071/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note that there's no requirement for address 0 to be hardware trapped, it's just the implementation being friendly. As long as the runtime never hands out 0 as a valid allocation the program isn't going to be able to validly dereference 0. Supposedly on the VAX address zero used to happen to be readable and guaranteed to contain 0, resulting in a pile of non-portable C programs that sloppily treated NULL as a pointer to an empty string in places...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2023 16:14 UTC (Thu)
                               by <b>Andreaskem</b> (guest, #103995)
                              [<a href="/Articles/934807/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For my day job, I work on software written for IBM's AIX OS. This nightmare of an operating system does not segfault on reads from a NULL-pointer (and quite a few bytes starting from NULL. Could be a whole page but I never checked). Instead, you get NUL bytes. Consequently, portability issues are legion. Also, you can accidentally mishandle pointers for quite a while before you get a crash, usually on the first write access. So, NULL pointer bugs can quickly become extremely confusing.<br>
Among the many, many reasons to hate AIX, this is one of the most prominent.<br>
<p>
How this OS ist still alive and kicking (for liberal definitions of the term alive) is beyond me. Old systems have incredible amounts of inertia.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2023 20:10 UTC (Thu)
                               by <b>fest3er</b> (guest, #60379)
                              [<a href="/Articles/934824/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
DEC-10: address 0 is accumulator (register) 0. It is possible to write a program in the accumulators; the shortest such program is "XCT 0" in AC0 (do nothing really fast).<br>
<p>
Of course, few people program DEC-10s/DEC-20s these days.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor934848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2023 2:02 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/934848/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From Linux fortune cookie: "Whip me. Beat me. Make me maintain AIX."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor933924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 19:09 UTC (Mon)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/933924/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The real problem, I'd argue, is the fact that the UNIX file descriptor API has the rule that syscalls that return file descriptors (open, socket, accept, pipe etc.) must return the lowest unused file descriptor.<br>
<p>
This has two subtleties. The first is a security concern with the fact that 0, 1, and 2 are "special" to userspace: you can run a setuid program without one of those file descriptors open and potentially trick it into writing some privileged file. The attack works as follows: first, the program opens some file for writing, and because of the "lowest unused" rule, it gets assigned fd 1 or 2. Second, you provide some input to the program that causes it to print an error message, perhaps with an attacker-controlled substring (e.g., "Argument %s is invalid"). Then the error message gets written to fd 1 or 2, and now the privileged file has attacker-controlled garbage in it. For file formats like crontabs that are newline-delimited and ignore unparseable lines, this gets you privilege escalation. Because standard userspace libraries like libc often do print errors to stderr or stdout, this is hard to protect against on a case-by-case basis.<br>
<p>
Some OSes (e.g., OpenBSD) protect against this by opening /dev/null on any unused FDs in the 0-2 range when execing a setuid program. As far as I can tell, Linux does not (but maybe I'm missing something...). This behavior is permitted in POSIX.1-2001, but not before.<br>
<p>
The second subtlety is that this requires a process-wide lock on the file descriptor table or some equivalent form of synchronization. If two threads in the same process call something like open (or, more likely, accept) at the same time, they have to serialize with each other because they are both bound to pick the lowest unused fd. See section 7 of <a href="https://people.csail.mit.edu/nickolai/papers/clements-sc.pdf">https://people.csail.mit.edu/nickolai/papers/clements-sc.pdf</a> which has a good chart showing opens-per-second-per-core tanking as the number of cores increases, and on a research OS with an O_ANYFD option that simply returns some unused file descriptor, opens-per-second-per-core staying basically constant. (The io_uring folks have run into this scaling problem too and have introduced per-ring "direct descriptors" to avoid interacting with the process-wide FD table: <a href="https://lwn.net/Articles/863071/">https://lwn.net/Articles/863071/</a>)<br>
<p>
Also, it's not even clear that this rule even makes any sense. Libraries are, I believe, permitted to open file descriptors and even threads on their own. They certainly do in practice, and even pure libc calls like getpwnam can cause file descriptors to get opened and perhaps left open. Furthermore, signals can hit at any time (and libraries can and do register signal handlers on their own), and a bunch of syscalls that return new fds, like open, are async-signal-safe. And POSIX specifies the library-level interface, not the system-call-level interface, so it doesn't really help that the kernel guarantees this behavior for a particular ordering of syscalls. So it's not clear you can reliably take advantage of this POSIX promise.<br>
<p>
If I had a magic wand of breaking backwards compatibility, I would specify two things: first, that any operation that gets you a file gets you some unused file descriptor, not the lowest one, and second, that it will _never_ get you file descriptors 0 through 2. If you want to reopen an stdio file descriptor, you have to explicitly dup2 over the file descriptor you want. A simple close(1); open("file.txt") will no longer work.<br>
<p>
(Yes, this would likely break the userspace ABI of select, which can only handle a limited maximum file descriptor. If I had a magic wand, I'd get rid of that too.)<br>
<p>
If you had this rule, then fd 0 would already be somewhat special from the kernel's point of view, and in particular you could never get into a case where a normal operation returned you a file descriptor of 0 and you wanted to use it. You'd have to dup2 onto fd 0 on purpose, by convention for stdin, and it would make sense for APIs like this one that take paths to say, no reasonable path is ever going to be at fd 0.<br>
<p>
(If I had a more powerful magic wand, I would make the current working directory fixed file descriptor 3, and the current root directory fixed file descriptor 4 with kernel-side restrictions on unprivileged processes changing it, and implement chdir and chroot as library calls.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 20:41 UTC (Mon)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/933940/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; and second, that it will _never_ get you file descriptors 0 through 2. If you want to reopen an stdio file descriptor, you have to explicitly dup2 over the file descriptor you want</span><br>
<p>
That requires an extra syscall. If we were to ignore backwards compatibility, I would propose making any syscall that creates a file descriptor take a descriptor number as argument, overwrite that descriptor (as though with dup3), and if you pass -1 *then* it picks an arbitrary unused one.<br>
<p>
That said, another way to avoid that syscall would be to just use io_uring: submit one batch of operations that creates a file descriptor and then installs it into a specific file descriptor number in your process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 21:07 UTC (Mon)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/933945/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would hope there aren't any use cases where replacing stdio is so high-throughput that you can't deal with an additional syscall. :) <br>
<p>
But I don't think it really does require another syscall - dup2() implicitly closes the target file descriptor. So you replace close(1); open("log.txt", O_WRONLY) with int fd = open("log.txt", O_WRONLY); dup2(fd, 1).<br>
<p>
(And if this is in the world where the lowest-unused-FD rule is gone, then we've probably actually gained a bit of performance, because you can avoid at least one lock.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2023 15:21 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/934051/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You also need close(fd) though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2023 23:44 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/934095/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oops, good point. Though for the specific case of redirecting stdio between fork and exec, I think you can get away with int fd = open("log.txt", O_WRONLY | O_CLOEXEC); dup2(fd, 1); as dup2 is specified as not setting the cloexec flag on the new fd.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor933967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2023 6:05 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/933967/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Those "magic wand" ideas sound intriguing. If the kernel had a debug kconfig menu full of experiments like this, I'd try them all out to see what breaks. I already turn on some of the assorted hardening options (and broke boot at least once doing it :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2023 16:24 UTC (Tue)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/934062/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This should be easy for fork and random pids where there is no requirement to return the lowest/next one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2023 18:42 UTC (Thu)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/934257/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Some OSes (e.g., OpenBSD) protect against this by opening /dev/null on any unused FDs in the 0-2 range when execing a setuid program. As far as I can tell, Linux does not (but maybe I'm missing something...). This behavior is permitted in POSIX.1-2001, but not before.</span><br>
<p>
Linux does it as well for setuid/setgid, as far as I know.   It is too bad it is not done for *everything* by default though (with a way to override it to allow for closed FDs 0-2 on execve(), just in case).<br>
<p>
I am not sure the Linux kernel can actually change the default behavior here for non-set*id programs.  It *is* bound to break *something*, somewhere :-(<br>
<p>
Personally, I would actually welcome such a change (maybe with a execve() flag that allows the old behavior), as long as it could be toggled system-wide at first, so that we get a chance to fix the few that actually need FD 0-2 closed on execve() before enabling it by default everywhere.<br>
<p>
And $deity help you with CLOSE ON EXEC enabled on whatever is sitting on FDs 0-2, when whatever gets execve()'d is not explicitly prepared for that...<br>
<p>
Now, even if it can't be done by the kernel, the libc certainly could, especially when any of its standard stream functions or headers are referenced.   That said, you get no help from, e.g. glibc. It is the opposite, actually.<br>
<p>
I add something to the effect of the C code below to every C application (and call it as the *first* thing the application does), to avoid the whole Undefined Behavior you get out of the libc *and* $random third-party libraries when FDs 0-2 are closed on program start:<br>
<p>
static int is_valid_fd(const int fd)<br>
{<br>
return fcntl(fd, F_GETFD) != -1 || errno != EBADF;<br>
}<br>
<p>
static void fix_fds(const int fd, const int fl)<br>
{<br>
int nfd;<br>
<p>
if (is_valid_fd(fd))<br>
return;<br>
<p>
nfd = open("/dev/null", fl);<br>
if (nfd == -1 || dup2(nfd, fd) == -1) {<br>
exit(EXIT_FAILURE);<br>
}<br>
if (nfd != fd)<br>
close(nfd);<br>
}<br>
<p>
static void sanitize_std_fds(void)<br>
{<br>
/* do it in file descriptor numerical order! */<br>
fix_fds(STDIN_FILENO,  O_RDONLY);<br>
fix_fds(STDOUT_FILENO, O_WRONLY);<br>
fix_fds(STDERR_FILENO, O_RDWR);<br>
}<br>
<p>
Note: it is probably a lot safer in the long run to trust open() and dup2() sanity, than *anything* from &lt;stdio.h&gt;, and in fact, AFAIK you cannot trust glibc freopen(): I have a note down somewhere that glibc's freopen() will screw things up if you try it on a stream that has a closed FD, and that FD is what open() would return (i.e. the first available FD).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2023 12:19 UTC (Fri)
                               by <b>TheJH</b> (subscriber, #101155)
                              [<a href="/Articles/934293/">Link</a>] 
      </p>
      
      </div>
      </summary>
      That's not the kernel's doing, it happens in the libc. From glibc's csu/libc-start.c:
<pre><code>
  /* Some security at this point.  Prevent starting a SUID binary where
     the standard file descriptors are not opened.  We have to do this
     only for statically linked applications since otherwise the dynamic
     loader did the work already.  */
  if (__builtin_expect (__libc_enable_secure, 0))
    __libc_check_standard_fds ();
</code></pre>

From glibc's sysdeps/unix/sysv/linux/dl-sysdep.c:
<pre><code>
  /* If this is a SUID program we make sure that FDs 0, 1, and 2 are
     allocated.  If necessary we are doing it ourself.  If it is not
     possible we stop the program.  */
  if (__builtin_expect (__libc_enable_secure, 0))
    __libc_check_standard_fds ();
</code></pre>


      
          <div class="CommentReplyButton">
            <form action="/Articles/934293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor934363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2023 15:57 UTC (Sat)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/934363/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For completeness, breaking the "lowest unused fd" rule has been proposed before: <a href="https://lwn.net/Articles/236843/">https://lwn.net/Articles/236843/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor941419"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The problem is the lowest-unused-file-descriptor rule</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2023 8:40 UTC (Mon)
                               by <b>Aissen</b> (subscriber, #59976)
                              [<a href="/Articles/941419/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; first, the program opens some file for writing</span><br>
<p>
AFAIU, one cannot open a regular file for writing without access permission on it. Most permissions on regular file fds are only checked at open time, which is one of the reasons fd-passing (via fork/exec or SCM_RIGHTS) is a useful thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941419/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor933946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2023 21:00 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/933946/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the file descriptors _is_ magic. Rust uses it to make a niche, which is why I cared about it recently.<br>
<p>
Where POSIX calls return a file descriptor, it says that's a C integer where -1 signifies an error, as a result -1 can't be a valid file descriptor, and so Rust's OwnedFd and BorrowedFd mark this as a niche, meaning Option&lt;OwnedFd&gt; is a 32-bit value, with the underlying bit patterns 0 through 0xFFFFFFFE being Some(file_descriptor) and 0xFFFFFFFF as None<br>
<p>
This use of niches for sentinels really appeals to me, but alas for now in stable Rust it's only available to the standard library, as giving types a niche is a perma-unstable feature today, and the long term is supposedly Pattern Types instead of stabilising the existing feature, which are a big complicated piece of work where even a "Please where do I help?" got no feedback.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2023 14:31 UTC (Tue)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/934046/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought all negative numbers were (indirectly) defined to be non-fds? In which case it goes something like this:<br>
<p>
* 0: conventionally stdin<br>
* 1: conventionally stdout<br>
* 2: conventionally stderr<br>
* 3 to INT_MAX inclusive: other file descriptors<br>
* INT_MIN to -1 inclusive: reserved non-file-descriptors<br>
<p>
(AT_FDCWD is -100, at least on Linux.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor934267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Special file descriptors in BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2023 21:14 UTC (Thu)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/934267/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_166">https://pubs.opengroup.org/onlinepubs/9699919799/basedefs...</a><br>
<p>
So yeah, pretty much what you wrote.<br>
<p>
I'd add that you never use anything else than "-1" for a sentinel value to mean "invalid FD".  As you mentioned, other negative values than "-1" might have special meaning for some syscall or library function, like AT_FDCWD for openat() and friends.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/934267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
