        <!DOCTYPE html>
        <html lang="en">
        <head><title>Glibc and the kernel user-space API [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/534682/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/533892/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/534682/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Glibc and the kernel user-space API</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Michael Kerrisk</b><br>January 30, 2013</br>
           </div>
<p> We are accustomed to thinking of a system call as
being a direct service request to the kernel. However, in reality, most
system call invocations are mediated by wrapper functions in the GNU C
library (glibc). These wrapper functions eliminate work that the programmer
would otherwise need to do in order to employ a system call. But it turns
out that glibc does not provide wrapper functions for all system calls,
including a few that see somewhat frequent use. The question of what (if
anything) to do about this situation has arisen a few times in the last few
months on the libc-alpha mailing list, and has recently surfaced once more.

<p>

<p> A system call allows a program to request a service&mdash;for example,
open a file or create a new process&mdash;from the kernel. At the assembler
level, making a system call requires the caller to
assign the unique system call number and the argument values to particular
registers, and then execute a special instruction (e.g., SYSENTER on modern
x86 architectures) that switches the processor to kernel mode to execute
the system-call handling code. Upon return, the kernel places the system
call's result status into a particular register and executes a special
instruction (e.g., SYSEXIT on x86) that returns the processor to user
mode. The usual convention for the result status is that a non-negative
value means success, while a negative value means failure. A negative
result status is the negated error number (<tt>errno</tt>) that indicates
the cause of the failure.

<p> All of the details of making a system call are normally hidden from the
user by the C library, which provides a corresponding wrapper function and
header file definitions for most system calls. The wrapper function accepts
the system call arguments as function arguments on the stack, initializes
registers using those arguments, and executes the assembler instruction
that switches to kernel mode. When the kernel returns control to user mode,
the wrapper function examines the result status, assigns the (negated)
error number to <tt>errno</tt> in the case of a negative result, and
returns either -1 to indicate an error or the non-negative result status as
the return value of the wrapper function. In many cases, the wrapper
function is quite simple, performing only the steps just described. (In
those cases, the wrapper is actually autogenerated from
<tt>syscalls.list</tt> files in the glibc source that tabulate the types
of each system call's return value and arguments.)  However, in a few cases
the wrapper function may do some extra work such as repackaging arguments
or maintaining some state information inside the C library.

<p> The C library thus acts as a kind of gatekeeper on the API that the kernel
presents to user space. Until the C library provides a wrapper function,
along with suitable header files that define the calling signature and any
constant and structure definitions used by the system call, users must
do some manual work to make a system call. 

<p> That manual work includes defining the structures and constants needed
by the system call and then invoking the <tt>syscall()</tt> library
function, which handles the details of making the system call&mdash;copying
arguments to registers, switching to kernel mode, and then setting
<tt>errno</tt> once the kernel returns control to user space. Any system
call can be invoked in this manner, including those for which the C library
already provides a wrapper. Thus for example, one can bypass the wrapper
function for <tt>read()</tt> and invoke the system call directly by
writing:

<pre>
    nread = syscall(SYS_read, fd, buf, len);
</pre>

<p> The first argument to <tt>syscall()</tt> is the number of the system
call to be invoked; <tt>SYS_read</tt> is a constant whose
definition is provided by including <tt>&lt;unistd.h&gt;</tt>

<p> The C library used by most Linux developers is of course the GNU C
library. Normally, glibc tracks kernel system call changes quite
closely, adding wrapper functions and suitable header file definitions to
the library as new system calls are added to the kernel. Thus, manually
coding system calls is normally only needed when trying to use the
latest system calls that have not yet appeared in the most recent iteration
of glibc's six-month release cycle or when using a recent kernel on a
system that has a significantly older version of glibc.

<p> However, for some system calls, glibc support never appears.  The
question of how the decision is made on whether to support a particular
system call in glibc has once again become a topic of discussion on the
libc-alpha mailing list. The most recent discussion started when Kees Cook,
the implementer of the recently added
<a href="/Articles/519010/"><tt>finit_module()</tt></a> system call, <a
href="/Articles/534788/">submitted</a> a rudimentary patch to add glibc
support for the system call. In response, Joseph Myers and Mike Frysinger
noted various pieces that were missing from the patch, with Joseph
 <a href="/Articles/534789/">adding</a> that "<q>in the
kexec_load discussion last May / June, doubts were expressed about whether
some existing module-related syscalls really should have had functions in
glibc.</q>"

<p> The module-related system calls&mdash;<tt>init_module()</tt>,
<tt>delete_module()</tt>, and so on&mdash;are among those for which glibc
does not provide support. The situation is in fact slightly more complex
in the case of these system calls: glibc does not provide any header file
support for these system calls but does, through an accident of history,
export a wrapper function ABI for the calls.

<p> The earlier discussion that Joseph referred to took place when
Maximilian Attems attempted to add a header file to glibc to provide
support for the <tt>kexec_load()</tt> system call, <a
href="/Articles/534890/">stating</a> that his aim was "<q>to axe the
syscall maze in kexec-tools itself and have this syscall supported in
glibc.</q>" One of the primary glibc maintainers, Roland McGrath, <a
href="/Articles/534792/">had a rather different take</a> on the
necessity of such a change, stating "<q>I'm not really convinced this
is worthwhile.  Calling 'syscall' seems quite sufficient for such arcane
and rarely-used calls.</q>" In other words, adding support for these
system calls clutters the glibc ABI and requires (a small amount of) extra
code in order to satisfy the needs of a handful of users who could just use
the <tt>syscall()</tt> mechanism.

<p> Andreas Jaeger, who had reviewed earlier versions of Maximilian's
patch, <a href="/Articles/534799/">noted</a> that
"<q>linux/syscalls.list already [has] similar esoteric syscalls like
create_module without any header support. I wouldn't object to do this for
kexec_load as well</q>". Roland <a href="/Articles/534800/">agreed</a>
that the <tt>kexec_load()</tt> system call is a similar case, but felt that
this point wasn't quite germane, since adding the module system calls to
the glibc ABI was a "dubious" historical step that can't be reversed for
compatibility reasons.


<p> But in the recent discussion of <tt>finit_module()</tt>, Mike Frysinger
<a href="/Articles/534806/">spoke</a> in favor of adding full glibc support
for module-related system calls such as <tt>init_module()</tt>.  Dave
Miller <a href="/Articles/534846/">made a similar argument</a> even more
succinctly:




<div class="BigQuote">

It makes no sense for every tool that wants to support
doing things with kernel modules to do the syscall()
thing, propagating potential errors in argument signatures
into more than one location instead of getting it right in
one canonical place, libc.

</div>

<p>
In other words, employing <tt>syscall()</tt> can be error prone: there is
no checking of argument types nor even checking that sufficient arguments
have been passed.

<p> Joseph Myers <a href="/Articles/534807/">felt</a> that the earlier
<tt>kexec_load()</tt> discussions hadn't fully settled the issue, and was
interested in having some concrete data on how many system calls don't have
glibc wrappers. Your editor subsequently donned his man-pages maintainer
hat and grepped the man pages in section 2 to determine which system calls
do not have full glibc support in the form of a wrapper function and header
files. The <a href="/Articles/534852/">resulting list</a> turns out to be
quite long, running to nearly 40 Linux system calls.  However, the
story is not quite so simple, since some of those system calls are obsolete
(e.g., <tt>tkill()</tt>, <tt>sysctl()</tt>, and <tt>query_module()</tt>)
and others are intended for use only by the kernel or glibc (e.g.,
<tt>restart_syscall()</tt>). Yet others have wrappers in the C library,
although the wrappers have a significantly different names and provide some
piece of extra functionality on top of the system call (e.g., <tt>
rt_sigqueueinfo()</tt> has a wrapper in the form of the <tt>sigqueue()</tt>
library function). Clearly, no wrapper is required for those system calls,
and once they are excluded there remain  perhaps 15 to 20 system calls
that might be candidates to have glibc support added.

<p> Motohiro Kosaki <a href="/Articles/534855/">considered</a> that the
remaining system calls could be separated into two categories: those with
only one or a few applications uses and those that seemed to him to have
more widespread application use. Motohiro was agnostic about whether
the former category (which includes the module-related system calls,
<tt>kcmp()</tt>, and <tt>kcmp_load()</tt>) required a wrapper. However, in
his opinion the system calls in the latter category (which includes system
calls such as <tt>ioprio_set()</tt>, <tt>ioprio_get()</tt>, and
<tt>gettid()</tt>) clearly merited having full glibc support.

<p> The lack of glibc support for <tt>gettid()</tt>, which returns the
caller's kernel thread ID, is an especially noteworthy case. A
long-standing glibc <a
href="http://sourceware.org/bugzilla/show_bug.cgi?id=6399">bug report</a>
requesting that glibc add support for this system gained little traction
with the previous glibc maintainer. However, excluding that system call is
rather anomalous, since it is quite frequently used and the kernel exposes
thread IDs via various <tt>/proc</tt> interfaces, and glibc exposes various
kernel APIs that can employ kernel thread IDs (for example,
<tt>sched_setaffinity()</tt>, <tt>fcntl()</tt>, and the
<tt>SIGEV_THREAD_ID</tt> notification mode for POSIX timers).


<p> The discussion has petered out in the last few days, despite Mike
Frysinger's attempt to further push the debate along by reading and
summarizing the various pro and contra arguments in <a
href="/Articles/534868/">a single email</a>. As noted by various
participants in the discussion, adding glibc wrappers for some currently
unsupported system calls would seem to have some worthwhile benefits. It
would also help to avoid the confusing situation where programmers
sometimes end up searching for a glibc wrapper function and header file
definitions that don't exist. It remains to be seen whether these arguments
will be sufficient to persuade Roland in the face of his concerns about
cluttering the glibc ABI and adding extra code to the library for the
benefit of what he believes is a relatively small number of users.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-User-space_ABI">Development model/User-space ABI</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/534682/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor535181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 16:23 UTC (Wed)
                               by <b>justincormack</b> (subscriber, #70439)
                              [<a href="/Articles/535181/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are other issues with the syscall(2) interface too, like having to split up 64 bit arguments manually on 32 bit architectures.<br>
<p>
And the documentation in man(2) is very schizophrenic, as it is sometimes about the syscall and sometimes about the glibc interface or quirks. Ideally there should be entries in man 2 and man 3 for some more calls (or all of them?).<br>
<p>
Sometimes glibc makes very odd decisions, like caching the output of getpid() so it returns the incorrect value if you call clone(2) yourself.<br>
<p>
Sometimes however there can be useful bug fixes, and lots of compatibility wrappers which are useful. But again documentation in man 3 would be useful...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535186"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 16:30 UTC (Wed)
                               by <b>glandium</b> (guest, #46059)
                              [<a href="/Articles/535186/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There are other issues with the syscall(2) interface too, like having to split up 64 bit arguments manually on 32 bit architectures.</font><br>
<p>
Or having to handle different ways to pass arguments for syscalls with a lot of them on some architectures.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535186/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor535325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 0:09 UTC (Thu)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/535325/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
<font color="purple">
And the documentation in man(2) is very schizophrenic, as it is sometimes about the syscall and sometimes about the glibc interface or quirks. Ideally there should be entries in man 2 and man 3 for some more calls (or all of them?).
</font>
</blockquote>

<p>
There's some relevant thoughts about this 
<a rel="nofollow" href="http://www.kernel.org/doc/man-pages/todo.html#migrate_to_kernel_source">here</a>.
The main point is that the user shouldn't (as far as I am concerned) need to consult two pages to get the information they need.
      
          <div class="CommentReplyButton">
            <form action="/Articles/535325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor535416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 15:22 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/535416/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, there really ought to be a separate section (2s?) to document the actual kernel syscall.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 6:17 UTC (Fri)
                               by <b>vapier</b> (guest, #15768)
                              [<a href="/Articles/535566/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
section 2 is the standard location for syscalls (or rather, for the ABI the kernel provides).  but the contention isn't the location, it's splitting information across two pages for end developers (section 2 and section 3).  mkerrisk posted a link that explains a bit more.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 11:37 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/535608/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm aware what sections 2 and 3 are traditionally for. However, you can have "sub-sections", indicated by a letter suffix on the section. E.g. several sections have POSIX specific sub-sections. Compare "man 1 sh" to "man 1p sh", or "man nan" to "man 3p nan".<br>
<p>
There's no reason you couldn't have a "k" sub-section (so "2k" and/or "3k"), to document kernel specific things about programming interfaces. There's no reason why you can't have *both* a glibc and Linux kernel specific version for a man-page.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2013 22:19 UTC (Sat)
                               by <b>vapier</b> (guest, #15768)
                              [<a href="/Articles/535885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
using subsections instead of the proper (and already standardized) main sections doesn't address the stated concern in any way<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor535189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 16:46 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/535189/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From the article, quoting Dave Miller:<br>
<p>
<font class="QuotedText">&gt; It makes no sense for every tool that wants to support doing things with kernel modules to do the syscall() thing, propagating potential errors in argument signatures into more than one location instead of getting it right in one canonical place, libc.</font><br>
<p>
Does that canonical place have to be libc though?  Why not e.g. some liblinux which could live in the kernel source tree?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 17:59 UTC (Wed)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/535215/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do we even really need a library ?<br>
A header file with the proper macro wrappers set and prototype should be sufficient.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor535236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 18:31 UTC (Wed)
                               by <b>samroberts</b> (subscriber, #46749)
                              [<a href="/Articles/535236/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wasn't there an article in the last year about the kernel perhaps including a userspace library as a part of it's source? That seems a decent place to put "raw" syscall wrappers.<br>
<p>
I think C callable functions with prototypes would offer better type-checking than macros that generate syscall(), and one reason to NOT use syscall directly is to get the arg types correct.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 19:14 UTC (Wed)
                               by <b>kpfleming</b> (subscriber, #23250)
                              [<a href="/Articles/535251/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A header file with the appropriate 'static inline' functions would serve this purpose nicely; it doesn't need to be compiled and distributed as a library, but the function calls are type-checked and can be written more easily than preprocessor macros.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 21:48 UTC (Wed)
                               by <b>justincormack</b> (subscriber, #70439)
                              [<a href="/Articles/535300/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You would have to namespace them though, as they mainly have the same names as existing libc functions...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 23:41 UTC (Wed)
                               by <b>and</b> (guest, #2883)
                              [<a href="/Articles/535321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You would have to namespace them though, as they mainly have the same names as existing libc functions...</font><br>
<p>
The same is true if you would use macros<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor535327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 1:19 UTC (Thu)
                               by <b>skissane</b> (subscriber, #38675)
                              [<a href="/Articles/535327/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Officially GNU LibC is not just to support the Linux kernel, but other kernels as well. Of course, in reality Linux is the main kernel it gets used with, but the portability is a nice idea to maintain.
<p>
This suggests it is useful to distinguish new functionality into two groups:
<ol><li>functions that another kernel could well implement, even if no other kernel does so right now; functionality that could potentially be standardised as part of SUS/POSIX, even if it isn't right now</li>
<li>functionality which is inherently very kernel-specific, and while other kernels may provide the functionality, they are likely to do so with rather different API designs. These kinds of functions are unlikely to ever be standardised, and there is little value in providing cross-kernel APIs for them</li></ol>
<p>
I think module loading, kexec, etc., really belong to group (2). That then suggests, that these functions don't belong in LibC, but instead in some separate Linux-specific library or header file (a "liblinux").
      
          <div class="CommentReplyButton">
            <form action="/Articles/535327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535338"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 3:36 UTC (Thu)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/535338/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I'm no software engineer it seems to be that there are inherent complexities and inefficiencies in trying to abstract away non-standard features and in preventing them from being used in the main body of code, to be relegated to a separate support library.  You can't pervasively make full use of possibly useful features because you have to support more impoverished environments which might not have the feature, or might have the feature but with a highly incompatible API.  If you try to use the local APIs of each OS then you may end up with a different implementation for each OS, wrapped in ifdefs.<br>
<p>
I think there is a real debate that should happen to figure out where the best place is to draw the lines for cross platform compatibility.  Should one use the OpenBSD model where there is a core project that takes full advantage of all the OpenBSD-only features along with a separate project for porting that to other systems.  What about the rest of user space, of desktops, where should things be tied to the particular OS by using OS features and where should things be designed for the lowest common denominator, or where is it acceptable to provide multiple implementations with ifdef.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535338/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor535410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 14:26 UTC (Thu)
                               by <b>bkw1a</b> (subscriber, #4101)
                              [<a href="/Articles/535410/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm currently experimenting with the Ceph distributed filesystem, which can make use of "syncfs" if it's available.  I'm running a kernel that supports syncfs (The ElRepo kernel-ml-3.7.5-1), but on a distribution (CentOS 6.3) that doesn't have a glibc that knows about this function.  It would be nifty if the kernel came with a "liblinux" that implemented things like this, instead of the daunting (non-starter, really) prospect of upgrading to a new glibc just to get syncfs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor535219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2013 18:09 UTC (Wed)
                               by <b>jwarnica</b> (subscriber, #27492)
                              [<a href="/Articles/535219/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Forgive my ignorance in the details of shared objects... but why would GlibC not include these (more obscure) syscalls in some auxiliary library? One which has a disclaimer like "this is guaranteed to break, but is better than nothing, STFU".<br>
<p>
Or maybe then the discussion would just go from "exist?", to "promote to supported?".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 0:01 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/535526/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the argument is that it's more trouble than it's worth. That is, more time and anxiety is spent providing the wrapper than that spent by the few people actually using the syscall writing their own wrapper. It's not so much about maintenance, but the upfront work and pile of junk wrappers.<br>
<p>
Writing your own wrapper is utterly trivial, unless you're a masochist and are intent on supporting multi-arch systems. For syscalls like gettid, there's absolutely nothing wrong with just writing syscall(SYS_gettid). It can even be cleaner if you're writing portable apps, because you can just `#ifdef SYS_gettid', rather than testing for the existence of glibc or __linux, or having to bring autotools into the equation (if it's not already).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor535615"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 12:06 UTC (Fri)
                               by <b>bgoglin</b> (subscriber, #7800)
                              [<a href="/Articles/535615/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All numa related syscalls are also missing in glibc (mbind, move_pages, migrate_pages). You have to link with libnuma to get them even when you don't use the libnuma API.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535615/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor536711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glibc and the kernel user-space API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2013 11:30 UTC (Thu)
                               by <b>pebolle</b> (guest, #35204)
                              [<a href="/Articles/536711/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
0) It's is interesting that this article mentions Maximilian Attems attempt to add a header file to glibc. Because directly after that attempt he submitted the patch that became mainline commit 29a5c67e7a78815fda0567a867adce467f6e6e5a ("kexec: export kexec.h to user space"): <a rel="nofollow" href="https://lkml.org/lkml/2012/5/24/107">https://lkml.org/lkml/2012/5/24/107</a>.<br>
<p>
1) As a result of that commit include/uapi/linux/kexec.h now exports a declaration of kexec_load(). But this declaration doesn't come with a matching definition of that function, so it doesn't help much to include kexec.h if one wants to use kexec_load().<br>
<p>
2) The patch ended up in the mainline tree without any discussion, as far as I can tell. A previous attempt, two years earlier, did generate discussion but didn't end up in mainline: <a rel="nofollow" href="https://lkml.org/lkml/2010/6/19/106">https://lkml.org/lkml/2010/6/19/106</a>. Note that this earlier attempt didn't export a declaration of kexec_load(). <br>
<p>
3) I noticed all that because ever since v3.5 (which shipped that commit) the headers_check utility complains about kexec.h:<br>
    [...]include/linux/kexec.h:49: userspace cannot reference function or variable defined in the kernel<br>
<p>
(This warning isn't entirely correct, of course, as there is no matching definition of kexec_load() in the kernel tree.)<br>
<p>
3) To me it seems this declaration of kexec_load() in kexec.h should be dropped. It serves no real purpose. Am I correct?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/536711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
