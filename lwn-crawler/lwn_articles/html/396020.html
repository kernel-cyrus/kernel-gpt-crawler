        <!DOCTYPE html>
        <html lang="en">
        <head><title>A brief history of union mounts [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/396020/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/395458/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/396020/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A brief history of union mounts</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>July 14, 2010</p>
           <p>This article was contributed by Valerie Aurora</p>
           </div>
<p>
Several weeks ago, I mentioned on my blog that I
planned <a href="http://valerieaurora.wordpress.com/2010/06/14/moving-out-of-san-francisco-and-programming/">to
move out of programming</a> in the near future.  A few days later I
received this email from a kernel hacker friend:
</p>

<div class="BigQuote">
<p>
At first, I thought we were losing a great hacker... But
then I read on your blog: "Don't worry, I'm going to get union mounts
into mainline before I change careers," and I realized this means
you'll be with us for a few years yet! :)
</p>
</div>

<p>
How long has union mounts existed without going into the mainline
Linux kernel?  Well, to put it in a human perspective, if you'd been
born the same year as the first Linux implementation of union mounts,
you'd be writing your college application essays right now.  Werner
Almsberger began work on
the Inheriting
File System, one of the early ancestors of Linux union mounts, in
1993 - 17 years ago!
</p>

<h4>Background</h4>

<p>
A union mount does the opposite of a normal mount: Instead of hiding
the namespace of the file system covered by the new mount, it shows a
combination of the namespaces of the unioned file systems.  Some use
cases include a writable live CD/DVD-based system (without a
complicated mess of symbolic links, bind mounts, and writable
directories), and a shared base file system used by multiple clients.
For an extremely detailed review of unioning file systems in general,
see the LWN series:
</p>

<ul>
<p>
<li> <a href="http://lwn.net/Articles/324291/">Unioning file systems:
    Architecture, features, and design</a>
<p>
<li> <a href="http://lwn.net/Articles/325369/">Unioning file systems:
    Union directories and mounts</a>
<p>
<li> <a href="http://lwn.net/Articles/327738/">Unioning file systems:
    unionfs and aufs</a>
</ul>

<p>
This article will provide a high-level overview of various
implementations of union mounts from the original 1993 Inheriting File
System through the present day VFS-based union mount implementation
and plans for near-term development.  We deliberately leave aside
unionfs, aufs, and other non-VFS implementations of unioning, in large
part because the probability of merging a non-VFS unioning file system
into mainline appears to be even lower than that of a VFS-based
solution.
</p>

<h4><tt>readdir()</tt> redux</h4>

Throughout this article, we will place special emphasis on the
evolution of <tt>readdir()</tt>, since historically it has been the
greatest stumbling block for any implementation of union mounts.  A
summary from the first article in the LWN unioning file systems
series:
</p>

<div class="BigQuote">
<p>
One of the great tragedies of the UNIX file system interface is the
enshrinement
of <tt>readdir()</tt>, <tt>telldir()</tt>, <tt>seekdir()</tt>,
etc. family in the POSIX standard. An application may begin reading
directory entries and pause at any time, restarting later from the
"same" place in the directory. The kernel must give out 32-bit magic
values which allow it to restart the <tt>readdir()</tt> from the point
where it last stopped. Originally, this was implemented the same way
as positions in a file: the directory entries were stored sequentially
in a file and the number returned was the offset of the next directory
entry from the beginning of the directory. Newer file systems use more
complex schemes and the value returned is no longer a simple
offset. To support <tt>readdir()</tt>, a unioning file system must
merge the entries from lower file systems, remove duplicates and
whiteouts, and create some sort of stable mapping that allows it to
resume <tt>readdir()</tt> correctly. Support from userspace libraries
can make this easier by caching the results in user memory.
</p>
</div>

<h4>Union mounts development time line</h4>

<p>
As mentioned earlier, one of the first implementations of a unioning
was the <a href="http://icapeople.epfl.ch/almesber/ifs.html">Inheriting
File System</a>.  In a pattern to be repeated by many future
developers, Werner quickly became disenchanted with the complexity of
the implementation of IFS and stopped working on it, suggesting that
future developers try a mixed user/kernel implementation instead:
</p>

<div class="BigQuote">
<p>
Well, I completed it to the point where it was a nice proof of
concept, but still with problems (leaks inodes, probably has a few
races left, was also a bit too liberal with locking, etc.).
</p>

<p>
Then I looked back at what I did and was disgusted by its
complexity. So I decided that, before I might even consider proposing
inclusion into the mainstream kernel, I'd have to see how much poorer
(performance-wise) a user-space implementation would be. I did some
initial hacking on NFS until I convinced myself that userfs might be
the better approach. Unfortunately, I never found the time to work on that.
</p>
</div>

<p>
Many other kernel developers agreed with Werner.  One of Linus
Torvalds' <a href="http://lkml.indiana.edu/hypermail/linux/kernel/9603.1/0162.html">earliest
recorded NAKs</a> of a kernel-based union file system came in 1996:
</p>

<div class="BigQuote">
While at USENIX, I saw the _correct_ way to do a union FS. It was done
as a pre-loaded shared library, and because of that it was a lot more
flexible than any kernel implementation would ever be [...] After
having seen that, I don't think I necessarily would even want a kernel
implementation. It simply was so much better done in user space.
</div>

<p>
In 1998, Werner updated his IFS page to suggest working on
a unioning file system as a good academic research topic:
</p>

<div class="BigQuote">
<p>
Sounds like a very nice master's thesis topic for some good Linux
hacker ;-) [...] So far nobody has taken the challenge. So, if you're
an aspiring kernel hacker, aren't afraid of complexity, have a lot of
time, and are looking for an interesting but useful project, you may
just have found it :-)
</p>
</div>

<p>
Around 2003 - 2004, Jan Blunck took up the gauntlet Werner threw down
and
began <a href="http://www.linuxtag.org/2005/freecongress-details-talkid-155.html">working
on union mounts</a> for his thesis.  The union mount implementation
Jan produced lay dormant until 2007, when discussion about
merging <a href="http://en.wikipedia.org/wiki/UnionFS">unionfs</a>
into mainline

triggered <a href="http://marc.info/?l=linux-kernel&m=117524884207813">renewed interest</a> in a VFS-based version of unioning.  At
that point, Bharata B. Rao took the lead and began working with Jan
Blunck on a new version of union mounts.  Bharata and Jan posted
several versions in 2007.
</p>

<p>
The <a href="http://marc.info/?l=linux-fsdevel&m=117681527820133">first
version posted</a> in April 2007 used Jan's original strategy of keeping two
pointers in the dentry for each directory, one pointing to the
directory below this dentry's in the union stack, and one to the
dentry of the topmost directory.  The drawback to this implementation
is that each file system can only be in one union stack at a time,
since dentries are shared between all mounts of the same underlying
file system.
</p>

<p>
The <a href="http://marc.info/?l=linux-fsdevel&m=117913503200362">second
version posted</a> in May 2007 implemented yet another minor variation on
in-kernel <tt>readdir()</tt>, this time using per file pointer cookies.  From
the patch set's documentation:
</p>

<div class="BigQuote">
<p>
When two processes issue <tt>readdir()</tt>/<tt>getdents()</tt> call
on the same unioned directory, both of them would be referring to the
same dentries via their file structures. So it becomes necessary to
maintain rdstate separately for these two instances. This is achieved
by using a cookie variable in the rdstate. Each of these rdstate
instances would get a different cookie thereby differentiating them.
</p>
</div>

<p>
In June 2007, Bharata and
Jan <a href="http://marc.info/?l=linux-fsdevel&m=118231827024394">posted
a third version</a> with an important and novel change to the way
union stacks are formed.  They replaced the in-dentry links to the
topmost and lower directories with an external structure of pointers
to (vfsmount, dentry) pairs.  For the first time, a file system could
be part of more than one union mount.  From the patch set's
documentation:
</p>

<div class="BigQuote">
<p>
In this new approach, the way union stack is built and traversed has
been changed. Instead of dentry-to-dentry links forming the stack
between different layers, we now have (vfsmount, dentry) pairs as the
building blocks of the union stack. Since this (vfsmount, dentry)
combination is unique across all namespaces, we should be able to
maintain the union stack sanely even if the filesystem is union
mounted privately in different namespaces or if it appears under
different mounts due to various types of bind mounts.
</p>
</div>

<p>
In July 2007, Jan
<a href="http://marc.info/?l=linux-fsdevel&m=118581230916874">posted
a fourth version</a> with some relatively minor changes to the way
whiteouts were implemented, among a few other things.  Jan says,
"<q>I'm able to compile the kernel with this patches applied on a 3
layer union mount with the [separate] layers bind mounted to different
locations. I haven't done any performance tests since I think there is
a more important topic ahead: better <tt>readdir()</tt> support.</q>"
</p>

<p>
In December 2007, Bharata B. 
Rao <a href="http://marc.info/?l=linux-fsdevel&m=119686559720586">posted
a fifth version</a> that implemented another in-kernel version
of <tt>readdir()</tt>:
</p>

<div class="BigQuote">
<p>
In this approach, the cached dirents are given offsets in the form of
linearly increasing indices/cookies (like 0, 1, 2,...). This helps us
to uniformly define offsets across all the directories of the union
irrespective of the type of filesystem involved. Also this is needed
to define a seek behaviour on the union mounted directory. This cache
is stored as part of the struct file of the topmost directory of the
union and will remain as long as the directory is kept open.
</p>
</div>

<p>
However, this approach had multiple problems, including excessive use
of kernel memory to cache directory entries and to keep the mapping of
indices to dentries.
</p>

<p>
<tt>readdir()</tt> continued to be a stumbling block, and union mounts
development slowed down for most of 2008.  In April 2008, Nagabhushan
BS implemented
and <a href="http://marc.info/?l=linux-fsdevel&m=120947680420674">posted</a>
a version of union mounts with most of the <tt>readdir()</tt> logic
moved to glibc.  "<q>I went through Bharata's RFC post on glibc
based Union Mount readdir solution
(<a href="http://lkml.org/lkml/2008/3/11/34">http://lkml.org/lkml/2008/3/11/34</a>)
and have come up with patches against glibc to implement the
same.</q>"

<p>
However, moving the complexity to user space wasn't the panacea everyone
had hoped for.  The glibc maintainers had many objections, the kernel
interface was an obvious kludge (returning whiteouts for "." to signal
a unioned directory), and no one could figure out how to handle NFS
sanely.
</p>

<p>
In November 2008, Miklos
Szeredi <a href="http://marc.info/?l=linux-fsdevel&m=122787012403963">posted</a>
a simplified version of union mounts that implemented <tt>readdir()</tt> in the
kernel.
</p>

<div class="BigQuote">
<p>
The directory entries are read starting from the top layer and they
are maintained in a cache. Subsequently when the entries from the
bottom layers of the union stack are read they are checked for
duplicates (in the cache) before being passed out to the user
space. There can be multiple calls to readdir/getdents routines for
reading the entries of a single directory.  But union directory cache
is not maintained across these calls. Instead for every call, the
previously read entries are re-read into the cache and newly read
entries are compared against these for duplicates before being they
are returned to user space.
</p>
</div>

<p>
This implementation only worked for file systems that return a simple
increasing offset in the d_off field for <tt>readdir()</tt>.  So ext2 worked,
but any file system with a modern directory hashing scheme did not.
</p>

<p>
In early 2009, I started to get interested in union mounts.  I talked
to several groups inside Red Hat and asked them what they needed most
from file systems.  I heard the same story over and over: "<q>We
really really need a unioning file system, but for some reason no one
at Red Hat will support unionfs...</q>" I did some research on the
available implementations and decided to go to work on Jan Blunck's
union mount patch set.
</p>

<p>
In May 2009, Jan Blunck and
I <a href="http://marc.info/?l=linux-fsdevel&m=124266382908872">posted</a>
a version of union mounts that implemented
in-kernel <tt>readdir()</tt> using a new concept: the fallthru
directory entry.  The basic idea is that the first
time <tt>readdir()</tt> is called on a directory, the visible
directory entries from all the underlying directories are copied up to
the topmost directory as fallthru directory entries.  This eliminated
all the problems I knew of in previous <tt>readdir()</tt>
implementations, but required the topmost file system to always be
read-write.  This implementation also was limited to only two layers:
one read-only file system overlaid with one read-write file system
because we were concerned with lock ordering problems.
</p>

<p>
In October 2009,
I <a href="http://marc.info/?l=linux-fsdevel&m=125615355718507">posted</a>
a version of union mounts that implemented some of the more difficult
system calls, such as <tt>truncate()</tt>, <tt>pivot_root()</tt>,
and <tt>rename()</tt>.  However, implementing <tt>chmod()</tt> and
other system calls that modified files without opening them turned out
to be fairly difficult with the current code base.  We thought the
hard part was copying up file data
in <tt>open()</tt>, <tt>rename</tt>, and <tt>link()</tt>, but it
turned out they were somewhat easier to implement because they already
looked up the parent directory of the file to be altered.  For union
mounts, we need the parent directory's
<tt>dentry</tt> and <tt>vfsmount</tt> in order to create a new version
of the file in the topmost level of the union file system if
necessary.  <tt>open()</tt>, <tt>rename</tt>, and <tt>link()</tt> also
needed the parent directory in order to create new directory entries,
so we just reused the parent in the union mount in-kernel copyup code.
But system calls like <tt>chmod()</tt> that only alter existing files
did not bother to lookup the parent directory's path, only the
target.  Regretfully, I decided to start on a major rewrite.
</p>

<p>
In March 2010,
I <a href="http://marc.info/?l=linux-fsdevel&m=126756790019402">posted</a>
a rewrite of the pathname lookup mechanism for union mounts, taking
into account Al Viro's recent VFS cleanups and removing a great deal
of unnecessary code duplication.
</p>

<p>
In May 2010,
I <a href="http://marc.info/?l=linux-fsdevel&m=127292910632750">
posted</a> the first version of union mounts that implemented nearly
all file related system calls correctly.  The four exceptions
were <tt>fchmod()</tt>, <tt>fchown()</tt>, <tt>fsetxattr()</tt>,
and <tt>futimensat()</tt>, which will fail on read-only file
descriptors. (UNIX is full of surprises; none of the VFS experts I
talked to knew that these system calls would succeed on a read-only
fd.)
</p>

<p>
The central primitive in this version is a function
called <tt>user_path_nd()</tt>.  It is a combination
of <tt>user_path()</tt>, which looks up a pathname and returns the
corresponding dentry and vfsmount, and <tt>user_path_parent()</tt>,
which looks up the parent directory of the file or directory given by
the pathname and returns the <tt>struct nameidata</tt> for the parent. (<tt>struct
nameidata</tt> is too complex to describe in full here, but suffice to say
it is usually needed to create an entry in a
directory.) <tt>user_path_nd()</tt> returns both the parent's
<tt>nameidata</tt> and the child's path.  Once we have both these pieces of
information, we can do an in-kernel copyup of a file
in <tt>chmod()</tt> or any other system call that modifies a file.
Unfortunately, <tt>user_path_nd()</tt> is also the weakest point in
this version of union mounts: it's racy, inefficient, and copies up
files even if the system call fails.
</p>

<p>
The day after I posted that version, I flew to North Carolina for a
long-anticipated in-person code review with Al Viro.  We spent three
days in his office painfully reviewing the entire union
mount implementation.  Al immediately figured out how to delete a
third of the code I'd spent the last year carefully massaging, and
then outlined how to rewrite the other two-thirds of the code more
elegantly, including <tt>user_path_nd()</tt>.  As a result of this
code review marathon, Linux has a feature-complete implementation of
union mounts that has undergone a full code review by the Linux VFS
maintainer for the first time.  Of course, the resulting todo list is
long and complex, and some problems may turn out to be insoluble, but
it's an important step forward.
</p>

<p>
The biggest design change Al suggested was to move the head of the
union stack back into the dentry, while keeping the rest of the union
stack in a singly linked list of <tt>struct union_dir</tt>'s allocated
external to the dentries for the read-only parts of the union stack.
This combines the speed and elegance of Jan Blunck's original
design using in-dentry pointers to the union
stack, with the flexibility of Bharata B. Rao's <tt>(vfsmount,
dentry)</tt> pairs, which allow file systems to be part of many
read-only layers.  This change removed the entire union stack hash
table and the associated lookup logic and shrunk
the <tt>union_dir</tt> struct from 7 members to 2.
I <a href="http://marc.info/?l=linux-fsdevel&m=127662792813470">posted</a>
this hybrid linked list version on June 15, 2010.
</p>

<p>
Most recently, on June 25th, 2010,
I <a href="http://marc.info/?l=linux-fsdevel&m=127749275818612">posted</a>
a version that implemented submounts in the read-only layers, as well
as allowed more than two read-only layers again.  Then I went on a two
week vacation - the longest vacation I've had since I started working
on union mounts - and tried to forget everything I knew about it.
</p>

<h4>Future Work</h4>

<p>
The next step is to implement the remainder of Al Viro's review
comments.  The last big-ticket item is
rewriting <tt>user_path_nd()</tt> and the in-kernel file copyup
boilerplate.  After that, it's back for another round of code review
from Al and the other VFS maintainers.  The 2010 Linux Storage and
File Systems workshop is in early August.  With luck we can hash out
any remaining architectural problems face-to-face at the workshop and
possibly merge union mounts into mainline before it's old enough to
vote.  Or it might languish for another 17 years outside the kernel.
Such are the vicissitudes of Linux kernel development.
</p>

<p>
Acknowledgments: I want to extend special thanks to the following
people: Kevin Roderick, who provided moral support, Tim Bowen, who
gave me a free day at the
<a href="http://www.spoke6.com">Spoke6 co-working space</a> while I
worked on this article, and, of course, Jake Edge, whose editorial
suggestions were, as usual, right on.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Union">Filesystems/Union</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Union_mounts">Union mounts</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Aurora_Valerie">Aurora, Valerie</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/396020/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor396106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 10:16 UTC (Thu)
                               by <b>aakef</b> (subscriber, #38030)
                              [<a href="/Articles/396106/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Somehow I find it amazing to spent so much time on the kernel implementation. <br>
In February 2007 I spent about 2 weeks on unionfs-fuse to add copy-on-write and it was then suitable for my needs. <br>
I still spend some of my spare free time on it to improve it, but this seems to be nothing compared to to the kernel union mount efforts. Pity that we cannot combine our work. Using a kernel solution somehow seems to be more an ideological decision than rational. Yes, I agree, unionfs-fuse is slow for some operations, but now lets assume we would spend some time on it to improve that...<br>
<p>
Cheers,<br>
Bernd<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 14:09 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/396141/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did unionfs-fuse work with NFS? Note: NFS needs seekdir()/telldir() to work, and that's the hard part. Last I heard, you couldn't NFS-export fuse filesystems (though that may well have changed now, Miklos improves fuse so fast that whenever I look at it all my previous complaints have vanished...)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 19:26 UTC (Thu)
                               by <b>aakef</b> (subscriber, #38030)
                              [<a href="/Articles/396215/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It works fine if you use unfs3 and probably also knfsd will partly work. In order to get knfsd properly working, we would need to switch to the low-level fuse interface (presently not on my TODO list).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor396187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 17:39 UTC (Thu)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/396187/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe unionfs-fuse has been tried for Debian and/or Ubuntu live-CDs and was found to be too slow to be usable. Currently they are both using aufs but they will probably switch to Val's implementation when it's done.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396212"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 19:24 UTC (Thu)
                               by <b>aakef</b> (subscriber, #38030)
                              [<a href="/Articles/396212/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I know that performance needs to be increased and it is on my TODO list for the 2nd next version. However, you really have to compare how much time Radek and I spent on unionfs-fuse compared to the kernel attempts. It is just a lack of my time to bring it into the state where I would like to have it...<br>
But then also on the other hand, I use unionfs-fuse my own self-made ubuntu live usb sticks and I don't see any difference in boot time and application load time between usb-stick vs. usb-stick + unionfs-fuse. I have not tried it on high speed SSDs yet (I simply don't have any).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396212/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor396942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2010 12:03 UTC (Thu)
                               by <b>obi</b> (guest, #5784)
                              [<a href="/Articles/396942/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
One of the great tragedies of the UNIX file system interface is the enshrinement of readdir(), telldir(), seekdir(), etc. family in the POSIX standard...
</blockquote>

<p>I keep hearing how POSIX is broken in myriad ways; see for instance the recent discussion about locking at <a rel="nofollow" href="http://0pointer.de/blog/projects/locking.html">Lennart Poettering's blog</a>.</p>

<p>Maybe we should start keeping a record of all these "Great Tragedies of POSIX". So maybe one day we can do something about it. Or are we really stuck with POSIX for all eternity?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/396942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396961"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2010 13:43 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/396961/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, we need "Why POSIX made the Editor Grumpy".  It could be a nice long series - with lots of guest editors probably.<br>
<p>
But telldir/seekdir isn't something that POSIX got wrong.  Maybe the cookie size (32bit) is a bit small, but that is as easy to overcome as the Y2K038 bug.<br>
<p>
Either you require readdir to return all the entries in a directory in one hit, or you need a stable pointer into the directory so you can ask for the 'next' chunk.<br>
The stable pointer doesn't *have* to be exposed to user-space, but if you are going to have any hope of supporting a network filesystem like NFS, then it has to be exposed to the network protocol, so it has to exist.<br>
<p>
It isn't hard to design a directory layout which allows stable indexes - it just requires a bit of fore-thought.<br>
<p>
It *is* hard to synthesis such pointers from a union of two directories as you cannot predict or control the pointers you get from each.  However it is possible to create a stable solution.<br>
<p>
Given that the current union-mount proposal requires "white-out" objects to be created in the on-top filessytem to make objects from the below filesystem disappear, it would not be unreasonable to instead require 'white-in' objects which make objects from the below filesystem appear.<br>
<p>
This would require a 'copy-up' of the directory when it is read (though more typically, when the directory is changed) which is a bit more harsh than the 'copy-up' that is required of files on e.g. a chmod.  But it would give reliable semantics and in many real cases would not be a real burden.<br>
<p>
To be a little more explicit:  The common case with union mount is (I expect) that you union-mount an empty filesystem on top of a read-only filesystem, and then make changes.  Each time you make changes in a new directory you need would to copy-up that directory and all parents that have not yet been copied-up.  The copy-up involves creating a white-in object in the top directory for each object in the bottom.  (It is a little more complicated than white-out as you want to store the 'DT_*' type of the underlying object).  Then further changes simply happen to the top level directory.<br>
A readdir simply uses the top-level directory.<br>
Any lookup which hits a white-in object (or name) continues the lookup in the underlying filesystem.<br>
<p>
(unfortunately the margin is too small to contain my elegant implementation....)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396961/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2010 21:20 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/397073/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
It could be a nice long series - with lots of guest editors probably.
</blockquote>
Hell yes. And the suck extends to fairly simple areas. Just saying 'EINTR' and 'short reads' is enough to make anyone who's ever written even a trivial C program on a Unix platform wince. (What do you mean I need a horrible-looking for loop to read a file reliably?!)

      
          <div class="CommentReplyButton">
            <form action="/Articles/397073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2010 2:51 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/397113/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
??  You don't get EINTR on read from a regular file - only pipes, sockets, char devices and similar things.<br>
<p>
But in general I agree - signals make it very hard to write correct programs.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397269"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2010 18:16 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/397269/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You do get EINTR on read from a regular file if you're unlucky enough to have that file on a network device (e.g. NFS with intr turned on). And before you say 'don't do that then', before very recently we had a choice of turning intr on or losing the whole mount point and very shortly afterwards often the whole machine if the network went down. (And, yes, I have encountered both short reads and EINTR in NFS-based regular file reads on both Linux and Solaris. So it does happen.)<br>
<p>
(Also, POSIX doesn't ban getting EINTR on reads from a regular file, so prudence dictates expecting it.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397269/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2010 4:20 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/397289/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fair point, though that is really an NFS issue rather than a general Posix issue.  And NFS has a lot more than just that to answer for.<br>
<p>
Posix has a concept of 'slow' and 'not slow' reads where 'slow' reads can result in a short read or EINTR, and disk IO is explcitly not a slow read.  So if your file is on disk you cannot get EINTR.<br>
I guess being on disk on another machine doesn't count. :-(<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor398273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2010 20:27 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/398273/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've heard this over and over again, but I've looked through the POSIX specs and I can't find it. No mention of slow reads, no mention that some devices are guaranteed not to get EINTR, no mention in the rationale either.<br>
<p>
Now perhaps this is a de facto universal implementation detail, but as far as I can see it isn't in POSIX itself. (Maybe I just haven't looked in the right place?)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/398273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor398312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2010 10:01 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/398312/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems you are right.<br>
<p>
<a href="http://www.opengroup.org/onlinepubs/9699919799/functions/read.html">http://www.opengroup.org/onlinepubs/9699919799/functions/...</a><br>
<p>
appears to allow any read to be interrupted, and says in the "informative" section "The issue of which files or file types are interruptible is considered an implementation design issue. This is often affected primarily by hardware and reliability issues." which is singularly unhelpful.<br>
<p>
I was basing my statements on "man 7 signal" which does talk about "slow" devices.  Clearly this isn't normative....<br>
<p>
As you say, POSIX by itself is enough to make one wince...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/398312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor398750"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2010 22:45 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/398750/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite so :/<br>
<p>
Even 'man 7 signal' says clearly that 'The details vary across Unix systems; below, the details for Linux', and that's not terribly useful really for the vast majority of software. (I suppose you can rely on it in mdadm ;} )<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/398750/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor397215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2010 20:01 UTC (Fri)
                               by <b>vaurora</b> (guest, #38407)
                              [<a href="/Articles/397215/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent idea - you've just described fallthru dentries. :)<br>
<p>
The implementation of fallthrus is pretty small, around a hundred lines in main VFS and then you reuse the whiteout infrastructure in the client file systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2010 2:10 UTC (Sat)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/397238/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Excellent idea - you've just described fallthru dentries. :)</font><br>
<p>
Yes.... after writing that I went back through the original article, noticed 'fallthru' this time, and felt a bit sheepish.<br>
<p>
I don't quite see either how you would implement fallthru using whiteout though, or why you would still want whiteout if you were using copy-up + fallthru..<br>
<p>
It is a pity that a block-based COW solution is so inefficent - it is such a simple solution that would address many of the use-cases (not the NFS-as-underlying-filesystem case of course).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor397288"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2010 4:18 UTC (Sun)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/397288/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Sure, POSIX has flaws. But at least it's not Win32. When you're frustrated by POSIX, take a deep breath and say that three times.
<p>
In the free world, there's no <a href="http://msdn.microsoft.com/en-us/library/ms687025%28v=VS.85%29.aspx">arbitrary 64-handle wait limit</a>. You can rename and delete filenames while the files they point to are still open. Shared libraries are versioned. You have a variety of fork and spawn options instead of the horror that is CreateProcess. You have a real pty interface --- it's impossible to emulate a win32 console, or even make isatty do the right thing.
<p>
You don't have eldrich horrors like <a href="http://msdn.microsoft.com/en-us/library/ms741513%28VS.85%29.aspx">WSAAcceptEx</a>. The kernel doesn't <a href="http://msdn.microsoft.com/en-us/library/ms681951%28VS.85%29.aspx">steal your threads to do its own book-keeping</a>. For the love of god, you don't have <a href="http://msdn.microsoft.com/en-us/library/ms682437%28VS.85%29.aspx">CreateRemoteThread</a>. IO redirection actually works --- programs seldom open /dev/tty directly, unlike the Windows world, where the canonical way to get colored output is to write it directly to the console buffer.
<p>
In POSIXland, you don't have drive letters. You don't need to be root to create a symlink. And you don't use backslashes for directory separators. (At least most Windows software accepts forward slashes too.) <code>/dev/null</code> exists only in <code>/dev</code>; you can create a file called "null" anywhere else. Try creating a file called "prn" anywhere on a Windows system.
<p>
Best of all, in POSIXland, programs accept a true vector of command-line arguments. In Windows, each program receives one string that's actually the <i>whole command line</i> and uses its own quoting and wildcard rules to interpret it. Naturally, this approach yields wildly unpredictable results.
<p>
So, of course POSIX can be improved. But it's hardly "broken in myriad ways" ; you can only say that from a position of merciful privilege.
      
          <div class="CommentReplyButton">
            <form action="/Articles/397288/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2010 7:11 UTC (Sun)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/397295/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great post!  A little perspective can be nice at times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor398276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A brief history of union mounts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2010 20:41 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/398276/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's notable how many of those faults are *completely unchanged* from the days I was doing DOS, back in the DOS 3.3 days.<br>
<p>
MS really has strangled itself in the name of backward compatibility with a broken original system. Sure, we try to be compatible with older Unixes, but at least Unix was a sane base to build on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/398276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
