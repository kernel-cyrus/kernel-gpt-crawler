        <!DOCTYPE html>
        <html lang="en">
        <head><title>GPIO in the kernel: an introduction [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/532714/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/532269/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/532714/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>GPIO in the kernel: an introduction</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 16, 2013</br>
           </div>
A GPIO (general-purpose I/O) device looks like the most boring sort of
peripheral that a computer might offer.  It is a single electrical signal
that the CPU can either set to one of two values — zero or one,
naturally — or read one of those values from (or both).
Either way, a GPIO does not seem like a particularly expressive device.
But, at their simplest, GPIOs can be used to control LEDs, reset lines, or
pod-bay door locks.  With additional "bit-banging" logic, GPIOs can be
combined to implement higher-level protocols like <a
href="https://en.wikipedia.org/wiki/I%C2%B2C">i2c</a> or <a 
href="https://en.wikipedia.org/wiki/Display_Data_Channel">DDC</a> 
 — a frequent
occurrence on contemporary systems.  GPIOs are thus useful in a lot of
contexts. 
<p>
GPIO lines seem to be especially prevalent in embedded systems; even so,
there never seems to be enough of them.  As one might expect, a system with
dozens (or even hundreds) of GPIOs needs some sort of rational abstraction
for managing them.  The kernel has had such a mechanism
since 2.6.21 (it was initially added by David Brownell).  The API has
changed surprisingly little since then, but that period of relative stasis
may be about to come about to an end.  The intended changes are best
understood in the context of the existing API, though, so that is what this
article will cover.  Subsequent installments will look at how the GPIO API
may evolve in the near future.
<p>
Naturally, there is an include file for working with GPIOs:
<p>
<pre>
    #include &lt;linux/gpio.h&gt;
</pre>
<p>
In current kernels, every GPIO in the system is represented by a simple
unsigned integer.  There is no provision for somehow mapping a desired
function ("the sensor power line for the first camera device," say) onto a
GPIO number; the code must come by that knowledge by other means.  Often
that is done through a long series of macro definitions; it is also
possible to pass GPIO numbers through platform data or a device tree.  
<p>
GPIOs must be allocated before use, though the current implementation does
not enforce this requirement.  The basic allocation function is:
<p>
<pre>
    int gpio_request(unsigned int gpio, const char *label);
</pre>
<p>
The <tt>gpio</tt> parameter indicates which GPIO is required, while <tt>label</tt>
associates a string with it that can later appear in sysfs.  The usual
convention applies: a zero return code indicates success; otherwise the
return value will be a
negative error number.  A GPIO can be returned to the system with:
<p>
<pre>
    void gpio_free(unsigned int gpio);
</pre>
<p>
There are some variants of these functions; <tt>gpio_request_one()</tt> can
be used to set the initial configuration of the GPIO, and
<tt>gpio_request_array()</tt> can request and configure a whole set of
GPIOs with a single call.  There are also "managed" versions
(<tt>devm_gpio_request()</tt>, for example) that automatically handle
cleanup if the developer forgets.
<p>
Some GPIOs are used for output, others for input.  A suitably-wired GPIO
can be used in either mode, though only one direction is active at any
given time.  Kernel code must inform the GPIO core of how a line is
to be used; that is done with these functions:
<p>
<pre>
    int gpio_direction_input(unsigned int gpio);
    int gpio_direction_output(unsigned int gpio, int value);
</pre>
<p>
In either case, <tt>gpio</tt> is the GPIO number.  In the output case, the
value of the GPIO (zero or one) must also be specified; the GPIO will be set accordingly
as part of the call.  For both functions, the return value is again zero or
a negative error number.  The direction of (suitably capable) GPIOs can be
changed at any time.
<p>
For input GPIOs, the current value can be read with:
<p>
<pre>
    int gpio_get_value(unsigned int gpio);
</pre>
<p>
This function returns the value of the provided <tt>gpio</tt>; it has no
provision for returning an error code.  It is assumed (correctly in almost
all cases) that any errors will be found when
<tt>gpio_direction_input()</tt> is called, so checking the return value
from that function is important.
<p>
Setting the value of output GPIOs can always be done using
<tt>gpio_direction_output()</tt>, but, if the GPIO is known to be in
output mode already, <tt>gpio_set_value()</tt> may be a bit more efficient:
<p>
<pre>
    void gpio_set_value(unsigned int gpio, int value);
</pre>
<p>
Some GPIO controllers can generate interrupts when an input GPIO changes
value.  In such cases, code wishing to handle such interrupts should start
by determining which IRQ number is associated with a given GPIO line:
<p>
<pre>
    int gpio_to_irq(unsigned int gpio);
</pre>
<p>
The given <tt>gpio</tt> must have been obtained with
<tt>gpio_request()</tt> and put into the input mode first.  If there is an
associated interrupt number, it will be passed back as the return value
from <tt>gpio_to_irq()</tt>; otherwise a negative error number will be
returned.  Once obtained in this manner, the interrupt number can be passed
to <tt>request_irq()</tt> to set up the handling of the interrupt.
<p>
Finally, the GPIO subsystem is able to represent GPIO lines via a sysfs
hierarchy, allowing user space to query (and possibly modify) them.  Kernel
code can cause a specific GPIO to appear in sysfs with:
<p>
<pre>
    int gpio_export(unsigned int gpio, bool direction_may_change);
</pre>
<p>
The <tt>direction_may_change</tt> parameter controls whether user space is
allowed to change the direction of the GPIO; in many cases, allowing that
control would be asking for bad things to happen to the system as a whole.
A GPIO can be removed from sysfs with <tt>gpio_unexport()</tt> or given
another name with <tt>gpio_export_link()</tt>.
<p>
And that is an overview of the kernel's low-level GPIO interface.  A number
of details have naturally been left out; see <a
href="/Articles/532717/">Documentation/gpio.txt</a> for a more thorough
description.  Also omitted is the low-level driver's side of the API, by
which GPIO lines can be made available to the GPIO subsystem; covering that
API may be the subject of a future article.  The next installment, though,
will look at a couple of perceived deficiencies in the above-described API
and how they might be remedied.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#General-purpose_IO">General-purpose I/O</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#GPIO">GPIO</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/532714/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor532909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2013 9:19 UTC (Thu)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/532909/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fun that you're diggin into this Jon, I have just had a presentation for the ELC accepted where I try to give an overview of recent changes in GPIO and pinctrl.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/532909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor533002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2013 18:12 UTC (Thu)
                               by <b>dougg</b> (guest, #1894)
                              [<a href="/Articles/533002/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here is a view from the trenches of the Linux gpio subsystem, seen from the Atmel AT91 family, specifically the AT91SAM9x5 sub-family.<br>
<p>
The biggest mistake was introduced initially: using a single sequence of kernel gpio numbers to represent a two level hierarchy. For example the AT91SAM9G20 has 3 banks: PA0-31, PB0-31 and PC0-31. For some crazy reason (something about not interfering with interrupt numbers) they mapped PA0 to 32 and the gpio numbers followed in sequence from there (hence PC31 is 127). Well sanity finally prevailed and around lk 3.5 they remapped PA0 to 0. Great, lots of user space code to rewrite.<br>
<p>
And in lk 3.8.0-rc1 they were at it again. A gpio pin that had a sysfs name of /sys/class/gpio/gpio32 suddenly became /sys/class/gpio/pioB0 . Well that's a better name but why not use /sys/class/gpio/pb0 so as to agree with Atmel's naming (apart from capitalisation)?? And more user space code needs to be rewritten.<br>
<p>
Back around lk 2.6.28 they removed a gpio pass-through driver leaving sysfs as (almost) the only way to get to gpios. I say almost because for serious work with AT91s mmap() is your friend. With luck in lk 3.9 we might get a well-designed block gpio driver so it will probably get vetoed or bowdlerized.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/533002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor533276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2013 23:58 UTC (Fri)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/533276/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It sounds like your concern is accessing GPIOs from userspace, but I thought the primary intended consumer of this particular ABI was kernel drivers, and that accessing GPIOs via /sys was intended just for debugging, in lieu of a proper driver for the hardware you're playing with.

<p>Then again, <a href="http://www.kernel.org/doc/Documentation/gpio.txt">Documentation/gpio.txt</a> does claim that "for some tasks, simple userspace GPIO drivers could be all that the system really needs", which at least suggests that it should be considered a production API.  So complaints about API breakes are probably worth bringing up when they happen.
      
          <div class="CommentReplyButton">
            <form action="/Articles/533276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor532920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2013 11:25 UTC (Thu)
                               by <b>notti</b> (subscriber, #67230)
                              [<a href="/Articles/532920/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you missed the value in the gpio_set_value function<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/532920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor532930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2013 13:05 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/532930/">Link</a>] 
      </p>
      
      </div>
      </summary>
      That's a little embarrassing...and I rechecked all those prototypes.  Fixed, thanks.
      
          <div class="CommentReplyButton">
            <form action="/Articles/532930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor533066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2013 21:08 UTC (Thu)
                               by <b>zuki</b> (subscriber, #41808)
                              [<a href="/Articles/533066/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Frankly I don't see the point of such a stub of an article. It would be better to have all three instalments now, and nothing for two weeks, then to be teased like that.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/533066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor533160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2013 8:44 UTC (Fri)
                               by <b>russell</b> (guest, #10458)
                              [<a href="/Articles/533160/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Everyone thinks GPIO is easy, and that probably explains why the interfaces are incomplete.  GPIO usually has a lot more functionality than can be accessed.<br>
<p>
1. GPIO can be both output and input at the same time.  Yep you may want to read back the value of an output.  MCUs I've used in the past offered this.  After all output are really just stronger versions of the pull up/down :)<br>
<p>
2. GPIO have pull up/down resistors.<br>
<p>
3. And this is the BIG one.  GPIO has state BEFORE the kernel boots.  Bootstrap code can set the state of GPIO during the first few cycles of operation.  This can eliminate the need for extra external hardware.  However, the kernel blows this away and you have to wait for userspace to boot before you get control!!!!  This behaviour on for example RPi required extra hardware to be added to the circuit to prevent this kind of transient boot behaviour from glitching relays.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/533160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor533170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2013 11:50 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/533170/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; GPIO can be both output and input at the same time</font><br>
<p>
Reading back output GPIO is described in Documentation/gpio.txt<br>
My main problem is that people (even software manager responsible of software "quality") do think it is clean to use the C preprocessor, either in C or C++.<br>
That leads to massive amount of #define, to define the address, the value when active, the value when inactive, the shift position for each GPIO and the mask for that GPIO (you never know if the mask is shifted or not).<br>
Then you have a set of GPIO to represent a 3 bit value, and the preprocessor will never tell you that you are trying to write 0x15 in this 3 bit value.<br>
Also those quality specialists tell you to use the macro:<br>
#define IOWRITE32BYTE(addr, val) *((volatile unsigned *)(addr)) = (val)<br>
(Hint: try to write the same addr twice with a newer compiler).<br>
Anyway on newer architecture, those are memory mapped and IHMO it is a lot cleaner to use C to declare them:<br>
volatile struct my_IO_s {<br>
#ifdef BIG_ENDIAN<br>
   enum { healthy, fail } power_state : 1;<br>
   unsigned power_active : 1;<br>
#else<br>
   unsigned power_active : 1;<br>
   enum { healthy, fail } power_state : 1;<br>
#endif<br>
} * const my_IO = (volatile struct my_IO_s *)0xDC002000;<br>
Instead of pages and pages of #define.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/533170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor533280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2013 0:33 UTC (Sat)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/533280/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Also those quality specialists tell you to use the macro:<br>
#define IOWRITE32BYTE(addr, val) *((volatile unsigned *)(addr)) = (val)<br>
(Hint: try to write the same addr twice with a newer compiler).
</blockquote>

<p>The volatile should ensure that both writes occur in that case.

<blockquote>
Anyway on newer architecture, those are memory mapped and IHMO it is a lot cleaner to use C to declare them:<br>
volatile struct my_IO_s {<br>
  enum { healthy, fail } power_state : 1;<br>
  unsigned power_active : 1;<br>
} * const my_IO = (volatile struct my_IO_s *)0xDC002000;<br>
Instead of pages and pages of #define.
</blockquote>

<p>
I agree, and I do the same in embedded development, but it's not perfect.  The three biggest problems:

<ul>
<li>You lose control over the access size.  It can vary between compilers, compiler versions, architectures, and even ABIs for particular architectures.  For example, see <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=23623">GCC bug #23623</a>

<li>They don't map well to unusual registers.  Consider an interrupt flag register which behaves like:
<pre>
    read 0: interrupt has not occurred
    read 1: interrupt has occurred
    write 0: no action
    write 1: clear interrupt flag
</pre>

To clear a flag, you can't just do:

<pre>
    my_IO->timer_interrupt = 1;
</pre>

because this can become

<pre>
    tmp = *my_IO_addr | (1 &lt;&lt; TIMER_INTERRUPT_SHIFT);
    *my_IO_addr = tmp;
</pre>

Instead, you'd need to use something like:

<pre>
    *my_IO = (struct my_IO_s) {
        .timer_interrupt = 1
    };
</pre>

which is not much better than the equivalent:

<pre>
    *my_IO_addr = (1 &lt;&lt; TIMER_INTERRUPT_SHIFT);
</pre>

<li>Even for a more normal register like a GPIO port, it's quite difficult
to set two bits simultaneously with a single write.  You can't do:

<pre>
    *my_IO_addr |= (1 &lt;&lt; PIN0_SHIFT) | (1 &lt;&lt; PIN1_SHIFT);
</pre>

without something like:

<pre>
   struct my_IO_s tmp = *my_IO;
   tmp.pin0 = 1;
   tmp.pin1 = 1;
   *my_IO = tmp;
</pre>
</ul>

Really it's one of the more annoying parts of C when doing embedded development on a constrained system, as it's hard to avoid without adding some layer of performance-killing indirection (like Arduino does).
      
          <div class="CommentReplyButton">
            <form action="/Articles/533280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor533423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2013 11:36 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/533423/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; #define IOWRITE32BITS(addr, val) *((volatile unsigned *)(addr)) = (val)</font><br>
<font class="QuotedText">&gt; The volatile should ensure that both writes occur in that case.</font><br>
<p>
Last time I tried few days ago it did not work, you have to do:<br>
#define IOWRITE32BITS(addr, val) do { \<br>
  volatile unsigned *ptr = (volatile unsigned *)(addr); \<br>
  *ptr = (val); \<br>
  } while (0)<br>
<p>
<font class="QuotedText">&gt; You lose control over the access size</font><br>
<p>
Yes, I would also like to have bitfields accessed like they are declared, i.e. "char abit : 2;" accessed as a byte and "unsigned abit :2;" accessed as a 32 bits, because it is usual to have devices which cannot do short word access (lots of system on chip).<br>
<p>
<font class="QuotedText">&gt; [... using "(struct my_IO_s) {}" extension ...]</font><br>
<p>
My system is more complex than Arduino, I have arrays of structures containing other arrays in these I/O areas, and all those #define blessed by software-quality people drive me mad.<br>
#define FPGA1_FILTER_2_PARAMETER_4_ACTIVE 1<br>
How to do a loop for each filters?<br>
In short, in C or C++, unlike BASIC, the linker is made to manage addresses, the compiler manages offsets into these addresses; the C pre-processor has nothing to do there.<br>
IHMO even GPIO in the kernel shall be identified with an address, not a #define.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/533423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor533187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2013 14:42 UTC (Fri)
                               by <b>dougg</b> (guest, #1894)
                              [<a href="/Articles/533187/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To your second and third points, welcome to pinctrl introduced in lk 3.7 and 3.8 . And while you are at it, look at the device tree stuff (aka "open firmware" and hence lots of "of_" adorned names). gpio pin states can and should be set before the Linux kernel gets a look in (e.g. in uboot or earlier), and when it does the kernel should resist the temptation to set those lines to some arbitrary state.<br>
<p>
Things are moving so fast in the device tree/pinctrl area that it might be worth LWN writing another article on the subject. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/533187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor534713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2013 21:27 UTC (Mon)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/534713/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>1. GPIO can be both output and input at the same time. Yep you may want to read back the value of an output.</blockquote>
<p>Indeed this is an absolute requirement for a GPIO used as an I2C SCL line.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/534713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor533185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2013 14:20 UTC (Fri)
                               by <b>kvaml</b> (guest, #61841)
                              [<a href="/Articles/533185/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just in time to help with my new Raspberry Pi.  Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/533185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor694916"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2016 7:52 UTC (Wed)
                               by <b>codename_y</b> (guest, #109837)
                              [<a href="/Articles/694916/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi, I have tried to make a driver that utilize linux/gpio.h, but when I try to insmod it, I keep getting this error:<br>
<p>
[ 3030.112044] gpiotest: Unknown symbol gpio_direction_output (err 0)<br>
[ 3030.118537] gpiotest: Unknown symbol gpio_request (err 0)<br>
<p>
Could you give me some insight about why this happened? I have tried to find by myself but no luck so far.<br>
<p>
Thanks for your help<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/694916/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor694917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2016 8:05 UTC (Wed)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/694917/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They're EXPORT_SYMBOL_GPL - make sure that your MODULE_LICENSE tag is GPL compatible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/694917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor702486"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2016 19:12 UTC (Mon)
                               by <b>annonch</b> (guest, #111527)
                              [<a href="/Articles/702486/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it possible to register an interrupt to both falling edge and rising edge and then distinguish which case it is inside the interrupt handler?<br>
<p>
When I try to register two interrupts I get an error resource is busy, I think because it is the same irq_number (-16)<br>
<p>
When I try to register the interrupts with the IRQF_SHARED | IRQF_TRIGGER_RISING flags I get Invalid argument (-22)<br>
<p>
So I create a interrupt with flags IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING but when the interrupt is called, I want to distinguish the two conditions separately.<br>
<p>
It is an arm device with kernel 4.4.21<br>
<p>
Any advice? :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/702486/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor702487"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2016 19:27 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/702487/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is it possible to register an interrupt to both falling edge and rising edge and then distinguish which case it is inside the interrupt handler?</font><br>
<p>
Generally speaking, no. I'm not familiar with your specific platform, but typically one configures the interrupt controller to look for either a rising edge or a falling edge (or low/high level) for each input and it generates a single interrupt when that event occurs. As a result, there is no way to statically configure it to watch for both rising and falling edges.<br>
<p>
You could try dynamically reconfiguring the interrupt—set it as falling-edge in the rising-edge handler, and vice-versa—but performance would probably become an issue and you might miss some events depending on how long the handler is delayed. A better option, if you control the wiring and have a spare interrupt-capable GPIO, would be to route the same signal to two separate pins and set up a handler for each pin, one rising-edge and one falling-edge.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/702487/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor702497"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2016 22:58 UTC (Mon)
                               by <b>annonch</b> (guest, #111527)
                              [<a href="/Articles/702497/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wow thank you for the suggestion, it seems to work perfectly! I have configured an additional pin fed with the same signal and I think this method will work well for my project. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/702497/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor708922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2016 14:20 UTC (Tue)
                               by <b>bla</b> (guest, #112986)
                              [<a href="/Articles/708922/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Anything speaking against using gpio_get_value in the isr to discern between rising and falling?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/708922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor708923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2016 14:56 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/708923/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Anything speaking against using gpio_get_value in the isr to discern between rising and falling?</font><br>
<p>
The ISR will only run on the rising edge _or_ the falling edge, not both, so gpio_get_value will generally return a known result: either high for a rising-edge-triggered interrupt, or low for falling-edge.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/708923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor708999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2016 16:46 UTC (Tue)
                               by <b>bla</b> (guest, #112986)
                              [<a href="/Articles/708999/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why wouldn't IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING with request_irq work?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/708999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor709011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2016 18:28 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/709011/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why wouldn't IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING with request_irq work?</font><br>
<p>
Things may be different on ARM or x86, but in my work on embedded PowerPC targets I have yet to see an interrupt controller than can be configured to trigger on both rising and falling edges for the same signal. Typically there are four possible trigger modes, of which only one can be active at a time: rising edge, falling edge, high level, or low level.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/709011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor709015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2016 19:11 UTC (Tue)
                               by <b>bla</b> (guest, #112986)
                              [<a href="/Articles/709015/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, probably a gpio-controller/IRQ line limitation. I'll check if it works on a Raspberry (should, as Wiring has a BOTH option).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/709015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor709262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2016 11:07 UTC (Thu)
                               by <b>bla</b> (guest, #112986)
                              [<a href="/Articles/709262/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, you c a n set a combined interrupt mask and query the pin state in the ISR on an RPi, but gpio_get_value seems to have latency, which makes this approach pretty much useless in conjunction with switch bounce and the ISR time constraints. <br>
For implementing long button presses, detecting the first flank and reading the level with a thread after some delay seems to be the better approach, it also doesn't require a state change to trigger the long press signal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/709262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor709375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2016 20:05 UTC (Thu)
                               by <b>BlueLightning</b> (subscriber, #38978)
                              [<a href="/Articles/709375/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Surely the answer to switch bounce is to do the debouncing in hardware?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/709375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor709378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2016 20:32 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/709378/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But hardware debounce would require adding extra $0.02 worth of components and growing your board size by 2 square millimeters.<br>
<p>
Why spent that money on every unit when it can be done once, "for free" in software?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/709378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor709538"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 17, 2016 6:44 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/709538/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fun trivia: this is exactly what the NES Classic does. In their GPL code dump there's a kernel driver for the controller - it has the same wire protocol the Wiimote uses (internally!), but leaves the kernel to deal with all that hardware-related insanity and more.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/709538/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor714376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2017 10:36 UTC (Mon)
                               by <b>asmo</b> (guest, #114090)
                              [<a href="/Articles/714376/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
I need to use the same GPIO output in two different drivers.<br>
Is it possible to use the set of apis gpio_request/gpio_get_value/gpio_set_value in parallel in both device drivers?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/714376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor779724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2019 16:51 UTC (Wed)
                               by <b>Circuits</b> (guest, #130419)
                              [<a href="/Articles/779724/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great information! Too bad this post was made in 2013 cause I have some questions here in 2018. Is the author or another authority still using LWN.net?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/779724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor780022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GPIO in the kernel: an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2019 9:38 UTC (Mon)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/780022/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I do think the author is still using LWN.net. :) But he may be busy with other things.

      
          <div class="CommentReplyButton">
            <form action="/Articles/780022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
