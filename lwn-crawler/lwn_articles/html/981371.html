        <!DOCTYPE html>
        <html lang="en">
        <head><title>Reports from OSPM 2024, part 1 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/981371/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/981629/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/981371/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Reports from OSPM 2024, part 1</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="GAByline">
           <p>July 11, 2024</p>
           <p>This article was contributed by Giovanni Gherdovich</p>
           <hr>
<a href="/Archives/ConferenceIndex/#OS-Directed_Power-Management_Summit-2024">OSPM</a>
</div>
The sixth edition of the <a
href="https://retis.sssup.it/ospm-summit/">Power Management and Scheduling
in the Linux Kernel (OSPM) Summit</a> took place on May 30-31 2024, and was
graciously hosted by the <a href="https://www.irit.fr/en/home">Institut de
Recherche en Informatique de Toulouse (IRIT)</a> in Toulouse, France.  This
is the first of a series of articles describing the discussions held at
OSPM 2024; topics covered include latency hints, energy-aware scheduling,
ChromeOS, and user-space schedulers.
<p>
IRIT is one of the largest French joint research units (unit√© mixte de
recherche), with more than 700 collaborators and the stated mission of
placing "<q>mankind and its environment at the heart of computer
science</q>"; it is a fitting partner for a gathering of kernel developers
looking to optimize energy consumption in Linux. The list of sponsors for
the Summit doesn't end at the IRIT: it also includes <a
href="https://arm.com/">Arm</a>, <a href="https://linaro.org/">Linaro</a>,
and the <a href="https://www.santannapisa.it/en">Scuola Superiore
Sant'Anna</a> in Pisa as the host for the Summit web site.

<p>The following contains summaries of the sessions from the first
half day of the event. A recording of the entire summit is available as a
playlist on the <a
href="https://www.youtube.com/playlist?list=PLXJaBJgIrHE3g1hdEpypbFR4SHLEX6NfN"">IRIT
YouTube channel</a>.

<p>
<h4>How to set some latency hints to CFS tasks</h4>

<p>Vincent Guittot started out the summit with an attempt at
characterizing the various latency constraints that tasks may have, as a way
of directing a renewed effort toward <a href="/Articles/887842/">a
"latency-nice" interface</a>. Since the algorithm for the scheduler has
changed from completely fair scheduling (CFS) to <a
href="/Articles/925371/">EEVDF</a>, the prior discussions don't apply
anymore. He sees two main groups of tasks: those that are sensitive to
scheduling latency in one way or another, and those that aren't, but which
benefit from a longer time slice and little to no preemption.</p>

<p>Guittot raised the issue that, with EEVDF, a task's virtual runtime
doesn't account for performance variations caused by DVFS (CPU-frequency
scaling). When executing on a CPU running at a lower frequency, the task
makes less progress, yet it consumes the same amount of absolute time as
another that's running at a higher clock. He thinks that the virtual
runtime can be easily normalized and made frequency-invariant, but he's
also concerned about how this may affect the limit on lag (a measure of
under-service experienced by a task) offered by the original EEVDF
algorithm.</p>

<p>With <a href="/Articles/969062/">the latest EEVDF patches</a>,
user-space applications can set their own time slice using the <a
href="https://man7.org/linux/man-pages/man2/sched_setattr.2.html"><tt>sched_setattr()</tt></a>
system call. This puts the burden of measuring their own run time and
requesting a suitable time-slice value onto applications. When considering
an interface that allows a tighter collaboration between kernel and
applications to set an appropriate slice value, Daniel Bristot de Oliveira
observed that there isn't, as of now, a means for user space to notify the
scheduler of the end of a work cycle, which would be beneficial for those
tasks with a somewhat regular and recurrent nature. The <a
href="https://man7.org/linux/man-pages/man2/sched_yield.2.html"><tt>sched_yield()</tt></a>
system call comes close, but Peter Zijlstra would prefer adding a new
system call for that specific purpose.</p>

<p>Enrico Bini asked if it would be advantageous to group tasks in cores
according to their time granularity (time-slice length). The rationale
is that, if the scheduler mixes tasks with long and short slices, it seems
inevitable that either the long-running tasks will often be preempted, or
the short ones will experience high latency. Zijlstra agreed it would be
beneficial to incorporate this logic into the load balancer.</p>

<p>Dietmar Eggemann stressed that, whatever the latency API will turn out
to be, it is necessary to identify an agreed-upon set of benchmarks to
evaluate progress along the way. He mentioned that, in Android, many of the
ideas proposed during this session have been tested, and some turned out to
make no difference.</p>

<p>For the recording of Guittot's session on latency hints, see <a
href="https://www.youtube.com/watch?v=BI3QvJVa0IM">this video</a>.

<h4>Fixing, improving, and extending energy-aware scheduling</h4>

<p>
During the second session of the morning, Guittot identified a set of
quirks in the <a href="/Articles/749900/">energy-aware scheduling (EAS)</a>
engine that he's determined to correct. He presented data from an Arm
"three-gear" big.LITTLE CPU. The device has four "little" (slow but
energy-efficient) cores, three "mid" cores, and one "big" (fast but
energy-expensive) core.  A number of concerns came to light:
<p>
<ul class="spacylist">

<li> <b>A small task runs on a big core for no reason.</b> Consider a small,
     periodic task that needs to run quickly with more CPU time than a
     little core could provide.  A mid core would be perfect, but the big
     core is too much. It is possible to use <a
     href="/Articles/762043/">utilization clamping</a> and set a minimum
     amount of CPU power for this task to keep it off the little cores. If
     a larger task is occupying one of the mid cores, though, EAS would
     place the smaller one on the big core, even if there's a free
     mid. Guittot's proposed solution is to apply the cost of the predicted
     operating performance point (OPP) only for the runnable time of tasks,
     as reported by <a href="/Articles/531853/">PELT</a> historical data.

<li> <b>Spare CPU capacity vs. actual OPP cost.</b> At task wakeup, EAS
     picks a candidate core in each performance domain (little, mid, and
     big), according to each core's load compared to its capacity;
     Guittot argues that looking directly at the cost for the predicted OPP
     would yield better placements. Energy-model maintainer Lukasz Luba
     isn't fully convinced, as there are diminishing returns when using
     more sophisticated placement algorithms.

<li> <b>More room than spare capacity would suggest.</b> When cores report
     having no spare capacity, EAS isn't effective and the resulting
     placements can be highly imbalanced. In Guittot's example, clamping
     the maximum utilization exacerbates this condition, as cores look
     smaller than they are. Guittot pointed out that when a task has a
     utilization that is larger than the capacity of a CPU, it can be
     serviced nonetheless; it only needs to run a little longer.

<li> <b>Over-utilization scrambles all placements.</b> Imagine some kernel
     thread waking up and running for just a handful of microseconds. If
     that causes a core to cross the 80% utilization tipping point, EAS
     will be disengaged globally and the ordinary load balancer will take
     over, invalidating all previous efforts to optimize the system's power
     consumption. Guittot said that, for those cores and domains that aren't
     overutilized, it is better to continue using an energy-efficient task
     placement algorithm.

<li> <b><tt>uclamp_max</tt> prevents EAS from running often enough.</b>
     Smartphones are becoming increasingly powerful, but all that
     horsepower isn't meant to be exercised constantly. The practice is
     thus to clamp the maximum utilization of tasks, but as Guittot
     reports, this results in less-frequent wakeups, and thus fewer
     opportunities for EAS to optimize for power. Guittot intends to
     introduce the notion of misfit tasks with respect to power needs, and
     when such cases are detected, use load balancing to pull these tasks
     onto a more appropriate core.
</ul>

<p>For the recording of Guittot's session on EAS, see <a
href="https://www.youtube.com/watch?v=PHEBAyxeM_M">this video</a>.

<h4>ChromeOS and EEVDF</h4>

<p>The most important application in a ChromeOS laptop is, of course, the
Chrome web browser; Youssef Esmat described the progress he and his team
have made in integrating the EEVDF scheduler with these systems, especially
with the browser. Chrome's threads can be classified by their tolerance to
latency in three groups: user-interface-related threads, which capture user
input and need the highest priority, background threads, such as those
representing inactive tabs, which are not critical to user experience, and
everything else, sitting somewhere in between these two extremes.</p>

<p>Esmat stressed that Chrome's perceived performance depends heavily on
satisfying the latency and throughput needs of its UI threads. These have
to be serviced promptly, and at the same time are vulnerable to preemption
as they are long-running. The EEVDF algorithm is based on the assumption
that tasks, in general, don't behave like that.  Instead, it assumes that,
if a task needs to be scheduled quickly, it also completes quickly and,
conversely, if it runs for a prolonged time, it can tolerate higher
scheduling latencies.</p>

<p>
For this analysis, he compared the EEVDF scheduler with CFS, using
web-application workloads such as Google Meet and Google Docs, and
measuring input latency and percentage of dropped frames. Stock EEVDF
performed worse than CFS; Esmat discovered that quadrupling the base EEVDF
time-slice length, which defaults to 1.5ms for a two-core machine,
restored parity with CFS. The real gain came from removing the eligibility
mechanism altogether from EEVDF and scheduling only based on the deadline
value: this change would make the new scheduler outperform CFS by some 30%
in the metrics of interest. The reason for this improvement is that, with
eligibility, background threads would become eligible and preempt UI
threads before they could finish their time slice; as discussed, the quality
of Chrome's user experience depends on UI threads running until
completion.</p>

<p>Being the clear winner in the initial comparison, the version of EEVDF
with a large base time slice and no eligibility was selected for field
testing, and deployed to users for real-world comparison with CFS. The new
scheduler outperformed CFS in page-load speed (time to first content paint,
time to largest content paint) and almost all aspects of UI input latency:
key pressed, mouse pressed and touch pressed. There is one regression
though, in latency for gesture scrolling, and Esmat's team is working on
a reproducer so that the issue can be studied and solved.</p>

<p>
For the recording of Esmat's session on EEVDF benchmarking, see <a
href="https://www.youtube.com/watch?v=dxsbtjJRSm4">this video</a>.

<h4>Writing a Linux scheduler in Rust that runs in user space</h4>

<p>
Andrea Righi introduced <a
href="https://github.com/sched-ext/scx/tree/main/scheds/rust/scx_rustland
">scx_rustland</a>, a framework to write CPU schedulers for Linux that run as
user-space programs. Initially a project aimed at teaching operating
systems concepts to undergraduate students, it led Righi to appreciate the
convenience of the change/build/run workflow to modify the kernel's
behavior without rebooting.  This effort was able to prove that user-space
scheduling is not only possible, but can even reach respectable
performance, such as video gaming at 60&nbsp;frames per second while
compiling the Linux kernel at the same time. A lively discussion followed,
centered on the merits and disadvantages of Righi's and similar frameworks,
and on whether or not there's a place in Linux for something like <a
href="/Articles/974387/">sched_ext</a>, the kernel patch upon which Righi's
work is based.

<p>
Juri Lelli recalled starting out in scheduler development; after trying
both a research framework for scheduler plugins and coding his algorithms
directly in the kernel, he concluded the learning curve was the same. Righi
replied that creating schedulers in user space, in Rust, is of great appeal
for the new generation. Bristot objected that a plugin framework only
relieves developers from some implementation boilerplate, which is
definitely not the hard part of scheduler development. Esmat argued that,
for undergraduate students, there's a lot of value in quickly applying
their changes to a running Linux system; it could get them excited about
kernel development. Himadri Chhaya-Shailesh believes sched_ext will be a
great teaching aid at universities, since one can test scheduler code
without recompiling the kernel. In her experience as a lecturer, kernel
compilation takes a large part of the lab sessions.</p>

<p>Thomas Gleixner maintains that the core machinery for scheduling in
Linux isn't modular enough to expose hooks such as those added by
sched_ext, at least not without introducing large technical debt. John
Stultz asked what sched_ext is offering in terms of correctness testing for
user-provided schedulers; Righi mentioned the sched_ext watchdog, which
prevents scheduling starvation at run time. I agreed that
a generic test suite for custom schedulers would be helpful to distribution
vendors; it would facilitate the interaction during support requests,
allowing users to show that their third-party scheduler meets basic quality
standards. Christian Loehle commented on benchmark results achieved with
custom schedulers: getting, say, higher frames per second than stock Linux
in gaming, without any mention of power consumption, for example, is an
unfair comparison. Righi replied that custom schedulers can afford to be
workload-specific; reporting only the metric the scheduler set out to
optimize seems acceptable in this context.</p>

<p>For the recording of Righi's session on user-space scheduling, see <a
href="https://www.youtube.com/watch?v=HQRHo8E_4Ks">this video</a>.
<p>

[Thanks to Daniel Lezcano and Juri Lelli for proofreading this article.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Latency">Latency</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler-EEVDF">Scheduler/EEVDF</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Gherdovich_Giovanni">Gherdovich, Giovanni</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#OS-Directed_Power-Management_Summit-2024">OS-Directed Power-Management Summit/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/981371/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
