        <!DOCTYPE html>
        <html lang="en">
        <head><title>ACCESS_ONCE() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/508991/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/508218/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/508991/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>ACCESS_ONCE()</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 1, 2012</br>
           </div>
Even a casual reader of the kernel source code is likely to run into
invocations of the <tt>ACCESS_ONCE()</tt> macro eventually; there are well
over 200 of them in the current source tree.  Many such readers probably do
not stop to understand just what that macro means; a recent discussion on
the mailing list made it clear that even core kernel developers may not
have a firm idea of what it does.  Your editor was equally ignorant but
decided to fix that; the result, hopefully, is a reasonable explanation of
why <tt>ACCESS_ONCE()</tt> exists and when it must be used.
<p>
The functionality of this macro is actually well described by its name; its
purpose is to ensure that the value passed as a parameter is accessed
exactly once by the generated code.  One might well wonder why that
matters.  It comes down to the fact that the C compiler will, if not given
reasons 
to the contrary, assume that there is only one thread of execution in the
address space of the program it is compiling.  Concurrency is not
built into the C language itself, so mechanisms for dealing with concurrent
access must be built on top of the language; <tt>ACCESS_ONCE()</tt> is one
such mechanism.
<p>
Consider, for example, the following code snippet from
<tt>kernel/mutex.c</tt>:
<p>
<pre>
    for (;;) {
	struct task_struct *owner;

	owner = ACCESS_ONCE(lock-&gt;owner);
	if (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))
	    break;
 	/* ... */
</pre>
<p>

This is a small piece of the adaptive spinning code that hopes to quickly grab a
mutex once the current owner drops it, without going to sleep.  There is
much more to this <tt>for</tt> loop than has been shown here, but this code
is sufficient to show why <tt>ACCESS_ONCE()</tt> can be necessary.
<p>
Imagine for a second that the compiler in use is developed by fanatical
developers who will optimize things in every way they can.  This is not a
purely hypothetical scenario; as Paul McKenney recently <a
href="/Articles/508999/">attested</a>: "<q>I have seen the glint in
their eyes when they discuss optimization techniques that you would not
want your children to know about!</q>"  These developers might create a
compiler that concludes that, since the code in question does not actually
modify <tt>lock-&gt;owner</tt>, it is not necessary to actually fetch its
value each time through the loop.  The compiler might then rearrange the
code into something like:
<p>
<pre>
    owner = ACCESS_ONCE(lock-&gt;owner);
    for (;;) {
	if (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))
	    break;
</pre>
<p>
What the compiler has missed is the fact that <tt>lock-&gt;owner</tt> is
being changed by another thread of execution entirely.  The result is code
that will fail to notice any such changes as it executes the loop multiple
times, leading to unpleasant results.  The <tt>ACCESS_ONCE()</tt> call
prevents this optimization happening, with the result that the code
(hopefully) executes as intended.
<p>
As it happens, an optimized-out access is not the only peril that this code
could encounter.  Some processor architectures (x86, for example) are not
richly endowed with registers; on such systems, the compiler must make
careful choices regarding which values to keep in registers if it is to
generate the highest-performing code.  Specific values may be pushed out of
the register set, then pulled back in later.  Should that happen to the
mutex code above, the result could be multiple references to
<tt>lock-&gt;owner</tt>.  And <i>that</i> could cause trouble; if the
value of <tt>lock-&gt;owner</tt> changed in the middle of the loop, the
code, which is
expecting the value of its local <tt>owner</tt> variable to remain
constant, could become fatally confused.  Once 
again, the <tt>ACCESS_ONCE()</tt> invocation tells the compiler not to do
that, avoiding potential problems.
<p>
The actual implementation of <tt>ACCESS_ONCE()</tt>, found in
<tt>&lt;linux/compiler.h&gt;</tt>, is fairly straightforward:
<p>
<pre>
    #define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))
</pre>
<p>
In other words, it works by turning the relevant variable, temporarily,
into a <tt>volatile</tt> type.
<p>
Given the kinds of hazards presented by optimizing compilers, one might
well wonder why this kind of situation does not come up more often.  The
answer is that most concurrent access to data is (or certainly should be)
protected by locks.  Spinlocks and mutexes both function as optimization
barriers, meaning that they prevent optimizations on one side of the
barrier from carrying over to the other.  If code only accesses a shared
variable with the relevant lock held, and if that variable can only change
when the lock is released (and held by a different thread), the compiler
will not create subtle problems.  It is only in places where shared data is
accessed without locks (or explicit barriers) that a construct like
<tt>ACCESS_ONCE()</tt> is required.  Scalability pressures are causing the
creation of more of this type of code, but most kernel developers still
should not need to worry about <tt>ACCESS_ONCE()</tt> most of the time.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#ACCESS_ONCE">ACCESS_ONCE()</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#volatile">volatile</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/508991/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor509359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 15:16 UTC (Thu)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/509359/">Link</a>] (57 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>"Concurrency is not built into the C language itself"</blockquote>

It is in C11, but not in prior versions.

<blockquote>"Given the kinds of hazards presented by optimizing compilers, one might well wonder why this kind of situation does not come up more often."</blockquote>

I believe we typically do want compilers to optimize code, so I don't understand the negativity towards compiler optimizations in the article (nor towards the folks that write those optimizations).  If you're going to synchronize, you need to let the compiler know.  It's unrealistic to expect C/C++ compilers to find out exactly which variables might be accessed in a multi-threaded fashion, and nobody would like the performance degradation that conservative assumptions for that would cause.
      
          <div class="CommentReplyButton">
            <form action="/Articles/509359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 15:35 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/509364/">Link</a>] (38 responses)
      </p>
      
      </div>
      </summary>
      Negativity?  I certainly didn't intend any negativity.  One can say that compiler optimizations can present subtle hazards in the presence of concurrency without being negative toward optimizations in general.  We <i>like</i> optimizations; we just need a way to keep them from creating bugs.
      
          <div class="CommentReplyButton">
            <form action="/Articles/509364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509605"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 16:52 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/509605/">Link</a>] (37 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems to me the bug is in the kernel.  Either lock or lock-&gt;owner should be volatile-qualified in its declaration.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509605/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 16:55 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/509608/">Link</a>] (33 responses)
      </p>
      
      </div>
      </summary>
      Nobody said the (potential) bug was anywhere else.  But declaring that variable as volatile would deoptimize things much more than is necessary.  Rather than do that, the developers involved used <tt>ACCESS_ONCE()</tt> and things work as they should.
      
          <div class="CommentReplyButton">
            <form action="/Articles/509608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 22:00 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/509668/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; We like optimizations; we just need a way to keep them from creating bugs. </font><br>
<p>
That's what I was responding to.  As a professional compiler developer, it's really irritating to read about compilers "creating bugs" when the problem is actually with undefined, unspecified or implementation-defined behavior in the code.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 10:17 UTC (Tue)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/509988/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the problem is actually with undefined, unspecified or implementation-defined behavior in the code.</font><br>
<p>
Compiler developers (professional or otherwise) should take into account that not all developers are as aware as they of each and all language subtleties. Most compiler users use their common sense, not the language specification, to infer what the code does.<br>
<p>
If something has the potential of doing harm, and the user is perfectly capable of doing it by hand anyway if really needed, then it's best for the compiler not to do it. I believe that the case at hand is a perfect example of that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 11:40 UTC (Tue)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/509999/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; the problem is actually with undefined, unspecified or implementation-defined behavior in the code.</font><br>
<p>
<font class="QuotedText">&gt; Compiler developers (professional or otherwise) should take into account that not all developers are as aware as they of each and all language subtleties. Most compiler users use their common sense, not the language specification, to infer what the code does.</font><br>
<p>
The famous --do-what-I-mean-not-what-I-write compiler switch.<br>
<p>
It is a risky thing to do to abandon the written spec to start developing against unwritten common sense stashed in the brain of developers.<br>
<p>
This is dangerous because it assumes something that is even more difficult to achieve than making the developers know the spec by heart: it assumes that all the developers around the globe know the same part of the spec and all use it in the same, exact, consistent way.<br>
<p>
There will always be differences in the way people use tools and languages. These differences will create conflicts. I think that the best way to resolve conflicts is to point out the relevant part of the spec that dictates what to do. Yes, the spec may be not well written or ambiguous, but those are problems that can be solved. The alternative is to argue in a bug report and let the most vocal person (or the one backed by the biggest implementer) win, ignoring the fact that there may be heaps of people out there using the language in the way the less vocal debater think it should be used.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 13:31 UTC (Wed)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/510183/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The famous --do-what-I-mean-not-what-I-write compiler switch.</font><br>
<p>
That would be a good switch, yes. By default the compiler should be in --do-what-I-write-not-what-some-ambiguous-line-of-the-spec-allows-you-to-interpret, though. It would be better for everybody.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 16:51 UTC (Wed)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/510237/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That *is* the --do-what-I-mean-not-what-I-write switch.<br>
<p>
How can the compiler possibly know what you meant when you wrote something outside the language spec?<br>
<p>
Take a very simple but common issue: undefined data.  There are countless compiler analyses and transformations that mode code around, reallocate stack space, etc. that cause the undefined variable to have different (garbage) values.  What might happen to work one day most assuredly will not when compiled with a compiler 2-3 versions newer.<br>
<p>
What should the compiler do?  Disable all code motion of and around the offending expression?  That would be lunacy.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510338"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2012 3:47 UTC (Thu)
                               by <b>mmorrow</b> (guest, #83845)
                              [<a href="/Articles/510338/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Take a very simple but common issue: undefined data. There are countless compiler analyses and transformations that mode code around, reallocate stack space, etc. that cause the undefined variable to have different (garbage) values. What might happen to work one day most assuredly will not when compiled with a compiler 2-3 versions newer.
</blockquote>

A good example of this can be seen in GCC's constant propagation implem (tree-ssa-ccp.c):

<blockquote>
<pre>
/*
...
- If an argument has an UNDEFINED value, then it does not affect
  the outcome of the meet operation.  If a variable V_i has an
  UNDEFINED value, it means that either its defining statement
  hasn't been visited yet or V_i has no defining statement, in
  which case the original symbol 'V' is being used
  uninitialized. Since 'V' is a local variable, the compiler
  may assume any initial value for it.
...
*/
</pre>
</blockquote>

And we can see this in action with e.g.

<blockquote>
<pre>
size_t f(int x){size_t a; if(x) a = 42; return a;}
</pre>
</blockquote>

which gives

<blockquote>
<pre>
f:
  movl  $42, %eax
  ret
  .ident  "GCC: (GNU) 4.8.0 20120408 (experimental)"
</pre>
</blockquote>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510338/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor510542"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 7:40 UTC (Fri)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/510542/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Take a very simple but common issue: undefined data.</font><br>
<p>
Undefined data, hah. In Java it is a compilation error to use a variable that is not provably assigned in all possible code paths between declaration and use. I like this feature *a lot* and I'm always surprised that C compilers have such a great difficulty with detecting it. (The JVM verifier does this analysis as well during class loading, so it has to be *fast* as well as correct.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510542/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 14:58 UTC (Fri)
                               by <b>quanstro</b> (guest, #77996)
                              [<a href="/Articles/510583/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the claim above is that the choice is to<br>
(a) follow the standard, or<br>
(b) do something arbitrary.<br>
<p>
that is not the choice in this case.  the choice is to<br>
either<br>
(a) rearrange the code in optimization, or<br>
(b) leave it as the developer wrote it.<br>
<p>
personally, i find this sort of code reorg by compilers<br>
to be problematic as it generally makes code quite hard<br>
to reason about.  experienced developers would lift the<br>
assignment out of the loop if it mattered, and it were<br>
legal.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510602"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 15:40 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/510602/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the claim above is that the choice is to</font><br>
<font class="QuotedText">&gt; (a) follow the standard, or</font><br>
<font class="QuotedText">&gt; (b) do something arbitrary.</font><br>
<p>
This is a false choice.  (a) and (b) are the same thing in the presence of undefined/unspecified/implementation-defined behavior.  And it's not arbitrary.  It's the decision of the compiler engineers.<br>
<p>
<font class="QuotedText">&gt; personally, i find this sort of code reorg by compilers</font><br>
<font class="QuotedText">&gt; to be problematic as it generally makes code quite hard</font><br>
<font class="QuotedText">&gt; to reason about. experienced developers would lift the</font><br>
<font class="QuotedText">&gt; assignment out of the loop if it mattered, and it were</font><br>
<font class="QuotedText">&gt; legal.</font><br>
<p>
I hear this a lot.  Then people get surprised when I show them what the compiler did to their code.  Believe me, there is no reason anyone should waste time hand-optimizing code without proof of need.  Either they're going to miss a lot of opportunity or they are going to screw things up and make the compiler's job harder.<br>
<p>
If a developer were to hand-optimize code to achieve the same performance result, the source code would be unmaintainable.<br>
<p>
We want optimizing compilers.  I can't believe anyone would suggest otherwise.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510602/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2012 16:16 UTC (Sun)
                               by <b>quanstro</b> (guest, #77996)
                              [<a href="/Articles/510807/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
in the example given in the op, there was no reason for the read to be in the<br>
loop, except if it might change.  the compiler made the assumption that the<br>
coder was wrong.  that might not be a useful assumption.<br>
<p>
as i see it, the trade-off here is non-standard constructions, and the<br>
principle of least surprise for performance.<br>
<p>
i'm not convinced of the claim that this is always a win.  <br>
<p>
the compiler i use on a daily basis does not do strength reduction or optimize<br>
away indirection. it assumes you know what you're doing.  i don't notice that<br>
it is slower.  i also don't have to worry that the compiler will break my<br>
drivers by "optimizing" them.<br>
<p>
(never mind that with modern intel cpus, strength reduction can be a loss due<br>
to microop caching.)<br>
<p>
i think this is a good trade off for my case because it avoids obtuse, and<br>
non-portable constructions that can be hard to remember to apply.  that is,<br>
for most code, developer time is more expensive than run time.<br>
<p>
just my two cents, and i realize that there are cases in the linux kernel<br>
where complex macros need this sort of optimization.  but perhaps that's<br>
complexity begetting itself.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 12:05 UTC (Mon)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/510978/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;in the example given in the op, there was no reason for the read to be in the</font><br>
<font class="QuotedText">&gt; loop, except if it might change. the compiler made the assumption that the</font><br>
<font class="QuotedText">&gt; coder was wrong. that might not be a useful assumption.</font><br>
<p>
No, the coder *was* wrong, and the assumption is *always correct in standard C*. That's the point. The programmer might have assumed semantics which are not C, but the compiler merely assumed that the programmer was writing in C, not writing in some unspecified language that looks a lot *like* C and exists only in the programmer's head.<br>
<p>
It is axiomatic that a valid optimisation (ie. one which precisely follows C semantics, and any which don't are buggy and tend to be quickly fixed) cannot break correct valid C; if code breaks then it is because the programmer has made incorrect assumptions about the exact meaning *in C* of what they're writing.<br>
<p>
If your variable might change between accesses, then you need to tell the compiler that, because it is not the case in the standard C model, which is why there's a keyword existing specifically for that purpose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 14:52 UTC (Thu)
                               by <b>quanstro</b> (guest, #77996)
                              [<a href="/Articles/511717/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
i agree with what you say, but that's not the point i'm trying to make.<br>
(and btw, i don't think that ACCESS_ONCE is standard c.  nor can the<br>
kernel be compiled with an arbitrary compiler; it depends on gcc.)<br>
<p>
for me, making code safe from all possible according-to-hoyle legal<br>
transformations of the code is not really interesting or useful.<br>
i'd much rather focus on having a tractable, easy-to-use programming<br>
environment.<br>
<p>
if restricting the compiler from making some theoretically legal<br>
code transformations reduces bugs and generally makes life easier,<br>
then why not do it?<br>
<p>
as it is i believe there are some gcc optimizations that can break the<br>
kernel.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 19, 2012 19:38 UTC (Sun)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/512352/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ACCESS_ONCE() is simply the macro called out in the article, which simply uses the volatile keyword in a cast, which is part of standard C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor510670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 17:33 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/510670/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
personally, i find this sort of code reorg by compilers
to be problematic as it generally makes code quite hard
to reason about.
</blockquote>
I'm curious. Why don't you say the same about register allocation? Combined with stack spilling, that can often have the same effect as code motion. How do you plan to get rid of that?
<p>
(I've seen this from various safety-critical embedded people too: they want the compiler to 'not optimize'. I've tried pointing out that this is a meaningless request, that translation necessarily implies many of the same transformations that optimization does, but they never seem to get it. What they generally *mean* is that they want the smallest possible number of transformations -- or perhaps that they want the transformations to be guaranteed bug-free.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/510670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor510601"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 15:35 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/510601/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C compilers detect it all the time.  It is a trivial analysis.  Users tend to ignore the warnings, however.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510601/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2012 18:52 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/510931/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which is why, when I gave a bunch of novice programmers instruction about how to maintain code, I said "the standard is (a) always turn warnings to max and (b) always fix or otherwise understand *every* warning".<br>
<p>
We had a bunch of warnings we couldn't get rid of, hence it didn't say "fix all warnings", but "explain it away" is just as effective, if less satisfying.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor510958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 8:02 UTC (Mon)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/510958/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; C compilers detect it all the time. It is a trivial analysis. Users tend to ignore the warnings, however.</font><br>
<p>
It is. And they do. And every time I see someone fixing a "use of undefined variable" warning by initializing it to zero at declaration point, I cringe. I've seen it in stable updates to the kernel a lot...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 16:31 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/511026/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Absolutely.  One needs to first understand _why_ the warning is there before fixing it.  Warnings don't replace understanding.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor510966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 9:38 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/510966/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is not trivial, or even possible, to detect if a variable is only initialised and used when another variable is set to a special value.<br>
Something like (very simplified):<br>
extern unsigned loglevel;<br>
<p>
void fct (void) {<br>
  int avar;<br>
  if (loglevel = 4) avar = 10;<br>
  increase_loglevel();<br>
  do_some_unrelated_stuff();<br>
  if (loglevel == 5) printf ("%d\n", avar);<br>
}<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 16:34 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/511027/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is not trivial to get an exact and accurate answer in the general case, true, but I was assuming we were talking about the common case of locally-declared variables.<br>
<p>
Still, even in this case the compiler could warn about it even if it doesn't know for sure.  The code certainly looks suspicious and a warning would be appropriate.  False positives are just fine if they are limited in number.  The compiler can provide directives to suppress them if the programmer knows it's not a problem.<br>
<p>
Note that gcc does just this.  It warns that variables *might* be uninitialized.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor511031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 16:50 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/511031/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fortunately, in your example avar is always initialized to 10. :)<br>
<p>
Assuming "loglevel = 4" was replaced with "loglevel == 4", I would expect the compiler to generate a warning in this case, since it can't _prove_ that avar was initialized before the printf() call. I would also hope that the compiler would take advantage of the fact that avar is either 10 or undefined to simply set it to 10 regardless of loglevel, for code size and performance reasons if nothing else.<br>
<p>
In cases like this, IMHO, it would be better to use a common flag rather than testing loglevel multiple times:<br>
<p>
void fct (void) {<br>
  int avar;<br>
  bool use_avar;<br>
  use_avar = (loglevel == 4);<br>
  if (use_avar) avar = 10;<br>
  increase_loglevel();<br>
  do_some_unrelated_stuff();<br>
  if (use_avar) printf ("%d\n", avar);<br>
}<br>
<p>
I'm not sure whether the compiler can follow this any better than before, so there may still be a warning, but at least the coupling is visible to anyone reading the code, and doesn't depend on the implementation of external functions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor510967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 9:56 UTC (Mon)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/510967/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; How can the compiler possibly know what you meant when you wrote something outside the language spec?</font><br>
<p>
The code we are arguing about, the one with ACCESS_ONCE(), is NOT outside the spec in any way, is it? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 12:11 UTC (Mon)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/510979/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; How can the compiler possibly know what you meant when you wrote something outside the language spec?</font><br>
<p>
<font class="QuotedText">&gt; The code we are arguing about, the one with ACCESS_ONCE(), is NOT outside the spec in any way, is it?</font><br>
<p>
No it isn't. The point is that, absent the ACCESS_ONCE() macro, the assumption that the compiler shouldn't pull that access out of the loop is what's outside the language spec, because the spec says it can safely do so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 10:57 UTC (Fri)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/512024/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the spec says it can safely do so.</font><br>
<p>
But does the spec say it _has_ to do so? Does it more good or harm?<br>
<p>
Not everything that is allowed is good. For example, the compiler is (in theory) allowed to do anything it wants when presented with code that raises undefined behavior. Anything. "rm -rf /" for instance would be 100% correct. Are GCC developers planing this "feature" for gcc 4.8? Of course not, that would be stupid when you could be playing nethack instead...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor511028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 16:35 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/511028/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, it is.  It uses typeof().<br>
<p>
But ignoring that, nye has the more useful response.  :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 10:37 UTC (Fri)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/512021/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
typeof() is clearly something acceptable in gcc's C dialect. Or have they removed their own extension without the word noticing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2012 10:07 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/512404/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thing is, can the type returned by typeof() be modified by adding the "volatile" keyword, how much can it be modified (how to remove volatility, possible to change the sign-ness by adding signed/unsigned)...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor510049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 19:42 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/510049/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, we have plenty of cases where we try to cater to users who stretch (to put it mildly) the standard.  But one must recognize that the programmer is no longer programming in said language.  He or she is programming in some other, ill-defined language.<br>
<p>
My point is that a bug caused by the programmer not adhering to the language standards is not caused by the compiler.  The compiler team may be willing to work around the problem but that doesn't mean the code ain't broke.<br>
<p>
<font class="QuotedText">&gt; If something has the potential of doing harm, and the user is perfectly </font><br>
<font class="QuotedText">&gt; capable of doing it by hand anyway if really needed, then it's best for </font><br>
<font class="QuotedText">&gt; the compiler not to do it.</font><br>
<p>
The problem is that the compiler has *no way* to know if the code is potentially harmful because the code is doing something outside the definition of the language.  The problem ACCESS_ONCE is trying to solve is a perfect example.  The compiler doesn't know which parts of code will be operating in a multi-threaded environment, much less which pieces of memory are shared.  We have "volatile" to mark variables in a way that happens to work for our current threading models.  But it is the only thing we have in C right now.<br>
<p>
Compiler writers generally don't want to limit legal transformations because those transformations can help the vast majority of programmers who don't have whatever specialized problem one programmer might complain about.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 14:30 UTC (Wed)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/510184/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The problem is that the compiler has *no way* to know if the code is potentially harmful</font><br>
<p>
It's not the code that it's harmful, but the transformation the compiler does in the optimization. To put it another way: the compiler chooses to do something that is NOT what the code says. It does so because it assumes it's safe. Because there's no way it can be sure if the transformation is safe (or not!), it should not be doing it.<br>
<p>
<font class="QuotedText">&gt; The compiler doesn't know which parts of code will be operating in a multi-threaded environment</font><br>
<p>
Isn't it common sense that any code compiled today _can_ be used in a multi-threaded environment?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 16:56 UTC (Wed)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/510245/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's not the code that it's harmful, but the transformation the compiler </font><br>
<font class="QuotedText">&gt; does in the optimization.</font><br>
<p>
No.  The code is the specification of what the programmer wants to happen.  If the programmer doesn't mark something "volatile" when it should be, there's no way the compiler can automatically infer that information.<br>
<p>
<font class="QuotedText">&gt; Because there's no way it can be sure if the transformation is safe (or </font><br>
<font class="QuotedText">&gt; not!), it should not be doing it.</font><br>
<p>
You've just killed all compiler optimization.<br>
<p>
<font class="QuotedText">&gt; Isn't it common sense that any code compiled today _can_ be used in a </font><br>
<font class="QuotedText">&gt; multi-threaded environment?</font><br>
<p>
And any variable might be shared.  So now the compiler must assume everything is volatile.<br>
<p>
You've just killed all compiler optimization.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 10:07 UTC (Mon)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/510969/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And any variable might be shared.</font><br>
<p>
Threads are supposed to share all memory, aren't they?<br>
<p>
<font class="QuotedText">&gt;You've just killed all compiler optimization.</font><br>
<p>
Only the unsafe ones. There are plenty of opportunities for optimization, but I don't think this is an example of one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 16:41 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/511030/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Threads are supposed to share all memory, aren't they?</font><br>
<p>
It depends on the threading model and since the standard doesn't specify one, the compiler cannot know in the general case.<br>
<p>
Now, gcc has for example the -pthreads switch that tells it something about what to expect so that can help.  But the kernel build system almost certainly doesn't use that.<br>
<p>
<font class="QuotedText">&gt; There are plenty of opportunities for optimization, but I don't think </font><br>
<font class="QuotedText">&gt; this is an example of one.</font><br>
<p>
When one restricts what is know about memory accesses, the compiler kills a *lot* of compiler transformation.  Much much more than one would think.  Spill code gets a lot more inefficient, for example, which you wouldn't expect to happen since spills are entirely local.  But it does because the compiler cannot do certain peeps that can help reduce the amount of spill code.<br>
<p>
The "big" transformations like loop restructuring, vectorization and the like are almost impossible if the behavior of memory can't be determined.  These are no more "unsafe" than any other transformation.  The compiler won't do them if it doesn't know it's safe according to the standard.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2012 16:58 UTC (Mon)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/511042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Now, gcc has for example the -pthreads switch that tells it something about what to expect so that can help.</font><br>
<p>
Except that for many platforms it's equivalent to '-D_REENTRANT -lpthread' and so only affects the preprocessor and linker, which doesn't tell the compiler anything.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor509734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 12:49 UTC (Sat)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/509734/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;It seems to me the bug is in the kernel. Either lock or lock-&gt;owner should be volatile-qualified in its declaration.</font><br>
<p>
That problem with that idea is that practically everything in the kernel would have to be declared volatile. That is inefficient when it doesn't matter (because a lock has been acquired), and misleading otherwise. Linus made some comments along these lines: <br>
<p>
<a href="http://lwn.net/Articles/233482/">http://lwn.net/Articles/233482/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor624535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 15:27 UTC (Thu)
                               by <b>cborni</b> (subscriber, #12949)
                              [<a href="/Articles/624535/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually the old ACCESS_ONCE code was supposed to work:<br>
<p>
While it is not that obvious the C99 standard basically forbids<br>
duplicating the memory access in that case. For an argumentation of<br>
a similiar case please see:<br>
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22278#c43">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22278#c43</a><br>
<p>
For the implementation-defined cases regarding volatile there are some<br>
GCC-specific clarifications which can be found here:<br>
<a href="https://gcc.gnu.org/onlinedocs/gcc/Volatiles.html#Volatiles">https://gcc.gnu.org/onlinedocs/gcc/Volatiles.html#Volatiles</a><br>
<p>
This issue was reported as bug and fixed (as a bug)<br>
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58145">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58145</a>"<br>
<p>
SO strictly speaking it was a gcc bug<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624639"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 20:01 UTC (Thu)
                               by <b>cborni</b> (subscriber, #12949)
                              [<a href="/Articles/624639/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
wow, I posted this into the wrong thread. Please disregard this here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624639/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor509368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 17:08 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509368/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      I believe that the features in C11 will prove quite helpful, though opinions do vary rather widely (disclaimer: I was involved in the C11 process).  But please keep in mind that there has been concurrent code written in C for some decades: <a href="http://en.wikipedia.org/wiki/Sequent_Computer_Systems">Sequent</a> started in 1983, which was almost three decades ago, and Sequent was probably not the first to write parallel code in C.  Linux added SMP support in the mid-1990s, which is well over a decade ago.

<p>So what did us parallel programmers do during the decades before C11?  Initially, we relied on the fact that early C compilers did not do aggressive optimizations, though register reloads did sometimes trip us up.  More recently, we have relied on non-standard extensions (e.g., the barrier() macro) and volatile casts.  Those of us living through that time (and I am a relative newcomer, starting shared-memory parallel programming only in 1990) have been shifting our coding practices as the compiler optimizations become more aggressive.

<p>And I am very sorry to report that I really have seen compiler writers joyfully discuss how new optimizations will break existing code.  In their defense, yes, the code that they were anticipating breaking was relying on undefined behavior. Then again, until production-quality C11 compilers become widely available, all multithreaded C programs that allow concurrent read-write access to any given variable will continue to rely on undefined behavior.
      
          <div class="CommentReplyButton">
            <form action="/Articles/509368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 19:20 UTC (Thu)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/509400/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      Yes we've relied on assumptions about compiler implementations. And that sure works, but it isn't ideal, and people should be aware of that.  With memory models (that specify multi-threaded executions) we can at least reduce that to assuming that the compiler implements the model correctly.  Compiler and application writers need to have a common understanding of the model, but at least we have formalizations of the model.

<blockquote>Those of us living through that time (and I am a relative newcomer, starting shared-memory parallel programming only in 1990) have been shifting our coding practices as the compiler optimizations become more aggressive.</blockquote>

Considering the example in the article, hoisting a load out of a loop is not something that I'd call an aggressive optimization.

<blockquote>And I am very sorry to report that I really have seen compiler writers joyfully discuss how new optimizations will break existing code. In their defense, yes, the code that they were anticipating breaking was relying on undefined behavior.</blockquote>

And I wouldn't have been joyful about that either.  But repeating stereotypes and anecdotal "evidence" about this or that group of people doesn't help us at all.

IMHO, the point here shouldn't be kernel vs. compilers or such, but pointing out the trade-offs between compiler optimizations of single-threaded pieces of code vs. synchronizing code, why we have to make this distinction, how we can draw the line, what memory models do or can't do, etc.

Shouldn't we be rather discussing how we can get compilers to more quickly reach production-quality support of memory models, and how to ensure and test that?  Or starting from the C/C++ memory model, whether there are limitations of it that are bad for the kernel, and whether compilers could offer variations that would be better (e.g., with additional memory orders)?
      
          <div class="CommentReplyButton">
            <form action="/Articles/509400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 21:29 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509428/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yep, having the compiler understand concurrency is a good thing, no argument from me.  If you wish to argue that point, you will need to argue it with someone else.  ;-)<br>
<p>
And indeed, there are any number of optimizations that are profoundly unaggressive by 2012 standards.  However, the fewer registers the target system has (and yes, I have used single-register machines), the less memory the compiler has available to it (I have used systems with 4Kx12bits of core, and far smaller systems were available), and the smaller the ratio of memory latency to CPU clock period (1-to-1 on many systems 30 years ago), the less likely the compiler will do certain optimizations.  All of these system attributes have changed dramatically over the past few decades, which in turn has dramatically changed the types of optimizations that compilers commonly carry out.<br>
<p>
I, too, favor looking for solutions.  But few people are going to look for a solution until they believe that there is a problem.  The fact that you already realize that there is a problem is a credit to you, but it is unwise to assume that others understand (or even care about) that problem.  And then there is of course the likely disagreements over the exact nature of the problem, to say nothing of over the set of permissible solutions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509549"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 11:29 UTC (Fri)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/509549/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree that the underlying problem might not be easy to see. But exactly this is a reason for not wrapping it in jokes and other things that can distract.  Also, in this case here, the funny bit doesn't even hint at the problem, so it won't help to explain.<br>
<p>
And I've too often seen people actually understand such (supposedly) funny comments literally (compilers are evil! they don't read my mind!) to really like such comments.  And yes, I realize that this is just anecdotal evidence :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509549/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509596"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 16:53 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509596/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I cannot say that I found your concerns convincing, and your further commentary isn't helping to convince me.<br>
<p>
So rather that continue that sterile debate, let me ask a question on the examples in the article.  In C11/C++11, would it be sufficient to make the -&gt;owner field be atomic with memory_order_relaxed accesses, or would the volatile cast still be necessary to prevent the compiler from doing those optimizations?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509596/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 20:59 UTC (Fri)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/509647/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's a question about forward progress, which isn't specified in much detail in at least C++11.<br>
<p>
On the one hand, mo_relaxed loads can read from any write in the visible sequence of side effects. So this would allow to hoist the load. Same for mo_acquire loads actually, I believe.<br>
<p>
On the other hand, there's C++11 1.10.2 and 1.10.25. You could interpret those as saying that the atomics in the abstract machine would eventually load the most recent value (in modification order).  Assuming that the standard's intent is that this is an additional constraint on reads-from, then compilers wouldn't be allowed to hoist the load out of loops.  I didn't see an equivalent of 1.10.2 / 1.10.25 in C11. (You said you've been involved in C11; is there any, or if not, why not?)<br>
<p>
Either way, I bet you've thought this through before.  So what's your detailed answer to your question?  What's your suggestion for how to specify progress guarantees in more detail in the standards?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 22:13 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509666/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C++11's 1.10.24 says that any thread may be assumed to eventually either terminate, invoke a library I/O function, access or modify a volatile object, or perform a synchronization or atomic operation.  This was a late add, and it replaced some less-well-defined language talking about loop termination.  I could read this as saying that the compiler is not allowed to hoist atomic operations out of infinite loops, in other words, that load combining is allowed, but the implementation is only allowed to combine a finite number of atomic loads.  How would you interpret it?<br>
<p>
I believe that this wording will be going into C11 as well, but will find out in October.  Not so sure about 1.10.2 -- C gets to support a wider variety of environments than C++, so is sometimes less able to make guarantees.<br>
<p>
How about the second issue raised in the original article?  If an atomic variable is loaded into a temporary variable using a memory_order_relaxed load, is the compiler allowed to silently re-load from that same atomic variable?<br>
<p>
My approach would be to continue using things like ACCESS_ONCE() until such time as all the compiler people I know of told me that it was not necessary, and with consistent rationales for why it was not necessary.  By the way, this is one of the reasons I resisted the recent attempt to get rid of the "volatile" specifier for atomics -- the other being the need to interact with interrupt handlers (in the kernel) and signal handlers (in user space).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 12:05 UTC (Mon)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/509888/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't interpret 1.10.24 the same way.  To me, it just ensures the compiler that there cannot be an infinite loop without any synchronization or side-effects in it.  The only purpose of that that I see is similar to the note in 1.10.24 -- removal of empty loops (e.g., after stuff has been hoisted out of the loop).<br>
I don't see how it would restrict reads-from inside of infinite loops. Even if the relaxed loads would have to stay in the loop, they'd still be allowed to read from an "old" write. (That's why I mentioned 1.10.25, which could mean that they eventually should pick up a recent value, forever; in that case, the load would also have to stay in the loop).<br>
Why are you reading 1.10.24 differently?  What's the detailed reasoning?<br>
<p>
The second issue, silently reloading from memory for a mo_relaxed load, would not be allowed, I think.  The abstract machine wouldn't do it.  It is allowed under as-if for nonatomic accesses (with no synchronization in-between etc.) because we can assume data-race-freedom and thus no concurrent modification by other threads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509919"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 16:58 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509919/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Suppose that a loop depends on a relaxed atomic load.  Suppose that the compiler unrolls the loop by (say) a factor of two.  I don't see anything in 1.10.24 that tells me that the compiler is prohibited from actually performing the relaxed atomic load only once per iteration of the unrolled loop, that is to say, only once per two iterations of the loop as written in the source code.  Such an optimization could be a problem in some situations.<br>
<p>
Don't get me wrong, I would be happy to learn that I am being overly paranoid, and that something actually forces the compiler to actually perform each and every relaxed atomic load, but I have heard too many compiler writers discussing optimizations that are not consistent with this less-paranoid view of this matter.<br>
<p>
Your argument that silent reloading from memory for a memory_order_relaxed load does sound more convincing.  If I consistently hear the same thing from enough compiler writers over a sufficiently long period of time, I will start recommending ACCESS_ONCE() only to prevent the compiler from optimizing atomic loads out, not to prevent the compiler from reloading from atomics.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509919/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor509450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 22:54 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/509450/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
But repeating stereotypes and anecdotal "evidence" about this or that group of people doesn't help us at all.
</blockquote>
Quite. How dare Paul use self-deprecating humour on a mailing list! It should be forbidden in case it offends people too thick to recognise it as humour.
<p>
(Thanks, but no thanks. Humour is a balm, not a menace. And we <i>do</i> often have an evil gleam in our eyes when discussing optimizations, so it wasn't even untrue.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/509450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 1:26 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509473/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Besides which, they tell me that I have had an evil gleam in my eyes a time or two as well.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509482"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 2:40 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/509482/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <a rel="nofollow" href="http://lwn.net/Articles/456240/">Experts agree</a> that gleam must have been evil indeed around tree RCU time...:)
      
          <div class="CommentReplyButton">
            <form action="/Articles/509482/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 4:53 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509502/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      And if the gleam was evil around tree RCU time, it must have been positively satanic around the time of the <a href="http://lwn.net/Articles/253651/">first mainlined preemptible RCU</a>...
      
          <div class="CommentReplyButton">
            <form action="/Articles/509502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 12:04 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/509730/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wasn't sure whether to thank the Prince of Darkness or controlled substances for that one. I'm glad to see it was the former: cavalier use of controlled substances is, of course, illegal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 21:45 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509763/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
;-) ;-) ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor509527"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 7:53 UTC (Fri)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/509527/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Then again, as mentioned below in the comments section, there is a guaranteed reliable way of doing this in C; it's declaring the variable volatile. This little trick may be within the C standard, but I'm pretty sure the people adding volatile to C never expected "(*(volatile typeof(x) *)&amp;(x))". Some programmers use every trick to optimize their code, then expect the compiler to maximally optimize their code while understanding all of their little tricks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509527/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 12:14 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/509731/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What matters with volatile (and any other language construct, really, but volatile in particular) isn't what the people adding it to the Standard expected. It's whether the Standard states, explicitly or by implication, that it will work; what implementations do; and what the people writing those implementations expect.<br>
<p>
Like const and restrict, volatile has been intended to be applied to pointers from the very start (that's always been its intended use: all the cv-quals are of limited use applied to non-pointer types). So saying that casting a normal pointer to volatile was not expected is unsupported by the facts. Of course they didn't expect tricks involving typeof(), because typeof() isn't in the Standard! So what matters is surely whether it works, and can be expected to continue to work, in compilers implementing typeof(). The answer to the first is, yes, it works, and if it stops working, well, the kernel hackers and compiler hackers do talk to each other, and it'll either be made to work again or another technique will be implemented to do the same thing (in which case ACCESS_ONCE() just becomes a compiler-version-specific macro).<br>
<p>
But this doesn't strike me as something too terribly likely to break in future compiler versions. The precise semantics of volatile are distinctly underspecified, to be sure, but C11 atomic operations are specifically declared as taking objects of volatile-qualified type, and volatile's meaning as 'minimize optimizations applied to things manipulating anything of volatile type, do not duplicate, elide, move, fold, spindle or mutilate' is of long standing.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor632969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2015 22:00 UTC (Wed)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/632969/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Typeof here isn't important to whats being done. Absent typeof you'd just have ACCESS_INT_ONCE() (or use the volatile cast directly instead of via a macro); the use of typeof here just makes the code more tidy and allows using a macro to express the programmer's intent better to other programmers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/632969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor509378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 17:50 UTC (Thu)
                               by <b>thedevil</b> (guest, #32913)
                              [<a href="/Articles/509378/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is lock-&gt;owner not declared volatile to start with?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 21:14 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/509430/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      Because that would pessimize <i>all</i> accesses to that field.  In general, use of <tt>volatile</tt> is <a rel="nofollow" href="/Articles/233479/">strongly discouraged</a> in the kernel; there's really only a few places where it is really needed.
      
          <div class="CommentReplyButton">
            <form action="/Articles/509430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509614"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 17:01 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/509614/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I understand Linus' reasoning but I don't agree with it.  He's right that usually you want to mark an access as, "get this from memory always."  However, C doesn't have a defined way to do that (ACCESS_ONCE is nonstandard).  The real solution is to introduce a new keyword (not called "volatile") that can mark object access expressions.<br>
<p>
Lacking that, it should be sufficient to load the volatile-qualified name into a temporary and use the temporary to allow optimization.  This way code is safe by default (no need to remember to use ACCESS_ONCE) and can be optimized explicitly where developers know it is safe.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509614/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509933"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 17:04 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509933/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is your objection to ACCESS_ONCE() specifically, to the volatile cast, or to the use of the non-standard typeof()?  The reason I ask is that I am not sure whether your recommendation of "volatile-qualified name" includes volatile casts or whether you are instead insisting that we declare the variable being loaded from as volatile.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509933/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 17:23 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/509938/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ACCESS_ONCE is nonstandard due to typeof.  That's not too bad for the kernel because developers only expect it to be compilable by gcc anyway.<br>
<p>
The use of a cast is fine.<br>
<p>
I'm suggesting the variable be declared volatile for safety reasons and temporaries be used to explicitly avoid pessimizing code when developers know it is safe.  That way things are safe by default and explicitly and obviously optimized when possible.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 17:24 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/509940/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'll just add that my point is that declaring the variable volatile doesn't kill performance everywhere.  It's perfectly possible to do performance optimizations when safe.  By using temporaries.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 18:16 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509948/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      It does sound like it just might be well past time for typeof() in the C/C++ standards.  ;-)  That said, both gcc and llvm seem to support typeof(), and I bet a lot of other compilers do as well, either directly or indirectly.  But perhaps the Linux kernel will eventually move from typeof() to C++11 <a href="http://en.wikipedia.org/wiki/Decltype">decltype()</a>, once the commonly-used compiler versions support it.

<p>Yes, you can in principle use manually coded temporaries to enable compiler optimizations in cases where a lock is held that prevents changes to the variable being loaded, but it is not at all clear to me why this would be a better solution than using ACCESS_ONCE(), especially in the Linux kernel.


      
          <div class="CommentReplyButton">
            <form action="/Articles/509948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 20:49 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/509956/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yes, you can in principle use manually coded temporaries to enable </font><br>
<font class="QuotedText">&gt; compiler optimizations in cases where a lock is held that prevents changes </font><br>
<font class="QuotedText">&gt; to the variable being loaded, but it is not at all clear to me why this </font><br>
<font class="QuotedText">&gt; would be a better solution than using ACCESS_ONCE()</font><br>
<p>
Safety and explicitness.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2012 23:12 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/509962/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, but it is still not clear to me, especially your point about explicitness.  After all, one of the advantages of the ACCESS_ONCE() approach is that lockless accesses are very clearly and explicitly flagged.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509977"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 3:42 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/509977/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, ACCESS_ONCE explicitly flags "volatile" accesses.  That is, one has to explicitly use it to guarantee safety.  That's an invitation for bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509977/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 14:37 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/510018/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And one of the corresponding bugs for your suggested approach of marking the variable volatile and caching the value in a temporary is failure to update the temporary when updating the underlying variable.  So I remain unconvinced.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 19:44 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/510050/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the programmmer is optimizing by using a temporary, the assumption is that the programmer knows what he or she is doing.  The optimization is explicit and is an immediate flag to the reader to carefully examine the (existing or new) code for bugs.<br>
<p>
I'm not trying to convince you, simply stating what I believe is good programming practice.  Maybe I'm wrong.  But it's worked for me so far.  :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 15:26 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/510210/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To each their own, I guess.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor509979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 5:52 UTC (Tue)
                               by <b>viro</b> (subscriber, #7872)
                              [<a href="/Articles/509979/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Have fun deciding how its semantics should look like for variably-modified types.  Gets *really* interesting when combined with another gccism, of course - ({...}).  In effect, that allows something that looked like local in one scope to leak outside; gcc used to ICE on fairly simple combinations.<br>
IIRC, there had been other places where it didn't play well with very unexpected parts of standard (e.g. bitfield signedness; does special treatment of signed int in there extend to e.g. typeof(signed int)?  Taken a few steps further it can, unless you are very careful, extend the distinction between int and signed int through all the type system...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 15:24 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/510020/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      I must admit that I have never used "typeof(({ printf("From typeof()\n"); j; })) k = 1;" to declare a variable "k" of the same type as "j", but gcc appears quite happy with it.

<p>And yes, gcc also seems quite happy to leak types from "({...})":

<pre>
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
	int i = argc;
	signed int j = i;
	typeof(({ struct foo { int a; } q = { 1 }; printf("From typeof()\n"); q; })) k = { 2 };

	printf("i = %d, j = %d, k.a = %d\n", i, j, k.a);
	return 0;
}
</pre>

<p>Yow!!!

<p>Fortunately for me, ACCESS_ONCE() does not depend on the semantics of typeof() applied to either "({...})"; or bitfields, although only because it is illegal to take the address of either of them.  ;-)
      
          <div class="CommentReplyButton">
            <form action="/Articles/510020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 15:35 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/510024/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Fortunately for me, ACCESS_ONCE() does not depend on the semantics of typeof() applied to either "({...})"; or bitfields, although only because it is illegal to take the address of either of them. ;-)</font><br>
<p>
Are you sure about the first case? It seemed to work for me in GCC 4.5.1, at least in the case where the result of the "({...})" is a non-local l-value:<br>
<p>
int x;<br>
int *f(void)<br>
{<br>
  return &amp;({ x; });<br>
}<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 15:57 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/510037/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      I am using gcc 4.6.1, and the following emits a compiler error complaining that an lvalue is needed:

<pre>
#include &lt;stdio.h&gt;

#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))

int q = 3;

int main(int argc, char *argv[])
{
	int i = argc;

	i = ACCESS_ONCE(({ printk("foo"); q; }));
	printk("i = %d\n", i);
}
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/510037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 18:35 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/510047/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting... it seems to work only if the variable is the only expression inside the statement expression. "&amp;({ x; })" and "&amp;({ ; x; })" are accepted, but "&amp;({ x; x; })" and "&amp;({ (void)0; x; })" both fail as you described. Perhaps the compiler is reducing the trivial one-expression form to a normal expression before performing the l-value check. It would make more sense to me to either fail both cases or move the "&amp;" operator inside the brackets, i.e. "&amp;({ ...; x; })" internally becomes "({ ...; &amp;x; })".<br>
<p>
Is there any particular reason the statement expression can't be an l-value, provided the final form is an l-value, or was that case simply considered too error-prone?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 21:12 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/510054/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have to ask, what is this ({…}) GCCism? I've searched the manual and online for it and "variably modified type" but not found anything useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510055"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2012 21:26 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/510055/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here is the URL you are looking for: <a href="http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510055/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor509635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 18:04 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/509635/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Also, <em>implicit</em> access-once behaviour can make it harder to understand how the code works.

      
          <div class="CommentReplyButton">
            <form action="/Articles/509635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor583531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2014 22:39 UTC (Thu)
                               by <b>timur</b> (guest, #30718)
                              [<a href="/Articles/583531/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>The functionality of this macro is actually well described by its name</i>
<br><br>
I disagree.  I was completely confused by the article until I saw the implementation of ACCESS_ONCE, because the behavior being described is the opposite of what I think "access once" means.  ACCESS_ONCE makes me believe that that it operates like pr_info_once(), which literally calls pr_info only once, no matter how many times loop repeats.

I also don't see how declaring it volatile forces the compiler to reload the variable only at the top of the loop.  Since it's declared volatile, the compiler can reload 'owner' any time it wants.
      
          <div class="CommentReplyButton">
            <form action="/Articles/583531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor583536"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2014 22:55 UTC (Thu)
                               by <b>timur</b> (guest, #30718)
                              [<a href="/Articles/583536/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm ... I think I get it.  Since lock-&gt;owner is temporarily declared volatile, the compiler forces a load at that point in the code.  But 'owner' is not declared volatile, so the compiler doesn't need to reload it, and it has "forgotten" about lock-&gt;owner, so it never tries to reload it, until the loop restarts.<br>
<p>
Sneaky.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/583536/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor583578"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Declaring it volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2014 4:07 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/583578/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe a better name would be FORCE_ACCESS_HERE().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/583578/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
