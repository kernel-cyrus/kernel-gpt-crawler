        <!DOCTYPE html>
        <html lang="en">
        <head><title>A perf ABI fix [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/567894/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/567614/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/567894/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A perf ABI fix</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 24, 2013</br>
           </div>
It is often said that the kernel developers are committed to avoiding ABI
breaks at almost any cost.  But ABI problems can, at times, be hard to
avoid.  Some have argued that the perf events interface is particularly
subject to incompatible ABI changes because the <tt>perf</tt> tool is part
of the 
kernel tree itself; since <tt>perf</tt> can evolve with the kernel, there
is a possibility that
developers might not even notice a break.  So the recent discovery of a
perf ABI issue is worth looking at as an 
example of how compatibility problems are handled in that code.

<p>
The <tt>perf_event_open()</tt> system call returns a file descriptor that,
among other things, may be used to map a ring buffer into a process's
address space with <tt>mmap()</tt>.  The first page of that buffer contains
various bits of housekeeping information represented by
<tt>struct&nbsp;perf_event_mmap_page</tt>, defined in
<tt>&lt;uapi/linux/perf_event.h&gt;</tt>.  Within that structure (in a 3.11
kernel) one finds this bit of code:
<p>
<pre>
    union {
	__u64	capabilities;
	__u64	cap_usr_time  : 1,
		cap_usr_rdpmc : 1,
		cap_____res   : 62;
    };
</pre>
<p>
For the curious, <tt>cap_usr_rdpmc</tt> indicates that the <tt>RDPMC</tt>
instruction (which reads the performance monitoring counters directly) is
available to user-space code, while <tt>cap_usr_time</tt> indicates that
the time stamp counter can be read with <tt>RDTSC</tt>.  When these
features (described as "capabilities," though they have nothing to do with
the security-oriented capabilities implemented by the kernel) are
available, code which is monitoring itself can eliminate the 
kernel middleman and get performance data more efficiently.
<p>

The intent of the above union declaration is clear enough: the developers
wanted to be able to deal with the full set of capabilities as a single
quantity, or to be able to access the bits individually via the
<tt>cap_</tt> fields.  One need not look at it for too long, though, to see
the error: each of the <tt>cap_</tt> fields is a separate member of the
enclosing union, so they will all map to the same bit.  This interface,
thus, has never worked as intended.  But, in a testament to the
thoroughness of our code review, it was <a
href="http://git.kernel.org/linus/c7206205d00ab375839bd6c7ddb247d600693c09">merged
for 3.4</a> and persisted through the 3.11 release.
<p>
Once the problem was noticed, Adrian Hunter quickly posted <a
href="/Articles/567925/">the obvious fix</a>, grouping the <tt>cap_</tt>
fields into a separate structure.  But it didn't take long for Vince Weaver
to <a href="/Articles/567926/">find a new problem</a>: code that 
worked with the broken structure definition no longer does with the fixed
version.  The fix moved 
<tt>cap_usr_rdpmc</tt> from bit&nbsp;0 to bit&nbsp;1 (while leaving
<tt>cap_usr_time</tt> in bit&nbsp;0), with the result that
binaries built for older kernels look for it in the wrong place.  If a
program is, 
instead, built with the newer definition, then run on an older kernel, it
will, once again, look in the wrong place and come to the wrong conclusion.
<p>
After some discussion, it became clear that it would not be possible to fix
this problem in an entirely transparent way or to
hide the fix from newer code.  At that point, Peter Zijlstra <a
href="/Articles/567928/">suggested</a> that a version number field be used;
applications could explicitly check the ABI version and react accordingly.
But Ingo Molnar <a href="/Articles/567929/">rejected</a> that approach as
"<q>really fragile</q>" and came up with a fix of his own.  After a
few rounds of discussion, the union <a href="/Articles/568139/">came to
look like this</a>: 
<p>
<pre>
    union {
 	__u64	capabilities;
 	struct {
	    __u64 cap_bit0			: 1,
	    	  cap_bit0_is_deprecated	: 1, 
	    	  cap_user_rdpmc		: 1,
	    	  cap_user_time			: 1,
	    	  cap_user_time_zero		: 1,
	    	  cap_____res			: 59;
 	};
     };
</pre>
<p>
In the new ABI, <tt>cap_bit0</tt> is always zero, while
<tt>cap_bit0_is_deprecated</tt> is always one.  So code that is aware of
the shift can test <tt>cap_bit0_is_deprecated</tt> to determine which
version of the interface it is using; if it detects a newer kernel, it will
know that the various <tt>cap_user_</tt> (changed from <tt>cap_usr_</tt>)
fields are valid and can be used. 
Code built for older kernels will, instead, see all of the old capability
bits (both of which mapped onto bit&nbsp;0) as being set to zero.  

(For the curious, the new <tt>cap_user_time_zero</tt> field was added in <a
href="http://git.kernel.org/linus/c73deb6aecda2955716f31572516f09d930ef450">an
independent 3.12 change</a>).
<p>
One could argue that this change still constitutes an ABI break, in that
older code may 
conclude that <tt>RDPMC</tt> is unavailable when it is, in fact, supported
by the system it is running on.  Such code will not perform as well as it
would have with an older kernel.  But it will perform correctly, which is
the biggest concern here.  More annoying to some might be the fact that
code written for one version of the interface will fail to compile with the
other; it is an <i>API</i> break, even if the ABI continues to
work.  This will doubtless be irritating for some users or packagers, but it
was seen as being better than continuing to allow code to use an interface that
was known to be broken.  Vince Weaver, who has sometimes been critical of
how the perf ABI is managed, <a href="/Articles/567931/">conceded</a> that
"<q>this seems to be about as reasonable a solution to this
problem as we can get</q>". 
<p>
One other important aspect to this change is the fact that the structure
itself describes which interpretation should be given to the capability
bits.  It can be tempting to just make the change and document somewhere
that, as of 3.12, code must use the new bits.  But that kind of check is
easy for developers to overlook or forget, even in this simple situation.
If the fix is backported into stable kernels, though, then simple kernel version
number checks are no longer good enough.  With the special
<tt>cap_bit0_is_deprecated</tt> bit, code can figure out the right thing to
do regardless of which kernel the fix appears in.
<p>
In the end, it would be hard to complain that the perf developers have
failed to respond to ABI concerns in this situation.  There will be an API
shift in 3.12 (assuming Ingo's patch is merged, which had not happened as
of this writing), but all combinations of newer and older kernels and
applications will continue to work; this ABI break went in during the 3.12
merge window, but never found its way into a stable kernel release.  The
key there is early testing; by catching this issue at the beginning of the
development cycle, Vince helped to ensure that it would be fixed by the
time the stable release happened.  The kernel developers do not want to
create ABI problems, but extensive user testing of development kernels is a
crucial part of the process that keeps ABI breaks from happening.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-User-space_ABI">Development model/User-space ABI</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Performance_monitoring">Performance monitoring</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/567894/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor568157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2013 20:12 UTC (Tue)
                               by <b>kugel</b> (subscriber, #70540)
                              [<a href="/Articles/568157/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is the API break required? If the fields were not renamed from usr to user the same code would comopile under both.<br>
<p>
As for keeping ABI compatible; can bit0 not still have the same buggy value that it has in the old code instead of always-zero?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2013 20:50 UTC (Tue)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/568164/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You need to check the _bit0* fields to determine the kernel's version of this interface, so you have to code for new struct anyway.<br>
<p>
Old code would probably compile, but it shouldn't -- it should use the new API. The rename make sure of that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor568163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2013 20:55 UTC (Tue)
                               by <b>cuviper</b> (subscriber, #56273)
                              [<a href="/Articles/568163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps a decent compromise would have bit0 = (time &amp;&amp; rdpmc).  This way, old userspace can keep its full performance advantage when both bits really are true, but it will never have a misinterpretation when only one was supposed to be set.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor568167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2013 21:16 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/568167/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">Why is the API break required? If the fields were not renamed from usr to user the same code would comopile under both.</font></blockquote>

<p>And <b>that</b> is exactly the problem: now you can have a code which can be compiled with old headers and new headers but which will only work if old headers are used. Not fun. It's <b>much</b> better to introduce explicit API breakage in such cases.</p>

<p>You see, API and ABI are different. APIs are used by programmers when they write programs and if they are changed (subtly or not so subtly) then the best way to communicate the problem is to introduce deliberate breakage (programmer will fix the problem or will use old version of headers), ABIs breakage is handled by the end-user (or system administrator who's only marginally more clueless then end-user) and they don't have any sane means of handling it. Instead they will just change random stuff around till the damn thing will start.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor568180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2013 23:54 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/568180/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Without tracing the kernel discussion thread, I don't know if the rich vein of humor in this event has been fully worked out, but I don't see how it ever can be.<br>
<p>
The error was not to have put bitfields in a union, the error was to have put bitfields in at all.  I gather that the C committee has considered deprecating bitfields so that any header using them will elicit warnings.  In the meantime, we depend upon ridicule, ostracism, and the quirky mis-implementation of bitfields in every C compiler ever.  Surely all suggestions to add even more bitfields were offered tongue-in-cheek?  We can but hope.<br>
<p>
As an abstract feature, bitfields are acknowledged to have an eldritch appeal, like ear tufts, 5-cm-thick toenails, or webbed fingers, but (fair warning!) anyone who speaks up for _using_ bitfields must prepare to be taunted.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 3:19 UTC (Wed)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/568197/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The perf_event interface is full of bitfields for reasons I don't fully understand.<br>
<p>
To make things more fun, there are proposals in the works to export the bit offsets in these bitfields (specifically the ones in struct perf_event_attr) via /sys so that the kernel can export event configs to the perf tool more "efficiently".  I personally think this will only end in tears. Especially once endianess is factored in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 3:41 UTC (Wed)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/568199/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also I should probably disclose that I'm the Vince Weaver who apparently has become famous for being grumpy about the perf_event ABI.<br>
<p>
In this case I was grumpy because the initial Changelog for the structure re-arrangement did not mention anything at all about the ABI implications or the bit overlap.<br>
<p>
It was only by luck that I noticed this issue, because I had updated the perf_event.h header in my perf_event_tests testsuite to 3.12-rc1 but had rebooted back to 3.11 for other reasons.  If I hadn't done that it's likely no one would have noticed this issue until after the 3.12 release.<br>
<p>
Not that it matters a lot though, as I'm possibly the only person in the world actually using RDPMC for anything right now.  It's used by the High Performance Computing people for low-latency self monitoring, but the perf tool doesn't use the interface at all.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 9:19 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/568221/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you using some library or doing this directly?  I'd like to do the same thing, but the API seems to be (intentionally) poorly documented.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 13:39 UTC (Wed)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/568239/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you using some library or doing this directly? I'd like to do the same</font><br>
<font class="QuotedText">&gt; thing, but the API seems to be (intentionally) poorly documented.</font><br>
<p>
I'm currently doing the RDPMC accesses directly.  The eventual goal is to have the PAPI performance library use the interface; there are overhead issues with the interface I was dealing with first (sometimes it is slower to use RDPMC than to just use the read() syscall, for reasons that took me a long time to figure out.  Thankfully there are workarounds).<br>
<p>
In any case yes, the documentation is awful.  I wrote the perf_event_open() manpage in an attempt to address this.  I've been working on updating the RDPMC part of that recently, although had to spend time trying to sanely document this ABI issue instead.<br>
<p>
Don't go by the example RDPMC code in perf_event.h, it's out of date and possibly never really worked.  I've been meaning to send a patch to fix that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 19:20 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/568291/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Don't go by the example RDPMC code in perf_event.h, it's out of date and possibly never really worked. I've been meaning to send a patch to fix that.</font><br>
<p>
Could a patch which replaces it with "TODO: Add an example" (or similar) be pushed for 3.12 at least? If there's anything worse than no documentation, it's bad documentation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor568234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 12:31 UTC (Wed)
                               by <b>busterb</b> (subscriber, #560)
                              [<a href="/Articles/568234/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I used to think bitfields were neat, until I found out how badly the performed on an embedded MIPS.<br>
<p>
The difference between dereferencing a bitfield and just doing a (flags &amp; FLAG) test was generally a 20-30% speedup on inner loops in an ISA like MIPS due to its insistence on aligned memory accesses. Similar thing with the 'packed' GCC attribute.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 8:51 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/568377/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; bitfield ... insistence on aligned memory accesses</font><br>
<p>
There isn't any relation in between bitfields and alignment, so it would probably be better to fix the compiler than fix few random source files, long term...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 9:30 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/568385/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Wouldn't that break the ABI? Long-term this may be a good idea, but short-term it'll be quite a problem.
      
          <div class="CommentReplyButton">
            <form action="/Articles/568385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 11:05 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/568399/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Wouldn't that break the ABI?</font><br>
<p>
No, instead of reading the 2nd bit of unaligned byte, the compiler emits code to read bit (2+8) of aligned word. Bit stay at the same place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 12:56 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/568412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      This will only work for read, not for writes. And even then only if <b>int</b> and not <b>_Bool</b> is used.
      
          <div class="CommentReplyButton">
            <form action="/Articles/568412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor568457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 16:17 UTC (Thu)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/568457/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One thing not really addressed is how bitfields run opposite ways on little endian and big endian systems.<br>
<p>
Not a problem in most cases, but perf_event describes some bitfields<br>
such as struct perf_branch_entry that get written to disk directly.<br>
<p>
So if you record a session, then move it to an opposite-endian machine and try to read it back in you have problems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568598"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Good one</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2013 12:05 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/568598/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; opposite ways on little endian and big endian systems</font><br>
<p>
On my side of the world, you do have little-endian system and BI-endian systems: the processor may be big-endian, but then it always has to interact with at least one little-endian subsystem (could be as simple as a PCI card, more usually most subsystems).<br>
Then, they added stuff at the virtual memory layer to describe that memory mapped area as either little or big endian, which solves a small part of the problem, two bit fields still increment as 0b00, 0b10, 0b01, 0b11.<br>
Then, big endian processor sort of disappeared.<br>
<p>
I still prefer:<br>
struct status {<br>
#ifdef LITTLE_ENDIAN<br>
unsigned b1:1, b2:1, b3:1, unused:29;<br>
unsigned xx;<br>
#else<br>
unsigned xx;<br>
unsigned unused:29, b3:1, b2:1, b1:1;<br>
#endif<br>
}<br>
than the 40 equivalent lines of #define, if I have a lot of those status.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568598/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor568200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 4:18 UTC (Wed)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/568200/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Reading the old code, it looks like bit 0 was *actually* true if either capability was available. So you could leave bit 0 with that behavior, have bit 1 indicate one capability and bit 2 indicate the other. Then you've got the following properties:<br>
<p>
Old binary, new kernel: same as old kernel, buggy but not a regression.<br>
New binary, new kernel: works correctly.<br>
New binary, old kernel, no code change: doesn't use either feature, but the system might not have whichever feature you're actually interested in, so it's safer.<br>
New binary, old kernel, extra code: if bit 0 is set, but neither other bit is set, you know that the info is unreliable; if bit 0 is not set, you know the system has neither feature.<br>
<p>
The only possible regression is that a new build with only the old API and an old kernel, which explicitly tests for a feature, would no longer have its test subverted; it would no longer use a feature that might happen to work when there's no way to tell.<br>
<p>
If you interpret the old ABI as "kernel will only set the bit if it is definitely making the feature available", this wouldn't be an ABI change, in that the new code would conform to that ABI at least as well as the old code did.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor568248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 15:34 UTC (Wed)
                               by <b>jfasch</b> (guest, #64826)
                              [<a href="/Articles/568248/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I personally like the positiveness of the article, and that of the entire LWN site.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor568293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 19:55 UTC (Wed)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/568293/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <p>I'm reminded of this gem from some GNU humor Web page I read a few years ago:</p>
<pre>
#define struct union
</pre>
<p>I'm not sure that would fix the perf ABI mess, though. ;-)</p>

<p>Seriously, though, why use the bit fields at all?  Why not:</p>

<pre>
__uu64 capabilities;
#define CAP_USR_TIME            (1ULL&lt;&lt;63)
#define CAP_USR_RDPMC           (1ULL&lt;&lt;62)
#define HAS_CAP_USR_TIME(x)     (x)&amp;CAP_USR_TIME
#define HAS_CAP_USR_RDPMC(x)    (x)&amp;CAP_USR_RDPMC
#define SET_CAP_USR_TIME(x)     (x)|=CAP_USR_TIME
#define SET_CAP_USR_RDPMC(x)    (x)|=CAP_USR_RDPMC
#define UNSET_CAP_USR_TIME(x)   (x)&amp;=~CAP_USR_TIME
#define UNSET_CAP_USR_RDPMC(x)  (x)&amp;=~CAP_USR_RDPMC
</pre>

<p>Now you have the full complement of query, set, and unset operations in beautiful preprocessor code.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2013 20:56 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/568302/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't it wonderful that we're writing our kernel in a language where preprocessor macros can defensibly be called "beautiful" by comparison to the alternative?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 0:19 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/568324/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Gcc and Clang both support C99 inline functions.  All the operations defined above can be expressed directly in type-checked C, without preprocessor macros, with identical runtime performance.<br>
<p>
There are still places for CPP macros, but this isn't one of them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 9:38 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/568379/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; All the operations defined above can be expressed directly in type-checked C</font><br>
<p>
C cannot have function with bitfields parameters (i.e. parameter of 3 bits), so the simple bitfield version:<br>
struct { unsigned dummy : 3; } a_var;<br>
void fct (void) { a_var.dummy = 9; }<br>
generate warning (gcc-4.6.3):<br>
large integer implicitly truncated to unsigned type [-Woverflow]<br>
<p>
The equivalent in C is:<br>
unsigned avar;<br>
extern inline void WARN_set_dummy_too_high(void) {<br>
//#warning set_dummy value too high<br>
char overflow __attribute__((unused)) = 1024; // to get a warning<br>
}<br>
inline void set_dummy(unsigned val) {<br>
if (__builtin_constant_p(val) &amp;&amp; (val &amp; ~0x7))<br>
 WARN_set_dummy_too_high();<br>
avar = (avar &amp; ~0x7) | (val &amp; 0x7);<br>
}<br>
void fct (void) { set_dummy(9); }<br>
<p>
If the bitfield is signed, the C function gets even more complex, and prone to off-by-one bugs.<br>
<p>
I have seen so much crap with #define (files with 10000+ #define lines, with bugs) that I would say bitfields is the future... let the compiler manage bits and bytes and let the linker manage addresses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 10:40 UTC (Thu)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/568397/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>Any time I see a :1 bitfield, I wonder why the author didn't just set up an unsigned char/short/int/long/long long and define compile-time constants for the bit(s).</p>
<p>Any time I see a :n (n &gt; 1) bitfield, I wonder what makes the author simultaneously believe that (a) it's important to squash that value into a bitfield instead of just using an int*_t or uint*_t (b) it's not important for people to be able to look at the code and predict what it will do.</p>
<p>(And any time I see a bitfield without an explicit signedness specifier, I wonder if I can revoke the author's coding privileges.)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/568397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 11:51 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/568402/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; bitfield, I wonder why the author didn't just set up an unsigned char</font><br>
<p>
Well, I was talking about describing the hardware, for instance a PCIe memory mapped window which control complex behaviour.<br>
I do not like to see stuff like:<br>
fpga.output_video.channel[3].sound.dolby.volume = 45;<br>
expressed with #defines:<br>
#define FPGA ((volatile void *)0xFD000000)<br>
#define OUTPUT_VIDEO (FPGA + 0x10000)<br>
#define CHANNEL (OUTPUT_VIDEO + 0x100)<br>
#define SIZEOF_CHANNEL 0x20<br>
#define OUTPUT_VIDEO_CHANNEL(n) (CHANNEL + (n * SIZEOF_CHANNEL))<br>
#define SET_SOUND_DOLBY_VOLUME(channel, v) ((stuff1 &amp; stuff2) &lt;&lt; 12) ... etc...<br>
<p>
For code unrelated to hardware, and not mapped to a fixed format (like for instance the structure of an Ethernet frame), then using bitfields is a lot less important.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 12:40 UTC (Thu)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/568409/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>Yes, you're describing exactly the situation I'm implying with my comment.</p>
<p>I've worked with hardware a lot. I've worked with hardware that has default settings useful to exactly no-one. I've worked with hardware that sometimes fails to assert its interrupt output and then won't attempt to assert an interrupt again until the interrupt it didn't assert has been serviced. I've worked with hardware with complex functional blocks that were pulled in their entirety from a previous device, but only half-documented in the new device's manual. I've worked with hardware with read-to-clear status bits, hardware with write-zero-to-clear status bits, hardware with write-one-to-clear status bits, and hardware with combinations of those.</p>
<p>Thanks to that, I've spent enough time staring at bus analyser traces that I have come to appreciate code of the form ""read register at offset X from BAR Y of PCI device Z'; compose new value; write register at offset X from BAR Y of PCI device Z", because I can directly correlate what I see on the analyser to what I see in the code - and, even better, I can quickly tell when what I see on the analyser <em>doesn't</em> correlate to what I see in the code.</p>
<p>Most hardware isn't bit-addressable. Bitfields in device drivers look an awful lot like a misguided attempt to make it look like it is.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/568409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2013 9:25 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/568571/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A also work with hardware, but mine may be working better.<br>
Maybe FPGAs work better, at least read/write issues are dealt by VHDL teams.<br>
What I am saying is that ten lines of #define to write a memory map register do not scale; once the single block works, FPGA teams just put 2048 of them on one corner of the FPGA.<br>
Then, most of the errors you find is that the wrong "ENABLE_xx" mask has been used with a memory map register, or someone defined<br>
#define FROBNICATE_1 xxx<br>
#define FROBNICATE_2 xxx+2<br>
...<br>
#define FROBNICATE_256 xxx+512<br>
but failed to increment for (only) FROBNICATE_42<br>
<p>
When using C described memory mapped registers (with a volatile struct of bitfields), you can read a single bit directly (knowing that the compiler will read the struct once and extract the bit), but when you want to access multiple bits you read the complete volatile struct into a locally declared (non volatile) struct (of the same type).<br>
If you want to modify and write you do it on your locally declared struct and write the complete struct back.<br>
The reading and writing of volatiles appear clearly in the source, and you can follow on your analyser, but the compiler is still free to optimize any treatment of non-volatile structs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2013 9:54 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/568583/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>What I am saying is that ten lines of #define to write a memory map register do not scale; once the single block works, FPGA teams just put 2048 of them on one corner of the FPGA.</blockquote>
<p>It seems to me that dealing with an FPGA containing 2048 instance of the same functional block <em>should</em> only require defining two or three more macros than dealing with an FPGA containing one instance of that block. If it doesn't... you need to have a quiet word or six with your FPGA teams about little things like "address space layout".</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2013 11:33 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/568594/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; require defining two or three more macros</font><br>
<p>
In that case the 10000's lines of #define is automatically generated by some TCL command nobody really is interested of reading, while "compiling" the VHDL.<br>
You have the choice as a software engineer either to use that file or not use it; if you do not use it by what do you replace it.<br>
For me, having an array of 2048 structures, each of them containing one hundred different control/status bits, few read and few write buffer, fully memory mapped and most area not even declared volatile leads to a source code ten times smaller with a lot less bugs.<br>
Obviously my knowledge of the preprocessor is sufficient to use the 10000's line file and "concat" names to counters in macros to access all the defines if my employer want to. I can do so for the 20 different parts of the VHDL chip, on each of the chips.<br>
Note that there is always an exception to every rule, and someone will modify the automatically TCL generated file, in the future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor568505"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 20:13 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/568505/">Link</a>] 
      </p>
      
      </div>
      </summary>
      What mpr said.  Further, any use of bitfields to control hardware makes the driver non-portable to any other architecture.  Further further, there is no way to know, ABI notwithstanding, how any particular compiler version will implement a series of bitfield operations, so use of bitfields makes your driver code non-portable even to the next release of the same compiler.
<p>
Categorically, there is <i>never any excuse</i> to use bitfields to operate hardware registers.  Use of bitfields in a driver is a marker of crippling incompetence.  Publishing code written that way will blight your career more reliably than publishing designs for amateur road mines.
      
          <div class="CommentReplyButton">
            <form action="/Articles/568505/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor568501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 20:06 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/568501/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Perhaps I shouldn't have said &quot;Seriously&quot;... My facetiousness extended to the second part of my original comment.  Not to mention a typo:  s/<tt>__uu64</tt>/<tt>__u64</tt>/.  Of course, I <i>could</i> simply do a <tt>typedef __u64 __uu64;</tt> and <i>voil&agrave;!</i> Typo gone. :-D</p>

<p>I'm actually intrigued by the fact some above mention using bitfields is perhaps preferred to preprocessor macros.  I was under the perception (based on my 2003-2005 undergraduate CS education) that they're frowned upon.  As are <tt>union</tt>s. (Personally, I'm not bothered by either; I have used bitfields and unions, even very recently, in code I've written for demonstrating <a href="http://babbage.cs.qc.cuny.edu/IEEE-754/">IEEE-754</a> floating point representation in binary.  A quick look at <tt>/usr/include/ieee754.h</tt> will show lots of bitfields.)</p>

<p>P.S.1: Even COBOL has a union programming structure (the <tt>REDEFINES</tt> keyword).</p>

<p>P.S.2: I <i>do</i> think the Perf developers' solution is quite elegant.  Well done, folks!</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/568501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568511"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 20:25 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/568511/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I despair.  
<p>
Might such travesties have led Brian Kernighan to say that Linux kernel code was even worse than Microsoft NT kernel code he had seen?
<p>
At X.org, they take long-time brokenness of a feature to demonstrate that the feature is unused and may be eliminated.  That would not be inappropriate in this case.  If the feature is expected to be useful in the future, the sensible approach is to design another interface <i>with another name</i>, and leave the busted one the hell alone.
      
          <div class="CommentReplyButton">
            <form action="/Articles/568511/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor568330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is the &quot;right kind of version number&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 1:26 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/568330/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Literal version numbers are what most people use, but they need not be that simple-minded. The pre-IP ARPANET also used a one-bit version number, according to an old colleague.<br>
<p>
This is also an elegant solution to the "how do I introduce versioning" problem, exactly as was faced by the RCS developers when they first had to introduce an incompatible change.  Something that's at least physically there (albeit not always "logically" there) gets used as the indicator, and everything thereafter can have as wide a version number as it needs.  <br>
<p>
If this structure only changes every 10-20 years, a one bit width will probably do for all time (;-))<br>
<p>
See also Paul Stachour's paper at <a href="http://cacm.acm.org/magazines/2009/11/48444-you-dont-know-jack-about-software-maintenance">http://cacm.acm.org/magazines/2009/11/48444-you-dont-know...</a> for a more conventional worked example.<br>
<p>
--dave (who edited Paul's paper) c-b<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is the &quot;right kind of version number&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 11:11 UTC (Thu)
                               by <b>jnareb</b> (subscriber, #46500)
                              [<a href="/Articles/568401/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There was similar situation that Git DVCS developers faced when adding new features to its network protocol.  The first version was not designed with extendability in mind, but because exchange was done with pkt-lines, with length as part of payload but original parsing stopped at NUL ("\0") character they have shoe-horned information about extensions ('capabilities', this time in extendable space separated list of capabilites format) after NUL character; old clients skip capabilities list, new clients parse it and reply which they want to use.<br>
<p>
Backward compatibility was preserved with a very few exception for server-client transfer thorough whole existence of Git.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor568407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is the &quot;right kind of version number&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2013 11:53 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/568407/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An elegant approach!<br>
<p>
It's a lot easier in modern programming languages, where a new variant can be intruduced by adding a parameter. For common cases, this can hide the ened for versioning and future-proofing from the developer.<br>
<p>
Unless, of course, you're making a change from an absolute date to a relative one, both expressed as an integer (:-()<br>
<p>
--dave<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/568407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor568924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Need for a special ABI/API team?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2013 15:36 UTC (Mon)
                               by <b>proski</b> (subscriber, #104)
                              [<a href="/Articles/568924/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Perhaps all ABI changes should be vetted by a person or a group of persons who would go through a checklist and test the change.
<p>
Linux kernel is too big to rely solely on bright minds, who can devise new ideas but cannot be tasked with checking the code based on existing rules.
      
          <div class="CommentReplyButton">
            <form action="/Articles/568924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor569301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A perf ABI fix</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2013 11:38 UTC (Thu)
                               by <b>heijo</b> (guest, #88363)
                              [<a href="/Articles/569301/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
cap_bit0 needs to be set to (cap_user_time &amp;&amp; cap_user_rdpmc).<br>
<p>
Setting it to always zero is idiotic and degrades older applications...<br>
<p>
Stop pushing crap into the kernel.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/569301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor569337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More perf bitfield fun</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2013 16:04 UTC (Thu)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/569337/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Other bitfields in the perf interface continue to cause trouble.<br>
See this recent proposed patch: <a href="https://lkml.org/lkml/2013/8/10/154">https://lkml.org/lkml/2013/8/10/154</a><br>
that tries to sanely provide access to perf_mem_data_src on both big and little endian systems.<br>
<p>
There's got to be a better way of doing this, but it's likely too late.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/569337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
