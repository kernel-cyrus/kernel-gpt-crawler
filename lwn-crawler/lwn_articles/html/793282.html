        <!DOCTYPE html>
        <html lang="en">
        <head><title>Bcachefs gets closer [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/793282/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/793456/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/793282/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Bcachefs gets closer</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 11, 2019</br>
           </div>
When it comes to new filesystems for Linux, patience is certainly a
virtue.  Btrfs took years to mature and, according to some, still isn't
ready yet.  <a href="/Articles/309094/">Tux3</a> has kept users waiting
since at least 2008; as of 2018 its developer still <a
href="https://phunq.net/pipermail/tux3/2018-April/002357.html">said</a>
that it was progressing.  By these measures, <a
href="https://bcachefs.org/">bcachefs</a> is a relative youngster, having
been first <a href="/Articles/655183/">announced</a> a mere four years
ago.  Development of this next-generation filesystem continues, and 
bcachefs developer Kent Overstreet recently <a
href="/ml/linux-kernel/20190610191420.27007-1-kent.overstreet@gmail.com/">proclaimed</a>
his desire to "<q>get this sucker merged</q>", but there are some
obstacles to overcome still.
<p>
Bcachefs has its origins in the <a href="/Articles/497024/">bcache</a>
caching layer, though it is a separate project at this point.
Like most of the newer filesystems out there, it uses a copy-on-write
approach — data is copied to a new location when changed rather than
overwritten.  That enables the implementation of a number of interesting
features; those intended for bcachefs include data checksumming,
compression, multiple-device and RAID support, hierarchical storage
management, snapshots, and, naturally,
good performance.  Work on bcachefs has apparently been slowed by the fact
that there is relatively little interest in supporting this work;
Overstreet has been <a href="https://www.patreon.com/bcachefs">soliciting
donations on Patreon</a> to be able to push the project forward.  He has
seemingly had some success in this area, and feels that the filesystem is
now getting close to ready:
<p>
<div class="BigQuote">
	This has been a monumental effort over a lot of years, and I'm
	_really_ happy with how it's turned out. I'm excited to finally
	unleash this upon the world.
</div>
<p>
Those who wish to play with this new filesystem will quickly discover that
one of the places where development has lagged is documentation.  For the
most part, users have to pull down the code and stumble through the process
of setting up a filesystem.  There is, at least, <a
href="/Articles/793287/">a man page</a> for the <tt>bcachefs</tt> command
that makes a good starting point.
<p>
Overstreet said that the bcachefs code is in a state where it is ready for
merging into the mainline.  Users will have to be patient for a little
while longer, though, as it seems that there are still a few obstacles in
the way, starting with <a
href="/ml/linux-kernel/CAHk-=wi0iMHcO5nsYug06fV3-8s8fz7GDQWCuanefEGq6mHH1Q@mail.gmail.com/">a
number of complaints from Linus Torvalds</a> on how the repository itself
is managed.  Simply cleaning things up at that level is likely to require a
fair amount of work.
<p>
<h4>Core-kernel changes</h4>
<p>
But, beyond that, there are a number of core-kernel changes that will have
to go in to support bcachefs.  Overstreet surely knew that this is where
any initial resistance might come from; code that is buried within a filesystem
implementation is unlikely to hurt people who do not actually use it, but
core-kernel changes can have wider repercussions.  So, while the bcachefs
code itself has not been seen on the kernel mailing lists in recent times,
the core changes were all posted for review.
<p>
One of those changes is the addition of a new locking primitive called a <a
href="/ml/linux-kernel/20190610191420.27007-3-kent.overstreet@gmail.com/">SIX
lock</a>.  These locks are reader/writer locks, but with a twist.  Normal
reader/writer locks allow any number of readers to access the protected
data concurrently, but a writer has exclusive access.  SIX locks tweak the
model by turning the writer side into a two-step process.  Any code that
wishes to have write access to a protected data structure must first obtain
an "intent" lock.  Only one holder of an intent lock may exist, so the
second thread that tries to obtain one will block until the first releases
its lock.  But holding the intent lock does not block readers, who can
continue to access the data structure.
<p>
Before actually making any changes, though, the holder of the intent lock
must upgrade it to a write lock, which will ensure that everybody else,
including readers, is excluded.  The intent lock, thus, gives a writer
access to a data structure that will not change while allowing that writer
to minimize the amount of time that it holds exclusive access to the data
structure.
<p>
Overstreet said that SIX locks "<q>seem to be pretty
uncontroversial</q>" and, for the most part, the (lack of) complaints
would seem to bear that out.  That said, Torvalds did suggest that it might
be better to add the "intent" level to the kernel's rwsem locks rather than
introducing an entirely new locking primitive.  Dave Chinner <a
href="/ml/linux-kernel/20190611041045.GA14363@dread.disaster.area/">objected</a>
to this idea, though, saying that rwsems are already too fragile and should
not be complicated further.  A definitive resolution has not been reached
here, but it seems likely that SIX locks will be merged with the rest when
the time comes.
<p>
Then, there is another locking primitive called <a
href="/ml/linux-kernel/20190610191420.27007-4-kent.overstreet@gmail.com/"><tt>pagecache_lock</tt></a>.
There is one of these locks for each address space; its job is to regulate
the addition of pages to the page cache.  This lock can be acquired in two
modes, called "add" and "block"; the former is for adding pages, while the
latter is for preventing others from adding pages.  Any number of threads
can hold the lock simultaneously as long as they all use the same mode, so
many threads can be adding pages concurrently, for example.  Changing the
mode of the lock may require a wait, though.  Torvalds didn't like this
lock, saying "<q>we don't do those hacky recursive things</q>".
<p>
Overstreet agreed that this lock is not ideal; in the patch-set cover
letter he said it was "<q>intentionally ugly in the hopes that someone
else will come up with a magical elegant solution</q>" — an approach
that is often surprisingly effective.  He defended the need for the lock,
though.  In current kernels, a number of operations, such as direct I/O,
will remove pages from the page cache to prevent data corruption resulting
from an operation that bypasses the cache.  But there is nothing that
prevents the system from faulting those pages back into the cache; that can
happen as a result of user-space code, automatic readahead in the kernel,
or any of a number of other things.  If pages re-enter the cache at the
wrong time, data corruption could result.
<p>
The existence of the problem is not in doubt, but opinions differ on how it
might be solved.  Torvalds <a
href="/ml/linux-kernel/CAHk-=wizTF+NbMrSRG-bc-LyuT7PUJ1QRAR8q_anOd6mY+9Z4A@mail.gmail.com/">suggested</a>
that some sort of page-level locking mechanism would be better.  Chinner is
<a
href="/ml/linux-kernel/20190613235524.GK14363@dread.disaster.area/">working
on range locks</a> as a possible solution; he also said that more and more
I/O is likely to bypass the page cache altogether.  Matthew Wilcox <a
href="/ml/linux-kernel/20190611142644.GC32656@bombadil.infradead.org/">suggested</a>
another approach where buffered I/O operations would not be able to add
pages to the 
cache while direct I/O is underway, but where direct I/O would also just
act like buffered I/O when the relevant pages already exist in the cache.
<p>
Unsurprisingly, this problem was not solved in the mailing-list
discussion.  A number of ideas were raised, though, and Overstreet is left
with the task of showing that his solution remains the best — a tall
order.
<p>
Finally, there is the <a
href="https://elixir.bootlin.com/linux/latest/source/drivers/md/bcache/closure.h">"closure"
mechanism</a> that is currently used inside the bcache code.  A closure is
essentially a reference count with some supporting code to make it easy to
wait for specific things to happen.  Overstreet wants to move the closure
code into the <tt>lib</tt> directory to make it more widely available.
Most people seem not to care, but Christoph Hellwig <a
href="/ml/linux-kernel/20190613072841.GA7996@infradead.org/">seems strongly
opposed</a> to the idea.  He has not yet responded to a request for more
information on why he dislikes it, though.
<p>
Thus, as can be seen, there are a few problems that need to be solved yet —
and that is before anybody has looked at the bcachefs code itself.  That is
likely to get close scrutiny as well when the time comes; some filesystem
developers have been clear in their belief that merging filesystem code
before it is ready has led to long-term problems in the past.  So, while
bcachefs looks like an interesting feature that is actively
progressing, the smart money would still not be on it landing in the
mainline kernel in the near future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-bcachefs">Filesystems/bcachefs</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/793282/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor793505"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2019 22:48 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/793505/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Strongly prefer putting the SIX logic in rwsem. If it doesn't go there, these SIX locks are never going to get priority inheritance right.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793505/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793598"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 21:48 UTC (Fri)
                               by <b>naptastic</b> (guest, #60139)
                              [<a href="/Articles/793598/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What's the difference between the problems SIX locks solves, and the problems RCU solves? Your statement worries me because I remember life before priority inheritance and I don't want to go back there. Especially when the phrase "will block until" is part of the article. Much thanks for your insight.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793598/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793602"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2019 0:51 UTC (Sat)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/793602/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What's the difference between the problems SIX locks solves, and the problems RCU solves?</font><br>
<p>
RCU doesn't solve btree traversal concurrency problem by itself.<br>
<p>
SIX locks arose from Kent's observation that if you write lock the btree traversal path to modify a leaf, then you can't concurrently traverse the tree for lookups and that's a major performance limitation. The tl;dr is that the "intent" state of teh SIX lock is designed to allow some concurrency between btree lookups and modifications without requiring complex changes to traditional btree algorithms.<br>
<p>
IOWs, with a btree you don't know if a path modification is required until you've got the leaf node to be modified locked exclusively. Traditional locking just exclusively locks the whole tree just in case the path needs updating, because it's simple and easy to understand. You could just use a single tree lock w/ RCU lookups, but then you have to guarantee that the modifications are ordered in a way to avoid RCU traversals seeing corrupt/incorrect state (complex!). That's why rwsems are typically used - it avoids the modification complexity problem RCU lookups introduce, but allows some lookup concurrency. However, because btrees are used in places where there are high modification rates the single writer lock still ends up being the scalability limitation.<br>
<p>
IOWs, Btree concurrency algorithms are all about how to do the path modification without requiring the whole tree to be locked. i.e. we need to be able to traverse back up the tree from the leaf and lock+modify as we go. This is difficult because we're locking in the opposite direction to traversal - modification has a different locking order to lookups. This locking order mismatch is what Kent has addressed with SIX locks - taking an intent lock on the way down doesn't limit lookup concurrency, but it guarantees that nodes can be locked exclusively safely on the way back up if path modification is necessary. It's a unique but relatively simple way to provide top down btree algorithms with useful lookup/modification concurrency.<br>
<p>
Compare this to traditional lock coupling algorithms (lock per tree node) that need to use different algorithms to allow concurrency during modifications - they require the ability to lock the tree exclusively node-by-node from the bottom up without the entire path being locked against modification. This places constraints on the tree structure, how modifications can be made, how node split/merge works, and then there's the problem of ensuring that racing path modifications don't result in a corrupt tree. This is a lot more complex than top-down based modification with SIX locks. Yet, in terms of scalability, the SIX locks likely perform as well as traditional fine grained lock coupling because both algorithms result in roughly the same modification/lookup path concurrency constraints.<br>
<p>
The variant of the btree I'm using for tracking range locks takes fine grained lock coupling one step further - it uses RCU-based optimistic lock coupling. The advantage of this is that the lookup side is 100% lockless and avoids dirtying cachelines so scales as if there is no locking at all. RCU is used purely as an epoch based garbage collection mechanism, not as a concurrency mechanism (RCU can be used for more than just "locking" :). The lockless lookup algorithm also allows concurrent modifications in the same path as it can resolve path modifications races safely (through structural and locking order constraints), hence modification concurrency scales much better than the other locking mechanisms mentioned above. The downsides are, however, yet more structural constraints and complexity....<br>
<p>
-Dave.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793602/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2019 18:05 UTC (Sat)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/793634/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That was very useful, thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor793693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2019 11:14 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/793693/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This insight could be generalized to other locking mechanisms too.  If you open a file for writing, but you're not sure you will need to write to it, then with flock() you have to get an exclusive lock to the file, blocking anyone else who only wanted a shared lock.  You could instead acquire an intent lock (keeping out any other possible writers, but allowing readers to continue) and then upgrade to an exclusive lock if and when you wanted to write.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 4:25 UTC (Tue)
                               by <b>naptastic</b> (guest, #60139)
                              [<a href="/Articles/793774/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I'm reading this correctly (and thank you ALL for your generous responses to my question!) then SIX locks have reduced the computational complexity of some operations on B-trees in general, which seems like a pretty big deal. Is that the case?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 9:22 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/793793/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>They don't reeduce computational complexity at all; they only reduce lock wait time (lock contention) for readers when there are concurrent writers.
<p>Still a big deal, but not as big a deal as reducing computational complexity would be - search/insert/delete are still O(log n).
<p>One way of looking at it is that, if lock ordering wasn't a thing when using rwlocks, then a writer could take read locks to find the node for insertions or deletion, then upgrade read locks to write locks as it splits and combines. However, lock ordering is a thing, and if you do this, two concurrent writers can both need to take the same write lock in order to finish their write, resulting in deadlock.
<p>SIX locks allow you to claim read locks that can be safely upgraded to write locks; when you take a read lock with intent to write in the SIX lock world, you permit concurrent reads, but no-one else can take an intent to write or a write lock for the same node. This means that when you upgrade a read lock with intent to write, you can't have a lock ordering issue, and no deadlock can happen.
<p>They're basically a clever extension of rwlocks for the case where you want to lock out readers in the opposite order to writers.
      
          <div class="CommentReplyButton">
            <form action="/Articles/793793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Reduce code complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2019 4:49 UTC (Sun)
                               by <b>CChittleborough</b> (subscriber, #60775)
                              [<a href="/Articles/794247/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      If I understood previous posts correctly, SIX locks make the <em>coding</em> less complex. There will be some efficiency gains (so the factor on the O(log n) might be slightly smaller), but the main benefit is that you  can use much simpler rules about locking, making the code <em>much less fragile</em>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/794247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Reduce code complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2019 11:24 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/794298/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Well, that depends on the angle at which you're viewing it.
<p>If you don't care about performance in the face of writes, then it doesn't remove complexity - writers simply take a write lock on every node they visit while trying to find the node to change, and thus lock out all readers. Readers can release locks as they walk, so that they only hold a lock on a maximum of two nodes at once (current node, next node).
<p>If you do care about performance in the face of writes, you need ever more complex code to avoid the writer locking out all readers during a write; this code is the stuff other posts are talking about, and is the code that SIX locks make redundant. Instead, writers take "Intent" locks, readers can still read (taking Shared locks) while the Intent locks tree is built up, and then get locked out briefly as the intent locks are changed to eXclusive, the changes are made, and then the locks are released.
<p>In other words, what this provides is a simple way to keep readers reading while writers are operating, compared to past complex code that tried to do that atop reader-writer locks. That should simplify high-performance B-tree access code, and make it easier to implement possible optimizations (for example, you could identify that a node is the highest node that could possibly be split or combined by this write, and thus release all the locks above it, and you can only convert I to X when you're about to modify a node and thus have unlocked all its children, so that readers don't get locked out until the last possible moment).
      
          <div class="CommentReplyButton">
            <form action="/Articles/794298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor793518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 3:59 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/793518/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Christoph Hellwig seems strongly opposed to the idea.</font><br>
<p>
I'm with Christoph here.  When I've has cause the read the bcache code, it is the closures that were hardest to read.  I found it very hard to reason about them.<br>
Closures are a lovely mathematical concept, but I don't find they work well as an engineering tool.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793586"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 18:35 UTC (Fri)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/793586/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't have a problem with them when they are used conservatively in environments like python or lisp.<br>
<p>
I wouldn't expect them to be particularly desirable in C in a kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793586/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793589"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 19:15 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/793589/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From the documentation in <a href="https://elixir.bootlin.com/linux/latest/source/drivers/md/bcache/closure.h">https://elixir.bootlin.com/linux/latest/source/drivers/md...</a> , these look nothing like what a Python programmer would call a closure (and probably not what any other kind of programmer would call a closure). I'm not sure if they have a precedent in any language under any name.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793589/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2019 10:21 UTC (Sat)
                               by <b>TheGopher</b> (subscriber, #59256)
                              [<a href="/Articles/793617/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
These look like destructors for a refcounted object to me.. but maybe I'm missing something.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793644"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2019 23:57 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/793644/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They sound a bit like that, except you can (optionally) synchronously wait for the object to be destructed. Also, in the 'destructor' you can increment the refcount again to resurrect the object while also binding it to a new destructor. I think that might stretch the destructor analogy a bit too far...<br>
<p>
Maybe it's more like Promises in JavaScript (and some other languages), where you create an object representing a future value then attach a function to be called later when the value becomes known, but without the value, and with nesting instead of chaining (which is the opposite of the best practice in JS), and with a refcount instead of just a pending/fulfilled state. But I don't really understand JS promises, and don't understand these 'closures', so I don't know how accurate that is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793644/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor793591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 19:46 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/793591/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The wait/wakeup API is complicated and it's not immediately clear how it relates to the core refcount/callback API. That core however seems pretty elegant to me.<br>
<p>
And I am not sure why it's called closure, but hey, naming is the hardest part.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 16:12 UTC (Tue)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/793857/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's because the refcount in a closure counts "things this closure is waiting on".<br>
<p>
So a closure could be waiting on multiple child closures - that was the original use case, in bcache where a write request might be waiting on a write to the backing device, and/or a write to the cache device; representing each of those with closures gives an elegant way of waiting for everything we've kicked off to complete. That's where the name came from, because if you look at as writing asynchronous code in continuation passing style and whatever you're embedding the closure in as your stack frame, you end up with something analogous to the spaghetti stack you get in Lisp/Scheme when working with closures or continuations.<br>
<p>
But I agree it didn't turn out to be the best name.<br>
<p>
Anyways, if a closure is something that just waits on things, then a waitlist is a pretty obvious extension - instead of owning the ref directly and using closure_get()/closure_put() directly, it's the waitlist that owns a ref on the closure as long as the closure is on that waitlist; closure_wake_up() then just removes everything currently on the waitlist and drops the refs.<br>
<p>
This lets you do some very cool things.<br>
<p>
closure_wait_event() works exactly like wait_event(), except that because wait_event() works by mucking with the task state directly you're very restricted on what you can safely do inside the condition check (e.g. you can't lock a mutex in the condition check anymore, it should technically be safe but modern kernels will complain). Being able to call arbitrary code from inside the condition check can often result in _vastly_ cleaner code - have a look at bch2_journal_res_get_slowpath() for an example.<br>
<p>
It gets better.<br>
<p>
Sometimes you have to call into some other code that _might_ have to block for awhile - often an allocation of some kind (memory, btree nodes, etc.) and you've got locks held where you need to do the allocation, locks that ideally you wouldn't be holding while you're blocking waiting on resources to become available. But often you don't know if you'll need the allocation except while you've got those locks held, which makes things ugly.<br>
<p>
There's two options. One is that you can do this dance where you start out with a temporary local variable set to NULL; the idea is that when you get to where you'd need to allocate, if that temporary is still NULL you drop your locks, allocate, save it there, and then restart from the top - then, on the next loop through if you still need to allocate you just use the one you did before. And before returning, you have to check if you've got an object allocated that you didn't use.<br>
<p>
This pattern is used quite a bit in the kernel, but it can get pretty ugly and it's not always workable in every situation.<br>
<p>
Using closures lets you decouple where the waiting is done from the decision that we need to wait. The model used in bcachefs for these functions that might need to block is, we pass in a pointer to a closure. Then, if the operation can't be done right now, the function puts the closure on a waitlist and returns -EAGAIN; now, the caller can unwind until it gets to a point where it's safe to sleep, and then either call closure_sync() or continue_at(), and then retry the operation later.<br>
<p>
This ends up being much, much cleaner.<br>
<p>
Also, these days I tend to make use of the asynchronous aspect of closures less - for a lot of uses they're more just improved completions. It would be nice to figure out a good way to merge their functionality with the other kernel infrastructure for waiting and wakeups - e.g. get rid of closure_waitlist and just make it possible for them to go on regular waitlists.<br>
<p>
Personally - they do what I need them for well enough that I don't have that much interest in revisiting and reworking stuff like that, I've got my hands full enough as it is. But if someone else wanted to work on that I'd be willing to help with the design.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor793526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 6:46 UTC (Fri)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/793526/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linus sort of complained about this, but git revert really sets people up for failure.  These days git commits are always &lt;12 digit hash&gt; ("Title").  Never just a huge hash.  To me "revert blah blah" is not and ideal subject...  And of course you should have a commit message.<br>
<p>
But the default git revert command is old and I keep hoping someone will update it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 9:20 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/793533/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      Linus gave an example:
<blockquote>The commit message is

    This reverts commit 36f389604294dfc953e6f5624ceb683818d32f28.

which is wrong to begin with - you should always explain *why* the
revert was done, not just state that it's a revert.

But since you rebased things, that commit 36f3896042 doesn't exist any
more to begin with.  So now you have a revert commit that doesn't
explain why it reverts things, but the only thing it *does* say is
simply wrong and pointless.</blockquote>
This is something that has always annoyed me about rebasing -- any log message that mentions a commit becomes broken.  And it's not just the log messages generated by 'git revert'; you might often mention a commit by hand, as 'This fixes a bug introduced in abcde...' or 'The last user of this interface was removed in bcdef...'.
<p>
You could work around it by always giving not just a commit hash, but also the first line of the log message of that commit -- but even that might not be enough (personally I try not to restate things in the commit message that are obvious from the diff, so removing an unused function would just be the message 'Unused.').  You'd need to state the original log message, the time and date of the original commit... all things that a version control system is supposed to track for you.
<p>
Ideally 'git rebase' should suggest rewriting the log messages when they mention a commit which has been changed (or removed altogether) as part of rebasing.  It sucks that you can have nonsensical commit messages which could easily be checked automatically.
      
          <div class="CommentReplyButton">
            <form action="/Articles/793533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793540"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 12:10 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/793540/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>The other direction is the one that the <a href="https://www.mercurial-scm.org/doc/evolution/">Evolve extension</a> to Mercurial takes. Rebase doesn't remove the commit that was rebased - it creates a new one, and adds metadata to tell the system that the old commit has been rewritten into the new commit hash.
<p>Various clever things then happen so that only the metadata and visible commits are exchanged, and not the commits that have been rewritten, but then when you ask Mercurial about abcde, it can tell you that abcde no longer exists, but that "bcdef" is its replacement.
<p>This way, you can still use commit hashes to refer to a unique commit; if that commit is rewritten before you can see it, you simply get told that there is a newer commit you can look at instead.
      
          <div class="CommentReplyButton">
            <form action="/Articles/793540/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 14:22 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/793569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds neat.  Another (hacky) fix would be for git to track commit hashes mentioned in log messages, and not garbage collect the commits which are mentioned, so that if you have a log message you know you can always view details of the commits it talks about.  That wouldn't give you the information about what they've been rebased into, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor793593"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2019 20:20 UTC (Fri)
                               by <b>newren</b> (subscriber, #5160)
                              [<a href="/Articles/793593/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Ideally 'git rebase' should suggest rewriting the log messages when</font><br>
<font class="QuotedText">&gt; they mention a commit which has been changed (or removed</font><br>
<font class="QuotedText">&gt; altogether) as part of rebasing. It sucks that you can have</font><br>
<font class="QuotedText">&gt; nonsensical commit messages which could easily be checked</font><br>
<font class="QuotedText">&gt; automatically. </font><br>
<p>
I included this in one of the GSoC ideas for git, which Rohit Ashiwal picked up this summer and he has it listed as a bonus item[1,2].  The lack of such an ability in git rebase has bugged me too, especially after I implemented the same idea for git-filter-repo[3] and I saw how seamless it was; after that, when I needed to rebase it was just so annoying to have these dangling obsolete references.  Anyway, long story short, Rohit might implement it this summer; if it doesn't fit in his GSoC project, I'm likely going to implement and propose it sometime afterward.<br>
<p>
[1] <a href="https://rashiwal.me/">https://rashiwal.me/</a><br>
[2] <a href="https://public-inbox.org/git/20190405213100.9577-1-rohit.ashiwal265@gmail.com/">https://public-inbox.org/git/20190405213100.9577-1-rohit....</a><br>
[3] <a href="https://github.com/newren/git-filter-repo">https://github.com/newren/git-filter-repo</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793593/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor793656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2019 6:44 UTC (Sun)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/793656/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When patches remove unused code I prefer if the commit says when the last user was removed or that it was never used.  I quite often look up this information when I review the patch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor793687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2019 3:34 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/793687/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This is something that has always annoyed me about rebasing -- any log message that mentions a commit becomes broken</font><br>
<p>
Any log message that mentions a commit *in the rebased branch* becomes broken. Usually when rebasing, I would suggest that such references point towards squashing those commits together (because it either fixes it or reverts it) or combining/splitting them in some other dimension other than time. If it is a genuine mention, I usually word it as "the previous commit(s)" or in reverse "this is in preparation for further improvement to X". If the former gets split-merged (its ancestors merged to `master` before it), the commit is now merged and can be referred to via its hash/title/date triple reliably on a rebase. The latter doesn't need to be managed in that way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2019 10:55 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/793692/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree, most of the time 'fix XYZ' can be squashed into the commit that it fixes.  But sometimes I will temporarily remove a feature (some lesser-used command line option or whatever), refactor things a bit, then add the feature back again.  That results in a patch series that has a 'revert' commit in it, and this does make sense as a logical sequence of patches.  And it's not the previous commit that is being reverted, but something further back in history.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2019 19:30 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/793753/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm. I guess I would be doing the refactoring in a separate branch completely. Maybe I don't work on projects that I can forsee requiring taking out some "lesser-used" feature before refactoring (without it having to affect the refactor anyways). Do you have examples of this in any of your projects?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2019 20:42 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/793756/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, but usually for scripts used by me and other programmers as part of system maintenance -- not the production system itself.  So I might remove the --verbose command line option then add it back later (since that option doesn't really have a specification for what it should do).  Or in a web page scraper, remove automatic retrying on error (which isn't needed 99% of the time) so I can refactor the download code, then add it back when finished.  In larger systems it would only be things like logging: sometimes I take out some log message statements because they are getting in the way of refactoring, then add them back later in the same branch.<br>
<p>
A more common case, now I think about it, is related to bug fixes.  The first commit in a branch may be "more robust check for error case we have just discovered".  Like, check for the bad state earlier, or die with a better message.  Then you fix the bug and gradually rework things so that the particular error state becomes impossible.  Then at the end of the branch you can remove the paranoia that checked everywhere for the bad condition.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2019 15:10 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/794444/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm. I think I prefer commits that are more contained than that, but I also work on projects where cherry-pick and backporting are useful while also preserving sensible `git bisect` behaviors. At the core, it sounds like a different project flow to the ones I usually work on :) .<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor793765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2019 23:20 UTC (Mon)
                               by <b>newren</b> (subscriber, #5160)
                              [<a href="/Articles/793765/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problems with a reference like "two commits ago" are (1) if I re-order commits during the rebase then the commit message still needs to be reworded -- but instead of correcting a hash (which could have been automated) I now need to correct how many commits there are separating the relevant two commits and it's much less likely to be noted as a stale reference and can thus confuse rather than just fail to help future readers, (2) even if the count is correct, it can still confuse others looking through git log later, since git log will intersperse commits from different branches that were merged based on committer timestamp (--topo-order isn't the default).<br>
<p>
I like referring to commits by an abbreviated hash/title/date triple, but I really want the abbreviated hash to get updated automatically during a rebase.  Sure, it doesn't come up all the time, but it comes up just often enough to be annoying and I hate attempting to figure out how to reword things some other way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794446"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2019 15:13 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/794446/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Giving exact counts usually isn't the way I do things personally. Usually it is "previous commits" or some vague-y ordering like that. And given that I do topic branches for ~everything, I'm usually only looking at the first-parent history of all the merges, have gotten it down to a given topic (where the count-ordering is easy in the vast majority of cases), or have found it via a file/grep search of the history.<br>
<p>
One question I do have for commit rewriting: what if I flip the order such that when writing commit A that references the (now-future) commit B where the hash is unknown right now. Error that there's an apparent ordering problem? How about false positives?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794446/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor794068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 9:46 UTC (Thu)
                               by <b>dunlapg</b> (guest, #57764)
                              [<a href="/Articles/794068/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why on earth would anyone revert a commit in their own not-yet-merged branch?  A properly constructed patch series shouldn't have any detritus from development; and if you need "scaffolding" to build up the functionality, then the patches should say, "Add scaffolding" and "Remove scaffolding", not "Revert c/s $HASH".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bcachefs gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 15:24 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/794117/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, the second patch has a log message 'Removed scaffolding.  We no longer need it because...'<br>
<p>
It then has an extra line, at the end of the commit message, noting<br>
<p>
'This reverts commit abcdef0123.'<br>
<p>
When you're reviewing the patch sequence, it's sometimes handy to refer back to the earlier commit in this way.  A review interface will let you jump quickly between the two, and so on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor793646"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Naming things</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2019 0:56 UTC (Sun)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/793646/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The SIX lock sounds very much like the locking system the CVS version control system uses.<br>
<p>
The “intent locks” are called “promotable locks” there, which is much more intuitive, and therefore I propose a rename.<br>
<p>
If you have cvs and texinfo installed, the following command shows the documentation:<br>
<p>
	info '(cvs)Locks'<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793646/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Naming things</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 3:59 UTC (Thu)
                               by <b>markh</b> (subscriber, #33984)
                              [<a href="/Articles/794038/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SPX (shared/promotable/exclusive) or RPW (read/promotable/write) doesn't roll off the tongue quite as smoothly as SIX (shared/intent/exclusive).  And while "readwrite" is only two syllables and short enough to pronounce in full each time, "readpromotablewrite" is a mouthful.  On the other hand, when you tell people that you're using SIX locks, they may wonder why you need so many.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Naming things</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 9:38 UTC (Thu)
                               by <b>dunlapg</b> (guest, #57764)
                              [<a href="/Articles/794067/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think "RPW locks" is fast enough to say, and has the additional advantage of being able to "hook" onto the concept of "reader-writer" locks.  I don't mind SIX but I do think RPW would be better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor794103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Naming things</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 13:44 UTC (Thu)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/794103/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Depends on the language ☻<br>
<p>
I say er-pe-we you say arr-pi-dabbel-yu.<br>
<p>
But mostly I say “promotable locks”, which flows even faster, or “promotable locking scheme” when talking about the thing you call RPW scheme.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
