        <!DOCTYPE html>
        <html lang="en">
        <head><title>EPOLL_CTL_DISABLE and multithreaded applications [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/520012/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/519515/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/520012/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>EPOLL_CTL_DISABLE and multithreaded applications</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Michael Kerrisk</b><br>October 17, 2012</br>
           </div>
<p> Other than the merging of the server-side component of <a
href="https://lwn.net/Articles/508865/">TCP Fast Open</a>, one of the few
user-space API changes that has gone into the just-closed 3.7 merge window
is the addition of a new <tt>EPOLL_CTL_DISABLE</tt> operation for the
<tt>epoll_ctl()</tt> system call. It's interesting to look at this
operation as an illustration of the sometimes unforeseen complexities of
dealing with multithreaded applications; that examination is the subject of this
article. However, the addition of the <tt>EPOLL_CTL_DISABLE</tt> feature
highlights some common problems in the design of the APIs that the kernel
presents to user space. (To be clear: <tt>EPOLL_CTL_DISABLE</tt> is the
<i>fix</i> to a past design problem, not a design problem itself.) These
design problems will be the subject of a follow-on article next week.

<p> Understanding the need for <tt>EPOLL_CTL_DISABLE</tt> requires an
understanding of several features of the epoll API. For those who are
unfamiliar with epoll, we begin with a high-level picture of how the API
works. We then look at the problem that <tt>EPOLL_CTL_DISABLE</tt> is
designed to solve, and how it solves that problem.


<h4> An overview of the epoll API</h4>


<p> The (Linux-specific) epoll API allows an application to monitor
multiple file descriptors in order to determine which of the descriptors
are ready to perform I/O.  The API was designed as a more efficient
replacement for the traditional <tt>select()</tt> and
<tt>poll()</tt> system calls. Roughly speaking, the performance of those
older APIs scales linearly with the number of file descriptors being
monitored. <!--This was not an obvious problem when these APIs were first
in invented, since typical applications monitored at most a few file
descriptors. However, it is a problem for modern applications such as
network servers that work with thousands of file descriptors. (To be a
little more precise about <tt>select()</tt>, the performance scales
according the highest file descriptor number being monitored.)--> That
behavior makes <tt>select()</tt> and <tt>poll()</tt> poorly suited for
modern network applications that may handle thousands of file descriptors
simultaneously.

<p> The poor performance of <tt>select()</tt> and <tt>poll()</tt> is an
inescapable consequence of their design. For each monitoring operation,
both system calls require the application to give the kernel a complete
list of all of the file descriptors that are of interest. And on each call,
the kernel must re-examine the state of all of those descriptors and then
pass a data structure back to the application that describes the readiness
of the descriptors.

<!--

<p> The reason for the poor performance of the older system calls lies in
the design of the APIs themselves. Both of the APIs have the following
characteristics:

<ul>

<p>
<li>
On each call, the application passes a data structure that identifies <i>all</i>
of the file descriptors to be monitored. Correspondingly, each call returns
a data structure that describes the readiness of all of the file
descriptors.

<p>
<li>
On each call, the kernel checks <i>all</i> of the file descriptors that
were passed to see which ones are ready.

</ul>

<p>

These APIs don't efficiently handle a situation that commonly occurs
when repeatedly monitoring the same (or a slowly changing) large set of
file descriptors: typically, only one or a few file descriptors become
ready between successive calls to the APIs. 

-->

<p> The underlying problem of the older APIs is that they don't allow an
application to inform the kernel about its <i>ongoing</i> interest in a
(typically unchanging) set of file descriptors. If the kernel had that
information, then, as each file descriptor became ready, it could record
the fact in preparation for the next request by the application for the set
of ready file descriptors. The epoll API allows exactly that approach, by
splitting the monitoring API up across three system calls:

<ul>

<p> <li> <tt>epoll_create()</tt> creates an internal kernel data structure
("an epoll instance") that is used to record the set of file descriptors
that the application is interested in monitoring. The call returns a file
descriptor that is used in the remaining epoll APIs.

<p> <li> <tt>epoll_ctl()</tt> allows the application to inform the kernel
about the set of file descriptors it would like to monitor by adding
(<tt>EPOLL_CTL_ADD</tt>) and removing (<tt>EPOLL_CTL_DEL</tt>) file
descriptors from the <i>interest list</i> of the epoll
instance. <tt>epoll_ctl()</tt> can also modify (<tt>EPOLL_CTL_MOD</tt>) the
set of events that are to be monitored for a file descriptor that is
already in the interest list. Once a file descriptor has been recorded in
the interest list, the kernel tracks I/O events for the file descriptor
(e.g., the arrival of new input); if the event causes the file descriptor
to become ready, the kernel places the descriptor on the <i>ready list</i>
of the epoll instance, in preparation for the next call to
<tt>epoll_wait()</tt>.

<p> <li> <tt>epoll_wait()</tt> requests the kernel to return one or more
ready file descriptors. The kernel satisfies this request by simply
fetching items from the ready list (the call can block if there
are no descriptors that are yet ready). The application uses
<tt>epoll_wait()</tt> each time it wants to check for changes in the
readiness of file descriptors. What is notable about <tt>epoll_wait()</tt>
is that the application does not need to pass in a list of file descriptors
on each call: the kernel already has that information via preceding calls
to <tt>epoll_ctl()</tt>. In addition, there is no need to rescan the
complete set of file descriptors to see which are ready; the kernel has
already been recording that information on an ongoing basis because it
knows which file descriptors the application is interested in.

</ul>

<p>
Schematically, the epoll API operates as shown in the following diagram:

<p>
<blockquote>

<img src="https://static.lwn.net/images/2012/epoll_API.png" alt="[Overview of the epoll
API]" hspace=10 vspace=5>

</blockquote>

<p> Because the kernel is able to maintain internal state about the set of
file descriptors in which the application is interested,
<tt>epoll_wait()</tt> is much more efficient than <tt>select()</tt> and
<tt>poll()</tt>. Roughly speaking, its performance scales according to the
number of ready file descriptors, rather than the total number of file
descriptors being monitored.


<h4>Epoll and multithreaded applications: the problem</h4>

<p>The author of the patch that implements <tt>EPOLL_CTL_DISABLE</tt>,
Paton Lewis, is not a regular kernel hacker. Rather, he's a developer with
a particular user-space itch, and it would seem that a kernel change is the
only way of scratching that itch. In the description accompanying the first
iteration of his patch, Paton began with the following <a
href="/Articles/520022/">observation</a>:

<div class="BigQuote">

<p> It is not currently possible to reliably delete epoll items when using
the same epoll set from multiple threads. After calling epoll_ctl with
EPOLL_CTL_DEL, another thread might still be executing code related to an
event for that epoll item (in response to epoll_wait). Therefore the
deleting thread does not know when it is safe to delete resources
pertaining to the associated epoll item because another thread might be
using those resources.

<p> The deleting thread could wait an arbitrary amount of time after
calling epoll_ctl with EPOLL_CTL_DEL and before deleting the item, but this
is inefficient and could result in the destruction of resources before
another thread is done handling an event returned by epoll_wait.

</div>

<p> The fact that the kernel records internal state is the source of a
complication for multithreaded applications. The complication arises from
the fact that applications may also want to maintain state information
about file descriptors. One possible reason for doing this is to prevent
file descriptor starvation, the phenomenon that can occur when, for
example, an application determines that a file descriptor has data
available for reading and then attempts to read all of the available
data. It could happen that there is a very large amount of data available
(for example, another application may be continuously writing data on the
other end of a socket connection). Consequently, the reading application
would be tied up for a long period; meanwhile, it does not service I/O
events on the other file descriptors&mdash;those descriptors are starved of
service by the application.

<p> The solution to file descriptor starvation is for the application to
maintain a user-space data structure that caches the readiness of each of
the file descriptors that it is monitoring. Whenever <tt>epoll_wait()</tt>
informs the application that a file descriptor is ready, then, instead of
performing as much I/O as possible on the descriptor, the application makes
a record in its cache that the file descriptor is ready. The application
logic then takes the form of a loop that (a) periodically calls
<tt>epoll_wait()</tt> and (b) performs a <i>limited</i> amount of I/O on
the file descriptors that are marked as ready in the user-space
cache. (When the application finds that I/O is no longer possible on one of
the file descriptors, then it can mark that descriptor as not ready in the
cache.)

<p> Thus, we have a scenario where the both kernel and a user-space
application are maintaining state information about the same
resources. This can potentially lead to race conditions when competing
threads in a multithreaded application want to update state information in
both places. The most fundamental piece of state information maintained in
both places is "existence".

<p> For example, suppose that an application thread determines that it is
no longer necessary to monitor a file descriptor. The thread would first
check to see whether the file descriptor is marked as ready in the
user-space cache (i.e., there may still be some outstanding I/O to
perform), and then, if the file descriptor is not ready, the thread would
delete the file descriptor from the user-space cache and from the kernel's
epoll interest list using the <tt>epoll_ctl(EPOLL_CTL_DEL)</tt>
operation. However, these steps could fall afoul in scenarios such as the
following involving two threads operating on file descriptor 9:



<blockquote>
<table border=0 cellspacing=2 cellpadding=5 style ="tr.odd  { background-color:#FFF; }">
  <tr>
    <th><b>Thread 1</b>
    </th>
    <th><b>Thread 2</b>
    </th>
  </tr>
  <tr class="Even">
    <td>
      Determine from the user-space cache that descriptor 9 is not ready.
    </td>
    <td>
    </td>
  </tr>
  <tr class="Even">
    <td>
    </td>
    <td>
      Call <tt>epoll_wait()</tt>; the call indicates descriptor 9 as ready.
    </td>
  </tr>
  <tr class="Even">
    <td>
    </td>
    <td>
      Record descriptor 9 as being ready inside the user-space cache so that I/O
      can later be performed.
    </td>
  </tr>
  <tr class="Even">
    <td>
      Delete descriptor 9 from the user-space cache.
    </td>
    <td>
    </td>
  </tr>
  <tr class="Even">
    <td>
      Delete descriptor 9 from the kernel's epoll interest list 
      using <tt>epoll_ctl(EPOLL_CTL_DEL)</tt>.
    </td>
    <td>
    </td>
  </tr>
</table>
</blockquote>

<p>
Following the above scenario, some data will be lost. Other scenarios could
lead to a corrupted cache or an application crash.

<p> No use of (per-file-descriptor) mutexes can eliminate the sorts of
races described here, short of protecting the calls to
<tt>epoll_wait()</tt> with a (global) mutex, which has the effect of
destroying concurrency. (If one thread is blocked in a
<tt>epoll_wait()</tt> call, then any other thread that tries to acquire
the corresponding mutex will also block.)


<h4>Epoll and multithreaded applications: the solution</h4>


<p> Paton's solution to this problem is to extend the epoll API with a new
operation that atomically prevents other threads from receiving further
indications that a file descriptor is ready, while at the same time
informing the caller whether another thread has "recently" been told the
file descriptor is ready. The new operation relies on some of the inner
workings of the epoll API.

<p> When adding (<tt>EPOLL_CTL_ADD</tt>) or modifying
(<tt>EPOLL_CTL_MOD</tt>) a file descriptor in the interest list, the
application specifies a mask of I/O events that are of interest for the
descriptor. For example, the mask might include both <tt>EPOLLIN</tt> and
<tt>EPOLLOUT</tt>, if the application wants to know when the file
descriptor becomes either readable or writable. In addition, the kernel
implicitly adds two further flags to the events mask in the interest list:
<tt>EPOLLERR</tt>, which requests monitoring for error conditions, and
<tt>EPOLLHUP</tt>, which requests monitoring for a "hangup" (e.g., we are
monitoring the read end of a pipe, and the write end is closed). When a
file descriptor becomes ready, <tt>epoll_wait()</tt> returns a mask that
contains all of the requested events for which the file descriptor is
ready. For example, if an application requests monitoring of the read end
of a pipe using <tt>EPOLLIN</tt> and the write end of the pipe is closed,
then <tt>epoll_wait()</tt> will return an events mask that includes both
<tt>EPOLLIN</tt> and <tt>EPOLLHUP</tt>.

<p> As well as the flags that can be used to monitor file descriptors for
various I/O events, there are a few "operational flags"&mdash;flags that
modify the semantics of the monitoring operation itself. One of these is
<tt>EPOLLONESHOT</tt>. If this flag is specified in the events mask for a
file descriptor, then, once the file descriptor becomes ready and is
returned by a call to <tt>epoll_wait()</tt>, it is disabled from further
monitoring (but remains in the interest list). If the application is
interested in monitoring file descriptor once more, then it must re-enable
the file descriptor using the <tt>epoll_ctl(EPOLL_CTL_MOD)</tt> operation.

<!--
<p>
<blockquote>

<img width="350" src="https://static.lwn.net/images/2012/epoll_flags.png" alt="[epoll flags]"
hspace=10 vspace=5>

</blockquote>
-->

<blockquote>

<table border=0 cellspacing=2 cellpadding=4>
  <tr  class="Even">
    <th colspan=2>
      Per-descriptor events mask recorded in an epoll interest list
    </th>
  </tr>
  <tr class="Even">
    <td>
        Operational flags
    </td>
    <td>
        I/O event flags
    </td>
  </tr>
  <tr class="Even">
    <td>
       <tt>EPOLLONESHOT</tt>, 
       <tt>EPOLLET</tt>, ...
    </td>
    <td>
       <tt>EPOLLIN</tt>, 
       <tt>EPOLLOUT</tt>, 
       <tt>EPOLLHUP</tt>, 
       <tt>EPOLLERR</tt>, ...
    </td>
  </tr>
</table>
</blockquote>

<p> The implementation of <tt>EPOLLONESHOT</tt> relies on a trick. If this
flag is set, then, if the file descriptor indicates as being ready
via <tt>epoll_wait()</tt>, the kernel clears all of the
"non-operational flags" (i.e., the I/O event flags) in the events mask for
that file descriptor. This serves as a later cue to the kernel that it
should not track I/O events for this file descriptor.

<p> By now, we finally have enough details to understand Paton's extension
to the epoll API&mdash;the <tt>epoll_ctl(EPOLL_CTL_DISABLE)</tt>
operation&mdash;that allows multithreaded applications to avoid the kind of
races described above. To successfully use this extension requires the
following:

<ol>

<p> <li> The user-space cache that describes file descriptors should also
include a per-descriptor "delete-when-done" flag that defaults to false but
can be set true when one thread wants to inform another thread that a
particular file descriptor should be deleted.

<p> <li> All <tt>epoll_ctl()</tt> calls that add or modify file descriptors
in the interest list must specify the <tt>EPOLLONESHOT</tt> flag.

<p> <li> The <tt>epoll_ctl(EPOLL_CTL_DISABLE)</tt> operation should be used
as described in a moment.

</ol>

<p> In addition, calls to <tt>epoll_ctl(EPOLL_CTL_DISABLE)</tt> and
accesses to the user-space cache must be suitably protected with
per-file-descriptor mutexes. We won't go into details here, but <a
href="/Articles/520019/">the second version</a> of Paton's patch adds a
sample application to the kernel source tree (under
<tt>tools/testing/selftests/epoll/test_epoll.c</tt>) that demonstrates the
principles.

<p> The new epoll operation is employed via the following call:

<pre>
    epoll_ctl(epfd, EPOLL_CTL_DISABLE, fd, NULL);
</pre>

<tt>epfd</tt> is a file descriptor referring to an epoll
instance. <tt>fd</tt> is the file descriptor in the interest list that is
to be disabled. The semantics of this operation handle two cases:

<ul>

<p> <li> One or more of the I/O event flags is set in the interest list
entry for <tt>fd</tt>. This means that, since the last <tt>epoll_ctl()</tt>
operation that added or modified this interest list entry, no other thread
has executed an <tt>epoll_wait()</tt> call that indicated this file
descriptor as being ready. In this case, the kernel clears the I/O event
flags in the interest list entry, which prevents subsequent
<tt>epoll_wait()</tt> calls from returning the file descriptor as being
ready. The <tt>epoll_ctl(EPOLL_CTL_DISABLE)</tt> call then returns zero to
the caller. At this point, the caller knows that no other thread is
operating on the file descriptor, and it can thus safely delete the
descriptor from the user-space cache and from the kernel interest list.

<p> <li> No I/O event flag is set in the interest list entry for
<tt>fd</tt>. This means that since the last <tt>epoll_ctl()</tt> operation
that added or modified this interest list entry, another thread has
executed an <tt>epoll_wait()</tt> call that indicated this file descriptor
as being ready. In this case, <tt>epoll_ctl(EPOLL_CTL_DISABLE)</tt> returns
&ndash;1 with <tt>errno</tt> set to <tt>EBUSY</tt>.  At this point, the
caller knows that another thread is operating on the descriptor, so it sets
the descriptor's "delete-when-done" flag in the user-space cache to
indicate that the other thread should delete the file descriptor once when
it has finished using it.

</ul>

<p> Thus, we see that with a moderate amount of effort, and a little help
from a new kernel interface, a race can be avoided when deleting file
descriptors in multithreaded applications that wish to avoid file
descriptor starvation.


<h4>Concluding remarks</h4>


<p> There was relatively little comment on the first iteration of Paton's
patch. The only substantive comments came from Christof Meerwald; in
response to these, Paton created the second version of his patch. That
version received <i>no</i> comments, and was incorporated into 3.7-rc1. It
would be nice to think that the relatively paucity of comments reflects the
silent agreement that Paton's approach is correct. However, one is left
with the nagging feeling that in fact few people have reviewed the patch,
which leaves open the question: is this the best solution to the problem?

<p> Although <tt>EPOLL_CTL_DISABLE</tt> solves the problem, the solution is
neither intuitive nor easy to use. The main reason for this is that
<tt>EPOLL_CTL_DISABLE</tt> is a bolt-on hack to the epoll API that
satisfies the requirement (often <a href="/Articles/486395/">repeated</a>
by Linus Torvalds) that <i>existing</i> user-space applications must not be
broken by making a kernel ABI change. Within that constraint,
<tt>EPOLL_CTL_DISABLE</tt> <i>may</i> be the best solution to the
problem. However, it seems certain that a better solution might have been
possible if it had incorporated during the <i>original</i> design of the
epoll API. Next week's follow-on article will consider whether a better
initial solution could have been found and also consider why it might not
be possible to find a better solution within the constraints of the current
API.

<p> Finally, it's worth noting that the <tt>EPOLL_CTL_DISABLE</tt> feature
is not yet cast in stone, although it will become so in about two months,
when Linux 3.7 is released. In the meantime, if someone comes up with a
better idea to solve the problem, then the existing approach could be
modified or replaced.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Epoll">Epoll</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#User-space_API">User-space API</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/520012/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor520360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2012 16:00 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/520360/">Link</a>] 
      </p>
      
      </div>
      </summary>
      After this article was published, it has <a rel="nofollow" href="/Articles/520358/">become clear</a> that, thanks partially to Michael's questions, this API is likely to be changed by the final 3.7 release.  Stay tuned.
      
          <div class="CommentReplyButton">
            <form action="/Articles/520360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor520418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2012 20:49 UTC (Thu)
                               by <b>mhelsley</b> (guest, #11324)
                              [<a href="/Articles/520418/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rather than a mutex guarding the epoll fd (and thus the interest set), and rather than EPOLL_CTL_DISABLE, could userspace RCU be used to protect the shared resources of the set until they are unused? I haven't fully thought it through but if it works then that might be another scalable solution which is useable "today".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 12:41 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/520483/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That pretty much boils down to delaying the deletion of the items to a moment where all epoll_waits have been done (since epoll_wait is an RCU quiescence point).<br>
<p>
An efficient solution for an arbitrary number of epoll_wait threads can be implemented even in userspace and without using a full-blown RCU.<br>
<p>
Equip each thread with a) an id or something else that lets each thread refer to "the next" thread; b) a lists of "items waiting to be deleted".  Then the deleting thread adds the item being deleted to the first thread's list.  Before executing epoll_wait, thread K empties its list and "passes the buck", appending the old contents of its list to that of thread K+1.  This is an O(1) operation no matter how many items are being deleted; only Thread N, being the last thread, actually has to go through the list and delete the items.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor520449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 2:25 UTC (Fri)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/520449/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Better solution: since epoll lets you store a generic 64 bit cookie, just use a 64 bit sequence that increments for each new file descriptor.  In a hash table, store the cookie -&gt; fd mapping.  The hash table should be thread safe but still scalable, and you could have a ref count too.  So all wakeups from epoll need to check the hash table to see if the fd still exists, and check it out (bump refcount) if so.<br>
<p>
So unless you need to process more than 2^63 sockets...<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 14:05 UTC (Fri)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/520490/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Better solution: since epoll lets you store a generic 64 bit cookie, just use a 64 bit sequence that increments for each new file descriptor.
</blockquote>

<p>
I haven't thought through your solution very far, but it seems unfortunate to have to chew up the cookie to solve this problem. User space might very want to user the epoll_event.data field for other purposes.
      
          <div class="CommentReplyButton">
            <form action="/Articles/520490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 15:25 UTC (Fri)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/520503/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To clarify, my solution is all user space, no kernel changes.  It's just changing the kernel from holding a 'strong reference' to a 'weak reference'.  (You know what they say about adding a layer of indirection...)<br>
<p>
When I did epoll, I used it in edge_triggered mode (and also not 'oneshot') and had a single thread processing the epoll events and scheduling workers.  I had worker threads that just pumped data to and from the kernel.  I put direct pointers in the epoll data (i.e. strong references) to my internal structures since I had only one thread calling epoll.  <br>
<p>
But if I had multiple threads calling epoll, I think the solution I outlined would work fine.  I don't see what else I would need the cookie for... as long as its still doing its job, pointing to a real data structure of mine.<br>
<p>
And the nice thing is, it works with all epoll modes.  What's very distasteful about the kernel patch is that it requires ONESHOT (yuck!).  <br>
<p>
The epoll designer(s) had their thinking caps on with this api.  Storing arbitrary cookies +  edge triggered mode = Insanely good.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 15:35 UTC (Fri)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/520504/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
But if I had multiple threads calling epoll, I think the solution I outlined would work fine. I don't see what else I would need the cookie for... as long as its still doing its job, pointing to a real data structure of mine.
</blockquote>

<p>
Yes, but other people may want to use the cookie in a quite different way, and it seems a shame to limit the generality of the API by requiring it to be used for this task.

<blockquote>
And the nice thing is, it works with all epoll modes. What's very distasteful about the kernel patch is that it requires ONESHOT (yuck!). 
</blockquote>

<p>
Yes, requiring the use of EPOLLONESHOT is rather unfortunate. I strongly suspect that there could be a solution quite similar to the EPOLL_CTL_DISABLE approach that doesn't require EPOLLONESHOT. I have something in mind, but I need to think about it a little more.
      
          <div class="CommentReplyButton">
            <form action="/Articles/520504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 21:39 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/520547/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ONESHOT is the obvious and easiest way to handle lockless multithreaded processing of an epoll queue. In fact, on Solaris ONESHOT is the only option. There are no persistent events. The kernel, of course, is free to optimize for persistence, but userspace threads don't need to worry about a loaded gun lying around.<br>
<p>
Edge-triggered signaling only provides a nominal percentage improvement in performance. If you're already going multithreaded and attempting lockless, than you're already massively multicore. Why bother adding all the complexity of edge-triggered events? Also, it's worth pointing out that with *BSD kqueue, ONESHOT automatically removes the decriptor from the queue. If epoll followed this excellent example then using ONESHOT would be end of story.<br>
<p>
Seems to me the simplest solution to starvation is to ask the kernel to return events in FIFO order, i.e. the last one installed will also be the last in the next reported pending queue. That way you can use ONESHOT and still guarantee that there's only ever be a single owner of the object, e.g. exactly one of the threads or the kernel.<br>
<p>
For the early termination cases (e.g. a second thread walking a shared queue and destroying sockets), just call shutdown on the socket and let the kernel report it via the normal queue processing.<br>
<p>
The root of the problem here is that people want to use both a message passing pattern via epoll messaging, as well as allow arbitrary threads to jump into the fray and manipulate shared contexts. That's just asking for trouble.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2012 0:23 UTC (Tue)
                               by <b>normalperson</b> (guest, #47508)
                              [<a href="/Articles/521994/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree ONESHOT is awesome for MT and probably should've been the default.<br>
<p>
epoll_wait() already returns ONESHOT events in FIFO order based on my reading of fs/eventpoll.c (and my own testing/experience).  kqueue also seems to return in FIFO order with ONESHOT.<br>
<p>
I wrote a server based on this behavior (along with concurrent calls to epoll_wait(...,maxevents=1,...)) for getting fair distribution between threads stuck in I/O wait a while back: <a href="http://bogomips.org/cmogstored.git">http://bogomips.org/cmogstored.git</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor520476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 10:47 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/520476/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Now, how do I automatically add this excellent documentation to my copy of _The Linux Programming Interface_? The paper just won't update properly! :}<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2012 14:33 UTC (Fri)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/520495/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the kind words. I *do* wish I'd thought of the diagram at the time I wrote TLPI, though. I love having good diagrams...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor521156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 5:14 UTC (Thu)
                               by <b>cyanit</b> (guest, #86671)
                              [<a href="/Articles/521156/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Other solution: pass a pointer to a userspace reference count in a new EPOLL_CTL_ADD_RC, which is incremented in the kernel under the epoll lock when an event concerning that fd is returned to userspace.<br>
<p>
This way, after EPOLL_CTL_DEL either the fd will never be returned or the reference count has been raised already.<br>
<p>
Userspace just needs to be changed to use EPOLL_CTL_ADD_RC and to decrement the reference count after it finished processing the event, and delete the fd data if it goes to zero either at that point or after EPOLL_CTL_DEL.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2012 14:39 UTC (Sun)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/521741/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
so both userspace and the kernel are modifying the reference count?  I'm confused.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor521318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 16:32 UTC (Thu)
                               by <b>happynut</b> (guest, #4117)
                              [<a href="/Articles/521318/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps I'm missing something, but it seems like the proposed solution is to add a synchronous call to control an asynchronous queue.<br>
<p>
Couldn't this be solved with a flag (or an alternate version) of EPOLL_CTL_DEL to add an event to the queue reporting that the delete has been fully processed?<br>
<p>
Then the caller of epoll_wait() could then clean up the remaining application's data structures, with no new locks required.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521740"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2012 14:38 UTC (Sun)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/521740/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How do you know 'what fully processed' means?  Another thread could have been 'woken up' by the kernel, but hasn't gotten around to looking in your internal structures.  If another thread gets the 'deleted processed' event, it could delete the data structure prematurely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521740/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521779"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2012 18:57 UTC (Sun)
                               by <b>happynut</b> (guest, #4117)
                              [<a href="/Articles/521779/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
I mean "fully processed" by the kernel, which is really the only issue; the application can (and indeed: must, even with the proposed EPOLL_CTL_DISABLE change) control its own concurrency issues with its own locks.<br>
<p>
The issue is that the kernel and app are running asynchronously with an implicit race condition around removing file descriptors from epoll; sending a notification through the normal epoll mechanism that the kernel is done should be enough to allow both sides of the API to run asynchronously.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521779/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor521683"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2012 14:16 UTC (Sat)
                               by <b>runciter</b> (guest, #75370)
                              [<a href="/Articles/521683/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is nonsense.  The deleting thread should just mark the cache data for that fd as "ready for deletion" and interrupt the epoll_wait (using a write to a pipe monitored by epoll, for example).  The thread doing epoll_wait() can then synchronously release the resources.  You'll need a mutex for the "ready-for-deletion" flag, but you need it for the "exists" or "ready" flags anyway.  It's just a matter of checking the flags: the deleting thread checks "ready" before deleting; the epoll_wait() thread checks "ready for deletion" before updating "ready".  With a mutex in place there is no race.<br>
<p>
I don't get the point about losing data at all.  You've decided to destroy the userspace cache entry *first*, before epoll_ctl() returned.  Data will be lost either way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521683/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521742"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2012 14:49 UTC (Sun)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/521742/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It sounds like the issue is a timeout case.  The diagram shows one thread sees the file descriptor as not ready (no events) and decides to delete it.  But, then suddenly an event for it comes in and starts processing on another thread.  I don't see how your solution addreses that.  Your pipe wakeup could happen at the same time as a 'real' socket wakeup event.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521742/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE and multithreaded applications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2012 17:59 UTC (Sun)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/521773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My comment was imprecise at best.  I'll clarify what I think you are doing:<br>
<p>
Thread 1 decides the fd is no longer needed, due to no events<br>
Thread 2 gets a wakeup for a real event, but is then scheduled out and does not progress<br>
Thread 1 deletes the socket from epoll, marks fd as needing deletion, and signals via a pipe.<br>
Another thead 3 then reads the pipe and deletes the fd<br>
<p>
That does nothing to address the race with thread 2.  There's still a race, all you've added is the essence of a sleep() which delays things.  (Like the article mentioned, the solution of adding an arbitrary delay).  <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
