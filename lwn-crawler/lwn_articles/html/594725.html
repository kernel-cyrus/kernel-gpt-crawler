        <!DOCTYPE html>
        <html lang="en">
        <head><title>Avoiding memory-allocation deadlocks [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/594725/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/594227/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/594725/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Avoiding memory-allocation deadlocks</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>April 16, 2014</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
There is a saying that you need to spend money to make money, though
this apparent paradox is easily resolved with a start-up loan and the
discipline of balancing expenses against income.  A similar logic
applies to the management of memory in an operating system kernel such
as Linux: sometimes you need to allocate memory to free memory.  Here, too, 
discipline is needed, though the typical consequences of not
being sufficiently careful is not bankruptcy but rather a deadlock.
<p>
The history of how the Linux kernel developed its
balance between saving and spending is interesting as a
microcosm of how Linux development proceeds, and useful in
understanding how to handle future deadlocks when they occur.  A good
place to start this history is in early 1998 with the introduction of
<TT>__GFP_IO</TT> in Linux 2.1.80pre3.
<p>
<h4><TT>__GFP_IO</TT> in 2.1.80pre3</h4>

<p>
Any memory allocation request in Linux includes a <tt>gfp_t</tt> argument,
which is a set of flags to guide how the <tt>get_free_page()</tt> function
can go about locating a free page.  <a
href="https://git.kernel.org/cgit/linux/kernel/git/history/history.git/commit/?id=472bbf0af5bc9f7c933a5d3212b0d765176e728a">2.1.80pre3</a>
marks a change in
this argument's type; it went from being a simple enumerated type to being
a bitmask.
The concepts embodied in each flag were present previously, but this
is the first time that they could be explicitly identified.
<p>

<TT>__GFP_IO</TT> was one of the new flags.  If it was set, then
<tt>get_free_pages()</tt> was allowed to call <tt>shm_swap()</tt> to write some pages
out to swap.  If <tt>shm_swap()</tt> needed to allocate any
<tt>buffer_head</tt> structures to
complete the writeout, it would be careful not to set <TT>__GFP_IO</TT>.
Without this protection, an infinite recursion could easily happen,
which would quickly exhaust the stack and cause the kernel to crash.
<p>
We have <TT>__GFP_IO</TT> in the kernel today, but, despite having the same
name, it is a different flag.  Having been introduced for 2.1.80, the
original <TT>__GFP_IO</TT> was removed in 2.1.116, to be replaced with...
<p>
<h4><TT>PF_MEMALLOC</TT> in 2.1.116</h4>

<p>
In the <a
href="https://git.kernel.org/cgit/linux/kernel/git/history/history.git/commit/?id=ac995a26c87ac75983960cbe4085a77b6bbe3e4d">distant
past</a> (August 1998), we did not have change logs of 
nearly the quality that we have today, so an operating-system archaeologist
is left to 
guess at the reasons for changes.  All we can be really sure of is that
the (per-request) <TT>__GFP_IO</TT> flag to <tt>get_free_page()</tt>
disappeared, and a new 
per-process flag called <TT>PF_MEMALLOC</TT> appeared to take over the task
of avoiding recursion.

One clear benefit of this change is that it is more focused in
addressing one particular issue: recursion is clearly a per-process
issue and so a per-process flag is fitting.  Previously, many memory
allocation sites would avoid <TT>__GFP_IO</TT> when they didn't really need
to, just in case.  Now each call site doesn't need to worry about the
problem of recursion; that concern is addressed precisely where it is needed.
<p>
The code comments here highlight an important aspect of memory
allocation:
<p>
<pre>
	 * The "PF_MEMALLOC" flag protects us against recursion:
	 * if we need more memory as part of a swap-out effort we
	 * will just silently return "success" to tell the page
	 * allocator to accept the allocation.
</pre>
<p>
When possible, <tt>get_free_page()</tt> will just pluck a page
off the free list and return it as quickly as it can.  When that is not
possible, it does not satisfy itself with freeing just one page, but
will try to free quite a few, to save work next time.  Thus, it
is re-stocking that startup loan.

A particular consequence of <TT>PF_MEMALLOC</TT> is that the memory allocator
won't try too hard to gets lots of pages; it will make do with what it
has.
<p>
This means that processes with the <TT>PF_MEMALLOC</TT> flag set will have
access to 
the last 
dregs of free memory, while other processes will need to go out and free up
lots of memory first before they can use any.  This property of
<TT>PF_MEMALLOC</TT> is still present and somewhat more formal in the current
kernel.  The memory allocator has a concept of "watermarks" such that,
if the amount of free memory is below the chosen watermark, the allocator will
try to free more memory rather than return what it has.  Different
<TT>__GFP</TT> flags can select different watermark levels (min, low, high).
<TT>PF_MEMALLOC</TT> causes all watermarks to be ignored; if any memory is
available at all, it will be returned.
<p>
<TT>PF_MEMALLOC</TT> effectively says "It is time to stop saving and start
spending, or we'll have no product to sell".

In consequence of this, <TT>PF_MEMALLOC</TT> is now used more broadly than
just for avoiding recursion (though it still has that role).  Several
kernel threads, such as those for <tt>nbd</tt>, the network block device,
<tt>iscsi_tcp</tt>, and the MMC card controller, all set <TT>PF_MEMALLOC</TT>,
presumably so they can be sure to get memory whenever they are called
upon to write out a page of memory (so it can be freed).
<p>
In contrast, the MTD driver (which manages NAND flash and has a
similar role to the MMC card driver) <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=d5ba1c8ffd0b7d38e1fac48184637e6d6c1197d3">stopped
using</a> the <TT>PF_MEMALLOC</TT> 
flag in 2.6.33 with a comment suggesting it was an inappropriate
usage.  Whether the other uses in the kernel are still justified is a question
too deep for our present discussion.


<p>
<h4><TT>__GFP_IO</TT> in 2.2.0pre6</h4>

<p>
When <TT>__GFP_IO</TT> <a
href="https://git.kernel.org/cgit/linux/kernel/git/history/history.git/commit/?id=70c27ee94003b5e3741c5d36f5a84ac6cc81ae82">reappears</a>
it has a similar purpose as the 
original, but for an importantly different reason.
To understand that reason, it suffices to look at a comment in the code:
<p>
<pre>
	/*
	 * Don't go down into the swap-out stuff if
	 * we cannot do I/O! Avoid recursing on FS
	 * locks etc.
	 */
</pre>
<p>
The concern here still involves recursion, but it also involves locks,
such as the per-inode mutex, the page lock, or various others.
Calling into a filesystem to write out a page may require taking a
lock.  If any such lock is held when allocating memory then it is
important to avoid calling into any filesystem code that might try to
acquire the same lock.  In those cases, the
code must be careful not to pass <TT>__GFP_IO</TT>; in other cases, it is
perfectly safe to include that flag.
<p>
So while <TT>PF_MEMALLOC</TT> avoids the specific recursion of
<tt>get_free_page()</tt> calling into <tt>get_free_page()</tt>, <TT>__GFP_IO</TT> is more
general and prevents any function holding a lock from calling, through
<tt>get_free_page()</tt>, into any other function which might want that lock.
The risk here isn't exhausting the stack as with <TT>PF_MEMALLOC</TT>; the
risk is a deadlock.
<p>
One might wonder why a <TT>GFP</TT> flag was used for this rather than a
process flag, which would effectively say "I am holding a filesystem
lock", given that the previous experience with <TT>__GFP_IO</TT> wasn't a
success.  Like many software designs, it probably just "seemed like a
good idea at the time".
<p>
<h4><TT>__GFP_FS</TT> in 2.4.5.8</h4>

<p>
This flag started life named <TT>__GFP_BUFFER</TT> in 2.4.5.1, but didn't
really work properly until 2.4.5.8 when it was renamed to <TT>__GFP_FS</TT>.
Apparently there was a <a
href="http://git.kernel.org/cgit/linux/kernel/git/tglx/history.git/commit/?id=75b566af5cc6f64f9ab5b66608ff8ce18098a2b4">thinko</a>
in the original design, which required 
not only a range of code changes, but also a new name.
<p>

<TT>__GFP_FS</TT> effectively split some functionality away from <TT>__GFP_IO</TT>
so that where there was one flag, now there were two.  Only three
combinations of the two were expected: neither, both, or the new
possibility of just the <TT>__GFP_IO</TT> flag being set.  This would allow
buffers that were already prepared to be written out, but would
prohibit any calls into filesystems to prepare those buffers.  I/O
activity would be permitted, but filesystem activity would not.
<p>
Presumably, the fact that <TT>__GFP_IO</TT> previously had such a broad effect was
harming performance, in that it had to be excluded in places where some
I/O was still possible.  Refining the rules by adding a new flag led to
more flexibility, and so fewer impediments to performance.
<p>
<h4><TT>PF_FSTRANS</TT> in 2.5.36</h4>

<p>
This new process flag appeared when <a
href="https://git.kernel.org/cgit/linux/kernel/git/tglx/history.git/commit/?id=ef5cc2fd95520561f7e3c8c49b809000dee033ba">XFS
support</a> was merged into Linux 
in late 2002.  Its purpose was to indicate that a filesystem
transaction (hence the name) was being prepared, meaning that any
write to the filesystem would likely block until the transaction
processing was complete.

The effect of this flag was to exclude <TT>__GFP_FS</TT> from any memory
allocation request which happened while <TT>PF_FSTRANS</TT> was set, or at
least any request from within the XFS code.  Other requests would not
be affected, but then other code that allocated memory would be
unlikely to be called while the flag was set.
<p>
Another way to see this flag is that, in the same way that the
original <TT>__GFP_IO</TT> was converted to <TT>PF_MEMALLOC</TT>, now <TT>__GFP_FS</TT> is
being converted to a process flag, too.  In this case, the conversion is
not complete, though.
<p>
Back in the halcyon days of 2.1.116, removing a flag like <TT>__GFP_IO</TT>
was quite straightforward — there were few users and the implications of
the change
could be easily understood.  In the more complex times of 2.5.36,
such a step would be far from easy.  Carefully adding new
functionality is one thing, removing something that is entrenched is
quite another, as we have seen with the <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4ba8216cd90560bc402f52076f64d8546e8aefcb">Big
Kernel Lock</a> and the 
<a href="https://lwn.net/Articles/593670/"><tt>sleep_on()</tt>
interface</a>.  Allowing either the new flag or the absence of 
the old to have the same effect is not a big cost and it was best to
leave things that were working alone.
<p>

Skipping ahead of ourselves a little to <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=5cf02d09b50b1e">3.6-rc1</a>,
the <TT>PF_FSTRANS</TT> 
flag also gets used by NFS.  Rather than setting it during a
transaction, NFS sets it while constructing and transmitting an RPC
request onto the network, so the name is now slightly less appropriate.

Also the effect of the flag on NFS is not exactly to clear <TT>__GFP_FS</TT>,
but simply to avoid a call to transmit a <TT>COMMIT</TT> request inside
<tt>nfs_release_page()</tt>, which is also avoided  if <TT>__GFP_FS</TT> is missing.

This is a superficially different usage than the usage by XFS, but it has
a generally similar effect for a generally similar reason.   Modifying
the flag to have a more global effect of clearing <TT>GFP_FS</TT> and maybe
renaming it to <TT>PF_MEMALLOC_NOFS</TT> might not be a bad idea.
<p>
<h4><tt>set_gfp_allowed_mask()</tt> in 2.6.34</h4>
<p>
This function actually <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7e85ee0c1d15ca5f8bff0f514f158eba1742dd87">appeared</a>
in <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=dcce284a259373f9e5570f2e33f79eca84fcf565">2.6.31</a>,
but becomes more interesting in 2.6.34.

<p>
<tt>gfp_allowed_mask</tt> is a global variable holding a set of <TT>GFP</TT> flags
which are allowed to be honored — all others are ignored.  In
particular, <TT>__GFP_FS</TT>, <TT>__GFP_IO</TT>, and <TT>__GFP_WAIT</TT> (which generally
allows <tt>get_free_page()</tt> to wait for memory to be freed by other
processes) are sometimes disabled via this mechanism.  Thus it is a bit like
<TT>PF_FSTRANS</TT>, except that it affects more processes and disables more
flags.
<p>
<tt>gfp_allowed_mask</tt> came about while providing support for
<tt>kmalloc()</tt> 
earlier in the boot process.  During early boot, interrupts are still
disabled and any attempt to allocate memory with <TT>__GFP_WAIT</TT> or
certain other flags can trigger a warning from the <tt>lockdep</tt>
checker.  It would be 
surprising if memory were so tight during boot that the allocator
actually needed to wait, but getting rid of warnings is generally a
good thing, so <tt>gfp_allowed_mask</tt> was initialized to exclude the three
flags mentioned, and these were added back in once the boot process
was complete.
<p>
One thing we have learned over the years is that boot isn't as special
as we sometimes think: whether it is suspend and resume, or hotplug
hardware which teaches us this, it seems to be a lesson we keep
finding new perspectives on.

In that light, it is perhaps unsurprising that, in <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=452aa6999e6703ffbddd7f6ea124d3968915f3e3">2.6.34</a>,
the use of this mask was extended to 
cover suspend and resume  (though an <a
href="https://lkml.org/lkml/2009/6/12/82">early version</a> of the original 
patch did mention the importance of suspend).
<p>

In the case of memory allocation deadlocks, the suspend case is more
significant than the boot case.  During boot there is usually lots of
free memory — not so during suspend, when we may well be
short of memory.  It wasn't warnings that prompted this change, but
genuine deadlocks.
<p>
Suspend and resume are largely orderly processes, with devices
being put to sleep in sequence, and then woken again in the reverse
sequence.  So it would not be enough just for block devices to avoid
using <TT>__GFP_IO</TT> (which they already do).  Rather, every driver must
avoid the <TT>__GFP_IO</TT> flag, and others, as the target block device of
some write request, might be sequenced with this driver so that it is
already asleep, and will not awake before this one is completely awake.
<p>
Having a system-wide setting to disable these flags may be a bit
excessive — just the process which is sequencing suspend might be
sufficient — but it is certainly an easy fix and, as it cannot affect
normal running of the system, it is thus a safe fix.
<p>
<h4><TT>PF_MEMALLOC_NOIO</TT> in 3.9-rc1</h4>
<p>
Just as suspend/resume has taught us that boot-time is not that much
of a special case, so too runtime power management has taught us that
suspend isn't all that much of a special case either.

If a block device is runtime-suspended to save power, then obviously it
cannot handle requests to write out a dirty page of memory until it
has woken up, and until any devices it depends on (a USB controller, a PCI
bus) are awake too.  So none of these devices can safely perform
memory allocation using <TT>__GFP_IO</TT>.
<p>
In order to ensure this, we could use <tt>set_gfp_allowed_mask()</tt> while a
device was suspending or resuming, but if multiple such devices were
suspending or resuming we could easily lose track of when to restore the
right mask.

So <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=21caf2fc1931b485483ddd254b634fa8f0099963">this
change</a> introduces a process flag much like <TT>PF_FSTRANS</TT>, 
only to disable <TT>__GFP_IO</TT> rather than <TT>__GFP_FS</TT>.  It also takes care
to record the old value whenever the flag is set, and restore that old
value when done.  To know when to set this flag, a <tt>memalloc_noio</tt> flag
is introduced for each device; it is then propagated into the
parents in the device tree.  <TT>PF_MEMALLOC_NOIO</TT> is set whenever
calling into the power management code for any device with
<tt>memalloc_noio</tt> set. 
<p>

As both the early boot processing and the suspend/resume processing
are largely single-threaded (or have dedicated threads), it is quite
possible that setting <TT>PF_MEMALLOC_NOIO</TT> and <TT>PF_FSTRANS</TT> on those
threads would be a sufficient alternative to using
<tt>set_gfp_allowed_mask()</tt>.  However, as there is no clear benefit from
such a change, and no clear certainty that it would work, it is safer,
once again, to leave that which works alone.
<p>
<h4>Patterns that emerge</h4>
<p>
Amid all these details there are a couple of patterns which stand
out.
<p>
The first is repeated refinement of the "avoid recursion" concept.  At
first it was implicit in an enumerated value passed to
<tt>get_free_page()</tt>, then it was made explicit in the first <TT>__GFP_IO</TT>,
and then the <TT>PF_MEMALLOC</TT> flag.  Next it was extended to cover more subtle forms of
recursion with the second version of <TT>__GFP_IO</TT> and, finally, that was
split into 
two separate flags to express an even wider range of recursion
scenarios that can be separately avoided.
<p>
It is conceivable that there is room for further refinement.  We could
have separate flags for different sorts of locks &mdash; one for
page locks and one for inode locks, for example.  There is no evidence
that this would presently be useful, but Linux isn't really finished
yet, so we just don't know.
<p>
The second pattern is the repeated discovery that just having a <TT>GFP</TT> flag
often isn't enough — three times a new process flag was added because
sometimes it isn't just a single allocation that needs to be
controlled, but all allocations made by a given process.  Is it only a
matter of time before we get either a process flag which disables
<TT>__GFP_WAIT</TT> or a per-process <tt>gfp_allowed_mask</tt>?
<p>
As a footnote to this pattern, it is amusing that in <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b37f1dd0f543d9714f96c2f9b9f74f7bdfdfdf31">3.6-rc1</a>,
as part 
of adding support for swap-over-NFS, a new flag, <TT>__GFP_MEMALLOC</TT>, was
added which has much the same effect as <TT>PF_MEMALLOC</TT> in ignoring the
normal low-watermarks and providing access to the last reserves of
memory.


This, together with the per-socket <tt>sk_allocation</tt> mask, allows
certain TCP sockets (those which NFS is performing swap over) to access
those last reserves to make sure that swap-out always succeeds.

Clearly there is need for both <TT>GFP</TT> flags and process flags, as well as
some per-device and per-socket flags.
<p>
<h4>We've not seen the last of this</h4>

<p>
While studying history can be generally enlightening, it can also be
specifically useful as it is in this case.  Next week, we will use this
understanding of memory allocation deadlocks to explore some
deadlocks which have long been possible in a certain configuration,
but which now need to be removed.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#gfp_t">gfp_t</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management">Memory management</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/594725/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor594977"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2014 13:22 UTC (Wed)
                               by <b>blackwood</b> (guest, #44174)
                              [<a href="/Articles/594977/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent article. One bit I've missed though is some mention that lockdep is tracking the NOFS (or NOIO, I've forgotten which one it does track) allocation context and will detect and catch potential deadlocks even without actually being under memory pressure. Which is a really awesome and powerful debug feature and I wonder how that affects interface design tradeoffs for all the different ways to specify allocation constraints (i.e. per-allocation, per-process or global).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/594977/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor594983"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2014 14:43 UTC (Wed)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/594983/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is this really all as haphazard and ad-hoc as the article makes it seem? Is the problem space equally chaotic, so that only a reactive, band-aid approach works?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/594983/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor595030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2014 15:57 UTC (Wed)
                               by <b>RelytDeveloper</b> (guest, #96089)
                              [<a href="/Articles/595030/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I may not be fully qualified to answer your question, but Kernel.org uses the GIT change management control platform; and hosts several instances of cGIT, a web-based GIT wrapper.<br>
<p>
The Kernel is big. It's probably too big to read, and likely too big to understand in one sitting.<br>
<p>
Using techniques such as GIT Bi-Section, find, locate, grep, awk, and sed are necessary tools to manage such a large code base.<br>
<p>
Since we did not always have GIT, records of the Kernel pre-dating GIT are spotty. A Git-Bi-Section compares the last known working code base to the regression code base, and tells you which Change-ID-hashes account for the trouble.<br>
<p>
It is a professional quality GNU/Linux Kernel, but it spans many architectures and lieutenant-headed projects, and eight (?) versions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/595030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor595494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 19, 2014 7:51 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/595494/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ncm wasn't talking about the process of analyzing the problem -- he was talking about the somewhat chaotic and ad-hoc 'add this gfp flag, whoops, that's not enough, make it a pf, now add a mask to ignore it again' iterative process.<br>
<p>
I'd say this is unavoidable, not so much because the solution space is so large as because the requirements change. Things like swap-over-NFS, suspend, early kmalloc etc imposed new requirements regarding things like allocator locks that simply weren't there before. e.g. before swap-over-networking turned up, you could safely chuck away network packets that arrived when under heavy memory pressure: they'd be retransmitted later and all would be fine. But if that might be part of the swapout process, suddenly you can't ignore that any more and the whole panoply of mm locks collides with the whole panoply of networking locks and the networking layer's own allocations and, well...<br>
<p>
I'll admit that I'm amazed that anything got done at all before lockdep was around. Even with lockdep, locking hierarchy maintenance still feels terribly haphazard. There's really not much documentation even for crucial core locks like the mmap_sem (one comment partially documenting core parts of the locking hierarchy, that's all). You're just expected to know, and if you don't know and lockdep doesn't save you (e.g. if spinlocks are involved) expect a nice long fun crashy debugging session.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/595494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor595103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2014 22:44 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/595103/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is this really all as haphazard and ad-hoc as the article makes it seem?</font><br>
<p>
yes and no<br>
<p>
when a lock in introduced, there is a lot of analysis to try and make sure that there are no problems. It's not haphazard and ad-hoc<br>
<p>
However, when you get a random bug report to analyze, you don't know if it is a locking error, what lock it could be, in what subsystem, let alone the changes since that lock went in place.<br>
<p>
remember that in the last release cycle, there were just over 12,000 different changes from 14,000 individuals that added 591,000 lines of code while removing 250,000 lines<br>
<p>
with the code this large, nobody can keep track of everything, and you can't put out a call to everyone to look at any one bug (let alone all of them).<br>
<p>
The bisection approach lets you narrow down where the problem was introduced, so that you can get the correct people involved to troubleshoot it.<br>
<p>
It's actually an incredibly efficient process, as much as it seems ad-hoc and haphazard at first glance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/595103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor595336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 17, 2014 19:23 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/595336/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was thinking the same thing after reading this article - amazement that it even works.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/595336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor595570"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2014 17:27 UTC (Mon)
                               by <b>bourbaki</b> (guest, #84259)
                              [<a href="/Articles/595570/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent article. I, for one, would love to see more "history" article like this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/595570/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor595594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2014 23:03 UTC (Mon)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/595594/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm with you Nic!  This is great stuff to read.<br>
<p>
Cheers<br>
Jon<br>
<p>
PS Apologies if your nic. (ha!) is actually your name and not related to the mathematician(s).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/595594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor595913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding memory-allocation deadlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2014 6:44 UTC (Thu)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/595913/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I strongly suspect that the reason the "new" GFP_IO was an allocation flag rather than a process flag is that a given piece of code should generally know exactly what locks may be held when it is called (hence it knows whether to supply GFP_IO or not), but you cannot expect any particular piece of code to know whether it's being called within a memory allocation path or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/595913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor596405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">explaining acronyms on first usage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2014 21:08 UTC (Sat)
                               by <b>tpo</b> (subscriber, #25713)
                              [<a href="/Articles/596405/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be nice if on the first mention of GFP the article could note that it's an abbreviation of "Get Free Page". Like this for example:<br>
<p>
"A good place to start this history is in early 1998 with the introduction of the __GFP_IO (Get Free Page) flag in Linux 2.1.80pre3.<br>
<p>
Thanks for the article!<br>
*t<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/596405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor596507"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">explaining acronyms on first usage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2014 22:32 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/596507/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your request is certainly in line with the LWN author guidelines:<br>
<p>
<font class="QuotedText">&gt; Acronyms should be spelled out on their first use, except for the most common and obvious ones (i.e. GNU, GPL).</font><br>
<p>
I think I felt that the close proximity to a mention of "get_free_pages()" was sufficient to make it clear.  Of course, what is clear to one person may not be clear to another.<br>
<p>
Thanks for the feedback.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/596507/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor596938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">explaining acronyms on first usage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2014 10:29 UTC (Thu)
                               by <b>tpo</b> (subscriber, #25713)
                              [<a href="/Articles/596938/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see that you did not (yet?) update the article. Technical kernel LWN articles seem to quickly acquire "defacto reference documentation" status. <br>
<p>
<font class="QuotedText">&gt; I think I felt that the close proximity to a mention of "get_free_pages()" was sufficient to make it clear.</font><br>
<p>
I agree. All the same I managed to read the whole article trying to understand the technical problems (which are far from trivial to see through) wondering until the end what GFP would be standing for... and finally googled it. Then I slapped my head.<br>
<p>
But I think me being a stupid human being is not central here. The aim with documentation should be to make it as easy as possible for the reader to understand the technical issues and from that standpoint and this LWN article joining the "reference documentation" I think updating the article would be a good thing to do.<br>
<p>
:-)<br>
<p>
Thanks Neil!<br>
*t<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/596938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor601746"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">explaining acronyms on first usage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2014 13:03 UTC (Mon)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/601746/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; it's an abbreviation of "Get Free Page"</font><br>
<p>
After 10.5 years I know what "gfp" means.<br>
At last!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/601746/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
