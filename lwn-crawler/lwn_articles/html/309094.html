        <!DOCTYPE html>
        <html lang="en">
        <head><title>Tux3: the other next-generation filesystem [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/309094/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/308809/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/309094/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Tux3: the other next-generation filesystem</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 2, 2008</br>
           </div>
There is a great deal of activity around Linux filesystems currently.  Of
the many ongoing efforts, two receive the most attention: ext4, the
extension of ext3 expected to keep that filesystem design going for a few
more years, and btrfs, which is seen by many as the long-term filesystem of
the future.  But there is another project out there which is moving quickly
and is worth a look: Daniel Phillips's Tux3 filesystem.
<p>
Daniel is not a newcomer to filesystem development.  His <a
href="http://lwn.net/2000/0831/a/tux2.php3">Tux2</a> filesystem was
announced in 2000; it attracted a fair amount of interest until it <a
href="http://lwn.net/2000/1005/a/tux2-patents.php3">turned out</a> that
Network Appliance, Inc. held patents on a number of techniques used in
Tux2.  There was some talk of filing for defensive patents, and Jeff Merkey
<a
href="http://lkml.indiana.edu/hypermail/linux/kernel/0010.0/0491.html">popped
up</a> for long enough to claim to have hired a patent attorney to help
with the situation.  What really happened is that Tux2 simply faded from
view.
Tux3 is built on some of the same ideas as Tux2, but many of those ideas
have evolved over the eight intervening years.  The new filesystem, one
hopes, has changed enough to avoid the attention of NetApp, which has shown
a willingness to use software patents to defend its filesystem turf.
<p>

Like any self-respecting contemporary filesystem, Tux3 is based on
B-trees.  The inode table is such a tree; each file stored within is also a
B-tree of blocks.  Blocks are mapped using extents, of course - another
obligatory feature for new filesystems.  Most of the expected features are
present.  In many ways, Tux3 looks like yet another POSIX-style filesystem,
but there are some interesting differences.
<p>

Tux3 implements transactions through a forward-logging mechanism.  A set of
changes to the filesystem will be batched together into a "phase," which is
then written to the journal.  Once the phase is committed to the journal,
the transaction is considered to be safely completed.  At some future time,
the filesystem code will "roll up" the journal changes and write them back
to the static version of the filesystem.
<p>
The logging implementation is interesting.  Tux3 uses a variant of the
copy-on-write mechanism employed by Btrfs; it will not allow any filesystem
block to be overwritten in place.  So writing to a block within a file will
cause a new block to be allocated, with the new data written there.  That,
in turn, will require that the filesystem data structure which maps
file-logical blocks to physical blocks (the extent) will need to be changed
to reflect the new block location.  Tux3
handles this by writing the new blocks directly to their final location,
then putting a "promise" 
to update the metadata block into the log.  At roll-up time, that promise
will be fulfilled through the allocation of a new block and, if necessary,
the logging of a promise to change the next-higher block in the tree.  In
this way, changes to files propagate up through the filesystem one step at
a time, without the need to make a recursive, all-at-once change.
<p>
The end result is that the results of a specific change can remain in the
log for some time.  In Tux3, the log can be thought of as an integral part
of the filesystem's metadata.  This is true to the point that Tux3 doesn't
even bother to roll up the log when the filesystem is unmounted; it just
initializes its state from the log when the next mount happens.  Among
other things, Daniel says, this approach ensures that the journal recovery
code will be well-tested and robust - it will be exercised at every
filesystem mount.
<p>

In most filesystems, on-disk inodes are fixed-size objects.  In Tux3,
instead, their size will be variable.  Inodes are essentially containers
for attributes; in Tux3, normal filesystem data and extended attributes are
treated in almost the same way.  So an inode with more attributes will be
larger.  Extended attributes are compressed through the use of an "atom
table" which remaps attribute names onto small integers.  Filesystems with
extended attributes tend to have large numbers of files using attributes
with a small number of names, so the space savings across an entire
filesystem could be significant.
<p>
Also counted among a file's attributes are the blocks where the data is
stored.  The Tux3 design envisions a number of different ways in which file
blocks can be tracked.  A B-tree of extents is a common solution to this
problem, but its benefits are generally seen with larger files.  For
smaller files - still the majority of files on a typical Linux system - data can be
stored either directly in the inode or at the other end of a simple block
pointer.  Those representations are more compact for small files, and they
provide quicker data access as well.  For the moment, though, only extents
are implemented.
<p>

Another interesting - but unimplemented - idea for Tux3 is the concept of
<a href="http://lwn.net/Articles/288896/">versioned pointers</a>.  The
btrfs filesystem implements snapshots by retaining a copy of the entire
filesystem tree; one of these copies exists for every snapshot.  The
copy-on-write mechanism in btrfs ensures that those snapshots share data
which has not been changed, so it is not as bad as it sounds.  Tux3 plans
to take a different approach to the problem; it will keep a single copy of
the filesystem tree, but keep track of different versions of blocks (or
extents, really) within that tree.  So the versioning information is stored
in the leaves of the tree, rather than at the top.
But the versioned extents idea <a
href="/Articles/309166/">has been deferred for now</a>, in favor of getting
a working filesystem together.
<p>

Also removed from the initial feature list is support for subvolumes.  This
feature initially seemed like an easy thing to do, but interaction with
<tt>fsync()</tt> proved hard.  So Daniel finally <a
href="/Articles/309168/">concluded</a> that volume management was best left
to volume managers and dropped the subvolume feature from Tux3.
<p>

One feature which has never been on the list is checksumming of data.
Daniel once <a
href="http://kerneltrap.org/node/16428#comment-304303">commented</a>:
<p>
<div class="BigQuote">
	Having been checksumming filesystem data during continuous
	replication for two years now on multiple machines, and having
	caught exactly zero blocks of bad data passed as good in that time,
	I consider the spectre of disks passing bad data as good to be
	largely vendor FUD. That said, checksumming will likely appear in
	the feature list at some point, I just consider it a decoration,
	not an essential feature.
</div>
<p>
Tux3 development is far from the point where the developers can worry about
"decorations"; it remains, at this point, an embryonic project being pushed
by a developer with a bit of a reputation for bright ideas which never
quite reach completion.  The code, thus far, has been developed in user
space using FUSE.  There is, 
however, <a href="http://lwn.net/Articles/308652/">an in-kernel version</a>
which is now ready for further development.  According to Daniel:
<p>
<div class="BigQuote">
	The functionality we have today is roughly like a buggy Ext2 with
	missing features.  While it is very definitely not something you
	want to store your files on, this undeniably is Tux3 and
	demonstrates a lot of new design elements that I have described in
	some detail over the last few months.  The variable length inodes,
	the attribute packing, the btree design, the compact extent
	encoding and deduplication of extended attribute names are all
	working out really well.
</div>
<p>
The potential user community for a stripped-down ext2 with bugs is likely
to be relatively small.  But the Tux3 design just might have enough to
offer to make it a contender eventually.  
<p>
First, though, there are a few little
problems to solve.  At the top of the list, arguably, is the complete lack
of locking - locking being the rocks upon which other filesystem projects
have run badly aground.  The code needs some cleanups - little problems
like the almost complete lack of comments and the use of macros as formal
function parameters  are likely to raise red flags on wider review.  Work
on an fsck utility does not appear to have begun.  There has been no real
benchmarking work done; it will be interesting to see how Daniel can manage
the "never overwrite a block" policy in a way which does not fragment files
(and thus hurt performance) over time.  And so on.
<p>

That said, a lot of these problems could end up being resolved rather
quickly. Daniel has put the code out there and appears to have attracted an
energetic (if small) community of contributors.  Tux3 represents the core
of a new filesystem with some interesting ideas.  Code comments may be
scarce, but Daniel - never known as a tight-lipped developer - has posted a
wealth of information which can be found in the <a
href="http://news.gmane.org/group/gmane.comp.file-systems.tux3/last=/force_load=t">Tux3
mailing list archives</a>.  Potential contributors should be aware of <a
href="/Articles/309174/">Daniel's licensing scheme</a> - GPLv3 with a
reserved unilateral right to relicense the code to anything else - but
developers who are comfortable with that are likely to find an interesting
and fast-moving project to play in.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Tux3">Filesystems/Tux3</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/309094/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor309239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2008 19:20 UTC (Tue)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/309239/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I look forward to a stable Tux3 FS!<br>
<p>
I know that with the whole reiserfs debate there was talk of adding a generic journaling layer to the kernel, and now tux3 will have some form of transaction support!  But, has anyone considered adding entire FS transactions to the VFS API layer (including the ability to rollback) to help with the future development of distributed redundant filesystems?  <br>
<p>
It seems like there are many new distributed filesystems also in development.  If they do have data redundancy, most of them do not do it in a transactional manner yet, probably because it is hard.  However, if these FSes had sub filesystem kernel support for transactions, this might become much easier.  <br>
<p>
Hmm, maybe some tricks could even be played to use snapshots in this way?  A brute force approach might even be to use lvm snapshots, but this might seriously stress lvm if a new snapshot were required for every FS write and it could also mean severe performance penalties.  However, an lvm fallback method would allow transactions to be added to the kernel VFS layer even for older filesystems such as FAT.  <br>
<p>
If this suggested in kernel transaction support could allow commit/rollback decisions to be exported to userspace, I would think that it could easily be used (and would be very welcomed) by distributed FS designers.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2008 19:35 UTC (Tue)
                               by <b>sbergman27</b> (guest, #10767)
                              [<a href="/Articles/309247/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"""<br>
I know that with the whole reiserfs debate there was talk of adding a generic journaling layer to the kernel<br>
"""<br>
<p>
I thought that was jbd?<br>
<p>
<a href="http://en.wikipedia.org/wiki/Journaled_block_device">http://en.wikipedia.org/wiki/Journaled_block_device</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2008 19:59 UTC (Tue)
                               by <b>avik</b> (guest, #704)
                              [<a href="/Articles/309252/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
jbd is an in-kernel interface for journalling changes to block devices.  What is described here is a filesystem-level, user-visible transaction support.<br>
<p>
Consider:<br>
<p>
  begin transaction<br>
  yum update<br>
  test test test<br>
  commit transaction (or abort transaction)<br>
<p>
Useful work can continue to be performed while the update takes place, and is not lost in case of rollback.<br>
<p>
I believe NTFS supports this feature.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor310348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2008 14:48 UTC (Tue)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/310348/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <pre>
begin transaction
yum update
test test test
commit transaction
</pre>

<p>
This sounds like a nice idea at first, but you're forgetting an essential step: if you have multiple 
transactions outstanding, you need some way to combine the results to get a consistent filesystem.</p>

<p>For example, suppose that the yum transaction modified <code>/etc/motd</code>, and a user 
edited this file at the same time (before the yum transaction was committed).  What is
the final, consistent value of this file after the transaction?</p>

<p>
From DBMSes you can find lots of different strategies to deal with these cases.  A non-exhaustive
list might include: Don't permit the second transaction to succeed.  Always take the result of the first (or 
second) transaction and overwrite the other.  Use a merge strategy (and there are many different sorts).
</p>

<p>
As usual in computer science, there is a whole load of interesting, accessible theory here, which is
being completely ignored.  My favorite which is directly relevant here is
<a href="http://okmij.org/ftp/Computation/Continuations.html#zipper-fs">Oleg's Zipper 
filesystem</a>.
</p>

<p>Rich.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/310348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor310427"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2008 20:26 UTC (Tue)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/310427/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are correct, that is actually quite more advanced than what I was proposing.  But since I did not go into any details about what I was asking for, I can hardly object. :)   The real problem with the above, apart from perhaps being difficult to achieve, is that it would likely break posix semantics!<br>
<p>
The yum proposal probably assumes that I could have multiple writes interleaved with reads from the same locations that could succeed in one transaction and then possibly be rolled back.  Posix requires that once a write succeeds any reads to the same location that succeed after the write report the newly written bytes.  To return a read of some written bytes to any process, even the writer, with the transaction pending, and to then rollback the transaction and return in a read what was there before the write, to any process, would break this requirement.  The yum example above probably requires such "broken" semantics.<br>
<p>
What I was suggesting is actually something much simpler than the above:  a method to allow a transaction coordinator to intercept every individual write action (anything that modifies the FS) and decide whether to commit of rollback the write (transaction).  <br>
<p>
The coordinator would intercept the write after the FS signals "ready to commit".  The write action would then block until either a commit or a rollback is received from the coordinator.  This would not allow any concurrent read or writes to the portion of the object being modified during this block, ensuring full posix semantics.  <br>
<p>
For this to be effective with distributed redundant filesystems, once the FS has signaled ready to commit, the write has to be able to survive a crash so that if the node hosting the FS crashes, the rollback or commit can be issued upon recovery (depending on the coordinator's decision) and reads/writes must continue to be blocked until then (even after the crash!)<br>
<p>
If the commit is performed, things continue as usual, if there is a rollback, the write simply fails.  Nothing would seem different to applications using such an FS, except for a possible (undetermined) delay while the coordinator decides to commit or rollback the transaction.<br>
<p>
<p>
That's all I had in mind, not bunching together multiple writes. It should not actually be that difficult to implement, the tricky part is defining a useful generic interface to the controller that would allow higher level distributed FSes to use it effectively.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/310427/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor309303"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2008 0:00 UTC (Wed)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/309303/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not that JBD has many users. Reiser4, JFS, XFS and btrfs all use their own journalling. Leaves... ext3 to use jbd. Wow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309303/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2008 12:40 UTC (Wed)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/309345/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>Reiser4, JFS, XFS and btrfs all use their own journalling. Leaves... ext3 to use jbd.</i>
<br><br>
And OCFS2.  JBD was created at a time when it seemed as though all future filesystems would  be journalling filesystems.  Incidentally, any filesystem developer who overlooks Stephen Tweedie's copious writings on the JBD design, does so at their peril whether they intend to use journalling or some other atomic commit model.
	
      
          <div class="CommentReplyButton">
            <form action="/Articles/309345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor309261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2008 20:33 UTC (Tue)
                               by <b>aigarius</b> (guest, #7329)
                              [<a href="/Articles/309261/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One other common utility that Linux filesystem developers often forget is undelete - a tool that would analyse the filesystem and report what files and what versions of files it can recover. This should be simple enough to implement in Tux3.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2008 23:01 UTC (Tue)
                               by <b>jmorris42</b> (guest, #2203)
                              [<a href="/Articles/309289/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; undelete - a tool that would analyse the filesystem and</font><br>
<font class="QuotedText">&gt; report what files and what versions of files it can recover.</font><br>
<p>
Sounds like you are stuck in DOS mode.  For an undelete in a real OS, beyond the Windows 'trashcan' desktop GUIs implement, it should be a "Do or Do Not, there is no try." deal.  Either have real file versioning, snapshots, etc. or don't bother.  Snuffling around on the platters for raw blocks and just blanking out the first letter of file names are bad ideas best left in the dustbin of history.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2008 23:26 UTC (Tue)
                               by <b>Ze</b> (guest, #54182)
                              [<a href="/Articles/309295/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p><i>Sounds like you are stuck in DOS mode. For an undelete in a real OS, beyond the Windows 'trashcan' desktop GUIs implement, it should be a "Do or Do Not, there is no try." deal. Either have real file versioning, snapshots, etc. or don't bother. Snuffling around on the platters for raw blocks and just blanking out the first letter of file names are bad ideas best left in the dustbin of history.</i></p>
undelete through versioning is bloody useful. However it's no substitute for a tool that tries to recover data when there has been a failure. When people are writing filesystems they often don't think about how they could make it easier for themselves or others to write a tool to recover corrupted data in the event of various failures (both software and hardware).

Personally I don't see the loss of logical volumes as a big deal. I've never understood the point of them when you could just have a fast index in the first place.
      
          <div class="CommentReplyButton">
            <form action="/Articles/309295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309333"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2008 9:48 UTC (Wed)
                               by <b>niner</b> (subscriber, #26151)
                              [<a href="/Articles/309333/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hardware failures and accidental deletion is what we have backups for.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309333/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 3:54 UTC (Thu)
                               by <b>Ze</b> (guest, #54182)
                              [<a href="/Articles/309537/">Link</a>] 
      </p>
      
      </div>
      </summary>
      >Hardware failures and accidental deletion is what we have backups for
I would argue that accidental deletion is one of the things that versioning should handle.

Unfortunately backups offer only limited granularity along with people failing to use or test them. When you combine all that you can see why people a clear need for data recovery tools.

People clearly feel a need for recovery tools since there are quite a few tools on the market both free and commercial. It makes sense to consider that use case when designing a file system. It can only lead to better documented and designed file system.
      
          <div class="CommentReplyButton">
            <form action="/Articles/309537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor309706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 17:40 UTC (Thu)
                               by <b>lysse</b> (guest, #3190)
                              [<a href="/Articles/309706/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, and you'll still have backups for it in the future. But wouldn't it be nice to have a way out of your last backup having gone up in flames at a really inconvenient time? Is there some reason why it would be desirable to limit the number of ways of thwarting Murphy we permit ourselves? Because honestly, I can't think of one...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor309631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 12:15 UTC (Thu)
                               by <b>smitty_one_each</b> (subscriber, #28989)
                              [<a href="/Articles/309631/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a side effect, consider that you could end up making real deletion of information (say, credit card numbers) harder.<br>
Amdist all the great work (which is well above my skill level, kudos to all) there are ramifications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor309293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2008 23:04 UTC (Tue)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/309293/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <i>One other common utility that Linux filesystem developers often forget is undelete - a tool that would analyse the filesystem and report what files and what versions of files it can recover. This should be simple enough to implement in Tux3.</i>
<br><br>
It's on the to.do list.  The standard argument against undelete is that it can be implemented at a higher level, as a move to a Trash folder in place of a delete.  In practice, there is often not a gui around, and it doesn't help when you are running a shell under the gui.  So if it turns out to be easy to do as part of the versioning, Tux3 will have it.
<br><br>
Regards,

Daniel

      
          <div class="CommentReplyButton">
            <form action="/Articles/309293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2008 2:55 UTC (Wed)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/309313/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doesn't Tux3 support snapshots (or won't it, in the future)?  With snapshots you don't need undelete.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2008 7:23 UTC (Wed)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/309324/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Snapshots do not take care of all undelete cases - you might not have taken a snapshot before deleting something important.  But I am thinking in terms of using the snapshot mechanism to support undelete, essentially creating an "anonymous snapshot" just for the directory where the delete happened.  This could be done without wasting a lot of space by using Tux3's versioned attribute model, which would avoid having to use a full disk block just to remember a single undeleted name.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2008 8:05 UTC (Wed)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/309325/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've seen your email exchange with Matt Dillon on tux3 and hammer on the dragonfly lists some time back.  Hammer can take snapshots at very fine-grained interval -- say every few minutes -- via a cron job and it is not very expensive (supposedly -- I haven't used it myself, yet).  That would be incredibly useful.  Undelete doesn't take care of all recovery requirements either -- you may have deleted text in a document that you later want back, for example.  With hammer, just look at the snapshot from 2 minutes before you deleted it. <br>
<p>
I suppose if you have a filesystem where many bulky files are being altered frequently, this is not a great idea, but you can tune the frequency of the snapshot and pruning (or disable snapshotting entirely, if need be...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor309300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2008 8:38 UTC (Wed)
                               by <b>plougher</b> (guest, #21620)
                              [<a href="/Articles/309300/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>Like any self-respecting contemporary filesystem, Tux3 is based on B-trees [...] Blocks are mapped using extents, of course - another obligatory feature for new filesystems</i>
<p>
Of course this should be qualified as any self-respecting read/write filesystem.  B-trees and extents are completely unnecessary for read-only filesystems.
<p>
Tux3 seems to have some nice design decisions which should offer high performance (reduced seeking).  I like the variable sized inodes, (potential) optimised inodes for small files, and the packed attributes.  Though I'm obviously bound to say that Squashfs has had variable sized inodes optimised for different file types/sizes for many years.
<p>
 

      
          <div class="CommentReplyButton">
            <form action="/Articles/309300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor309576"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Correctness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 4:06 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/309576/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <i>having caught exactly zero blocks of bad data passed as good</i>
<p>
Evidently Daniel hasn't worked much with disks that are powered off unexpectedly.  There's a widespread myth (originating where?!) that disks detect a power drop and use the last few milliseconds to do something safe, such as finish up the sector they're writing.  <b>It's not true</b>.  A disk will happily write half a sector and scribble trash.  Most times reading that sector will report a failure, but you only get reasonable odds.  Some hard read failures, even if duly reported, count as real damage, and are not unlikely. 
<p>
Your typical journaled file system doesn't protect against power-off scribbling damage, as fondly as so many people wish and <i>believe</i> with all their little hearts.
<p>
Even without unexpected power drops, it's foolish to depend on more reliable reads than the manufacturer promises, because they trade off marginal correctness (which is hard to measure) against density (which is on the box in big bold letters).  What does the money say to do?

PostgreSQL uses 64-bit block checksums because they care about integrity.  It's possibly reasonable to say that theirs is the right level for such checking, but not to say there's no need for it.
      
          <div class="CommentReplyButton">
            <form action="/Articles/309576/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Correctness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2008 18:22 UTC (Fri)
                               by <b>man_ls</b> (guest, #15091)
                              [<a href="/Articles/309902/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Everything you say can be prevented by a more robust filesystem with data journaling, even without checksums. Ext3 with <a href="http://batleth.sapienti-sat.org/projects/FAQs/ext3-faq.html">data=ordered</a> is an example.
<p>
Even with checksumming data integrity is not guaranteed: yes, the filesystem will detect that a sector is corrupt, but it still needs to locate a good previous version and be able to roll back to that version. Isn't it easier to just do data journaling?
      
          <div class="CommentReplyButton">
            <form action="/Articles/309902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Correctness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2008 22:18 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/309941/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>Everything you say can be prevented by a more robust filesystem ...</i>
<p>
<b>FALSE</b>.  I'm talking about hardware-level sector failures.  A filesystem without checksumming can be made robust against reported bad blocks, but a bad block that the drive delivers as good can completely bollix ext3 or any fs without its own checksums.  Drive manufacturers specify and (just) meet a rate of such bad blocks, low enough for non-critical applications, and low enough not to kill performance of critical applications that perform their own checking and recovery methods.  
<p>
Denial is not a sound engineering practice.
      
          <div class="CommentReplyButton">
            <form action="/Articles/309941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Correctness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2008 0:06 UTC (Sat)
                               by <b>man_ls</b> (guest, #15091)
                              [<a href="/Articles/309956/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Interesting point: it seems I misread your post so let me re-elaborate. Data journaling prevents against half-written sectors, since they will not count as written. This leaves a power-off which causes physical damage to a disk, and yet the disk will not realize the sector is bad. Keep in mind that we have data journaling, so this particular sector will not be used until it is completely overwritten. The kind of damage must be permanent yet remain hidden when writing, which is why I deemed it impossible. It seems you have good cause to believe it can happen, so it would be most enlightening to hear any data points you may have.
<p>
As to your concerns about high data density and error rates, they are exactly what Mr Phillips happily dismisses: in practice they do not seem to cause any trouble.
<p>
Over-engineering is not a sound engineering practice either.
      
          <div class="CommentReplyButton">
            <form action="/Articles/309956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor310109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Correctness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2008 22:28 UTC (Sun)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/310109/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We have, elsewhere in this same thread, reports of bad data delivered as good, and causing trouble, Mr. Phillips's opinion notwithstanding. The incidence is, therefore, not negligible for data many people care about. Partially-written blocks are only one cause of bad sectors, which I noted only because they are an example on one that occurs much for frequently for some users than for others. Bad sectors may occur in the journal as well as in file contents. The drive will detect and report only a large, but not always a large enough, fraction of these.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/310109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor310037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File checksums needed?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2008 18:57 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/310037/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
A disk will happily write half a sector and scribble trash. Most times reading that sector will report a failure, but you only get reasonable odds.
</blockquote>
<p>
Actually, I think the probability of reading such a sector without error indication <em>is</em> negligible.  There are much more likely failure modes for which file checksums are needed.  One is where the disk writes the data to the wrong track.  Another is where it doesn't write anything but reports that it did.  Another is that the power left the client slightly before the disk drive and the client sent garbage to the drive, which then correctly wrote it.
<p>
I've seen a handful of studies that showed these failure modes, and I'm pretty sure none of them showed simple sector CRC failure.
<p>
If sector CRC failure were the problem, adding a file checksum is probably no better than just using stronger sector CRC.

      
          <div class="CommentReplyButton">
            <form action="/Articles/310037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor311544"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File checksums needed?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2008 1:57 UTC (Tue)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/311544/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>There are much more likely failure modes for which file checksums are needed. One is where the disk writes the data to the wrong track. Another is where it doesn't write anything but reports that it did. Another is that the power left the client slightly before the disk drive and the client sent garbage to the drive, which then correctly wrote it.</i>
<br><br>
Scribble on final write is something we plan to detect, by checksumming the commit block.  I seem to recall reading that SGI ran into hardware that would lose power to the memory before the drive controller lost its power-good, and had to do something special in XFS to survive it.  Better would be if hardware was engineered not to do that.
      
          <div class="CommentReplyButton">
            <form action="/Articles/311544/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor312306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Please, stop...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2008 3:31 UTC (Sat)
                               by <b>sandeen</b> (guest, #42852)
                              [<a href="/Articles/312306/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can we just drop the whole "XFS expects and/or works around special hardware" meme?  This has been kicked around for years without a shred of evidence.  I may as well assert that XFS requires death-rays from mars for proper functionality.<br>
<p>
XFS, like any journaling filesystem, expects that when the storage says data is safe on disk, it is safe on disk and the filesystem can proceed with whatever comes next.  That's it; no special capacitors, no power-fail interrupts, no death-rays from mars.  There is no special-ness required (unless you consider barriers to prevent re-ordering to be special, and xfs is not unique in that respect either).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/312306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor312308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Please, stop...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2008 3:55 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/312308/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You must have seriously misread the post to which you responded.  It doesn't mention special features of hardware.  It does mention special flaws in hardware and how XFS works in spite of them.
<p>
I too remember reports that in testing, systems running early versions of XFS didn't work because XFS assumed, like pretty much everyone else, that the hardware would not write garbage to the disk and subsequently read it back with no error indication.  The testing showed that real world hardware does in fact do that and, supposedly, XFS developers improved XFS so it could maintain data integrity in spite of it.

      
          <div class="CommentReplyButton">
            <form action="/Articles/312308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor310882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Correctness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2008 16:50 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/310882/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>A disk will happily write half a sector and scribble
trash. Most times reading that sector will report a failure, but you
only get reasonable odds.</blockquote>

Given that disk drives do their own checksumming, you get pretty good
odds.  And if you think they are not good, why would you think that FS
checksums are any better?

<p>Concerning getting such damage on power-off, most drives don't do
that; we would hear a lot about drive-level read errors after turning
off computers if that was a general characteristic.  However, I have
seen such things a few times, and it typically leads to me avoiding
the brand of the drive for a long time (i.e., no Hitachi drives for
me, even though they were still IBM when it happened, and no Maxtor,
either; hmm, could it be that selling such drives leads to having to
sell the division/company soon after?); they usually did not happen
happen on an ordinary power-off, but in some unusual situations that
might result in funny power characteristics (that's still no excuse to
corrupt the disk).

      
          <div class="CommentReplyButton">
            <form action="/Articles/310882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor311499"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Correctness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2008 21:06 UTC (Mon)
                               by <b>grundler</b> (guest, #23450)
                              [<a href="/Articles/311499/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ncm wrote:<br>
<font class="QuotedText">&gt; There's a widespread myth (originating where?!) that disks</font><br>
<font class="QuotedText">&gt; detect a power drop and use the last few milliseconds to do</font><br>
<font class="QuotedText">&gt; something safe, such as finish up the sector they're writing.</font><br>
<font class="QuotedText">&gt; It's not true. A disk will happily write half a sector and scribble trash.</font><br>
<p>
It was true for SCSI disks in the 90's. The feature was called "Sector Atomicity". As expected, there is a patent for one implementation:<br>
    <a href="http://www.freepatentsonline.com/5359728.html">http://www.freepatentsonline.com/5359728.html</a><br>
<p>
AFAIK, every major server vendor required it. I have no idea if this was ever implemented for IDE/ATA/SATA drives. But UPS's became the norm for avoiding power failure issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/311499/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor309591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 6:11 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/309591/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about online fsck-ing, which I have not seen mentioned here yet?  Surely that ought to be feasible if there is no update in place.  (I'm not actually sure why it is not generally feasible with journalling filesystems, possibly excluding the journal itself, at least if you temporarily disable journal write out).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309599"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 7:26 UTC (Thu)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/309599/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Online checking is planned.  Offline checking is in progress.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309599/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309619"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 11:09 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/309619/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually this patch<br>
<p>
<a href="http://patchwork.ozlabs.org/patch/6047/">http://patchwork.ozlabs.org/patch/6047/</a> (filesystem-freeze-implement-generic-freeze-feature.patch)<br>
<p>
might make general online fs checking doable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309619/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor309600"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 8:05 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/309600/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <cite>Having been checksumming filesystem data during continuous
replication for two years now on multiple machines, and having caught
exactly zero blocks of bad data passed as good in that time, I consider the
spectre of disks passing bad data as good to be largely vendor
FUD.</cite><br>
<p>
I must strongly object here. Over the last years, I have had 3 different
customers, using 2 different RAID-controller vendors with 2 different disk
types (SCSI, SATA), who got destroyed RAID contents because of a broken
disk that did not report (or detect) it's errors.
<p>
The problem is, that even RAID controllers do not "read-after-write" and
thus verify the contents of a disk. So if the disk says "OK" after a write
where in reality it's not, your RAID and filesystem contents still go to be
destroyed (because the drive reads back other data than it wrote).
<p>
Another check could be "on every read also calculate the RAID checksum to
verify", but for performance reasons nobody does that.
<p>
There REALLY should be filesystem-level checksumming, and a generic
interface between filesystem and disk controller, where the filesystem can
tell the RAID controller to switch to
"paranoid mode", doing read-after-write of disk data. It's gonna be slow
then, but at least the controller will find a broken disk and disable it -
after that, it can switch to performance mode again.
<p>
Yes, our customers were quiet unsatisfied that even with RAID controllers
their data got broken. But the worst is, it takes a long time for customers
to see and identify there is a problem - you can only hope for a good
backup strategy! Or for a filesystem doing checksumming.
<p>
mfg zmi
      
          <div class="CommentReplyButton">
            <form action="/Articles/309600/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 12:47 UTC (Thu)
                               by <b>etienne_lorrain@yahoo.fr</b> (guest, #38022)
                              [<a href="/Articles/309632/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 For RAIDs, there should be few selectable options:<br>
- read (all mirrors) after writes, report error if content differ (slow)<br>
- write (all mirrors) and return if all writes successfull, post a read of the same data and report delayed error if content differ.<br>
- write (one mirror) and return as soon as possible, post writes to other mirrors, then post a read of the same data (all mirrors) and report delayed error if content differ.<br>
 Obviously, for previous test, you should run the disks with their cache disabled.<br>
<p>
 Those can run with cache enabled:<br>
- read all mirrors and compare content, report error to the read operation if content differ (slow)<br>
- read and return first available data, but keep data and compare when other mirrors deliver data; report delayed error if mirrors have different data.<br>
<p>
 That is better handled in the controller hardware itself, I do not know if some hardware RAID controller do it correctly.<br>
 I am not sure there is a defined clean way to report "delayed errors" in either SCSI or SATA, there isn't any in ATA interface (so booting from those RAID drives using the BIOS may be difficult).<br>
 Moreover the "check data" (i.e. read and compare) in SCSI is sometimes simply ignored by devices, so that may have to be implemented by reads in the controller itself.<br>
 I am not sure a lot of users would accept the delay penalties due to the amount of data transferred in between controller and RAID disks...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor309765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 21:38 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/309765/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
+1<br>
<p>
I've only lived with maybe a few dozen disks in my life, but I've still corruption like that too -- in this case, it turned out that the disk was fine, but one of the connections on the RAID card was bad, and was silently flipping single bits on reads that went to that disk (so it was nondeterministic, depending on which mirror got hit on any given cache fill, and quietly persisted even after the usual fix of replacing the disk).<br>
<p>
Luckily the box happened to be hosting a modern DVCS server (the first, in fact), which was doing its own strong validation on everything it read from the disk, and started complaining very loudly.  No saying how much stuff on this (busy, multi-user, shared) machine would have gotten corrupted before someone noticed otherwise, though... and backups are no help, either.<br>
<p>
I totally understand not being able to implement everything at once, but if there comes a day when there are two great filesystems and one is a little slower but has checksumming, I'm choosing the checksumming one.  Saving milliseconds (of computer time) is not worth losing years (of work).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2008 22:52 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/309945/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Checksumming only the file system's metadata and log, but not the user-level data, is a reasonable compromise.  Then applications that matter (e.g. PostgreSQL, or your DVCS) can provide their own data checksums (and not pay twice) and operate on a reliable file system.<br>
<p>
This suggests a reminder for applications providing their own checksums: mix in not just the data, but your own metadata (block number, file id).  Getting the right checksum on the wrong block is just embarrassing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2008 23:58 UTC (Fri)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/309954/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Checksumming only the file system's metadata and log, but not the user-level data, is a reasonable compromise</font><br>
<p>
Well, maybe...<br>
<p>
Within reason, my goal is to have a much confidence as possible in my data's safety, with as little investment of my time and attention.  Leaving safety up to individual apps is a pretty wretched system for achieving this -- it defaults to "unsafe", then I have to manually figure out which stuff needs more guarantees, which I'll screw up, plus I have to worry about all the bugs that may exist in the eleventeen different checksumming systems being used in different codebases... This is the same reason I do whole disk backups instead of trying to pick and choose which files to save, or leaving backup functionality up to each individual app.  (Not as crazy as an idea as it sounds -- that DVCS basically has its own backup system, for instance; but I'm not going around adding that functionality to my photo editor and word processor too.)<br>
<p>
Obviously if checksumming ends up causing unacceptable slowdowns, then compromises have to be made. But I'm pretty skeptical; it's not like CRC (or even SHA-1) is expensive compared to disk access latency, and the Btrfs and ZFS folks seem to think usable full disk checksumming is possible.<br>
<p>
If it's possible I want it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2008 8:26 UTC (Sat)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/309995/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is another case where the end-to-end argument applies.  Either (a) it's a non-critical application, and backups (which you have to do anyway) provide enough reliability; or (b) it's a critical application, and the file system can't provide enough assurance anyway, and what it could do would interfere with overall performance.<br>
<p>
Similarly, if your application is seek-bound, it's in trouble anyway.  If performance matters, it should be limited by the sustained streaming capacity of the file system, and then delays from redundant checksum operations really do hurt.<br>
<p>
Hence the argument for reliable metadata, anyway: the application can't do that for itself, and it had better not depend on metadata operations being especially fast.  Traditionally, serious databases used raw block devices to avoid depending on file system metadata.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2008 8:55 UTC (Sat)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/309999/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
End-to-end is great, and it absolutely makes sense that special purpose systems like databases may want both additional guarantees and low-overhead access to the drive. But basically none of my important data is in a database; it's scattered all over my hard drive in ordinary files, in a dozen or more formats. If the filesystem *is* your database, as it is for ordinary desktop storage, then that's the only place you can reasonably put your integrity checking.<br>
<p>
Backups are also great, but there are cases (slow quiet unreported corruption that can easily persist undetected for weeks+, see upthread) where they do not protect you.<br>
<p>
(In some cases you can actually increase integrity too -- if your app checks its checksum when loading a file and it fails, then the data is lost but at least you know it; if btrfs checks a checksum while loading a block and it fails, then it can go pull an uncorrupted copy from the RAID mirror and prevent the data from being lost at all.)<br>
<p>
<font class="QuotedText">&gt;If performance matters, it should be limited by the sustained streaming capacity of the file system, and then delays from redundant checksum operations really do hurt.</font><br>
<p>
Again, I'm not convinced. My year-old laptop does SHA-1 at 200 MB/s (using one core only); the fastest hard-drive in the world (according to storagereview.com) streams at 135 MB/s.  Not that you want to devote a CPU to this sort of thing, and RAID arrays can stream faster than a single disk, but CRC32 goes *way* faster than SHA-1 too, and my laptop has neither RAID nor a fancy 15k RPM server drive anyway.<br>
<p>
And anyway my desktop is often seek-bound, alas, and yours is too; it does make things slow, but I don't see why it should make me care less about my data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor310101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2008 21:33 UTC (Sun)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/310101/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For most uses we would benefit from the file system doing as much as it can, and even backing itself up -- although we'd like to be able to bypass whatever gets in the way.  But if the file system does less, at first, the first thing to checksum is the metadata.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/310101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor311440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2008 1:42 UTC (Tue)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/311440/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <i>I've only lived with maybe a few dozen disks in my life, but I've still corruption like that too -- in this case, it turned out that the disk was fine, but one of the connections on the RAID card was bad, and was silently flipping single bits on reads that went to that disk (so it was nondeterministic, depending on which mirror got hit on any given cache fill, and quietly persisted even after the usual fix of replacing the disk).
<br><br>
Luckily the box happened to be hosting a modern DVCS server (the first, in fact), which was doing its own strong validation on everything it read from the disk, and started complaining very loudly. No saying how much stuff on this (busy, multi-user, shared) machine would have gotten corrupted before someone noticed otherwise, though... and backups are no help, either.</i>
<br><br>
Our ddnap-style checksumming at replication time would have caught that corruption promptly.
<br><br>
<i>if there comes a day when there are two great filesystems and one is a little slower but has checksumming, I'm choosing the checksumming one. Saving milliseconds (of computer time) is not worth losing years (of work).</i>
<br><br>
It is not milliseconds, it is a significant fraction of your CPU, no matter how powerful.  But yes, if you want extra checking is important to you, should be able to have it.  Whether block checksums belong in the filesystem rather than volume manager is another question.  There may be a powerful efficiency argument that checksumming has to be done by the filesystem, not the volume manager.  If so, I would like to see it.
<br><br>
Anyway, when the time comes that block checksumming rises to the top of the list of things to do, we will make sure Tux3 has something respectable, one way or another.  Note that checksumming at replication time already gets nearly all the benefit at a very modest CPU cost.
<br><br>
If you want to rank the relative importance of features, replication way beats checksumming.  It takes you instantly from having no backup or really awful backup, to having great backup with error detection.  So getting to that state with minimal distractions seems like an awfully good idea.
      
          <div class="CommentReplyButton">
            <form action="/Articles/311440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor312386"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2008 12:26 UTC (Sun)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/312386/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Our ddnap-style checksumming at replication time would have caught that corruption promptly.</font><br>
<p>
What is that, and how does it work?  I'm curious...<br>
<p>
In general, I don't see how replication can help in the situation I encountered -- basically, some data on the disk magically changed without OS intervention.  The only way to distinguish between that and a real data change is if you are somehow hooked into the OS and watching the writes it issues.  Maybe ddsnap does that?<br>
<p>
<font class="QuotedText">&gt;It is not milliseconds, it is a significant fraction of your CPU, no matter how powerful.</font><br>
<p>
Can you elaborate?  On my year-old laptop, crc32 over 4k-blocks does &gt;625 MiB/s on one core (adler32 is faster still), and the disk with perfect streaming manages to write at ~60 MiB/s, so by my calculation the worst case is 5% CPU.  Enough that it could matter occasionally, but in fact seek-free workloads are very rare... and CPUs continue to follow Moore's law (checksumming is parallelizable), so it seems to me that that number will be &lt;1% by the time tux3 is in production :-).<br>
<p>
No opinion on volume manager vs. filesystem (so long as the interface doesn't devolve into distinct camps of developers pushing responsibilities off on each other); I could imagine there being locality benefits if your merkle tree follows the filesystem topology, but eh.<br>
<p>
<font class="QuotedText">&gt;If you want to rank the relative importance of features, replication way beats checksumming.</font><br>
<p>
Fair enough, but I'll just observe that since I do have a perfectly adequate backup system in place already, replication doesn't get *me* anything extra, while checksumming does :-).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/312386/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor310038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File checksums needed?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2008 19:07 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/310038/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Having been checksumming filesystem data during continuous replication for two years now on multiple machines, and having caught exactly zero blocks of bad data passed as good in that time,
</blockquote>
<p>
If TUX3 is for small systems, Philipps is probably right.  I don't know what "continuous replication" means or how much data he's talking about here, but I have a feeling that studies I've seen calling for file checksumming did maybe 10,000 times as much I/O as this.

      
          <div class="CommentReplyButton">
            <form action="/Articles/310038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor309620"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 11:32 UTC (Thu)
                               by <b>biolo</b> (guest, #1731)
                              [<a href="/Articles/309620/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does anyone know if there has been any talk about implementing HSM (Hierarchical Storage Management) in Linux? I'm aware there are one or two (very expensive) proprietary solutions out there, but it strikes me that now is a good time to at least consider how you would implement it and what you need from the various layers to handle it. Since we have two potential new generic file systems in the works, whose on-disk layout hasn't been fixed yet I can't think of a better time. <br>
<p>
Obviously HSM is one of those things that crosses the traditional layering, but BTRFS at least is already handling multi layer issues.<br>
<p>
Implementing a linux native HSM strikes me as one of those game changers, we'd have a huge feature none of the other OS's can currently match without large expenditure. I've lost count of the number of situations where organizations have bought hugely expensive SCSI or FC storage systems with loads of capacity, where what they actually needed was just a few high performance disks (or even SSDs nowadays) backed by a slower but high capacity set of SATA disks. Even small servers or desktops probably have a use for this, that new disk you just bought to expand capacity is probably faster that the old one.<br>
<p>
Using tape libraries at the second or third level of the HSM has a few more complications, but could be tackled later.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309620/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 17:42 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/309707/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there is interest, but currently the only way to do this is via FUSE<br>
<p>
the hooks that are being proposed for file scanning are also being looked at as possibly being used for HSM type uses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor309625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 11:55 UTC (Thu)
                               by <b>meuh</b> (guest, #22042)
                              [<a href="/Articles/309625/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>The code needs some cleanups - little problems like the almost complete lack of comments and the use of macros as formal function parameters are likely to raise red flags on wider review</blockquote>

And here is
<a href="http://hg.tux3.org/tux3?cs=05354dc10bec">changeset 580</a>: "The "Jon Corbet" patch. Get rid of SB and BTREE macros, spell it like it is."

      
          <div class="CommentReplyButton">
            <form action="/Articles/309625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2008 19:39 UTC (Fri)
                               by <b>liljencrantz</b> (guest, #28458)
                              [<a href="/Articles/309910/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cool. Doesn't fix the lack of comments, though. *hint* :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor309658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 16:13 UTC (Thu)
                               by <b>joern</b> (guest, #22392)
                              [<a href="/Articles/309658/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Tux3 handles this by writing the new blocks directly to their final location, then putting a "promise" to update the metadata block into the log. At roll-up time, that promise will be fulfilled through the allocation of a new block and, if necessary, the logging of a promise to change the next-higher block in the tree. In this way, changes to files propagate up through the filesystem one step at a time, without the need to make a recursive, all-at-once change.</font><br>
<p>
Excellent, you had the same idea.  How do you deal with inode-&gt;i_size and inode-&gt;i_blocks changing on behalf of the "promise"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor309755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2008 21:05 UTC (Thu)
                               by <b>joern</b> (guest, #22392)
                              [<a href="/Articles/309755/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, and there is another more subtle problem.  When mounting the filesystem with very little DRAM available, it may not be possible to cache all "promised" metadata blocks.  So one must start writing them back at mount time.  However, before they have all been loaded, one might have an incorrect (slightly dated) picture of the filesystem.  The easiest example I can come up with involves three blocks, A, B and C, where A points to B and B points to C:<br>
A -&gt; B -&gt; C<br>
<p>
Now both B and C are rewritten, without updating their respective parent blocks (A and B):<br>
A -&gt; B -&gt; C<br>
     B'   C'<br>
<p>
B' and C' appear disconnected without reading up on all the promises.  At this point, when mounting under memory pressure, order becomes important.  If A is written out first, to release the "promise" on B', everything works fine.  But when B is written out first, to release the "promise on C', we get something like this:<br>
A -&gt; B -&gt; C<br>
     B'   C'<br>
     B"---^<br>
<p>
And now there are two conflicting "promises" on B' and B".  A rather ugly situation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/309755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor310775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2008 8:01 UTC (Thu)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/310775/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Hi Joern,
<br><br>
<i>there is another more subtle problem. When mounting the filesystem with very little DRAM available, it may not be possible to cache all "promised" metadata blocks. So one must start writing them back at mount time.</i>
<br><br>
You mean, first run with lots of ram, get tons of metadata blocks pinned, then remount with too little ram to hold all the pinned metadata blocks.  A rare situation, you would have to work at that.  All of ram is available for pinned metadata on remount, and Tux3 is pretty stingy about metadata size.
<br><br>
In your example, when B is rewritten (a btree split or merge) the promise made by C' to update B is released because B' is on disk.  So the situation is not as complex as you feared.
<br><br>
I expect we can just ignore the problem of running out of dirtyable cache on replay and nobody will ever hit it.  But for completeness, note that writing out the dirty metadata is not the only option.  By definition, one can reconstruct each dirty metadata block from the log.  So choose a dirty metadata block with no dirty children, reconstruct it and write it out, complete with promises (a mini-rollup).  Keep doing that until all the dirty metadata fits in cache, then go live.  This may not be fast, but it clearly terminates.  Unwinding these promises is surely much easier than unwinding credit default swaps :-)
<br><br>
Regards,
<br><br>
Daniel
      
          <div class="CommentReplyButton">
            <form action="/Articles/310775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor312332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2008 13:08 UTC (Sat)
                               by <b>joern</b> (guest, #22392)
                              [<a href="/Articles/312332/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; I expect we can just ignore the problem</font><br>
<p>
In that case I am a step ahead of you. :)<br>
<p>
The situation may be easier to reach than you expect.  Removable media can move from a beefy machine to some embedded device with 8M of RAM.  Might not be likely for tux3, but is reasonably likely for logfs.<br>
<p>
And order is important.  If B is rewritten _after_ C, the promise made by C' is released.  If it is rewritten _before_ C, both promises exist in parallel.<br>
<p>
What I did to handle this problem may not apply directly to tux3, as the filesystem designs don't match 100%.  Logfs has the old-fashioned indirect blocks and stores a "promise" by marking a pointer in the indirect block as such.  Each commit walks a list of promise-containing indirect blocks and writes all promises to the journal.<br>
<p>
On mount the promises are added to an in-memory btree.  Each promise occupies about 32 bytes - while it would occupy a full page if stored in the indirect block and no other promises share this block.  That allows the read-only case to work correctly and consume fairly little memory.<br>
<p>
When going to read-write mode, the promises can be moved into the indirect blocks again.  If those consume too much memory, they are written back.  However, for some period promises may exist both in the btree and in indirect blocks.  Care must be taken that those two never disagree.<br>
<p>
Requires a bit more RAM than your outlined algorithm, but still bounded to a reasonable amount - nearly identical to the size occupied in the journal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/312332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor310771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Tux3: the other next-generation filesystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2008 6:42 UTC (Thu)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/310771/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>How do you deal with inode->i_size and inode->i_blocks changing on behalf of the "promise"?</i>
<br><br>
These are updated with the inode table block and not affected by promises.  Note that we can sometimes infer the i_size and i_blocks changes from the logical positions of the written data blocks and could defer inode table block udpates until rollup time.  And in the cases where we can't infer it, write the i_size into the log commit block.  More optimization fun.
      
          <div class="CommentReplyButton">
            <form action="/Articles/310771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2008, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
