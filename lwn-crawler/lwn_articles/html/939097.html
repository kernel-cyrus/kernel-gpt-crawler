        <!DOCTYPE html>
        <html lang="en">
        <head><title>Unmaintained filesystems as a threat vector [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/939097/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/939365/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/939097/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Unmaintained filesystems as a threat vector</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 28, 2023</br>
           </div>
One of the longstanding strengths of Linux, and a key to its early success,
is its ability to interoperate with other systems.  That interoperability
includes filesystems; Linux supports a wide range of filesystem types,
allowing it to mount filesystems created by many other operating systems.
Some of those filesystem implementations, though, are better maintained
than others; developers at both the kernel and distribution levels are
currently considering, again, how to minimize the security risks presented
by the others.
<p>
<h4>HFS (and HFS+) in the kernel</h4>
<p>
Back in January, the syzbot fuzzing system <a
href="/ml/linux-kernel/000000000000dbce4e05f170f289@google.com/">reported</a>
a crash with the HFS filesystem.  For those who are not familiar with HFS,
it is the native filesystem used, once upon a time, by Apple Macintosh
computers.  Its <a
href="https://elixir.bootlin.com/linux/v6.4.5/source/fs/hfs/Kconfig">kernel
configuration help text</a> promises that users "<q>will be able to mount
Macintosh-formatted floppy disks and hard drive partitions with full
read-write access</q>".  It seems that, in 2023, there is little demand for
this capability, so the number of users of this filesystem is relatively
low.
<p>
The amount of maintenance it receives is also low; it was <a
href="https://git.kernel.org/linus/6cf515e113fc">marked as orphaned</a> in
2011, at which point it had already seen some years of neglect.  So it is
not all that surprising that the syzbot-reported problem was not fixed or,
even, given much attention.  At the end of the brief discussion in January,
Viacheslav Dubeyko, who occasionally looks in on HFS (and the somewhat more
modern HFS+ filesystem as well), <a
href="/ml/linux-kernel/50D6A66B-D994-48F4-9EBA-360E57A37BBE@dubeyko.com/">said</a>
that there was nothing to be done in the case where a filesystem has been
deliberately corrupted.
<p>
On July 20, Dmitry Vyukov (who runs syzbot) <a
href="/ml/linux-kernel/CACT4Y+aJb4u+KPAF7629YDb2tB2geZrQm5sFR3M+r2P1rgicwQ@mail.gmail.com/">restarted
the discussion</a> by pointing out that the consequences of a bug in HFS
can extend beyond the small community of users of that filesystem: "<q>Most
popular distros will happily auto-mount HFS/HFS+ from anything inserted
into USB (e.g. what one may think is a charger). This creates interesting
security consequences for most Linux users</q>".

There is an important point in that message that is worth repeating: users
may not be aware that the device they are plugging into their computer
contains a filesystem at all.  One often sees warnings about plugging
random USB sticks into a computer, but any device — or even a charging
cable — can present a block device with a filesystem on it.  If the
computer mounts that filesystem automatically, "<q>interesting security
consequences</q>" may indeed follow.
<p>
The new round of discussion still has not resulted in the problem being
fixed.  Instead, some developers called for the removal of the HFS and HFS+
filesystems entirely.  Matthew Wilcox <a
href="/ml/linux-kernel/ZLlvII%2FjMPTT32ef@casper.infradead.org/">said</a>:
"<q>They're orphaned in MAINTAINERS and if distros are going to do such a
damnfool thing, then we must stop them</q>".  Dave Chinner <a
href="/ml/linux-kernel/ZLmzSEV6Wk+oRVoL@dread.disaster.area/">argued</a>
that the kernel community needs to be more aggressive about removing
unmaintained filesystems in general:
<p>
<blockquote class="bq">
	We need to much more proactive about dropping support for
	unmaintained filesystems that nobody is ever fixing despite the
	constant stream of corruption- and deadlock- related bugs reported
	against them.
</blockquote>
<p>
Linus Torvalds, though, <a
href="/ml/linux-kernel/CAHk-=wg7DSNsHY6tWc=WLeqDBYtXges_12fFk1c+-No+fZ0xYQ@mail.gmail.com/">was
unimpressed</a>, saying that, instead, distributors should just fix the
behavior of their systems.  The lack of a maintainer, he added, is not a
reason to remove a filesystem that people are using; "<q>we have not
suddenly started saying 'users don't matter'</q>".  That brought the
discussion to an end, once again, with no fix for the reported bug in
sight.
<p>
<h4>Distribution changes</h4>
<p>
As the conversation was reaching an end on the linux-kernel list, it <a
href="/ml/debian-devel/ZLl1PLU938klkucC@bongo.bofh.it/">picked up</a> on
debian-devel.  There, Marco d'Itri asked the kernel developers to simply
blacklist HFS and HFS+ from being used for automounting filesystems.
Matthew Garrett, though, <a
href="/ml/debian-devel/20230721082012.GA19433@srcf.ucam.org/">pointed
out</a> that the kernel, which cannot completely block automounting without
disabling the filesystem type entirely, was probably the wrong place to
solve the problem.  Instead, he <a
href="/ml/debian-devel/20230721173536.GA26591@srcf.ucam.org/">suggested</a>,
a udev rule could be used to prevent those filesystems from being
automounted, while keeping the capability available for users who manually
mount HFS or HFS+ filesystems.
<p>
Shortly thereafter, Garrett <a
href="/ml/fedora-devel/ZLtwvqu%2FCBaN1iiX@srcf.ucam.org/">raised the
issue</a> on the Fedora development list as well, suggesting the addition
of a udev rule once again.  There, some participants saw that rule as
perhaps improving the situation, but others, including <a
href="/ml/fedora-devel/ZLu+Cm13gm%2F9whyZ@kawka3.in.waw.pl/">Zbigniew
Jędrzejewski-Szmek</a> and <a
href="/ml/fedora-devel/RZ77YR.54R774W5MQTA@redhat.com/">Michael
Catanzaro</a>, pointed out that, if a user wants to see the files contained
within a a filesystem image, they will do what is needed to mount it, even
if that mounting does not happen automatically.  Solomon Peachy <a
href="/ml/fedora-devel/ZL1Q3eTS2c9A+Ee2@shaftnet.org/">suggested</a> that
adopting this policy would only result in an addition to the various
"things to fix after installing Fedora" lists telling users how to turn
automounting back on.
<p>
Nobody mentioned the possibility that the user was not expecting a given
device to have a filesystem at all.  Forcing such a filesystem to
be mounted manually would presumably address that problem since,
presumably, most users would not go to the trouble of mounting a filesystem
that they did not expect to be there in the first place.  But, as Demi
Marie Obenour <a
href="/ml/fedora-devel/fb671fde-b24a-0ba4-f507-5dd5ce00b137@gmail.com/">pointed
out</a>, a malicious filesystem image could be employed willingly by a user
to take control of a locked-down system:
<p>
<blockquote class="bq">
	Unfortunately, this original threat model is out of date.
	kernel_lockdown(7) explicitly aims to prevent root from
	compromising the kernel, which means that malformed filesystem
	images are now in scope, for all filesystems.  If a filesystem
	driver is not secure against malicious filesystem images, then
	using it should fail if the kernel is locked down, just like
	loading an unsigned kernel module does.
</blockquote>
<p>
In that case, it seems, disabling automounting would not be a sufficient
fix; the vulnerable filesystem type would need to be disabled entirely.
<p>
There is an aspect of the problem that has not received as much attention
as it might warrant, though Eric Sandeen did <a
href="/ml/fedora-devel/e16e3a56-cd51-3bd5-05a9-10a1f0b74652@redhat.com/">touch
on it</a>: the number of filesystem implementations in Linux that are
robust in the face of a <i>maliciously</i> corrupted image is quite close
to zero.  Many filesystems can deal with corruption resulting from media
errors and the like; checksums attached to data and metadata will catch
such problems.  Malicious corruption, instead, will have correct checksums,
entirely bypassing that line of defense.  Filesystem developers who have
thought about this problem are mostly unanimous in saying that it cannot
readily be solved — the space for possible attacks is simply too large.
<p>
So, while unmaintained filesystems like HFS may provide a sort of
low-hanging fruit for attackers, they are not the sole cause of the
problem.  Intensively maintained filesystems, including ext4, Btrfs, and
XFS, are also susceptible to malicious filesystem images.  So even removing
support entirely for the older, unmaintained filesystem types would not
solve the problem.
<p>
In the Debian discussion, Garrett suggested
that risky filesystems could be mounted as FUSE filesystems in user space,
thus making it much easier to contain any ill effects — "<q>but even though
this has been talked about a bunch I haven't seen anyone try to implement
it</q>".  On the Fedora side, Richard W. M. Jones <a
href="/ml/fedora-devel/20230722105247.GC7781@redhat.com/">suggested</a>
that <a href="https://libguestfs.org/">libguestfs</a>, which mounts
filesystems within a virtual machine, could be used.  Once again, that
would contain the results of any sort of exploitation attempt.
<p>
If the objective is truly to make it safe for users to mount untrusted
filesystems, some sort of isolation will almost certainly prove to be
necessary.  Making most filesystem implementations robust against malicious
filesystem images just does not seem to be an attainable goal in the near
future — even if resources were being put toward that goal, which is not
happening to any great extent.  It is not a simple solution, and the result
will have a performance cost, but security often imposes such costs.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Security">Filesystems/Security</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security">Security</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/939097/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor939525"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 16:44 UTC (Fri)
                               by <b>KJ7RRV</b> (guest, #153595)
                              [<a href="/Articles/939525/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Forcing such a filesystem to be mounted manually would presumably address that problem since, presumably, most users would not go to the trouble of mounting a filesystem that they did not expect to be there in the first place.</span><br>
<p>
[citation needed]<br>
<p>
I would expect that most users would see an unexpected filesystem and think, "Hmm, what's this?" and mount it. More security-conscious users wouldn't, but I think most users who would plug in an untrusted device in the first place would probably mount an unexpected filesystem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939525/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 17:06 UTC (Fri)
                               by <b>hkario</b> (subscriber, #94864)
                              [<a href="/Articles/939532/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
yup, "USB drive left in a parking lot" is totally an attack vector<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor939545"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 18:24 UTC (Fri)
                               by <b>Nahor</b> (subscriber, #51583)
                              [<a href="/Articles/939545/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But as the article mentions, one wouldn't expect a filesystem to show when plugging a USB cable. So one might think the filesystem is on some other disk. This is especially true given that some computers have hidden partitions (e.g. recovery partitions). Then, out of curiosity, the user may try to mount it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939545/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 23:52 UTC (Fri)
                               by <b>rgmoore</b> (<b>&#x272D; supporter &#x272D;</b>, #75)
                              [<a href="/Articles/939573/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>There are reasons for wanting an ordinary USB device to also have a small block device, too.  If it's an unusual device, the block device could contain drivers or other software needed to make it work.  It's a totally legitimate thing to do; it even protects the buyer against the company no longer providing the software on their web site.  Not to mention that USB is designed to allow users to daisy chain devices, so it would be totally normal for plugging in a single cable to add multiple devices to the system simultaneously.



      
          <div class="CommentReplyButton">
            <form action="/Articles/939573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2023 1:06 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/939575/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If it's an unusual device, the block device could contain drivers or other software needed to make it work. It's a totally legitimate thing to do; it even protects the buyer against the company no longer providing the software on their web site. </span><br>
<p>
FWIW, I own two such devices, one is a cellular modem and the other is a label printer.<br>
<p>
There are also various microcontroller development boards that present as a mass-storage device when plugged in -- This filesystem is completely fake/virtual, and exists to allow the device firmware to be updated without requiring any additional tools (or permissions)<br>
<p>
<span class="QuotedText">&gt; Not to mention that USB is designed to allow users to daisy chain devices, so it would be totally normal for plugging in a single cable to add multiple devices to the system simultaneously. </span><br>
<p>
Modern laptop docks are nearly exclusively set up this way.   But even putting those aside, I also own multiple Hub+card reader widgets that I use nearly daily, so plugging stuff in that presents a mass storage device is something completely routine.<br>
<p>
Remember, "Of course I want to access that device; it's why I plugged it in!" is the overwhelmingly common use case here, and we have to remember to not throw up usability impediments or we'll just have users disable/bypass these mechanisms.  By all means, let's harden things as much as possible, including sandboxing (eg via libguestfs), but that has to all be automatic and completely transparent for it to be viable.  Security is meaningless if it results in an unusable system.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939827"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 19:12 UTC (Mon)
                               by <b>rgmoore</b> (<b>&#x272D; supporter &#x272D;</b>, #75)
                              [<a href="/Articles/939827/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I have to think FUSE is the right way to deal with this kind of thing, at least as a default.  Most removable media is relatively low performance, so the added overhead of the user space driver is a reasonable price to pay for better security.  The rare case of high-performance removable media should be treated as the exception rather than the standard.  The big problem is just that there aren't FUSE drivers for every filesystem, and the more obscure and less well maintained the kernel driver, the less likely it is there will be a FUSE implementation.  What we need to make it work is a way of letting FUSE use kernel drivers.



      
          <div class="CommentReplyButton">
            <form action="/Articles/939827/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor939844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 20:15 UTC (Mon)
                               by <b>estansvik</b> (subscriber, #127963)
                              [<a href="/Articles/939844/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agree. Knowing myself, if I found a file system on what looks like a cable, I'd probably mount it in a heartbeat and start poking around out of curiosity. I'm probably security nightmare. I guess I should check MAINTAINERS first to see if it's a well maintained implementation before mounting my next cable :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor939539"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 18:12 UTC (Fri)
                               by <b>shironeko</b> (subscriber, #159952)
                              [<a href="/Articles/939539/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
is there any articles/threads that talks about why writing a "secure" filesystem is seen as such a hard task? If/how does other OS guard against kernel takeover via usb charging cables?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939539/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 20:10 UTC (Fri)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/939556/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So the issue is that 'secure' means different things in different contexts. Most filesystems have high security guarentees as long as the medium they are stored on is under physical control of the 'user' at all times. The issue is that when the drive is 'mobile' that things get tricky because you have to have trust of so many things to actually reach any level of security.<br>
1. The hardware path may be lieing. [A USB cable may have a cpu which injects commands into the pathway of the drive and computer.]<br>
2. The initial probing of the drive requires some level of trust of the device that says it actually is what it is. <br>
3. Checksums can be and are tampered with (supposedly syzkiller does this a lot). <br>
4. Encrypting things might help, but not against 'Joe told me to plug his USB key in to get the files.' You might trust Joe, you might not trust his 16 year old son who goes by L33t0ne online these days... who totally didn't play with Joe's computer equipment last night. <br>
5. Filesystems are hard enough with all the ways they can get corrupted and you have to somehow accept and 'deal' with. You can make things 'secure' by just saying 'nope your file is broken and I can't really trust the rest of the disk anymore so broken, buy another'. Users hate that and so you start saying 'ok I can try and get around this problem and maybe correct things...' which is great for users and great for exploits. <br>
<p>
The list goes on. Basically look at either any filesystem thread when someone comes up with a new filesystem to see all the 'crap' that normal filesystems have to deal with just to 'function'  which eventually take a simple system into a very complex one with various features being thrown out because the complexity was just too high for 'normal' drives which are meant to be in a 'trusted' environment. Now try to add in all the corruptions they have to deal with removable media but try to come up with a way to make the system 'ensure' that the drive is both ok and not lethal.<br>
<p>
I don't know any current papers on this.. so maybe someone has come up with a better way to deal with this<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor939641"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2023 6:01 UTC (Sun)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/939641/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If we ignore that they're customarily attached to block device partitions, a filesystem is fundamentally a data structure much bigger than system RAM, full of indices, pointer forests, array bounds and checksums that may as well all be attacker-controlled. It's the worst case scenario and that's assuming the hardware itself can be trusted to operate to spec.<br>
<p>
C experts still struggle to parse ASN.1 securely and that's a static target, half a century old and a few kilobytes in size. So far the best answer for _that_ is "invent an entirely new language where C mistakes cannot be expressed", and that's like trying to switch a national grid to 70Hz.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939641/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939649"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2023 7:57 UTC (Sun)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/939649/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;and that's like trying to switch a national grid to 70Hz.</span><br>
<p>
That's not true. There are cheap and easy to handle "transformers" available. Called FFI.<br>
FFI makes it possible to rewrite the critical part of the application only. No need to change the world in one step. Not even need to change the world at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939649/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor940550"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2023 14:35 UTC (Sat)
                               by <b>smammy</b> (subscriber, #120874)
                              [<a href="/Articles/940550/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Technically" transformer is the wrong metaphor here. Changing AC frequency requires conversion to DC and then back to AC. It's a huge hassle and not without power loss. ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940550/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor940553"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2023 16:59 UTC (Sat)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/940553/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I know. That's why I wrote "transformers" in quotes. ;)<br>
The word can be understood by people who don't know anything about electric stuff.<br>
It's commonly been known as that brick you put in between things so that the two things can work with each other. That's very similar to what FFI does. Which makes it a good metaphor, IMO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940553/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor939674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2023 19:04 UTC (Sun)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/939674/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you saying that all of the block-device-based filesystems in Linux need to be rewritten in Rust?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 3:58 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/939700/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If that is anyone's solution, they'll need to explain how we train a few dozen filesystem developers in Rust while we also expect them to continue maintaining their filesystem.<br>
<p>
I'm not opposed to Rust, but the idea that we'll mandate rewriting everything I'm Rust is madness. It'll need to be piece-by-piece, with the push coming from the maintainers themselves, not by pushing the already overworked people who understand filesystems to also learn Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 12:13 UTC (Mon)
                               by <b>liw</b> (subscriber, #6379)
                              [<a href="/Articles/939721/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think it makes sense to rewrite all file systems in Rust. Apart from rewrites being risky, in general, as you point out, file system developers would need to learn Rust first.<br>
<p>
However, if there's appetite for a rewrite, that would be a good time to consider reviewing and documenting detailed requirements, how testing is done, and generally how to improve things. Adding comprehensive test suites would make sense before a rewrite is started, in any case.<br>
<p>
(Blatant advertising: I give a basics of Rust training course, for a fee. I'm available, if there's interest. But I do userland, not kernel, Rust.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 13:01 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/939724/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The approach to testing is interesting. I'm unsure of the value of unit tests for filesystems. Today's fs testing is based around running xfstests which is a collection of stress tests and very specific corner case tests. It's been built up over decades, but it's all driven from userspace on an active kernel. ie we test using qemu to boot a test kernel.<br>
<p>
I don't need to be sold on the value of unit tests; I have many for the XArray. Where possible they can be run both in-kernel and in userspace. They're very important to me. I just don't know how useful they'd be to a filesystem. xfstests seems to cover all the ground that unit tests would, and while we could move that work into unit tests, it seems a lot like wasted time.<br>
<p>
Darrick &amp; Kent have been playing with gcov recently and they're hitting some reasonably high percentages -- 82.3% of lines for fs/xfs for example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor940526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2023 6:19 UTC (Sat)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/940526/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If that is anyone's solution, they'll need to explain how we train a few dozen filesystem developers in Rust while we also expect them to continue maintaining their filesystem.</span><br>
<p>
Easy: in a scenario where rewriting everything in Rust is feasible, training a few dozen fs developers in Rust seems like the easiest part.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor939927"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2023 14:32 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/939927/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Better than Rust would be to write the critical parts of filesystems in a constrained language similar to <a href="https://github.com/google/wuffs">Wuffs</a>. Done right, this ensures that any corruption of the filesystem data structures (malicious or otherwise) simply leads to the kernel misinterpreting the filesystem contents, but does not allow you to exploit bugs in the kernel (you might have permissions wrong on a file, or a file containing the metadata of another file, including ownership etc).
<p>But that requires someone to invent the domain-specific language and maintain it, even if it "just" compiles down to C and Rust datastructures for in-kernel use.


      
          <div class="CommentReplyButton">
            <form action="/Articles/939927/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2023 14:57 UTC (Tue)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/939944/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don’t know if one could write an entire filesystem in Wuffs, but one could certainly write the parsing and serialization code in Wuffs.  Wuffs would definitely be a better choice than either C or Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor939948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2023 14:59 UTC (Tue)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/939948/">Link</a>] 
      </p>
      
      </div>
      </summary>
      To avoid confusion, this comment was a <i>question</i>, not a statement.


      
          <div class="CommentReplyButton">
            <form action="/Articles/939948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor940988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2023 22:02 UTC (Wed)
                               by <b>ebiederm</b> (subscriber, #35028)
                              [<a href="/Articles/940988/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust does not protect many of the possible attacks.<br>
<p>
A big danger is kernel stack overflow as the kernel stack size is limited.<br>
<p>
Another danger is plausible but invalid filesystem state such as hard-linked directories.  Perhaps appearing as a circular directory tree, that you can descend forever.<br>
<p>
Three needs to be guarding against lock inversions, caused by plausible but invalid data structures.<br>
<p>
<p>
The only idea I can think of that might make the problem tractable is to use a public/private key pair.  With the public key used to verify the filesystem checksums.  The private key would be needed to write them.  That would at least allow  fsck to be able to validate the filesystem.<br>
<p>
<p>
But I seriously recommend FUSE with a filesystem driver hooked to a user mode linux kernel so all linux filesystems can be supported.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Do all block-device-based filesystems need to be rewritten?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 1:21 UTC (Thu)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/941001/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FUSE is indeed by far the best answer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor939546"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 18:28 UTC (Fri)
                               by <b>warrax</b> (subscriber, #103205)
                              [<a href="/Articles/939546/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In the Debian discussion, Garrett suggested that risky filesystems could be mounted as FUSE filesystems in user space, thus making it much easier to contain any ill effects</span><br>
<p>
A hostile file system mounted for the currently running user can still delete or exfiltrate ALL of the user's data if any sort of code execution exploit is possible. Or am I misunderstanding how FUSE works? It doesn't run as a 3rd (super-unprivileged) user, does it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939546/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 19:01 UTC (Fri)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/939548/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's no reason any FUSE filesystem needs access to arbitrary files, just confine it in an LSM policy that only grants access to the relevant block device and /dev/fuse.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor939550"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 19:28 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/939550/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; A hostile file system mounted for the currently running user can still delete or exfiltrate ALL of the user's data if any sort of code execution exploit is possible.</span><br>
<p>
A point I've made many times now is that the overwhelmingly common threat vector is "malicious files on a well-formed filesystem" -- You don't need elevated privileges to exfiltrate/encrypt/delete files owned by the same user that double-clicked on the wrong file.  Combine that with the increasingly-common passwordless sudo norm, and there's no need for "exploits" to take over the whole system.<br>
<p>
Similarly, the overwhelmingly common usage scenario is "of course I want to access the files on this device; it's why I plugged it in!" Anything that requires the user to click "yes" or otherwise trigger a mount will get muscle-memoried into uselessness pretty rapidly.  <br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939550/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2023 19:52 UTC (Fri)
                               by <b>KJ7RRV</b> (guest, #153595)
                              [<a href="/Articles/939554/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; the increasingly-common passwordless sudo norm</span><br>
<p>
Are there distros allowing passwordless sudo by default (‽), or is it just increasingly common for users to enable it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2023 15:18 UTC (Tue)
                               by <b>MarcB</b> (subscriber, #101804)
                              [<a href="/Articles/939949/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is an annoying trend to place increasing restrictions on access to local logs without any sane way to allow administrative access. <br>
<p>
/dev/kmsg, i.e. dmesg, is the most kernel-related example - and also a pretty bad one, because there is absolutely no way to fix this with permissions (you would have to hope the data gets to /var/log/kern.log, or similar - but the system might have severe issues, which is why you are using dmesg in the first place).<br>
<p>
This pattern is also very common for many modern applications. Unlike older ones, they make no use of group permissions.<br>
<p>
I can see how people are tempted to relax sudo rules more and more, even though this is a very bad idea (the sudoers man page literally contains a "Quick guide to EBNF").<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor943052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2023 9:51 UTC (Wed)
                               by <b>rbtree</b> (guest, #129790)
                              [<a href="/Articles/943052/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can use any FIDO2 or U2F token as a shortcut. U2F tokens are dirt cheap these days (I've seen okay quality ones for $5 apiece). <br>
<p>
When you try to elevate, instead of a password prompt you see a request to touch the hardware token (plus an optional PIN verification: unlike a good user's password, the PIN is typically short, and entering it incorrectly 6-10 times in a row  resets the token to the factory state).<br>
<p>
Note that you should really put the config somewhere in /etc and mark the file as owned by root. The default is to put it in ~/.config — then you can just add another key there and elevate.<br>
<p>
<a rel="nofollow" href="https://wiki.archlinux.org/title/Universal_2nd_Factor">https://wiki.archlinux.org/title/Universal_2nd_Factor</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/943052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor943658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2023 11:26 UTC (Wed)
                               by <b>daenzer</b> (subscriber, #7050)
                              [<a href="/Articles/943658/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW,<br>
<p>
 journalctl —dmesg <br>
<p>
works without sudo even if dmesg itself doesn’t.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/943658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor939618"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2023 21:18 UTC (Sat)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/939618/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One practical answer is that writing secure userspace code is significantly easier than writing secure kernelspace code. You have a much greater choice of languages - e.g., I'd strongly consider using something like Python for reading HFS filesystems, as the chances that anyone is using it for performance-sensitive work is low. (Put another way, I'd bet you can easily get the same performance on a modern machine with Python as you could with the original HFS implementation on the first computers it ran on!)<br>
<p>
And even in the two languages the kernel supports, it's much easier to use existing third-party libraries that can handle parsing robustly in userspace than in kernelspace (e.g. serde for Rust, there's a demo at <a href="https://github.com/Rust-for-Linux/linux/pull/1007">https://github.com/Rust-for-Linux/linux/pull/1007</a> but I am guessing it's not realistic to see it in-tree any time soon), so you can avoid hand-rolled parsers that are more likely to be buggy. The overall development and testing experience is easier, too, which should help.<br>
<p>
But also as mjg59 said in another comment, yes you can sandbox the FUSE process. Even if you're on a distro where LSMs aren't an easy choice, you should be able to get a lot of sandboxing out of seccomp and/or unprivileged user namespaces. Or you certainly _can_ run it as a third user if you'd like (you need the user_allow_other option in /etc/fuse.conf, which is mostly there to protect against hostile filesystems hanging and giving you a bad time, but it's a much lower threat than actually running code).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939618/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2023 14:35 UTC (Sun)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/939666/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An even better practical answer: a userspace compromise is limited to that process and what it has rights to do.  If that’s a lot, well, you have a problem, but it might not be.<br>
<p>
A good kernel compromise - it’s all in one address space and can read user memory.  That’s it, game over.<br>
<p>
Languages etc do matter as well but the bigger difference is the scope of a compromise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor939675"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2023 19:17 UTC (Sun)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/939675/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      It’s actually worse than just removable media.  Under <code>kernel_lockdown(7)</code>, the threats to the kernel include <i>almost everything</i>.  They include USB devices.  They include removable filesystems.  They include <code>mkfs</code> and <code>fsck</code>, and therefore include <i>local</i> filesystems!  They even include PCI devices attached via Thunderbolt, and therefore most device drivers.  I would not be surprised if the overall attack surface exceeds even that of web browsers, and browsers were at least written with security as a goal.


      
          <div class="CommentReplyButton">
            <form action="/Articles/939675/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2023 19:40 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/939679/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem as I understand it there is that DMA expects access to the full address space. And it's running a program that is nothing to do with the kernel.<br>
<p>
So it can simply overwrite kernel memory, and there's nothing the kernel can do about it ...<br>
<p>
(So you're relying on getting the MMU to contain  this potentially hostile peripheral.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 3:59 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/939701/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your understanding is, as usual, incorrect.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor939716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 10:49 UTC (Mon)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/939716/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Perhaps they could be moved/sandboxed using the  "<a href="https://lwn.net/Articles/755919/">User mode blobs</a>"  infrastructure?


      
          <div class="CommentReplyButton">
            <form action="/Articles/939716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor939771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 14:11 UTC (Mon)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/939771/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Periodical reminder that the LKL out-of-tree patch set (<a href="https://github.com/lkl/linux">https://github.com/lkl/linux</a>) comes with a 'lklfuse' tool which allows any in-kernel filesystem to be run in an userspace process using FUSE, which could then be sandboxed (as suggested in sibling comments). So same as libguestfs, without the virtual machine overhead.<br>
<p>
Getting some company to provide funding and/or manpower for that to be upstreamed would be a great step forward.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Kernel Library</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2023 15:18 UTC (Mon)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/939812/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      That would be absolutely awesome, especially if it could be compiled to WebAssembly for fine-grained sandboxing.  I’m not aware of a single exploit against a WebAssembly implementation that does not rely on a miscompilation, and miscompilations require the WebAssembly module <i>itself</i> to be malicious, as opposed to being exploited during runtime.


      
          <div class="CommentReplyButton">
            <form action="/Articles/939812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor939869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Kernel Library</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2023 3:20 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/939869/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;   miscompilations require the WebAssembly module itself to be malicious</span><br>
<p>
Or just buggy? Why would WASM be inherently less vulnerable than JITing JavaScript engines, which do have escape bugs once in a while?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/939869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor940814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Kernel Library</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2023 22:06 UTC (Tue)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/940814/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But it's rare to find a JS program written by a non malicious dev, where there's some *input* to the program that causes it to trigger an exploitable jit bug. In theory it could happen, but in practice jit exploits generally require structuring the code in some very specific weird way, which is easy if the attacker writes the code but much harder if they only control the bytes being fed to some preexisting code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor940239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2023 8:51 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/940239/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem here is when you get to more complicated layered cases like partitions and device-mapper.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor940430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2023 10:26 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/940430/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think those are nearly as important as filesystems. I would hope to think the partition parsing code would be minimal enough that it could be thoroughly fuzzed and audited to be free of holes with high confidence, so that can be left to the host kernel. And device mapper on USB sticks sounds  a really rare case to me, are there really distros that try to autodetect and autoconfigure device mapper on hotplugged devices?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor940240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2023 8:54 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/940240/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To expand on the libguestfs point.  Gnome has a virtual filesystem (GVFS, <a href="https://en.wikipedia.org/wiki/GVfs">https://en.wikipedia.org/wiki/GVfs</a>).  Someone enterprising could write a GVFS backend that talks to the libguestfs API, which would allow things like Gnome's file manager to transparently and safely open untrusted volumes.  And it'd pretty efficient for copying large files in and out.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor940756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2023 13:52 UTC (Tue)
                               by <b>anarcat</b> (subscriber, #66354)
                              [<a href="/Articles/940756/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Every time something like this comes up, it seems the filesystem maintainers consistently refuse to commit to making the kernel code resilient against hostile filesystems. This completely boggles my mind. I understand it's a hard problem and a threat vector that has never really be considered seriously, but we had the same situation with the network stack decades ago (anyone was around for the ping of death?), and attitudes have thankfully changed around this. We do not consider the network as trusted anymore: the kernel carefully unpacks every data structure it gets from the network now.<br>
<p>
Why is a filesystem so fundamentally different? I hear there might be a performance impact on sanity checks, but the same could have been said of the network, and netdev doesn't look kindly on performance hits. They seem to be able to juggle that balance better than filesystems...<br>
<p>
Right now, we're in a similar situation with the firewall: we have a bunch of CVEs coming out from nftables where a root user (in a namespace of course) can use vulnerabilities to escalate privileges outside the namespace. We treat those as serious bugs (AKA security issues outside of the kernel) and fix them.<br>
<p>
Maybe it's time to treat filesystems the same way?<br>
<p>
Am I wrong to assume the issues around hostile filesystems could be abused to escape user sandboxes the same way recent vulnerabilities around nftables did?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor940775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2023 14:58 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/940775/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The difference is that (in most cases) the system is in control of what gets written to disk, so there's no need to worry about what gets read from disk.<br>
<p>
While with the network the system has NO control over what is received, and cannot trust ANYTHING.<br>
<p>
I'm far more concerned about the effort filesystem devs seem to put in to protecting the filesystem, compared to the lack of effort they put into protecting the contents.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor940776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2023 15:07 UTC (Tue)
                               by <b>anarcat</b> (subscriber, #66354)
                              [<a href="/Articles/940776/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
The difference is that (in most cases) the system is in control of what gets written to disk
</blockquote>

You can drive a bus through that "most cases". Security is not about "most cases", it's exactly about those corner cases that allows attackers to do whatever they want with a system. When the kernel mounts a filesystem, it just doesn't know what's written on there, and does *not* have control over it, by definition. It's a read operation. It has control over writes, and even then, there's a potentially hostile stack of microcontrollers underneath there.

<p>
I understand if we'd make this argument about RAM or CPU, you need to draw that line somewhere. I think the point I'm trying to make is the line isn't drawn in the right place for filesystem images. Those used to be tied to (hard) disks, but those days are long gone...


      
          <div class="CommentReplyButton">
            <form action="/Articles/940776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor940789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2023 19:10 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/940789/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; While with the network the system has NO control over what is received, and cannot trust ANYTHING.</span><br>
<p>
If someone injects something into the network stream, with valid checksums and metadata, then the user/application *will* get attacker-supplied data that can trigger all sorts of secondary problems.  The relative ease of which attackers can inject this stuff into the network means that applications have to add more layers of security (eg TLS or application-specific stuff) to be resilient in the face of intentional attacks.<br>
<p>
This is the sort of filesystem attack we're talking about here -- intentionally mangled metadata but with the checksums fixed up so that from the FS's perspective, it's legitimate.  How is the filesystem supposed to know that the data/metadata it's reading is sane when the only mechanisms it has for such things have been intentionally subverted?  The consider that this mangled metadata might only be illegitimate in combination with another portion of filesystem that might never get examined.<br>
<p>
Short of effectively running a full fsck scrub at mount time (and failing to mount until all errors are fixed offline) I don't see a way to ensure the overall filesystem is in a 100% internally consistent/sane state at mount time.   This won't protect you against the on-disk metadata from getting changed out from underneath you either, so you'd end up needing to maintain all metadata in memory, and only doing writes on updates.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/940789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor940806"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2023 19:49 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/940806/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Or you need the effect of corrupt filesystems to be limited to that instance of the filesystem, which is a more manageable, but still hard, problem.
<p>If the worst case impact of mounting a malformed filesystem image is that you can read parts of the image that you should not have been able to read as a normal user (e.g. there's a file whose content is the superblock, or a file that lets you read part of the partition that's not in use by the filesystem's metadata), then there's no security issue; the attacker who can damage the filesystem in ways that expose other parts of the device also has access to the full device without damaging the filesystem.
<p>The problem here, however, is that a damaged filesystem might tickle a bug that gives access to anything the kernel has access to, not just to the partition, loopback image, or raw device that the filesystem is stored on. It's not great if a filesystem bug can be used to change the IP stack's state such that an attacker controlled remote device can get root on your system.


      
          <div class="CommentReplyButton">
            <form action="/Articles/940806/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor941098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 16:00 UTC (Thu)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/941098/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      It <i>is</i> time to treat filesystems the same way, but it is unreasonable to expect the (already overworked) filesystem maintainers to fix the stream of vulnerabilities syzbot (and other fuzzers) are finding.  Google, Oracle, Red Hat, and other companies need to hire people specifically to fix these vulnerabilities and backport the fixes.



      
          <div class="CommentReplyButton">
            <form action="/Articles/941098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unmaintained filesystems as a threat vector</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 16:20 UTC (Thu)
                               by <b>anarcat</b> (subscriber, #66354)
                              [<a href="/Articles/941107/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See that's what I'm talking about.<br>
<p>
I'm not talking about Ted Ts'o or any specific kernel maintainer to actively start doing this, I know everyone is busy. What I would like is some openness to consider those things a real problem, and I think there's a blockage there. Ts'o, in particular, has been pretty vocal about this being unfixable and not part of the threat model, which I find frustrating.<br>
<p>
Hell, if anything Google and Samsung would need this to keep hackers from doing jailbreaks on their phones eventually, won't they? :p<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
