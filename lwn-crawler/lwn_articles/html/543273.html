        <!DOCTYPE html>
        <html lang="en">
        <head><title>Anatomy of a user namespaces vulnerability [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/543273/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/542918/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/543273/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Anatomy of a user namespaces vulnerability</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Michael Kerrisk</b><br>March 20, 2013</br>
           </div>
<p> An exploit <a href="/Articles/543442/">posted</a> on March 13
revealed a rather easily exploitable security vulnerability (CVE 2013-1858)
in the implementation of user namespaces.  That exploit enables an
unprivileged user to escalate to full root privileges. Although a fix was
quickly provided, it is nevertheless instructive to look in some detail at
the vulnerability, both to better understand the nature of this kind of
exploit and also to briefly consider how this vulnerability came to appear
inside the user namespaces implementation. General background on user
namespaces can be found in  <a
href="/Articles/532593/">parts 5</a> and <a href="/Articles/540087/">part
6</a> of our recent <a href="/Articles/531114/#series_index">series</a> of
articles on namespaces.




<h4>Overview</h4>


<p> The vulnerability was discovered by Sebastian Krahmer, who posted
proof-of-concept <a
href="http://stealth.openwall.net/xSports/clown-newuser.c">code</a>
demonstrating the exploit on the oss-security mailing list.

<!--; Sebastian <a
href="http://pwnies.com/archive/2009/winners/">is no stranger</a> to
finding privilege escalation bugs.-->

The exploit is based on the fact that
Linux 3.8 allows the following combination of flags when calling
<tt>clone()</tt> (and also <tt>unshare()</tt> and <tt>setns()</tt>):

<pre>
    clone(... CLONE_NEWUSER | CLONE_FS, ...);
</pre>

<p> <tt>CLONE_NEWUSER</tt> says that the new child should be in
a new user namespace, and with the <a
href="/Articles/528078/">completion</a> of the user namespaces
implementation in Linux 3.8, that flag can now be employed by unprivileged
processes. Within the new namespace, the child has a full set of capabilities,
although it has no capabilities in the parent namespace.  

<p> The <tt>CLONE_FS</tt> flag says that the caller of <tt>clone()</tt> and
the resulting child should share certain filesystem-related attributes&mdash;root
directory, current working directory, and file mode creation mask
(umask). The attribute of particular interest here is the root directory,
which a privileged process can change using the <tt>chroot()</tt> system
call.

<p> It is the mismatch between the scope of these two flags that creates
the window for the exploit.  On the one hand, <tt>CLONE_FS</tt> causes the
parent and child process to share the root directory attribute.  On the
other hand, <tt>CLONE_NEWUSER</tt> puts the two processes into separate
user namespaces, and gives the child full capabilities in the new user
namespace. Those capabilities include <tt>CAP_SYSCHROOT</tt>, which gives a
process the ability to call <tt>chroot()</tt>; the sharing provided by
<tt>CLONE_FS</tt> means that the child can change the root directory of a
process in another user namespace.

<p> In broad strokes, the exploit achieves escalation to root privileges by
executing any set-user-ID-root program that is present on the system in a
<a href="http://en.wikipedia.org/wiki/Chroot">chroot environment</a> which
is engineered to execute attacker-controlled code. That code runs with user
ID 0 and allows the exploit to fire up a shell with root privileges.  The
exploit as demonstrated is accomplished by subverting the dynamic linking
mechanism, although other lines of attack based on the same foundation are
also possible.



<h4>The vulnerability scenario</h4>

<p> The first part of understanding the exploit requires some understanding
of the operation of the dynamic linker.  Most executables (including most
set-user-ID root programs) on a Linux system employ shared libraries and
dynamic linking.

<!--
Rather than including the code of all libraries inside
the executable itself (i.e., static linking), a dynamically linked
executable instead contains a list of dynamic dependencies&mdash;libraries
that needed to be loaded along with the executable at run time. Dynamic
linking is generally considered to have <a
href="http://www.akkadia.org/drepper/no_static_linking.html">many
advantages</a> over static linking.
-->

At run time, the dynamic linker loads the required shared libraries in
preparation for running the program. The pathname of the dynamic linker is
embedded in the executable file's ELF headers, and is listed among the
other dependencies of a dynamically linked executable when we use the
<tt>ldd</tt> command (here executed on an x86-64 system):

<pre>
    $ <b>ldd /bin/ls | grep ld-linux</b>
            /lib64/ld-linux-x86-64.so.2 (0x00000035b1800000)
</pre>


<p>
There are a few important points to note about the dynamic linker. First, it
is run before the application program. Second, it is run under whatever
credentials would be accorded to the application program; thus, for
example, if a set-user-ID-root program is being executed, the dynamic
linker will run with an effective user ID of root.

<p> Executable files are normally protected so that they can't be modified
by users other than the file owner; this prevents, for example,
unprivileged users from modifying the dynamic linker path embedded inside a
set-user-ID-root binary. For similar reasons, an unprivileged user can't
change the contents of the dynamic linker binary.

<p>
However, suppose for a moment that an unprivileged user could construct a
chroot tree containing (via a hard link) the set-user-ID-root binary and
an executable of the user's own choosing at
<tt>/lib64/ld-linux-x86-64.so.2</tt>. Running the set-user-ID-root binary
would then cause control first to be passed to the user's own code, which
would be running as root. The aim of the exploit is to bring about the
situation shown in the following diagram, where pathnames are shown linked
to various binary files:


<blockquote>

    <img src="https://static.lwn.net/images/2013/namespaces/userns_exploit_chroot.png" alt="[chroot layout]">

</blockquote>

<p> The key point in the above diagram is that two pathnames link to the
<tt>fusermount</tt> binary (a set-user-ID-root program used for mounting
and unmounting <a href="http://fuse.sourceforge.net/">FUSE</a>
filesystems). If a process outside the chroot environment executes the
<tt>/bin/fusermount</tt> binary, then the real dynamic linker will be
invoked to load the binary's shared libraries. On the other hand, if a
process inside the chroot environment executes the other link to the binary
(<tt>/suid-root</tt>), then the kernel will load the ELF interpreter
pointed to by the link <tt>/lib64/ld-linux-x86-64.so.2</tt> inside the
chroot environment. That link points to code supplied by an attacker, and
will be run with root privileges.

<p>
How does the Linux 3.8 user namespaces implementation help with this
attack? First, an unprivileged user can create a new user namespace in which
they gain full privileges, including the ability to create a chroot
environment using <tt>chroot()</tt>. Second, the differing scope of
<tt>CLONE_NEWUSER</tt> and <tt>CLONE_FS</tt> described above means that
the privileged process inside a new user namespace can construct a chroot
environment that applies to a process outside the user namespace. If that
process can in turn then be made to execute a set-user-ID binary inside
the chroot environment, then the attacker code will be run as root.




<h4>A three-phase attack</h4>


<p> Although Sebastian's program is quite short, there are many details
involved that make the exploit somewhat challenging to understand;
furthermore, the program is written with the goal of accomplishing the
exploit, rather than educating the reader on how the exploit is carried
out.  Therefore, we'll provide an equivalent program, <a
href="/Articles/543509/"><tt>userns_exploit.c</tt></a>, that performs the
same attack&mdash;this program is structured in a more understandable way
and is instrumented with output statements that enable the user to see what
is going on. We won't walk though the code of the program, but it is well
commented and should be easy to follow using the explanations in this article.

<p> The attack code involves the creation of three processes, which we'll
label "parent", "child", and "grandchild".  The attack is conducted in
three phases; in each phase, a separate instance of the attacker code is
executed. This concept can at first be difficult to grasp when reading the
code. It's easiest to think of the <tt>userns_exploit</tt> program as
simply offering itself in three flavors, with the choice being determined
by command-line arguments and the effective user ID of the process.

<p>
The following diagram shows the exploit in overview:

<blockquote>

    <img src="https://static.lwn.net/images/2013/namespaces/userns_exploit_steps.png" alt="[user
    namespace exploit steps]">

</blockquote>

<p>
In the above diagram, the vertical dashed lines indicate points where a
process is blocked waiting for another process to complete some action.

<p>
In the first phase of the exploit, the program starts by discovering its
own pathname. This is done by reading the contents of the
<tt>/proc/self/exe</tt> symbolic link.
The program needs to know its own pathname for two
reasons: so it can create a link to itself inside the chroot tree and so it
can re-execute itself later.

<p> The program then creates two processes, labeled "parent" and "child"
in the above diagram. The parent's task is simple. It will loop, using the
<tt>stat()</tt> system call to check whether the program pathname
discovered in the previous step is owned by root and has the
set-user-ID permission bit enabled. This causes the parent to wait until
the other processes have finished their tasks.

<p>
In the meantime, the "child" populates the directory tree that will be used
as the chroot environment. The goal is to create the set-up shown in the
following diagram:

<blockquote>

    <img src="https://static.lwn.net/images/2013/namespaces/userns_exploit_chroot_2.png" alt="[chroot layout]">

</blockquote>

<p> The difference from the first diagram is that we now see that it is the
<tt>userns_exploit</tt> program that will be used as the fake dynamic
loader inside the chroot environment. Furthermore, that binary is also
linked outside the chroot environment, and the exploit design takes advantage of
that fact.

<p> Having created the chroot tree shown above, the child then employs
<tt>clone(CLONE_NEWUSER|CLONE_FS)</tt> to create a new process&mdash;the
grandchild. The grandchild has a full set of capabilities, which allows it
to call <tt>chroot()</tt> to place itself into the chroot tree. Because the
grandchild and the child share the root directory attribute, the child is
now also placed in the chroot environment.

<p>
Its small task complete, the grandchild now terminates. At that point,
the child, which has been waiting on the grandchild, now
resumes. As its next step, the child executes the program at the path
<tt>/suid-root</tt>. This is in fact a link to the <tt>fusermount</tt>
binary. Because the child is in the initial user namespace and the
<tt>fusermount</tt> binary is set-user-ID-root, the child gains root
privileges.

<p> However, before the <tt>fusermount</tt> binary is loaded, the kernel
first loads its ELF interpreter, the file at the path
<tt>/lib64/ld-linux-x86-64.so.2</tt>.  That, as it happens, is actually the
<tt>userns_exploit</tt> program.  Thus, the <tt>userns_exploit</tt> program
is now executed for a second time (and the <tt>fusermount</tt> program is
never executed).

<p> The second phase of the exploit has now begun.  This instance of the
<tt>userns_exploit</tt> program recognizes that it has an effective user ID
of 0. However, the only files it can access are those inside the chroot
environment. But that is sufficient. The child can now change the ownership
of the file <tt>/lib64/ld-linux-x86-64.so.2</tt> and turn on the file's
set-user-ID permission bit. That pathname is, of course, a link to the
<tt>userns_exploit</tt> binary.  At this point, the child's work is now
complete, and it terminates.

<p> All of this time, the parent process has been sitting in the background
waiting for the <tt>userns_exploit</tt> binary to become a set-user-ID-root
program. That, of course, is what the child has just accomplished. So, at
this point, the parent now executes the <tt>userns_exploit</tt> program
<i>outside</i> the chroot environment. On this execution, the program is
supplied with a command-line argument.

<p> The third and final phase of the exploit has now started. The
<tt>userns_exploit</tt> program determines that it has an effective user ID
of 0 and notes that it has a command-line argument. That latter fact
distinguishes this case from the second execution of the
<tt>userns_exploit</tt> and is a signal that this time the program is being
executed outside the chroot environment. All that the program now
needs to do is execute a shell; that shell will provide the user with full
root privileges on the system.




<h4>Further requirements for a successful exploit</h4>

<p> There are a few other steps that are necessary to successfully
accomplish the exploit. The <tt>userns_exploit</tt> program must be
statically linked. This is necessary so that, when executed as the dynamic linker
inside the chroot environment, the <tt>userns_exploit</tt> program does not
itself require a dynamic linker.

<p> In addition, the value in the <tt>/proc/sys/fs/protected_hardlinks</tt>
file must zero. The <tt>protected_hardlinks</tt> file was a feature that
was added in Linux 3.6 specifically <a href="/Articles/503660/">to prevent
the types of exploit</a> discussed in this article. If this file has the
value one, then only the owner of a file can create hard links to it. On a
vanilla kernel, <tt>protected_hardlinks</tt> unfortunately has the default
value zero, although some distributions provide kernels that change this
default.


<p>
In the process of exploring this vulnerability, your editor
discovered that set-user-ID binaries built as hardened,
position-independent executables (PIE) cannot be used for this particular
attack. (Many of the set-user-ID-root binaries on his Fedora system were
hardened in this manner.) While PIE hardening thwarts this particular line of
attack, the <tt>chroot()</tt> technique described here can still be used to
exploit a set-user-ID-root binary in other ways. For example, the
binary can be placed in a suitably constructed chroot environment
that contains the genuine dynamic linker but a compromised libc.

<p> Finally, user namespaces must of course be enabled on the system where
this exploit is to be tested, and the kernel version needs to be precisely
3.8. Earlier kernel versions did not allow unprivileged users to create
user namespaces, and later kernels will fix this bug, as described
below. The exploit is unlikely to be possible with distributor kernels:
because the Linux 3.8 kernel does not support the use of user namespaces
with various filesystems, including NFS and XFS, distributors are
unlikely to enable user namespaces in the kernels that they ship.


<h4>The fix</h4>

<p> Once the problem was <a href="/Articles/543308/">reported</a>, Eric
Biederman <a href="/Articles/543310/">considered</a> two possible
solutions. The more complex solution is to create an association from a
process's <tt>fs_struct</tt>, the kernel data structure that records the
process's root directory, to a user namespace, and use that association to
set limitations around the use of <tt>chroot()</tt> in scenarios such as
the one described in this article. The alternative is the simple and
obviously safe solution: disallow the combination of <tt>CLONE_NEWUSER</tt>
and <tt>CLONE_FS</tt> in the <tt>clone()</tt> system call, make
<tt>CLONE_NEWUSER</tt> automatically imply <tt>CLONE_FS</tt> in the
<tt>unshare()</tt> system call, and disallow the use of <tt>setns()</tt> to
change a process's user namespace if the process is sharing
<tt>CLONE_FS</tt>-related attributes with another process.

<p> Subsequently, Eric <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e66eded8309ebf679d3d3c1f5820d1f2ca332c71">concluded</a>
that the complex solution seemed to be unnecessary and would add a small
overhead to every call to <tt>fork()</tt>. He thus opted for the simple
solution: the Linux 3.9 kernel (and the 3.8.3 stable kernel) will disallow
the combination of <tt>CLONE_NEWUSER</tt> and <tt>CLONE_FS</tt>.



<h4>User namespaces and security</h4>

<p> As we noted in <a href="https://lwn.net/Articles/531114/">an earlier
article</a>, Eric Biederman has put a lot of work into trying to ensure
that unprivileged can create user namespaces without causing security
vulnerabilities.  Nevertheless, a significant exploit was found soon after
the release of the first kernel version that allowed unprivileged processes
to create user namespaces. Another user namespace vulnerability that
potentially allowed unprivileged users to load arbitrary kernel modules was
also <a href="/Articles/543539/">reported</a> and <a
href="/Articles/543544/">fixed</a> earlier this month. In addition, during
the discussion of the <tt>CLONE_NEWUSER|CLONE_FS</tt> issue,
Andy Lutomirski has <a href="/Articles/543316/">hinted</a> that there may
be another user namespaces vulnerability to be fixed.

<p> Why is it that several security vulnerabilities have sprung from the
user namespaces implementation? The fundamental problem seems to be that
user namespaces and their interactions with other parts of the kernel are
rather complex&mdash;probably too complex for the few kernel developers
with a close interest to consider all of the possible security
implications. In addition, by making new functionality available to
unprivileged users, user namespaces expand the attack surface of the
kernel. Thus, it seems that as user namespaces come to be more widely
deployed, other security bugs such as these are likely to be
found. One hopes that they'll be found and fixed by the kernel developers
and white hat security experts, rather than found and exploited by black
hat attackers.

<p>
<i>Updated on 22 February 2013 to clarify and correct some minor details of the
"simple and safe" solution under the heading, "The fix".</i><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Namespaces-User_namespaces">Namespaces/User namespaces</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Namespaces">Namespaces</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Vulnerabilities-Privilege_escalation">Vulnerabilities/Privilege escalation</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/543273/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor543671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2013 21:28 UTC (Wed)
                               by <b>spender</b> (guest, #23067)
                              [<a href="/Articles/543671/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Typo in the first sentence: March 13th, not Feb 13th.<br>
<p>
-Brad<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543681"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2013 21:48 UTC (Wed)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/543681/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Typo in the first sentence: March 13th, not Feb 13th.</font><br>
<p>
Fixed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543681/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2013 22:57 UTC (Wed)
                               by <b>adler187</b> (guest, #80400)
                              [<a href="/Articles/543693/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, grammar issue in the last sentence before "The Fix" section:<br>
<p>
"... user namespaces are unlikely to enable user namespaces in the kernels that they ship."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typos and such</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2013 23:05 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/543694/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      It's been a while since we've needed to remind folks of the line of text right above the comment box:
<p>
<blockquote>
Please <b>do NOT post typos</b> in the article as comments, send them to lwn@lwn.net instead.
</blockquote>
<p>
The alternative is to clutter the comment stream with stuff that persists long after the error is fixed and benefits nobody.  
      
          <div class="CommentReplyButton">
            <form action="/Articles/543694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typos and such</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 5:41 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/543713/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The comment form lets you choose plain text or HTML.  It should also let you choose 'comment' or 'correction'.  If a correction is posted when the LWN staff are not around it can be displayed with the comments until an editor has the chance to act on it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor543678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2013 21:45 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/543678/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you enjoy thinking about security, please look at this stuff.  It's really neat, but there is certainly lots of room for bugs.<br>
<p>
(I'll publicly post at least two more of varying severities once there are patches.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor543690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2013 22:35 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/543690/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Complexity is not the root problem.<br>
<p>
The root problem is that previously, once you gained root you had the master keys to the whole system. Game over. Now, anybody can create their personal little sandbox and you need to vet *every* activity to make sure that it doesn't spill over. That's something that Linux historically didn't do (no need); no wonder that a few cases which fell through the cracks.<br>
<p>
… and chroot() has a history of being a security loophole anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 5:33 UTC (Thu)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/543711/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup, consider that there are some filesystem APIs that allow root to have r/w access to all inodes and their attributes in a filesystem because they bypass the filesystem namespace altogether...<br>
<p>
-Dave.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 7:42 UTC (Thu)
                               by <b>lkundrak</b> (subscriber, #43452)
                              [<a href="/Articles/543718/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm curious, which ones they are?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 14:36 UTC (Thu)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/543785/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm actually confused as to what his statement is to begin with. Root by virtue of having privileged access can do whatever it wants to any file assuming you don't bring capabilities or other access controls into the picture. Saying root has access to read/write to any inode or change any attributes is a vacuous statement since root can open any file in the filesystem read/write to begin with by virtue of being root. You don't need special APIs for that you just use open. Maybe he's talking about debug file systems or tools that are available for certain file systems like XFS that let you manipulate the inodes of a filesystem directly?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 16:52 UTC (Thu)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/543819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Root by virtue of having privileged access can do whatever it wants to any file</font><br>
<p>
Isn't "root" now an ambiguous term?  Don't we now have local root and global  or system root?  We certainly don't want local root to have privileges to do things like open arbitrary files by inode number.  For filesystems the local root mounted or owns perhaps, but certainly not with regard to filesystems mounted by system root or other local root users.<br>
<p>
Unless the idea is to adopt the convention that "root" always refers to system root, and never to local root without further qualification, any such reference is likely to lead to some considerable degree of confusion. This thread is a perfect example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor543862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 21:05 UTC (Thu)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/543862/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Maybe he's talking about debug file systems or tools that are available</font><br>
<font class="QuotedText">&gt; for certain file systems like XFS that let you manipulate the inodes</font><br>
<font class="QuotedText">&gt; of a filesystem directly?</font><br>
<p>
File handles are the problem. And when combined with interfaces like bulkstat, you've got a capability to find, open and *invisibly modify* any file in the filesystem regardless of namespace restrictions...<br>
<p>
<a href="http://oss.sgi.com/archives/xfs/2013-03/msg00382.html">http://oss.sgi.com/archives/xfs/2013-03/msg00382.html</a><br>
<p>
-Dave<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor543732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 10:48 UTC (Thu)
                               by <b>Tobu</b> (subscriber, #24111)
                              [<a href="/Articles/543732/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      chroot doesn't reduce the attack surface much because there's still the whole kernel, but I wouldn't call it a loophole. It's just a user namespaces forerunner, which should be combined with seccomp or similar if one wants a strong security boundary. suid on the other hand is an attractive nuisance: a simple design, but every privileged process that uses it has to be paranoid about its entire environment.
      
          <div class="CommentReplyButton">
            <form action="/Articles/543732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543883"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 22:49 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/543883/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
chroot does reduce the attack surface, considerably.<br>
<p>
No more setuid issues.<br>
<p>
No more /tmp race conditions.<br>
<p>
No more /dev.<br>
<p>
No more /proc.<br>
<p>
No more /sys.<br>
<p>
No more playing with named pipes or unix domain sockets owned by privileged processes.<br>
<p>
I'll never understand the attitude of "chroot isn't enough; let's instead add a layer of incredibly complex policy, and tens of thousands of lines of new code to the kernel". Yeah.. that's much better....<br>
<p>
It wasn't but a few years ago that one could confidently say that Linux shook the bugs out of simple stuff like file permissions, including setuid linker issues, and run-of-the-mill data races. Now we're adding a whole new set of incredibly complex subsystems and interfaces, and _willingly_ putting everybody through the grinder all over again.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543883/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 22:58 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/543884/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the problem with chroot has been that it's not perfect.<br>
<p>
Root can mount things inside the chroot, create device files, etc and so it's possible for someone to escape out of a chroot after they become root.<br>
<p>
I've never bought into the 'this makes chroot worthless' mantra, it may only slow an attacker, but slowing an attacker can still be valuable.<br>
<p>
<p>
<p>
If these namespaces could only be setup by root, we would not really be any worse off, but since people are so fascinated by the "my admin won't let me do X, so I'm going to figure out a way to do it anyway" problem that they are giving too much power to non-root users.<br>
<p>
If you admin doesn't want to let you do something, go use a different box (including one where you are the admin), don't engineer a way around the admin's restrictions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2013 8:48 UTC (Fri)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/543902/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the problem with chroot has been that it's not perfect.</font><br>
<p>
The problem with chroot, as I was told, is that it is not and has never been a security mechanism.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2013 18:41 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/544009/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  The problem with chroot, as I was told, is that it is not and has never been a security mechanism.</font><br>
<p>
It depends on how you define 'security mechanism'<br>
<p>
chroot has always provided security in that processes in a chroot in that it prevented that process from accessing any files outside that chroot.<br>
<p>
This doesn't mean that this security couldn't be bypassed (if you could get root inside the chroot), but if you did not have root in the chroot, it helped.<br>
<p>
for example, if a server had a vulerability that allowed it to access arbitrary files on the filesystem, putting it in a chroot can be very useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor544299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2013 9:42 UTC (Mon)
                               by <b>talex</b> (guest, #19139)
                              [<a href="/Articles/544299/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Root can mount things inside the chroot, create device files, etc and so it's possible for someone to escape out of a chroot after they become root.</font><br>
<p>
As I understand it: with user namespaces, *anyone* can escape from a chroot. At least, that seemed to be the case when I tested it (I was experimenting with using namespaces to sandbox some aspects of 0install:<br>
<a href="http://thread.gmane.org/gmane.comp.file-systems.zero-install.devel/6805/focus=6807">http://thread.gmane.org/gmane.comp.file-systems.zero-inst...</a> )<br>
<p>
<font class="QuotedText">&gt; If these namespaces could only be setup by root, we would not really be any worse off, but since people are so fascinated by the "my admin won't let me do X, so I'm going to figure out a way to do it anyway" problem that they are giving too much power to non-root users.</font><br>
<p>
The problem with that (only making security features available to root) is that then prorgammers can't use them. For example, 0install needs to unpack archives it downloads. Since tar may contain bugs, we'd like to run tar in a restricted environment (e.g. a chroot where /home doesn't exist). If that requires root, then 0install itself has to be setuid, which is not good.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2013 10:17 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/544306/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
why should you be able to install new software on the system without the permission of the admin of that system?<br>
<p>
if 0install needs to run tar as root to install it's applications, and you don't want to trust tar as root, then you shouldn't trust it. untar the files as the user and then change their permissions afterwords.<br>
<p>
And if you think that users should be able to change the ownership of files to be other users without requiring some sort of privilege, you just don't understand the concepts.<br>
<p>
<p>
Namespaces makes it possible to escape from a chroot, because they let the user become root inside a changeroot.<br>
<p>
But namespaces are intended to replace chroot, so you would not be likely to use chroot and namespaces together.<br>
<p>
now, once distros start enabling all these namespaces by default, they end up weakening the security of anything that's using chroot, but if a distro is doing that, the distro should be changing the programs to be locked down via namespaces limitations instead<br>
<p>
nobody should be using Fedora in production, it's bleeding edge, and exposing this sort of security problem where namespaces interact badly with each other and with other features is exactly the sort of bleeding that such a distro produces.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2013 11:00 UTC (Mon)
                               by <b>talex</b> (guest, #19139)
                              [<a href="/Articles/544312/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; why should you be able to install new software on the system without the permission of the admin of that system?</font><br>
<p>
That's just the way Linux works. Any user can cause executable files to be written to their home directory, and can then run them. But, like most people, I am the admin of my computer, so I don't need to ask anyone's permission to install software.<br>
<p>
<font class="QuotedText">&gt; if 0install needs to run tar as root to install it's applications, and you don't want to trust tar as root, then you shouldn't trust it. untar the files as the user and then change their permissions afterwords.</font><br>
<p>
0install doesn't run tar as root. It runs it as my normal user. But that's still more privileges that I'd like to give it.<br>
<p>
For example, let's say I'm installing OpenTTD. Currently, 0install downloads the archive as my user (talex), unpacks it, verifies it, and runs it. OpenTTD does not gain root privileges on my system, but it does run with my user privileges. I'd like to restrict it further so that, for example, it can't read or write to my home directory (or anywhere except it's own data directory).<br>
<p>
<font class="QuotedText">&gt; But namespaces are intended to replace chroot, so you would not be likely to use chroot and namespaces together.</font><br>
<p>
So, what is the replacement for chroot in the new namespaces world then? Should I unmount all existing filesystems and mount something new over the real root? I'm not sure how to do that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor544371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Complexity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2013 18:46 UTC (Mon)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/544371/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Chrooting to an empty, unwritable directory, closing fds and dropping privileges denies useful filesystem access.  A kernel that suddenly changes that is not okay and should be fixed.

(And that's one of the bugs I found.  Guess I might as well make the whole thing public.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/544371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor543692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2013 22:51 UTC (Wed)
                               by <b>Celest</b> (guest, #69372)
                              [<a href="/Articles/543692/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Typo: user namespaces are unlikely to enable user namespaces -&gt; the first "user namespaces" should be replaced by "distributors" I suppose.<br>
<p>
Great article. I really enjoy reading exploit walkthrough especially this one since it relates to namespace. Thanks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor543696"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 0:13 UTC (Thu)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/543696/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't the combination of CLONE_NEWUSER and about half of the other CLONE_xxx options lead to potential security risks as well?  After all one may request that processes in two completely different security contexts should share things they probably shouldn't - signal handlers, thread groups, memory spaces, SYS V semaphores, and so on.<br>
<p>
It is hard to see how most of that could possibly be useful in such a combination, and some of it looks positively dangerous.  And if that is the case, wouldn't the conservative option be to disable the combination of CLONE_NEWUSER with everything that isn't recognized as necessary and/or useful? <br>
<p>
Perhaps it might also be worthwhile to consider renaming the CLONE_xxx options to clearly indicate which options actually clone things, which ones share things, and which ones create new things.  With aliases for backward compatibility of course.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543696/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor543697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2013 0:57 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/543697/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I also wonder about these 'odd' combinations.<br>
<p>
One thing I've found is that any time I tend to think "there's no reason for anyone to use _that_ combination", someone ends up running into a case where it's exactly the right thing to use.<br>
<p>
You almost need these things to be configurable. The problem is in figuring out how to do that without imposing unacceptable overhead in every fork() call.<br>
<p>
I wonder if the 'traditional' flags and combinations could be whitelisted into a very fast special case, and combinations that use the new flags/features branch off to a more flexible/detailed set of checks that may be a bit slower.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/543697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor544224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2013 11:36 UTC (Sun)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/544224/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given the complexity of the feature, it's unfortunate no-one specialising in making such exploits offered to test or tested the code prior to it being shipped.<br>
<p>
It would of course be cynical to suggest that it's because finding exploits in released kernels gets more credits that finding exploits in code under development.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor544242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2013 16:38 UTC (Sun)
                               by <b>meyert</b> (subscriber, #32097)
                              [<a href="/Articles/544242/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So, why isn't this set to "enabled" on current Fedora 18?<br>
<p>
# cat /proc/sys/fs/protected_hardlinks<br>
0<br>
<p>
Where to enable this option permanently?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2013 16:40 UTC (Sun)
                               by <b>meyert</b> (subscriber, #32097)
                              [<a href="/Articles/544243/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there actually a list of options that better where enabled in Fedora, from a security point of view? like this other one I know about:<br>
<a href="https://fedoraproject.org/wiki/Features/SELinuxDenyPtrace">https://fedoraproject.org/wiki/Features/SELinuxDenyPtrace</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor544247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2013 17:47 UTC (Sun)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/544247/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is enabled in Fedora 19 by default and I am not sure there is a list of options documented that can be enabled in general. If they were, they probably would be there by default anyway.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor545529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Setting protected *links</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2013 6:23 UTC (Tue)
                               by <b>Duncan</b> (guest, #6647)
                              [<a href="/Articles/545529/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; # cat /proc/sys/fs/protected_hardlinks</font><br>
<font class="QuotedText">&gt; 0</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; Where to enable this option permanently?</font><br>
<p>
Assuming fedora has the common sysctrl initscript/unitfile, along with the associated /etc/sysctrl.d/* and/or /etc/syctrl.conf, you'd set it there (omitting the /proc/sys bit as that's the normal working dir for this unit/script).<br>
<p>
As I follow upstream kernel development reasonably closely on both LWN and independently (running a custom configured Linus git kernel), I saw the feature introduced for kernel 3.7, and added entries to my sysctrl.conf file appropriately (JED are my initials, used to distinguish my own modifications, $&gt;&gt; is the non-root version of the last line of my custom-set $PS1 bash prompt (#&gt;&gt; would indicate root, appearing as green on red so there's no mistaking it):<br>
<p>
$&gt;&gt;grep protected /etc/sysctl.conf <br>
# JED: protected sticky/tempdir symlinks/hardlinks (kernel 3.7+)<br>
fs.protected_symlinks = 1<br>
fs.protected_hardlinks = 1<br>
<p>
<p>
Duncan<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor546215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Setting protected *links</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 5, 2013 21:11 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/546215/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could also drop a file in /etc/sysctl.d/99-jed.conf file instead of conflicting with package manager-controlled files.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/546215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor726980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a user namespaces vulnerability</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2017 19:34 UTC (Sun)
                               by <b>Dippynark</b> (guest, #117191)
                              [<a href="/Articles/726980/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent article, very useful for cementing my understanding of namespaces.<br>
<p>
I am bit confused about one aspect of the fix; one part of the fix is 'make CLONE_NEWUSER automatically imply CLONE_FS in the unshare() system call'. In this case, couldn't the child in the description of the exploit simply fork and then the grandchild could call unshare(CLONE_NEWUSER) (which would be the same as unshare(CLONE_NEWUSER | CLONE_FS) according to the fix), putting it back into the same environment as described in the article?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
