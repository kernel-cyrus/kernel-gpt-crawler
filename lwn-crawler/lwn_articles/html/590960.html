        <!DOCTYPE html>
        <html lang="en">
        <head><title>User-space out-of-memory handling [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/590960/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/590685/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/590960/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>User-space out-of-memory handling</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>March 19, 2014</p>
           <p>This article was contributed by David Rientjes</p>
           </div>
Users of Linux sometimes find themselves faced with the dreaded out-of-memory
(OOM) killer, an unavoidable consequence of having overcommitted memory and
finding swap completely filled up.  The kernel finds itself with no other
option than to abruptly kill a process when no memory can be reclaimed.  The
OOM killer has claimed web browsers, media players, and even X window
environments as victims for years.  It's very easy to lose a large amount of
work in the blink of an eye.
<p>
Occasionally, the OOM killer will actually do something helpful: it will kill a
rogue memory-hogging process that is leaking memory and unfreeze everything
else that is trying to make forward progress.  Most of the time, though, it
sacrifices something of importance without any notification; it's these
encounters that we remember.

One of my goals in my work at Google is to change that.  I've recently
proposed a patchset to actually 
give a process a notification of this impending doom and the ability
to do something about it.  Imagine, for example, being able to actually
select what 
process is sacrificed at runtime, examine what is leaking memory, or create
an artifact to save for debugging later.
<p>
This functionality
is needed if we want to do anything other than simply kill the 
process on the 
machine that will end up freeing the most memory — the only thing the OOM
killer is guaranteed to do.  Some influence on that heuristic is available
through <tt>/proc/&lt;pid&gt;/oom_score_adj</tt>, which either biases or
discounts an amount of memory for a process, but we can't do anything else and
we can't possibly implement all practical OOM-kill responses into the kernel
itself.
<p>
So, for example, we can't force the newest process to be killed in place of
a web server that 
has been running for over a year.  We can't compare the memory usage of a
process with what it is expected to be using to determine if it's out of
bounds.  We also can't kill a process that we deem to be the lowest priority.
This priority-based killing is exactly what Google wants to do.
<p>
There are two different types of out-of-memory conditions of interest:
<p>
<ul>
 <li><b>System OOM:</b> when the system as a whole is depleted of all
 memory.</li> 
<p>
 <li><b>Memory controller OOM:</b> when a control group using the memory
 controller (a "memcg") has
     reached its allowed limit.</li>
</ul>
<p>
User-space out-of-memory handling can address OOM conditions for
both control groups using the memory controller and for the system as a
whole. Either way, the
interface is provided by the  memory controller since the handler
should be implemented in a way that it doesn't care whether it is attached to
a memory controller cgroup or not.
<p>


<h4>A brief tour of the memory controller</h4>
<p>
The memory controller  allows processes to be aggregated
together into memcgs and for their memory usage to be accounted together.
It also prevents total memory
usage from exceeding a configured limit, which provides very effective memory
isolation from other processes running on the same system.  Processes
attached to a memcg may not cause the group as a whole to use more memory than the
configured limit.
<p>
When a
memcg usage reaches its limit and memory cannot be reclaimed, the memcg is
out of memory.

This happens because memory allocation within a memcg is done in two phases: the
<i>allocation</i>, which is done with the kernel's page allocator, and the
<i>charge</i>, which is done by the memory controller.  If the allocation
fails, the system as a whole is out of memory; if that succeeds and then
the charge fails, the memcg is out of memory.
<p>
As your tour guide for the memory controller cgroup, I must first offer a
warning: this functionality must be compiled into your kernel.  If you're not
in control of the kernel yourself, you may find that memcg is not enabled or
mounted.  Let's check my desktop machine running a common distribution:
<p>
<pre>
    $ grep CONFIG_MEMCG /boot/config-$(uname -r)
    CONFIG_MEMCG=y
    CONFIG_MEMCG_SWAP=y
    # CONFIG_MEMCG_SWAP_ENABLED is not set
    # CONFIG_MEMCG_KMEM is not set
</pre>
<p>
Ok, good, this kernel has the memory controller enabled.  Now let's see if
it's mounted:
<p>
<pre>
    $ grep memory /proc/mounts
    cgroup /sys/fs/cgroup/memory cgroup rw,memory 0 0
</pre>
<p>
It is, at <tt>/sys/fs/cgroup/memory</tt>.  If it weren't mounted, we could
mount it if we had root privileges with:
<p>
<pre>
    mount -t cgroup none /sys/fs/cgroup/memory -o memory
</pre>
<p>
At the mount point, there are several control files that can be used to
configure the memory controller.
This memcg itself is the root memcg — the control group that contains all
processes in the system by default.  Memcgs can be added by creating
directories with <tt>mkdir</tt>, just like any other filesystem.
Those memcgs will include all of these control files as well, and you can
create children in them as well.
<p>
There are four memcg control files of interest in current kernels:
<p>
<ul>
 <li><tt>cgroup.procs</tt> or <tt>tasks</tt>: a list of process IDs that are
  attached to this memcg.</li>
<p>
 <li><tt>memory.limit_in_bytes</tt>: the amount of memory, in bytes, that can
  be charged by processes attached to this memcg.</li>
<p>
 <li><tt>memory.usage_in_bytes</tt>: the current amount of memory, in bytes,
  that is charged by processes attached to this memcg.</li>
<p>
 <li><tt>memory.oom_control</tt>: allows processes to register
  <tt>eventfd()</tt> notifications when this memcg is out of memory and
  control whether the kernel will kill a process or not.</li>
</ul>
<p>
My patch set adds another control file to this set:
<p>
<ul>
 <li><tt>memory.oom_reserve_in_bytes</tt>: the amount of memory, in
  bytes, that can be charged by processes waiting for OOM notification.
  Keep reading to see why this is useful and necessary.
</li>
</ul>
<p>
The limit of the root memcg is infinite so that processes attached to it may
charge as much memory as possible from the kernel.
<p>
When <tt>memory.use_hierarchy</tt> is enabled, the usage, limit, and reserves
of descendant memcgs are accounted to the parent as well.  This allows a
memcg to overcommit its resources, an important aspect of memcg that we'll
talk about later.  If a memcg limits its usage to 512 MiB and has two child
memcgs with limits of 512 MiB and 256 MiB each, for example, then the group
as a whole is overcommitted.  
<p>
<h4>Memory controller out of memory handling</h4>
<p>
When the usage of a memcg reaches its limit and the kernel cannot reclaim any
memory from it or a descendant memcg, it is out of memory.  By default, the
kernel will kill the process attached to that memcg (or one of its
descendant memcgs) 
that is using the most memory.  It is possible to disable the kernel OOM
killer by doing
<p>
<pre>
    echo 1 &gt; memory.oom_control
</pre>
<p>
in the relevant control directory.  
Now, when the memcg is out of memory, any process attempting to allocate
memory will effectively deadlock unless
memory is freed.  This behavior may seem unhelpful, but that situation
changes if user space has registered for a memcg OOM
notification.  To register for a notification when a memcg is out of memory,
a process can use <tt>eventfd()</tt> in a sequence like:
<p>
<ul>
 <li>Open <tt>memory.oom_control</tt> for reading.</li>
<p>
 <li>Create a file descriptor for notification by doing
     <tt>eventfd(0, 0)</tt>.</li>
<p>
 <li>Write "<tt>&lt;fd of open()&gt;</tt>
            <tt>&lt;fd of eventfd()&gt;</tt>" to
     <tt>cgroup.event_control</tt>.</li>
</ul>
<p>
The process would then do something like:
<p>
<pre>
    uint64_t ret;
    read(&lt;fd of eventfd()&gt;, &amp;ret, sizeof(ret));
</pre>
<p>
and this <tt>read()</tt> will block until the memory controller is out of
memory.  This will only wake up the
process when it needs to react to an OOM condition, rather than requiring
it to poll the out-of-memory state. 
<p>
Unfortunately, there may not be much else that this process can do to
respond to an OOM situation.  If it has locked its 
text into memory with <tt>mlock()</tt> or <tt>mlockall()</tt>, or it is
already resident in memory, it is now aware that the memory controller is out
of memory.  It can't do much of anything else, though, because most
operations of interest require the allocation of more memory.  If this
process was a shell, for example, an attempt to run
<tt>ps</tt>, <tt>ls</tt>, or even <tt>cat tasks</tt> would stall forever
because no memory could be allocated.  That leads to an obvious question:
how is user space supposed 
to kill a process if it cannot even get a list of processes?
<p>
The goal of user-space out-of-memory handling is to transition that
responsibility to user space so users can do <i>anything</i> they want under
these conditions.  This is only possible because of memory reserves.

With my patchset, it's possible to use the new
<tt>memory.oom_reserve_in_bytes</tt> to configure an amount of memory that
the limit may be overcharged solely by processes  that
are registered for out-of-memory notifications.  If you run:
<p>
<pre>
    echo 32M &gt; memory.oom_reserve_in_bytes
</pre>
<p>
then any processes attached to this memcg that has registered for
<tt>eventfd()</tt> notifications with <tt>memory.oom_control</tt>, (including
notifications from other memcgs), may overcharge the limit
by 32MiB.  This allows user space to actually do something interesting: read
a file, check memory usage, build a list of processes attached to out of
memory memcgs, etc.  The reserve should only need to be a few megabytes at
most for these operations if the process is already locked in memory.
<p>
The user-space OOM handler does not necessarily need to kill a process.  If it
can free memory in other (usually creative) ways, no kill may be
required.  Or, it may simply want to create a record for examination later
that includes the state of the memcg's memory, process memory, or statistics
before re-enabling the kernel OOM killer with <tt>memory.oom_control</tt>.
With a reserve, writing to <tt>memory.oom_control</tt> will actually work.
<p>
The memcg remains out of memory until the user-space OOM handler frees some
memory (including the memory taken from the reserve), it re-enables the
kernel out-of-memory killer, or makes memory available by other means.
<p>
One possible "other means" would be to increase the memcg limit.  If
top-level memcgs represent individual jobs running on a machine, it's usually
advantageous to set the memcg limit for each to be less than the full
reservation for 
that job.  The kernel will aggressively try to reclaim memory and push the
memcg's usage below its limit before finally declaring it to be out of
memory as a last resort.  Then, and only then, systems software can increase
the limit of the memcg if there is memory available on the system.  Don't
worry, this job would become the first process killed if the system is out of
memory and there's a system user-space OOM handler which we'll describe next!
<p>
It's important that the out-of-memory reserve is configured appropriately for
the user-space OOM handler.  If an OOM handler is dealing with out-of-memory
conditions in other memcgs, the memcg that the OOM handler is attached to is
overcharged.  If there is more than one user-space OOM handler attached,
then <tt>memory.oom_reserve_in_bytes</tt> must be adjusted accordingly
depending on the maximum memory usage that is allocated by those handlers.
<p>
<h4>System out of memory handling</h4>
<p>
If the entire system is out of memory, then no amount of memory reserve
granted by a memcg, including the root memcg, will allow a process to
allocate more.  In
this case, it isn't the <i>charge</i> to the memcg that is failing but rather
the <i>allocation</i> from the kernel.
<p>
Handling this situation requires a different type of reserve implementation
in the kernel: an 
amount of memory set aside by the memory-management subsystem that allows
user-space 
out-of-memory handlers to allocate in system OOM conditions when nobody else
can.  A per-zone reserve is nothing new: the <tt>min_free_kbytes</tt>
sysctl knob
has existed for years; it ensures that some small amount of memory is always
free so that important allocations, such as those that are needed for reclaim
or are required by exiting processes to free their own memory, will succeed.
The user-space OOM handling reserve is simply a small subset of the
<tt>min_free_kbytes</tt> reserve for system out of memory conditions.
<p>
The reserve would be pointless, however, if the kernel out-of-memory killer
stepped in and killed something itself.  Without the patchset, the OOM killer
cannot be disabled for the entire system; the patchset makes it possible to
disable the system OOM killer just like you can disable the OOM killer for a
memcg.  This is done via the same interface, <tt>memory.oom_control</tt>, in
the root memcg.
<p>
Access to the reserve is implemented immediately before the kernel
out-of-memory killer 
is called.  We do a check with a new per-process flag,
<tt>PF_OOM_HANDLER</tt> to determine if this process is waiting on an OOM
notification.  If it is, and the process is attached to the root memcg, then
the kernel will try to allocate below the per-zone minimum watermarks.  If
the reserve is configured 
correctly, this effectively guarantees memory to be available for user space
to handle the condition.  Since the per-process flag is used in the page
allocator's
slow path, there is no performance downside to this feature: it will simply be
a conditional for all processes that aren't handling the out of memory
condition.
<p>
An important aspect of this design is that the interface for handling
system out-of-memory conditions and handling memory controller
out-of-memory conditions is  
the same.  User space should not need to have a different implementation
depending on whether it is running on a system unconstrained by memcg or
whether it's attached to a child memcg.  The user-space OOM handler
does not need to be changed in any way: if it's attached to the root
memcg, it will handle system out-of-memory conditions and if it's attached
to a descendant memcg, it will handle memcg out-of-memory conditions.
<p>
Earlier, we talked about the hierarchical nature of memcg and how it's
possible to overcommit memory in child memcgs.  This is the same at the top
level: it's possible for the sum of the memcg limits of all of the root
memcg's immediate children to exceed the amount of system memory.  In this
case, the memcg out-of-memory reserve is useless for the handling of system OOM
conditions since the the memcg has not
reached its limit, the <i>charge</i> would succeed but the <i>allocation</i>
fails first.
<p>
In configurations such as this, the system-level OOM killer may want to do
priority-based killing.  Rather than simply killing the process using the
most memory on the system, which is the heuristic used by the kernel OOM
killer, it may want to sacrifice the lowest priority process depending on
business goals or deadlines.  Top-level memcgs represent individual jobs
running on the machine each with their own limit and priority.  Given a
memory reserve, it's trivial to kill a process from within the lowest
priority memcg.  This is exactly what Google wants to do.
<p>
It is also possible to give those jobs the same type of control.
If system-level software does a <tt>chown</tt> so that memcg control fields are
configurable (except for the limit or reserve, of course) by the job attached
at the top level, then the job may create its own child memcgs and enforce
its own out-of-memory policy.  It may even overcommit its child memcgs so the
sum of their limits exceeds its own limit.  When the job's limit is reached
and the out of memory notification is sent, it may effect a policy as if it
were a system out-of-memory condition: the interface is exactly the same.  In
this way, the top-level memcgs are virtualized environments as if all system
memory was bounded by its limit.
<p>
<h4>Will it be merged?</h4>
<p>
When this idea has been proposed in the past, there has been some 
controversy as to whether the kernel really wants to start making a 
commitment to adding another memory reserve to the kernel.  Some have
suggested that it  
is a large maintenance burden to support such a feature and that the 
number of people who actually want to use it outside of Google is very 
small.  
<p>
Google depends on user-space out-of-memory handling to effect a policy 
beyond the kernel default of selecting the largest process and killing it.  
The choice is important especially when talking about one of the most 
aggressive policies you'll find in Linux: the immediate termination of a 
process that hasn't necessarily done anything wrong.  I believe that 
making something that is extremely difficult or impossible to achieve and 
empowers users to have control over such an important thing as process 
termination is worthwhile.
<p>
<h4>Future development</h4>
<p>
In the future, it will be possible to release a library that handles all of
the above implementation details behind the scenes and allows users to
implement their own <tt>HandleOOM()</tt> function.  Such a library could also
provide implementations for some of the common actions that a user-space OOM
handler may do: read the list of processes on the system or attached to an
OOM memory controller, check the memory usage of a particular process, etc.
<p>
It is also possible to replace the disabling of the OOM killer, either memcg
or system OOM killer, with an out-of-memory delay.  For example, another
memcg control file could be added to allow user space a certain amount of time
to respond and make memory available before the kernel steps in itself.  This
could be useful if the user-space OOM handler is buggy or has allocated
more than 
its reserve allows; adding a delay isn't as dangerous as disabling the
system OOM killer outright. 
<p>
This would also allow your favorite Linux distribution to ship with an out of
memory handler that could pop up a window and allow the user to select how
to proceed 
or to diagnose the issue further.  This saves your important document or
presentation that you've been working hard on by not immediately killing
something out from under you for that MP3 you just started playing.
<p>
User-space out-of-memory handling is a powerful tool that will give users
and administrators more flexibility in controlling their systems and keep
important 
processes running when they need to be.  I've described some motivations for
Google; others may use it for something completely different.  The
functionality can be used by anyone for their own needs exactly because the
power is in user space.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Out-of-memory_handling">Memory management/Out-of-memory handling</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#OOM_killer">OOM killer</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Rientjes_David">Rientjes, David</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/590960/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor591284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2014 1:33 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/591284/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting; I'd like X (and tmux) to not be the first on the chopping block when things go south :) . However, a few questions:<br>
<p>
  - What is the future of this with the new single-manager heirarchy?<br>
  - Can more than one process connect to cgroup.event_control at a time? If so, what actually happens? The first gets called? Last? Undefined? All?<br>
  - It seems to me that access to memory.oom_reserve_in_bytes should be restricted to the OOM-handling process, not user-based. How is access control done for that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor591344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Probably an OT question, but as we are talking about OOM...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2014 13:42 UTC (Fri)
                               by <b>rvfh</b> (guest, #31018)
                              [<a href="/Articles/591344/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
tl;dr but...<br>
<p>
Before killing a process, we could also stop it. If you can detect a process using a lot of memory and creating a lot of swapping, thus hanging the computer, why not stop it and ask the user what to do?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor591365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Probably an OT question, but as we are talking about OOM...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2014 15:15 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/591365/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That might deadlock the system, depending on how you intend to ask the user what to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor591379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Probably an OT question, but as we are talking about OOM...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2014 15:58 UTC (Fri)
                               by <b>rvfh</b> (guest, #31018)
                              [<a href="/Articles/591379/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Correct. But in that case you might as well kill the task you had stopped after a timeout, so you get the 'good old OOM killer' behaviour.<br>
<p>
The stop would be nice for the AFAIK most common case where some app starts thrashing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor591452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2014 23:51 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/591452/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      It's worth pointing out that OOM kill is not inevitable.  One can run a system without overcommit (I don't remember the sysfs switch to do that) and then OOM kill never happens (you get an entirely different kind of failure when memory is exhausted).  And one can run processes with rlimits and essentially eliminate innocent processes being victimized by memory hogs.

      
          <div class="CommentReplyButton">
            <form action="/Articles/591452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor591459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2014 1:33 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/591459/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
.. at the cost of not actually benefiting from a good chunk of your memory because it has to be kept reserved for processes that allocated it but never used it (remember that when you fork, each fork needs the full memory used by the process, at least long enough for one of them to hit exec)<br>
<p>
for most people, this isn't a worthwhile tradeoff.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor591850"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2014 15:24 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/591850/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Each fork needs the full memory, and for multithreaded processes you suddenly find you're using up the total memory needed for each thread's stack, even if they're almost totally empty.<br>
<p>
And you don't even avoid OOM kills for all of that, just reduce their frequency. Not worth it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591850/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor591849"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2014 15:22 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/591849/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Running a system without overcommit does not avoid the OOM killer entirely, because VM_GROWS[UP|DOWN] VMAs -- e.g. main-thread stacks -- are always allocated when needed, and when you run out of space on one, it'll probably happen at a basically random function call boundary. Not much way of returning an error from *that*: the OOM killer is the only thing that can possibly run.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591849/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor591615"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2014 23:39 UTC (Sun)
                               by <b>pixelpapst</b> (guest, #55301)
                              [<a href="/Articles/591615/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I've recently proposed a patchset to actually give a process a notification of this impending doom and the ability to do something about it.</font><br>
<p>
+1. I have always felt we needed a SIG_IMPENDINGDOOM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591615/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor592423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2014 17:07 UTC (Fri)
                               by <b>dfsmith</b> (guest, #20302)
                              [<a href="/Articles/592423/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've never understood why malloc() cannot return NULL.  Most programs would probably handle that case more daintily than they handle kill().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/592423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor592425"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2014 17:42 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/592425/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I'd expect most programs to either check for malloc() returning NULL and then call abort() when it does (IIRC, GNU documentation advocates wrapping malloc() in a wrapper that does this for you), or not check and then get killed by SIGSEGV when they try to dereference the NULL pointer they were given.
      
          <div class="CommentReplyButton">
            <form action="/Articles/592425/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor592426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2014 17:52 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/592426/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
malloc() can return NULL just fine. The problem is that it wouldn't do any good unless you disabled overcommit, which is simply too useful to disable outside of very specific workloads. (Consider the copy-on-write which is an integral part of the fork()/exec() model, the use of mmap() with MAP_PRIVATE, programs which allocate more RAM than they actually need...) The malloc() will always succeed, even if you're out of physical RAM and swap space, because it doesn't actually need any RAM until you access the page. At that point it's much too late to return NULL.<br>
<p>
I'd rather see the process block until memory becomes available, though, rather than being killed outright.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/592426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor592524"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2014 19:25 UTC (Sun)
                               by <b>helsleym</b> (guest, #92730)
                              [<a href="/Articles/592524/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think a process could block until memory becomes available. It would catch SIGBUS and use a carefully crafted signal handler to await the availability of more memory. The signal handler would need its own pre-allocated signal stack and other memory. All of that memory would need to be locked and perhaps "touched" so that it's guaranteed to always be resident. I'm sure there are other details I'm forgetting. It could be written as a simple library any application could link to and supply as its SIGBUS handler.<br>
<p>
Then, yes, the problem is getting the OOM killer to ignore those programs waiting for more memory. This is rather counter to the OOM killer's purpose however -- what happens if all/most memory-hogging programs use this approach? It would likely result in "thrashing" -- the OOM killer would ignore a (bunch of) process(es) waiting for memory, free a small amount of memory, then the allocation(s) would go through and you'd be out of memory again. Rinse and repeat.<br>
<p>
So none of that solves the general problem of OOM nor does it really make things clearly better. <br>
<p>
tl;dr: OOM is hard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/592524/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor593712"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2014 6:31 UTC (Tue)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/593712/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, OOM is hard. For example, the last time I looked at the issue, the OOM and LMK were looking at virtual address space, which may be shared among multiple tasks. Freeing up memory that's shared isn't helpful until you kill all the tasks that are sharing it. So, it's more helpful to look at the non-shared part of the virtual address space. That seemed a bit of a challenge.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/593712/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor600023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space out-of-memory handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2014 22:03 UTC (Thu)
                               by <b>modusus</b> (guest, #97183)
                              [<a href="/Articles/600023/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a small mistake<br>
Write "&lt;fd of open()&gt; &lt;fd of eventfd()&gt;" to cgroup.event_control.<br>
<p>
should be<br>
Write "&lt;fd of eventfd()&gt; &lt;fd of open()&gt;" to cgroup.event_control.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/600023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
