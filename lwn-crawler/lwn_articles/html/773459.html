        <!DOCTYPE html>
        <html lang="en">
        <head><title>Toward race-free process signaling [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/773459/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/774101/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/773459/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Toward race-free process signaling</h1>
</div>
<div class="ArticleText">
<div class="GAByline">
           <p>December 6, 2018</p>
           <p>This article was contributed by Marta Rybczyńska</p>
           </div>
<p>Signals have existed in Unix systems for years, despite the general
consensus that they are an example of a <a href="/Articles/414618/">bad
design</a>. Extensions and new ways of using signals pop up from time to
time, fixing the issues that have been found. A notable addition was the
introduction of <a
href="http://man7.org/linux/man-pages/man2/signalfd.2.html"><tt>signalfd()</tt></a>
nearly 10 years ago. Recently, the kernel developers have discussed how to avoid
race conditions related to process-ID (PID) recycling, which occurs when a
process 
terminates and another one is assigned the same PID.  A process that fails
to notice that its target has exited may try to send a signal to the wrong
recipient, with potentially grave consequences. A patch set from Christian
Brauner is trying to solve the issue by adding 
signaling via file descriptors.</p>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>PIDs increase for each new process up to the maximum value, and then go
back to the beginning. For the maximum value, most distributions use the
conservative value of 32768 to avoid breaking legacy systems. However,
users can consult and change the maximum value in
<tt>/proc/sys/kernel/pid_max</tt>. Signal-related APIs identify processes
by PID. The disadvantage of this method is that, in the lifetime of a
system, the same PID is reused as processes are created and terminated. What
happens if a process has finished and another one has taken its PID? The
PID value stays valid. Other processes, unaware of the situation, may try
to send signals to the wrong process. This may have
consequences as serious as terminating the wrong service. This
race condition requires the PID space to wrap  between the creation of
the two processes, which is not uncommon.</p>

<h4><tt>/proc/<i>pid</i>/kill</tt> proposal</h4>

<p>The recent discussion started when Daniel Colascione <a
href="/ml/linux-kernel/20181029221037.87724-1-dancol@google.com/">proposed
adding a file called <tt>kill</tt></a> to each process's <tt>/proc</tt>
directory. Writing the numerical value of the desired signal to
that file would send that signal to the selected process. The race was solved —
or attempted to be solved — by holding the <tt>/proc</tt> directory open,
thus preventing the PID from being reused at the wrong time. The <a
href="/ml/linux-kernel/20181030104037.73t5uz3piywxwmye@gmail.com/">discussion
showed</a> that other developers were considering the same problem in
parallel.</p>

<p>While the problem was well understood, a debate started about
the implementation. One part of the discussion concerned whether opening
the 
<tt>/proc</tt> directory is enough to prevent PID reuse, in which case the patch
would not have not been necessary in the first place. A small test case was
developed and 
showed that <a href="/ml/linux-kernel/CAKOZueuBdY_b=CVk29pzn0NAt9sJtzr6yqx9Y00WCppCm1JFWQ@mail.gmail.com/">the
answer is no</a>. A modification in the kernel, like the proposed patch, is
needed to solve the issue.</p>

<p>A heated debate followed on a proper API to deliver the signal: should it be
a write to the file or another system call?  Jann Horn <a
href="/ml/linux-kernel/CAG48ez01OWYVqEo+Qf65scG7a-48tDM4Gh3BOUKY+-b9g+9itw@mail.gmail.com/">suggested
an <tt>ioctl()</tt></a>, <a
href="/ml/linux-kernel/20181031181717.GD2180@cisco/">followed</a>
by Tycho Andersen, who agreed that this would simplify the permission checks.
Colascione replied by supporting the choice of using <tt>write()</tt> and stated
that it is unsafe to <a href="/ml/linux-kernel/CAKOZuetdSK8jhD1snja8p4AQTNPrLOugQrVn642RCH8S4QBGFg@mail.gmail.com/">call
<tt>ioctl()</tt> on an unknown descriptor</a>. In case of a mistake, we
do not know what the effect of a random operation will be (this is,
however, similar when writing to an unknown file). His other option was
adding a new system call.</p>

<p>Another part of the debate was started by Aleksa Sarai who <a
href="/ml/linux-kernel/20181030050012.u43lcvydy6nom3ul@yavin/">added
namespaces</a> to the mix: there is a risk of processes sending
signals between PID namespaces in situations when they normally do not have
that ability. He suggested that only processes from the same PID namespace
should be able to send such signals.</p>

<p>In the same thread, Brauner mentioned that he is working on a <a
href="/ml/linux-kernel/20181030103910.mnzot3zcoh6j7did@gmail.com/">similar
solution</a> and proposed postponing the patch review to after the
discussion at Linux Plumbers Conference that was then two weeks away.
Colascione and other developers were interested to know more. Colascione
also <a href="/ml/linux-kernel/CAKOZuesuj6HyX-Y6J7wJ73PB_EuoKc2OB68nYzWY-08i+M+z-g@mail.gmail.com/">added
some context to the discussion</a> by noting that there had been previous,
but unsuccessful, attempts to solve this problem.
There are two options to fix the issue and keep the interface race-free:
either keep a PID reserved when the handle is open, or keep
a reference to the <tt>struct pid</tt> instead of the PID value.</p>

<h4>Signaling by <tt>/proc/<i>pid</i></tt></h4>

<p>After LPC, Brauner <a
href="/ml/linux-kernel/20181119103241.5229-1-christian@brauner.io/">submitted
a new patch set</a>. It proposes to solve the signal delivery issue
by using file descriptors to identify processes; these descriptors would be
obtained by 
opening a process's <tt>/proc</tt> directory.
The solution Brauner proposed is to store a handle to the
process's <tt>struct pid</tt> in the inode associated with that descriptor;
this gives a stable handle that does not have 
the disadvantages of the simple PID number. It turned out that the patch
could be simplified; Eric W. Biederman <a href="/ml/linux-kernel/87o9ak28nl.fsf@xmission.com/">explained</a>
that the handle is already present in the inode reference and
<tt>proc_pid()</tt> is enough to get the handle from a file descriptor.</p>

<p>While the first part of the patch deals with getting the handle, the
second part of the patch set implements sending the signal itself; it is
done using a new system call named <tt>procfd_signal()</tt>. This system call
operates on a file descriptor of a process; the previous discussions 
convinced Brauner that this is a solution preferred over an
<tt>ioctl()</tt>. The new system call has the following prototype:</p>
<pre>
    long procfd_signal(int fd, int sig, siginfo_t *info, int flags);
</pre>

<p>It sends the signal <tt>sig</tt> to the process identified by the file
descriptor <tt>fd</tt>. The optional <tt>info</tt> argument is a pointer to
<tt>siginfo_t</tt> provided by the caller (used when sending realtime
signals), and <tt>flags</tt> is reserved 
for future use and should be zero. On success, the system call returns
zero; in
case of an error it returns -1 and <tt>errno</tt> is set to the
detailed error code: <tt>EBADF</tt> if the given file descriptor is not
valid, <tt>EINVAL</tt> if the signal value is invalid or the file
descriptor does not refer to a process, <tt>EPERM</tt> if the caller does
not have sufficient permissions to send a signal to the target, and
<tt>ESRCH</tt> if the target process does not exist.</p>

<p>The submission caused discussions of both the implementation and the use
of signaling via file descriptors. While there has been no direct
opposition, the developers noted a number of issues that should be taken
into account. Sarai <a
href="/ml/linux-kernel/20181119202857.k5zw742xjfrw677j@yavin/">started 
a discussion about sending signals to other namespaces</a>. As a result, a
check has been added so that sending signals is possible only to processes
in child PID
namespaces. This avoids problems when file descriptors leak
between namespaces, for example when the root file system is bind-mounted into a
container. Adding the possibility to send signals to ancestors <a
href="/ml/linux-kernel/20181121213946.GA10795@mail.hallyn.com/">can
be always added in the future</a>.</p>

<p>The debate on which system call to use restarted with Andersen <a
href="/ml/linux-kernel/20181119223954.GA4992@cisco/">again
preferring an <tt>ioctl()</tt> interface</a>. Colascione and Brauner
argued instead
for a new system call. This kind of debate happens quite often in the kernel
community. Some developers prefer adding a new <tt>ioctl()</tt>, because
they think that adding a system call is too complex. On the other hand,
<tt>ioctl()</tt> is considered a worse API. Andy Lutomirski added a twist
to the debate and <a href="/ml/linux-kernel/CALCETrWyuQvTtksN1J1XbCFPka_rLOaFqa5W==EvGQvoaf9f3Q@mail.gmail.com/">proposed
a better version of the <tt>ioctl()</tt> system call</a>. The
discussion finished without a clear conclusion.</p>

<p>An example of how to use the mechanism has been posted
in the cover letter. It is simple: the programs opens the right
<tt>/proc/<i>pid</i></tt> directory and then sends the signal with all
parameters.</p>

<p>The <a
href="/ml/linux-kernel/20181120105124.14733-1-christian@brauner.io/">second
version</a> of the submission included both 32 and 64-bit versions of the
system call with two different entry points. Lutomirski <a
href="/ml/linux-kernel/CALCETrWnQNMQcCmFZrftVVYgAMW6DT3gyxvVb_v9_enUCUkHiw@mail.gmail.com/">objected</a>,
explaining that this design should be avoided for new system calls. The two
versions are necessary due to the differing definition of <tt>struct
siginfo_t</tt>.  An easy way to avoid creating multiple entry points was
eventually found, and the patch set was reposted as <a
href="/ml/linux-kernel/20181206121858.12215-1-christian@brauner.io/"><tt>taskfd_send_signal()</tt></a>
with the same argument types.

<p>The submission tries to fix a problem that has been experienced by multiple
people and the developers seem motivated to have the work done. The
solution goes in the direction of following the long-established
convention of using file descriptors. There is no conclusion yet if
this approach will be accepted &mdash; probably more iterations will 
still be needed. However, it seems likely that we will get an improvement in
the robustness of signal usage in the not-that-far future.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#pidfd">pidfd</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls-pidfd_send_signal">System calls/pidfd_send_signal()</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Rybczynska_Marta">Rybczynska, Marta</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/773459/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor774123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 19:26 UTC (Thu)
                               by <b>daniele.nicolodi</b> (subscriber, #94121)
                              [<a href="/Articles/774123/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I may be missing something but I don't see how this solves all race conditions. Unless a mechanism is introduced to fork a process and return a file handle pointing at /proc/pid there still is a race between the time fork() returns and /proc/pid is opened.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 19:58 UTC (Thu)
                               by <b>jspenguin</b> (guest, #120333)
                              [<a href="/Articles/774127/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There has never been an issue with a parent sending a signal to a direct child process. PIDs are never recycled until the parent process calls wait() or exits. This mechanism would only be necessary for processes sending signals to other processes that are not direct child processes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:07 UTC (Thu)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/774129/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a race here nevertheless: The pid of a process one wants to send a signal to can only be known at some time x + n, x being the time when fork returned and n the delay until the pid was communicated to the process desiring to use it. There's no way this process can determine if the pid is still used by the other process it wanted to send a signal to by the time it tries to use it, be it roundabout via proc or directly via kill.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:11 UTC (Thu)
                               by <b>nopsled</b> (guest, #129072)
                              [<a href="/Articles/774132/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think there are plans to introduce a new variant of clone that has CLONE_NEW or so as an additional flag that returns a process descriptor (since clone has already run out of flags).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:28 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774135/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The next clone, instead of just having a bigger flag parameter, really should, instead, look something like this:<br>
<p>
#define CLONE2_SHARE_VM (1&lt;&lt;0) /* VALUE is a bool: default to true */<br>
#define CLONE2_OUTPUT_FD /* VALUE is an int*: on success, clone2 writes a procfd FD */<br>
... <br>
<p>
struct clone2_parameter {<br>
  void* value; /* In, in-out, or out depending on NAME */<br>
  int name; /* CLONE2_XXX; after the pointer for 32-bit ABI compat crap */<br>
};<br>
<p>
/* Make a new task (process or thread). The new process's properties are mumble.<br>
clone2_parameters override these defaults. If multiple clone2 parameter structures<br>
have the same NAME, the last one wins. Return child PID on success; on failure, -1 with errno set. */<br>
int clone2(const struct clone2_parameter* parameters, int nparameters);<br>
<p>
This way, we can create an interface as rich as we want, in an extensible way, without ever again having to make a new god damn process creation system call. It'd also let us implement a posix_spawn directly, without vfork.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 5:51 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774321/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've been working on a deep dive into the history of process management on UNIX, and noticed all these kernel implementations of posix_spawn() popping up (NetBSD, OS X, Solaris). While their rationale is solid (avoiding huge pointless serializing VM copies), directly implementing posix_spawn() looks like a potential mistake, due to the perpetual incompleteness of that interface.<br>
<p>
This led to thoughts about a compromise, and a potentially reasonable answer: something like a combined fork+exec, where the VM is not preserved and inherited FDs are explicitly specified. The target of the exec is a helper binary to implement the desired post-fork behavior. Configuration of the helper would be done e.g. over a pipe or a memfd.<br>
<p>
If a new clone() variant is under discussion as described here, another option might be to address the VM problem by allowing the variant to specify memory regions preserved in the child. posix_spawn() only requires access to existing file descriptors and say, one page describing the new child configuration.<br>
<p>
The point of both options is to keep that huge inflexible interface in userspace, and some system call that still provides all the performance benefit, for applications where posix_spawn() doesn't go far enough (e.g. changing security credentials or similar)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 5:55 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774322/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Forgot to mention, the biggest motivation for a userspace spawn may be the sheer size of an equivalent kernel implementation ;) <a href="https://github.com/SilkieDragon/xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/bsd/kern/kern_exec.c#L2205-L3207">https://github.com/SilkieDragon/xnu/blob/0a798f6738bc1db0...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor774325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 6:00 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/774325/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought that one of the better ideas is to make all the relevant process-management functionality to accept an explicit process file descriptors. And then the final piece - ability to create a process in a "suspended" state.<br>
<p>
Intermediary executables are just a crutch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 6:15 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774326/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The trouble is that there is an almost unlimited set of fork() use cases that can't be addressed by posix_spawn(), and no sensible finite set of APIs can ever fully describe what was already possible post-fork. As a contrived example, creating a connected UNIX client socket attached to the new process stdio, where peercred accurately reflects the connecting process is the new process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 9:03 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/774341/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As a contrived example, creating a connected UNIX client socket attached to the new process stdio, where peercred accurately reflects the connecting process is the new process.</font><br>
You still will be able to dup() sockets into the new process. I'm not sure how you would forge the peercred, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 15:38 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774355/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The question is not whether one contrived example has an incomplete solution in the proposed scheme, but whether even a reasonable subset of use cases could be catered for even when approaching something like 100% churn in the interface, implementation, locking requirements and security model for almost all existing system calls, without forcing users to resort to e.g. vfork or debugging APIs (which they may lack privilege to use) to fill the remaining gaps.

<p>
We don't need to answer it for ourselves, Windows had process handles since prehistory, where you find <a href="https://opcode0x90.wordpress.com/2011/01/15/injecting-dll-into-process-on-load/">endless hacks like this</a> to cope with their process creation API remaining incomplete after almost 30 years.
      
          <div class="CommentReplyButton">
            <form action="/Articles/774355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor774133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:13 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774133/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And that's why we'll eventually need a variant of clone(2) that returns a file descriptor. That's out of scope for the present patch, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:47 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/774141/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wrote CLONE_FD a while ago; if anyone wants to pick it up and run with it, the only open remaining from the discussion at the time was that people wanted a more detailed ptrace test suite to make sure nothing in the intricate interaction between ptrace, reparenting, and child processes broke.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774370"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2018 1:01 UTC (Sun)
                               by <b>brauner</b> (subscriber, #109349)
                              [<a href="/Articles/774370/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fwiw, if this patch lands I intend to pick yours up and would very much like your input.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774370/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2018 12:50 UTC (Sun)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/774389/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great! Happy to help.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor774131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:15 UTC (Thu)
                               by <b>jspenguin</b> (guest, #120333)
                              [<a href="/Articles/774131/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But with fork, there's no race condition, because the process doing the signaling is the direct parent.  Even if the forked child exits immediately, before fork even returns in the parent, the process will remain in the table as a zombie. As long as the parent process signals the child before calling wait, it is impossible for that pid to refer to any other process. Signaling a zombie has no effect, even SIGKILL.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774139"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:42 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774139/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's still a race, even with direct children, when multiple components in a process don't coordinate with each other and each want to run child processes for their own purpose. For example, the Java VM basically has a constant waitpid(-1) running; if some shared library in that process makes a subprocess, and that subprocess dies, then Java's waitpid might reap it before the shared library does, making the shared library's process manipulation malfunction in various exciting ways.<br>
<p>
One of my long-term goals is to make it possible for unrelated components that happen to share a process to easily manage their own sets of children.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774139/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 21:01 UTC (Thu)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/774144/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In principle, this can be solved with an intermediate process acting as relay for "a component" desiring to run controlled processes in face of a 'hostile' VM interfering with that: It would create and destroy more processes on behalf on "the component" and would escape the VM-autoreaper by not terminating.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 20:55 UTC (Fri)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/774290/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OTOH, this ("unrelated components sharing a process") is pretty much a travesty: As these components share an address space, they are related, regardless if they want this or not, and have to cooperate with each other. If they're really unrelated, they ought to run in different processes.<br>
<p>
There's little point in coding against basic system design choices like this one (just because other systems are or were based on different design choices).<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 21:46 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774364/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's perfectly reasonable for a process to host components that are developed separately and that aren't aware of each other. That ship sailed a long time ago.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 22:42 UTC (Sat)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/774365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Today, the best way to wait on N child processes in that kind of environment is to spawn N threads, each of which calls waitpid(). At least with a clone2-returning-a-process-FD you can reduce that to a single, race-free poll().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor774390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2018 13:20 UTC (Sun)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/774390/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"It's commonly done" is not the same as "it's perfectly reasonable". That's what I already wrote: The "hosted components" are not separate and have to be aware of each other if they're running in a shared address space/ single process. In the given context, a process can manage its children which includes reliably signalling them but multiple "components" sharing a process can't separate "their children" from each other. If this has to be done, a number of (possibly cooperating) processes have to be used. A process is the fundamental system abstraction for separating independently executing entities from each other. Hence, if such separation is desired, it's sensible to use processes for that.<br>
<p>
One could argue backwards and forwards here whether or not this design choice is or was sensible but "that ship sailed a long time ago" and it's better to put the available facilities to (some) good use than to keep fighting them. Instead of bemoaning fork (an undercurrent in this conversation), one can try to find uses for it (and there are plenty -- I use fork much more often than exec).<br>
<p>
Eg, some program I have been writing in the past (idea more recently reused in a different context) had to do "HTTP requests" to interact with some set of servers. In the 'modern' internet, where TCP connections can suddenly turn into black holes for all kinds of weird reasons (aka random "session timeouts" enforced by firewalls), this obviously needs some sort of timeout. An extremely simple way to implement this reliably is to fork a process tasked with doing the HTTP interaction synchronously (easily possible because the forked process runs a copy of the forking program) and let the parent enforce the timeout. Or use alarm to arrange for a SIGALRM to be delived to the forked process after some time. The parent can then just wait until the child terminated, determine its fate via exit status and possibly retry the request.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor774233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 14:27 UTC (Fri)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774233/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One of my long-term goals is to make it possible for unrelated components that happen to share a process to easily manage their own sets of children.</font><br>
<p>
Something like the windows Job API? <a href="https://docs.microsoft.com/en-us/windows/desktop/procthread/job-objects">https://docs.microsoft.com/en-us/windows/desktop/procthre...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor774140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:45 UTC (Thu)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/774140/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's obviously correct but there's no need for a new mechanism to send signals in this case, either. The parent can just use kill.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor774124"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 19:49 UTC (Thu)
                               by <b>nopsled</b> (guest, #129072)
                              [<a href="/Articles/774124/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hm, Daniel Colascione's approach as I understand it was to preserve the PID and *prevent* reuse, but anyway, the new approach seems fine to me. Except one thing.<br>
<p>
Why does taskfd_send_signal() have to do permission checks like kill does? Isn't that very much NOT how Unix works, that is, shouldn't they be done once at open() time and not when sending signals? I can, for instance, drop privileges after getting a process handle and still send signals as if I had the same privileges back then, or pass it to some other process (think of scenarios where service managers delegate killing to a different supervisor for some unit, which has its own specialized needs).<br>
<p>
The patchset even describes it being in the same vein as the write() system call, in a loose sense:<br>
<p>
<font class="QuotedText">&gt; Signaling processes through taskfds is the equivalent of writing to a file.</font><br>
<p>
I can already see why, privilege elevation (and the curse i.e. setuid), but, it is then appropriate to invalidate the file descriptor completely for anyone but root. That should not stop userspace from having coherent and proper semantics, that do not drift away from the general pattern followed elsewhere in the kernel.<br>
<p>
FreeBSD already committed this same mistake in their pdkill interface. I hope it is not repeated here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774124/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:19 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774134/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See <a href="https://lore.kernel.org/lkml/CAKOZuetfqvn1uVqKJ=16iEzG4g449YOjC_tLM60eKBSkv9u+bQ@mail.gmail.com/">https://lore.kernel.org/lkml/CAKOZuetfqvn1uVqKJ=16iEzG4g4...</a><br>
<p>
The short version: ordinarily, I'd agree with you, but processes are weird. They can change their credentials (and thus signal-ability) over their lifetimes without changing their identity. IMHO, this is a fundamental misdesign in the Unix process model, but we're stuck with it now. Consequently, we need to separate objects that refer to process *identity* from objects that give object-holders the capability to act on processes, and invalidate the latter on process credential change. <br>
<p>
In the message above, I described how one would go about implementing this sort of interface. It would *work*, but from a pragmatic perspective, I don't see a need for this open-based capability check infrastructure, so I favor a simple direct system call instead. This capability FD approach could be implemented in the future as an extension to the current API. We're having a hard enough time getting this relatively small patch into the tree. I don't want to complicate it further.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:48 UTC (Thu)
                               by <b>nopsled</b> (guest, #129072)
                              [<a href="/Articles/774137/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Consequently, we need to separate objects that refer to process *identity* from objects that give object-holders the capability to act on processes, and invalidate the latter on process credential change.</font><br>
<p>
I do agree, but it appears to me that the wrong step has been taken already, and the case of extending this particular process descriptor API to a capability based model is already very weak. It would be better if this handle was not obtained through /proc/PID (because a process handle now means many things as far as capabilities one can exercise over it, and now needs another layer on top through flags in yet another system call(s) to further granularise access to what it offers), but something like /proc/PID/kill, so it only represents the capability to be able to send signals. <br>
<p>
My 2 cents: How this API and anything else on top shapes (there is more stuff planned for inclusion, from what I gather) will very much depend on what the notion of this process handle represents, and if nothing like what we're talking of is in the minds of people pushing for this change, I find it difficult to understand if it will ever happen. If anything, system calls need very good reasons to get included (we already have too many), and if the current API proves to be good enough for the immediate use cases people have, it would never happen, really.<br>
<p>
It is also worthwhile to note where the inspiration for process descriptors (FreeBSD's pdfork and friends), the original CLONE_FD patchset (porting it from David Drysdale's Capsicum for Linux patchset), and others, actually comes from (Capsicum), and why I am emphasizing to treat them as capabilities (and why I called FreeBSD's pdkill a mistake).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:58 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774143/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perfect is the enemy of the good. I really don't want a good and useful feature to get bogged down in unrelated discussions of capsicum and various BSD APIs. What you're proposing can be added in the future and has no immediate use case, so adding it at this point would just endanger the whole feature.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor774160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 22:05 UTC (Thu)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/774160/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suggested roughly what you’re suggesting, and it got shot down. The problem is that a capability to manipulate a process that survives execve is problematic without NO_NEW_PRIVS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 22:37 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774161/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can you elaborate? It's not immediately clear to me how NO_NEW_PRIVS matters.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor775005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2018 20:09 UTC (Sat)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/775005/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I presume the idea is that I fork and get a kill fd.  Then I execve a suid executable and now I can send signals to a root process, unless something were done to prevent the suid bit from having effect, or that would invalidate my kill fd.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/775005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor774146"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Re: FreeBSD already committed this same mistake in their pdkill interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 21:01 UTC (Thu)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/774146/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can you elaborate on what you think the mistake is?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774146/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor774151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 21:29 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774151/">Link</a>] (40 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So pardon my ignorant question but...<br>
<p>
Why can't an extra UUID be added to all processes, and a new kill_with_uuid(PID, UUID) syscall handle disambiguation?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 21:35 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/774152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
UUIDs are ugly<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor774155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 21:57 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774155/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
After reading the article more, the questions are:<br>
<p>
1) Should the process uniqueness token be "internal" (a file descriptor that must never be closed/lost) or "external" (some opaque string/uuid that can be used by any program, like a pid is)<br>
2) Should the kernel or userspace generate it, and how/when.<br>
<p>
Typically if I start a transaction I care about, I assign my own client-generated uniqueness/idemptotency token and send that to the server.  So that would loosely translate into<br>
<p>
child_token = generate_my_uniquess_token_string()<br>
child_pid = fork_with_token(..., child_token)<br>
...<br>
kill(child_pid, child_token)<br>
<p>
And there are no races.  Assume that any UID is responsible for not colliding its own child_token strings with itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 22:07 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774159/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a further thought experiment - this reminds me of when AWS finally added the ability to set resource tags when you create EC2 instances.  Previously, there was a race - you'd create instances first, get their ids, then tag them.  Bad.   Now you can just pass the tag(s) you want into the RunInstances call.<br>
<p>
So is that the goal?  Letting a unix user tag their child processes safely, so they can identify them later?  Seems very useful, and should be orthogonal to "security" issues.<br>
And to be clear, you can first generate that tag and write it to disk, and then create the child process.  So even if you crash, your child can be cleaned up safely by some other monitoring process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 23:52 UTC (Thu)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774164/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
After reading your comment it's hard to take the other proposals seriously, they're ridiculously over-engineered. A kill2() that accepted an opaque, randomly generated per-process cookie stashed in the task structure that could be extracted somehow would be vastly simpler for implement and for users to understand.<br>
<p>
Of course, having a 'process file descriptor' is overall much more generic, and perhaps those designs have aspirations for extending the functionality later, but this does not seem worth probably yet another 8kb of .text, possibly only in the name of being 'UNIXey'<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 7:42 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/774199/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So you are saying that we supplement the current process id (limited to 32767) with a 64-bit or 128-bit value that is unique for the lifetime of the system (until a reboot)?<br>
<p>
Then all the existing system calls taking a process id get a ‘2’ version taking the longpid instead. All other semantics stay the same. <br>
<p>
That does seem a much better way to address the issue (and perhaps others besides, eg pid namespaces for containers would no longer be necessary once user space migrates to the new API). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774202"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 8:20 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/774202/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This won't work. Or more precisely, it'll have all the same drawbacks.<br>
<p>
Consider the current use-case:<br>
- list processes<br>
- get process pid<br>
- kill process by pid<br>
<p>
The new use-case will be:<br>
- list processes<br>
- get process pid<br>
- get long pid by pid<br>
- kill process by long pid<br>
<p>
The race condition is still there. You'll need to fix all the APIs to use long pids in the first place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774202/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 9:02 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/774215/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, every system call will need a version that returns a long pid. So the new fork() will return the long pid directly, and so on. There is no need for a separate and race-prone lookup from short pid to long pid (which is not a 1-1 mapping anyway). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774216"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 9:05 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/774216/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But at this point it makes sense to just use file descriptors instead of long pids. File descriptors are way better for many reasons - they can be securely sent over Unix sockets, they can be inherited by subprocesses and so on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774216/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 11:22 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/774222/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess the only thing you can't do with a file descriptor is type it in on the command line.  So shell scripts, etc, would still be prone to race conditions.<br>
<p>
(A numeric 64-bit pid can be sent over sockets and told to a subprocess, of course.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 14:01 UTC (Fri)
                               by <b>ebiederm</b> (subscriber, #35028)
                              [<a href="/Articles/774230/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A 64bit pid is long enough you can't reliably type it on the command line, even 32bits are a problem.<br>
<p>
This is part of the reason why pids which have a 32bit type are limited to 16bits by default.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 17:18 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/774279/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
These days, that's the only reason to do this. People not running 10-year-old code are unlikely to be affected by &gt;16-bit PIDs.<br>
<p>
I habitually set maxpid to 99999. Anything unlikely to run &gt;1000 processes, like Raspberry Pis, get 9999.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 17:53 UTC (Fri)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/774284/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the bigger maxpid, the better – safer.  Short pids encourage manual typing, which is error-prone. Big pids kinda forces copy-pasting, which is safer (modulo pid reuse).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor774286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 19:46 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/774286/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry for being unclear. I didn’t mean literally typing in the number (I would cut and paste anyway). I was illustrating the general point that a process id is just a number, with no special magic, and can be handled by any programming language including shell scripts. It can be saved to a file, passed on the command line, even sent over TCP/IP if necessary.<br>
<p>
Existing code which works with 15-bit process ids could normally work on 64-bit ones with no change, or at most a change of type from int to long in strongly typed languages. File descriptors are great, but they form their own closed world and need a new set of APIs. They cannot just be treated as an opaque number or a string of text. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor787558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2019 3:02 UTC (Mon)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/787558/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In many cases, /proc/self/fd/... is a neat way to "type an fd on the command-line".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/787558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor787572"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2019 12:22 UTC (Mon)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/787572/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your favorite shell's autocomplete mechanism should be able to understand PIDs too.<br>
<p>
It's still somewhat dangerous to actually use that, though. The probability that mistyping the first four digits and pressing TAB gives you an entirely unrelated process shouldn't be underestimated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/787572/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor774237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 16:03 UTC (Fri)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774237/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding is that this is an attempt to fix an edge case in code that does not keep track of its own children correctly. The problem is one of:<br>
<p>
1) Child exits, crap parent kills unrelated process because it wasn't paying attention<br>
2) /etc/init.d/postfox stop, crap init script kills unrelated process due to stale PID file.<br>
<p>
No solution presented thus far actually solves case 1), the old API will continue to exist in perpetuity, and any new API will always only see limited uptake, due to portability or simple lack of effort to port everything over. There is a limit to the value in any solution, because it is unlikely to see revolutionary uptake. A simple solution therefore seems preferable.<br>
<p>
The file descriptor solution does not meaningfully solve case 2), there is still a race for the init script to open /proc/blah/pid and somehow introspect the descriptor it received matches the daemon it is trying to kill, so some "is this really the process I want?" code is still necessary.<br>
<p>
The FD solution creates a world of security pain that doesn't match the typical UNIX files model, because the kernel object in question can change its security identity over time.<br>
<p>
The cookie-based solution does not entail updating every single API, the original problem is only about signal delivery, and thus only effects kill() and possibly clone().<br>
<p>
A cookie-based solution allows the identifier persist on disk easily. Consider two new system calls:<br>
<p>
- pid_to_handle(pid_t pid, struct pid_handle *handle) -- accepts pid==0 or pid==child pid. In the 0 case, PID of current process returned. In remaining case, return -1 if PID is not a child of the current process.<br>
<p>
- kill_by_handle(pid_t, struct pid_handle *); -- works identically to kill(), except handle must match. No other restriction placed on caller.<br>
<p>
After calling clone(), pid_to_handle() is used by the parent prior to waitpid() to retrieve the handle. For daemonizing processes, it must be the child invoking it on itself as any handle the parent could receive would be for the intermediary daemonizing process that almost immediately died.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 17:30 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/774281/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A cookie-based solution allows the identifier persist on disk easily.</font><br>
<p>
A pid-plus-verifiable-identifier approach solves this problem just as well.<br>
<p>
<font class="QuotedText">&gt; /etc/init.d/postfox stop, crap init script kills unrelated process due to stale PID file.</font><br>
<p>
This is why sane init systems tend to not use PID files.<br>
<p>
<font class="QuotedText">&gt; After calling clone(), pid_to_handle() is used by the parent prior to waitpid() to retrieve the handle.</font><br>
<p>
This entails a race. You should not be required to assume that your thread is the only one calling waitpid(-1). clone2() needs to return the handle atomically.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 17:37 UTC (Fri)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This entails a race. You should not be required to assume that your thread is the only one calling waitpid(-1). clone2() needs to return the handle atomically.</font><br>
<p>
That's a fair point, but multi-threaded software with competing threads calling waitpid(-1) are no less buggy IMHO than those with competing threads say, closing random file descriptors, or creating new ones without CLOEXEC -- the problem is simply moved. It's just one of many single-thread-centric interfaces an MT app must give up. And particularly, it is a class of problem that is not fixed by modifying clone() -- an MT app exhibiting this behaviour has bigger problems than race-free child signalling<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor774308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 2:12 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/774308/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt;  /etc/init.d/postfox stop, crap init script kills unrelated process due to stale PID file.</font><br>
&gt;<br>
<font class="QuotedText">&gt; This is why sane init systems tend to not use PID files.</font><br>
<p>
If the service takes a POSIX lock on the PID file (rather than writing it out), the PID can be queried atomically. You can't *use* it atomically, but that's because the only way to atomically send a signal to an individual process is if you're the parent and aren't using SA_NOCLDWAIT.<br>
<p>
If the child disassociates from the service manager then you either need to rely on process groups or cgroups. While process groups are atomic (a beneficial inheritance from legacy TTY and batch job management), the cgroups approach still involves reading PIDs from a file, which has the same TOCTTOU race.<br>
<p>
Basically, on Linux I think it's still impossible to write a service manager that isn't susceptible to the classic PID file race while also being able to accurately signal individual wayward processes. (And to be fair, I don't think it's possible on any other Unix-like system, at least not using published and supported interfaces.) You could use cgroups and PID namespaces to minimize collateral damage, but it's still fundamentally a hack. You could use a seccomp policy to prevent disassociation from the process group, but you still couldn't target *individual* processes in the group.<br>
<p>
To safely signal individual processes there's really no substitute for process descriptors. A larger PID namespace that doesn't recycle PIDs isn't any better, even as an expediency. In both cases you still need to add a bevy of new syscalls and additional bookkeeping in the kernel. While PIDs may seem easier to use from the shell, the shell is perfectly capable of juggling and passing around descriptors (e.g. exec 8&lt;/proc/PID). The necessary bookkeeping in the kernel isn't less for wider PIDs because, like with the shell, all the infrastructure for descriptors exists and is easily applied. The benefit of descriptors, however, is that it gives processes a handle to query process state, like exit status, as well as a channel for reliable delivery of lifetime events (e.g. fork) so that a service manager could manage process trees in a straight-forward, race-free manner. That may not happen immediately, but if you're going to add new syscalls, why pick the dead-end solution?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 2:41 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/774312/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Basically, on Linux I think it's still impossible to write a service manager that isn't susceptible to the classic PID file race while also being able to accurately signal individual wayward processes.</font><br>
You can do that with cgroups, but it does require some trickery:<br>
- Put a process in cgroup.<br>
- SIGSTOP it.<br>
- Inspect the cgroup to make sure the process is still the correct one.<br>
- Send the signal.<br>
- SIGCONT it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 2:43 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/774313/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you're willing to risk sending SIGSTOP to a random process, as done here, there is no value to cgroups or indeed any API change whatsoever.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor774337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 8:39 UTC (Sat)
                               by <b>nopsled</b> (guest, #129072)
                              [<a href="/Articles/774337/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No need to SIGSTOP or anything else, just use the freezer (which is coming for v2, patches have already been posted).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 9:02 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/774340/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The last time I tried that (3-4 years ago) it resulted in unrecoverable system lockups. So I kinda hesitate to recommend it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor774309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 1:59 UTC (Sat)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/774309/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you just want to track and kill your children processes, FreeBSD's pdfork() and pdkill() do exactly that.  The handle is an opaque unique integer (i.e., a file descriptor).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2018 19:22 UTC (Sun)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/774409/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The handle is an opaque unique integer (i.e., a file descriptor).</font><br>
<p>
File descriptors are only integers within the context of a single process; the integer is meaningless without the process's descriptor table. For tracking one's own child processes that works OK, but it makes it difficult to save the identifier to a file or send it to an unrelated process, which are both desirable use cases.<br>
<p>
Personally, I like the suggestion to switch to monotonically increasing 64-bit process IDs, but with the constraint that at any time the least significant 32 bits of any new process ID must be unique and range from 1 to pid_max. Just skip any PIDs which overlap or would be out of range. Make the 64-bit PIDs start at 2**32 so that they can be distinguished from traditional PIDs, and have system calls accept both the full 64-bit PID or just the least significant 32 bits. The effect would be that you can still refer to processes exactly as you do now, or in a race-free way using larger integer IDs, using the same system calls. (This is basically a cross between "don't reuse PIDs" and "tag processes with GUIDs as well as traditional PIDs").<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774511"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2018 21:25 UTC (Mon)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/774511/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; File descriptors are only integers within the context of a single process;</font><br>
<p>
Maybe you meant "unique" rather than "integers?"<br>
<p>
<font class="QuotedText">&gt; it makes it difficult to save the identifier to a file or send it to an unrelated process</font><br>
<p>
Huh?  E.g., <a href="http://poincare.matf.bg.ac.rs/~ivana/courses/ps/sistemi_knjige/pomocno/apue/APUE/0201433079/ch17lev1sec4.html#ch17lev2sec6">http://poincare.matf.bg.ac.rs/~ivana/courses/ps/sistemi_k...</a><br>
<p>
<font class="QuotedText">&gt; Personally, I like the suggestion to switch to monotonically increasing 64-bit process IDs, but with the constraint that at any time the least significant 32 bits of any new process ID must be unique and range from 1 to pid_max. </font><br>
<p>
Yeah, that is a pretty good proposal given the constraints Linux faces around not breaking the kernel ABI at all for any binary that exists today.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774511/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2018 4:30 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/774664/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; File descriptors are only integers within the context of a single process;</font><br>
<font class="QuotedText">&gt; Maybe you meant "unique" rather than "integers?"</font><br>
<p>
That would also work, but no, I meant "integers". I suppose some would say that the file descriptor *is* the integer, and representationally that's often true, but to me the term refers conceptually to an active entry in the file descriptor table (a particular file/pipe/socket/device, set of flags, position, etc.), and the integer is just the index into the table. (Consequently, all file descriptors have unique integer identifiers within a process, but not all integers are file descriptors.) A process only has one descriptor table, so there is an isomorphism between the process's file descriptor table entries and their integer indices. Outside the process, however, you need some other way to identify the state that a file descriptor stands for; the index alone, without context, isn't enough.<br>
<p>
<font class="QuotedText">&gt;&gt; it makes it difficult to save the identifier to a file or send it to an unrelated process</font><br>
<font class="QuotedText">&gt; Huh? [link to "Passing File Descriptors over UNIX Domain Sockets"]</font><br>
<p>
I'm aware of FD passing over UNIX domain sockets, but that's only a partial solution. How exactly does one pass a file descriptor to or from a shell script using Unix-domain sockets, for example? Even from C it's more complex than just sending an identifier over *any* available communications channel. It also doesn't address the use case of serializing the identifier to a file, where there may not be any process running to hold the file descriptor open.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2018 5:43 UTC (Wed)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/774668/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That would also work, but no, I meant "integers". I suppose some would say that the file descriptor *is* the integer, and representationally that's often true, but to me the term refers conceptually to an active entry in the file descriptor table (a particular file/pipe/socket/device, set of flags, position, etc.), and the integer is just the index into the table.</font><br>
<p>
Ok — this might just be a terminology difference between FreeBSD and Linux.  In FreeBSD, file descriptors are definitely integers.  They index a per-process table of 'struct filedescent's named the 'fdescenttbl.'  Each filedescent has a 'struct file' pointer,  'struct filecaps', flags, and a sequence number associated with it.<br>
<p>
The 'struct file' tracks things like 'f_type' (DTYPE_VNODE for regular files, DTYPE_SOCKET, DTYPE_PIPE, DTYPE_KQUEUE, etc); 'fileops' (file-level vtable of operations); file-associated credentials; associated 'struct vnode' (inode in Linux terminology), if any; the file offset (for operations like read(2) or write(2) that don't take an explicit offset); etc.<br>
<p>
So you can understand my confusion — we would call what you're talking about a 'filedescent' or just 'file'.<br>
<p>
<font class="QuotedText">&gt; all file descriptors have unique integer identifiers within a process</font><br>
<p>
Ok, definitely 'filedescent' in our terminology, rather than 'file' (which would be shared by a dup(2)ed fd).<br>
<p>
<font class="QuotedText">&gt; Outside the process, however, you need some other way to identify the state that a file descriptor stands for; the index alone, without context, isn't enough.</font><br>
<p>
Sure.  That state can be passed between processes using unix domain sockets and control messages, though.  That's not as frictionless as copying and pasting some pid number between arbitrary processes, but it's not like the credential is locked to the original process exclusively.<br>
<p>
<font class="QuotedText">&gt; How exactly does one pass a file descriptor to or from a shell script using Unix-domain sockets, for example?</font><br>
<p>
It could readily be done with an extension builtin, or a helper program.  (Or something crazy like ctypes.sh.)  Yeah, it's higher friction than just passing around some integer.  On the flip side, it works without increasing pid space to 64 bits.<br>
<p>
<font class="QuotedText">&gt; It also doesn't address the use case of serializing the identifier to a file, where there may not be any process running to hold the file descriptor open.</font><br>
<p>
I'm not sure it's reasonable to serialize a process handle of any kind to a file and expect it to be meaningful later.  Say your file is on NFS, or backed up to a remote system.  Or even a local filesystem, but the machine has been rebooted.  I'm not overly concerned with not handling that case.<br>
<p>
Thanks for the discussion, it's been interesting and given me some food for thought.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2018 22:34 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/774769/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In FreeBSD, file descriptors are definitely integers. They index a per-process table of 'struct filedescent's named the 'fdescenttbl.'</font><br>
<p>
So to unpack the abbreviations a bit, you're saying that in FreeBSD, "file descriptors" are integers which identify "file descriptor entry" structures in a per-process "file descriptor entry table". I can see how that would be confusing.<br>
<p>
I'm not sure it's a FreeBSD vs. Linux thing, but to me including "entry" in the name of the type for the elements of an array seems a bit awkward. I would just say "file descriptor table" for the array, and the elements of the array ("file descriptor table entries") would simply be referred to as "file descriptors". If the "file descriptor" is a member of the current process's "file descriptor table", as is usually the case, then it can be referred to simply by its index in the table (its "file descriptor number"). One might casually refer to this as "passing a file descriptor" when one is really just passing the index of the file descriptor, much like "passing an object" usually just means passing the address of the object.<br>
<p>
(BTW, note the terminology in that document you linked to: "Passing File Descriptors over UNIX Domain Sockets". It is not the *integer* which is being passed over the socket—the receiving process will most likely get a different integer—but rather the object which the integer refers to.)<br>
<p>
<font class="QuotedText">&gt;&gt; How exactly does one pass a file descriptor to or from a shell script using Unix-domain sockets, for example?</font><br>
<font class="QuotedText">&gt; It could readily be done with an extension builtin, or a helper program.</font><br>
<p>
It could be, but now we're talking about adding dependencies on external programs which (a) haven't been written yet and (b) won't necessarily be present on every system. In the end you could just rewrite any shell script in C, but I wouldn't consider that a realistic solution to the problem of "how to do X in a shell script". The object is to create a script which works with existing systems and commonly available tools.<br>
<p>
<font class="QuotedText">&gt; On the flip side, it works without increasing pid space to 64 bits.</font><br>
<p>
Along those lines, the only change that's really needed is for open references to /proc/PID directories (or their contents) to block PID reuse. As others have pointed out, there are ways to tag processes via their environment variables—as long as they are willing to cooperate—so any process could (1) open the PID directory, (2) check for the matching environment variable, and (3) send the signal if the environment matches, knowing that the PID won't be reused since the directory is open. The kernel could improve on this somewhat by implementing pdfork() and assigning unforgeable identifiers when processes are created, but it's not really necessary just to prevent races for most use cases.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2018 16:14 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/774996/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
POSIX already has terms for these things. The things open(2) returns are 'file descriptions': the file description is where things like the open flags and file offset reside: the file descriptor is an integer pointer to a file description, which also has flags of its own (currently only O_CLOEXEC). dup() and fork() copy the descriptor, but leave it referring to the same description. close() closes a descriptor, and if no descriptors are left referencing its description, the description is also closed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor775178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2018 16:35 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/775178/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the file descriptor is an integer pointer to a file description, which also has flags of its own (currently only O_CLOEXEC).</font><br>
<p>
This is interesting but it really just adds another layer of indirection: file descriptor number (integer) -&gt; file descriptor (object with flags) -&gt; file description (object with flags &amp; file offset) -&gt; file. It's still true that a file descriptor is not simply an integer, since integers don't have O_CLOEXEC flags.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/775178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor774275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 16:36 UTC (Fri)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/774275/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My first thought was similar:  Instead of having to hack on /proc open() semantics, put a uuid into the path of the file to send signals to:<br>
<p>
echo 1 &gt; /proc/1234/uuid/u-u-i-d-h-e-r-e/kill<br>
<p>
So it's accessible, and instead of saving the PID to send a signal to, you save the path to the kill file.  If you need/want to preserve the racy behavior, it's still possible to do <br>
<p>
echo 1 &gt; /proc/1234/uuid/*/kill<br>
<p>
...though of course discouraged.  Make it easier to Do The Right Thing, not harder.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor774156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 22:29 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/774156/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or maybe just 64-bit PIDs (incrementing as normal, but with no practical need to worry about recycling)? Instead of adding weird new syscalls that take process fds, add pid64_t variants of everything that takes a pid_t now. On 64-bit archs I assume pid_t is passed to syscalls as a 64-bit int anyway, so you wouldn't even need to define new syscalls - just swap them all to accept pid64_t, then "#define pid_t pid64_t" in userspace to make use of the expanded range.<br>
<p>
For compatibility with old applications, I suppose you could start PIDs at 2^32, and if the syscall is passed a value &lt;2^32 then it must have come from an application with 32-bit pid_t, so do a pid_t-&gt;pid64_t lookup in some clever table. Guarantee that no concurrent processes will have the same PID mod 2^32, via some other cleverness. The lookup will only be wrong if two non-concurrent processes have the same PID mod 2^32, which is the race condition that already exists so it's not making anything worse.<br>
<p>
(I'd be surprised if it was really that easy, though, and I assume people have already considered and rejected it?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 8:33 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/774203/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
PIDs are still part of the user interface. When I need to kill a process on my long-running server, I don't want to copy+paste (or, on a dumb terminal (these still exist, you know), remember and type) a 10-digit number. Not to mention my eyes glazing over when I start "ps".<br>
<p>
That being said, clone-with-fd and kill-via-uniquetoken serve different purposes and IMHO should both be added. The former prevents a multithreaded program from getting confused about whether its child has been reaped by another thread; the latter prevents some unrelated process from killing the wrong task by mistake.<br>
<p>
"kill-via-uniquetoken" doesn't even need another syscall – just a field in the task struct that "ps" displays. "kill" would then open /proc/pid/NNN, read the current token, and compare it with the one it thinks is correct before killing the process the usual way – the PID can't be raced now because the directory is still open.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 16:20 UTC (Fri)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/774271/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Keeping the directory open does not reserve the PID.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 17:23 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/774280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Keeping the directory open does not reserve the PID.</font><br>
<p>
I assumed from previous notes here that this is no longer true in current kernels. I didn't check, so if I'm mistaken, well, that's fixable. (Though somebody could DoS the system by locking every PID in existence, so this feature should probably be limited to processes the holder can actually affect.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor774287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2018 19:51 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/774287/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I expect the process id numbers would only reach ten digits if the system had been up long enough to spawn a billion processes. Tab completion for process ids would help. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774435"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2018 11:04 UTC (Mon)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/774435/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote> Tab completion for process ids would help. </blockquote>
Would it?
<ul>
<li><pre>$ ps aux | grep 'runawayprogram'
james    1720223467 ... runawayprogram</pre>
<li>runawayprogram dies (and is reaped).<br>
<li>User enters (without pressing Enter)<pre>$ kill -9 17202</pre>
<li>User presses tab, and Bash finds only one process:
17202<strong><u>3</u></strong>3467
</ul>

What's the chance that the user notices before pressing enter?
      
          <div class="CommentReplyButton">
            <form action="/Articles/774435/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774540"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2018 8:21 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/774540/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, OK, maybe not.  I don't think the problem gets any worse than if the process id is limited to 15 bits, in which case exactly the same id could end up belonging to a different process.<br>
<p>
Currently kill(1) can take a pid or a process name.  It should let you redundantly specify both, and (without any race condition) check that they match before sending the signal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774540/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor774311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 2:35 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/774311/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the latter prevents some unrelated process from killing the wrong task by mistake.</font><br>
<p>
How does an unrelated process discover the token? By querying a global task list, which then returns an identifier. Because files (including open file references) are first-class citizens in Unix, even from the shell, it's not much more difficult as a technical matter to use and apply a descriptor object than it is a named identifier. For the simple use case of debugging or killing errant processes, the token approach might be simpler. But let's be honest: for those cases the current situation is good enough. When process management races are a real concern, it's rarely in situations where people are copy+pasting output from ps(1). The issue of races arise in the context of building tooling or otherwise programmatically doing process management work.<br>
<p>
Finally, process descriptors permit userspace (e.g. the service manager) to implement unique process identifiers, at least in theory. Process descriptors provide a path to unique tokens. But simply providing unique tokens is a dead-end street.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor774157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 22:05 UTC (Thu)
                               by <b>thiago</b> (guest, #85680)
                              [<a href="/Articles/774157/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FreeBSD has a similar, but much more limited API: <a href="https://www.freebsd.org/cgi/man.cgi?query=pdkill">https://www.freebsd.org/cgi/man.cgi?query=pdkill</a><br>
<p>
     pid_t<br>
     pdfork(int	*fdp, int flags);<br>
<p>
     int<br>
     pdgetpid(int fd, pid_t *pidp);<br>
<p>
     int<br>
     pdkill(int	fd, int	signum);<br>
<p>
     int<br>
     pdwait4(int fd, int *status, int options, struct rusage *rusage);<br>
<p>
The pdkill(2) syscall is insufficient for the needs of realtime signals, since it doesn't allow for the siginfo structure. But if taskfd_send_signal(2) exists, pdkill can be implemented as a glibc function. The pdgetpid(2) call sounds nice, but I don't think we want it. First, because of namespaces (which FreeBSD doesn't have to deal with) and second because it would bind a legacy interface to a new technique.<br>
<p>
For me, as a library maintainer, the important part are the pdfork() and pdwait4() syscalls. They are not required to solve the problem that is being attempted to be solved, though. The patch that josh and I created a few years ago tried to do that: pdfork() was implemented by a CLONE_FD parameter passed to a clone4(2) (an extended version of clone(2)) and the waiting was implemented by select(2)/poll(2) triggering, then reading a siginfo_t from the file descriptor.<br>
<p>
In other news, I still have that clone4() syscall patch and it's probably useful even without the CLONE_FD flag.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 2:16 UTC (Sat)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/774310/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For what it's worth, FreeBSD's pdwait4() was always aspirational — it was documented, but never implemented.  I removed it from the documentation after years of it never getting implemented.  It may happen one day, but for now it is vaporware.<br>
<p>
One other thing FreeBSD has done in this space that I think was inspired by Linux cgroups is procctl(2) PROC_REAP_*[1].  This mechanism allows you to create a sort of process group that cannot be escaped.  You can signal all live processes within the group from the parent ("reaper"); a reused pid does not get re-added to the reapgroup, and the reaper is responsible for wait(2)ing orphaned zombies that originate in the reaper group.<br>
<p>
I am less familiar with the procctl REAP stuff, so I may be doing a poor job of explaining it.  Sorry. :-)<br>
<p>
[1]: <a href="https://www.freebsd.org/cgi/man.cgi?query=procctl&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+12-current&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=procctl&amp;apr...</a><br>
[2]: <a href="https://svnweb.freebsd.org/base?view=revision&amp;revision=275800">https://svnweb.freebsd.org/base?view=revision&amp;revisio...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 3:00 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/774315/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux has prctl(2) PR_SET_CHILD_SUBREAPER<br>
<p>
  A subreaper fulfills the role of init(1) for its descendant<br>
  processes.  When a process becomes orphaned (i.e., its<br>
  immediate parent terminates) then that process will be<br>
  reparented to the nearest still living ancestor subreaper.<br>
  Subsequently, calls to getppid() in the orphaned process will<br>
  now return the PID of the subreaper process, and when the<br>
  orphan terminates, it is the subreaper process that will<br>
  receive a SIGCHLD signal and will be able to wait(2) on the<br>
  process to discover its termination status.<br>
<p>
-- <a href="http://man7.org/linux/man-pages/man2/prctl.2.html">http://man7.org/linux/man-pages/man2/prctl.2.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor775379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2018 10:30 UTC (Fri)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/775379/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't EVFILT_PROCDESC basically the replacement for pdwait4? Except I guess it doesn't let you reap the process...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/775379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor774369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2018 0:58 UTC (Sun)
                               by <b>brauner</b> (subscriber, #109349)
                              [<a href="/Articles/774369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fwiw, if this patch lands I intend to pick yours up and would very much like your input.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor774414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Additional existing process match entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2018 1:32 UTC (Mon)
                               by <b>ewen</b> (subscriber, #4772)
                              [<a href="/Articles/774414/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the aim is just to avoid the "recorded PID a while ago, it exited, and a new process has started with the same PID" problem, the obvious solution (other than decreasing the chances of PID reuse, eg, by increasing the PID range beyond 15 bits...) is to use some more entropy from the process to ensure that you have found the *correct* process, for instance the *Parent* Process ID:<br>
<p>
ewen@abbey:~$ cd /proc/$$<br>
ewen@abbey:/proc/7244$ grep Pid status | grep -v Tracer<br>
Pid:	7244<br>
PPid:	7243<br>
ewen@abbey:/proc/7244$ <br>
<p>
If we match on both Pid *and* PPid, then the chances of sending the signal to the "wrong version of Pid NN" is dramatically reduced.  (The remaining use cases are basically (a) spawned by the same parent, or (b) reparented to PID 1 because parent exited; in the first case the parent proces should *already* know if it has collected the exit code or not, and from memory the PID won't be reused until it has collected the exit code.)<br>
<p>
Obviously this requires a new system call, and obviously while the old system call  exists it could also be used to send signals ignoring these extra match parameters.  But that seems to be true of every other proposal too.  And using the PPid value requires very little change other than a new system call to accept the additional parameter.  Ideally that new system call could optionally accept a bunch of other "match parameters", at least as a trivial extension later -- eg UID / GID / root / CWD all seem like potentially useful matches in some cases, that should be "slow changing" (and thus limited race on fetch / use cycles).<br>
<p>
Ewen<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Additional existing process match entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2018 17:59 UTC (Mon)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774493/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW, I have a daemon that monitors 4,000 processes on a VM.  It looks for custom UUID values in /proc/PID/environ.  <br>
That works great if you're calling fork() from a single threaded process.  But if multithreaded, you can't set new environment vars just for your own thread+fork AFAIK.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774534"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Additional existing process match entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2018 6:53 UTC (Tue)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/774534/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Huh? You fork first and *then* set the uuid envvar. Still a race condition either way. If I were to write that sort of daemon I'd add a small API to it to *tell me* which process has a given UUID – or, even better, send the signals on my behalf.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774534/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774600"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Additional existing process match entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2018 18:03 UTC (Tue)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774600/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, total brain fart - I was just trying to say "I don't recommend the environ hacks as a general solution".<br>
<p>
But the point is that there is a way to assign arbitrary string labels / tags to processes in Linux today, using the environ mechanism.<br>
If only there were 1) a way to set the labels at clone/fork time (not exec), and 2) a way to make kill() match the extra labels.<br>
Assuming we've all given up on just making pids 64 bit.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774600/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Additional existing process match entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2018 18:35 UTC (Tue)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774603/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the /proc directory locking can temporarily prevent PID recycling, the problem could be decomposed:<br>
<p>
1) Kernel adds /proc/PID/longpid attribute (guaranteed unique by kernel)  Pass PID+longpid to kill_ex() to avoid a PID recycling race.<br>
2) Kernel makes open(/proc/pid) prevent PID recycling<br>
3) (optional) Kernel adds /proc/PID/tags, which is like /proc/PID/environ but set at clone() time.  Only userspace sets/gets this field.<br>
<p>
So now, an external process can scan /proc/*, look at "tags", and then get "longpid".  Using open/openat to prevent races.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774605"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Additional existing process match entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2018 18:41 UTC (Tue)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/774605/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(Really wish I could edit comments).<br>
<p>
It looks like #1 is not even needed in some situtations here.  If you call kill() while you have the /proc/pid dir locked, there's no need for disambiguation.  Hmm.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774605/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor774667"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward race-free process signaling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2018 5:14 UTC (Wed)
                               by <b>amworsley</b> (subscriber, #82049)
                              [<a href="/Articles/774667/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why can't you just use an existing file descriptor system call to send the signal?<br>
e.g. write(fd, siginfo_t *info, sizeof (siginfo_t))<br>
<p>
It seems a natural analog of the process which is receiving signals via signalfd filedescriptors?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774667/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
