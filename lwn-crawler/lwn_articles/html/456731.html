        <!DOCTYPE html>
        <html lang="en">
        <head><title>The x32 system call ABI [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/456731/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/456507/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/456731/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The x32 system call ABI</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 29, 2011</br>
           </div>
The 32-bit x86 architecture has a number of well-known shortcomings.  Many
of these were addressed when this architecture was extended to 64 bits by
AMD, but running in 64-bit mode is not without problems either.  For this
reason, a group of GCC, kernel, and library developers has been working on
a new machine model known as the "x32 ABI."  This ABI is getting close to
ready, but, as a recent discussion shows, wider exposure of x32 is bringing
some new issues to the surface.
<p>
Classic 32-bit x86 has easily-understood problems: it can only address 4GB
of memory and its tiny set of registers slows things considerably.  Running
a current processor in the 64-bit mode fixes both of those problems nicely,
but at a cost: expanding variables and pointers to 64 bits leads to
expanded memory use and a larger cache footprint.  It's also not uncommon
(still) to find programs that simply do not work properly on a 64-bit
system. Most programs do not
actually need 64-bit variables or the ability to address massive amounts of
memory; for that code, the larger data types are a cost without an
associated benefit.  It would be really nice if those programs could take
advantage of the 64-bit architecture's additional registers and instructions
without simultaneously paying the price of increased memory use.
<p>
That best-of-both-worlds situation is exactly what the <a
href="https://sites.google.com/site/x32abi/">x32 ABI</a> is trying to
provide.  A program compiled to this ABI will run in native 64-bit mode,
but with 32-bit pointers and data values.  The full register set will be
available, as will other advantages of the 64-bit architecture like the
faster <tt>SYSCALL64</tt> instruction.  If all goes according to plan, this
ABI should be the fastest mode available on 64-bit machines for a wide
range of programs; it is easy to see x32 widely displacing the 32-bit
compatibility mode.
<p>
One should note that the "if" above is still somewhat unproven: actual
benchmarks showing the differences between x32 and the existing pure modes
are hard to come by.
<p>

One outstanding question - and <a href="/Articles/456739/">the spark for
the current discussion</a> - has
to do with the system call ABI.  For the most part, this ABI looks similar
to what is used by the legacy 32-bit mode: the 32-bit-compatible versions
of the system calls and associated data structures are used.  But there is
one difference: the x32 developers want to use the <tt>SYSCALL64</tt>
instruction just like
native 64-bit applications do for the performance benefits.  That
complicates things a bit, since, to know what data size to expect, the
kernel needs to be able to distinguish 
system calls made by true 64-bit applications from those running in the x32
mode, regardless of the fact that the processor is running in the same mode in
both cases.  As an added challenge, this distinction needs to be made
without slowing down native 64-bit applications.  
<p>
The solution involves using an expanded version of the 64-bit system call
table.  Many system calls can be called directly with no compatibility
issues at all - a call to <tt>fork()</tt> needs little in the translation
of data structures.  Others do need the compatibility layer, though.  Each
of those system calls (92 of them) is assigned a new number starting at
512.  That leaves a gap above the native system calls for additions over
time.  Bit&nbsp;30 in the system call number is also set
whenever an x32 binary calls into the kernel; that enables kernel code that
cares to implement "compatibility mode" behavior.
<p>
Linus didn't seem to mind the mechanism used to distinguish x32 system
calls in general, but he <a href="/Articles/456741/">hated the use of
compatibility mode</a> for the x32 ABI.  He asked:
<p>
<div class="BigQuote">
	I think the real question is "why?". I think we're missing a lot of
	background for why we'd want yet another set of system calls at
	all, and why we'd want another state flag. Why can't the x32 code
	just use the native 64-bit system calls entirely?
</div>
<p>
There are legitimate reasons why some of the system calls cannot be shared
between the x32 and 64-bit modes.  Situations where user space passes
structures containing pointers to the kernel (<tt>ioctl()</tt> and
<tt>readv()</tt> being simple examples) will require special handling since
those pointers will be 32-bit.  Signal handling will always be special.
Many of the other system calls done specially for x32, though, are there to
minimize the differences between x32 and the legacy 32-bit mode.  And those
calls are the ones that Linus <a href="/Articles/456745/">objects to</a>
most strongly.
<p>
It comes down, for the most part, to the format of integer values passed to
the kernel in structures.  The legacy 32-bit mode, naturally, uses 32-bit
values in most cases; the x32 mode follows that lead.  Linus is saying,
though, that the 64-bit versions of the structures - with 64-bit integer
values - should be used instead.  At a minimum, doing things that way would
minimize the differences between the x32 and native 64-bit modes.  But
there is also a correctness issue involved.
<p>
One place where the 32- and 64-bit modes differ is in their representation
of time values; in the 32-bit world, types like <tt>time_t</tt>, <tt>struct
timespec</tt>, and <tt>struct timeval</tt> are 32-bit quantities.  And
32-bit time values will overflow in the year 2038.  If the year-2000 issue
showed anything, it's that long-term drop-dead days arrive sooner than one
tends to think.  So it's not surprising that Linus is <a
href="/Articles/456750/">unwilling</a> to add a new ABI that would suffer
from the 2038 issue:
<p>
<div class="BigQuote">
	2038 is a long time away for legacy binaries. It's *not* all that
	long away if you are introducing a new 32-bit mode for performance.
</div>
<p>
The width of <tt>time_t</tt> cannot change for legacy 32-bit binaries.  But
x32 is an entirely new ABI with no legacy users at all; it does not have to
retain any sort of past compatibility at this point.  Now is the only time
that this kind of issue can be fixed.  So it is probably entirely safe to
say that an x32 ABI will not make it into the mainline as long as it has
problems like the year-2038 bug.
<p>

At this point, the x32 developers need to review their proposed system call
ABI and find a way to rework it into something closer to Linus's taste;
that process is <a href="/Articles/456760/">already underway</a>.
Then developers can get into the serious business of building systems under
that ABI and running benchmarks to see whether it is all worth the effort.
Convincing distributors (other than Gentoo, of course) to support this ABI
will take a fairly convincing story, but, if this mode lives up to its
potential, that story might just be there.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#User-space_API">User-space API</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#x32">x32</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/456731/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor457182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory seen from a single process</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 1:21 UTC (Thu)
                               by <b>cma</b> (guest, #49905)
                              [<a href="/Articles/457182/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      A doubt here...<br/><br/>
Does x32 will provide for a single process for mapping/seeing more than 2GB of ram?
      
          <div class="CommentReplyButton">
            <form action="/Articles/457182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457192"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory seen from a single process</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 3:38 UTC (Thu)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/457192/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes...4GB!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457192/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor457204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory seen from a single process</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 5:18 UTC (Thu)
                               by <b>Tuna-Fish</b> (guest, #61751)
                              [<a href="/Articles/457204/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since the kernel will always be running x64 and using address space well clear of the first 32 bits, 32-bit user programs running on it always have full 4GB available (well, less the first page usually).<br>
<p>
If you need more than 4GB, you should compile your program for native 64 bit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory seen from a single process</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2011 17:43 UTC (Tue)
                               by <b>cma</b> (guest, #49905)
                              [<a href="/Articles/458778/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Thanks!

So this could be a problem for apps needing more than 4GB. Like MySQL with larger buffers or a memory based DB.

Regards
      
          <div class="CommentReplyButton">
            <form action="/Articles/458778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory seen from a single process</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2011 17:51 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/458780/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
yes, if you have one application that needs more than 4G itself (not counting memory used by the kernel internally, or used by the kernel to buffer disk I/O), then you need to use AMD64, not x32<br>
<p>
a large database is a perfect example of a situation where you would want the full 64 bits available.<br>
<p>
given these other memory usesin a system, it's very likely that a machine with 6-8G of ram that's dedicated for database use could still be very happy with x32<br>
<p>
however, if you are splitting the database up using sharding (where you have multiple database instances, which could live on separate machines, including virtual machines), it's very possible that each one will only need 4G or less of address space even with far more ram.<br>
<p>
also, if you have a database like postgres that used multiple processes (instead of multiple threads), you should recognize that each process can have 4G of address space, so unless you have a huge amount of shared memory allocated, 4G per process may be a very comfortable limit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor457195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 3:57 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/457195/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      Curiously, that <a href="https://sites.google.com/site/x32abi/">first link</a> does have some benchmarks, and in none of them is x32 actually the best choice -- on one of them ia32 wins, and on one of them x86-64 wins. I guess this must reflect some lack of optimization in the toolchain or something, since I can't see how adding more registers could ever legitimately make a CPU-bound 32-bit program *slower*...?
      
          <div class="CommentReplyButton">
            <form action="/Articles/457195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 4:24 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/457196/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Further down the page is this note:</P>
<BLOCKQUOTE><pre>
    GCC
        The current x32 implementation isn't optimized:
            Atom LEA optimization is disabled.
            Memory addressing should be optimized.
</pre></BLOCKQUOTE>
<P>So, that presumably accounts for why 181.mcf slowed down 0.5% to 1% relative to normal 32-bit x86.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor457237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 8:08 UTC (Thu)
                               by <b>slashdot</b> (guest, #22014)
                              [<a href="/Articles/457237/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't understand why they need to change the kernel and add a new "x32" ABI.<br>
<p>
Why not just have x32 programs use the x86-64 system calls and otherwise behave as normal x86-64 programs from the kernel's perspective?<br>
<p>
The only difference would then be that they would only use 4GB of address space (mmap with MAP_32BIT), and store pointers in 32-bit-sized locations in memory.<br>
<p>
In fact, you could probably use #pragma and/or __attribute__ to specify pointer size, and use a 64-bit libc, while most other libraries and the executable are 32-bit.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 11:56 UTC (Thu)
                               by <b>and</b> (guest, #2883)
                              [<a href="/Articles/457287/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that some structures contain pointers which are always 64 bits in kernel space but in x32 the userspace only has 32 bits. The "new" system calls thus have to translate these pointers before the structures can be used by "normal" kernel space code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457297"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 12:53 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/457297/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not simply use the 64-bit structures then?<br>
<p>
When putting a pointer into these structures, it can simply be zero-extended.<br>
<p>
Only memory allocation system calls would need a new flag (to allocate below 4G). Other than these, the kernel does not have to change at all. The rest could be done in userspace.<br>
<p>
(The only other change needed in the kernel would be to add a flag in the executable file format to make ASLR use only the lower 32  bits.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457297/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 22:17 UTC (Thu)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/457423/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you use the 64 bit structures, then you have a 64-bit userland program...<br>
Resuming:<br>
x86_64/amd64 =&gt; wastes space (and cache == performance), many registers<br>
ia32 =&gt; gains space, few registers<br>
x32 =&gt; gains space, many registers<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2011 22:05 UTC (Mon)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/457765/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe the idea here is _not_ to use 64 bit pointers everywhere, but rather to use 64 bit pointers in certain circumstances, and do one of the following:<br>
<p>
(1) Change the source level API for all pertinent ioctl structures that contain pointers so that programs have to manually zero extend a 32 bit pointer into some sort of opaque 64 bit value.<br>
(2) Use a compiler extension that does this transparently, i.e. that supports  a special pointer type where the high order bits are always zero.<br>
<p>
I suspect (1) would break source compatibility in far too many places, although it seems like it is what should have been done way back when these interfaces were first designed. <br>
<p>
(2) seems ideal, but requires cooperation for every supporting compiler.  I don't know exactly why, but the x32 ABI devs are trying to avoid that if at all possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2011 1:05 UTC (Tue)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/457773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is also:<br>
<p>
(3) Keep the source level API 32-bit, but have glibc do the zero-extension into the true 64-bit API before calling the kernel.<br>
<p>
The main problem with that is, of course, ioctl (the same compat ioctl problem the kernel already has). So, how about this:<br>
<p>
(4) Same as (3) but add a new x32_ioctl 64-bit syscall which calls into the compat ioctl engine the kernel already has.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor457426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 22:28 UTC (Thu)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/457426/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; can't see how adding more registers could ever legitimately make a </font><br>
<font class="QuotedText">&gt; CPU-bound 32-bit program *slower*...? </font><br>
<p>
Several things could conspire to make this happen, besides the lack of optimization already noted.<br>
<p>
- Function calls are more expensive due to additional callee-save registers.<br>
- Systems calls are more expensive due to larger context save and restore.<br>
- Things like setjmp/longjmp are slower for the same reason.<br>
- Longer instruction encoding causes icache pressure.<br>
<p>
Then there are all sorts of microarchitecture changes resulting from the ISA additions that can reduce clock-for-clock performance.  Things like longer pipelines to compensate for more complicated instruction decoding, though these are likely secondary at best.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor457273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 10:28 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/457273/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This also assumes that native x86-64 won't have 512 syscalls at any point in the future. This suggests that the rate of syscall addition will slow or stop. This seems... unlikely, unless everyone falls in love with giant multiplex syscalls again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457516"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2011 14:50 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/457516/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
x32 syscall behaviour is supposed to be distinguished by a high bit set on %eax, not by the syscall table index. The choice to start numbering from 512 seems to be intended to avoid a collision with other additions made in parallel, not to provide a permanent distinction between native x86_64 and x32 syscalls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457516/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2011 19:45 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/457631/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, right, perfectly normal procedure then, just with a much bigger gap than I'm used to :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor457422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 22:45 UTC (Thu)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/457422/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Convincing distributors (other than Gentoo, of course) to support this ABI </font><br>
<p>
Surely it is application developers rather than distributors who would support this thing?<br>
<p>
In the Gentoo case, presumably I'd merely have to remember to pick a kernel option before emerging something that could use this.  Said option would be mentioned in the middle of a 300 package emerge, after setting a USE flag, which I'd never notice 8)<br>
<p>
For now fixing how CUPS can cause a 2 hour load time for a Libre Office file is probably going to yield better performance improvements (its something to do with printers being unavailable away from "home")<br>
<p>
I am not an expert but this look like a bodge of some sort. An application is written to work with a 2^n bit system.  If it runs on a 2^n bit system then great.  If not then you'll need a compatibility layer.<br>
<p>
Surely the 64 bit version of a (previously) 32 bit app can be efficient in terms of memory and register usage.<br>
<p>
I can't help but be reminded of the 16 -&gt; 32 bit migration.<br>
<p>
FIX THE BLOODY APPLICATION!<br>
<p>
Cheers<br>
Jon<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457432"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2011 23:00 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/457432/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
depending on the application, the fact that pointers and memory addresses change from 32 bits to 64 bits can actually slow the system significantly.<br>
<p>
the larger footprint uses more CPU cache, making the system spend more time waiting for the cache to be updated from memory.<br>
<p>
this is why many of the chips that have both 32 bit and 64 bit modes tend to run 64 bit kernels with 32 bit userspace, for programs that don't need to address more than 4G of ram, the overhead of the larger data objects results in a slowdown<br>
<p>
x86/AMD64 is pretty much unique in the fact that 64 bit mode doesn't just extend the registers to 64 bits, it also gives you twice as many registers to work with. Since the x86 platform has far fewer registers than more modern designs, the availability of more registers means that far more things can happen in the CPU itself, without having to save and load values out to the cache (or worse yet, to RAM) in a constant shuffle to get register space for the things that need it. x86 systems spend a HUGE amount of time doing this register shuffle.<br>
<p>
the idea behind the x32 architecture is to be able to take advantage of these extra registers (which almost always result in improved performance) without having to pay the overhead of larger pointers to memory.<br>
<p>
the fact that many 32 bit applications that are nto 64 bit clean can be made to run in this mode is pure gravy, and if the time change takes place, this may be sacraficed in order to get a better long-term x32 architecture.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457432/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2011 5:35 UTC (Fri)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/457469/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <i>the idea behind the x32 architecture is to be able to take advantage of these extra registers (which almost always result in improved performance) without having to pay the overhead of larger pointers to memory.</i>
<p>
I can see the reasoning, but still I feel the ideal is <b>very bad</b>. It reminds me too much of the "memory models" of MS-DOS, 16-bit Xenix and 16-bit OS/2, and the problems associated to having then separate library versions of each, and slightly different requirements and capacities of programs depending on how they were compiled. Been there, and did not like it. Please don't bring this mess to Linux!
<p>
Having more modes just means more available ways for the programmer to screw things up, and more possibilities for low-level bugs and security holes in the kernel and C library. The now-existing 32-bit mode in x86_64 is justifiable for supporting legacy binaries, but other memory models will just complicate things with very little gain.

      
          <div class="CommentReplyButton">
            <form action="/Articles/457469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2011 14:41 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/457515/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Please don't bring this mess to Linux!
</blockquote>
Linux has had 'this mess' since the days of SPARC64 in the 90s, and now with x86-64 and x86-32, biarchy is downright common. The linker and dynamic linker know about it, and you cannot accidentally link against the wrong library. Biarch packaging problems have largely been weeded out by the ubiquity of x86-64.

      
          <div class="CommentReplyButton">
            <form action="/Articles/457515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2011 19:02 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/457566/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I know hat Sparc and PowerPC both have this sort of 32/64 split.<br>
<p>
and as far as I have seen, almost all distros for those chips ship 64 bit kernels with 32 bit userspace because 32 bit binaries are faster to run than 64 bit ones (due to the more compact code and memory addresses), as long as you can live in 4G of address space as an application.<br>
<p>
there are actually very few cases where a single application needs to address more than 4G of address space, and in many, if not most of those cases there are real advantages to just running multiple processes rather than a single giant process. so this works very well in the real world.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2011 22:36 UTC (Fri)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/457583/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; there are actually very few cases where a single application needs to address more than 4G of address space,</font><br>
<p>
I guess you think java applications are few. :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2011 22:47 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/457585/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
yes, the number of Java applications where a single application needs to address more than 4G of memory are few.<br>
<p>
remember that visualization is supposed to be the wave of the future, especially for things in datacenters. part of the way this works is that you slice up the memory available on a server to allocate it between many more small servers. most such servers end up with less than 4G per virtual server and what we are talking about for x32 is 4G per _application_ (not counting OS buffering, kernel allocations, or any other overhead) this is a lot more elbow room.<br>
<p>
not every application can fit in 4G, but when you really look at it, a surprising number of them will.<br>
<p>
and pointer-heavy things like Java are especially likely to benifit from the smaller pointers of x32<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2011 7:48 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/457694/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Java actually benefits so much, that Oracle JVM actually implements userspace pointer compression!<br>
<p>
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a> and <br>
<a href="http://blog.juma.me.uk/tag/compressed-oops/">http://blog.juma.me.uk/tag/compressed-oops/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor457767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2011 22:38 UTC (Mon)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/457767/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; and pointer-heavy things like Java are especially likely to benifit from</font><br>
<font class="QuotedText">&gt; the smaller pointers of x32</font><br>
<p>
Offtopic, but interesting: 64-bit Java already offers the -XX:+UseCompressedOops option which turns on pointer compression. By dropping 3 bits from the least significant end of the address, it can address 32GB of memory using 32-bit pointer fields.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2011 14:35 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/457815/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Userspace pointer compression has its own costs. In my tests it often performs worse than non-compressed version.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor490191"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2012 14:30 UTC (Mon)
                               by <b>Richard_J_Neill</b> (subscriber, #23093)
                              [<a href="/Articles/490191/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is quite a clever trick. If I understand rightly, what Java is doing is giving up byte-addressability, in favour of more address space. I.e. you can't create a pointer to a byte/char any more; the smallest data-type then becomes an int, and strings have to contain 4*n bytes. Given that x86 accesses memory 32-bits at a time anyway, this is a fairly natural thing to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/490191/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor490483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2012 20:49 UTC (Tue)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/490483/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Given that x86 accesses memory 32-bits at a time anyway, </font><br>
<p>
On modern CPU memory is addressed internally by cache lines that are typically 16-32-64 bytes in size. On x86 the byte access is just as fast as 32-bit access. Moreover, misaligned access to 32-bit values is allowed and is not costly as long as the variable does not cross the cache line boundary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/490483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor498043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 21, 2012 15:08 UTC (Mon)
                               by <b>mikemol</b> (guest, #83507)
                              [<a href="/Articles/498043/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For basic instructions, yes. Take a look at the SSE instructions; while there are unaligned and aligned versions for several, the aligned versions will carry better performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/498043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor457607"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2011 11:50 UTC (Sat)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/457607/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I kind of wish that the Linux distros took that approach when transitioning to x86_64, I am of the opinion that the transition would have been a lot smoother especially for desktops had that been the case. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457607/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457621"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2011 17:12 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/457621/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there were two big factors that cause distros to go the direction they did for AMD64<br>
<p>
1. especially early on there were problems with the compatibility mode causing occasional 'strange' errors when running 32 bit userspace on a 64 bit kernel.<br>
<p>
2. the added registers of 64 bit mode significantly improve the performance of 64 bit code vs 32 bit code, in almost every case even when you take into account the extra overhead of the larger pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457621/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That way lies madness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2011 3:30 UTC (Tue)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/457784/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't this likely to be superior enough to motivate desktop distributions to switch to an x32 user space with a 64 bit kernel, with x86-64 libraries as extensions for those applications that actually benefit from a large address space?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor457772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MS and Apple? Intel or AMD?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2011 0:24 UTC (Tue)
                               by <b>kragilkragil2</b> (guest, #76172)
                              [<a href="/Articles/457772/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do Windows or OSX do it this way? <br>
My guess is they don't because they would need compiler support, but I also think that some engineers at Apple, MS, Intel or AMD did the benchmarks and concluded that it isn't worth it. AFAIK modern CPUs use some sort of shadow registers or something to mask away the performance penalties you get by having so few registers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor457786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2011 5:49 UTC (Tue)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/457786/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ugh. I'm having such a hard time making myself believe that this is a good idea.<br>
<p>
The inevitable result of this is that I'm going to have _two_ copies of most of my system libraries in core at all times, and we'll be back to the bad old days where common software isn't 64 bit clean (right now its mostly only proprietary crap-ware like flash thats problematic) <br>
<p>
And for what? so a very few overly pointered memory bandwidth bound test cases can run faster? Any many of these cases could run just as well by switching to (e.g.) using pointer offsets internally (which would also reduce their scalability, but no worse than switching to 32 bit mode).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457805"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2011 12:27 UTC (Tue)
                               by <b>liljencrantz</b> (guest, #28458)
                              [<a href="/Articles/457805/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed. This, to me, sounds like over-optimizing. <br>
<p>
Aside from the possibility of getting a 64-bit time_t on 32-bit systems, this sounds like a huge waste of time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457805/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor457866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2011 6:23 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/457866/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If x32 compiled distributions run significantly faster than x64, it seems rather likely to me that desktop users will generally end up with _one_ x32 copy of system libraries in memory, with x64 libraries only loaded for the occasional application that needs a very large memory space. <br>
<p>
With open source applications, what is there to complain about?  If you don't like x32 just use x64 only.<br>
<p>
And of course the big advantage of x32 over pointer compression is that no source modifications are required, modifications that in a typical C application would be extremely painful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor457867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2011 6:47 UTC (Wed)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/457867/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"If you don't like x32 just use x64 only"  which means I get to go back to the bad old days of playing (int) to (void *)/(size_t) conversion guy because when 64 bit systems weren't commonly deployed on developers desktops a lot of stuff simply didn't work without a bunch of fuss.  The freedom of open source has tremendous but not infinite value there is a real cost to being an oddball.<br>
<p>
"If x32 compiled distributions run significantly faster than x64" IFF, but based on the currently available micro-benchmarks this seems unlikely.  I've yet to see an example of a single application which is faster in x32 than best_of(x86,x86_64), and if we're in the two libraries mode then taking the choice of x86 for those few memory bandwidth bound pointer heavy apps that don't mine the scalability constraint is no worse.<br>
<p>
"occasional application" like... my browser? (which is currently using ~4GiB of VM, though not as much resident obviously).<br>
<p>
Not to mention the reduced address space for ASLR. <br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/457867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2011 21:19 UTC (Thu)
                               by <b>JanC_</b> (guest, #34940)
                              [<a href="/Articles/458129/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's using almost 4 GiB on a 64-bit system now?  But of course your browser would supposedly need significantly less memory when running in x32 mode?  And once Firefox also uses out-of-process rendering (like Chrome/Chromium), that would become even less of an issue...?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor458143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 2:30 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/458143/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;I've yet to see an example of a single application which is faster in x32 than best_of(x86,x86_64)</font><br>
<p>
That is the wrong metric to judge an ABI by - unless you agree that we should stick with an x86 + x86_64 biarchy indefinitely, and have distributions compile every other application appropriately.  Then we really will end up with both sets of libraries pinned in memory.<br>
<p>
  x32 is noticeably better than x86, on some benchmarks as much as 30% more. It is also noticeably better than x86_64, another 30% on important workloads. It is a better all around ABI for most applications. <br>
<p>
  x86 is stunted, and will hopefully go away in a few years.  But x32 sounds like it is worth keeping around for a long time.  A 30% performance increase on many workloads isn't the sort of thing you want to idly throw away.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor458195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 12:23 UTC (Fri)
                               by <b>NikLi</b> (guest, #66938)
                              [<a href="/Articles/458195/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is not "pointer memory bandwidth bound test cases".<br>
<p>
A vm like python uses a *lot* of pointers:<br>
<p>
- a list of 'n' items is a buffer of 'n' pointers. Same for tuples.<br>
- a dictionary of 'n' items is a buffer of ~6*n pointers<br>
- every string item carries a pointer<br>
- every instance is a dictionary plus a couple of pointers<br>
<p>
C programmers think with memory buffers but for dynamic languages where objects work by reference are mostly based on tons of pointers; this is what makes them dynamic. And yes, making all those pointers half their size is very important. Because imagine that when you want to look up something in a list, this list is fetched to the cache and all the pointers are traversed while looking for the item. Fetching a 2k buffer is better than fetching a 4k buffer. In fact, x86 might be more suitable than x86-64 for such vms!<br>
<p>
(It would be very interesting to see some python benchmarks for x32 vs x86, nontheless)<br>
<p>
Now, one may say that "if you want speed, do it in C". However making a dynamic language faster will benefit thousands of programs written in that language, which is important for some people..<br>
<p>
Using pointer offsets suffers from one extra indirection and will kill a big part of the cache. On the other hand, pointing to more than 4G of things is an overkill.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 14:12 UTC (Fri)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/458207/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Using pointer offsets suffers from one extra indirection and will kill a big part of the cache. On the other hand, pointing to more than 4G of things is an overkill.</font><br>
<p>
You use a single offset (after all, we're assuming you're willing to take a 4G limit in these applications) and keep it in a register.<br>
<p>
Alternatively, how about an ABI that promises you that you can get memory under the 4G mark and you use 32 bits internally, and covert at the boundaries to external libraries.  This way single applications can be 32 bit without overhead but it doesn't drag the whole system with it?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 15:45 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/458220/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
what you are trying to describe is basically what the x32 architecture is doing.<br>
<p>
however you missed that libraries can allocate memory as well, and so the libraries must be compiled to only request memory under 4G as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 18:12 UTC (Fri)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/458254/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would only take a single syscall to the kernel to tell it to never give this process access to _any_ address space outside of the first 4gb (not via sbrk, mmap, etc).<br>
<p>
It would have ~all the performance benefits without doubling the libraries in memory.  It wouldn't, however, retain the benefit of reduced porting benefit of existing 32bit crapware since pointers in library owned structures would be the other size. ::shrugs::<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 3:23 UTC (Sun)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/458403/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What you describe could be done, but it would be difficult to implement, require special compiler support to do well, and would break source compatibility even with special compiler support. <br>
<p>
It would be essentially the same as adding support for 80286 style near and far pointers across the code base.  In C, every structure, every header file, every shared pointer declaration would potentially have to be marked whether it was using large or small pointers.  The compiler certainly wouldn't know that an arbitrary function or structure declaration was referring to something from a library, and some libraries would have to come in a non-standard flavor in any case.<br>
<p>
Now as you say, there are certain advantages to that, in terms of memory and cache footprint.  They did it back in the x286 era for a reason.  But it is much more impractical to implement that sort of thing across the source code for practically everything then simply to compile under a new ABI, especially if the new ABI performs well enough to be the system default.<br>
<p>
A reasonable distribution policy could be to replace x86 with x32, and not ship x86_64 libraries in x32 distributions. It could simply say that if you want have a 64 bit user space, you should use a full 64 bit version. 64 bit addressing could be reserved for the kernel.  If I were to guess, half of the people currently planning to use x32 (e.g. in embedded applications) have that sort of thing in mind in any case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor491330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2012 21:28 UTC (Mon)
                               by <b>snadrus</b> (guest, #60224)
                              [<a href="/Articles/491330/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about building x32 off ia32 compatibility? There would be no kernel changes, but just compiler changes to use the additional registers. You may even be able to use ia32 or x32 libraries interchangeably if you're not passing by register.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/491330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor491384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2012 9:08 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/491384/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>1. Open <a href="http://en.wikipedia.org/wiki/X86-64#Operating_modes">wikipedia</a>. Read.<br />
2. Try to pretend you never asked this question.</p>

<p>Perhaps then you'll be considered seriously in some future architecture dispute.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/491384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor492194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Your worst yet, and for me your last</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2012 6:37 UTC (Fri)
                               by <b>biged</b> (guest, #50106)
                              [<a href="/Articles/492194/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Khim, you have exceeded your usual levels of hostility and brashness with this comment, and so I have added you to my filter. (I mention this as a reminder to others: My Account -&gt; Comment Filtering.)<br>
<p>
Your response here is beyond rude: it is poisonous. You should realise that with more time and attention someone might be able to explain the misconception, help others and avoid insulting anyone.<br>
<p>
Please stop treating LWN as your inbox: post less often, and more thoughtfully.  For me, you have become a spammer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/492194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor458340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2011 8:27 UTC (Sat)
                               by <b>bersl2</b> (guest, #34928)
                              [<a href="/Articles/458340/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I know nobody cares, but seeing "x32" makes my blood boil as much as seeing "x64" did.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2011 17:11 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/458364/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can see reasons for preferring AMD64 to x64, but why are you offended by x32 and what would you prefer instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 14:28 UTC (Sun)
                               by <b>Baylink</b> (guest, #755)
                              [<a href="/Articles/458416/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe bersl thinks the same thing I do: it should be x86_32, for parallelism with x86_64.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor492551"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2012 21:16 UTC (Sun)
                               by <b>tenchiki</b> (subscriber, #53749)
                              [<a href="/Articles/492551/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope the people developing the x32 ABI have looked at what worked and what didn't work in the IRIX n32 ABI; it had a lot of the same requirements and issues. IRIX 64-bit systems ran %99+ of userspace as n32 for the same reasons mentioned (most apps don't need &gt;2G address space, and 32bit pointers used the cache better).<br>
One of the notable specs for the n32 ABI that don't seem to have been mentioned for x32 is to make the long datatype to be 64bits:<br>
<p>
ABI:   o32     n32    64<br>
int     32      32    32<br>
long    32      64    64<br>
pointer 32      32    64<br>
(all other types same size)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/492551/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor492557"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2012 23:05 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/492557/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">One of the notable specs for the n32 ABI that don't seem to have been mentioned for x32 is to make the long datatype to be 64bits</font></blockquote>

<p>Why would anyone want this? x32 uses ILP32 model to minimize difference between IA32 mode and x32 mode. Any other choice just looks… strange.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/492557/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor492573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2012 6:56 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/492573/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because it lets you have access to the 64bit arithmetic capabilities of the hardware, even when you don't need the 64bit addressing capabilities.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/492573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor492582"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2012 9:00 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/492582/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      What's wrong with using <code>long long</code> for that?
      
          <div class="CommentReplyButton">
            <form action="/Articles/492582/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor492594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2012 11:07 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/492594/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, good point. Actually, I think in IRIX n32 it was indeed "long long" that was 64bit! (Making 64bit long risked breaking software that assumed sizeof(long) == sizeof(void *) and tried to store longs in pointers).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/492594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor527798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2012 14:08 UTC (Sun)
                               by <b>normcf</b> (guest, #88125)
                              [<a href="/Articles/527798/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having found the conversation interesting, I just want to interject a small historical thought.  About 30 years ago, I worked on a Burroughs B6700.  This machine had a 48bit architecture and the virtual memory management that was quite advanced.  In this discussion, I have heard many consider the tradeoffs of 64bit pointers in the cache vs most programs requiring &lt; 4G of user space.  I offer a compromise of 48 bits, which would greatly extend the date/time issue, give space for almost all programs and still not be piggish on pointers in cache.  Of course, I presume there are plenty of downsides of this, including, perhaps, hardware issues, but if we're doing all this work anyway, changing system calls, compilers, loaders etc., maybe considering a middle ground would be useful.  Please just ignore me if it is too ridiculous.  Thanks. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/527798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor527818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The x32 system call ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 2, 2012 23:06 UTC (Sun)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/527818/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
all current hardware has significant benefits if the data is aligned properly (32 bit values aligned on a multiple of 4 bytes, 64 bit values aligned on a multiple of 8 bytes). As a result, in the normal case, 48 bit unaligned values are going to be slower to use.<br>
<p>
If you have a huge array of pointers, the memory savings will outweigh this cost, but not for the normal uses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/527818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
