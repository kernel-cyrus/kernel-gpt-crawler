        <!DOCTYPE html>
        <html lang="en">
        <head><title>A fresh look at the kernel's device model [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/645810/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/645410/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/645810/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A fresh look at the kernel's device model</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>May 27, 2015</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>Understanding the Linux device model is (or should be, at least) 
central to working with 
device drivers in Linux — and drivers constitute over half of the kernel code.
I've been working with a variety of device
drivers at differing levels of involvement for some years but until
recently I didn't feel that I really understood the model.  This is
potentially dangerous as, without a good understanding, it is easy to make
poor choices.</p>

<p>The problem, or at least <i>my</i> problem, is firmly rooted in the
terminology.  The device model involves things called &quot;device&quot;
and &quot;driver&quot;, &quot;bus&quot; and &quot;class&quot;.  To be able
to understand the model, I need accurate definitions of these terms, and
useful definitions are hard to find.</p>

<p>An <a href="/Articles/31185/">LWN article</a> from 2003
is an excellent example, as it clearly presents some definitions
of the sort that can be found in other documentation and in the source
code.  It declares a device to be: "<q>A physical or virtual object
which attaches to a (possibly virtual) bus</q>".
This sounds good and highly general, but it doesn't actually match
reality, even the reality of twelve years ago when the article was written.</p>

<p>For example, in the device model, a partition on a hard drive is a
&quot;device&quot; 
much like the hard drive as a whole is.  The hard drive as a whole may
attach to a &quot;bus&quot;, but the partition certainly doesn't: at best
it attaches to the whole drive.

Also, there are devices that don't attach to anything, let alone a
&quot;bus&quot;. The devices listed in directories under
<tt>/sys/devices/virtual</tt> are not &quot;attached&quot;
to anything.  That &quot;virtual&quot; directory is not a special bus
called &quot;virtual&quot;, it is simply a place to put things that don't
belong anywhere else.</p>

<p>Similar oversimplifications are found when trying to find definitions
of the other objects.  This is very likely because the driver model was
still under development and the meanings that would end up being useful had
not yet fully crystallized.  Now, over a decade later, the available
documentation still refers to the same terms and generally uses the same
imprecise definitions.</p>

<h4>The eye of the beholder</h4>

<p>The epiphany that allowed me to form a coherent understanding of the
device model was that none of these terms really have an external meaning
at all.  They are defined purely by the code that implements them.  A
device is simply any data structure that contains an embedded
<tt>struct device</tt>, no more and no less.</p>

<p>Meaning comes only from the mind of the developer working with the code.
Having multiple independent developers will likely result in multiple
different meanings. The meanings that seem to be associated with the terms
and that are found in documentation are the meanings that the early
developers were thinking about.  Those ideas have been revised over time,
and other developers have had other thoughts.</p>

<p>The definition &quot;anything with a <tt>struct device</tt>"
may be accurate, but is not useful for someone considering the
implementation of a new driver or modification to an old one.  Similarly
&quot;what other developers are thinking&quot; is too nebulous to be
useful.  With a bit of effort, and some carefully chosen examples, each of
these can be fleshed out a bit and together form a picture that is,
hopefully, a good start.

So, to present my understanding of the device model, and particularly of
those four terms, I will present some examples to show what other
developers have thought, and what value a <tt>struct device</tt>
provides.</p>

<p>The first example revolves around the <a
href="http://www.ti.com/product/tca6507">TCA6507</a> chip from Texas
Instruments.  This is a simple piece of hardware that accepts requests
over an &quot;i2c&quot; bus, and responds by draining current through seven
separate pins with various on/off patterns.  This is particularly intended
to pull electrical current through an LED to make it glow, but can equally
pull current through a resistor to create logic 0 or 1 levels.  This
example is chosen because it is the most &quot;device-like&quot; of devices
that I am familiar with — it perfectly fits the earlier definition.</p>

<p>The second example is the <a
href="https://www.kernel.org/doc/Documentation/workqueue.txt">workqueue</a>
mechanism in Linux. It allows arbitrary
tasks to be handed off for asynchronous completion, either promptly or
after a delay, and will attempt to make optimal use of resources in doing
so.  It is also the least &quot;device-like&quot; thing I came across.</p>

<p>With these examples in mind, together with the previously mentioned
block devices, we can proceed to those definitions.</p>

<h4>Devices</h4>

<p>A device is an instance. It is corresponds to a thing, or maybe an
&quot;object&quot; in the most general sense of the word.  A device gains
its thing-hood primarily by a person thinking that it is something worth
identifying.  A device may sometimes correspond to a specific piece of
hardware like an integrated circuit, but it could equally correspond to a
collection of such circuits or just one component of the functionality of a
circuit.  Hardware need not exist at all — a device could be virtualized or
could represent something that has no real physical equivalent at all.
It is just a &quot;thing&quot;.</p>

<p>The TCA6507 chip is represented in Linux by a device.  Each of the seven
controllable pins may be connected to something and this may lead to
more devices.

If a pin is attached to an LED, for example, then there will be a separate
device 
that represents that LED, though arguably it could be seen as
representing the signalling capability of the &quot;LED plus pin&quot;
combination.  Different people will probably look at this in different
ways.</p>

<p>If a pin is connected to a &quot;pull-up&quot; resistor and used to
signal a logic level, then it will be represented in Linux as a
&quot;GPIO&quot; — General Purpose I/O pin.  In terms of the device model, all
of the pins that are configured as GPIOs are presented as a single
&quot;gpiochip&quot; device.  So while there is one device for
<em>each</em> LED, there is one device for <em>all</em> GPIOs.</p>

<p>Each individual GPIO can be configured and used internally, or may be
exported to user space through <tt>sysfs</tt>.  When a GPIO is
exported, a new device is created to represent just that one GPIO.  This is
visible as a directory under <tt>/sys/class/gpio</tt>;
files are available there that can be used to set the output level to 1 or
0.</p>

<p>There are two important lessons in this example.  One is that choices are
context-dependent and probably very developer-dependent as well.  Grouping
GPIOs into a &quot;chip&quot; seems to make sense, while doing the same with
LEDs doesn't seem to be a priority, though there has been a <a href="http://comments.gmane.org/gmane.linux.leds/1929">suggestion</a>
that there might be value in that.

The second lesson is that one reason to make a &quot;thing&quot; into a
&quot;device&quot; in the device model is so that it can appear in
<tt>sysfs</tt> and be directly examined or manipulated.</p>

<p>Moving on to our second example we find something that is not at all
&quot;device-like&quot;.  There are many &quot;things&quot; or
&quot;instances&quot; in Linux that are not device-like and are not
represented as devices: filesystems and processes are obvious examples.
One that <i>is</i> represented as a device is the workqueue.</p>

<p>The workqueue subsystem in Linux creates a &quot;device&quot; to
represent each distinct queue.  The <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=226223ab3c4118ddd10688cc2c131135848371ab">apparent
reason</a> for this is much like the reason for (sometimes) making devices
for GPIOs — it allows the thing (i.e. the workqueue) to be examined and
managed via <tt>sysfs</tt>.  A thing doesn't <em>have</em> to be a
device to appear in <tt>sysfs</tt>, modules and filesystems are clear
counter-examples to that idea.  But making something a &quot;device&quot;
is a relatively easy and well-worn path to <tt>sysfs</tt> access.</p>

<p>The compelling reason to use a &quot;device&quot; to represent some
&quot;thing&quot; seems to be the interfaces.  A &quot;device&quot; not
only has standard interfaces in sysfs, it also has standard interfaces for
power management, and may make use of internal services (like the
<a href="/Articles/222860/">devm resource management API</a>)
that are only
provided to devices.  There is also useful functionality for grouping
&quot;like&quot; devices together, for varying definitions of
&quot;like&quot;.</p>

<h4>Classes</h4>

<p>A &quot;class&quot; is both the implementation of a set of devices, and
the set of devices themselves.  A class can be thought of as a driver in
the more general sense of the word.  The device model has specific objects
called &quot;drivers&quot; but a &quot;class&quot; is not one of those.</p>

<p>All the devices in a particular class tend to expose much the same
interface, either to other devices or to user space (via sysfs or
otherwise).  Exactly how uniform the included devices are is really up to
the class 
though.  It is not unusual for there to be optional aspects of an
interface that not all devices in a class present.  It is not unheard-of
for some devices in the same class to be completely different from others.</p> 

<p>So far we have met three classes in our examples.  A device that
represents an LED attached to a TCA6507 is a member of the &quot;leds&quot;
class.  This class supports the blinking, flashing, and brightness control
features of physical LEDs.  The class requires an underlying device to be
available, such as a TCA6507 or a GPIO or any of various other
options.  This underlying device must be able to turn the LED on or
off, may be able to set the brightness, and might even provide timer
functionality to autonomously blink the LED with a given period and
duty cycle.  The &quot;leds&quot; class hides as much of this detail as it can
to provide a simple abstract device.</p>

<p>Similar to the &quot;leds&quot; class is the &quot;gpio&quot; class;
it provides a uniform interface to a variety of devices that can
generate (output) or can sense (input) an electrical logic level.  If the
underlying device can generate an interrupt on a level change,
&quot;gpio&quot; can translate that to a notification via <tt>poll()</tt>
or can route it to the interrupt handler for some other device.  The gpio
class provides both the &quot;gpiochip&quot; devices and the individual
&quot;gpio&quot; devices.</p>

<p>The third class we have met is the &quot;disk&quot; class
which provides both whole hard drives and partitions within drives.  As with
the &quot;leds&quot; class, there are a few different interfaces to storage
functionality that can be provided and the &quot;disk&quot; class presents
a unified interface to that functionality.</p>

<p>There is some obvious similarity between the &quot;gpio&quot; class
implementing both &quot;gpios&quot; and &quot;gpiochips&quot;, and the
&quot;disk&quot; class implementing both &quot;disks&quot; and
&quot;partitions&quot;.  There are also differences.

One of those is that &quot;gpio&quot; and &quot;gpiochip&quot; provide
completely different interfaces, while &quot;disk&quot; and
&quot;partition&quot; have a lot of commonality in their interfaces — both
have block sizes and support I/O, but only a &quot;disk&quot; can be
&quot;removable&quot;.</p>

<p>Another, less obvious difference involves another aspect of the device
model.  Each &quot;device&quot; can have a &quot;type&quot;.  This type is
often presented in the &quot;uevent&quot; file in the relevant
<tt>sysfs</tt> directory.  For example, the command:</p>
<p>
<pre>
    grep DEVTYPE /sys/class/block/*/uevent
</pre>

<p>will show the type of every block device on your
system.  The different types in the &quot;gpio&quot; class are not known to
the device model, though, so they are not reported by the
<tt>uevent</tt> file. 
A human or a script would need to deduce the type from the device names if it
was important.</p>

<p>Each of the classes listed here can be seen as providing a generic
interface over a range of different hardware.  This seems to be
part of the original intention of the &quot;class&quot; facility.  
However "generic" isn't a very precise term.  What one developer sees as
   "generic" another developer might see as "specific".  These perspectives
   can change over time too, particularly if a simple or successful interface
   gets used more broadly than its initial context.

<p>To enforce this point it is worth briefly considering the
&quot;backlight&quot; class of devices.  A backlight for a graphics
display can use a number of different underlying technologies, including a
device of the &quot;leds&quot; class.  So depending on your perspective, an
LED might be a generic interface for signaling, or a specific underlying
technology for backlighting.  It depends on whose eye is beholding.</p>

<h4>Buses</h4>

<p>A &quot;bus&quot; is similar to a &quot;class&quot; in several ways, but
it has an important difference.  While a class is a complete
implementation of the devices that are members of that class, the
bus is only a partial implementation.  For complete
functionality, a bus usually works with a set of &quot;drivers&quot;.

A bus may implement some devices completely by itself, like a
class does.  Other devices will require a driver to be
attached.  The choice of driver can be made by the bus, by the
driver (which can be asked if it &quot;matches&quot; a given
device), or by a request through <tt>sysfs</tt>.</p>

<p>Our examples so far provide two examples of buses.  The
workqueue subsystem defines a &quot;workqueue&quot;
bus to hold the devices that it creates for each workqueue.  The set of
drivers for this bus is empty.  There are no separate
implementations and no indication that there ever might be.  This is
probably the most minimal structure that a bus can have.</p>

<p>The other example, which has not yet been made explicit, is the
<a
href="http://en.wikipedia.org/wiki/I%C2%B2C">i2c</a> bus,
which is a standard two-wire bus for communicating between integrated circuits,
typically all on 
a single board.  This is the bus that is used to control the TCA6507, so
the <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/leds/leds-tca6507.c?id=030bbdbf4c833bc69f502eae58498bc5572db736">leds-tca6507</a>
driver is written to work with the &quot;i2c&quot; bus in Linux.</p>

<p>The &quot;i2c&quot; bus in the device model is a collection of code
that provides interface support between an individual driver like
leds-tca6507 and some i2c bus master such as the <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/i2c/busses/i2c-omap.c?id=030bbdbf4c833bc69f502eae58498bc5572db736">OMAP
I2C</a> controller.  It manages bus arbitration, retry handling, and
various other protocol details.

The &quot;i2c&quot; bus thus supports two different types of
device, though the distinction is not directly visible in
<tt>sysfs</tt> as the types are not given textual names.</p>

<p>The <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/i2c/i2c-core.c?id=030bbdbf4c833bc69f502eae58498bc5572db736#n744"><tt>i2c_client_type</tt></a>
includes all devices that are 
supported by separate drivers and represent hardware that can be
communicated with via the i2c protocol.

The <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/i2c/i2c-core.c?id=030bbdbf4c833bc69f502eae58498bc5572db736#n1210"><tt>i2c_adapter_type</tt></a>,
instead, is implemented in the i2c
bus code without using a separate driver.  It represents the whole
bus and exposes a character-special device in <tt>/dev</tt>
(e.g. <tt>/dev/i2c-0</tt>) that can be used to interact directly with
i2c clients, bypassing any driver.</p>

<p>By providing code and device support to both the client (or slave) side
and the adapter (or master) side of an electrical bus, the Linux
&quot;i2c&quot; bus very clearly represents the whole i2c bus.
When there is
  an electrical bus to represent, a device model bus will often fill that
  role.  When there is no electrical bus, as with workqueues, a bus might
  represent something else entirely.</p>

<p>Devices in a bus tend to reflect specific hardware rather than generic
functionality, but once again it is hard to draw a clear line.  One of the
many drivers for the &quot;usb&quot; bus is the &quot;usbhid&quot; driver
that supports any mouse, keyboard or similar &quot;human interface
device&quot;.  This isn't really very specific.</p>

<h4>When is a bus not a bus?</h4>

<p>I had a particular reason for choosing an &quot;leds&quot; device as one
of the examples, and that is because the &quot;leds&quot; class has a
particularly interesting structure.

Each &quot;leds&quot; device exposes a &quot;trigger&quot; attribute in
sysfs.  This file contains a list of all possible triggers, the currently
active one surrounded by brackets.  For example:</p>

<blockquote>
<pre><tt>none usb-gadget usb-host cpu0 cpu1 cpu2 cpu3 cpu4 cpu5 cpu6 cpu7
AC-online BAT0-charging-or-full BAT0-charging BAT0-full
BAT0-charging-blink-full-solid [mmc0] rfkill1 phy0rx phy0tx phy0assoc
phy0radio phy0tpt rfkill2 rfkill3 rfkill33
</tt></pre>
</blockquote>

<p>Writing the name of some trigger to this file will locate the driver for
that trigger, loading a module if necessary, and will configure the device
to use that trigger.  This may involve presenting different attributes via
<tt>sysfs</tt>.

This mechanism for binding a trigger to an &quot;leds&quot; device is
extremely similar to the mechanism that a bus
provides to bind a driver to a device.  Lots of the details are different,
but the core functionality and purpose are the same.</p>

<p>We saw earlier that the workqueue subsystem, despite being a
bus, had no separate drivers and so could have been a
class. Here we see that &quot;leds&quot;, despite being a
class, has a number of separate drivers (called
&quot;triggers&quot;) and so could have been a bus.  This seems
to emphasize that fact that the choice of bus or
class, like the particular role of a device, is
truly in the eye of the beholder.  There is no firm external meaning.</p>

<p>We can get a hint of what meaning one developer saw by examining the <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/workqueue.c?id=030bbdbf4c833bc69f502eae58498bc5572db736#n4911">declaration</a>
and registration of the &quot;workqueue&quot; bus.  It is declared:</p>
<p>
<pre>
    static struct bus_type wq_subsys = { /* ... */ };
</pre>

<p>and registered:</p>
<p>
<pre>
    return subsys_virtual_register(&amp;wq_subsys, NULL);
</pre>

<p>So, while it is a <tt>bus_type</tt>, it is named as a
&quot;subsys&quot; or &quot;subsystem&quot; and registered as a
&quot;virtual subsystem&quot;.  It seems the eye of at least one developer
looked at a &quot;bus&quot; and saw a &quot;subsystem&quot;.</p>

<p>There appears, both here and elsewhere, to be a desire to discard the
separate concepts of &quot;class&quot; and &quot;bus&quot; and instead just
have &quot;subsystems&quot;.  A subsystem would be exactly what
a bus is, but without all the baggage that comes with the
name.  As a class provides nothing that is not provided by a
bus, it could simply be dropped.  Whether this transition will
ever be complete remains to be seen.</p>

<h4>A lesson learned</h4>

<p>This, then, is the lesson of the driver model: the implementation
provides functionality, not meaning.  The meaning comes from the thoughts
of developers and is coherent or disjoint in the same measure that those
developers are of one mind, or not.</p>

<p>A &quot;device&quot;, is just a thing that provides and consumes
interfaces.  It represents an idea more than it represents any particular
hardware.

A &quot;bus&quot; is better known as a &quot;subsystem&quot; and is some
code to implement devices together with a mechanism to attach separate
&quot;drivers&quot; to those devices.  A bus (or subsystem) is also the set
of device associated with that code.

A &quot;class&quot; is just a bus without the mechanism for
separate drivers.

And a &quot;driver&quot; is code that works in concert with a particular
bus to implement certain devices.

<p>These definitions helped me to lose the baggage that I tried to
associate with &quot;device&quot; and &quot;bus&quot; and provided clearer
understanding.  But it is not yet enough for a complete understanding.
Devices do not exist in isolation — they have those interfaces for a
reason.  A full understanding of the device model requires some
understanding of how they all fit together and a good place to look at that
is in <tt>/sys/devices</tt> which contains all the devices on a
particular system.</p>

<p>So next week we will dive in to <tt>/sys/devices</tt> and find out
how that directory tree is structured, what it contains, and what more we
can learn about devices.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Device_model">Device model</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/645810/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor646514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 10:08 UTC (Fri)
                               by <b>vrfy</b> (guest, #13362)
                              [<a href="/Articles/646514/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The so called "driver model" seemed never really thought through; even that time it appeared more like an export of the implementations how specific things worked, than an attempt to consistently "model" something to export to internal and external users. It was and still is over-complicated, and some part never made much sense when expressed in the kernel or when it was to be consumed by userspace.<br>
<p>
In the past, we have removed and unified 3 needlessly different types of device (struct class_device, struct sys_device) from the "driver model". We merged the separate "block" subsystem into a class. We merged the confusingly separated hierarchies of devices into one single tree (people started to express hierarchies of devices in /sys/class).<br>
<p>
The simple idea is that the "devices" of the system show up in one single tree at /sys/devices. Devices of a common type have a "subsystem" symlink pointing back to the subsystem's directory. All devices of that subsystem are listed there.<br>
 - /sys/devices is the single unified hierarchy of all devices, used to express parent/child relationships<br>
 - /sys/{bus,class} is home of the subsystem, the grouping/listing of devices of this type, used to lookup devices by subsystem + name<br>
<p>
So at least the "device" itself and /sys/devices is something that looks kind of reasonable to consume today.<br>
<p>
That subsystems are still called class and bus makes not much sense and it should be replaced by /sys/subsystem, and compatibility provided by symlinks only. /sys/class is conceptually insufficient, it cannot safely expose subsystem knobs, because it is a single directory occupied by the list of devices of that subsystem. There is no place for safely exposing other information. /sys/bus in contrast is fine, it has a "devices" subdirectory.<br>
<p>
The distinction of bus vs. class never made much sense. For that reason, udev internally merges the view of them and only exposes "subsystem", it refuses to distinguish "bus" and "class". Even 8 years old udev versions would already start using /sys/subsystem if it appeared today :)<br>
  <a href="http://cgit.freedesktop.org/systemd/systemd/commit/?id=5ac285437500a857f69d8b883d5aac3692662d0f">http://cgit.freedesktop.org/systemd/systemd/commit/?id=5a...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor646522"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 11:05 UTC (Fri)
                               by <b>HIGHGuY</b> (subscriber, #62277)
                              [<a href="/Articles/646522/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've always thought of a bus as an addressing/enumeration context and a place where drivers are matched to devices.<br>
<p>
My most recent use of buses is an PCIe-connected FPGA's memory map exposing various pieces of functionality, so a new fpga bus was created where subdrivers are matched to ranges of the FPGA's memory map. Here too, each subdevice is addressible within the bus by using the starting address.<br>
<p>
Probably in the workqueue example as well is i2c/spi/pci/... devices attached to a bus are enumerated in a particular way, which implies they are somehow individually addressable within the bus context.<br>
<p>
Classes, as you mention, group devices by common functionality, instead.<br>
<p>
But you have clearly identified that there are many other uses... Apparently they're just tools in the driver writer's toolbox...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646522/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor646586"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2015 17:19 UTC (Fri)
                               by <b>Alan.Stern</b> (subscriber, #12437)
                              [<a href="/Articles/646586/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is one important point that argues against merging the "class" and "bus" concepts into one.  Namely, a device can belong to both a bus and a class -- but it can't belong to two buses or two classes.<br>
<p>
Another interesting point worth mentioning: When the device model was originally created, a large part of the motivation was to have a single common framework for power management.  In particular, for system suspend (runtime PM was not added to the kernel until considerably later).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646586/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor646665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2015 0:15 UTC (Sat)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/646665/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Namely, a device can belong to both a bus and a class</font><br>
<p>
I can see how this is possible. I'm having trouble seeing how it is useful.  Is there an example I can look at?<br>
<p>
I can almost imagine that a bus might be able to include some of its devices in one class and some in another class.  But I think I would either just make them different types, or have two related devices, one in the bus one in the class.  Maybe an example will help clarify for me.<br>
<p>
Thanks!<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor647352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2015 17:22 UTC (Sat)
                               by <b>Alan.Stern</b> (subscriber, #12437)
                              [<a href="/Articles/647352/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can't think of any examples.  In practice, drivers embed multiple struct devices in their private data structures.  Generally one of these devices belongs to a bus and the others to classes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor647192"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2015 11:46 UTC (Thu)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/647192/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Namely, a device can belong to both a bus and a class -- but it can't belong to two buses or two classes.</font><br>
<p>
Doesn't multi-path I/O break this constraint by having the same piece of hardware accessible through multiple hardware busses? Then a bus address identification no longer identifies an unique device, and there would possibly be fewer hardware devices than there are bus addresses associated with them. Conceptually there's little that stops a PCI-like hardware bus from being accessible through multiple bridges as well, e.g. in some weird-arse redundant cluster environment.<br>
<p>
This whole set-up sounds like an ad-hoc reimplementation of a shitty Java, with "struct device" corresponding to the Object base class, and classes to interfaces, but only permitting one class per device (thereby e.g. splitting multi-class devices into many and a "parent" device that handles PM for them all). The temptation to tear it down for simplification's sake is obvious. However, there's a lot of good in having a structure that forbids explosions of abstract hierarchy wank during future development, especially when the obvious alternative would replace the structural hierarchy with a more homogenous structure (i.e. like Java, but not as shittily) and force a mild level of such wank for an ante to achieve functional parity.<br>
<p>
Really the question is: what are the policies associated with the flexibly homogeneous substitute, and how do they combine to a better outcome in the next 15 years than the current status? Does having such policies, instead of program-defined structure, reduce the kernel's architectural strength? If so, shouldn't that policy be part of the kernel in some way that retains that strength (by e.g. being as much subject to debate as changes to code are) to the degree that historically-proven code does?<br>
<p>
The "Unix way" is, roughly speaking, one where the kernel provides low-level mechanisms that arise from the combined natures of hardware and OS concepts, and lets consumers define policy to their detriment alone. With udev and the other freedesktop.org stuff we've seen over the past decade, this separation has become reversed: now userspace policy is entering the kernel and influencing its architecture. This trend is not currently showing signs of being about to reverse, so I question whether it should have a potential in-road to the eventual flattening (and thereby vendorization) of device drivers within the kernel.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647192/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor646920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2015 21:36 UTC (Mon)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/646920/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Duck test for device: If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.<br>
<p>
The choice of GPIO as an example is maybe more confusing than other examples could be, and I'm saying that as GPIO maintainer. Look closer at it:<br>
<p>
First &lt;linux/gpio/driver.h&gt;: obviously it contains struct device *dev --- wait --- a *pointer* to a device, so it is not really a device after all as it does not embed a struct device, it merely happy refers to what other subsystems would call its parent. Avoids creating a new device for the GPIO chip since there is usually or rather always one underneath, i2c device or platform device or even USB or PCI device.<br>
<p>
Then the class and per-gpioline-devices ... well configure out CONFIG_GPIO_SYSFS and none of them exist. So according to the logic that if it walks like a duck and talks like a duck ... all of GPIO's struct device and struct class is merely a means of getting a userspace ABI in sysfs, as is hinted at in the article.<br>
<p>
Would it be better to have a "real" struct device embedded inside the struct gpio_chip? You bet. Whoever does that refactoring will be a hero. And possibly a struct device inside each GPIO descriptor too then, if this stinking sysfs ABI should prevail. But I would prefer to make all of that sysfs legacy and replace GPIO access with a chardev /dev/gpiochipN that use ioctl() instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/646920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor647028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2015 22:43 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/647028/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Duck test for device: If it looks like a duck,....</font><br>
<p>
I don't think there is much agreement on what a "device" looks like though.<br>
<p>
<font class="QuotedText">&gt; But I would prefer ...</font><br>
<p>
which lends weight to my point - different people prefer different things, each for excellent reasons.<br>
<p>
Thanks for the extra details on GPIOs - they seem to confirm that "device" has no real meaning, it is just a tool in the developer's tool box.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor647253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2015 3:24 UTC (Fri)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/647253/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a great idea for an article series. I can't claim it all made sense to me (the, seeming, arbitrary nature of the implementations of just crying out for stricter rules now that we've a large sample set of devices to generalize from--with legacy devices being exempt) but I've a much clearer idea of what is meant by devices and their related interfaces.<br>
To sum up: a device is a thing, and you can choose to ignore implementing it in class.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor647335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fresh look at the kernel's device model</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2015 6:45 UTC (Sat)
                               by <b>xxiao</b> (guest, #9631)
                              [<a href="/Articles/647335/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope the forthcoming LDD3 book can pull in these.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/647335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
