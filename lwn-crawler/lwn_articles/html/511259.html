        <!DOCTYPE html>
        <html lang="en">
        <head><title>Signed overflow optimization hazards in the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/511259/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/510443/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/511259/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Signed overflow optimization hazards in the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="GAByline">
           <p>August 15, 2012</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<p>A recent <a href="http://lwn.net/Articles/508991/">LWN article</a>
described a couple of the hazards that compiler optimizations can pose
for multithreaded code.
This article takes a different approach, looking at a compiler-optimization
hazard that can also strike sequential code.
This hazard stems from an annoying aspect of the C11 standard,
namely that signed-integer overflow is undefined (Section 3.4.3).
<p>
Overflow is a consequence of the fact that a computer's
native arithmetic capability is quite limited.
For example, if a C program running on a typical Linux system 
tries adding one <code>int</code> variable with value 2,147,483,647 to another
<code>int</code> with value&nbsp;1, the result will be
-2,147,483,648&mdash;which might surprise people who naively
expect the mathematically correct value of +2,147,483,648.
This deviation from mathematical correctness occurs
because the machine cannot represent the correct value of
2,147,483,648 in a 32-bit
<a href="http://en.wikipedia.org/wiki/Two's_complement">twos-complement</a>
integer.
Therefore, any attempt to compute this number without
<a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">help</a>
from software will result in overflow.


<div class="tlr">
<p><a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
Yecch!!!
Why can't CPU designers come up with something better?
<br><a href="#qq1answer">Answer</a>
</div>

<p>The number -2,147,483,648 is &ldquo;unusual&rdquo; in that adding it to
itself (again, using twos-complement 32-bit integers) results in zero.
Furthermore, it is its own negative: negating -2,147,483,648 results in
-2,147,483,648.
Therefore, this
<a href="http://en.wikipedia.org/wiki/Two's_complement#The_most_negative_number">weird number</a>
is (1)&nbsp;equal to half of zero and (2)&nbsp;both positive and negative
but (3)&nbsp;not equal to zero.
This weirdness earned this number a special mention in the C standard,
which says that its handling is implementation-defined
(Section 6.2.6.2, Paragraph 2).

<p>Unfortunately, relying on signed integer overflow for both
normal and weird values is extremely
convenient when working with free-running counters.
For example, suppose that our program is dealing with a succession of
work items, each designated by an integer.
Suppose further that this code might be called upon to report on
the past and future 25 work items.
This situation will likely require a fast way to distinguish between
past, current, and future work.
Signed twos-complement integers make this easy.
If <code>current</code> is the integer corresponding to the current
work item,

<pre>
    (current - other &gt; 0)
</pre>

<p>will evaluate to <code>true</code> if the <code>other</code> work item
is from the past.
This works, even if the counter hits the maximum value and wraps around,
due to the circular nature of twos-complement integers: 
adding one to the largest positive number that can be represented
results in the smallest negative number.  As a result, there is no need to
write special-case code to handle counter overflows.

<p>The simplicity of this approach has caused coders to willfully ignore
the undefined nature
of C signed-integer overflow since well before the dawn of Linux.
For example, I was happily relying on twos-complement semantics
from C signed-integer overflow in the early 1980s, and the only reason
I wasn't doing so earlier was that I wasn't using C any earlier.
Nor am I alone.
Here are a couple of representative code fragments from version 3.5
of the Linux kernel:

<pre>
    if (auth_vnode-&gt;acl_order - acl_order &gt; 0) {

    return (int)(tcmp - __raw_readl(timer_base + MX1_2_TCN)) &lt; 0 ?  -ETIME : 0;
</pre>

<p>The first is from <code>afs_cache_permit()</code> in
the AFS filesystem, which is using this pattern
to sort out the order of events in a distributed filesystem.
The second example is from <code>mx1_2_set_next_event()</code> in the ARM
architecture, which is using a variation on this theme to determine
whether the requested event time really is in the future.
Here the actual subtraction is unsigned, but the result is cast
to a signed integer.

Because unsigned longs are always positive,
the only way that the result can be negative (when interpreted as a signed
value) is overflow, which the compiler
is permitted to assume never happens.
The compiler is therefore within its rights to unconditionally evaluate the
test as <tt>false</tt> and return
zero, which might fatally disappoint the caller.

<p>In addition, there used to be several instances of this pattern
in the Linux kernel's RCU implementation, where it was used to figure
out whether a given request had been implicitly satisfied due to the
efforts undertaken to fulfill concurrent requests of the same type.
These have since been converted to use unsigned arithmetic using the
technique described below.  

<p>One might well ask: is there really a problem here?
All systems running Linux are twos complement, so we really should not
worry about clauses in the C standard designed to handle the wider variety
of arithmetic that was available a few decades ago, right?

<p>Unfortunately, wrong.
The C compiler can and does make use of undefined behavior when
optimizing.
To see this, consider the following code:

<pre>
     1 long long_cmp_opt(const int a, const int b)
     2 {
     3   if (a &gt; 0) {
     4     do_something();
     5     if (b &lt; 0) {
     6       do_something_else();
     7       if ((a - b) &gt; 0)
     8         do_another_thing();
     9     }
    10   }
    11 }
</pre>

<p>At line&nbsp;7 the compiler knows that the variable <code>a</code>
is positive and the variable <code>b</code> is negative.
Therefore, ignoring the possibility of integer overflow, the compiler
knows that this &ldquo;if&rdquo; condition will always evaluate to
<code>true</code>, meaning that the compiler is within its rights to
invoke <code>do_another_thing()</code> unconditionally, without actually
doing the subtraction and comparison.
In contrast, if <code>a</code> is (say) 2,147,483,647 and <code>b</code> is
-2,147,483,648, the unoptimized code would avoid invoking
<code>do_another_thing()</code>.
Therefore, this optimization has significantly changed the program's behavior.


<div class="tlr">
<a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
But just how often is the compiler going to know
the sign of both the values???
<br><a href="#qq2answer">Answer</a>
</div>

<p>Of course, in real life, overflow really can occur.
But because the C standard says that signed overflow is undefined,
the compiler is permitted to do whatever it wishes in the overflow case.
And GCC&nbsp;4.6.1 really does omit the subtraction and comparison
when compiling this example for x86 at optimization levels of
<code>-O2</code> or higher. 

<p>Fortunately for the Linux kernel, GCC will generate the
 subtraction and comparison for <code>-O1</code> or less.
But optimizations can migrate to lower optimization
levels over time, and there may come a time when either performance
or energy-efficiency considerations motivate the
Linux kernel to move to higher optimization levels.
If that happens, what can be done?

<div class="tlr">
<a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
First you were talking about overflowing, now about wrapping.
Consistent terminology, please?
<br><a href="#qq3answer">Answer</a>
</div>

<p>One approach is to move to unsigned integers for free-running counters.
The C standard defines unsigned integers to use modular arithmetic,
so that wrapping the counter is fully defined (Section 6.2.5 Paragraph 9).

<p>Of course, checking for counter wrap must be done differently.
For purposes of comparison, here is the (undefined) signed version:

<pre>
    if ((a - b) &lt; 0)
</pre>

<p>And here is the corresponding version for unsigned long types:

<pre>
    if (ULONG_MAX / 2 &lt; a - b)
</pre>

<p>This version relies on the fact that, bit for bit, twos-complement
addition and subtraction are identical to their unsigned counterparts.
Now, the bitwise representation of the constant <code>ULONG_MAX / 2</code> is
a zero bit followed by all one-bits, which is the largest value that
does not have the most-significant bit set.
Therefore, if the result of computing <code>a&nbsp;-&nbsp;b</code> is greater
than this constant, we know that this result has its uppermost bit set.
Because the uppermost bit is the sign bit for twos-complement numbers,
we are guaranteed that the signed and unsigned versions compute identical
results.

<p>Of course, the unsigned version is more characters to type, but that
is what inline functions and C-preprocessor macros are for.
But what about the code that the compiler generates?
After all, the Linux kernel absolutely does not need extra instructions
loading large constants for each comparison!

<p>The good news is that GCC actually generates <i>exactly</i> the same
code for both of the above versions when compiled with <code>-O1</code>
on both x86 and PowerPC:

<pre>
   /* x86 code. */
      e:	8b 44 24 04          	mov    0x4(%esp),%eax
     12:	2b 44 24 08          	sub    0x8(%esp),%eax
     16:	c1 e8 1f             	shr    $0x1f,%eax
</pre>

<pre>
   /* PowerPC code. */
     1c:   7c 64 18 50     subf    r3,r4,r3
     20:   78 63 0f e0     rldicl  r3,r3,1,63
</pre>

<p>Of course, there will be times
when the Linux kernel absolutely must rely on undefined behavior.
However, this is not one of those times:  As shown above, there are
straightforward ways to avoid relying on signed integer overflow.
Removing the kernel's reliance on signed integer overflow could
avoid our getting burned by increasingly aggressive optimization, and
might further allow use of higher optimization levels to improve
performance and battery lifetime.
So it is not too early to start future-proofing the Linux kernel
by removing its reliance on signed integer overflow!

<h3><a name="Answers to Quick Quizzes">
Answers to Quick Quizzes</a></h3>

<dl>
<dt>
<a name="qq1answer"></a>
<p><b>Quick Quiz 1</b>:
Yecch!!!
Why can't CPU designers come up with something better?

</dt>
<dd>
<p><b>Answer</b>:
CPU designers have come up with a
<a href="http://en.wikipedia.org/wiki/Signed_number_representations">variety of schemes</a>
over the decades.
However, in my experience, each scheme has its own peculiarities.
I have used ones complement and twos complement,
and dealing with the peculiarities of twos complement proved easier for me
than those of ones complement.

<p>That said, I suspect that the dominance of twos complement was not due
to ease of use, but rather due to
the fact that it allows a single hardware adder to perform both
signed and unsigned computations.


</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>
</dd>
<dt>
<a name="qq2answer"></a>
<b>Quick Quiz 2</b>:
But just how often is the compiler going to know
the sign of both the values???
</dt>

<dd>
<p>
<b>Answer</b>:
The more inline functions we add, the higher the probability
that the compiler will be able to infer all sorts of things about the
values in question, including their sign.
And it only takes one unwanted optimization for the Linux kernel to fail.

</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>
</dd>

<dt>
<a name="qq3answer"></a>
<b>Quick Quiz 3</b>:
First you were talking about overflowing, now about wrapping.
Consistent terminology, please?
</dt>

<dd>
<p>
<b>Answer</b>:
Interestingly enough, the C standard does not define overflow for
unsigned integers.
Instead, it defines the unsigned integral types to use modular
arithmetic so as to eliminate the possibility of overflow.
Aside from things like division by zero, that is.
The term &ldquo;wrap&rdquo; works regardless.


</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>
</dd>
</dl><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#GCC">GCC</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/511259/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor511609"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 3:40 UTC (Thu)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/511609/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's worth pointing out that the optimizations resulting from "signed counters can't overflow" can be pretty useful, since it can allows the compiler to figure out loop sizes e.g. "This loop runs either 8 times exactly, or it overflows; so it runs 8 times— unrolling and vectorizing".<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511609/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 21:53 UTC (Thu)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/511889/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bingo.  This is also why it's particularly bad to use unsigned loop counters.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:19 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511894/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So the kernel's current use of -fno-strict-overflow is presumably disabling a number of optimizations.  How much performance would you two guess that the kernel is giving up?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:45 UTC (Thu)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/511900/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's hard to say—<br>
<p>
First, for code in the kernel, I assume that vectorizing is off the table because IIRC the kernel doesn't normally use the XMM registers to avoid saving them... so thats a chunk of the benefit that wouldn't exist in the kernel.<br>
<p>
Branch prediction is often effective enough to make the looping cost small. But not always. I've seen easily measurable gains in numerical code performance just from reorganizing things so the compiler could find limits and unroll, but it doesn't always matter.<br>
<p>
The most obvious thing to do would be to compile the kernel without the switches and hope that it runs long enough to run a few benchmarks. :)<br>
<p>
Another issue is that overflow is _usually_ a bug where it exists (Yes, there are plenty of times where a programmer is using it intentionally but they are far less common than cases where an overflow is a bug). By preferring to use signed values and preventing overflow where you won't handle it, and using unsigned only where you must for range or where you intend overflow you make tools that catch bugs with dynamic instrumentation of overflow far more powerful. ( E.g. <a href="http://embed.cs.utah.edu/ioc/">http://embed.cs.utah.edu/ioc/</a> ). Though since no one is applying these sorts of tools to the kernel I guess it doesn't matter currently. :)<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 17:20 UTC (Sat)
                               by <b>ppisa</b> (subscriber, #67307)
                              [<a href="/Articles/512248/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would worth to compile and run kernel for MIPS with GCC option -ftrapv, if its actual GCC implementation is not broken in the current GCC version. MIPS has wrapping (addu, addiu) and signed overflow generation (add, addi) variants of the instructions. But wrapping variants are used even for signed types to keep compatibility with usual C code writeup manners.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor511887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:47 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/511887/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I really doubt that using -fnowrapv or the equivalent provides much of a performance boost in practice.<br>
<p>
Most of the examples I've seen have been of the form "aha!  I can (incorrectly) assume that this if statement that the programmer put here is a no-op!"  In all of these cases I've seen, the "optimization" is something that a good programmer could have and probably would have done manually anyway.<br>
<p>
I'd really like to see some real-world performance numbers about the effects of this optimization.  Based on everything I've seen so far, this is a case where compiler writers got so carried away considering what they _could_ do, that they didn't stop to think if they _should_.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 23:10 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/511910/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still feel a little confused by this.  If you have a loop like this:<br>
<p>
<font class="QuotedText">&gt; int i;</font><br>
<font class="QuotedText">&gt; for (i = 0; i &lt; 5; i++) {</font><br>
<font class="QuotedText">&gt;  [expression not involving i]</font><br>
<font class="QuotedText">&gt; }</font><br>
<p>
I don't see how -fnowrapv will prevent you from unrolling the loop.  You know that starting at 0 and adding 1 will get you to 5 before it will get you to overflow.<br>
<p>
I guess you could come up with a scenario where you don't know the initial value of the counter, but you do have a constant positive increment and a set upper limit.  So something like this:<br>
<p>
<font class="QuotedText">&gt; for (i = function_from_another_translation_unit(); i &lt; 5; i++) {</font><br>
<font class="QuotedText">&gt;  [expression not involving i]</font><br>
<font class="QuotedText">&gt; }</font><br>
<p>
Even in this case, though, you still know that either you'll run the loop no times, or there will be no overflow.  You have to get to something like this to start seeing a problem:<br>
<p>
<font class="QuotedText">&gt; for (i = function_from_another_translation_unit(); i &lt; 0x7ffffffe; i += 2) {</font><br>
<font class="QuotedText">&gt;  [expression not involving i]</font><br>
<font class="QuotedText">&gt; }</font><br>
<p>
This is pretty exotic scenario, though.  If i starts off as 0x7fffffff and -fwrapv is enabled, the loop will never terminate, whereas with -fnowrapv it's undefined.  To me, this feels like buggy code in the first place, so I don't really care if it's not optimized.<br>
<p>
Am I missing something here?  Is there a good example of a real-world scenario where -fnowrapv helps well-written code?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 22:56 UTC (Sat)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/512285/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>Where I've heard it coming up is when you have code that effectively looks like this:</P>
<PRE>
    for (i = x; i < x + 16; i++)
    {
        /* code that does not modify either x or i */
    }
</PRE>
<P>
The compiler wants to know it's safe to assume this loop goes around 16 times.  That isn't true if "x + 16" could overflow.
</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/512285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2012 7:22 UTC (Mon)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/512394/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The compiler wants to know it's safe to assume this loop goes around 16 times. That isn't true if "x + 16" could overflow.</font><br>
<p>
If you want to make it explicit, there's a flag for this in GCC: -funsafe-loop-optimizations (along with -Wunsafe-loop-optimizations if you want to know when it happens; it's a warning, though, so beware of build environments which insist on -Werror). AFACT there are two cases handled by this flag: assuming that the loop counter does not overflow, and assuming that the loop is not infinite. Don't know the exact implementation details, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor511919"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 23:10 UTC (Thu)
                               by <b>klossner</b> (subscriber, #30046)
                              [<a href="/Articles/511919/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, a good programmer should have done that.  But the C compiler is often presented with automatically-generated code that has never been seen by human eyes, for example after several levels of macro expansion have done their work.  Folding out the resulting dead code is often a substantial win.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511919/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor512144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 19:09 UTC (Fri)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/512144/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <pre>
int find(char *s, char c, int lim)
{
  for (int i = 0; i != lim &amp;&amp; s[i]; i++)
    if (s[i] == c)
      return i;
  return -1;
}

int main()
{
  find("foo", 'o', 1);
  find("foo", 'o', -1);
}
</pre>

<p>If the compiler inlines the second call, it can drop the "i != lim" test by assuming that overflow is impossible.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/512144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor512494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2012 16:45 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/512494/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You don't believe vectorization can significantly speed up code?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2012 7:58 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/512634/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As someone who insists on rebuilding some of Debian's packages for my own machine (for fun and not for profit), I can tell that vectorization very rarely has any significant impact. Yes, it can provide a great boost in some synthetic benchmarks or maybe in HPC code (but then, HPC code relies more on optimization by hand and leaves little to the compiler, as I understand it), but very few loops in real-world code are well-formed enough to be suitable for auto-vectorization. I won't make your browser visibly faster :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2012 14:30 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/512702/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; but then, HPC code relies more on optimization by hand and leaves little </font><br>
<font class="QuotedText">&gt; to the compiler, as I understand it)</font><br>
<p>
Not true.  The Intel compiler, for example, will vectorize its brains out automatically.<br>
<p>
A code using lots of non-restrict pointers will certainly be difficult to vectorize.  Such code can sometimes be auto-parallelized but I don't believe gcc has that capability.<br>
<p>
gcc's vectorization is also pretty weak, though it is getting better.  That may be part of what you're seeing.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2012 10:39 UTC (Wed)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/512864/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A code using lots of non-restrict pointers will certainly be difficult to vectorize. Such code can sometimes be auto-parallelized but I don't believe gcc has that capability.</font><br>
<p>
It sorta-kinda does (-ftree-parallelize-loops) but I haven't tested it much. But I expect it to be even weaker than vectorization.<br>
<p>
<font class="QuotedText">&gt; gcc's vectorization is also pretty weak, though it is getting better. That may be part of what you're seeing.</font><br>
<p>
It may be that. Or it may be that most of the code in non-HPC world does not lend itself to vectorization easily. I actually don't know, I'm just an amateur and hobbyist :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor511618"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 5:32 UTC (Thu)
                               by <b>jmspeex</b> (subscriber, #51639)
                              [<a href="/Articles/511618/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This hazard stems from an annoying aspect of the C11 standard, namely that signed-integer overflow is undefined (Section 3.4.3).</font><br>
<p>
Actually, signed-integer overflow was undefined long before C11. It was definitely undefined in C99 and I'm pretty sure it also was in C89. After all, there *are* machines that handle it in different ways. There's (nearly extinct) one's complement and two's complement, but there's also saturating arithmetic that many DSPs use, where (for 16-bit type), 32767+1 = 32767.<br>
<p>
Also, when it comes to undefined arithmetic, there's a lot more to worry about. For example, shifting *by* a negative value is undefined. So is shifting a negative value left (even if the shift is by a positive number of bits). Fortunately, clang now has a feature that can add run-time checks to your source code and detect these undefined arithmetic operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511618/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 21:10 UTC (Thu)
                               by <b>daney</b> (guest, #24551)
                              [<a href="/Articles/511867/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Actually, signed-integer overflow was undefined long before C11.</font><br>
<font class="QuotedText">&gt; It was definitely undefined in C99 and I'm pretty sure it also was in C89.</font><br>
<p>
The first edition of K &amp; R explicitly states the signed-integer overflow is undefined.  This has carried through to the present.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511903"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:48 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511903/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Understood.  And when it was suggested within the C11 Standards committee that signed-integer overflow be given twos-complement semantics, the discussion was both emphatic and short.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511903/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 16:07 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/512111/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What did the arguments against it say, other than "that would remove compiler optimization possibilities"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 18:19 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/512258/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One objection was that there really are still non-twos-complement machines in common use.  As was noted by the comment to this article discussing saturating adders, where 32767+1==32767.  But this would be addressed by "implementation defined" rather than "undefined".<br>
<p>
Another objection was that there are systems still in common use that trap on signed integer overflow.  If the C standard required wrapping, compilers for such systems would require special edge-case checks on pretty much any signed integer operation.<br>
<p>
And there was of course also the objection that signed integer overflow always has been undefined.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor512147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 19:16 UTC (Fri)
                               by <b>gmaxwell</b> (guest, #30048)
                              [<a href="/Articles/512147/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
JM, the clang integer overflow checker we've used on our projects isn't part of clang proper, it's a (very useful) patch:  <a href="http://embed.cs.utah.edu/ioc/">http://embed.cs.utah.edu/ioc/</a><br>
<p>
Beyond the optimization possibilities, the existence of tools like this is also a reason for keeping the undefined behavior, e.g. continue using signed values for counters that don't need the extra unsigned range: Most of the time overflow that you didn't expect (and thus couldn't wrap in a casting macro) is a sign of a logic error. By keeping it invalid you gain the possibility of dynamic instrumentation to catch those errors.<br>
<p>
(Though I don't know if anyone has managed to get tools like this working with the kernel yet!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor511632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 7:13 UTC (Thu)
                               by <b>stevenb</b> (guest, #11536)
                              [<a href="/Articles/511632/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not just use -fwrapv in the kernel?<br>
<p>
`-fwrapv'<br>
     This option instructs the compiler to assume that signed arithmetic<br>
     overflow of addition, subtraction and multiplication wraps around<br>
     using twos-complement representation.  This flag enables some<br>
     optimizations and disables others.  This option is enabled by<br>
     default for the Java front-end, as required by the Java language<br>
     specification.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511698"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 13:28 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511698/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very cool, thank you for the info!  Very welcome information, especially in light of the fact that the kernel compiles at -O2, not -O1 as I incorrectly stated.  Apparently -fwrapv has also made its way into other compilers' command lines as well, including that of clang.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511698/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor511634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 7:25 UTC (Thu)
                               by <b>hobocken</b> (guest, #85839)
                              [<a href="/Articles/511634/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
»Fortunately for the Linux kernel, GCC will generate the subtraction and comparison for -O1 or less. But optimizations can migrate to lower optimization levels over time, and there may come a time when either performance or energy-efficiency considerations motivate the Linux kernel to move to higher optimization levels. If that happens, what can be done?«<br>
<p>
I don't understand the paragraph above. The kernel is already compiled<br>
with -O2 or -Os.<br>
From the top level Makefile:<br>
<p>
ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE<br>
KBUILD_CFLAGS   += -Os<br>
else<br>
KBUILD_CFLAGS   += -O2<br>
endif<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 9:02 UTC (Thu)
                               by <b>ken</b> (subscriber, #625)
                              [<a href="/Articles/511654/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly I noticed that to. It's been -O2 as far as I can remember. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 13:19 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511695/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And you are absolutely right: -O2 and no sign of -fwrapv.  Perhaps this is more urgent than I was thinking...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 13:58 UTC (Thu)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/511706/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a rel="nofollow" href="http://marc.info/?t=124806309500001&amp;r=1&amp;w=2">http://marc.info/?t=124806309500001&amp;r=1&amp;w=2</a><br>
<p>
The kernel currently uses -fno-strict-overflow because -fwrapv was buggy in some versions of gcc.  Unfortunately -fno-strict-overflow is also buggy in some other versions of gcc.  Depending on the version of gcc I compile with, I have to patch the makefile to use one or the other.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:49 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511904/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whew!  It goes back to being non-urgent.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor511705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 14:04 UTC (Thu)
                               by <b>baldrick</b> (subscriber, #4123)
                              [<a href="/Articles/511705/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The second example is from mx1_2_set_next_event() in the ARM architecture,</font><br>
<font class="QuotedText">&gt; which is using a variation on this theme to determine whether the</font><br>
<font class="QuotedText">&gt; requested event time really is in the future. Here the actual subtraction</font><br>
<font class="QuotedText">&gt; is unsigned, but the result is cast to an signed integer. Because unsigned</font><br>
<font class="QuotedText">&gt; longs are always positive, the only way that the result can be negative</font><br>
<font class="QuotedText">&gt; (when interpreted as a signed value) is overflow, which the compiler is</font><br>
<font class="QuotedText">&gt; permitted to assume never happens. The compiler is therefore within its</font><br>
<font class="QuotedText">&gt; rights to unconditionally evaluate the test as false and return zero,</font><br>
<font class="QuotedText">&gt; which might fatally disappoint the caller.</font><br>
<p>
As far as I know this is wrong: there is no problem in the second example.  The misunderstanding is in "Because unsigned longs are always positive, the only way that the result can be negative (when interpreted as a signed value) is overflow, which the compiler is permitted to assume never happens".  Since the numbers have unsigned type, subtracting them always has a well defined result.  The fact that when you think of these numbers as being signed you see in your head that a signed overflow must have occurred is of no relevance.  The cast to a signed type is also always well defined.  In fact I would say the right way to avoid this issue is to copy this example and do something like<br>
  (signed) ((unsigned)x - (unsigned)y) &lt; 0<br>
rather than do the baroque comparison recommended by the article.<br>
<p>
For more on this kind of thing I recommend <a href="http://blog.regehr.org/archives/213">http://blog.regehr.org/archives/213</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:46 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511899/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      Hmmm...  If I compile the following with gcc 4.6.1 with -O2:

<pre>
unsigned long long signed_cast(unsigned long long a, unsigned long long b)
{
        return (signed)((unsigned)a - (unsigned)b);
}
</pre>

<p>The following x86 object code is generated:

<pre>
 120:   8b 54 24 04             mov    0x4(%esp),%edx
 124:   2b 54 24 0c             sub    0xc(%esp),%edx
 128:   89 d0                   mov    %edx,%eax
 12a:   c1 fa 1f                sar    $0x1f,%edx
 12d:   c3                      ret
</pre>

<p>This is a 32-bit subtraction on 64-bit quantities.  And when I plugged 2^32=4294967296 for <code>a</code> and 2^31-1=2147483647 for <code>b</code>, <code>a-b</code> evaluated to 2147483649 (as expected), but 
signed_cast(a, b) evaluated to -2147483647.

<p>So unless I misunderstood what you are suggesting, I will be sticking with the baroque comparisons for RCU.
      
          <div class="CommentReplyButton">
            <form action="/Articles/511899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511961"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 2:20 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511961/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Though I could make the macros type-generic by (ab)using sizeof().  Not sure it is worth it, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511961/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor511976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 5:05 UTC (Fri)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/511976/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Hmmm... If I compile the following with gcc 4.6.1 with -O2:

<pre>
unsigned long long signed_cast(unsigned long long a, unsigned long long b)
{
        return (signed)((unsigned)a - (unsigned)b);
}
</pre>
...<br>
This is a 32-bit subtraction on 64-bit quantities.
</blockquote>

Well, yeah, that's because "(signed)" is casting 32-bit when compiled with -m32.  I might be misunderstanding your issue here but it seems you wanted:

<pre>
unsigned long long signed_cast(unsigned long long a, unsigned long long b)
{
        return (signed long long)((unsigned long long)a - (unsigned long long)b);
}
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/511976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 18:07 UTC (Sat)
                               by <b>ppisa</b> (subscriber, #67307)
                              [<a href="/Articles/512256/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope that behavior of unsigned to signed conversion stays defined (at least for GCC and GCC replacement compilers - LLVM, Intel atc.). GCC defines behavior in current manual version<br>
<p>
<a href="http://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html">http://gcc.gnu.org/onlinedocs/gcc/Integers-implementation...</a><br>
<p>
I use ((signed type)((unsigned type)a - (unsigned type)b) &gt; 0) often in our embedded code and in the fact I am probably author/coauthor of that MX1 example - if that line was not not rewritten by somebody.<br>
<p>
Paul's example behavior is correct according to my knowledge (unsigned) is equivalent to (unsigned int) ie on 32 bit target 32 bit subtraction is evaluated and then sign is extended to 64 bits when conversion to (signed it) and then 64 bit signed type is required.<br>
<p>
What is common trap is that plain<br>
<p>
(unsigned type) a - (unsigned type) b <br>
<p>
is not considered (type) nor (signed type). It is signed but interpreted as so big signed to hold additional bit if it is compared with zero. So additional cast to signed type same or smaller than both inputs (a and b) has to be used.<br>
<p>
I use next mechanism to allow cyclic comparison between different<br>
hardware, position, time, state generation counters etc in our code.<br>
<p>
<a href="http://ulan.git.sourceforge.net/git/gitweb.cgi?p=ulan/ulut;a=blob;f=ulut/ul_utdefs.h;#l42">http://ulan.git.sourceforge.net/git/gitweb.cgi?p=ulan/ulut;...</a><br>
<p>
Library is licensed GPL, LGPL, MPL, but code fragment can be taken as public domain, if it helps somebody.<br>
<p>
#ifndef ul_cyclic_gt<br>
#define ul_cyclic_gt(x,y) \<br>
        ((sizeof(x)&gt;=sizeof(long long))&amp;&amp;(sizeof(y)&gt;=sizeof(long long))? \<br>
                (long long)((unsigned long long)(x)-(unsigned long long)(y))&gt;0: \<br>
         (sizeof(x)&gt;=sizeof(long))&amp;&amp;(sizeof(y)&gt;=sizeof(long))? \<br>
                (long)((unsigned long)(x)-(unsigned long)(y))&gt;0: \<br>
         (sizeof(x)&gt;=sizeof(int))&amp;&amp;(sizeof(y)&gt;=sizeof(int))? \<br>
                (int)((unsigned int)(x)-(unsigned int)(y))&gt;0: \<br>
         (sizeof(x)&gt;=sizeof(short))&amp;&amp;(sizeof(y)&gt;=sizeof(short))? \<br>
                (short)((unsigned short)(x)-(unsigned short)(y))&gt;0: \<br>
         (signed char)((unsigned char)(x)-(unsigned char)(y))&gt;0 \<br>
        )<br>
#endif /*ul_cyclic_gt*/<br>
<p>
#ifndef ul_cyclic_ge<br>
#define ul_cyclic_ge(x,y) \<br>
        ((sizeof(x)&gt;=sizeof(long long))&amp;&amp;(sizeof(y)&gt;=sizeof(long long))? \<br>
                (long long)((unsigned long long)(x)-(unsigned long long)(y))&gt;=0: \<br>
         (sizeof(x)&gt;=sizeof(long))&amp;&amp;(sizeof(y)&gt;=sizeof(long))? \<br>
                (long)((unsigned long)(x)-(unsigned long)(y))&gt;=0: \<br>
         (sizeof(x)&gt;=sizeof(int))&amp;&amp;(sizeof(y)&gt;=sizeof(int))? \<br>
                (int)((unsigned int)(x)-(unsigned int)(y))&gt;=0: \<br>
         (sizeof(x)&gt;=sizeof(short))&amp;&amp;(sizeof(y)&gt;=sizeof(short))? \<br>
                (short)((unsigned short)(x)-(unsigned short)(y))&gt;=0: \<br>
         (signed char)((unsigned char)(x)-(unsigned char)(y))&gt;=0 \<br>
        )<br>
#endif /*ul_cyclic_ge*/<br>
<p>
Please, if you know about some target, compiler or intention to break assumption (at least hopefully current GCC version guarantee) that unsigned to signed conversion reinterprets MSB as a sign. As for correctness of the code, there could be problem if target specifies some basic arithmetic type with some bits unused. It short 16 bit but stored in 32 bit entity. But none of our targets has that problem.<br>
<p>
Code is used in many targets, some of safety grade class applications  so notice of possible (even future) breakage is critical for me and users.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 19:02 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/512260/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cool, that was the sort of thing I was thinking of with my "sizeof()" earlier, though I still do feel more comfortable with using the constants than relying on casting.<br>
<p>
But why the casts to unsigned integral types?  I would instead have expected a requirement that the caller's cyclic arithmetic be carried out in unsigned integers, so that the casts were unnecessary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 22:34 UTC (Sat)
                               by <b>ppisa</b> (subscriber, #67307)
                              [<a href="/Articles/512281/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, cast to unsigned used to work even for signed types and in practice works still. a+=20 is translated into single add instruction on all targets I know. The other reason for casting is, that sometimes you can strore in object only shorter part of time stamp or generation counter, if you know, that live period is small enough or if you only check for change. Casting both to smaller of the two makes subtraction possibly cheaper, the result has to be casted to smaller one anyway.<br>
<p>
But main reason for casting to ensure thing works on existing code<br>
with signed types.<br>
<p>
Best wishes,<br>
<p>
               Pavel<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor512342"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 19, 2012 17:00 UTC (Sun)
                               by <b>baldrick</b> (subscriber, #4123)
                              [<a href="/Articles/512342/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
By "signed" I meant "signed integer type of the same size" and by "unsigned" I meant "unsigned integer type of the same size".  The "same size" means: the same number of bits as the original integer type, so in the case of example 2 this means "signed long long" and "unsigned long long".  Sorry for not being clear.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512342/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2012 0:44 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/512381/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No problem!<br>
<p>
I must admit that it would be nice if "(signed typeof(a))" and (unsigned typeof(b))" flipped the signedness of "a" and "b", but my version of gcc really doesn't like either variant.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor511985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 6:45 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/511985/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>
You have that in reverse. Conversion to unsigned is always well defined. Conversion to signed where the value cannot be represented is implemented-defined:
</p>

<blockquote>
C99 6.3.1.3 Signed and unsigned integers
<ol>
<li> When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.</li>

<li> Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.49) </li>

<li> Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.</li>

</ol>
</blockquote>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2012 21:57 UTC (Fri)
                               by <b>pdewacht</b> (subscriber, #47633)
                              [<a href="/Articles/512178/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      But given that Linux is only intended to be compiled by gcc, we can rely on its implementation-defined behavior:

<blockquote>
The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type (C90 6.2.1.2, C99 6.3.1.3).
<blockquote>
For conversion to a type of width N, the value is reduced modulo 2^N to be within range of the type; no signal is raised.
</blockquote>
</blockquote>

<p>(and I don't see how any compiler for a two's complement computer could define different behavior.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/512178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 19:48 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/512264/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True enough!<br>
<p>
However, the Linux kernel's code can be legitimately used in any GPLv2 project, including those that might run on systems with non-twos-complement signed integer arithmetic.  This sharing of code among compatibly licensed projects is a very good thing, in my view.<br>
<p>
Which means in this case, where there is a solution that meets the C standard, and which loses nothing by doing so (at least on x86 and Power), it only makes sense to use that C-standard solution.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor512291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 23:58 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/512291/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
The result of ... converting an integer to a signed integer type when the value cannot be represented in an object of that type ...
<p>
For conversion to a type of width N, the value is reduced modulo 2^N to be within range of the type; 
</blockquote>

<p>
I must be reading that wrongly, because that's not at all what GCC does.  With -m32, int is a signed integer type of width 32.  UINT_MAX reduced modulo 2^32 is UINT_MAX, which is not within the range of int.  So this does not describe what (int)UINT_MAX does.
<p>
Rather, what GCC does appears to be the opposite of what the standard requires for conversion from negative number to unsigned integer (add UINT_MAX+1 until it fits): it subtracts UINT_MAX+1 until the value is within the range of int (in this case -1).

      
          <div class="CommentReplyButton">
            <form action="/Articles/512291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor511767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About undefined behaviour...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 16:45 UTC (Thu)
                               by <b>juhl</b> (guest, #33245)
                              [<a href="/Articles/511767/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>For people interrested in (or concerned about) undefined behaviour, the problems it can cause and the optimizations it enables etc, I can greatly recommend reading the following articles:</p>
<p>
<a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">What Every C Programmer Should Know About Undefined Behavior #1/3</a><br />
<a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">What Every C Programmer Should Know About Undefined Behavior #2/3</a><br />
<a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html">What Every C Programmer Should Know About Undefined Behavior #3/3</a><br />
<a href="http://blog.regehr.org/archives/213">A Guide to Undefined Behavior in C and C++, Part 1</a><br />
<a href="http://blog.regehr.org/archives/226">A Guide to Undefined Behavior in C and C++, Part 2</a><br />
<a href="http://blog.regehr.org/archives/232">A Guide to Undefined Behavior in C and C++, Part 3</a><br />
<a href="http://www.angelikalanger.com/Articles/VSJ/SequencePoints/SequencePoints.html">Sequence Points and Expression Evaluation in C++</a><br />
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/511767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor511905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About undefined behaviour...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:50 UTC (Thu)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/511905/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great links! Thank you very much!!!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor511907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About undefined behaviour...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 22:52 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/511907/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you, highly recommended!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor513139"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About undefined behaviour...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2012 16:03 UTC (Thu)
                               by <b>pwood</b> (guest, #86373)
                              [<a href="/Articles/513139/">Link</a>] 
      </p>
      
      </div>
      </summary>
      John Regehr's blog posts on undefined behaviour are always worth reading (his research group developed the IOC patch to clang that a couple of people have linked to above.) In the context of integer behaviour in C he has a quiz <a rel="nofollow" href="http://blog.regehr.org/archives/721">here</a> which is worth a look.

I'm not sure that you ever want to rely on undefined behaviour as suggested in the article as it means that the execution of your program is undefined and can change at the compiler's will. That is very different from relying on implementation defined behaviour.

      
          <div class="CommentReplyButton">
            <form action="/Articles/513139/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor511924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 23:19 UTC (Thu)
                               by <b>klossner</b> (subscriber, #30046)
                              [<a href="/Articles/511924/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
» I suspect that the dominance of twos complement was not due to ease of use, but rather due to the fact that it allows a single hardware adder to perform both signed and unsigned computations. «<br>
<p>
My recollection of those days is that the greater motivation was to get away from systems with two different representations of zero.  There were ancient Fortran codes run on CDC mainframes that had to test results for both postive and negative zero.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/511924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor511931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2012 23:34 UTC (Thu)
                               by <b>mmorrow</b> (guest, #83845)
                              [<a href="/Articles/511931/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Here's my favorite undefined-signed-overflow example:

<pre>
  int f(int x){while(x &lt; x + 1) x += 1; return x;}
</pre>

gives:

<pre>
  f:
  .L2:
    jmp .L2
    .ident  "GCC: (GNU) 4.8.0 20120408 (experimental)"
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/511931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor512283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 22:51 UTC (Sat)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/512283/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>This seems like it argues for a macro to hide the ugliness.  Name it something obvious such as "before()".  It makes the intent obvious and ensures the ugly math is done correctly.  Something like:</P>
<PRE>
/* return true if timestamp 'a' is earlier than timestamp 'b' */
#define before(a,b) (ULONG_MAX/2 &gt; ((unsigned long)(a) - (unsigned long)(b)))
</PRE>
<P>Or is this just an invitation to more problems?</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/512283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2012 23:04 UTC (Sat)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/512287/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see I missed ppisa's impressive macros upthread.  Those certainly seem to take into account a range of integer types as well!  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor512400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2012 8:59 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/512400/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So it is not too early to start future-proofing the Linux kernel by removing its reliance on signed integer overflow!</font><br>
<p>
Would be nice to have a GCC option for ia32 so that any "add" used for signed arithmetic is followed with "into" (exception if overflow).<br>
It will not slow too much the execution ("into" will not be predicted as a taken jump), and could help locate potential problems...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2012 8:51 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/512857/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <tt>-ftrapv</tt> is an architecture-independent compiler option to GCC. I don't know whether it works.
      
          <div class="CommentReplyButton">
            <form action="/Articles/512857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor512878"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2012 13:21 UTC (Wed)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/512878/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seems like -ftrapv can work, but it is far from just adding an "into" instruction after each signed "add" on ia32 - note that "into" has disappeared in amd64 instruction set.<br>
<p>
$ cat test.c <br>
int a, b, c;<br>
void main (void) {<br>
	c = a + b;<br>
}<br>
$ gcc -m32 -O2 -ftrapv test.c <br>
$ objdump -d a.out <br>
<p>
a.out:     file format elf32-i386<br>
....<br>
080483f0 &lt;main&gt;:<br>
push   %ebp<br>
mov    %esp,%ebp<br>
and    $0xfffffff0,%esp<br>
sub    $0x10,%esp<br>
mov    0x804a01c,%eax<br>
mov    %eax,0x4(%esp)<br>
mov    0x804a020,%eax<br>
mov    %eax,(%esp)<br>
call   8048420 &lt;__addvsi3&gt;<br>
mov    %eax,0x804a024<br>
leave  <br>
ret    <br>
....<br>
08048420 &lt;__addvsi3&gt;:<br>
push   %ebp<br>
mov    %esp,%ebp<br>
push   %ebx<br>
sub    $0x4,%esp<br>
mov    0xc(%ebp),%ecx<br>
mov    0x8(%ebp),%edx<br>
call   804845c &lt;__i686.get_pc_thunk.bx&gt;<br>
add    $0x1bc2,%ebx<br>
test   %ecx,%ecx<br>
lea    (%ecx,%edx,1),%eax<br>
js     8048450 &lt;__addvsi3+0x30&gt;<br>
cmp    %edx,%eax<br>
setl   %dl<br>
test   %dl,%dl<br>
jne    8048457 &lt;__addvsi3+0x37&gt;<br>
add    $0x4,%esp<br>
pop    %ebx<br>
pop    %ebp<br>
ret    <br>
xchg   %ax,%ax<br>
cmp    %edx,%eax<br>
setg   %dl<br>
jmp    8048444 &lt;__addvsi3+0x24&gt;<br>
call   80482fc &lt;abort@plt&gt;<br>
<p>
<p>
Without ftrapv:<br>
080483c0 &lt;main&gt;:<br>
mov    0x804a01c,%eax<br>
add    0x804a018,%eax<br>
push   %ebp<br>
mov    %esp,%ebp<br>
mov    %eax,0x804a020<br>
pop    %ebp<br>
ret    <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/512878/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor513056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2012 9:47 UTC (Thu)
                               by <b>reddit</b> (guest, #86331)
                              [<a href="/Articles/513056/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The sensible way to do this is (int)(a - b) &lt; 0 where a and b are unsigned.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/513056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor513059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2012 9:54 UTC (Thu)
                               by <b>georgm</b> (subscriber, #19574)
                              [<a href="/Articles/513059/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A question:<br>
<p>
What is the reason to write "if((a-b) &lt; 0) ..." instead of just "if(a&lt;b)"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/513059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor513072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signed overflow optimization hazards in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2012 10:28 UTC (Thu)
                               by <b>georgm</b> (subscriber, #19574)
                              [<a href="/Articles/513072/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The question concerns signed values, where wraps are not common. Unsigned benefit is clear.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/513072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
