        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rethinking splice() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/923237/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/923505/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/923237/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rethinking splice()</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 17, 2023</br>
           </div>
The <a
href="https://man7.org/linux/man-pages/man2/splice.2.html"><tt>splice()</tt>
system call</a> is built on an appealing idea: connect two file descriptors
together so that data can be moved from one to the other without passing
through user space and, preferably, without being copied in the kernel.
<tt>splice()</tt> has enabled some significant performance optimizations
over the years, but it has also proved difficult to work with and
occasionally surprising.  A recent linux-kernel discussion showed how
<tt>splice()</tt> can cause trouble, to the point that some developers now
wonder if adding it was a good idea.
<p>
Stefan Metzmacher is a <a href="https://www.samba.org/">Samba</a> developer
who would like to use <tt>splice()</tt> to implement zero-copy I/O in the
Samba server.  He has <a
href="/ml/linux-kernel/0cfd9f02-dea7-90e2-e932-c8129b6013c7@samba.org/">run
into a problem</a>, though.  If a file is being sent to a remote client
over the network, <tt>splice()</tt> can be used to feed the file data into
a socket; the network layer will read that data directly out of the page
cache without needing to make a copy in the kernel â€” exactly the desired
result. But if the file is written before network transmission is
complete, the newly written data may be sent, even though that write
happened after the <tt>splice()</tt> call was made, perhaps even in the
same process.  That can lead to unpleasant surprises (and unhappy Samba
users) when the data received at the remote end is not what is expected.
<p>
The problem here is a bit more subtle than it might seem at a first glance.
To begin with, it is not possible to splice a file directly into a network
socket; <tt>splice()</tt> requires that at least one of the file
descriptors given to it is a pipe.  So the actual sequence of operations is
to splice the file into a pipe, then to connect the pipe to the socket with
a second <tt>splice()</tt> call.  Neither <tt>splice()</tt> call knows when
the data it passes through has reached its final destination; the network
layer may still be working with the file data even after both
<tt>splice()</tt> calls have completed.  There is no easy way to know that
the data has been transmitted and that it is safe to modify the file again.
<p>
In his initial email, Metzmacher asked whether it would be possible to
prevent this problem by marking file-cache pages as copy-on-write when they
are passed to <tt>splice()</tt>.  Then, if the file were written while the
transfer was underway, that transfer could continue to read from the older
data while the write to the file proceeded independently.  Linus Torvalds
quickly <a
href="/ml/linux-kernel/CAHk-=wj8rthcQ9gQbvkMzeFt0iymq+CuOzmidx3Pm29Lg+W0gg@mail.gmail.com/">rejected</a>
that idea, saying that the sharing of the buffers holding the data is
"<q>the whole point of splice</q>".  Making those pages copy-on-write would
break sharing of data in general.  He later <a
href="/ml/linux-kernel/CAHk-=wj66F6CdJUAAjqigXMBy7gHquFMzPNAwKCgkrb2mF6U7w@mail.gmail.com/">added</a>
that a <tt>splice()</tt> call should be seen as a form of <a
href="https://man7.org/linux/man-pages/man2/mmap.2.html"><tt>mmap()</tt></a>,
with similar semantics.
<p>
He also said: "<q>You can say 'I don't like splice()'. That's fine. I used
to think splice was a really cool concept, but I kind of hate it these
days.  Not liking splice() makes a ton of sense.</q>" Like it or not,
though, the current behavior of <tt>splice()</tt> cannot change, since that
would break existing applications; even Torvalds's dislike cannot overcome
that.
<p>
Samba developer Jeremy Allison <a
href="/ml/linux-kernel/Y+aKuC1PuvX4STEI@jeremy-acer/">suggested</a> that
the solution to Metzmacher's problem could be for Samba to only attempt
zero-copy I/O when the client holds a lease on the file in question, thus
ensuring that there should be no concurrent access.  He later had to <a
href="/ml/linux-kernel/Y+aat8sggTtgff+A@jeremy-acer/">backtrack</a> on that
idea, though; since the Samba server cannot know when network transmission
is complete, the possibility for surprises still exists even in the
presence of a lease.  Thus, he concluded, "<q><tt>splice()</tt> is unusable
for Samba even in the leased file case</q>".
<p>
Dave Chinner <a
href="/ml/linux-kernel/20230210040626.GB2825702@dread.disaster.area/">observed</a>
that this problem resembles those that have previously been solved in the
filesystem layer.  There are many cases, including RAID&nbsp;5 or data
compressed by the filesystem, where data to be written must be held stable
for the duration of the operation; this is the whole <a
href="/Articles/442355/">stable-pages problem</a> that was confronted
almost twelve years ago.  Perhaps a similar solution could be implemented
here, he said, where attempts to write to pages currently being used in a
<tt>splice()</tt> chain would simply block until the operation has
completed.
<p>
Both <a
href="/ml/linux-kernel/CAHk-=wip9xx367bfCV8xaF9Oaw4DZ6edF9Ojv10XoxJ-iUBwhA@mail.gmail.com/">Torvalds</a>
and <a
href="/ml/linux-kernel/Y+XLuYh+kC+4wTRi@casper.infradead.org/">Matthew
Wilcox</a> pointed out the flaw with this idea: the <tt>splice()</tt>
operation can take an unbounded amount of time, so it could be used
(accidentally or otherwise) to block access to a file indefinitely.  That
idea did not go far.
<p>
Andy Lutomirski <a
href="/ml/linux-kernel/CALCETrU-9Wcb_zCsVWr24V=uCA0+c6x359UkJBOBgkbq+UHAMA@mail.gmail.com/">argued</a>
that <tt>splice()</tt> is the wrong interface for what applications want to
do; <tt>splice()</tt> has no way of usefully communicating status
information back to the caller.  Instead, he said, <a
href="/Articles/776703/">io_uring</a> might be a better way to implement
this functionality.  It allows multiple operations to be queued efficiently
and, crucially, it has the completion mechanism that can let user space
know when a given buffer is no longer in use.  Jens Axboe, the maintainer
of io_uring, was initially <a
href="/ml/linux-kernel/7a2e5b7f-c213-09ff-ef35-d6c2967b31a7@kernel.dk/">unsure</a>
about this idea, but <a
href="/ml/linux-kernel/b44783e6-3da2-85dd-a482-5d9aeb018e9c@kernel.dk/">warmed
to it</a> after Lutomirski <a
href="/ml/linux-kernel/CALCETrVx4cj7KrhaevtFN19rf=A6kauFTr7UPzQVage0MsBLrg@mail.gmail.com/">suggested</a>
that the problem could be simplified by taking the pipes out of the picture
and allowing one non-pipe file descriptor to be connected directly to
another.  The pipes, Axboe said, "<q>do get in the way</q>" sometimes.
<p>
Axboe thought that a new "send file" io_uring operation could be a good
solution to this problem; it could be designed from the beginning with
asynchronous operation in mind and without the use of pipes.  So that may
be the solution that comes out 
of this discussion â€” though somebody would, naturally, actually have to
implement it first.
<p>
There was some talk about whether <tt>splice()</tt> should be deprecated;
Torvalds <a
href="/ml/linux-kernel/CAHk-=wjQZWMeQ9OgXDNepf+TLijqj0Lm0dXWwWzDcbz6o7yy_g@mail.gmail.com/">
doesn't think</a> the system call has much value:
<p>
<blockquote class="bq">
	The same way "everything is a pipeline of processes" is very much
	historical Unix and very useful for shell scripting, but isn't
	actually then normally very useful for larger problems, splice()
	really never lived up to that conceptual issue, and it's just
	really really nasty in practice.
<p>
	But we're stuck with it.
</blockquote>
<p>
There is little point in discouraging use of <tt>splice()</tt>, though, if
the kernel lacks a better alternative; Torvalds expressed doubt that the
io_uring approach would turn out to be better in the end.  The only way to
find out is probably to try it and see how well it actually works.  Until
that happens, <tt>splice()</tt> will be the best that the kernel has to
offer, its faults notwithstanding.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#splice">splice()</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/923237/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor923646"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2023 16:32 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/923646/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"since the Samba server cannot know when network transmission is complete,"<br>
<p>
Sounds like a network fs that uses splice needs to have acknowledgements of when data is received, at the network fs protocol level. <br>
<p>
Not familiar with SMB, but I guess it lacks SMB level of signalling of file transfer completion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923646/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor923647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2023 16:48 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/923647/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The way it works is annoying indeed, but the main reason is that like most syscalls it returns a single result. A direct splice between two FDs would be great for networking, but it would need to provide two reports, one per FD (blocked on read, write, end reached, error etc). It would also save a lot of memory because right now when you pump from one FD to a pipe just to discover the other side is full, you've made room for no reason in the input FD and again when it's a socket, it reopens the window so the device that splices between two sockets serves as a giant pipe-based buffer between a server and a client.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor923659"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2023 22:29 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/923659/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW, I'm an application programmer, and for me splice() never made any sense. Why the heck do you need one side of the splice() to be a pipe?<br>
<p>
splice() should have been modified to use just regular descriptors. E.g. if I want to connect a file descriptor to a network socket, I should just do it directly. This way the kernel can have special-cased handling of file-based pages and provide meaningful completion notifications. There's probably a handful of such combinations that make sense (memfd() to socket, socket to memfd() or file, etc.)<br>
<p>
To make it even better, add a flag F_SPLICE_NO_FALLBACK that will fail the operation if there's no accelerated path available and the kernel would instead just fall back on a memcpy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923659/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 6:40 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/923664/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is also copy_file_range(2). And sendfile(2). And probably one or two random others that I don't know about. Every single one has a different set of arcane restrictions on what types of file descriptors you can pass it. And now we're talking about deprecating *one* of these things, but presumably the others will be left as-is.<br>
<p>
At this point, it's even worse than setuid/seteuid/etc., and that mess led directly to the creation of setresuid(2). Why can't we (application programmers) have nice things once in a while? This is not O_PONIES. This is a simple matter of "don't make three different syscalls that do basically the same thing." Or maybe even "don't provide abstractions that leak like a sieve."<br>
<p>
All we need is one, single syscall that:<br>
<p>
* Is exactly equivalent to a while/read/write loop.<br>
* Starts reading/writing from wherever the fd is currently positioned (if it's seekable and you want to seek, then call seek explicitly).<br>
* Takes a size argument (which is just about the only thing all three of those syscalls have in common).<br>
* Fails with EDOITYOURSELF if there's no optimization available and the kernel doesn't feel like emulating it. Then libc or somebody else can write a simple wrapper that does the while loop if necessary.<br>
* Blocks at least until the last write (in a hypothetical while/read/write loop) would have returned. It might still need to be fsync'd, but there should be no "oh, if you do a write at exactly the wrong time, it'll silently clobber all of your data" case.<br>
* Also, O_NONBLOCK and/or io_uring would be nice to have, but *now* we're getting more into the O_PONIES realm, so I would say this is a bonus goal (but still probably doable).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 6:56 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/923665/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; * Blocks at least until the last write (in a hypothetical while/read/write loop) would have returned. It might still need to be fsync'd, but there should be no "oh, if you do a write at exactly the wrong time, it'll silently clobber all of your data" case.</span><br>
<p>
To be clear: When I say this, I'm referring to the application-observable semantics of the operation, not to the underlying mechanism. In other words, I don't care whether the kernel actually copies the data, or moves it, or COWs it, or makes it dance the moonwalk. All I care about is the *semantics* - when this hypothetical syscall returns, it means the kernel considers the operation "committed" in some sense, and I can now proceed to close the src, or reopen it as writable and scribble on it, or truncate it, or whatever else I feel like, and the dest will not get messed up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2023 7:38 UTC (Mon)
                               by <b>moxfyre</b> (guest, #13847)
                              [<a href="/Articles/923751/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; when this hypothetical syscall returns, it means the kernel considers the operation "committed" in some sense, and I can now proceed to close the src, or reopen it as writable and scribble on it, or truncate it, or whatever else I feel like, and the dest will not get messed up.</span><br>
<p>
I very much like your proposal, and agree that it'd be a great designâ€¦ but the "in some sense" is doing some pretty heavy lifting here.<br>
<p>
Also, what happens if another thread seeks in one of the FDs before this one completes? Presumably it shouldn't be EXACTLY equivalent to a while/read/write loop in that sense?<br>
<p>
Aaaand now I start to get sense of how the current kernel interfaces came to be. ðŸ˜…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2023 8:43 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/923752/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; but the "in some sense" is doing some pretty heavy lifting here.</span><br>
<p>
It's vague because it's an implementation detail. The application should not know or care about what this entails. All it cares about is that the right data ends up in the right place.<br>
<p>
<span class="QuotedText">&gt; Also, what happens if another thread seeks in one of the FDs before this one completes? Presumably it shouldn't be EXACTLY equivalent to a while/read/write loop in that sense?</span><br>
<p>
None of the three syscalls that I mentioned upthread has anything in their respective man pages about how that works. Presumably, the kernel either interleaves the I/O with no synchronization, or just does whatever it feels like.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor923667"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 8:05 UTC (Sat)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/923667/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Starts reading/writing from wherever the fd is currently positioned (if it's seekable and you want to seek, then call seek explicitly).</span><br>
<p>
You could have two offsets. If a FD is non-seekable, ignore the offset, if the offset is -1 the current offset is used?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923667/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 8:32 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/923671/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps that is worth the bother, but the only use case I can think of is "I want to have one thread copy between fd A and fd B, while another thread simultaneously reads from or writes to one or both of A and B, and also I don't want to reopen the file," and IMHO that's just crazy. But I'm sure there's someone writing some ridiculous app out there that needs it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923675"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 10:10 UTC (Sat)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/923675/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. And while I'm at it, use iovec's instead of a direct pointer+len to a buffer. Then a user space library can provide easier to use wrappers for common cases.<br>
<p>
Similar to the normal IO read/write syscalls. If we had p{read,write}v2() from the start, read(), pread(), readv() (and corresponding ones for write) could be implemented in user space as wrappers.<br>
<p>
And also, a flags argument just in case it's needed later. History seems to suggest every syscall eventually needs such a thing. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923675/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 3:14 UTC (Mon)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/924493/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not only that, but a flags argument in which the low bits are "ignore if flag unrecognised" and the high bits are "syscall should fail if the flag bits are unrecognised".<br>
<p>
Given the number of times we've had issues with adding flags that change important semantics, where the syscall has no way to say "IDK what you setting flag bit 7 means, hope it isn't important".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 11:53 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/924502/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, just use 2 separate flags arguments. One for "optional, proceed if unrecognised" and the other for "mandatory, fail if unrecognised".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 12:29 UTC (Mon)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/924504/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This basically doesn't work. If any of your userspace is something like<br>
<p>
 unsigned int flags1, flags2 = 0;<br>
 syscall(..., &amp;flags1, &amp;flags2);<br>
<p>
then you've basically painted yourself into the corner of not being able to use flags1 for anything of interest in the future?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 12:37 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/924506/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
mandatory fail if unrecognised - for a set bit, obviously.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924545"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 14:21 UTC (Mon)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/924545/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I meant flags1 for the "optional, proceed if unrecognised" part. Don't see how you can really do "optional, proceed if unrecognised" at all since applications might just erroneously set random bits in there (as in the example), was just trying to illustrate why not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924545/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924563"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 16:22 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/924563/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If apps are specifying flag arguments with undefined values, well... they're going to get undefined behaviour (sooner or later) - tough for them I'd say.<br>
<p>
That's no different from today, where we have syscalls with flags that are not yet defined and their value (as yet) unchecked; or flags that are defined for future use but not yet implemented (and not checked), is it?<br>
<p>
GIGO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924563/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924564"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 16:38 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/924564/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>That conflicts with "don't break userspace". I built a perfectly working binary on Linux 6.4, which sets flags to 0x100 - a bad value, since the only currently defined value is 0. I upgrade to Linux 7.1, and it still works, since the defined flags values don't yet interpret 0x100. When I upgrade from 7.1 to 7.2, flags 0x100 is given a meaning, and my binary breaks. As far as Linus is concerned, that's a kernel regression, and you need to revert the feature that makes sense of flags value 0x100, and find a value that userspace doesn't set.
<p>Ultimately, this forces kernel developers to check all parameter values are set to something meaningful, and to error if any of the values are either not valid, or valid but not understood by this kernel. That way, my binary fails on Linux 6.4 as well as on 7.1, and <em>stops</em> failing on 7.2 - and Linus agrees that "binary used to fail with EINVAL, now works" is not a regression.


      
          <div class="CommentReplyButton">
            <form action="/Articles/924564/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2023 11:08 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/924631/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fair enough, that works too.<br>
<p>
In networking, it is common to allow for values that are optional, and not per se understood by the recipient - who may just ignore them. And values that are mandatory to understand, so the recipient must give some error if not recognised. <br>
<p>
Optional values allow a protocol to be extended with optional and wholly backwards compatible features, so that newer speakers with the feature happily co-exist with speakers without it. While 2 "newer" speakers presumably derive some benefit from both supporting the feature. I guess it's more rare in software (Linux especially) to have an application compiled with some such feature, and run it on some older kernel/library-stack that lacks it.<br>
<p>
Another way to achieve the latter - rather than explicitly having 2 classes of flags - is to specify that unused fields "Must Be Zero". If such a bit is set it's an error. If such a bit is then repurposed in an update, and it used by a new speaker with an old speaker, then the old speaker raises an error - the new speaker can try again without. 2 new speakers speaking to each other just happily use the new meaning of the formerly "Must Be Zero" flag.<br>
<p>
What you're saying is Linux kernel userspace-API flags must always be of the "MBZ" kind - there is no need for optional. Fair enough. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924633"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2023 17:29 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/924633/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>The tradeoff is different between networking and the kernel, too A program runs for milliseconds through to months on the same kernel, and the RTT to the kernel is on the order of 1 microsecond. Doing 10 RTTs to determine what features are supported and choosing fallbacks isn't significant time compared to the runtime of the program - especially since programs that use new features <em>and</em> have fallbacks for older kernels are likely to be long-running programs.
<p>In contrast, in the networking world, RTTs are higher (milliseconds, not microseconds, most of the time), and connection lifetime is shorter on the high end (connections for more than a day are unusual). Doing 10 RTTs to determine the feature set of the other end, when you'll only have the same remote for a few hours at most, and more likely for seconds at a time.


      
          <div class="CommentReplyButton">
            <form action="/Articles/924633/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2023 11:03 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/924755/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They're still protocols for different entities to communicate and achieve something, end of the day. ;)<br>
<p>
The fallback thing, the problem is the entity asking for the optional enhancement, that could otherwise be ignored, often will not implement the fallback path. So with a hard fail, the entire thing may fail. You need more logic to make the "nice to have, but optional and can be ignored" thing work reliably. The test matrix gets bigger (and bigger and bigger, with each such option).<br>
<p>
Just having it silently ignored if communicated to an entity that doesn't know it is simpler, and can not have fallback path bugs.<br>
<p>
Trade-offs in all directions. ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2023 11:22 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/924756/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>And to add another layer to the tradeoffs (one that's changed over time, to boot), in today's world it's often easier to not bother with the new feature at all until you can guarantee that all the hosts your application runs on have the new kernel feature, whereas it's often hard to get all the remote endpoints of a service you depend upon upgraded to new networking features.
<p>This will change again, but for now, that's where we sit.


      
          <div class="CommentReplyButton">
            <form action="/Articles/924756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924811"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2023 17:02 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/924811/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
yeah, software often doesn't care about this kind of compatibility. Except when it comes to systems software and features critical for booting. Then you need to think about forward and backward compatibility - least in the Linux world.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924811/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor924840"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2023 22:12 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/924840/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This mistake exists in other contexts too, even in hardware: &lt;<a href="http://www.os2museum.com/wp/forward-compatibility-landmines/">http://www.os2museum.com/wp/forward-compatibility-landmines/</a>&gt; &lt;<a href="http://www.os2museum.com/wp/theres-more-to-the-286-xenix-story/">http://www.os2museum.com/wp/theres-more-to-the-286-xenix-...</a>&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/924840/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor924548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2023 15:38 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/924548/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>You basically cannot do "optional, proceed if unrecognised" sanely. If you do, you have no way of distinguishing "app passed a non-zero flags value because it never went wrong testing on older kernels" from "app passed a non-zero flags value because it knows about the new meaning of this value".
<p>What you do need is a very clear way for the app to ask what flags values are known about - so that the app can test all the combinations it wants to use at start-up, fail early if the kernel doesn't support anything appropriate, and choose fallbacks if the kernel support is sub-optimal (e.g. older kernel).


      
          <div class="CommentReplyButton">
            <form action="/Articles/924548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor923668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 8:08 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/923668/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; FWIW, I'm an application programmer, and for me splice() never made any sense. Why the heck do you need one side of the splice() to be a pipe?</span><br>
<p>
Because the pipe is used as a kernel-side memory buffer. Don't think about it as splicing from one fd to another, think about it as reading from an fd to kernel memory (or writing from kernel memory to an fd).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 8:15 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/923670/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Don't think about it as splicing from one fd to another</span><br>
<p>
That's the problem. I _want_ to think about it as splicing one FD to another because it simply makes no sense otherwise. A buffer should be an internal technical detail.<br>
<p>
And for the zero-copy scenario, the "pipe as a kernel buffer" abstraction doesn't even make any sense!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 8:26 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/923672/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why doesn't it make sense otherwise? I have no qualms doing<br>
<p>
int ret = read(infd, buf, sizeof(buf));<br>
write(outfd, buf, ret);<br>
<p>
With splice(), the buffer is referenced by ID instead of by pointer, that's all.<br>
<p>
There's tons of problems with splice (as the article points out), and it hasn't aged well, but the abstraction isn't so weird.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 8:40 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/923673/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The argument isn't that buffers are illogical. The argument is that a more useful primitive would be one where I can just do<br>
<p>
int ret = readthenwrite(infd, outfd, maybe_some_other_args);<br>
<p>
and never even deal with buffers at all. Maybe under the hood the kernel deals with buffers, but as an application programmer, I would rather not have to think about them if I can avoid it.<br>
<p>
This is a superset of splice, because splice is just a special case of it where one of the fds happens to be a pipe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 11:55 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/923678/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not really a strict superset, since splice() follows tee() (where you can read once and send many) or vmsplice()+tee() (write once from memory, send many; think standardized HTTP headers).<br>
<p>
Most of this sort of feels obsolete with io_uring dominating, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2023 8:50 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/923711/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Those syscalls are not splice. I never claimed that readthenwrite (or whatever less-terrible name you want to call it, since readthenwrite is obviously just a placeholder) would be a superset of "splice, and also a bunch of random other syscalls that have a vaguely similar implementation to splice." My specific beef is not with the splice family of syscalls, it's with the family of "syscalls that are semantically equivalent to read and then write, but also have arbitrary restrictions that make no sense to the average application developer and have to be looked up in the man page every time you use them." See my other comment regarding copy_file_range(2) and sendfile(2).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor925005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2023 3:37 UTC (Fri)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/925005/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the logic would be:<br>
<p>
- splice composes with tee/vmsplice/etc. to allow more complex zero-copy IO flows<br>
<p>
- readthenwrite could not replace splice for this purpose, because splice has *super bizarre* semantics that are different from readthenwrite, as this article notes. (In particular, readthenwrite from a file into a pipe has to make a copy -- it skips bouncing through userspace, but it has to copy data from the page buffer into the pipe buffer, instead of doing wacky things with page pointers like splice does.) But those bizarre semantics are what let compositions of splice/tee/vmsplice/etc. be zero-copy.<br>
<p>
I don't think it really works out; this stuff really needs to be replaced with something better. But I can at least see why splice seemed like a good idea at the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/925005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor923690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 17:31 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/923690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why doesn't it make sense otherwise? </span><br>
<p>
The whole reason for splice() is to magically avoid buffers and transfer the data from one location to another. <br>
<p>
<span class="QuotedText">&gt; I have no qualms doing</span><br>
<p>
Except that if you actually do that, a pipe will be so much slower because of additional synchronization.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor923662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 0:06 UTC (Sat)
                               by <b>stressinduktion</b> (subscriber, #46452)
                              [<a href="/Articles/923662/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The information is possible to gather from the socket directly. Managing this along with the splice web is probably even worse, but maybe useful in certain cases:<br>
<p>
There is a possibility to loop progress information from the sockets back to the sockets' error queues. It was designed for handling transmit timestamp of network packets, but should also give clues about when data actually left the buffers: &lt;<a href="https://www.kernel.org/doc/Documentation/networking/timestamping.rst">https://www.kernel.org/doc/Documentation/networking/times...</a>&gt;, Section 2.1.1 (maybe along with bytestream timestamps, I don't remember the details anymore).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking splice()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2023 22:47 UTC (Sat)
                               by <b>willemb</b> (subscriber, #73364)
                              [<a href="/Articles/923704/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The socket error queue is indeed what MSG_ZEROCOPY uses for this exact purpose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
