        <!DOCTYPE html>
        <html lang="en">
        <head><title>Support for Intel's LASS [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/919683/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/919787/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/919683/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Support for Intel's LASS</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 13, 2023</br>
           </div>
Speculative-execution vulnerabilities come about when the CPU, while executing
speculatively, is able to access memory that would otherwise be denied to
it.  Most of these vulnerabilities would go away if the CPU were always
constrained by the established memory protections.  An obvious way to fix
these problems would be to make CPUs behave that way, but doing that
without destroying performance is not an easy task.  So, instead, Intel
has developed a feature called "linear address-space separation" (LASS) to
paper over parts of the problem; Yian Chen has posted <a
href="/ml/linux-kernel/20230110055204.3227669-1-yian.chen@intel.com/">a
patch set</a> adding support for this feature.
<p>
Speculative execution happens when the CPU is unable to complete an
instruction because it needs data that is not resident in the CPU's caches.
Rather than just wait for that data to be fetched from RAM, the CPU will
make a guess as to its value and continue running in the speculative mode.
If the guess turns out to be correct — which happens surprisingly often —
the CPU will have avoided a stall and 
will be ahead of the game; otherwise, the work that was done speculatively
is thrown out and the computation restarts.
<p>
This technique is crucial for getting reasonable performance out of current
CPUs, but it turns out to have a security cost: speculative execution is
allowed to access data that would be denied to code running normally.  A
CPU will be able to speculatively read data, despite permissions denying
that access in the page tables, without generating a fault.  That
data is never made available to the running process, but accessing it can
create state changes (such as loading data into the cache) that can be
detected by a hostile program and used to exfiltrate data that should not
be readable.  In response, kernel developers have adopted a number of
techniques, including address-space isolation and preemptive cache clearing,
to block these attacks, but those mitigations can have a substantial
performance cost.
<p>
LASS partially addresses the speculative-execution problem by wiring some
address-space-management policy into the hardware.  A look at, for example,
the <a
href="https://www.kernel.org/doc/html/latest/x86/x86_64/mm.html">Linux
x86-64 address-space layout</a> shows that all kernel-space addresses begin
with <tt>0xffff</tt>.  More to the point, they all have the highest-order
(sign) bit set, while all user-space addresses have that bit clear.  Linux is not
the only kernel to partition the 64-bit address space in this way.  LASS
uses this convention (and, indeed, requires it) to provide some
hardware-based address-space isolation.
<p>
Specifically, when LASS is enabled, the CPU will intercept any user-mode
reference to an address with the sign bit set, or any kernel-mode
access with that bit clear.  In other words, it prevents either mode from
accessing addresses that, according to the sign bit, belong to the other
mode.  Crucially, this policy is applied early in the execution of an
instruction.  Normal page protections 
can only be read (and, thus, enforced) by traversing through the page-table
hierarchy, which produces timing and cache artifacts.  LASS can trap a
forbidden access simply by looking at the address, without any reference to
the page tables, yielding constant timing and avoiding any internal
state changes.  And this test is easily performed during speculative
execution as well.
<p>
Of course, adding a new protection mechanism like this requires adaptation
in the kernel, which must disable LASS when it legitimately needs to access
user-space memory.  Most of the infrastructure needed to handle this is
already in place, since <a href="/Articles/517475/">supervisor-mode access
prevention</a> must be handled in a similar way.  There is a problem,
though, with the <a href="/Articles/446528/">vsyscall</a> mechanism,
which is a virtual system-call implementation.  The vsyscall area is
hardwired to be placed between the virtual addresses
<tt>ffffffffff600000</tt> and <tt>ffffffffff601000</tt>.  Since the sign
bit is set in those addresses, LASS will block accesses from user mode,
preventing vsyscalls from working.  LASS is thus mutually exclusive with vsyscalls; if one is
enabled, the other must be disabled.  Vsyscalls have long since been replaced
by the vDSO, but there may be old versions of the C library out there that
still use them.  If LASS support is merged, distributors will have to
decide which feature to enable by default.
<p>
LASS should be able to protect against speculative attacks where user
space is attempting to extract information from the kernel — Meltdown-based
attacks in particular.  It may not directly block most Spectre-based
attacks, which generally involve speculative execution entirely in kernel
space, but it may still be good enough to block the cache-based covert
channels used to get information out of the kernel.  The actual degree of
protection isn't specified in the patches, though, leading Dave Hansen to
<a
href="/ml/linux-kernel/8ac54f52-5bf0-bf6c-2473-7f0cf2a1a957@intel.com/">ask
for more information</a>:
<p>
<blockquote class="bq">
	LASS seemed really cool when we were reeling from Meltdown.  It
	would *obviously* have been a godsend five years ago.  But, it's
	less clear what role it plays today and how important it is.
</blockquote>
<p>
If LASS can allow some of the more expensive Meltdown and Spectre
mitigations to be turned off without compromising security, it seems worth
having.  But, for now, nobody has said publicly which mitigations, if any,
are rendered unnecessary by LASS.
<p>
In any case, it is not possible to buy a CPU that supports LASS now; it
will be necessary to wait until processors from the "Sierra Forest" line
become available.  Once those CPUs get out to where they can be tested, the
value of LASS will, hopefully, become more clear.  Until then, the
development community will have to do its best to decide whether a partial
fix to speculative-execution problems is better than the current state of
affairs.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures-x86">Architectures/x86</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Meltdown_and_Spectre">Security/Meltdown and Spectre</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/919683/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor919936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 16:35 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/919936/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Vsyscalls have long since been replaced by the vDSO, but there may be old versions of the C library</span><br>
<span class="QuotedText">&gt; out there that still use them. If LASS support is merged, distributors will have to decide which</span><br>
<span class="QuotedText">&gt; feature to enable by default.</span><br>
<p>
I have a couple of very old proprietary applications, that still work fine.<br>
How can I check if these use vsyscall?<br>
<p>
And will it be possible to disable LASS on a per-process basis?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 16:52 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/919937/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      For testing applications, you could try booting with <tt>vsyscall=none</tt> and see if they still work.  There's probably a better way but I don't know it offhand.
<p>
LASS is system-wide, so it can't be controlled on a per-process basis, at least in the posted implementation.


      
          <div class="CommentReplyButton">
            <form action="/Articles/919937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 17:07 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/919939/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cool. Thanks, Jonathan.<br>
I'll try that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 17:46 UTC (Fri)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/919943/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I took a very quick look at that bit of kernel code, it looks like the kernel cmdline option is the only way.<br>
<p>
However I bet you could trap those specific faults (I would imaging LASS would look like a page fault to the kernel? I haven't read it's docs, but it has to raise some sort of exception), and if they point at the vsyscall address, just jump the  corresponding vDSO address.<br>
<p>
Of course it would be slow, but old apps would still work.<br>
<p>
Alternately you might be able to get userfaultfd to be able to do something about this (though the kernel would have to forward the LASS fault correctly). I haven't had call to look into userfaultfd to know for sure though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 17:55 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/919944/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Patch 5 does discuss possibility of emulating vsyscalls: <a href="https://lwn.net/ml/linux-kernel/20230110055204.3227669-5-yian.chen@intel.com/">https://lwn.net/ml/linux-kernel/20230110055204.3227669-5-...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 18:09 UTC (Fri)
                               by <b>hansendc</b> (subscriber, #7363)
                              [<a href="/Articles/919948/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, it's theoretically possible to emulate vsyscalls that were thwarted by LASS.  But, the current emulation leverages page fault exceptions (#PF).  Those are nice because page faults set a control register (CR2) to the address that faulted.  That makes it dirt simple to tell if an access to the vsyscall page caused the fault: "if (is_vsyscall_vaddr(address))".<br>
<p>
LASS produces general protection faults (#GP).  Unfortunately, #GP's don't set CR2 and the CPU doesn't give great information about why the fault occurred.  It's quite possible to go fetch the instruction that faulted, decode it, and figure out that it was accessing the vsyscall page.  The kernel does exactly that for some #GP's.  But, it's kinda icky, and is best avoided.<br>
<p>
But, if someone *REALLY* cares deeply, please do speak up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 21:59 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/919966/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the case of a vsyscall, wouldn't the #GP have a saved instruction pointer in the vsyscall page (LASS documentation says "the fault is reported on the branch target, not the branch instruction")?<br>
<p>
Such an RIP would only be reachable with a call or jmp instruction, and if it was a call then the return address would already be on the stack. All you'd have to do would be invoke the system call, replace RIP with a word popped off the stack and go back to userspace.<br>
<p>
Not that it's a good idea. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2023 16:31 UTC (Tue)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/920234/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I assume what’s going on is that the CPU will fault on any attempt to set RIP to an address in the wrong half of the address space.<br>
<p>
Intel has an unfortunate history of designing CPUs that validate RIP when setting RIP instead of when using RIP. This results in rather unfortunate bugs^Woutcomes when doing creative things like putting a SYSCALL instruction at the very top of the lower half of the address space. The SYSCALL works fine and sets RCX (the saved pointer to the subsequent instruction) to RIP+2, which is noncanonical.  This is fine (from a very narrowly focused perspective) because RCX isn’t RIP.  A subsequent SYSRET will try to set RIP to the saved value and fault. This is fine because it’s how the CPU works (which is an excuse for almost anything), but it’s barely documented. The fault will cause an exception frame to be written to the user RSP, because that’s how SYSRET works (see above about excuses).  The result is privilege escalation.<br>
<p>
AMD generally seems more sensible in this regard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor919941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 18:03 UTC (Fri)
                               by <b>hansendc</b> (subscriber, #7363)
                              [<a href="/Articles/919941/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even without rebooting, you can also see if vsyscall emulation is being used:<br>
<p>
echo 1 &gt; /sys/kernel/debug/tracing/events/vsyscall/emulate_vsyscall/enable<br>
cat /sys/kernel/debug/tracing/trace_pipe <br>
<p>
Running tools/testing/selftests/x86/test_vsyscall_64 will let you know whether the tracing is working or not.<br>
<p>
BTW, if you run across a real program that cares, please do let us know.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 18:42 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/919951/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; BTW, if you run across a real program that cares, please do let us know.</span><br>
<p>
Building RHEL6 kernel in a container requires vsyscall=emulate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 13, 2023 20:07 UTC (Fri)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/919956/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The manylinux project (widely-compatible base ABI for Python builds) ran into this with CentOS 6, too.<br>
<p>
The solution we ended up going with was patching glibc to remove vsyscall support. The build scripts for that appear to be here: <a href="https://github.com/pypa/manylinux/tree/v2022.07.10-manylinux2010_x86_64_centos6_no_vsyscall/build_scripts">https://github.com/pypa/manylinux/tree/v2022.07.10-manyli...</a><br>
<p>
You can probably use the pre-built quay.io/pypa/manylinux2010_x86_64_centos6_no_vsyscall:2020-12-19-cd3e980 container, which contains the result of that build. For your use case of compiling RHEL 6 kernels, that should work.<br>
<p>
I also wrote a userspace vsyscall emulator using ptrace as an alternative: <a href="https://github.com/pypa/manylinux/pull/158/files">https://github.com/pypa/manylinux/pull/158/files</a> It definitely will cause a performance hit because every syscall will trap into the ptracer, but for the commenter above who has a proprietary program, this might be what you need. (Though, really, this should only be a problem for proprietary programs that make syscalls directly, e.g. by being static binaries; if they call into the system libc to make syscalls, then using a newer libc should be enough.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2023 17:50 UTC (Tue)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/920244/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That hack seems unlikely to work with if LASS is enabled.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2023 18:54 UTC (Tue)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/920246/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LASS generates a GPF if you access something with the high bit set, right? Wouldn't that show up to userspace as a SIGBUS or something? You'd probably have to change the == SIGSEGV check in the code, but as long as it sends a catchable signal, there should be a way to make it work.<br>
<p>
(Of course if you can use a non-vsyscall libc, that would be better....)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2023 21:40 UTC (Tue)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/920262/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’m still hoping for clarification, but I’m suspicious that RIP will point to the CALL into the vsyscall page, not into the vsyscall page.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor919981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 14, 2023 9:07 UTC (Sat)
                               by <b>dottedmag</b> (subscriber, #18590)
                              [<a href="/Articles/919981/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't RHEL6 ELS ended on Nov 30, 2022?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor920272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2023 0:25 UTC (Wed)
                               by <b>judas_iscariote</b> (guest, #47386)
                              [<a href="/Articles/920272/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
correct it is an annoying bug on a distribution that is out of support. burn it with fire!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor919977"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 14, 2023 6:50 UTC (Sat)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/919977/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the description of speculative execution is a bit muddled.  The second paragraph says that it runs with data not in the cache, guessing the value and continuing.  But the third paragraph talks about actually accessing the data, and putting it into the cache.  If speculative execution really were as described in the second paragraph, and never loaded anything from memory into the cache, then most cache-based side channel attacks would not be possible.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919977/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 14, 2023 11:00 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/919987/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Yes, this is not very clear.  The data in paragraph 1 is different from the data in paragraph 3. I will sketch how meltdown works as an example. 

<pre>
if (a != 0) {
  if ((*b &amp; 0x1) == 0) {
    load c
  } else {
    load d
  }
}
</pre>

a is 0, but it is not in the cache and the CPU speculates that a is not 0. As the speculation is mostly statistics, one can enforce this speculation. 
The pointer b points to non-accessible memory (e.g. kernel memory). Based on the value of *b, either c or d is loaded into the cache. Normally the access to *b would trigger a SEGFAULT, but as a is 0, the CPU detects at some point that this was all just speculation, it ignores the fault and continues as if nothing did happen. </br>

Now one can access c and d, measure the time this takes and conclude which of the two has been loaded into the cache. This gives away one bit from *b. </br>

So speculative execution does affect the cache. After all you can gain the most advantage if the value (c or d) is already on its way to the cache at the point of time when the value of a finally arrives at the CPU. </br>

The data that is not in the cache and whose value is point of speculation is a. The data that discovered is (one bit of) *b, and the data that is loaded into the cache is either c or d. The presence of c or d is used to discover the value of *b.




      
          <div class="CommentReplyButton">
            <form action="/Articles/919987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2023 12:11 UTC (Sun)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/920025/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your example require b to be in the cache, yes ?<br>
Then it computes *b, detect the fault, but still continue with load ?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2023 13:06 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/920032/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, b and *b should both be in the cache (the pointer and the data pointed to). Then misprediction is only detected after *b is evaluated and the load of c or d is already on its way. If *b would not be in the cache, probably a would arrive before *b and the inner if would never be evaluated. But *b would be loaded and one can just repeat the whole thing with some different a that is not yet in the cache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor919984"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 14, 2023 9:22 UTC (Sat)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/919984/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One huge benefit of LASS would be if it permitted turning *off* the unmapping of kernel space when in userspace, to improve syscall performance, without losing *as* much in the way of safety.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919984/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 14, 2023 11:02 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/919989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess that this is meant by the sentence:<br>
<span class="QuotedText">&gt; If LASS can allow some of the more expensive Meltdown and Spectre mitigations to be turned off without compromising security, it seems worth having. But, for now, nobody has said publicly which mitigations, if any, are rendered unnecessary by LASS.</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor920243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2023 17:45 UTC (Tue)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/920243/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm wondering why instead of trapping they just don't disable speculation between cross-modes. It would just slightly slow down accesses to the other mode without requiring software support. The vsyscall area would still be accessible without any effort. I suspect they've already thought about it and ditched the idea, but we don't know why.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor920537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for Intel's LASS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2023 18:47 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/920537/">Link</a>] 
      </p>
      
      </div>
      </summary>
      As described, LASS makes no sense that I can see.  It only fixes a part of Meltdown (the vulnerability where programs could extract data from mapped, but PROT_NONEd pages (typically user code reading kernel pages)).

<p>According to Intel, they put in Meltdown fixes in Coffee Lake Refresh in 2018 (AMD never was affected) and of course in later CPUs.  Given that all CPUs that get LASS already have the Meltdown fixes, what's the point of LASS?

<p>LASS would also prevent the kernel from accessing the user memory, which AFAIK would be a problem for the kernel; e.g., how does write(2) access the user-mode buffer that the kernel has to read in order to write it to a file.



      
          <div class="CommentReplyButton">
            <form action="/Articles/920537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
