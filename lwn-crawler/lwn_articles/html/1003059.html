        <!DOCTYPE html>
        <html lang="en">
        <head><title>The Homa network protocol [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/1003059/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/1003480/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/1003059/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The Homa network protocol</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 30, 2024</br>
           </div>
The origins of the TCP and UDP network protocols can be traced back a full
50&nbsp;years.  Even though networks and their use have changed radically
since those protocols were designed, they can still be found behind most
networking applications.  Unsurprisingly, these protocols are not optimal
for all situations, so there is ongoing interest in the development of
alternatives.  One such is the <a
href="https://homa-transport.atlassian.net/wiki/spaces/HOMA/overview">Homa
transport protocol</a>, developed by John Ousterhout (of <a
href="https://www.tcl.tk/">Tcl/Tk</a> and <a
href="https://raft.github.io/">Raft</a> fame, among other accomplishments),
which is aimed at data-center applications.  Ousterhout is currently trying
to get <a href="/ml/all/20241217000626.2958-1-ouster@cs.stanford.edu">a
minimal Homa implementation</a> into the kernel.
<p>
Most networking applications are still based on TCP, which was designed for
efficient and reliable transport of streams of data across a distributed
Internet.  Data-center applications, instead, are often dominated by large
number of small messages between many locally connected hosts.  The
requirements of TCP, including the establishment of connections and
ordering of data, add a lot of overhead to that kind of application.  The
design of Homa is intended to remove that overhead while taking advantage
of what current data-center networking hardware can do, with a focus on
minimizing the latency between a request and its response.
<p>
<h4>A quick Homa overview</h4>
<p>
At its core, Homa is designed for remote procedure call (RPC) applications;
every interaction on a Homa network comes down to a request and associated
reply.  A client will send a request message to a server that includes a
unique request ID; the server will send a reply back that quotes that ID.
The only state that exists on the server is held between the receipt of the
request and the receipt of the response by the client.
<p>
Much of the key to the performance of this protocol can be found in how
these messages are handled.  There is no connection setup; instead, the
client starts transmitting the request, with no introductory handshake, to
the server.  There is a limit on how many bytes of this "unscheduled"
request data can be sent in this manner, which is determined by the
round-trip time of the network; it should be just high enough to keep the
request-transmission pipeline full until an initial response can be
received from the server side.  The figure of about 10,000 bytes appears in
some of the Homa papers.
<p>
The initial request packet includes the length of the full request.  If the
request does not fit into the size allowed for the unscheduled data, the
client will wait for a "grant" response before sending any more.  That
grant should, if the server is responding quickly, arrive just as the
initial request data has finished transmitting, allowing the client to
continue sending without a pause.  Grants include a maximum amount of data
that can be sent, and thus function like the TCP receive window.
<p>
This machinery is intended to get a request to the server as quickly as
possible, but without the need for much, if any, buffering in the network
path between the two machines.  Priority queues are used to manage this
traffic, with unscheduled packets normally having the highest priority.
Lower priorities are used for granted traffic; the requests with the least
amount of data remaining to be received are given the highest priority.
<p>
Once the server has received the full request and processed it, a response
is sent back to the client.  Once again, the initial bytes are sent as
unscheduled packets, with grants required for the rest if the response is
large enough.  In the earlier descriptions of the protocol, the server
would forget everything it knew about the request immediately after sending
the response.  That created the possibility that requests could be resent
(if the response never arrives) and executed multiple times.  More recent
publications include an explicit acknowledgment message indicating that a
response has been received, with the sender retaining the necessary state
to retransmit a reply until that acknowledgment is received.
<p>
The details of the protocol are, of course, rather more complex than
described here.  There are, for example, mechanisms for clamping down on
the amount of unscheduled data sent if a server is finding itself
overloaded.  The receiving side of a message can request retransmission if
an expected packet does not arrive; unlike TCP and many other protocols,
Homa puts the responsibility for detecting lost packets onto the receiving
side.  There is also a fair amount of thought that has gone into letting
systems overcommit their resources by issuing more grants than they can
immediately handle; the purpose here is to keep the pipelines full even if
some senders do not transmit as quickly as expected.
<p>
See <a href="https://dl.acm.org/doi/10.1145/3230543.3230564">this paper</a>
for a more complete (and surely more correct) description of the Homa
protocol, <a
href="https://github.com/PlatformLab/HomaModule/blob/main/protocol.md">this
page</a>, which reflects some more recent changes, and <a
href="/Articles/914030/">this 2022 article</a> for more details.
<p>
<h4>Homa on Linux</h4>
<p>
The Unix socket interface was designed around streams, and is not a perfect
fit for Homa, but the implementation sticks with it to the extent it can.
A <a
href="https://man7.org/linux/man-pages/man2/socket.2.html"><tt>socket()</tt></a>
call is used to create a socket for communication with any number of other
systems; the <tt>IPPROTO_HOMA</tt> protocol type is used.  Homa can run
over either IPv4 or IPv6.  For server systems, a <a
href="https://man7.org/linux/man-pages/man2/bind.2.html"><tt>bind()</tt></a>
call can be used to set up a well-known port to receive requests; clients
need not bind to a port.
<p>
Messages are sent and received, as one might expect, with <a
href="https://man7.org/linux/man-pages/man2/sendmsg.2.html"><tt>sendmsg()</tt></a>
and <a
href="https://man7.org/linux/man-pages/man2/recv.2.html"><tt>recvmsg()</tt></a>,
but there are some Homa-specific aspects that developers must be aware of.
When sending a message, an application must include a pointer to this
structure in the <tt>msg_control</tt> field of the <tt>msghdr</tt>
structure passed to <tt>sendmsg()</tt>:
<p>
<pre>
    struct homa_sendmsg_args {
	uint64_t id;
	uint64_t completion_cookie;
    };
</pre>
<p>
If a request is being sent, <tt>id</tt> should be set to zero; the protocol
implementation will then assign a unique ID to the request (and write it
into <tt>id</tt>) before sending it to the server.  For a reply message,
<tt>id</tt> should be the ID value that arrived with the request being
responded to.  The <tt>completion_cookie</tt> value, which is only used for
requests, will be passed back to the caller with the reply data when it is
received.
<p>
The receive side is a bit more complicated, because Homa requires that the
buffer space for replies be registered before sending the first request on
a socket.  To do so, the process should allocate a range of memory, then
pass it into the kernel with <tt>SO_HOMA_RCVBUF</tt> <a
href="https://man7.org/linux/man-pages/man2/getsockopt.2.html"><tt>setsockopt()</tt></a>
operation, using this structure:
<p>
<pre>
    struct homa_rcvbuf_args {
	void *start;
	size_t length;
    };
</pre>
<p>
The <tt>start</tt> address must be page-aligned.  This memory is
split into individual buffers, called "bpages", each of which is
<tt>HOMA_BPAGE_SIZE</tt> in length; that size is 64KB in the current
implementation.  Each message will occupy at least one bpage; large
messages will be scattered across multiple, not necessarily contiguous,
bpages.
<p>
A message is received by making a call to <tt>recvmsg()</tt> with a
pointer to this structure passed in the <tt>msg_control</tt> field of
<tt>struct msghdr</tt>:
<p>
<pre>
    struct homa_recvmsg_args {
	uint64_t id;
	uint64_t completion_cookie;
	uint32_t flags;
	uint32_t num_bpages;
	uint32_t bpage_offsets[HOMA_MAX_BPAGES];
    };
</pre>
<p>
The flags field describes what the caller is willing to receive; it is a
bitmask that can include either or both of <tt>HOMA_RECVMSG_REQUEST</tt> (to
receive request messages) and <tt>HOMA_RECVMSG_RESPONSE</tt> (to receive
responses).  If <tt>id</tt> is zero, then <tt>HOMA_RECVMSG_RESPONSE</tt>
will cause any response message to be returned; otherwise, only a response
corresponding to the provided request ID will be returned.  On return,
<tt>num_bpages</tt> will indicate the number of bpages in the registered
buffer area have been used to hold the returned message;
<tt>bpage_offsets</tt> gives the offset of each one.
<p>
The bpages returned by this call are owned by the application at this
point, and will not be used by the kernel until they have been explicitly
returned.  That is done with a subsequent <tt>recvmsg()</tt> call, where
<tt>num_bpages</tt> and <tt>bpage_offsets</tt> will indicate a set of
bpages to be given back.
<p>
This code has been "<q>stripped down to the bare minimum</q>" to be able to
actually transmit requests and responses across the net; it is evidently
about half of the full set of Homa patches.  The intent, of course, is to
ease the task of reviewing the work and getting initial support into the
kernel; the rest of the work can come later.  In its current form,
according to the cover letter, its performance "<q>is not very
interesting</q>", but that is expected to improve once the rest of the work
is merged.
<p>
See <a href="https://www.usenix.org/system/files/atc21-ousterhout.pdf">this
paper</a> for more information on the Linux implementation of Homa.
<p>
<h4>Prospects</h4>
<p>
The Homa protocol originates at Stanford University, with support from a
number of technology companies.  Academic work often does not successfully
make the transition from interesting prototype into production-quality code
that can be accepted into Linux.  In this case, though, Ousterhout seems
determined to get the code into the mainline, and is trying to do the right
things to get it there.  Thus far, the four postings of the code have
yielded some conversations about the protocol, but have not yet resulted in
a detailed review of the code.  That suggests that the initial merge of
Homa is not imminent.
<p>
It does seem likely to happen at some point, though.  Then, it will be a
matter of whether the operators of large data centers decide that it is
worth using.  Complicating that question is Ousterhout's assertion (in the
above-linked paper) that, even in a kernel with less overhead than Linux,
CPUs simply are not fast enough to keep up with the increases in networking
speed.  The real future for Homa, he suggests, may be inside the networking
hardware itself.  In that case, the merging into Linux would be an
important proof of concept that accelerates further development of the
protocol, but its use in real-world deployments might be limited.  It does,
in any case, show how Linux is firmly at the center of protocol development
for modern networks.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-Protocols">Networking/Protocols</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/1003059/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor1003805"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IP protocol number</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2024 23:02 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/1003805/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For those who, like me, were wondering: this is IP protocol number 146 according to <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">https://www.iana.org/assignments/protocol-numbers/protoco...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003805/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1003806"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2024 23:05 UTC (Mon)
                               by <b>npws</b> (subscriber, #168248)
                              [<a href="/Articles/1003806/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This begs the question why the protocol has not been built on top of UDP.<br>
<p>
On a related note, 10, 15 years after DCCP has been merged, is there any real life use of this protocol?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003806/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003810"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 0:21 UTC (Tue)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/1003810/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
QUIC is layered on top of UDP because it has to contend with middleboxes. Homa is designed for the datacenter where you will generally not see middleboxes. What advantage would there be to putting UDP between Homa and IP?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003810/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 0:51 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/1003814/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not having to do it in the kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 1:19 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/1003816/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can send and receive raw IP from userspace: <a href="https://www.man7.org/linux/man-pages/man7/raw.7.html">https://www.man7.org/linux/man-pages/man7/raw.7.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 1:21 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/1003817/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Raw sockets require special permissions, and are in general not great for performance, if you have multiple listeners (i.e. multiple applications using Homa). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 1:24 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/1003818/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's a much better argument for UDP, sure. I was noting that it's *possible* to write raw IP protocols from userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor1003820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 7:03 UTC (Tue)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/1003820/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because there's an open source kernel that lets them implement what they want instead of using workarounds?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 9:48 UTC (Tue)
                               by <b>npws</b> (subscriber, #168248)
                              [<a href="/Articles/1003829/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is questionable whether this would really be a workaround. "The only state that exists on the server is held between the receipt of the request and the receipt of the response by the client". This sounds like pretty much what UDP is meant for, stateless query-response protocols. The benefits of using UDP are obvious, no need for a kernel implementation, at least initially, easier development, easier deployment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1004103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2025 17:30 UTC (Fri)
                               by <b>john_ousterhout</b> (guest, #175303)
                              [<a href="/Articles/1004103/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A user-space implementation of Homa is probably not a good idea because Homa's congestion control algorithm depends on having complete information about all traffic on the uplink. With a user-space implementation, no one app would have the complete information needed for congestion control (perhaps you could use shared memory among the apps to keep track of this, but that sounds pretty complex).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1004103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1004120"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2025 19:55 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/1004120/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The benefits of using UDP are obvious, no need for a kernel implementation, at least initially, easier development, easier deployment.</span><br>
<p>
Except that the costs (as I understand it) basically destroy all the benefits! It's called UDP/IP for a reason (although we normally drop the IP bit, same as TCP). The IP stands for Internet Protocol, which is designed to go through routers etc etc. Homa is designed for a LAN, where typically you're routing MAC addresses through a switch, not IP addresses through a router.<br>
<p>
So yes, the fundamental idea behind Homa and UDP is very similar. But the *implementation* is very different, and that's the whole point. And the whole point of Homa is that - by deleting all that overhead of routing - it gets a massive speedup.<br>
<p>
As the original article said, don't try to run Homa over a WAN. It's the (in)ability to be efficient over the WAN, that helps it be the Cheetah in the server room.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1004120/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1004121"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not UDP</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2025 20:17 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/1004121/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I don't think that routing, in particular, is key to the design of Homa, with the possible exception of the assumption that round-trip times will be short and constant.  Remember that Homa, too, is built on top of IP...


      
          <div class="CommentReplyButton">
            <form action="/Articles/1004121/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1003824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should this be implemented in endpoints at all?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 6:03 UTC (Tue)
                               by <b>buck</b> (subscriber, #55985)
                              [<a href="/Articles/1003824/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe I shouldn't be posting in ignorance, but …<br>
<p>
If the expectation is that host hardware won't be able to keep up and that the functionality will end up being in NICs, and if it requires prioritization in the network for different message types, then aren't you most of the way to Infiniband or maybe ROCE with Data Center Networking (DCQCN etc.) tuned up on all the switches?<br>
<p>
There was a somewhat skeptical viewpoint that came out on Homa from back about the same time LWN first wrote about it:<br>
<p>
<a href="https://blog.ipspace.net/2023/01/data-center-tcp-replacement/">https://blog.ipspace.net/2023/01/data-center-tcp-replacem...</a><br>
<p>
One of the LinkedIn comments reposted at the bottom contains a particularly eye-opening statement:<br>
<p>
<span class="QuotedText">&gt; Over 65% of Azure traffic (bytes and packets) uses RoCEv2, not TCP. TCP is a distant second.</span><br>
<p>
I wonder how the proportion has changed in the interim.<br>
<p>
While I think a dumb network and the end-to-end principle is usually for the best, it doesn't sound like anybody is really looking to add any value here but speed, which seems like a job for hardware, since the field is already full of hardware competitors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should this be implemented in endpoints at all?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 9:26 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/1003828/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; While I think a dumb network and the end-to-end principle is usually for the best, it doesn't sound like anybody is really looking to add any value here but speed, which seems like a job for hardware, since the field is already full of hardware competitors.</span><br>
<p>
This is a see-saw. Look at pretty much anything, you'll see it implemented in the CPU because hardware can't keep up, then dedicated hardware takes over because it's faster, then the CPU takes over because the hardware has ossified ...<br>
<p>
This is just another iteration of the same loop...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1003897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should this be implemented in endpoints at all?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 1, 2025 5:06 UTC (Wed)
                               by <b>Jordan_U</b> (subscriber, #93907)
                              [<a href="/Articles/1003897/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But now there won't be ossification because you'll just be able to update the docker container running on your NIC!<br>
<p>
Progress!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1004104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should this be implemented in endpoints at all?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2025 17:34 UTC (Fri)
                               by <b>john_ousterhout</b> (guest, #175303)
                              [<a href="/Articles/1004104/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Infiniband has just about all of the performance problems of TCP when it comes to congestion control etc.. The only advantage of Infiniband is that people like Mellanox built really nice NICs for it that bypass the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1004104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1004130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should this be implemented in endpoints at all?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2025 22:29 UTC (Fri)
                               by <b>bvanassche</b> (subscriber, #90104)
                              [<a href="/Articles/1004130/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><em>
Infiniband has just about all of the performance problems of TCP when it comes to congestion control etc.. The only advantage of Infiniband is that people like Mellanox built really nice NICs for it that bypass the kernel.
</em></p>
<p>Is there any scientific paper that backs the above statement about congestion? Multiple papers have been published about how to handle congestion in datacenter RDMA networks. Two examples:<p>
<ul>
<li>Zhu, Yibo, Haggai Eran, Daniel Firestone, Chuanxiong Guo, Marina Lipshteyn, Yehonatan Liron, Jitendra Padhye, Shachar Raindel, Mohamad Haj Yahia, and Ming Zhang. "Congestion control for large-scale RDMA deployments." ACM SIGCOMM Computer Communication Review 45, no. 4 (2015): 523-536.</li>
<li>Shpiner, Alexander, Eitan Zahavi, Omar Dahley, Aviv Barnea, Rotem Damsker, Gennady Yekelis, Michael Zus, Eitan Kuta, and Dean Baram. "RoCE rocks without PFC: Detailed evaluation." In Proceedings of the Workshop on Kernel-Bypass Networks, pp. 25-30. 2017.</li>
</ul>





      
          <div class="CommentReplyButton">
            <form action="/Articles/1004130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1004283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should this be implemented in endpoints at all?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2025 17:10 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/1004283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Congestion control is far from a solved problem, especially not across wider, less-controlled / uncoordinated networks. Some say ECN is the magic bullet, especially in its recent updated form of L4S / TCP Prague. Others (including a regular commenter here on LWN on networking matters, and Linux congestion/buffering contributor) I think disagree with that. <br>
<p>
Congestion control is a bit easier on low-hop, tightly controlled networks - i.e. DCs - but even there it is not solved. Fairness across different kinds of CC in particular is a bitch, as is fairness across flows with very different RTTs and/or BDPs. E.g., congestion controller might work great competing with low-latency, fast connections (i.e. intra-DC), but have issues with fairness competing with flows with different properties, like much higher RTT (e.g., cross-region DC to DC). It's clearly not at all an easy problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1004283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1004140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should this be implemented in software at all?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2025 6:35 UTC (Sat)
                               by <b>buck</b> (subscriber, #55985)
                              [<a href="/Articles/1004140/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry the comment you were responding to was so provocative.<br>
<p>
Your reply was, by contrast, most gracious (I say as someone who has no emotional attachment to Infiniband design [grin]).<br>
<p>
But since I can't withdraw my comment (I think), I at least fixed the Subject of this reply to reflect what my provocative question really was. (I certainly didn't mean to exclude NICs as an implementation target, which are probably considered, by anybody's definition, part of an "endpoint", or maybe even an "endpoint" in their own right, if they are smart NICs/"DPUs".)<br>
<p>
That said, if you are being gracious enough to give your code away, it's not my business to question what use the rest of the world may find to make of it. Clearly it has found plenty of use for Raft, TCL, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1004140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor1003847"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rx</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2024 14:46 UTC (Tue)
                               by <b>grawity</b> (subscriber, #80596)
                              [<a href="/Articles/1003847/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It reminded me a little bit of Rx, a fairly old RPC-transport used by AFS (and which also happens to have special kernel support as AF_RXRPC). From what I recall – if I recall correctly, that is –, Rx also does per-call congestion control instead of per-connection (it is connectionless), and it's what leads to its miserable performance over any sort of non-single-digit latency... But I guess it won't matter for a data center?<br>
<p>
And while I too like some protocols having their own IP protocol numbers, it definitely seems like a very limiting choice here, when UDP would provide multiplexing and unprivileged userspace access alike without any kernel changes (it's literally what UDP was meant for).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1003847/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1004205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Homa?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2025 18:26 UTC (Sun)
                               by <b>tao</b> (subscriber, #17563)
                              [<a href="/Articles/1004205/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With a name like Homa I was fully expecting it to deal with Home automation, not data-center applications...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1004205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1004302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does the Homa network protocol support zero-copy data reception?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2025 22:39 UTC (Mon)
                               by <b>bvanassche</b> (subscriber, #90104)
                              [<a href="/Articles/1004302/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      To achieve high performance, the CPU should not copy the contents of network data buffers. Does the Homa network protocol support sending and receiving data without copying it? The RDMA userspace verbs API supports this. The Berkeley socket API does not support zero-copy TCP receive (except when using <a href="https://lwn.net/Articles/752188/">mmap()</a>).


      
          <div class="CommentReplyButton">
            <form action="/Articles/1004302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1004319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does the Homa network protocol support zero-copy data reception?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2025 11:29 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/1004319/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know Homa, other than via 2 articles on LWN and the papers on it. The interface Homa presents, as described in this article, appears to be explicitly designed for zero-copy receive though - note how userspace allocates the buffer, and the API then allows responsibility/ownership of the buffer to be transferred back and forth between kernel and userspace. I.e., userspace assigns a set of buffers to the kernel, allowing the kernel to setup direct DMA to the buffer, and then ownership is transferred back to userspace on completion - allowing it to do what it wants with the same buffer. <br>
<p>
IIUC correctly anyway.<br>
<p>
On the Tx side, sendmsg() API is already capable of zerocopy - see <a href="https://www.kernel.org/doc/html/latest/networking/msg_zerocopy.html">https://www.kernel.org/doc/html/latest/networking/msg_zer...</a> . I assume, but do not know, that Homa relies on this existing userspace API for zerocopy on the Tx side.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1004319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
