        <!DOCTYPE html>
        <html lang="en">
        <head><title>Making use of persistent memory [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/674752/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/674649/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/674752/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Making use of persistent memory</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 10, 2016</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2016-linux.conf.au">linux.conf.au 2016</a>
</div>
Persistent memory holds a lot of promise: what's not to like about vast
amounts of directly-attached memory that remembers its contents over a
power cycle?  For some years we have been told that large persistent-memory
arrays are coming; now it seems that they are about to arrive.  According
to Matthew Wilcox, who spoke on the topic at <a
href="http://linux.conf.au/">linux.conf.au</a> 2016, Intel 
wants persistent memory to become a regular platform feature.  It will
start by shipping server platforms supporting 6TB arrays in 2017.  Matthew's
question was: how will we make use of that persistent memory?
<p>
There are a lot of ideas out there, he said, many of which have been
promoted by academics — most of whom are not greatly concerned about
practicality.  Start, for example, with the idea of total system
persistence, where the entire system can be turned off at any time and,
when powered back on, will simply pick up where it left off.  The problem
here is that the CPU caches are <i>not</i> persistent, and there is no easy

<a href="/Articles/674879/"><img
src="https://static.lwn.net/images/conf/2016/lca/MatthewWilcox-sm.jpg" width=200 height=250
alt="[Matthew Wilcox]" title="Matthew Wilcox" border=0 hspace=3 vspace=3
align="right"></a> 


way to know when all writes to main memory have completed.  Whole-system
persistence is a "delightful" idea, but it is not something that can be
done with today's hardware.
<p>
Stepping back a bit, one can try for application persistence — using
persistent memory to make cheap application snapshots.  Unfortunately, the
cache problem exists here as well.
<p>
Perhaps what needs to be done is to completely redesign the operating
system, creating a new system designed around persistent memory from the
beginning.  The "new" ideas that proponents of this idea bring up tend to
have a familiar ring to them: microkernels, nanokernels, unikernels, etc.
Matthew suggested that some people see new technology as an opportunity to
push the same ideas they have been promoting for years.  He wishes them the
best, but is looking for something that will work today.
<p>
Some developers at Intel created a new filesystem for persistent memory
called <a href="https://github.com/linux-pmfs/pmfs">pmfs</a>.  They are,
he said, smart people, but they are not 
Linux kernel developers.  As a result, the work they did is not suitable
for production settings.
<p>
What <i>can</i> be done today is to package up a persistent-memory array
and export it 
as a fast block device.  We <a href="/Articles/640113/">have support for
that</a> in the kernel
now, but, he said, it doesn't feel like a general-purpose solution.  To get
to that more general solution, he set out to make some small modifications
to existing filesystems so that they could make use of persistent memory;
he allowed that it was perhaps good that Dave Chinner was unable to attend
the conference, since Dave might just quibble with Matthew's notion of
"small".  In any case, Matthew started with the existing execute-in-place
support, rewrote it, and ended up with <a href="/Articles/610174/">the
subsystem now known as DAX</a>.
<p>
<h4>Beyond filesystems</h4>
<p>
There is more to proper persistent-memory support than getting the
filesystems to work, though.  Down at the CPU level, Intel's
designers have created a new set of instructions for use with persistent
memory.  The intent is to allow developers to initiate the flushing of
specific cache lines; it is not possible to know when a write completes,
but the operation can at least be started when needed.  The
<tt>CLFLUSH</tt> instruction has existed for years; its job is to remove a
line of data from the cache.  It is not optimal for persistent-memory
applications, though, because it serializes the instruction stream, hurting
performance.
<p>
That shortcoming will be addressed with the <tt>CLFLUSHOPT</tt>
instruction, which does not perform that serialization.  In the future,
there will also be <tt>CLWB</tt>, which starts writing out the cache line
but does not remove the data from the cache.  Finally, the <tt>PCOMMIT</tt>
instruction will ensure that all data written prior to the last
store fence is persistent.  It may not be written to a specific
persistent-memory array, but it will be in persistent storage somewhere.
<p>
There is still the question of how application programmers should make use
of persistent memory.  One option would be to create a special-purpose
programming language that natively understands persistence, but that, he
said, is not particularly interesting.  A bit more practical might be to
modify the runtime virtual machines for language like Python to get them to
issue the new instructions when needed.  That would avoid the need for code
changes in general, but is still not entirely interesting to "dinosaurs"
like him, who want to program in languages like&nbsp;C.
<p>
For such people, there is <a href="http://pmem.io/nvml/">a whole set of new
libraries</a> available.  At the 
lowest level, <tt>libpmem</tt> simply provides easy access to the new
instructions, but adds little otherwise.  The
<tt>libvmmalloc</tt> library supplies a replacement for
<tt>malloc()</tt> that can allocate from persistent memory.  It can also be
used for non-persistent applications; indeed, applications can be linked
against this library and be unaware that they are using persistent memory
at all.
For developers who are willing to code specific persistent-memory awareness
into their applications, there is <tt>libvmem</tt>.  It provides better
performance on persistent memory, but is still mainly expected to be used
with memory used as if it were volatile.
<p>
Developers wanting utilities to help with the storage of persistent memory
can use <tt>libpmemblk</tt>, which provides access to atomic blocks of
memory.  Log-oriented applications, which append data to an existing
structure, can use <tt>libpmlog</tt> to manage logs easily in persistent
memory.  But the interesting one, he said, is <tt>libpmemobj</tt>, which
provides a transactional object store on top of persistent memory.  It
provides locking that persists over system boots, type safety, and data
structures like doubly linked lists and a key-value store.  It can handle
replication of data across files.  And, for those who are so inclined, C++
support has been added in recent months.
<p>
Quite a bit of functionality has been built on these libraries, he said.
There is, for example, a MySQL storage engine that uses it.  Interested
developers can go to <a href="http://pmem.io/">pmem.io</a>, which hosts a
blog, pointers to the source, and other information.  There is also <a
href="http://intel.com/nvm/">intel.com/nvm</a>, which has mostly marketing
material about the upcoming persistent-memory hardware.  It
appears that, after years of hype, the hardware will soon be available, and
the software support will be there for it as well.
<p>
The <a
href="http://mirror.linux.org.au/linux.conf.au/2016/04_Thursday/Costa_Hall/Using_Persistent_Memory_for_Fun_and_Profit.webm">video
of this talk</a> is available for those wanting more information.
<p>
[Your editor thanks LCA for assisting with his travel expenses.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Nonvolatile_memory">Memory management/Nonvolatile memory</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#linux.conf.au-2016">linux.conf.au/2016</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/674752/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor675147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 7:36 UTC (Thu)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/675147/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I remember correctly, magnetic core memory was non-volatile, right? How did people make use of this fact back then?<br>
<p>
[Too many old ideas are forgotten and then painfully re-invented again, you see.]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 12:52 UTC (Thu)
                               by <b>zmower</b> (subscriber, #3005)
                              [<a href="/Articles/675184/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Like <a href=http://www.computerhistory.org/collections/catalog/XD130.80>this</a>?  These were the days before operating systems.  Persistent storage was punched cards or papertape if you were lucky and keying in programs with buttons if not!  Then the much cheaper and capable SRAMs came along which lost their contents when powered off.  Microcomputers happened and here we are today.
      
          <div class="CommentReplyButton">
            <form action="/Articles/675184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor675196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 15:04 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/675196/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I worked for a while with a Data General Nova, built into a radar van, that had core memory.  We "made use" of that fact by just turning off the power at night, and having it pick up again in the morning when we turned it on.  Probably worked about 80% of the time, otherwise we had to boot from the beginning.
<p>
Back then, though, it was just memory; persistence was just a side effect of how it worked.  Even then, when systems didn't do the sort of memory caching we see today, there was enough that could go wrong between power cycles that nobody depended on it to safely store data.  Now, hopefully, we can.
      
          <div class="CommentReplyButton">
            <form action="/Articles/675196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor675148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 7:45 UTC (Thu)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/675148/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <q>Start, for example, with the idea of total system persistence, where the entire system can be turned off at any time and, when powered back on, will simply pick up where it left off. The problem here is that the CPU caches are not persistent, and there is no easy [Matthew Wilcox] way to know when all writes to main memory have completed.</q>
<p/>
The same problem exists with hard disks, and yet they are considered non-volatile. Maybe the computers of today are not able to detect and react quickly enough to a sudden power loss, but surely systems could easily be designed to overcome this limitation?

      
          <div class="CommentReplyButton">
            <form action="/Articles/675148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675263"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 23:11 UTC (Thu)
                               by <b>Jonno</b> (subscriber, #49613)
                              [<a href="/Articles/675263/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On hard drives the problem is solved by explicit flushes and write barriers, which current CPUs can't do for persistent-memory. And even so there is lots of ways for things to go wrong with regards to recently written data, for an undefined value of "recently".<br>
<p>
As long as CPU cache, CPU registers, and/or peripheral devices remain volatile computers will likely never be able to just pick up where it was and go on after a sudden power loss, but with persistent main memory it should be possible to get a system suspend mode combining the simplicity and performance of sleep and the power savings of hibernate. An with a big enough battery or capacitor it should be possible for the kernel to try to enter that mode if main power disappears (though misbehaving peripheral devices or their drivers would still be able to sabotage it).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675263/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor675188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 14:33 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/675188/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      The promise of hardware-persistent memory always makes people think that we now can just use main memory and get rid of dealing with files, file systems, etc.  But we have actually had (software-)persistent memory for a long time, e.g., in the <a href="http://www.eros-os.org/papers/storedesign2002.pdf">EROS single-level store</a>, but it never became mainstream.  There is a reason for that.

<p>We need files and file formats for purposes besides just persistence: In particular, for exchanging data and for moving it from one version of a program to the next.  These purposes are still needed even with hardware-persistent memory, so we still need to deal with files.

<p>As an example of what happens when you ignore that, consider the pre-XML Microsoft Word format, which was reported to be mostly a memory dump of a part of the Word process.  Problems I have heard of with that format were that 1) you could corrupt your Word, and that corruption would be preserved across saving the document, and using it in a new Word process; 2) the file contained data that the users had intended to erase from the document.

<p>BTW, I am an academic:-).
      
          <div class="CommentReplyButton">
            <form action="/Articles/675188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 23:23 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/675264/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I find the CPU cache issue a red herring. That would only matter if you are planning on removing power at any arbitrary time, including in the middle of a write to memory and still expecting zero data loss (and if you pull power in the middle of a write to memory, which version do you expect to find there when you resume?)<br>
<p>
We are not going to be having devices that just loose power at random times. We are going to have devices where the CPU is much more willing to power off parts or all of the system. And the CPU can make sure that it's flushed it's caches when it does so, so it just won't be an issue.<br>
<p>
The real things that will drive how persistent memory is used is it's price, density, speed, and power consumption.<br>
<p>
Is it really going to be faster, cheaper, etc than DDRx ram? I really would be surprised if that was the case. Frankly, I do not expect that the Persistent memory is going to be as fast as simpler RAM (the more that has to be done to read/write the data, the harder it will be to ramp up clock speeds)<br>
<p>
If it's not better in all ways, then it's unlikely that systems will use persistent memory exclusively (except in some admittedly important corner cases like mobile/IoT devices)<br>
<p>
<p>
If you have a system that has regular RAM, persistent RAM, and flash/disk. I fully expect to see the persistent RAM used as a staging area before going to disk, a fast swap, and for queues of various types that databases and other software currently have to jump through a lot of hoops to get working halfway well on disks today.<br>
<p>
In the mobile/embedded space where they frequently only install one chip of RAM, making that chip be persistent will have a wonderful effect on battery life, it will mean that when the CPU decides that it can sleep, it doesn't have to do a lot of effort to preserve state, onto permanent storage, it just flushes it's CPU caches, enables the wake events, and powers itself off<br>
<p>
Besides, if persistent memory really is that great, how long before the CPUs (at least at the low end where performance isn't the primary factor) start using it in the core?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2016 13:11 UTC (Fri)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/675311/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>That would only matter if you are planning on removing power at any arbitrary time, including in the middle of a write to memory and still expecting zero data loss (and if you pull power in the middle of a write to memory, which version do you expect to find there when you resume?)
</blockquote>
Well, that's what we expect from databases: that they can survive going down at any point, and after a recovery process, we can re-open them and keep going as normal.
<blockquote>
We are not going to be having devices that just loose power at random times
</blockquote>
Good: I have this mental image of a device like that, letting power loose in the form of arcs hitting anything conductive nearby at random times...
<p>
But we all know what you meant, and that puts a <b>major</b> limitation on where you can use persistent memory. It rules it out of desktop systems, it probably rules it out of consumer devices with removable batteries, and it even makes server applications much dodgier: UPSes do fail, "high availability" virtual machines will occasionally end up being migrated behind the same UPS, and recovery time is important, if only because you know that the business is going to be on IT's back demanding that they can get on with doing the stuff they couldn't do during the unscheduled downtime.
<p>
Backups are good. Needing to use backups is bad.

      
          <div class="CommentReplyButton">
            <form action="/Articles/675311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2016 1:47 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/675454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well, that's what we expect from databases: that they can survive going down at any point, and after a recovery process, we can re-open them and keep going as normal. </font><br>
<p>
they do that by doing a very convoluted process so that they can tell that something only got partially written and write it again from a buffer.<br>
<p>
You really don't want to have to do that for every write to memory.<br>
<p>
<font class="QuotedText">&gt; it probably rules it out of consumer devices with removable batteries</font><br>
<p>
no, it just means that such devices have a small capacitor in them so that when they detect the loss of power, they can still do their 'suspend' work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor675328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2016 14:35 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/675328/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
I find the CPU cache issue a red herring. That would only matter if you are planning on removing power at any arbitrary time, including in the middle of a write to memory and still expecting zero data loss (and if you pull power in the middle of a write to memory, which version do you expect to find there when you resume?)
</blockquote>

Power loss is not instantaneous.  Voltage drops over time, and you have a little time until your hardware becomes incapable of writing reliably (and by that time it should have done all it's writing, otherwise the memory contents may be corrupted; I have experienced hard disks that did not get that right).  Anyway, when the system detects that power is failing, it should write all the caches back to permanent storage, and then store the CPU registers (as in a context switch), and the state of I/O devices.  When power comes back on, it should wait for the capacitors to be sufficiently full to perform a full shutdown again, then load the CPU and the state of I/O devices, and then continue processing.  There would still be some lossage, e.g., due to broken connections, but applications typically know how to deal with that.  So I think that the power loss situation is one where persistent memory could be helpful, if implemented well.

<p>Concerning the CPU caches, I expect that they can be dumped to memory already now for suspend-to-memory; or is the CPU kept powered-on in that state?

      
          <div class="CommentReplyButton">
            <form action="/Articles/675328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2016 1:50 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/675455/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point I', trying to make is that power loss is still a 'suspend' event, just a much faster one since there's far less data to worry about.<br>
<p>
the persistent memory cheerleaders try and make it sounds as if the system/os doesn't need to do _anything_ and the memory technology will avoid all problems.<br>
<p>
But the reality is that you need to treat it like a suspend problem. stop all ongoing activity (so you don't have a partial write somewhere) and write the volitile stuff (including CPU caches) to non-volitile storage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2016 3:45 UTC (Sat)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/675462/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree.<br>
<p>
If you use persistent memory like we've always used memory, then it isn't importantly different from the battery backed memory that laptops have had for years - maybe a bit bigger.<br>
If you use persistent memory like we've always used disk drives, then it behaves much like disk drives, or at least flash drives - maybe faster.<br>
You can use persistent memory like both memory and disk drives, but virtual memory has allowed that for years too - maybe with a bit more flexibility in sizing.<br>
<p>
While there are lots of interesting challenges on the implementation side, I think that for the user - persistent memory just means: a bit bigger, a bit faster, a bit more flexible.<br>
<p>
You will still need a suspend/resume discipline to save power - but you save more power.  You still need a RAID discipline to avoid data loss due to hardware error, though reliability is probably higher.  You still need to lay out long-term data like a filesystem, though the details of the layout can be different.<br>
<p>
If persistent memory ushers in a whole new usage-pattern, it wont be because memory is suddenly persistent.  It will be because someone finds a clever way to use bigger/faster/more-flexible/more-reliable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor675474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2016 7:37 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/675474/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
again, not a completely new idea, but rather a refinement on existing efforts.<br>
<p>
<p>
We know that Amazon has talked about wanting kindles to be able to go to sleep between keypresses in the past, but sleep/wake time hasn't been fast enough, would this shrink the amount of stuff needed to allow that?<br>
<p>
with persistent memory, you could also eliminate the flash storage, everything would just be stored in memory.<br>
<p>
how close are we to being able to build a e-ink reader that can power itself from an embeded solar panel? Without a need to power flash, scan a keyboard, or keep a touchscreen live, a simple e-reader should be able to wake-on-buttonpress, change the display, and go back to sleep. require USB to load stuff onto it so you don't have to power a radio (or use bluetooth low power, only enabled with a keypress)<br>
<p>
and what new price threshold would such a device pass that would enable nifty new uses? The Kindle sales really took off when they dropped below $100, are we now taking about devices that could drop below $10??<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor675511"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Integrity and backups of persistent memory?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2016 18:35 UTC (Sat)
                               by <b>songmaster</b> (subscriber, #1748)
                              [<a href="/Articles/675511/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is persistent memory being built with ECC or at least parity bits? Permanent storage on rotating media usually has a per-sector CRC to catch the effect of bits getting corrupted, but it's not obvious how to handle this on directly-accessible storage — maybe there could be some kind of CRC check done on a persistent page whenever it gets mapped into memory, and the checksum calculated and saved whenever it gets unmapped again (although that doesn't protect the page's integrity while it's mapped). I hope someone is thinking about these topics, I haven't heard talk about making backups of the contents of PM, or of anything like RAID for higher levels of integrity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675511/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor676200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2016 10:38 UTC (Thu)
                               by <b>oldtomas</b> (guest, #72579)
                              [<a href="/Articles/676200/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a very important observation. If you use persistent memory as "the whole status gets persisted" you persist unwanted corruption with it. No more "switch off, then on and all is well" (sometimes the system is so botched that reboot is not possible).<br>
<p>
As a little anecdote to make you smile: long years ago, a friend of mine had an electromechanical calculator (four arithmetics and square root: his father was an engineer). The "mechanical" part in electromechanical provided some sort of persistence.<br>
<p>
Obviously this marvel performed division by succesive subtraction: on divide-by-zero it went on an endless and quite noisy frenzy -- prompting the user to switch it off.<br>
<p>
That didn't help, though: switching it on again just resumed that frenzy...<br>
<p>
(Yes, there was some mysterious way to get things to normal again).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/676200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor675266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 23:35 UTC (Thu)
                               by <b>jhhaller</b> (guest, #56103)
                              [<a href="/Articles/675266/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The term I've seen used the most is non-volatile byte-addressable memory (NVBM). A couple of proposed use cases that I've run across in my looking at potential uses:
<UL>
<LI>
<A href=http://tolia.org/files/pubs/fast2011.pdf>Consistent and Durable Data Structures for Non-Volatile Byte-Addressable Memory, 2011</A>
</LI>
<LI>
<A href=http://www.sigops.org/sosp/sosp09/papers/condit-sosp09.pdf>Better I/O Through Byte-Addressable, Persistent Memory, 2009</A>
</LI>
</UL>
The key for NVBM is providing significantly cheaper and denser storage than RAM without being significantly slower. One advantage of NVBM is being able to avoid using both backing store and cache, as those are combined for workloads which fit into RAM, at a lower cost than RAM. Challenges include data integrity, and endurance, for applications where those are important. Other issues relate to data protection and concurrency, and how they may differ from RAM cache and backing store. Data privacy becomes a concern when one can boot a different operating system and have your way with the existing persistent storage. While some of these issues may be similar to those of block storage, the tools to deal with them are likely to be different. While using NVBM as a fast block device may be a good first step, it misses the advantage of having the storage be directly available.
<P>
The HP Machine is mostly based on NVBM, with the extension of having the memory widely addressable across multiple CPU sockets. That extension has some different challenges than those of a single server accessing NVBM, but deals with some of the challenges as well.
<P>
I would be shocked if there aren't already startups looking to provide new databases based on using NVBM directly, with such companies coming out of stealth mode once the hardware is really available.
      
          <div class="CommentReplyButton">
            <form action="/Articles/675266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor676566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Making use of persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2016 2:10 UTC (Sat)
                               by <b>welinder</b> (guest, #4699)
                              [<a href="/Articles/676566/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That shortcoming will be addressed with the CLFLUSHOPT instruction, ...</font><br>
<p>
I don't care what the docs say.  That will forever be known as the<br>
flu shot instruction.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/676566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2016, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
