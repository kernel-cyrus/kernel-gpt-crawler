        <!DOCTYPE html>
        <html lang="en">
        <head><title>Ensuring data reaches disk [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/457667/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/457315/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/457667/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Ensuring data reaches disk</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="GAByline">
           <p>September 7, 2011</p>
           <p>This article was contributed by Jeff Moyer</p>
           </div>
In a perfect world, there would be no operating system crashes, power
outages or disk failures, and programmers wouldn't have to worry about
coding for these corner cases.  Unfortunately, these failures are more
common than one would expect.  The purpose of this document is to
describe the path data takes from the application down to the storage,
concentrating on places where data is buffered, and to then provide
best practices for ensuring data is committed to stable storage so it
is not lost along the way in the case of an adverse event.  The main
focus is on the C programming language, though the system calls
mentioned should translate fairly easily to most other languages.
<p>
<h4>I/O buffering</h4>
<p>
In order to program for data integrity, it is crucial to have an
understanding of the overall system architecture.  Data can travel
through several layers before it finally reaches stable storage, as
seen below:
<p>
<blockquote>
<img src="https://static.lwn.net/images/2011/jm-data-flow.png" width=500 height=269 alt="[Data
flow diagram]">
</blockquote>
<p>
At the top is the running application which has data that it needs to
save to stable storage.  That data starts out as one or more blocks
of memory, or buffers, in the application itself.  Those buffers can
also be handed to a library, which may perform its own buffering.
Regardless of whether data is buffered in application buffers or by a
library, the 
data lives in the application's address space.  The next layer that the data
goes through is the kernel, which keeps its own version of a
write-back cache called the page cache.  Dirty pages can live in the
page cache for an indeterminate amount of time, depending on overall
system load and I/O patterns.  When dirty data is finally evicted from
the kernel's page cache, it is written to a storage device (such as a
hard disk).  The storage device may further buffer the data in a
volatile write-back cache.  If power is lost while data is in this
cache, the data will be lost.  Finally, at the very bottom of the
stack is the non-volatile storage.  When the data hits this layer, it
is considered to be "safe."
<p>
To further illustrate the layers of buffering, consider an
application that listens on a network socket for connections and
writes data received from each client to a file.  Before closing the
connection, the server ensures the received data was written to stable
storage, and sends an acknowledgment of such to the client.
<p>
After accepting a connection from a client, the application will need
to read data from the network socket into a buffer.  The following
function reads the specified amount of data from the network socket
and writes it out to a file.  The caller already determined from the
client how much data is expected, and opened a file stream to write
the data to.  The (somewhat simplified) function below is expected to
save the data read from the network socket to disk before
returning.
<p>
<blockquote>
<pre>
 0 int
 1 sock_read(int sockfd, FILE *outfp, size_t nrbytes)
 2 {
 3      int ret;
 4      size_t written = 0;
 5      char *buf = malloc(MY_BUF_SIZE);
 6 
 7      if (!buf)
 8              return -1;
 9
10      while (written &lt; nrbytes) {
11              ret = read(sockfd, buf, MY_BUF_SIZE);
12              if (ret =&lt; 0) {
13                      if (errno == EINTR)
14                              continue;
15                      return ret;
16              }
17              written += ret;
18              ret = fwrite((void *)buf, ret, 1, outfp);
19              if (ret != 1)
20                      return ferror(outfp);
21      }
22 
23      ret = fflush(outfp);
24      if (ret != 0)
25              return -1;
26 
27      ret = fsync(fileno(outfp));
28      if (ret &lt; 0)
29              return -1;
30      return 0;
31 }
</pre>
</blockquote>
<p>
Line 5 is an example of an application buffer; the data read from the
socket is put into this buffer.  Now, since the amount of data
transferred is already known, and given the nature of network
communications (they can be bursty and/or slow), we've decided to use
libc's stream functions (fwrite() and fflush(), represented by "Library
Buffers" in the figure above) in order to further buffer the data.
Lines&nbsp;10-21 take care of reading the data from the socket and writing it
to the file stream.  At line&nbsp;22, all data has been written to the file
stream.  On line&nbsp;23, the file stream is flushed, causing the data to
move into the "Kernel Buffers" layer.  Then, on line&nbsp;27, the data is
saved to the "Stable Storage" layer shown above.
<p>
<h4>I/O APIs</h4>
<p>
Now that we've hopefully solidified the relationship between APIs and
the layering model, let's explore the intricacies of the interfaces in
a little more detail.  For the sake of this discussion, we'll break
I/O down into three different categories: system I/O, stream I/O, and
memory mapped (mmap) I/O.
<p>
System I/O can be defined as any operation that writes data into the
storage layers accessible only to the kernel's address space via the
kernel's system call interface.  The following routines (not
comprehensive; the focus is on write operations here) are part of the
system (call) interface:
<p>
<blockquote>
<table>
<tr><th>Operation</th><th align="left">Function(s)</th></tr>
<tr class="Odd"><td>Open</td><td><tt>open()</tt>, <tt>creat()</tt></td></tr>
<tr class="Even"><td>Write</td><td><tt>write()</tt>, <tt>aio_write()</tt>,
		<tt>pwrite()</tt>, <tt>pwritev()</tt></td></tr>
<tr class="Odd"><td>Sync</td><td><tt>fsync()</tt>, <tt>sync()</tt></td></tr>
<tr class="Even"><td>Close</td><td><tt>close()</tt></td></tr>
</table>
</blockquote>


<p>
Stream I/O is I/O initiated using the C library's stream interface.
Writes using these functions may not result in system calls, meaning
that the data still lives in buffers in the application's address
space after making such a function call.  The following library
routines (not comprehensive) are part of the stream interface:
<p>
<blockquote>
<table>
<tr><th>Operation</th><th align="left">Function(s)</th></tr>
<tr class="Odd"><td>Open</td><td><tt>fopen()</tt>, <tt>fdopen()</tt>, 
	<tt>freopen()</tt></td></tr>
<tr class="Even"><td>Write</td><td><tt>fwrite()</tt>, <tt>fputc()</tt>,
	<tt>fputs()</tt>, <tt>putc()</tt>, <tt>putchar()</tt>,
	<tt>puts()</tt></td></tr>
<tr class="Odd"><td>Sync</td><td><tt>fflush()</tt>, followed by
    <tt>fsync()</tt> or	<tt>sync()</tt></td></tr>
<tr class="Even"><td>Close</td><td><tt>fclose()</tt></td></tr>
</table>
</blockquote>
<p>
Memory mapped files are similar to the system I/O case above.  Files
are still opened and closed using the same interfaces, but access to
the file data is performed by mapping that data into the process'
address space, and then performing memory read and write operations as
you would with any other application buffer.
<p>
<blockquote>
<table>
<tr><th>Operation</th><th align="left">Function(s)</th></tr>
<tr class="Odd"><td>Open</td><td><tt>open()</tt>, <tt>creat()</tt></td></tr>
<tr class="Even"><td>Map</td><td><tt>mmap()</tt></td></tr>
<tr class="Odd"><td>Write</td><td><tt>memcpy()</tt>, <tt>memmove()</tt>, 
	<tt>read()</tt>, or any other routine that
		writes to application memory	</td></tr>
<tr class="Even"><td>Sync</td><td><tt>msync()</tt></td></tr>
<tr class="Odd"><td>Unmap</td><td><tt>munmap()</tt></td></tr>
<tr class="Even"><td>Close</td><td><tt>close()</tt></td></tr>
</table>
</blockquote>
<p>
There are two flags that can be specified when opening a file to
change its caching behavior: <tt>O_SYNC</tt> (and related <tt>O_DSYNC</tt>), and
<tt>O_DIRECT</tt>.
I/O operations performed against files opened with <tt>O_DIRECT</tt> bypass the
kernel's page cache, writing directly to the storage.  Recall that the
storage may itself store the data in a write-back cache, so
<tt>fsync()</tt> is still required for files opened with <tt>O_DIRECT</tt>
in order to 
save the data to stable storage.  The <tt>O_DIRECT</tt> flag is only
relevant for the system I/O API.
<p>
Raw devices (<tt>/dev/raw/raw</tt><i>N</i>) are a special case of
<tt>O_DIRECT</tt> I/O.  These 
devices can be opened without specifying <tt>O_DIRECT</tt>, but still provide
direct I/O semantics.  As such, all of the same rules apply to raw
devices that apply to files (or devices) opened with <tt>O_DIRECT</tt>.
<p>
Synchronous I/O is any I/O (system I/O with or without <tt>O_DIRECT</tt>, or
stream I/O) performed to a file descriptor that was opened using the
<tt>O_SYNC</tt> or <tt>O_DSYNC</tt> flags.  These are the synchronous
modes, as defined by POSIX:
<p>
<ul>
<li> <tt>O_SYNC</tt>:  File data and all file metadata are written 
     synchronously to disk.
<p>
<li> <tt>O_DSYNC</tt>: Only file data and metadata needed to access the
     file data are written synchronously to disk.
<p>
<li> <tt>O_RSYNC</tt>: Not implemented
</ul>
<p>
The data and associated metadata for write calls to such file
descriptors end up immediately on stable storage.  Note the careful wording,
there.  Metadata that is not required for retrieving the data of the
file may not be written immediately.  That metadata may include the file's
access time, creation time, and/or modification time.
<p>
It is also worth pointing out the subtleties of opening a file
descriptor with <tt>O_SYNC</tt> or <tt>O_DSYNC</tt>, and then associating
that file 
descriptor with a libc file stream.  Remember that <tt>fwrite()</tt>s to the
file pointer are buffered by the C library.  It is not until an
<tt>fflush()</tt> call
is issued that the data is known to be written to disk.  In essence,
associating a file stream with a synchronous file descriptor means
that an <tt>fsync()</tt> call is not needed on the file descriptor after the
<tt>fflush()</tt>.  The <tt>fflush()</tt> call, however, is still necessary.
<p>
<h4>When Should You Fsync?</h4>
<p>
There are some simple rules to follow to determine whether or not an
<tt>fsync()</tt> call is necessary.  First and foremost, you must answer
the question: 
is it important that this data is saved now to stable storage?  If
it's scratch data, then you probably don't need to <tt>fsync()</tt>.  If it's
data that can be regenerated, it might not be that important to <tt>fsync()</tt>
it.  If, on the other hand, you're saving the result of a transaction,
or updating a user's configuration file, you very likely want to get
it right.  In these cases, use <tt>fsync()</tt>.
<p>
The more subtle usages deal with newly created files, or overwriting
existing files.  A newly created file may require an <tt>fsync()</tt> of not just
the file itself, but also of the directory in which it was created
(since this is where the file system looks to find your file).  This
behavior is actually file system (and mount option) dependent.  You
can either code specifically for each file system and mount option
combination, or just perform <tt>fsync()</tt> calls on the directories to
ensure that your code is portable.
<p>
Similarly, if you encounter a system failure (such as power loss,
<tt>ENOSPC</tt> or an I/O error) while overwriting a file, it can result in the
loss of existing data.  To avoid this problem, it is common practice
(and advisable) to write the updated data to a temporary file, 
ensure that it is safe on stable storage, then rename the
temporary file to the original file name (thus replacing the
contents).  This ensures an atomic update of the file, so that other
readers get one copy of the data or another.  The following steps are
required to perform this type of update:
<p>
<ol>
<li> create a new temp file (on the same file system!)
<li> write data to the temp file
<li> <tt>fsync()</tt> the temp file
<li> rename the temp file to the appropriate name
<li> <tt>fsync()</tt> the containing directory
</ol>
<p>
<h4>Checking For Errors</h4>
<p>
When performing write I/O that is buffered by the library or the
kernel, errors may not be reported at the time of the <tt>write()</tt> or
the <tt>fflush()</tt> call, since the data may only be written to the page
cache.  Errors from writes are instead often reported during calls to
<tt>fsync()</tt>,
<tt>msync()</tt> or <tt>close()</tt>.  Therefore, it is very important to
check the return values of these calls.
<p>
<h4>Write-Back Caches</h4>
<p>
This section provides some general information on disk caches, and the
control of such caches by the operating system.  The options discussed
in this section should not affect how a program is constructed at all,
and so this discussion is intended for informational purposes only.
<p>
The write-back cache on a storage device can come in many different
flavors.  There is the volatile write-back cache, which we've been
assuming throughout this document.  Such a cache is lost upon power
failure.  However, most storage devices can be configured to run in
either a cache-less mode, or in a write-through caching mode.  Each of
these modes will not return success for a write request until the
request is on stable storage.  External storage arrays often have a
non-volatile, or battery-backed write-cache.  This configuration also
will persist data in the event of power loss.  From an application
programmer's point of view, there is no visibility into these
parameters, however.  It is best to assume a volatile cache, and
program defensively.  In cases where the data is saved, the
operating system will perform whatever optimizations it can to
maintain the highest performance possible.
<p>
Some file systems provide mount options to control cache flushing
behavior.  For ext3, ext4, xfs and btrfs as of kernel version 2.6.35, the
mount option is "<tt>-o&nbsp;barrier</tt>" to turn barriers (write-back cache flushes)
on (the default), or "<tt>-o&nbsp;nobarrier</tt>" to turn barriers off.  Previous
versions of the kernel may require different options
("<tt>-o&nbsp;barrier=0,1</tt>"), 
depending on the file system.  Again, the application writer should not
need to take these
options into account.  When barriers are disabled for a file system,
it means that fsync calls will not result in the flushing of disk
caches.  It is expected that the administrator knows that the cache
flushes are not required before she specifies this mount option.
<p>
<h4>Appendix: some examples</h4>
<p>
This section provides example code for common tasks that
application programmers often need to perform.
<p>
<ol>
<li> <a href="/Articles/457670/">Synchronizing I/O to a file stream</a>
<p>
<li> <a href="/Articles/457671/">Synchronizing I/O using file
descriptors</a> (system I/O) 
This is actually a subset of the first example and is independent of the
<tt>O_DIRECT</tt>  open flag (so will work whether or not that flag was
specified). 
<p>
<li> <a href="/Articles/457672/">Replacing an existing file</a>
(overwrite).
<p>
<li> <a href="/Articles/459139/">sync-samples.h</a> (needed by the above
examples). 
</ol><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Data_integrity">Data integrity</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Moyer_Jeff">Moyer, Jeff</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/457667/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor458159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 5:44 UTC (Fri)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/458159/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Fascinating and enlightening article.  I didn't previously know much difference between what <tt>fflush()</tt> and <tt>fsync()</tt> do.  Thanks, Jeff!</p>

<p>I have a general question about data syncing:  In your sample function code below, assuming it were a <tt>main()</tt>, and lines 23 and 27 (and their sanity checks) were removed, would normal termination of the program cause the data to reach the disk?  I'm certain from my man pages travels that an implied library-buffer flush would occur, but would the kernel buffer(s) be sync'ed?  Thanks.</p>

<p>P.S. You forgot to <tt>free(buf);</tt> (and shame on you for leaking memory!). :-)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/458159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">s/below/above/</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 9:24 UTC (Fri)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/458182/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>s/below/above/</p>

<p>In my defense, your article (and sample code) were <i>below</i> the comment editor on my Web browser screen.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/458182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor458210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 14:31 UTC (Fri)
                               by <b>phro</b> (subscriber, #29295)
                              [<a href="/Articles/458210/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the fflush() and fsync() calls were removed, normal termination of the program would typically flush stdio streams (see the exit(3) man page for caveats).  The data would still be buffered by the kernel's page cache.<br>
<p>
Thanks for pointing out the memory leak.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor458176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 8:23 UTC (Fri)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/458176/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with fsync() is that while it may be necessary to, for example, ensure that your newly created file actually gets contents on disk before you overwrite the origina (the update pattern), there is no guarantee that this has acceptable performance implications.<br>
<p>
Say you are updating the state of a system frequently, eg every 30 seconds, and you wish to create a new file representing this new state, and replace the previous one.  You can call open(tempname), write(tmpfile), fsync(tmpfile), close(tmpfile), rename(), fsync(dir) and be sure that this data has landed as it shouldat the end of this string of actions, and that your window of data incoherency is at least limited to the time between the rename and the second fsync, if there is any incoherency at all.<br>
<p>
Unfortunately, for many filesystems, the first fsync will cause an I/O storm, pushing out a very larger amount of writeback cached data, because the filesystem is not designed for partial synchronization to disk. Similarly the second fsync may cause an I/O storm.<br>
<p>
You can continue working, in an awkward fashion, by leaving this blocking call in a thread, but you cannot avoid the fact that the fsync() calls may cause you to be no longer able to meet reasonable workload targets.<br>
<p>
If you have this combination of performance sensitivity and correctness, you have to go down the ugly path of specialcasing on a filesystem and platform basis.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 9:10 UTC (Fri)
                               by <b>trasz</b> (guest, #45786)
                              [<a href="/Articles/458181/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It might be worth mentioning that ZFS has an interesting solution for that: ZIL.  Basically, it's a small log intended just for operations that need to be synced to disk; since it's a log, the writes are fast, and it's possible to move it to a separate log device.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 15:59 UTC (Fri)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/458221/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yep, on some systems it's as cheap as you could hope!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor460306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2011 20:56 UTC (Fri)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/460306/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How much using fdatasync() instead of fsync() would help?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/460306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor458180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 8:56 UTC (Fri)
                               by <b>jvoss2</b> (guest, #7065)
                              [<a href="/Articles/458180/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The "if (ret =&lt; 0) {" line probably should read "if (ret &lt; 0) {"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 19:00 UTC (Fri)
                               by <b>valyala</b> (guest, #41196)
                              [<a href="/Articles/458265/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No. read(2) returns zero on the end of file. In our case this means that the incoming connection has been closed. The code just returns success (0) in this case, while not all the requested data has been read. The drawback of this design decision is that the caller of sock_read() cannot determine this case. It would be better returning the number of actual bytes written to the output file instead of just 'success/failure' code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor458209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 14:23 UTC (Fri)
                               by <b>baruchb</b> (subscriber, #6054)
                              [<a href="/Articles/458209/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Where is the "sync-samples.h" file #included in the sample code? Is it actually needed?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor458223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 16:26 UTC (Fri)
                               by <b>sionescu</b> (subscriber, #59410)
                              [<a href="/Articles/458223/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Articles like this make me think again that the Unix-Haters handbook is still as valid as ever, maybe it should be updated.<br>
<p>
Better OSes allow one to write code like (the equivalent of) this:<br>
<p>
fd = open(path, O_WRONLY | O_REPLACE);<br>
...<br>
close(fd, CLOSE_COMMIT);<br>
<p>
which atomically replaces the file's data - keeping intact its metadata(perms, xattrs, selinux context, etc...)<br>
<p>
Again, how disappointing...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 21:15 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/458281/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some of those better OS's have to be rebooted on a regular basis because an in-use binary file can't be replaced, either. So unless your filesystem implements multiversion read concurrency, locking up everything until the file is closed is more trouble than it is worth.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 22:45 UTC (Fri)
                               by <b>sionescu</b> (subscriber, #59410)
                              [<a href="/Articles/458304/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Who said anything about locking ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 0:12 UTC (Sun)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/458389/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Who said anything about locking ?</font><br>
<p>
I mention locking because it is the most common way to implement atomic commit semantics, from the perspective of all other processes. Your idea makes great sense as long as you have multiversion read concurrency, so that existing openers can see an old, read only version of the file indefinitely.<br>
<p>
POSIX simply has a different solution for that, as I am sure you know - the name / inode distinction, which allows you to delete a file, or rename replace it with a new version without locking other processes out, waiting, or disturbing existing openers.  <br>
<p>
It is unfortunate of course that there is no standard call to clone an existing file's extended attributes and security context for use in a rename replace transaction - perhaps one should be added, it would be a worthwhile enhancement. Hating UNIX when it is vastly superior to the most widely distributed alternative in this respect seems a bit pointless to me. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 16:00 UTC (Sun)
                               by <b>sionescu</b> (subscriber, #59410)
                              [<a href="/Articles/458412/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, it's the common way of implementing atomic commit when *modifying* the data, but it's not what I have in mind, which is this:<br>
<p>
open(path, O_REPLACE) only allocates a new inode<br>
<p>
close(fd, CLOSE_COMMIT) atomically replaces the reference to the old inode with the new inode(just like rename) copying all metadata except for the (a|c|m)time, then calls fsync()<br>
<p>
easy, isn't it ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 20:45 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/458440/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure. Practicalities: you could do it to open() (though you'd have to get the change into POSIX before Ulrich would let it past), but you could never do that to close() without breaking every C program ever written. You could call it close_replace(), perhaps?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458441"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 21:10 UTC (Sun)
                               by <b>sionescu</b> (subscriber, #59410)
                              [<a href="/Articles/458441/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why POSIX ? There are other Linux-specific open flags, did Ulrich object to every one of them ?<br>
<p>
The new syscall could be called close2, adding a "flags" parameter - in the spirit of accept4() et al.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458441/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458446"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 21:52 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/458446/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True, though close2() is a horrible name (as is wait$num() and accept$num()): give it a name that reflects its purpose.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458446/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 22:14 UTC (Sun)
                               by <b>sionescu</b> (subscriber, #59410)
                              [<a href="/Articles/458448/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How about "close_with_flags" ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2011 23:51 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/458457/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Again, ugh ('with'?). I'd simply say close_replace(), no need for a flag or indeed any parameters at all. This means it has the same prototype as close(), so if anyone wants to choose between calling close() or close_replace() at runtime, they can just use a function pointer.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor460114"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2011 0:59 UTC (Fri)
                               by <b>spitzak</b> (guest, #4593)
                              [<a href="/Articles/460114/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it is opened with the atomic-replace semantic, I would just have plain close() do the replacement.<br>
<p>
There may be a need to somehow "abort" the file so that it is as though you never started writing it. But it may be sufficient to do this if the process owning the fd exits without calling close().<br>
<p>
I very much disagree with others that say POSIX should be followed. The suggested method of writing a file is what is wanted in probably 95% of the time that files are written. It should be the basic operation, while "dynamic other processes can see the blocks change as I write them" is an extremely rare operation that should be the one requiring complex hacks.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/460114/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836570"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2020 23:05 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/836570/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And then what happens if the file is hardlinked, and you want to modify the original file, not make a modified copy...<br>
<p>
The trouble with POSIX is it is based on Unix and, sorry guys, Unix is crap as a commercial OS. It won because it was cheap and good enough.<br>
<p>
And I curse it regularly because, unlike a lot of people today, I&#x27;ve actually had experience of real commercial OSs. Trouble is, they&#x27;ve died because they cost too much to maintain :-(<br>
<p>
(Mind you, I&#x27;ve used real commercial OSs that had those flags to do fancy file-system stuff, and when they have bugs they really do have bugs ...)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836570/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836579"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2020 7:52 UTC (Mon)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/836579/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><q>The trouble with POSIX is it is based on Unix and, sorry guys, Unix is crap as a commercial OS. It won because it was cheap and good enough.</q></p>

<p>No, commercial Unix lost to Windows because <i>Windows</i> was cheap and good enough. <a href="https://www.youtube.com/watch?v=sforhbLiwLA">Only 99 dollars!</a>. (This was not a real ad, though.)</p>

<p>I also don't buy the argument that Unix cost more to maintain <i>per user</i>. Back then, Unix was a multi-user operating system that was centrally administered. Then came DOS and Windows and every user had their individual problems.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/836579/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How disappointing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2020 10:11 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/836584/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Except I was comparing Unix against proprietary OS&#x27;s from the likes of DEC, Honeywell, Pr1me, etc.<br>
<p>
While Unix was eating the mini-computers&#x27; lunch, yes, Windows came along and started eating its lunch ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor458276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">License of example files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 20:05 UTC (Fri)
                               by <b>chrish</b> (guest, #351)
                              [<a href="/Articles/458276/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a really useful article. However, the code examples in the appendix would be a lot more useful if they were available under a liberal license (BSD 3-clause, or even public domain) rather than GPL v3 or greater. I guess the latter is the default license for Red Hat (and that's great), but it's not the most useful license for short code examples.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">License of example files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2011 20:15 UTC (Fri)
                               by <b>phro</b> (subscriber, #29295)
                              [<a href="/Articles/458279/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I thought of that.  I'll see about posting the examples elsewhere with a less restrictive license.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">License of example files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2020 23:09 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/836571/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How about &quot;these examples are too simple to be worthy of copyright&quot; ... ?<br>
<p>
The law itself sets out a vague line, so just declare that this stuff falls the wrong side of the line.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor458380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2011 21:02 UTC (Sat)
                               by <b>vapier</b> (guest, #15768)
                              [<a href="/Articles/458380/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <pre> 5      char *buf = malloc(MY_BUF_SIZE);</pre>

you forgot to free(buf) after the while loop and in the early returns inside of the loop.  might as well just use the stack: char buf[MY_BUF_SIZE];

<pre>11              ret = read(sockfd, buf, MY_BUF_SIZE);</pre>

common mistake.  the len should be min(MY_BUF_SIZE, nrbytes - written).  otherwise, if (nrbytes % MY_BUF_SIZE) is non-zero, you read too many bytes from the sockfd and they get lost.

<pre>12              if (ret =< 0) {</pre>

typo ... should be "<=" as "=<" doesn't compile.

<pre>18              ret = fwrite((void *)buf, ret, 1, outfp);
19              if (ret != 1)</pre>

unless you build this with a C++ compiler, that cast is not needed.  and another common mistake: the size/nmemb args are swapped ... the size is "1" (since sizeof(*buf) is 1 (a char)), and the number of elements is "ret".  once you fix the arg order, the method of clobbering the value of ret won't work in the "if" check ...

<pre>27      ret = fsync(fileno(outfp));
28      if (ret < 0)
29              return -1;
30      return 0;</pre>

at this point, you could just as easily write:
<pre>    return fsync(fileno(outfp));</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/458380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2011 6:00 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/458665/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>another common mistake: the size/nmemb args are swapped ... the size is "1" (since sizeof(*buf) is 1 (a char)), and the number of elements is "ret". once you fix the arg order, the method of clobbering the value of ret won't work in the "if" check ... </I></BLOCKQUOTE>
<P>I don't think it's an error.  In the example, if<TT> fwrite </TT>returns anything other than '1', then it reports an error.  This is an "all-or-nothing"<TT> fwrite</TT>.  If it fails, 'ret' will be 0, otherwise it will be 1.  The semantic is "write 1 buffer of size 'ret' bytes."</P>
<P>I see nothing wrong with this, and it matches the<TT> if (ret != 1) </TT>statement that follows.  Sure, you don't get to find out how many bytes did get written, but the code wasn't interested in that anyway.  And, it's one less variable that's "live across call," so the resulting compiler output may be fractionally smaller/faster.  (While I can think of smaller microoptimizations, this type of microoptimization <I>is</I> pretty far down the list, I must admit.)</P>
<P>Personally, I think the code might be clearer breaking 'ret' up into multiple variables.  For example, if you did switch size/nmemb, you might rewrite the loop like so:</P>
<PRE>
      while (tot_written < nrbytes) {
              int remaining = nrbytes - tot_written;
              int to_read   = remaining > MY_BUF_SIZE ? MY_BUF_SIZE : remaining;

              read_ret = read(sockfd, buf, to_read);
              if (read_ret <= 0) {
                      if (errno == EINTR)
                              continue;
                      return read_ret;
              }
              write_ret = fwrite((void *)buf, 1, read_ret, outfp);
              tot_written += write_ret;
              if (write_ret != read_ret)
                      return ferror(outfp);
      }
</PRE>
<P>Written that way, you could easily add a way to return how many bytes <I>did</I> get written.</P>
<P>Also, the return value is inconsistent.  I think "<TT>return ferror(outfp)</TT>" is wrong.  <TT>ferror </TT> returns non-zero on an error, but it isn't guaranteed to be negative.  The other paths through this function return positive values on success, so shouldn't it be simply "<TT>return -1;</TT>" to match the<TT> read </TT>error path (which also simply returns -1, and maybe should be written as such)? ie:
</P>
<PRE>
      while (tot_written < nrbytes) {
              int remaining = nrbytes - tot_written;
              int to_read   = remaining > MY_BUF_SIZE ? MY_BUF_SIZE : remaining;

              read_ret = read(sockfd, buf, to_read);
              if (read_ret <= 0) {
                      if (errno == EINTR)
                              continue;
                      return -1;
              }
              write_ret = fwrite((void *)buf, 1, read_ret, outfp);
              tot_written += write_ret;
              if (write_ret != read_ret)
                      return -1;
      }
</PRE>
      
          <div class="CommentReplyButton">
            <form action="/Articles/458665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor458668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2011 6:08 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/458668/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Err... I guess the<TT> read </TT>error path returns -1 <I>or </I> 0, which again I think may be an error, unless you wanted to return 0 when the connection drops before "<TT>nrbytes</TT>" gets read.  Oops.</P>
<P>That raises a different question:  If you exit early due to the socket dropping, you won't<TT> fflush/fsync</TT>.  Seems like you want a '<TT>break</TT>' if <TT>read</TT> returned 0 and <TT>errno != EINTR</TT>, don't you?</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor458866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2011 5:33 UTC (Wed)
                               by <b>vapier</b> (guest, #15768)
                              [<a href="/Articles/458866/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
in the past i've been bitten where fwrite was given a char* and size==num bytes to write and nmemb==1 (like in the example here).  but perhaps that was a bug in the lower layers (it was a ppc/glibc setup).  i do know that size==sizeof(*buf) has always worked for me ;).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor458888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2011 11:59 UTC (Wed)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/458888/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the cast isn't needed with a C++ compiler either<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/458888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor459196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2011 13:43 UTC (Fri)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/459196/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; you forgot to free(buf) after the while loop and in the early returns inside of the loop. might as well just use the stack: char buf[MY_BUF_SIZE];</font><br>
<p>
Is-it such a good idea?<br>
I though that it was better to keep the stack small.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor459237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2011 19:17 UTC (Fri)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/459237/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That was painfully true 20 years ago.  With modern memory management it doesn't matter much.  Within reason of course -- a 20 MB buffer should probably still go on the heap.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor477222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">code feedback ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2012 20:34 UTC (Wed)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/477222/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I prefer to avoid putting buffers on the stack simply to reduce the difficulties associated with buffer overflows.  Not for security reasons (most of my programming is scientific), but simply so overwriting the buffer won't trash the stack, making debugging harder.  And also to allow valgrind to immediately recognize a buffer overwrite...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/477222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor459175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2011 9:16 UTC (Fri)
                               by <b>scheck</b> (guest, #4447)
                              [<a href="/Articles/459175/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Recall that the storage may itself store the data in a write-back cache, so fsync() is still required for files opened with O_DIRECT in order to save the data to stable storage."<br>
<p>
Why should I use fsync() for files opened with O_DIRECT and why has the storage device's cache anything to do with it?<br>
<p>
Apart from that a very nice and comprehensible article. Thank you.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor459180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2011 10:35 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/459180/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the storage device has a write cache but no independent power supply you have the problem that you will loose data on power loss because O_DIRECT will only guarantee that the write reaches the device, not that it reaches persistent storage inside that device.<br>
For that you need to issue some special commands - which e.g. fsync() knows how to do.<br>
Besides an O_DIRECT write doesn't guarantee that metadata updates have reached stable storage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836567"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2020 21:55 UTC (Sun)
                               by <b>yzou93</b> (guest, #142976)
                              [<a href="/Articles/836567/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An awesome article.<br>
My question about fsync() is how the OS could control/know the device-internal caching behavior.<br>
When designing a block device hardware, for example if Samsung wants to design a new SSD, is a cache control support for fsync() command issued from OS required?<br>
<p>
Thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836567/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2020 23:15 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/836573/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not that this is necessarily the way it&#x27;s done, but linux does have a disk database. I see that often enough watching the raid stuff. It&#x27;s quite possible (though probably not) that linux looks up the drive characteristics.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor836583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2020 9:56 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/836583/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>Yes, such a command is needed, and the various interface specs (ATA, SCSI, NVMe) all have standardised commands for flushing the cache.
<p>At a minimum, you get a FLUSH CACHE or SYNCHRONIZE CACHE type command, which is specified as not completing until all data in the cache is in persistent storage; this is enough to implement fsync() behaviour; beyond that, you can also have forced unit access (FUA) commands, which do not complete until the data written is on the persistent media, and even partial flush commands that only affect some sections of the drive.
<p>There's an added layer of complexity in that some standards have queued flushes which act as straight barriers (all commands before the flush complete, then the flush happens, then the rest of the queue); others have queued flushes that only affect commands issued before the flush in this queue (and can over-flush by flushing data from later commands in the queue), and yet others only have unqueued flushes which require you to idle the interface, wait for the flush to complete, and then resume issuing commands.
      
          <div class="CommentReplyButton">
            <form action="/Articles/836583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2020 10:17 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/836585/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ouch. As a database guy I&#x27;m desperate for &quot;queued flush straight barrier&quot;, because if you want data integrity that at least makes reasoning possible - &quot;if the transaction log is incomplete, revert; if the data write is complete, continue; if the log is complete and the data write isn&#x27;t, re-play the log&quot;.<br>
<p>
If you can&#x27;t be sure what has or hasn&#x27;t hit the disk - the nightmare scenario is &quot;part of the log, and part of the data&quot; - then you get the hoops that I believe SQLite and PostgreSQL go through :-(<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2020 17:11 UTC (Mon)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/836679/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
More fun is consumer grade SSDs that protect their metadata during power-loss but not necessarily the data.<br>
<p>
I had to rebuild a btrfs volume because my laptop battery ran down in the bag and on reboot the drive contained blocks saying writes had completed, but those data blocks had old data in them. In other words, data that had been committed to physical storage (or that was CLAIMED by the drive) was no longer present after power-loss. It probably had to fsck or equivalent on the Flash FTL and lost some bits. <br>
<p>
btrfs gets very upset about that.<br>
<p>
I guess this behavior is still better than some older SSDs which had to be secure-erased and reformatted after losing their entire FTL? I guess.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836686"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2020 18:27 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/836686/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>To be fair to btrfs, that's it's USP compared to ext4 - when hardware fails, it lets you know that your data has been eaten at the time of the issue, and not months down the line.
<p>And knowing consumer hardware, chances are very high that it did commit everything properly, and then had a catastrophic failure when there was a surprise power-down. Unfortunately, unless you have an acceptance lab verifying that kit complies with the intent of the spec, it often complies with the letter of the spec (if you're lucky) and no more :-(
      
          <div class="CommentReplyButton">
            <form action="/Articles/836686/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor459246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Opening device nodes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2011 22:50 UTC (Fri)
                               by <b>bjencks</b> (subscriber, #80303)
                              [<a href="/Articles/459246/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What are the semantics when you open a device node (either block, e.g. disk, or char, e.g. tape)? Does the kernel ever use page cache for device files? Does O_DIRECT do anything? What about O_SYNC? Does fsync always generate a barrier?<br>
<p>
Also, what about the different disk abstraction layers (LVM, dm-crypt, MD RAID, DRBD, etc) -- what's involved in passing an fsync() all the way down the stack?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor459337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">avoiding orphan files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2011 12:06 UTC (Mon)
                               by <b>aeriksson</b> (guest, #73840)
                              [<a href="/Articles/459337/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The upshot of using the write/sync/rename workflow is of course that the original file is left untouched until there is a fully comitted replacment ready on disk. The downside is that you need to create a temporary file with a temporary filename while doing it. This is bad for crash recovery, where you'd leave orphan files on the filesystem.<br>
<p>
Is there a way to sole that which I have overlooked?<br>
<p>
fd=open("",O_UNNAMED);<br>
....<br>
rename_unnamed(fd,"/some/file");<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor459398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">avoiding orphan files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2011 17:15 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/459398/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As someone who uses symlinks to manage dotfiles in another repository, the write/sync/rename workflow is annoying as all hell. Tin (since moved to slrn), gpg, pidgin, weechat (which is why I'm still using irssi), and more all force me to manually copy the file to the real location and remake the symlink. If there was a way to do the workflow and then replay the writes to an fd returned by open() on the original path, it would be much better. So far, it looks as if all of the above solutions still fail for me.<br>
<p>
Also in the write/sync/rename workflow, what happens if the temp file is on a separate filesystem? There's a copy involved there, so there is a time when the file is not atomically replaced (unless I'm missing some guarantee by POSIX in this case).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor459407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">avoiding orphan files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2011 18:17 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/459407/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Also in the write/sync/rename workflow, what happens if the temp file is on a separate filesystem?</font><br>
<p>
In the write/sync/rename workflow, this is never supposed to occur. The temp file must always be on the same filesystem as the real file for the atomic-rename guarantee to apply.<br>
<p>
Naturally, this can be extremely difficult to achieve in some cases. The file may be a symlink, which must be fully resolved to a symlink-free path to determine the real filesystem. The file may be the target of a bind mount, in which case I doubt there is any portable way to determine which filesystem it came from. And there there's the possibility that you can write to the file, but not the directory _containing_ the file...<br>
<p>
The write/sync/rename process is hardly an ideal way to implement atomic replacement semantics. There are simply too many potential points of failure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/459407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor477223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">avoiding orphan files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2012 20:38 UTC (Wed)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/477223/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The write/sync/rename process is hardly an ideal way to implement atomic replacement semantics. There are simply too many potential points of failure.</font><br>
<p>
True, but it's also the only one we've got, right?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/477223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor836574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">avoiding orphan files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2020 23:17 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/836574/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Except it doesn&#x27;t work - see my comment about hard-linked files ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/836574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor548009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Direct Reads </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2013 3:16 UTC (Sun)
                               by <b>nikm</b> (guest, #90499)
                              [<a href="/Articles/548009/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am interesting if there is a way to ensure that when you are reading data, these data is directly from the disk. As I wonder in case of reading even if the DIRECT_IO flag is used the data propably is read from kerner buffer. Is that correct?<br>
<p>
thanx<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/548009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor548066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Direct Reads </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2013 11:37 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/548066/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; ... data read from disk and not kernel buffers ...</font><br>
<p>
Maybe echo 1, 2 or 3 to /proc/sys/vm/drop_caches ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/548066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor623830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 1, 2014 13:47 UTC (Mon)
                               by <b>ppai</b> (guest, #100047)
                              [<a href="/Articles/623830/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm wondering about this case:<br>
Directory "a/b/c" already exists.<br>
<p>
    create("/tmp/whatever")<br>
    write("/tmp/whatever")<br>
    fsync("/tmp/whatever")<br>
    os.makedirs("a/b/c/d/e")<br>
    rename("/tmp/whatever", "a/b/c/d/e/obj.data")<br>
    fsync("a/b/c/d/e/")<br>
<p>
Is it really required to fsync dirs all the way from e to a ? Fsync is totally not necessary for "a/b/c" as it already existed. But after doing a makedirs(), there's no way to know which subtree of "a/b/c/d/e" needs fsync().<br>
Is it reasonable to fsync only the containing directory and expect the filesystem to take care of the rest (to make sure the entire tree makes it to disk) ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/623830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor899023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ensuring data reaches disk</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2022 10:48 UTC (Sat)
                               by <b>b10s</b> (guest, #135962)
                              [<a href="/Articles/899023/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi, thank you the article!<br>
<p>
<p>
<font class="QuotedText">&gt; Now, since the amount of data transferred is already known, and given the nature of network communications (they can be bursty and/or slow), we&#x27;ve decided to use libc&#x27;s stream functions (fwrite() and fflush(), represented by &quot;Library Buffers&quot; in the figure above) in order to further buffer the data.</font><br>
<p>
But actually reading is done without libc&#x27;s stream function:<br>
<p>
11              ret = read(sockfd, buf, MY_BUF_SIZE);<br>
<p>
<p>
May I ask, why have you mentioned nature of network here?<br>
<p>
<p>
---<br>
<p>
What if we do fsync() but will not do fflush() in your code example?<br>
The answer most likely - nothing will happen, since fsync flushes OS cache but our data is in libc cache.<br>
<p>
<p>
---<br>
<p>
<font class="QuotedText">&gt; Writes using these functions may not result in system calls, meaning that the data still lives in buffers in the application&#x27;s address space after making such a function call</font><br>
<p>
Except fflush()?<br>
<p>
&quot;Flushing output on a buffered stream means transmitting all accumulated characters to the file&quot;.<br>
<a rel="nofollow" href="https://www.gnu.org/software/libc/manual/html_node/Flushing-Buffers.html">https://www.gnu.org/software/libc/manual/html_node/Flushi...</a><br>
<p>
It sounds like fflush() ends with some system call, isn&#x27;t it? If so, which? (just write()?)<br>
<p>
---<br>
<p>
<font class="QuotedText">&gt; I/O operations performed against files opened with O_DIRECT bypass the kernel&#x27;s page cache, writing directly to the storage. Recall that the storage may itself store the data in a write-back cache, so fsync() is still required for files opened with O_DIRECT in order to save the data to stable storage.</font><br>
<p>
Then why O_DIRECT might be needed at all if we still have to call fsync()? What are use cases?<br>
<p>
---<br>
<p>
Do storages hide their cache? May kernel directly write to drive&#x27;s stable storage?<br>
I&#x27;ve heard some storages do hide their cache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/899023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
