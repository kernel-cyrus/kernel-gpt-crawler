        <!DOCTYPE html>
        <html lang="en">
        <head><title>Linux kernel design patterns - part 2 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/336255/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/337092/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/336255/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Linux kernel design patterns - part 2</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>June 12, 2009</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<a href="http://lwn.net/Articles/336224/">Last week</a> we discussed the
value of enunciating kernel design patterns 
and looked at the design patterns surrounding reference counts.
This week we will look at a very different aspect of coding and see
why the kernel has special needs, and how those needs have been
addressed by successful approaches.  The topic under the microscope
today is complex data structures.
<p>
By "complex data structures" we mean objects that are composed of a
variable number of simpler objects, possibly a homogeneous
collection, possibly a heterogeneous collection.  In general it is a
structure to which objects can be added, from which objects can be
removed, and in which objects can be found.
The preferred way to work with such data structures when we study them in an
introductory programming course is to use <a
href="http://en.wikipedia.org/wiki/Abstract_data_type">Abstract Data
Types</a>.
<p>
<h4>Abstract Data Types</h4>
<p>
The idea behind Abstract Data Types is to encapsulate the entire
implementation of a data structure, and provide just a well defined
interface for manipulating it.
The benefit of this approach is that it provides a clean separation.
The data type can be implemented with no knowledge of the application
which might end up using it, and the application can be implemented
with no knowledge of the implementation details of the data type.
Both sides simply write code based on the interface which works like a
contract to explicitly state what is required and what can be
expected.
<p>
On the other hand, 
one of the costs of this approach is tightly connected with the
abstract nature of the interface.  The point of abstracting an
interface is to remove unnecessary details.  This is good for
introductory computing students, but is bad for kernel programmers.

In kernel programming. performance is very important, coming as a
close third after correctness and maintainability, and sometimes
taking precedence over maintainability.  Not all code paths in the
kernel are performance-critical, but many are, and the development
process benefits from the same data structures being using in both
performance critical and less critical paths.  So it is essential that
data types are not overly abstracted, but that all details of the
implementation are visible so that the programmer can make optimal choices
when using them.
<p>
So the first principle of data structures in the kernel is not to hide
detail.  To see how  this applies, and to discover further principles
from which to extract patterns, we will explore a few of the more
successful data types used in the Linux kernel.
<p>
<h4>Linked Lists</h4>
<p>

Starting simply, the first data type we will explore are doubly linked
lists.  These are implemented by a single include file,
<tt>&lt;linux/list.h&gt;</tt>.
There is no separate ".c" file with any library of support routines.
All of the code for handling linked lists is simple enough to be
implemented using inline functions.  Thus it is very easy to use this
implementation in any other (GPLv2-licensed) project.
<p>
There are two aspects of the "list.h" lists which are worth noting as
they point to possible patterns.

The first is <tt>struct list_head</tt>, which serves not only as the head of a
list, but also as the anchor in items that are on a list.
Your author has seen other linked list implementations which required
that the first and second element in any data structures meant to be stored
in lists be the  "next" and
"previous" pointers, so that common list-walking code could be used on a variety
of different data structures.  Linux kernel lists do not suffer from this
restriction.  The <tt>list_head</tt> structure can be embedded anywhere in a
data structure, and the <tt>list_head</tt>s from a number of instances of
that structure can be linked together.  The containing structure can be
found from a <tt>-&gt;next</tt> or <tt>-&gt;prev</tt> pointer using 
the <tt>list_entry()</tt> macro.
<p>
There are at least two benefits of this approach.  One is that
the programmer still has full control of placement of fields in the
structure in case they need to put important fields close together to
improve cache utilization.  The other is that a structure can easily
be on two or more lists quite independently, simply by having multiple
<tt>struct list_head</tt> fields.
<p>
This practice of embedding one structure inside another and using
<tt>container_of()</tt> (which is the general form of <tt>list_entry()</tt>) to get the
parent from the child structure is quite common in the Linux kernel
and is somewhat reminiscent of object oriented programming.  The
container is like a subtype of the embedded structure.
<p>
The other noteworthy aspect of list.h is the proliferation of
"for_each" macros - the macros that make it easy to walk along a list
looking at each item in turn.  There are 20 of them (and that isn't
counting the four more in <tt>rculist.h</tt> which I'll choose to ignore in the
hope of brevity).
<p>
There are a few different reasons for this.  The simplest are that
<p>
<ul>
<li> We sometimes want to walk the list in the "reverse"
     direction (following the "prev" link).  There are five macros that go
     backward, and 15 that go forward.  
<p>
<li> We sometimes want to start in the middle of a list and
     "continue" on from there, so we have four "continue" macros and
     three "from" macros which interpret that starting point slightly
     differently.
<p>
<li> We sometimes want to work with the <tt>struct list_head</tt> embedded in
     the target structure, but often we really want to use the
     <tt>list_entry()</tt> macro to get the enclosing structure; we find it
     easiest if the "for_each" macro does that for us.  This provides
     the "entry" versions of the "for_each" macro, of which there are
     13 (more than half).
</ul>
<p>
Getting to the more subtle reasons, we sometimes want to be able to
delete the "current" item without upsetting the walk through the
list.  This requires that a copy of the "next" pointer be taken before
providing "this" entry to be acted upon, thus yielding the eight "safe"
macros.  An "ADT" style implementation of linked lists would quite
likely only provide "safe" versions so as to hide these details.
However kernel programmers don't want to waste the storage or effort
for that extra step in the common case were it isn't needed.
<p>
Then there is the fact that we actually have two subtly different
types of linked lists.  Regular linked lists use <tt>struct list_head</tt> as
the head of the list.  This structure contains a pointer to the start and to the
end.  In some use cases, finding the end of the list is not needed,
and being able to halve the size of the head of the list is very
valuable.  One typical use case of that kind is a hash table where all these
heads need to go in an array.  To meet this need, we have the <tt>hlist</tt>,
which is very similar to the regular list, except that only one
pointer is needed in <tt>struct hlist_head</tt>.  This accounts for six of the
different "for_each" macros.
<p>
If we had every possibly combination of forward or reverse, continue
or not, entry or not, safe or not, and regular or hlist, we would have
32 different macros.  In fact, only 19 of these appear to have been
needed and, thus, coded.  We certainly could code the remaining eleven, but as
having code that is never used tends to be frowned upon, it hasn't
happened.
<p>
The observant reader will have noticed a small discrepancy in some of
the above numbers.  Of the 20 macros, there is one that doesn't fit
the above patterns, and it drives home the point that was made earlier
about kernel programmers valuing performance.

This final "for_each" macro is <tt>__list_for_each()</tt>.  All of the other
macros use the "prefetch" function to suggest that the CPU starts
fetching the <tt>-&gt;next</tt> pointer at the start of each iteration so that
it will already be available in cache when the next iteration starts
(though the "safe" macros actually fetch it rather than prefetch it).
While this will normally improve performance, there are cases when it
will slow things down.  When the walk of the list will almost always
abort very early - usually only considering the first item - the
prefetch will often be wasted effort.  In these cases (currently all
in the networking code) the <tt>__list_for_each()</tt> macro is available.  It
does not prefetch anything.  Thus people having very strict performance
goals can have a better chance of getting the performance they want.
<p>
So from this simple data structure we can see two valuable patterns
that are worth following.
<p>
<ul>
<li> <b>Embedded Anchor</b>:  A good way to include generic objects in a data
  structure is to embed an anchor in them and build the data structure
  around the anchors.  The object can be found from the anchor using
  <tt>container_of()</tt>.
<p>
<li> <b>Broad Interfaces</b>:
   Don't fall for the trap of thinking that "one size fits all".
   While having 20 or more macros that all do much the same thing is
   uncommon, it can be a very appropriate way of dealing with the
   complexity of finding the optimal solution.  Trying to squeeze
   all possibilities into one narrow interface can be inefficient and
   choosing not to provide for all possibilities is counter-productive.
   Having all the permutations available encourages developers to use
   the right tool for the job and not to compromise.
   In 2.6.30-rc4, there are nearly 3000 uses of <tt>list_for_each_entry()</tt>,
   about 1000 of <tt>list_for_each_entry_safe()</tt>, nearly 500 of
   <tt>list_for_each()</tt>, and less than 1000 of all the rest put together.
   The fact that some are used rarely in no way reduces their importance.
</ul>
<p>
<h4>RB-trees</h4>
<p>

Our next data structure is the RB-Tree or <a
href="http://lwn.net/Articles/184495/">red-black tree</a>.
This is a semi-balanced, binary search tree that generally provides
order "log(n)" search, insert, and delete operations.  It is implemented in
<tt>&lt;linux/rbtree.h&gt;</tt> and <tt>lib/rbtree.c</tt>.
It has strong similarities to the <tt>list.h</tt> lists in that it embeds an
anchor (<tt>struct rb_node</tt>) in each data structure and builds the tree
from those.
<p>
The interesting thing to note about rbtree is that there is no search
function.  Searching an rbtree is really a very simple operation and
can be implemented in just a few lines as shown by the examples at the
top of <tt>rbtree.h</tt>.

A search function certainly could be written, but the developer chose
not to.  The main reason, which should come as no surprise, is
performance.
To write a search function, you need to pass the "compare" function
into that search function.  To do that in C, you would need to pass a
function pointer.  As compare functions are often very simple, the
cost of following the function pointer and making the function call
would often swamp the cost of doing the comparison itself.
It turns out that having the whole search operation compiled as one
function makes for more efficient code.

The same performance could possibly be achieved using inline functions
or macros, but given that the search function itself is so short, it
hardly seems worthwhile.
<p>
Note also that rbtree doesn't exactly provide an insert function
either.  Rather, the developer needs to code a search; if the search
fails, the new node must be inserted at the point where it was found
not to exist and the tree must be rebalanced.  There are
functions for this final insertion and rebalancing as they are
certainly complex enough to deserve separate functions.
<p>
By giving the developer the responsibility for search and for some of
insert, the rbtree library actually is giving a lot of valuable
freedom.  The pattern of "search for an entry but if it isn't there,
insert one" is fairly common.  However the details of what happens
between the "search" and "add" phases is not always the same and so
not something that can easily be encoded in a library.  By providing
the basic tools and leaving the details up to the specific situation,
users of rbtree find themselves liberated, rather than finding
themselves fighting with a library that almost-but-not-quite does what
they want.
<p>
So this example of rbtrees re-enforces the "embedded anchors" pattern
and suggests a pattern that providing tools is sometimes much more
useful than providing complete solutions.  In this case, the base data
structures and the tools required for insert, remove, and rebalance are
provided, but the complete solution can still be tailored to suit each
case.
<p>
This pattern also describes the kernel's approach to hash tables.
These are a very common data structure, but there is nothing that
looks even vaguely like a definitive implementation.  Rather the basic
building blocks of the hlist and the array are available along with
some generic functions for calculating a hash (<tt>&lt;linux/hash.h&gt;</tt>).
Connecting these to fit a given purpose is up to the developer.
<p>
So we have another pattern:
<p>
<ul>
<li> <b>Tool Box</b>:
   Sometimes it is best not to provide a complete solution for a
   generic service, but rather to provide a suite of tools that can be
   used to build custom solutions.
</ul>
<p>
<h4>Radix tree</h4>
<p>
Our last data structure is the <a
href="http://lwn.net/Articles/175432/">Radix tree</a>.
The Linux kernel actually has two radix tree implementations.
One is in <tt>&lt;linux/idr.h&gt;</tt> and <tt>lib/idr.c</tt>, the other in
<tt>&lt;linux/radix-tree.h&gt;</tt> and <tt>lib/radix-tree.c</tt>.
Both provide a mapping from a number (<tt>unsigned long</tt>) to an arbitrary
pointer (<tt>void&nbsp;*</tt>), though radix-tree also allows up to two "tags" to be
stored with each entry.  For the purposes of this article we will only
be looking at one of the implementations (the one your author is most
familiar with) - the radix-tree implementation.
<p>
Radix-tree follows the pattern we saw in <tt>list.h</tt> of having multiple
interfaces rather than trying to pack lots of different needs into the
one interface.  <tt>list.h</tt> has 20 "for_each" macros; radix-tree has six
"lookup" functions, depending on whether we want just one
item or a range (gang lookups), or whether we want to use the tags
to restrict the search (tag lookups) and whether we want to find the
place where the pointer is stored, rather than the pointer that is
stored there (this is needed for the subtle locking strategies of the
page cache).
<p>
However radix-tree does not follow the embedded anchor pattern of the
earlier data structures, and that is why it is interesting.

For lists and rbtree, the storage needed for managing the data
structure is exactly proportional to the number of items in the
data structure on a one-to-one basis, so keeping this storage in those
item works perfectly.  For a radix-tree, the storage needed is a
number of little arrays, each of which refers to a number of
items.  So embedding these arrays, one each, in the items cannot
work.
This means that, unlike list.h and rbtree, radix-tree will sometimes
need to allocate some memory in order to be able to add items to the
data structure.  This has some interesting consequences.
<p>
In the previous data structures (lists and rbtrees), we made no mention
of locking.  If locking is needed, then the user of the data
structure is likely to know the specific needs so all locking details are
left up to the caller (we call that "caller locking" as opposed to
"callee locking".  Caller locking is more common and generally
preferred).  This is fine for lists and rbtrees as nothing that they
do internally is affected particularly by locking.  
<p>

This is not the
case if memory allocation is needed, though.
If a process needs to allocate memory, it is possible that it will
need to sleep while the memory management subsystem writes data out to
storage to make memory
available.  There are various locks (such as spinlocks) that may not
be held while a process sleeps.  So there is the possibility for
significant interaction between the need to allocate memory internally
to the radix-tree code, and the need to hold locks outside the
radix-tree code.
<p>
The obvious solution to this problem (once the problem is understood) is to
preallocate the maximum amount of memory needed before taking the
lock.  This is implemented within radix-tree with the
<tt>radix_tree_preload()</tt> function.  It manages a per-CPU pool of available
<tt>radix_tree</tt> nodes and makes sure the pool is full and will not be used
by any other radix-tree operation.  Thus, bracketing <tt>radix_tree_insert()</tt>
with calls to <tt>radix_tree_preload()</tt> and
<tt>radix_tree_preload_end()</tt> ensures that the 
<tt>radix_tree_insert()</tt> call will not fail due to lack of memory (though the
<tt>radix_tree_preload()</tt> might) and that there will be no unpleasant
interactions with locking.
<p>
<h4>Summary</h4>
<p>
So we can now summarize our list of design patterns that we have found
that work well with data structures (and elsewhere) in the kernel.
Those that have already been detailed are briefly included in this list
too for completeness.
<p>
<ul>
<li> <b>Embedded Anchor</b>.  This is very useful for lists, and can be
       generalized as can be seen if you explore kobjects (an exercise
       left to the reader).
<p>
<li> <b>Broad Interfaces</b>.  This reminds us that trying to squeeze lots of
       use-cases in to one function call is  not necessary - just
       provide lots of function calls (with helpful and (hopefully)
       consistent names). 
<p>
<li> <b>Tool Box</b>.
       Sometimes it is best not to provide a complete solution for a
       generic service, but rather to provide a suite of tools that can be
       used to build custom solutions.
<p>
<li> <b>Caller Locks</b>.  When there is any doubt, choose to have the caller
       take locks rather than the callee.  This puts more control in
       that hands of the client of a function.
<p>
<li> <b>Preallocate Outside Locks</b>.  This is in some ways fairly obvious.
       But it is very widely used within the kernel, so stating it
       explicitly is a good idea.
</ul>
<p>
<a href="/Articles/336262/">Next week</a> we will complete
our investigation of kernel design patterns 
by taking a higher level view and look at some patterns relating to
the design of whole subsystems.
<p>
<h4>Exercises</h4>
<p>
For those who would like to explore these ideas further, here are some
starting points.
<p>
<ol>
<li>
  Make a list of all data structures that are embedded, by exploring
  all uses of the "container_of" macro.  Of these, make a list of
  pairs that are both embedded in the same structure (modeling multiple
  inheritance).  Comment on how this reflects on the general
  usefulness of multiple inheritance.
<p>
<li>
  Write a implementation of <a
  href="http://en.wikipedia.org/wiki/Skiplist">skiplists</a> 
  that would be suitable for in-kernel use.  Consider the
  applicability of each of the patterns discussed in this article.
  Extra credit for leveraging list.h lists.
<p>
<li>
Linux contains a mempool library which radix-tree chooses not to
   use, preferring it's own simple pool (in radix_tree_preload).
   Examine the consequences of changing radix-tree to use mempool, and
   of changing mempool to be usable by radix-tree.
   Provide patches to revert this design choice in radix-tree, or a
   pattern to explain this design choice.
<p>  
<li>
  Compare the radix-tree and idr implementations to see if one could
  be implemented using the other without sacrificing correctness,
  maintainability or performance.  Provide either an explanation of why
  they should stay separate, or a patch to replace one with the other.
  </ol><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-Patterns">Development model/Patterns</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/336255/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor337331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2009 10:58 UTC (Sat)
                               by <b>wingo</b> (guest, #26929)
                              [<a href="/Articles/337331/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very nice article, thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/337331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor337332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2009 11:19 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/337332/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I must say that while I've used the RB-tree 'provide a partial toolbox' in <br>
my own code, it felt ugly, more like an indictment of the language I was <br>
working in than anything else. I couldn't help but think that if C had a <br>
half-decent macro expansion facility, like Lisp, or guaranteed function <br>
cloning and cross-module inlining (Ada provides some of that), all this <br>
nonsense would be unnecessary. You could either provide a search macro <br>
that expanded into code that did the search, incorporating your comparator <br>
into the code itself rather than calling it, or the compiler could detect <br>
the frequent use of some comparator, clone the search function, and inline <br>
the comparator into the clone (and possibly the clone into its caller).<br>
<p>
So this is really a workaround for C being such an expressively <br>
impoverished language, IMHO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/337332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor337355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2009 22:49 UTC (Sat)
                               by <b>jlokier</b> (guest, #52227)
                              [<a href="/Articles/337355/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can in fact do this in C with macros.  For example I have a nice list-sorting macro which takes a comparison code fragment as argument, and expands to fast code to sort a list using that comparator.  Tree search and hash tables can be done similarly.<br>
<p>
I agree macros more like LISP would be much more versatile.  This is an area where C++ does well too, with or without templates.<br>
<p>
But you can do it in C if you're determined.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/337355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor337373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2009 9:20 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/337373/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I suppose you could do that. There'd be constraints on the form of <br>
the fragment, though: basically it'd have to be an expression.<br>
<p>
With the statement-expression extension you *might* be able to do <br>
something more than one expression long, but you're really playing in <br>
areas where that extension hasn't been tested by that point, so who knows <br>
if it'll work. (Well, I suppose I could try it.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/337373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor337410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2009 15:17 UTC (Mon)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/337410/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you're willing to write your code for GNU C only you can use the GCC extension allowing statements and declarations as expressions to make this much simpler.  see section 5.1 "Statements and Declarations in Expressions" in the chapter "C Extensions" in the GCC manual.<br>
<p>
This lets you have a much more complex "expressions"... at the expense of portability.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/337410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor338042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - lack of red/black tree search function</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2009 19:47 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/338042/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
... or guaranteed function cloning and cross-module inlining ...
</blockquote>
<p>
I don't think it's cross-moduleness or variable-argumentness that make the common search function slow.  It's the function pointer.
<p>
Does gcc inline even a locally defined used-once function when you call it via a constant function pointer?  Didn't used to.

      
          <div class="CommentReplyButton">
            <form action="/Articles/338042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor338069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - lack of red/black tree search function</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2009 22:26 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/338069/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, it doesn't, but a sufficiently clever compiler could. The key is the <br>
cross-module inlining.<br>
<p>
(Even there, you'd be in trouble if the function doing the call was in a <br>
different shared library than the caller. I don't see any way to fix <br>
that.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/338069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor338070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - lack of red/black tree search function</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2009 22:46 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/338070/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
The key is the cross-module inlining.
</blockquote>
<p>
Why is that the key?  The pointed-to function would be in the main .c file and the library function that takes the function pointer as its argument would be in an included .h file like all the other functions we like to have inlined.

      
          <div class="CommentReplyButton">
            <form action="/Articles/338070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor338163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - lack of red/black tree search function</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2009 22:21 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/338163/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes: and if the compiler was sufficiently clever, and all the .c files in <br>
the application were presented to it at once, it would recognise instances <br>
of this function that were frequently called with a particular function <br>
pointer and clone a variant of that function that had that function <br>
inlined into it: said variant would then get used only by the particular <br>
call site in question.<br>
<p>
This is way beyond what, say, GCC can do now, but is not disallowed nor <br>
impossible to implement.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/338163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor348236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - lack of red/black tree search function</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2009 15:32 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/348236/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <code>-fwhole-program</code>
      
          <div class="CommentReplyButton">
            <form action="/Articles/348236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor337484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2009 0:03 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/337484/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have a few reflections on this.<br>
<p>
Firstly: it may well be that C is "expressively impoverished".  Nevertheless, C is the language that Linux is written in, and that is not likely to change.  So if we find ways to make best use of those constructs which C gives us, and document them as Patterns, we can work around some of the worse short comings while still keeping the result reasonably maintainable.<br>
<p>
Secondly: if you look at cfq_rb_root in cfq-iosched.c, you will find an rbtree with an 'optimisation' that the left-most node is cached, as in that application it is often wanted.  Implementing that requires making changes inside the 'add' routine.  Keeping the implementation 'open' makes it easier to build that sort of enhancement.<br>
<p>
Thirdly: it may well be that there is a "better" pattern available using macros or inlines or whatever.  In writing the article I was not inventing patterns, but simply documenting them.  If doing so helps people to see the weaknesses in the patterns and thus to improve the code by applying a better pattern, then we will have achieved something very worthwhile.<br>
<p>
Thanks.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/337484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor338164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2009 22:23 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/338164/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, I agree with all of that. I wasn't saying that this was a *bad* thing: <br>
obviously C is a pretty damn good language to write kernels in! (I wasn't <br>
writing a kernel at the time.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/338164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor337341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2009 13:21 UTC (Sat)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/337341/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      The fourth paragraph makes it sound like the kernel always favours opening up structs/data types over making them opaque (abstract). I disagree with this assertion, there can be value in making structures opaque, if only to guarantee properly locked access or deter abuse of visible parts of structures.

Of course, the examples you give are perfectly valid examples where there is no value in making things opaque -- abuse is unlikely, performance concerns require using inlines and similar -- however there are also many examples in the kernel for exactly the opposite.

In code I maintain, I have often combined both approaches, like this:

<pre>
public.h:
struct foo {
   int public;

   u8 priv[] __align(sizeof(void*));
};

struct foo *foo_alloc(int privsz);
void foo_destroy(struct foo *f);
foo_do_something(struct foo *f);

internal.c:
struct internal_foo {
   int internal;
   /* ... */

   /* keep last */
   struct foo pub;
};

struct foo *foo_alloc(int privsz)
{
  struct internal_foo *res = kzalloc(sizeof(*res) + privsz);
  if (!res)
    return NULL;
  return &amp;res->pub;
}

/* etc */
</pre>

This pretty much combines the best of both worlds -- purely internal details are invisible to API users, and members that are part of the API and can safely be used by API users are made public.

      
          <div class="CommentReplyButton">
            <form action="/Articles/337341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor337483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2009 23:34 UTC (Mon)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/337483/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I guess that paragraph could be read as making a stronger statement than I can justify ... but if that sparks some discussion, maybe it isn't all bad.<br>
<p>
My main goal was not to describe the best patterns, but to describe the value of patterns in general, and illustrate that with a few that I was aware of.  The pattern that you describe is not one I have seen, and I suspect there are many more that I am not aware of.  One of my hopes in writing the series was that it would encourage others to describe patterns they had seen and liked.   You have at least partially realised this - thanks!<br>
<p>
I imagine there would be a number of situations where that pattern would be very apt - possibly more apt than the pattern of simply exposing everything.  What would be really useful (for any pattern) would be some analysis of strengths and weaknesses which could guide the choice of when it is a good one to use, and when it would best be avoided.  Enumerating examples can help a lot there.<br>
<p>
Thanks.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/337483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor337515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2009 10:13 UTC (Tue)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/337515/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
Yes, I don't think you could possibly be aware of all patterns used. And it may well be possible that I brought this "partial exposure pattern" to the kernel myself, I've used it across the wireless code a lot but I don't know whether it is used elsewhere.
</p>
<p>
As for comparing, let me start with a very short comparison to the "expose everything" pattern:<br>
Pros:
<ul>
<li> users forced to use APIs, less potential for abuse &amp; "trickery"
<li> internal details can be changed at will
</ul>
Cons:
<ul>
<li> not possible to embed into anything, needs to be allocated by API function
<li> cannot be allocated on stack
</ul>
Other differences:
<ul>
<li> no "init" function/macro necessary, but "alloc" function contains "init".
</ul>
</p>
<p>
For the cases where I've done it this way, the fact that it cannot be embedded or on the stack is not important because it serves more as the container itself rather than being a helper that can be embedded into something else. The one exception could be rfkill, but I made that completely opaque because it had been abused so much in the past.
      
          <div class="CommentReplyButton">
            <form action="/Articles/337515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor338053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2009 4:02 UTC (Sun)
                               by <b>rusty</b> (guest, #26)
                              [<a href="/Articles/338053/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Two points on your excellent article:<br>
<p>
(1) There is a reimplemented variation of these lists in CCAN (<a href="http://ccan.ozlabs.org/info/list.html">http://ccan.ozlabs.org/info/list.html</a>) which has fewer historical warts and a saner license (LGPL v2 or later) than the kernel one.<br>
<p>
(2) The rb_tree non-search function is a historical relic; recent gcc will happily inline functions passed by pointer, so search can be made an inline these days.  (I had a patch a while back, and reported a bug about the lack of inlining to gcc, which is how I know it's been fixed).<br>
<p>
Cheers,<br>
Rusty.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/338053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor339356"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 1, 2009 0:59 UTC (Wed)
                               by <b>xenoterracide</b> (guest, #59384)
                              [<a href="/Articles/339356/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
these are good articles. you should consider putting them in a book.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339356/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor341374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux kernel design patterns - part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2009 15:46 UTC (Wed)
                               by <b>pepsiman</b> (guest, #22382)
                              [<a href="/Articles/341374/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; We certainly could code the remaining eleven</font><br>
<p>
s/eleven/thirteen/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/341374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
