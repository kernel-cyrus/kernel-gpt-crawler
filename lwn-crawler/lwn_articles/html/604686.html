        <!DOCTYPE html>
        <html lang="en">
        <head><title>Filesystem notification, part 1: An overview of dnotify and inotify [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/604686/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/604218/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/604686/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Filesystem notification, part 1: An overview of dnotify and inotify</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>July 9, 2014</p>
           <p>This article was contributed by <a href="http://man7.org/">Michael Kerrisk</a>.</p>
           <hr>
<a href="/Articles/605313/">Filesystem notification</a>
</div>
<p>
    Filesystem notification APIs provide a mechanism by which
    applications can be informed when events happen within a
    filesystem&mdash;for example, when a file is opened, modified,
    deleted, or renamed. Over time, Linux has acquired three different
    filesystem notification APIs, and it is instructive to look at
    them to understand what the differences between the APIs are. It's
    also worthwhile to consider what lessons have been learned during
    the design of the APIs&mdash;and what lessons remain to be
    learned.

<p>
    This article is thus the first in a series that looks at the
    Linux filesystem notification APIs: dnotify, inotify, and
    fanotify. To begin with, we briefly describe the original API,
    dnotify, and look at its limitations. We'll then look at the
    inotify API, and consider the ways in which it improves on
    dnotify.  In a subsequent article, we'll take a look at the fanotify API.

<h4>Filesystem notification use cases</h4>

<p>
    In order to compare filesystem notification APIs, it's useful to
    consider some of the use cases for those APIs.  Some of the common
    use cases are the following:

<ul class="spacylist">

        <li>
        <i>Caching a model of filesystem objects</i>:

        The application wants to maintain an internal representation
        that accurately reflects the current set of objects in a
        filesystem, or some subtree of that filesystem.  An example of
        such an application is a file manager, which
        presents the user with a graphical representation of the
        objects in a filesystem.
        </li>

        <li>
        <i>Logging filesystem activity</i>:

        The application wants to record all of the events (or some
        subset of event types) that occur for the monitored filesystem
        objects.
        </li>

        <li>
        <i>Gatekeeping filesystem operations</i>:

        The application wants to intervene when a filesystem event
        occurs.  The classic example of such an application is an
        antivirus system: when another program tries to (for example)
        execute a file, the antivirus system first checks the contents
        of the file for malware, and then either allows the execution
        to proceed if the file contents are benign, or prevents
        execution if a virus is detected.
        </li>

</ul>



<h4>In the beginning: dnotify</h4>

<p>
    Without a kernel-supported filesystem notification API, an
    application must resort to techniques such as polling the state of
    directories and files using repeated invocations of system calls
    such as <tt>stat()</tt> and the <tt>readdir()</tt> library
    function.  Such polling is, of course, slow and inefficient.
    Furthermore, this approach allows only a limited range of events
    to be detected, for example, creation of a file, deletion of a
    file, and changes of file metadata such as permissions and file
    size. By contrast, operations such as file renames are difficult
    to identify.

<p>
    Those problems led to the creation of the first in-kernel
    implementation of a filesystem notification API, dnotify, which
    was implemented by Stephen Rothwell (these days, the maintainer of
    the <a href="/Articles/571980/">linux-next tree</a>) and which
    first appeared in Linux&nbsp;2.4.0 (in 2001).

<p>
    Because it was the first attempt at implementing a filesystem
    notification API, done at a time when the problem was less
    well understood and when some of the pitfalls of API design were
    less easily recognized, the dnotify API has a number of
    peculiarities.
    To begin with, the interface is multiplexed on the existing
    <tt>fcntl()</tt> system
    call.
    (By
    contrast, the later inotify and fanotify APIs were each
    implemented using new system calls.) To enable
    monitoring, one makes a call of the form:

<pre>
    fcntl(fd, F_NOTIFY, mask);
</pre>

<p>
    Here, <tt>fd</tt> is a file descriptor that specifies a directory
    to be monitored, and this brings us to the second oddity of
    the API: dnotify can be used to monitor only whole directories;
    monitoring individual files is not possible.
    The <tt>mask</tt> specifies the set of events to be monitored in
    the directory. These include events for file access, modification,
    creation, deletion, and attribute changes
    (e.g., permission and ownership changes) that are fully listed in the
    <a
    href="http://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl(2) 
    man page</a>.

<p>
    A further dnotify oddity is its method of notification. When an
    event occurs, the monitoring application is sent a signal
    (<tt>SIGIO</tt> by default, but this can be changed). The signal
    on its own does not identify which directory had the event, but if
    we
    use <a href="http://man7.org/linux/man-pages/man2/sigaction.2.html"><tt>sigaction()</tt></a>
    to establish the handler using the <tt>SA_SIGINFO</tt> flag, then
    the handler receives a <tt>siginfo_t</tt> argument
    whose <tt>si_fd</tt> field contains the file descriptor associated
    with the directory. At that point, the application then needs to
    rescan the directory to determine which file has changed. (In
    typical usage, the application would maintain a data structure
    that caches a mapping of file descriptors to directory names, so
    that it can map <tt>si_fd</tt> back to a directory name.)

<p>
    A simple example of the use of dnotify can be
    found <a href="/Articles/604696/">here</a>.


<h4>Problems with dnotify</h4>

<p>
    As is probably clear, the dnotify API is cumbersome, and
    has a number of limitations. As already noted, we can monitor only
    entire directories, not individual files. Furthermore, dnotify
    provides notification for a rather modest range of events. Most
    notably, by comparison to inotify, dnotify can't tell us when a
    file was opened or closed. However, there are also some other
    serious limitations of the API.

<p>
    The use of signals as a notification method causes a number of
    difficulties. The first of these is that signals are delivered
    asynchronously: catching signals with a handler can be racy and
    error-prone. One way around that particular difficulty is to
    instead accept signals synchronously using
    <a href="http://man7.org/linux/man-pages/man2/sigwaitinfo.2.html"><tt>sigwaitinfo()</tt></a>.
    The use of <tt>SIGIO</tt> as the default notification signal is
    also undesirable, because it is one of the traditional signals
    that does not queue. This means that if events are generated more
    quickly than the application can process the signals, then some
    notifications will be lost. (This difficulty can be circumvented
    by changing the  notification signal to one of the so-called realtime
    signals, which can be queued.)

<p>
    Signals are also problematic because they
    convey little information: at most, we get a signal number (it is
    possible to arrange for different directories to notify using
    different signals) and a file descriptor number. We get no
    information about which particular file in a directory triggered
    an event, or indeed what kind of event occurred. (One can play
    tricks such as opening multiple file descriptors for the same
    directory, each of which notifies a different set of events, but
    this adds complexity to the application.)
    One further reason that using signals as a notification method can
    be a problem is that an application that uses dnotify might also
    make use of a library that employs signals: the use of a
    particular signal by dnotify in the main program may conflict with
    the library's use of the same signal (or vice versa).

<p>
    A final significant limitation of the dnotify API is the need to open a
    file descriptor for each directory that is monitored. This is
    problematic for two reasons. First, an application that monitors a
    large number of directories may quickly run out of file
    descriptors.  However, a more serious problem is that holding file
    descriptors open on a filesystem prevents that filesystem from
    being unmounted.

<p>
    Notwithstanding these API problems, dnotify did provide an
    efficiency improvement over simply polling a filesystem, and
    dnotify came to be employed in some widely used tools such as
    the Beagle desktop search tool. However, it soon became clear that
    a better API would make life easier for user-space applications.


<h4>Enter inotify</h4>

<p>
    The inotify API was developed by John McCutchan with support from
    Robert Love. First released in Linux&nbsp;2.6.13 (in 2005), inotify
    aimed to address all of the obvious problems with dnotify.

<p>
    The API employs three dedicated system
    calls&mdash;<tt>inotify_init()</tt>, <tt>inotify_add_watch()</tt>,
    and <tt>inotify_rm_watch()</tt>&mdash;and makes use of the
    traditional <tt>read()</tt> system call as well.

<p>
    <img src="https://static.lwn.net/images/2014/inotify_instance.png" align="right"
    alt="[Inotify diagram]" width=356 height=366 hspace=5 />

<p>
    <a href="http://man7.org/linux/man-pages/man2/inotify_init.2.html"><tt>inotify_init()</tt></a>
    creates an inotify instance&mdash;a kernel data structure that
    records which filesystem objects should be monitored and
    maintains a list of events that have been generated for those
    objects. The call returns a file descriptor that is employed by
    the rest of the API to refer to this inotify instance.  The
    diagram at right summarizes the operation of an inotify instance.

<p>
    <a href="http://man7.org/linux/man-pages/man2/inotify_add_watch.2.html"><tt>inotify_add_watch()</tt></a>
    allows us to modify the set of filesystem objects monitored by an
    inotify instance. We can add new objects (files and directories)
    to the monitoring list, specifying which events are to be
    notified, and change the set of events that are notified for an
    object that is already in the monitoring
    list. Unsurprisingly, <a href="http://man7.org/linux/man-pages/man2/inotify_init.2.html"><tt>inotify_rm_watch()</tt></a>
    is the converse of <tt>inotify_add_watch()</tt>: it removes an
    object from the monitoring list.

<p>
    The three arguments to <tt>inotify_add_watch()</tt> are an inotify
    file descriptor, a filesystem pathname, and a bit mask: 

<pre>
    int inotify_add_watch(int fd, const char *pathname, uint32_t mask);
</pre>

<p>
    The
    <tt>mask</tt> argument specifies the set of events to be notified
    for the filesystem object referred to by <tt>pathname</tt> and can
    include some additional bits that affect the behavior of the
    call. As an example, the following code allows us to monitor file
    creation and deletion events inside the directory <tt>mydir</tt>,
    as well as monitor for deletion of the directory itself:

<pre>
    int fd, wd;

    fd = inotify_init();

    wd = inotify_add_watch(fd, "mydir",
                           IN_CREATE | IN_DELETE | IN_DELETE_SELF);
</pre>

<p>
    A full list of the bits that can be included in the <tt>mask</tt>
    argument is given in
    the <a href="http://man7.org/linux/man-pages/man7/inotify.7.html">inotify(7)
    man page</a>.
    The set of events notified by inotify
    is a superset of that provided by dnotify.
    Most notably, inotify provides notifications when filesystem objects
    are opened and closed, and provides much more information
    for file rename events, as we outline below.

<p>
    The return value of <tt>inotify_add_watch()</tt> is a "watch
    descriptor", which is an integer value that uniquely identifies the
    specified filesystem object within the inotify monitoring list.
    An <tt>inotify_add_watch()</tt> call that specifies a filesystem
    object that is already being monitored (possibly via a different
    pathname) will return the same watch descriptor number as was
    returned by the <tt>inotify_add_watch()</tt> that first added the
    object to the monitoring list.

<p>
    When events occur for objects in the monitoring list, they can be
    read from the inotify file descriptor using <tt>read()</tt>. (The
    inotify file descriptor can also be monitored for readability
    using <tt>select()</tt>, <tt>poll()</tt>, and <tt>epoll()</tt>.)
    Each
    <tt>read()</tt> returns one or more structures of the following
    form to describe an event:

<pre>
    struct inotify_event {
        int      wd;      /* Watch descriptor */
        uint32_t mask;    /* Bit mask describing event */
        uint32_t cookie;  /* Unique cookie associating related events */
        uint32_t len;     /* Size of name field */
        char     name[];  /* Optional null-terminated name */
    };
</pre>

<p>
    The <tt>wd</tt> field is a watch descriptor that was previously
    returned by <tt>inotify_add_watch()</tt>. By maintaining a data
    structure that maps watch descriptors to pathnames,
    the application can determine the filesystem object for which this
    event occurred.
    <tt>mask</tt> is a bit mask that describes the event that
    occurred. In most cases, this field will include one of the bits
    specified in the mask specified when the watch was
    established. For example, given the <tt>inotify_add_watch()</tt>
    call that we showed earlier, if the directory <tt>mydir</tt> was
    deleted, <tt>read()</tt> would return an event whose <tt>mask</tt>
    field has the <tt>IN_DELETE_SELF</tt> bit set. (By contrast, dnotify
    does not generate 
    an event when a monitored directory is deleted.)

<p>
    In addition to the various events for which an application may
    request notification, there are certain events for which inotify
    always generates automatic notifications. The most notable of
    these is <tt>IN_IGNORED</tt>, which is generated whenever inotify
    ceases to monitor an object. This can occur, for example, because
    the object was deleted or the filesystem on which it resides was
    unmounted. The <tt>IN_IGNORED</tt> event can be used by the
    application to adjust its internal model of what is currently
    being monitored. (Again, dnotify has no analog of this event.)

<p>
    The <tt>name</tt> field is used (only) when an event occurs for a
    file inside a monitored directory: it contains the null-terminated
    name of the file that triggered this event. The <tt>len</tt> field
    indicates the total size of the <tt>name</tt> field, which may be
    terminated by multiple null bytes in order to pad out the
    <tt>inotify_event</tt> structure to a size that allows successive
    structures in the read buffer to be aligned at
    architecture-appropriate byte boundaries (typically, multiples of
    16 bytes).

<p>
    The <tt>cookie</tt> field exists to help applications interpret
    rename events. When a file is renamed inside (or between) monitored
    directories, two events are generated: an <tt>IN_MOVED_FROM</tt>
    event for the directory from which the file is moved, and an
    <tt>IN_MOVED_TO</tt> event for the directory to which the file is
    moved. The first event contains the old name of the file, and the
    second event contains the new name. Both events have the same
    unique <tt>cookie</tt> value, allowing the application to connect
    the two events, and thus work out the old and new name of the
    file (a task that is rather difficult with dnotify).
    We'll say rather more about rename events in the next
    article in this series.


<p>
    Inotify does not provide recursive monitoring. In other words, if
    we are monitoring the directory <tt>mydir</tt>, then we will
    receive notifications for that directory as well as all of its
    immediate descendants, including subdirectories. However, we will
    not receive notifications for events inside the subdirectories.
    But, with some effort, it is possible to perform recursive
    monitoring by creating watches for each of the subdirectories in a
    directory tree. To assist with this task, when a subdirectory is
    created inside a monitored directory (or indeed, when any event is
    generated for a subdirectory), inotify generates an event that has
    the <tt>IN_ISDIR</tt> bit set. This
    provides the application with the opportunity to add watches for
    new subdirectories.

<h4>Example program</h4>

<p>
    The code below demonstrates the basic steps in using the
    inotify API. The program first creates an inotify instance and
    adds watches for all possible events for each of the pathnames
    specified in its command line. It then sits in a loop reading
    events from the inotify file descriptor and displaying information
    from those events (using our <tt>displayInotifyEvent()</tt>, shown
    in the full version of the code <a href="/Articles/604697/">here</a>).

<pre>
    int
    main(int argc, char *argv[])
    {
        struct inotify_event *event
        ...

        inotifyFd = inotify_init();         /* Create inotify instance */

        for (j = 1; j &lt; argc; j++) {
            wd = inotify_add_watch(inotifyFd, argv[j], IN_ALL_EVENTS);

            printf("Watching %s using wd %d\n", argv[j], wd);
        }

        for (;;) {                          /* Read events forever */
            numRead = read(inotifyFd, buf, BUF_LEN);
            ...

            /* Process all of the events in buffer returned by read() */

            for (p = buf; p &lt; buf + numRead; ) {
                event = (struct inotify_event *) p;
                displayInotifyEvent(event);

                p += sizeof(struct inotify_event) + event-&gt;len;
            }
        }
    }
</pre>

<p>
    Suppose that we use this program to monitor two
    subdirectories, <tt>xxx</tt> and <tt>yyy</tt>:

<pre>
    $ ./inotify_demo xxx yyy
    Watching xxx using wd 1
    Watching yyy using wd 2
</pre>

<p>
    If we now execute the following command:

<pre>
    $ mv xxx/aaa yyy/bbb
</pre>

<p>
    we see the following output from our program:

<pre>
    Read 64 bytes from inotify fd
        wd = 1; cookie =140040; mask = IN_MOVED_FROM
            name = aaa
        wd = 2; cookie =140040; mask = IN_MOVED_TO
            name = bbb
</pre>

<p>
    The <tt>mv</tt> command generated an <tt>IN_MOVED_FROM</tt> event
    for the <tt>xxx</tt> directory (watch descriptor&nbsp;1) and
    an <tt>IN_MOVED_TO</tt> event for the <tt>yyy</tt> directory
    (watch descriptor&nbsp;2).  The two events contained, respectively, the
    old and new name of the file. The events also had the
    same <tt>cookie</tt> value, thus allowing an application to
    connect them.

<h4>How inotify improves on dnotify</h4>

<p>
    Inotify improves on dnotify in a number of respects. Among the
    more notable improvements are the following:

    <ul class="spacylist">
        <li>
        Both directories and individual files can be monitored.
        </li>

        <li>
        Instead of signals, applications are notified of filesystem
        events by reading structured data from a file descriptor
        created using the API. This approach allows an application to
        deal with notifications synchronously, and also allows for
        richer information to be provided with notifications.
        </li>

        <li>
        Inotify does not require an application to open file descriptors
        for each monitored object. Instead, it uses an API-specific
        handle (the watch descriptor). This avoids the problems of
        file-descriptor exhaustion and open file descriptors preventing 
        filesystems from being unmounted.
        </li>

        <li>
        Inotify provides more information when notifying
        events. First, it can be used to detect a wider range of
        events. Second, when the subject of an event is a file
        inside a monitored directory, inotify provides the name of
        that file as part of the event notification.
        </li>
        <li>
        Inotify provides richer information in its notification of
        rename events, allowing an application to easily determine the
        old and new name of the renamed object.
        </li>
        <li>
        <tt>IN_IGNORED</tt> events make it (relatively) easy for an
        inotify application to maintain an internal model of the
        currently monitored set of filesystem objects.
        </li>
    </ul>


<h4>Concluding remarks</h4>

<p>
    We've briefly seen how inotify improves on dnotify.  In the next
    article in this series, we look in more detail at inotify,
    considering how it can be used in a robust application that
    monitors a filesystem tree. This will allow us to see the full
    capabilities of inotify, while at the same time discovering some
    of its limitations.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-User-space_ABI">Development model/User-space ABI</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Dnotify">Dnotify</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Inotify">Inotify</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Kerrisk_Michael">Kerrisk, Michael</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/604686/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor604894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2014 21:06 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/604894/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The benefit of requiring an open file descriptor is that you don't need to worry about overflows. This isn't the case with dnotify because of the way it uses signals, but with kqueue+EVFILT_VNODE you never have to worry about overflow because the kernel always has a place to store the event. And the file descriptor limit naturally provides back pressure to the application. The file descriptor resource limit is something that must already be managed.<br>
<p>
Rare is the application that actually handles IN_Q_OVERFLOW. The ability to get the file name with a change notification without having an open descriptor is an _optimization_, but for reliable code you still need to be prepared to scan the directory regardless. So what's the big deal about having a descriptor to a directory open, anyhow?<br>
<p>
fanotify has FAN_UNLIMITED_QUEUE, but that just seems like a DoS attack waiting to happen.<br>
<p>
inotify is more convenient than EVFILT_VNODE in many respects, but in terms of a sane API that equitably divides concerns between user-space and kernel-space, EVFILT_VNODE wins hands-down. How many file managers are there, versus applications which only need basic event notification for a small set of directories or files? That's a lot of convoluted kernel code to handle one or two applications.<br>
<p>
OS X Finder does just fine with EVFILT_VNODE. And OS X has the O_EVTONLY descriptor flag, which permits the kernel to unmount volumes with open descriptors.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor604912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2014 22:15 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/604912/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The file descriptor limit is only part of the reason for having watch descriptors instead.  'struct file' in the kernel is not small.  It is much larger than you would need to place a watch on a filesystem object.<br>
So using lots of file descriptors doesn't just push against a limit, it wastes memory.<br>
<p>
<a href="http://lxr.free-electrons.com/source/Documentation/filesystems/inotify.txt#L219">http://lxr.free-electrons.com/source/Documentation/filesy...</a>  (Line 219)<br>
<p>
I think it would be great to put 'struct file' on 'a diet' much like what was done to 'struct inode', so it only holds the bare minimum (including an _operations pointer) and various users embed it in a larger structure as required (the kernel approach to OO).<br>
<p>
That, combined with O_EVTONLY (great idea!), would allow fds to be used instead of wds.  Then you just pass all your O_EVTONLY fds to epoll and it "just works" :-)<br>
<p>
Unfortunately there is no room in Linux for another file notification API, so I'll never get to try this out.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605061"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 23:40 UTC (Thu)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/605061/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Unfortunately there is no room in Linux for another file notification API, so I'll never get to try this out.</font><br>
<p>
Indeed.  I gave up on trying to convince kernel devs that not having recursive watches was a huge API hole in inotify (try monitoring a hierarchy of 30 million files, I dare you ;).<br>
<p>
I implemented my own notification schemes in FUSE filesystems instead, and never looked back.  Among other things, I can prevent race conditions by blocking whatever's accessing the files until whatever's watching the accesses catches up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605061/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 8:49 UTC (Fri)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/605091/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't this a DoS wanting to happen? How can you prove that the watcher is making progress?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 14:02 UTC (Fri)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/605123/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Isn't this a DoS wanting to happen?</font><br>
<p>
Depends on how you define the "S" in DoS.<br>
<p>
If you want to trigger a backup process whenever files change, it might be reasonable to stop files changing until that process catches up, or at least wait until the notification has been stored in a persistent queue somewhere so the backup process can get to it later.<br>
<p>
The other common example is blocking access to files by content, e.g. in a virus scanner.<br>
<p>
Whether this is DoS or just a heavy implementation cost depends on whether it's more important to have up-to-date backups or to be able to rapidly modify files without blocking.<br>
<p>
Obviously this wouldn't be something you just let random users do with their file browsers.<br>
<p>
<font class="QuotedText">&gt; How can you prove that the watcher is making progress?</font><br>
<p>
By implementing a synchronous notification mechanism, e.g. make the watcher be a function call inside the FUSE daemon, or implement a lock on each notification object that blocks access to the watched object until the watcher clears the lock.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor606391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2014 3:05 UTC (Thu)
                               by <b>eMBee</b> (guest, #70889)
                              [<a href="/Articles/606391/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
exactly that.<br>
<p>
we tried to use inotify to find new files for backup, so that rsync or csync2 would not have to scan the whole tree of a few TB worth of files, but we found that setting up the watches alone took more than an hour. longer even than it takes for csync2 to scan the whole tree.<br>
<p>
would you be willing to publish your FUSE notification scheme?<br>
<p>
greetings, eMBee.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor605214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2014 0:59 UTC (Sat)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/605214/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Unfortunately there is no room in Linux for another file notification API, so I'll never get to try this out.</font><br>
<p>
Are you sure? I also thought that nobody would want another half baked file notifications api, but then fanotify was added...<br>
<p>
So who knows...Apparently I was wrong.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor605224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2014 7:51 UTC (Sat)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/605224/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why doesn't struct inotify_event{} contain a timestamp field?   Wouldn't that be valuable to a significant fraction of users?    Certainly it's easy to create a larger struct that extends (subclasses!) inotify_event{} but figuring out the value of the timestamp is less obvious given that, as the sample code shows, the typical instantiation proceeds to "Process all of the events in buffer returned by read()".   Perhaps the answer will be revealed in the eagerly awaited next episode of this cliffhanger series.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor605551"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2014 7:05 UTC (Wed)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/605551/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be really nice if the article also discussed how other OSes deal with this problem. In case there's some kind of NIH syndrome going on.<br>
<p>
That said, one advantage of not using real file descriptors is that you won't block unmount, which can be nice for something that's trying to run in the background.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605551/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2014 23:08 UTC (Wed)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/605695/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If only there was a way to own a 'weak' file descriptor that doesn't block unmounting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor604929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 4:23 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/604929/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Some of the common use cases are the following: </font><br>
<p>
I wonder what other, possibly less common, use cases there are.<br>
<p>
One of my favourites is as a publish/subscribe (aka 'multicast') IPC mechanism.  It is a bit clunky, but it can be made to work.<br>
Who needs dbus when you can muck about with files and dnotify :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor604933"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 4:41 UTC (Thu)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/604933/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you want to pull data out of a large set of files being updated (eg logfiles), inotify can be useful to do so in a timely way with a minimum of stats.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604933/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor604937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 5:22 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/604937/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The prospect of races seems worth mentioning.  If a new directory appears, anything could happen in it in the time it takes to start watching it. To me that seems a fatal flaw, and one that seems hard to excuse in notify.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor604947"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 8:37 UTC (Thu)
                               by <b>jbdenis</b> (guest, #56289)
                              [<a href="/Articles/604947/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; To me that seems a fatal flaw, and one that seems hard to excuse in notify.</font><br>
<p>
I concur. The fact that you can miss events is quite annoying. From my point of view, something like /dev/fsevents from OS X (<a href="http://en.wikipedia.org/wiki/FSEvents">http://en.wikipedia.org/wiki/FSEvents</a>) looks like a more robust way to handle the filesystem notification problem.<br>
<p>
There was an nice discussion here about this problem on the bup google groups :<br>
<p>
<a href="https://groups.google.com/forum/#!topic/bup-list/CXRI7MS3LwM">https://groups.google.com/forum/#!topic/bup-list/CXRI7MS3LwM</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604947/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor604980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 14:41 UTC (Thu)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/604980/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think fanotify fixes this, as long as you don't mind requesting monitoring of an entire filesystem, filtering out events that you're not interested in. This doesn't recurse into mounts underneath the monitored filesystem however.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 10:00 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/605100/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think fanotify fixes this, as long as you don't mind requesting monitoring of an entire filesystem, filtering out events that you're not interested in.</font><br>
Does that need to be done in userspace? That might be the next application for the new BPF :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor605644"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2014 18:22 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/605644/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It doesn't report link or unlink events, so if you're trying to use it to spot, well, things that changed (so you can, perhaps, back them up) fanotify is currently useless.<br>
<p>
It's OK for its original use case of virus scanning, but who the hell cares about that?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605644/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2014 7:20 UTC (Mon)
                               by <b>timmyp</b> (guest, #97966)
                              [<a href="/Articles/606023/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could fanotify usefully be extended to report link/unlink events, or does it have other flaws that would still preclude it's use?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2014 16:37 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/606301/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hm. It occurs to me that fanotify may report link / unlink as a modification of the linked directory. This still requires scanning the directory to find the new file, but is better than nothing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor605067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 0:06 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/605067/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the technique there is to monitor the new directory and also scan it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 14:45 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/605145/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think the technique there is to monitor the new directory and also scan it.</font><br>
<p>
It's a lot of fun (which I for one will happily leave to somebody else) to (try to) arrive at a coherent view of a directory which changes while you scan it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor605015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 15:48 UTC (Thu)
                               by <b>fandingo</b> (guest, #67019)
                              [<a href="/Articles/605015/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In one of the later articles, could you include some discussion on GTK+'s GFileMonitor and QT's QFileSystemWatcher? They're both built on inotify, but it might be interesting to include some higher-level notification methods. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor605227"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Filesystem notification, part 1: An overview of dnotify and inotify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2014 13:08 UTC (Sat)
                               by <b>tomgj</b> (guest, #50537)
                              [<a href="/Articles/605227/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
By contrast, the later inotify and fanotify APIs were each implemented using new system calls.
</blockquote><p>
I'm afraid the use of the word "implemented" in the above is problematic.  If we live in a world in which the implementation of an API is when someone writes the working code that shows the behaviour required by the design / specification of that API, it does seem problematic to also use "implemented" to mean something else.  In the above sentence, saying the APIs were *designed* or *specified* using new system calls would carry much less risk of causing confusion.  This avoids overloading "implemented" with closely related but critically distinct meanings.
</p><p>
Although it's clear to someone with a solid grasp of these concepts what the author actually meant in the sentence quoted above, adhering to a stricter nomenclature around interfaces and implementations, and specifically use of the word "implementation", could help these concepts develop better in the section of the readership where the concepts are muddled together in unhelpful ways.  And I would speculate that the majority of the readership falls in to the latter category.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/605227/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">API implementation or design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2014 19:44 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/605245/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
saying the APIs were *designed* or *specified* using new system calls would carry much less risk of causing confusion
</blockquote>
<p>
I agree with that.  I know that the implementation the author had in mind was where inotify is an implementation of the filesystem notification API concept, but it's sloppy.
<p>
There is surprisingly much sloppy terminology, requiring readers to disambiguate using context and common sense, in computer engineering.  In this article, for example, inotify_init() is called a system call.  It's really a whole class of system calls - over all computers and all time, there have probably been millions of inotify_init() system calls.
<p>
I've often said that confusing the object with the class is the biggest impediment to understanding in technical documents I read, but confusing design and implementation, forcing the reader to figure out which level of the process the author is writing about, might be the second biggest.

      
          <div class="CommentReplyButton">
            <form action="/Articles/605245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605553"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">API implementation or design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2014 7:22 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/605553/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If somebody asks about your duck call do you answer, "Which one? I've been hunting for 40 years."<br>
<p>
Probably not. 'cause it's referring to the characteristic sound you make to summon a duck, and not the particular times you made that sound.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605553/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605627"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">API implementation or design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2014 16:20 UTC (Wed)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/605627/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Right, that's another good example.  "Duck call" can refer to an object - a single event - or to a class of those events - the ones that have a certain characteristic sound.  The reader has to determine from context which one the writer meant.
<p>
Often, the reader can disambiguate instantly and subconsciously.  Other times, the reader has to look ahead a few sentences to resolve the ambiguity.  In the worst case, the reader subconsciously chooses the wrong interpretation and later gets stuck and has to back up and look for places the writer might have meant something else.
<p>
"Bob's duck call worked" is an example of where the disambiguation is not trivial.  Are we telling of a particular duck shooting or are we talking about Bob's now-over duck hunting career?
<p>
Regardless of whether it's easy or hard to disambiguate, the writer's goal should be to save the reader from having do <em>any</em> figuring out.  If the writer can be explicit about object versus class, that helps.

      
          <div class="CommentReplyButton">
            <form action="/Articles/605627/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
