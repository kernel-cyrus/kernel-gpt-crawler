        <!DOCTYPE html>
        <html lang="en">
        <head><title>Constant-time instructions and processor optimizations [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/921511/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/921959/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/921511/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Constant-time instructions and processor optimizations</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 3, 2023</br>
           </div>
Of all the attacks on cryptographic code, timing attacks may be among the
most insidious.  An algorithm that appears to be coded correctly, perhaps
even with a formal proof of its correctness, may be undermined by
information leaked as the result of data-dependent timing differences.
Both Arm and Intel have introduced modes that are intended to help defend
against timing attacks, but the extent to which those modes should be used
in the kernel is still under discussion.
<p>
<h4>Timing attacks</h4>
<p>
Timing attacks work by observing how much time is required to carry out an
operation; if that time varies according to the data being operated on, it
can be used to reconstruct that data.  As a simplistic example, imagine a
password-checking function that simply compares a provided string against a
password stored in a (presumably) secure location.  
A logical
implementation would be to start at the beginning, comparing characters,
and return a failure status as soon as an incorrect character is found.
That algorithm could be
naively coded as:
<p>
<pre>
    nchars = max(strlen(attempt), strlen(password));
    for (i = 0; i &lt; nchars; i++)
        if (attempt[i] != password[i])
	    return false;
    return true;
</pre>
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
The time this check takes is thus a function of the number of correct
characters at the beginning of the string.  An attacker could use this
information to reconstruct the password, one character at a time.
Real-world timing attacks that can, for example, extract cryptographic keys
have been demonstrated many times.

<p>
In response, security-oriented developers have learned to avoid
data-dependent timing 
variations in their code.  In the example above, for example, the entire
password string would be compared regardless of where the first wrong
character is found.  All of this careful work can be undermined, though, if
the CPU this code runs on has timing artifacts of its own.  It will surely
come as a shock to LWN readers to learn that, in fact, CPUs do exhibit such
behavior.
<p>
The CPU vendors are not unaware of this problem or its importance.  But
they are also not unaware of how beneficial some optimizations that
introduce timing differences can be for certain benchmark results.  The
usual tension between security and performance objectives comes into play
here, and the CPU vendors have taken the usual way out: make the users
figure out which they want to sacrifice to gain the other.
<p>
<h4>Constant-time processor modes</h4>
<p>
Both Arm and Intel have thus introduced modes that guarantee that some
instructions, at least, will execute in constant time regardless of what
the operands are.  In Arm's case, the mode is called <a
href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/DIT--Data-Independent-Timing">Data
Independent Timing (DIT)</a>; Intel calls its mode <a
href="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html">Data
Operand Independent Timing (DOIT)</a> mode, often called DOITM.  Neither
mode is enabled by default.
<p>
Back in August 2022, Eric Biggers <a
href="/ml/linux-kernel/YwgCrqutxmX0W72r@gmail.com/">asked</a> whether these
modes should be enabled by kernel.  As a result of that discussion, <a
href="https://git.kernel.org/linus/01ab991fc0ee">a patch by Ard
Biesheuvel</a> was merged to enable DIT for the arm64 architecture — but
only when running in the kernel.  DIT remains off for user space by
default, but enabling it is an unprivileged (and cheap) operation on that
architecture, so 
user-space developers can enable it easily when they feel the need.  This
feature will be part of the 6.2 kernel release; it has not, as of this
writing, been backported to any stable updates.
<p>
The story for x86 is less clear.  DOITM is controlled by a model-specific
register (MSR) and cannot be changed by user space.
The August discussion wound down despite
<a href="/ml/linux-kernel/Y1du6kdk/6L0O56a@sol.localdomain/">an attempt</a>
by Biggers to restart it in October.  He <a
href="/ml/linux-kernel/20230125012801.362496-1-ebiggers@kernel.org/">returned
in January</a>, asking once again whether DOITM should be enabled by
default for x86 — and advocating that it should:
<p>
<blockquote class="bq">
	Cryptography algorithms require constant-time instructions to
	prevent side-channel attacks that recover cryptographic keys based
	on execution times.  Therefore, without this CPU vulnerability
	mitigated, it's generally impossible to safely do cryptography on
	the latest Intel CPUs.
</blockquote>
<p>
Dave Hansen was <a
href="/ml/linux-kernel/14506678-918f-81e1-2c26-2b347ff50701@intel.com/">less
enthusiastic</a> about the idea, even though he concluded that it was
"<q>generally the right thing to do</q>".  He pointed to language in
Intel's documentation stating that DOITM only adds value for code that was
specifically written with timing differences in mind:
<p>
<blockquote class="bq">
	Translating from Intel-speak: Intel thinks that DOITM purely a way
	to make the CPU run slower if you haven't already written code
	specifically to mitigate timing side channels.  All pain, no gain.
	<p>
	The kernel as a whole is not written that way.
</blockquote>
<p>
DOITM, he said, is only going to be useful for a small amount of carefully
written cryptographic code in user space, and will only be a performance
loss for everything else.
He also noted that Intel explicitly warns that the performance impact of
DOITM may be "<q>significantly higher on future processors</q>".  The "Ice
Lake" generation of processors is the first where DOITM makes any
difference at all; constant-time operations are evidently the norm on
earlier generations.  
<p>
Biesheuvel <a
href="/ml/linux-kernel/CAMj1kXHcUdJQDzF1VYe8uP_-Lb1W6JXxmfTEDYGuMZqSy=2BqA@mail.gmail.com/">argued</a>
that the value of DOITM extends beyond user-space cryptographic libraries,
and that it is even more relevant to the kernel:
<p>
<blockquote class="bq">
	But for privileged execution, this should really be the other way
	around: the scope for optimizations relying on data dependent
	timing is exceedingly narrow in the kernel, because any data it
	processes must be assumed to be confidential by default (wrt user
	space), and it will probably be rather tricky to identify CPU bound
	workloads in the kernel where data dependent optimizations are
	guaranteed to be safe and result in a significant speedup.
</blockquote>
<p>
Biggers <a href="/ml/linux-kernel/Y9MAvhQYlOe4l2BM@gmail.com/">questioned
Hansen's focus on performance</a>, saying that the kernel operations that
benefit most from data-dependent optimizations are almost certainly the
ones that most need protection, since they are the ones that will show the
strongest timing differences.  He concluded:
<p>
<blockquote class="bq">
	I think the real takeaway here is that the optimizations that Intel
	is apparently trying to introduce are a bad idea and not safe at
	all.  To the extent that they exist at all, they should be an
	opt-in thing, not out-opt.  The CPU gets that wrong, but Linux can
	flip that and do it right.
</blockquote>
<p>
Hansen <a
href="/ml/linux-kernel/8b2771ce-9cfa-54cc-de6b-e80ce7af0a93@intel.com/">answered</a>
that the community has "<q>looked at how bad the cure is compared to the
disease for *every* one of these issues</q>", referring to other types of
hardware vulnerabilities.  DOITM is different, he said,
because it looks like the cure is likely to get worse over time rather than
better; that makes it hard to come up with a reasonable policy in the
kernel.  He later <a
href="/ml/linux-kernel/16e3217b-1561-51ea-7514-014e27240402@intel.com/">added</a>
that, after discussions within Intel, he feels the kernel community should
not jump to enable DOITM: "<q>Suffice to say that DOITM
was not designed to be turned on all the time.  If software turns it on
all the time, it won't accomplish what it was designed to do.</q>"
Doing that, he <a
href="/ml/linux-kernel/c5809098-9066-d90d-1bcc-108a11525cac@intel.com/">said</a>,
would deprive systems of the "<q>fancy new optimizations</q>" that are
coming in the future.

<p>
No conclusions have been reached this time either — at least, not yet.
It has not helped that, so far, nobody has posted any benchmarks showing
what the performance impact of DOITM is.  Assuming that cost is not huge,
though, it would be surprising if DOITM does not end up being enabled by
default in the kernel, at least, with the ability for user space to enable
it on demand.  "Insecure by default" is rarely a way to impress
users, after all.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures">Architectures</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Cryptography">Cryptography</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/921511/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor922135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 16:02 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922135/">Link</a>] (46 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; "Insecure by default" is rarely a way to impress users, after all.</span><br>
<p>
Well, for almost all code it's actually better to be "insecure by default", if that means it's faster.<br>
The code where timing attacks matter is only an extremely tiny amount.<br>
<p>
Code where timing matters has to be carefully designed today *already*.<br>
Therefore, I think "insecure by default" is the right choice. Code can simply flip the switch and enable this constant timing feature just where it matters.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 16:18 UTC (Fri)
                               by <b>wsy</b> (subscriber, #121706)
                              [<a href="/Articles/922141/">Link</a>] (44 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Problem is flipping an MSR is expensive and requires privilege. I think a safe defafult with an option to be unsafe is the way to go.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 18:39 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922157/">Link</a>] (43 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I think a safe defafult with an option to be unsafe is the way to go.</span><br>
<p>
And not just for flipping an MSR. What if someone takes sensitive code, written on a system BEFORE this stuff, and runs it on a processor that came after? How is it supposed to switch on a defense that didn't exist when the program was built?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 18:55 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922161/">Link</a>] (42 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; How is it supposed to switch on a defense that didn't exist when the program was built?</span><br>
<p>
It's supposed to behave the same way any existing binaries are supposed to behave when deployed on newer hardware -- no difference, because it can't optimize for what it doesn't know exists.<br>
<p>
Software that cares about constant time is already going to have to be very carefully written, perhaps even hand-coded in assembler for the specific processor being used.  If a new future processor has additional features to make this easier, that's still going to require opting in to those features.  Similarly, it may perform existing functions differently (eg faster, which is usually the goal for newer processors) which may require re-visiting that carefully-tuned software.<br>
<p>
Any other answer basically amounts to "backwards compatibility doesn't matter".<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 19:41 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922166/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup but isn't the point of what they're saying here, that these optimisations (which weaken security) will be switched on, by default, by the processor?<br>
<p>
So your code, which was perfectly secure before, is now insecure because although its inputs and outputs don't change, the way the processor runs it does. And the only way to get the original "timing profile" back is to turn off the options that didn't used to exist.<br>
<p>
Cheers,<br>
Wol<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 19:53 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922167/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, but what I'm saying is that this has nearly always been the case -- different processors execute the same code in different amounts of time, because execution time has never been guaranteed at an architectural level.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 0:12 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922180/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From the recent gihub incident, Hyrum's Law:<br>
<span class="QuotedText">&gt;With a sufficient number of users of an API,</span><br>
<span class="QuotedText">&gt;it does not matter what you promise in the contract:</span><br>
<span class="QuotedText">&gt;all observable behaviors of your system</span><br>
<span class="QuotedText">&gt;will be depended on by somebody.</span><br>
<p>
And indeed, this constant-time behavior has been heavily depended on by EVERYBODY for at least the last 30 years.<br>
<p>
Just because you did not specify it in a contract does not mean you are not responsible for it. The linux kernel is responsible for every bit of it's behavior that a userspace application comes to depend on, for example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 3:54 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922195/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Just because you did not specify it in a contract does not mean you are not responsible for it. The linux kernel is responsible for every bit of it's behavior that a userspace application comes to depend on, for example.</span><br>
<p>
Is "if you change the hardware the behaviour will not be identical" really such a hard thing to grasp?<br>
<p>
Am I the only one that remembers the "turbo" buttons on old PCs?  When off, it would down-clock it to the 4.77MHz of the original PC, because there was (badly-written!) software that had hard-coded timing that broke on newer (==faster) systems. Should that software have held up the progression of the entire industry?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 13:18 UTC (Sat)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/922211/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
#bringbackturbo<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922269"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 18:57 UTC (Sun)
                               by <b>barryascott</b> (subscriber, #80640)
                              [<a href="/Articles/922269/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
CPUs have dynamic clock speed already, aka turbo, based on the thermal overhead available on the chip.<br>
<p>
So this should already be an issue right?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922269/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 19:12 UTC (Sun)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/922270/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was referring to the little red button that inevitably need to be in the up/off state to make game's timing loop run at the intended rate. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 19:20 UTC (Sun)
                               by <b>barryascott</b> (subscriber, #80640)
                              [<a href="/Articles/922271/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes i know the button you mean, mandatory to make games work at the right speed.<br>
<p>
Just pointing out its a built in feature now.<br>
<p>
Also that it will change the time a crypto algorithm runs in.<br>
<p>
Oh and we already have efficiency cores that run slower then performance cores on recent CPUs.<br>
<p>
Another reason a CPU cannot be relied on to execute in constant wall clock time.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 21:11 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922275/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Another reason a CPU cannot be relied on to execute in constant wall clock time.</span><br>
<p>
Except you're missing the point ... although this too actually might be a help.<br>
<p>
We don't care whether wall time is constant, what we care about is that time is *independent* of the operation. If they all run on a slow core, fine. If they all run on a fast core, fine. If some run on the slow core and some on the fast, AT RANDOM, brilliant!<br>
<p>
But if time depends on the operator/operands, then anything capable of observing time will be able to leach information.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 22:04 UTC (Sun)
                               by <b>barryascott</b> (subscriber, #80640)
                              [<a href="/Articles/922277/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope i have not missed the point.<br>
<p>
What happens if the CPU turns turbo on or off while the algorithm is running?<br>
What happens if the thread is moved between cores with different performance characteristics as it runs?<br>
<p>
Do these events help or hinder security already?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 23:54 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922282/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What happens if turbo changes? What happens if it moves cores? That will IMPROVE security.<br>
<p>
The attacker is wanting to watch (and analyse) differences in times caused by the operands.<br>
<p>
Therefore the more you can introduce *noise* into the timings (eg by turning turbo on and off, or by core-switching), you're making an attacker's job harder, because they are getting statistically significant timing changes, that from their point of view is unwanted noise. It's interfering with their analysis.<br>
<p>
That's what you're missing. The less the time differences are caused by the operands, the more the time differences are caused by random events that have nothing to do with the operands, the better. You WANT to introduce noise, to hide the signal ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 7:45 UTC (Tue)
                               by <b>JanC_</b> (guest, #34940)
                              [<a href="/Articles/922428/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  What happens if turbo changes? What happens if it moves cores? That will IMPROVE security.</span><br>
<p>
Depends on whether the turbo changes &amp; core moves depend on the operands or not, of course…  :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor922394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 20:19 UTC (Mon)
                               by <b>draco</b> (subscriber, #1792)
                              [<a href="/Articles/922394/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Randomly changing clock rate won't help, it just increases the number of samples required. The variation due to CPU core will average out and the data driven variation will persist.<br>
<p>
cf. <a href="https://www.google.com/search?q=timing%20attacks%20random%20delay">https://www.google.com/search?q=timing%20attacks%20random...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 20:33 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/922398/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It doesn't hinder it, either - unless the choice of CPU clock rate is correlated with the input, it's just noise, and not signal. The problem only kicks in when the samples contain some signal correlated with the input data - at which point, there's no way to add noise that will prevent you ever finding the signal, given that you can get as many samples as you need.


      
          <div class="CommentReplyButton">
            <form action="/Articles/922398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 3:30 UTC (Sun)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922237/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The turbo button is irrelevant. It changed the clock speed but every instruction always took the same number of cycles regardless of it's setting and never, ever did any of those instructions' execution times change depending on their data.<br>
<p>
The possibility that different hardware may behave differently isn't in question.<br>
<p>
Intel decided to break a fundamental requirement of all security-critical code that has been well-documented for decades, from one generation fo hardware to the next. That's a colossally stupid design decision any way you slice it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922429"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 8:07 UTC (Tue)
                               by <b>JanC_</b> (guest, #34940)
                              [<a href="/Articles/922429/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Instructions like MUL &amp; DIV definitely had different timings depending on their operands on the original 8086 &amp; 8088.<br>
<p>
See e.g. <a href="https://www.oocities.org/mc_introtocomputers/Instruction_Timing.PDF">https://www.oocities.org/mc_introtocomputers/Instruction_...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922429/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 0:08 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922178/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      This hits the nail on the head. 
<br><br>
<b>It would take more human effort than every programmer on earth could muster</b> to review all the code out there for every spot where this optimization would have to be turned off and back on again. It is not a trivial change to go back over 30+ years of code and perform this kind of sensitive analysis.
<br><br>
The code of the last 15+ years MUST continue to work correctly on the latest processors. Honestly, inertia is the only thing that's kept x86 alive for most of it's life. It was something AMD understood well when they came out with amd64.
<br><br>
Leave these dangerous tricks disabled in the general case, and let people who need the speed opt-in as they currently do with mitigations=off. If the hardware allows control on a per-core or per-thread level, it should be fine to allow opting in on that basis too.
<br><br>
Then there is the problem of ongoing burden, because the very last thing we need is *YET ANOTHER* way to forget and screw up security.
<br><br>
P.S. And before anyone asks, yes the effects will be observable. This is not an accidental cache effect as caused as with Spectre. The whole point of these optimizations is to create as large and observable as possible a difference in execution time. It's how you know whether they work.









      
          <div class="CommentReplyButton">
            <form action="/Articles/922178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 11:33 UTC (Sat)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922207/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;It would take more human effort than every programmer on earth could muster to review all the code &gt;out there for every spot where this optimization would have to be turned off and back on again. It is not &gt;a trivial change to go back over 30+ years of code and perform this kind of sensitive analysis. </span><br>
<p>
That is not true.<br>
Such an analysis is not needed, because all of the code sections which are coded with constant-time-execution are already known today. Otherwise they wouldn't be constant-time (guaranteed).<br>
<p>
Only code sections which are *already* carefully coded with constant-time-execution today have to be revisited.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 3:43 UTC (Sun)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922238/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;constant-time-execution are already known today.</span><br>
<p>
Unbelievably, colossally, wrong.<br>
<p>
Firstoff, there is no central database of everywhere a bit of security code has been written. There are some obvious suspects, like sshd, or curl, or a browser. But would you have guessed that there was security-sensitive code in a text renderer?<br>
<p>
Second, take the example of the browser, or the ssh server, or whatever. Obviously there's security sensitive code in there. But having been written with constant time isn't the same as being somehow "tagged" for it. There's no universal way to find such code, being as at best you might have some vague comment next to it.<br>
<p>
You can't just grep -i "constant time" ./*.c across each codebase. Human people need to search through the code and apply human reasoning to find each and every instance. Across millions upon millions of lines of code.<br>
<p>
If you actually read the article carefully, you'd also know that all the data the kernel handles must remain secret in some way or another, since it belongs to a particular userspace process and shouldn't be snooped on. Intel's mistake was thinking that the security sensitive stuff was limited to a couple of cipher implementations, and here you've fallen into the same line of thinking. As one of the developers in the discussion pointed out, the places in the general kernel code where this would make the most difference are also the places most likely to be sensitive to disclosure. This is in many ways a potential arbitrary information disclosure vulnerability.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 13:08 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922254/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a TEMPEST in a teacup :-)<br>
<p>
For those who don't remember the big old computer screens - you know, the ones that were almost as deep as they were wide - there was a snooping method called "tempest". By pointing a radio receiver or whatever it was at the building over the road, you could actually recreate the picture on the screen.<br>
<p>
At the end of the day, EVERYTHING can be a security vulnerability, and adding new stuff by default that breaks old security guarantees should be a no-no.<br>
<p>
If we have a new instruction set that enables this stuff, great. We can use it as appropriate. Compilers can bake it into new code, fine. BUT DON'T BREAK OLD CODE. (And yes, it doesn't change the output the *good* guys are looking for. But if it changes the output the *BAD* guys are looking for, in a manner they can take advantage of, then that's BAAAAD!).<br>
<p>
Take advantage of this to design a new, backwards-compatible, instruction set and it'll be a good thing. Otherwise, no I don't want my personal details leaked. And while me, personally, is not worth attacking, someone like Rishi Sunak or Keir Starmer or or or ... they are a juicy target ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 15:19 UTC (Sun)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922260/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If there is code which needs constant time semantics and that code is not already written and documented with constant time in mind, then that piece of code is *already* broken.<br>
It might work. But only out of pure luck. And it might break at any time. Even today. Think of compiler update.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 16:25 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922261/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And even if it's written and documented (which according to your definition is NOT broken), if Intel suddenly change the x86 instruction code behaviour then it will still break. And THIS is the problem here - code that works fine - SECURITY code that works fine - will be broken by Intel changing the behaviour of existing op-codes.<br>
<p>
So ALL security-sensitive code has suddenly had the assumptions it relies on invalidated. Which means pretty much any company processing sensitive data will simply have to ban these processors from their datacentres ...<br>
<p>
Just one more poor decision in a long list of Intel decisions that looks good until you actually think through the consequences ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 16:35 UTC (Sun)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922262/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And even if it's written and documented (which according to your definition is NOT broken),</span><br>
<p>
Can you please stop putting words into my mouth.<br>
<p>
<span class="QuotedText">&gt; if Intel suddenly change the x86 instruction code behaviour then it will still break.</span><br>
<p>
Yes. But that's no different from today, where some compiler upgrade may break you timing assumptions.<br>
There's no such thing as timing assumptions in the C standard.<br>
<p>
And the same is true for processor instructions today.<br>
Yes, you get rough timing numbers. But you usually don't get detailed information about internal behaviour. (Pipelining, caching, microcode). And such internal behaviour did change in the past and will change in the future.<br>
<p>
Therefore, you will have to revisit and analyze your timing critical code on a regular basis anyway.<br>
Intel introducing this new non-constant execution timing does not fundamentally change that requirement.<br>
<p>
Having constant-timing code and just assuming that it will be constant timing on new toolchains and new processors simply is a false assumption and has always been.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922263"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 16:52 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922263/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Having constant-timing code and just assuming that it will be constant timing on new toolchains and new processors simply is a false assumption and has always been.</span><br>
<p>
And therein lies the problem. What that leads to is that every time you deploy a system, you need to do a full security audit. Okay, a lot of that audit could just be "oh these assumptions are still valid", but you can't even replace a failed motherboard without having to revisit everything.<br>
<p>
That's the problem with these changes. If they're on by default, it breaks pretty much every pre-existing security audit. Do you really want to be forced to rewrite a large chunk of your code, simply to be able to replace a failed motherboard safely?<br>
<p>
And why is it always Intel that seems to be at the centre of these storms? Okay, it could be biased reporting, but my memory goes back a long way and I don't remember the other x86 vendors being caught up in storms over bad engineering design decisions. The list of bad Intel decsions just goes on and on ...<br>
<p>
<span class="QuotedText">&gt; &gt; And even if it's written and documented (which according to your definition is NOT broken),</span><br>
<p>
<span class="QuotedText">&gt; Can you please stop putting words into my mouth.</span><br>
<p>
Fair enough. But in what other heavily regulated (and yes, computing - when handling PII - is heavily regulated) industry would a supplier expect to get away with just throwing all their customers' expectations in the dustbin? Would a steel manufacturer suddenly change the specification of structural girders and not expect massive kickback?<br>
<p>
If I have to comply with legal requirements, that place ME in jeopardy, I don't expect my suppliers to move the goalposts behind my back ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922263/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 17:14 UTC (Sun)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922265/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; That's the problem with these changes. If they're on by default, it breaks pretty much every</span><br>
<span class="QuotedText">&gt; pre-existing security audit. Do you really want to be forced to rewrite a large chunk of your</span><br>
<span class="QuotedText">&gt; code, simply to be able to replace a failed motherboard safely?</span><br>
<p>
That's essentially true. However,<br>
<p>
a) This has not fundamentally changed with the HW change from the article.<br>
b) I think you're greatly over estimating the mount of affected code and the amount of work.<br>
<p>
The affected code is basically only the well known parts of some types of crypto (e.g. remote authentication) and maybe some parts of the operating system which check credentials/permissions or does some IPC or something like that.<br>
<p>
Almost all code running on any machine is not affected security wise. (In contrast: If this performace measure is not enabled by default, then all code running is affected).<br>
<p>
And if there's code hidden somewhere which has constant timing requirements and we don't know about that fact, then we should develop methods to find and identify such code. Regardless of the HW change from the article, because such code is a security problem *already*.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 9:34 UTC (Mon)
                               by <b>leromarinvit</b> (subscriber, #56850)
                              [<a href="/Articles/922295/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Almost all code running on any machine is not affected security wise. (In contrast: If this performace measure is not enabled by default, then all code running is affected).</span><br>
<p>
I doubt that. Spectre attacks work, AFAIU, by exploiting the tiny timing differences created by speculative execution caching data (or not doing so). This, OTOH, deliberately introduces data-dependent timing differences that are designed to be as large as possible (since they're performance optimizations). So it seems like Spectre on steroids to me.<br>
<p>
How do you know which code needs to be protected? I'd question the assumption that it only matters for cryptographic code. I'd even say that the programmer CAN NOT know in advance if the information that's processed is sensitive, since that obviously depends on the information itself.<br>
<p>
A text renderer displaying this comment is probably irrelevant - LWN will happily serve a copy to anyone who asks. An image decoder decompressing cat pictures is probably not all that interesting a target either. But what if the same text renderer was displaying your draft of a classified report? What if the image being decoded was a construction drawing of your fancy new alien invasion shelter?<br>
<p>
It seems to me that the only person who can decide if such optimizations are acceptable is the user, and I'm leaning towards "off by default" for security. Make it easy to switch on, by all means, but the default configuration should be the one with the least "interesting" surprises.<br>
<p>
The only category of applications where this could probably be switched on by default are games, since it's highly unlikely that anything they process could be sensitive. But for everything else, we (as programmers) just don't know.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922297"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 10:01 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/922297/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Spectre is only a vulnerability under the assumption that the speculatively-executed code path has access to data that is not accessible under the intended code path, the speculative code can trigger timing variations that are visible to the intended code, *and* an attacker can directly or indirectly control the intended code (to the extent necessary to exfiltrate the data). In practice, this is quite common, especially in the kernel or in VMs.<br>
<p>
Spectre is fundamentally a privilege escalation attack, where we regard the speculative code as having a higher level of privilege than the intended code (because it has access to data that is not meant to be accessed). So, when we consider a case without this "speculative/intended" distinction, where there's just one code path (as in the case where Intel merely causes some instructions to execute faster), a Spectre-like attack cannot exist, because there is no privilege boundary to be crossed in the first place. In other words, you can't (usefully) attack yourself.<br>
<p>
Of course, this does not mean that there are no attacks, period. It just means that we won't see the same level of far-reaching "everything is on fire" problems we saw with Spectre. Vulnerabilities will be limited to cases where an attacker can cause victim code to execute a known algorithm on unknown-to-the-attacker data, and the attacker can also observe precise timing information. In practice, that's *mostly* crypto code, to my understanding, but I suppose there might be other edge cases where this comes up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922297/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 11:15 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922302/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Spectre attacks work,</span><br>
<p>
Spectre has nothing to do with this, at all.<br>
It's a completely different thing.<br>
The core of Spectre is that it opens a side channel via cache. That's not possible with the mechanism from the article.<br>
<p>
As I already said, I would maybe agree with enabling const-time in code such as the kernel, which handles data across permission boundaries. I still would like to see a real world threat scenario first, though.<br>
But I don't see any reason at all to enable it for all user code.<br>
<p>
<span class="QuotedText">&gt; How do you know which code needs to be protected?</span><br>
<p>
You'd better know already. Otherwise your algorithm probably is broken already.<br>
<p>
<span class="QuotedText">&gt; I'd even say that the programmer CAN NOT know in advance if the information that's processed is sensitive,</span><br>
<span class="QuotedText">&gt; since that obviously depends on the information itself.</span><br>
<p>
This is not about having "sensitive" information in the first place.<br>
It's about the algorithm.<br>
If your algorithm can leak information via timing to a third party that doesn't normally have access already and if the programmer can not rule out that such data is "sensitive", then it probably should be protected with constant timing.<br>
But that's *not* new. That doesn't change with the technology from the article.<br>
Your compiler can already compile your algorithm into data-dependent non-const-time. <br>
Therefore you must already protect against that today.<br>
<p>
<span class="QuotedText">&gt; But what if the same text renderer was displaying your draft of a classified report?</span><br>
<p>
Ok. And what kind of timing attack do you imagine?<br>
You are making up a lot of what-ifs, but no actual scenario where (non-)constant-timing comes into play.<br>
<p>
<span class="QuotedText">&gt;It seems to me that the only person who can decide if such optimizations are acceptable is the user,</span><br>
<p>
No, that's wrong. The only person who can decide is the algorithm developer.<br>
The user has no information about how the data is handled and how the algorithm works.<br>
<p>
There's a lot of hand waving going on here in the comments about how security would magically break everywhere. But nobody can really explain how that would actually work. Except for the already well known algorithms like password checks and credential hashing etc.<br>
<p>
I don't buy the argument that we must slow down the world, because we think there might be some vulnerability that we can't even explain how it would work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 11:41 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922304/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If your algorithm can leak information via timing to a third party that doesn't normally have access already and if the programmer can not rule out that such data is "sensitive", then it probably should be protected with constant timing.</span><br>
<p>
In other words, that's EVERY SINGLE DATABASE MANAGEMENT SYSTEM. There is your problem. The programmer (for the most part) has no clue whether the data is sensitive or not, and if he doesn't know, he must assume that it is.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 11:53 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922306/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;In other words, that's EVERY SINGLE DATABASE MANAGEMENT SYSTEM. There is your problem.</span><br>
<span class="QuotedText">&gt;The programmer (for the most part) has no clue whether the data is sensitive or not, and if he doesn't</span><br>
<span class="QuotedText">&gt;know, he must assume that it is.</span><br>
<p>
How do you extract data that you don't normally have access to from your database management system with this timing attack?<br>
Can you please explain that to me?<br>
<p>
The mere presence of "sensitive" data has nothing to do with this feature.<br>
<p>
If you can explain how you would do that with the feature from the article, then I will immediately stop arguing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 13:29 UTC (Mon)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/922311/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Databases don't even pretend to offer any kind of security against side-channel attacks in their data. If row-level security is offered, inserting into a table with a primary key will reveal the existence of another row with that primary key, whether or not you have permission to see it. The database will make no effort to hide whether lookups in an index succeed or not, so timing queries can reveal all sorts of information.<br>
<p>
This is all documented [1][2]. If you allow a user to execute arbitrary queries on a database, you're just asking for it. The answer is to not let users execute arbitrary queries on the database, not slow down everything to the slowest possible.<br>
<p>
Constant-time is really very hard, since the layers of CPU cache will make almost any operation involving memory dependant on the state of the system. If your algorithm doesn't take this into account, you're screwed already. Fortunately, it makes absolutely no difference in the vast majority of cases.<br>
<p>
[1] <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/row-level-security?view=sql-server-ver16#Best">https://learn.microsoft.com/en-us/sql/relational-database...</a><br>
<p>
[2] <a href="https://www.postgresql.org/docs/current/ddl-rowsecurity.html">https://www.postgresql.org/docs/current/ddl-rowsecurity.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor923452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2023 10:20 UTC (Thu)
                               by <b>demfloro</b> (guest, #106936)
                              [<a href="/Articles/923452/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;I don't buy the argument that we must slow down the world, because we think there might be some vulnerability that we can't even explain how it would work.</span><br>
<p>
Intel is trying to speed up the world at the cost of security. Processors before Ice Lake work as if DOITM is always enabled, Ice Lake and later processors will default to non-constant timing unless kernel enables DOITM. <br>
<p>
"For Intel® Core™ family processors based on microarchitectures before Ice Lake and Intel Atom® family processors based on microarchitectures before Gracemont that do not enumerate IA32_UARCH_MISC_CTL, developers may assume that the instructions listed here operate as if DOITM is enabled." from <a rel="nofollow" href="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html">https://www.intel.com/content/www/us/en/developer/article...</a><br>
<p>
Furthermore Intel tries to scare not to enable DOITM as they clearly plan to design future microarchitecture around it, so enabling DOITM will become more expensive. I don't see how all this is "slowing down the world".<br>
<p>
And on x86 currently there is no way for userspace to express to kernel need to enable DOITM at all. Hence kernel should keep DOITM enabled all the time to preserve past CPU behaviour for kernel itself and for userspace.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor922419"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 4:45 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/922419/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The only category of applications where this could probably be switched on by default are games, since it's highly unlikely that anything they process could be sensitive.</span><br>
<p>
Their DRM engines probably want to avoid being attacked…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922419/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor922670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2023 22:31 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/922670/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
And why is it always Intel that seems to be at the centre of these storms?
</blockquote>

In this particular case it seems that they caused the storm by their own documentation and the option to turn the operand-dependent timing of the affected instructions off.  Someone at Intel actually worried about constant-time routines, and did not want to break the constant-time property without giving the programmer a way to reassert it.  And if I understand the Intel documentation correctly (it is not that well written), the MSR setting exists since Skylake (2015), but only in Ice Lake (2019) and later they changed some previously constant-time instructions to have operand-dependent timing.

<p>I would not be surprised if some other CPU design house had just made the instructions have operand-dependent timing without announcing it and without such an MSR setting.

<p>OTOH, it's now 61 months since Spectre was published and 68 months since it was revealed to Intel and AMD, and AFAIK they all have failed to produce a Spectre-immune CPU, so Intel doesn't always take security so seriously.  Is this just whataboutism?  No: Assume you have a secret (e.g., a private key) that is architecturally accessed only with a constant-time algorithm to avoid classical side-channel attacks.  As long as Spectre is not fixed in hardware, that secret can be revealed through a successful Spectre attack on all the code (not just the tiny piece of code that performs architectural accesses to it) that has the secret in it's accessible memory; so unless you are sure that you mitigated all potential Spectre vulnerabilities (everywhere in the program), does the constant-time property of your architectural secret-handling code really matter?


      
          <div class="CommentReplyButton">
            <form action="/Articles/922670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 10:19 UTC (Thu)
                               by <b>nim-nim</b> (subscriber, #34454)
                              [<a href="/Articles/922688/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Once upon a time someone added compression to http (deflate, did wonders to make websites work fast on something else than the webdev lan). And then people figured how to break https by taking advantage of the way compression strips out the fat that makes observing and timing traffic hard.<br>
<p>
So now newer http specs explicitly deprecate compression. Even though it was a wonderful optimization, and the malvertizers continue to destroy site responsiveness with unwanted bulk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2023 7:31 UTC (Mon)
                               by <b>jwilk</b> (subscriber, #63328)
                              [<a href="/Articles/923109/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
[citation needed]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2023 10:19 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/923117/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think it's "deprecated" in general, but HTTP/2 says compression is forbidden in many cases (<a href="https://www.rfc-editor.org/rfc/rfc9113#name-use-of-compression">https://www.rfc-editor.org/rfc/rfc9113#name-use-of-compre...</a>):<br>
<p>
<span class="QuotedText">&gt; Compression can allow an attacker to recover secret data when it is compressed in the same context as data under attacker control. HTTP/2 enables compression of field lines (Section 4.3); the following concerns also apply to the use of HTTP compressed content-codings (Section 8.4.1 of [HTTP]).</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; There are demonstrable attacks on compression that exploit the characteristics of the Web (e.g., [BREACH]). The attacker induces multiple requests containing varying plaintext, observing the length of the resulting ciphertext in each, which reveals a shorter length when a guess about the secret is correct.</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; Implementations communicating on a secure channel MUST NOT compress content that includes both confidential and attacker-controlled data unless separate compression dictionaries are used for each source of data. Compression MUST NOT be used if the source of data cannot be reliably determined. Generic stream compression, such as that provided by TLS, MUST NOT be used with HTTP/2 (see Section 9.2).</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 2:44 UTC (Sun)
                               by <b>wujj123456</b> (subscriber, #84680)
                              [<a href="/Articles/922232/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Any other answer basically amounts to "backwards compatibility doesn't matter".</span><br>
<p>
This is quite a bit of a stretch to me. This is not incompatibility. It still runs and produces the same results. Imaging any timing change in new processors that expose previously unobservable race conditions becomes an issue of backward compatibility. One can equally argue the correctness of that program was dependent on the specific timing of each instructions it used. In that case, even results break, but it would be pretty wrong to view it as incompatibility. <br>
<p>
The carefully-tuned secure software made assumptions about unspecified behavior and thus more bugs are exposed on the new architecture. This needs to be fixed by the software owner and validated again on the new architecture. That would be my take. Of course, unless x86 ISA itself specified constant time data independent operation for certain instructions that Intel is going to break, then that's a different story. I haven't looked this up. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 8:37 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/922245/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The carefully-tuned secure software made assumptions about unspecified behavior and thus more bugs are exposed on the new architecture. This needs to be fixed by the software owner and validated again on the new architecture. That would be my take. Of course, unless x86 ISA itself specified constant time data independent operation for certain instructions that Intel is going to break, then that's a different story. I haven't looked this up.</span><br>
<p>
Why do you think this is unspecified behavior? The duration of most instruction (and the fact that the duration is independent of the operands) is definitely specified for the existing processors. This is necessary to produce efficient code, as the compiler needs to know when the results are ready and can be used without causing the processor to wait on the data. And this constant time behavior is absolutely vital for all cryptographic (and quite a bit of other) code in order to be secure. <br>
<p>
What was not specified that this will never change in future processors, just like it was never specified that all processors will support x86 indefinitely. If Intel now changes such a core design aspect, then this is clearly a backwards incompatible change that requires all software relying on the old behavior to be adapted. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 14:55 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922258/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why do you think this is unspecified behavior? The duration of most instruction (and the fact that the duration is independent of the operands) is definitely specified for the existing processors</span><br>
<p>
Yes, it is defined for *existing processors*.  But each of those existing processor family/generations can (and does) have *different* instruction durations.  Usually faster, but sometimes slower (eg for relatively uncommon legacy x86 instructions)  No CPU manufacturer has ever, EVER, guaranteed that relative instruction timing will never change in future processor families. [1]<br>
<p>
You cannot write one piece of software and expect it to behave *identically* (ie across the time domain) across every x86-64 (or x86, or ARM, or SPARC, or whatever) CPU ever produced to date, much less everything that will ever be produced.  And that's purely at the individual instruction level!  When you factor in different cache sizes/strategies, instruction decode/issue width, execution units, reorder buffers, branch predictors, uOP caches, and other microarchitectural state that varies with *every* processor family/generation, expecting identical, consistent behaviour (without careful adjustments for each processor type/family/whatever) is even more naive.  (And then you have the timing variations caused by other hardware, virtualization, and the likes of multitasking OSes)<br>
<p>
[1] And you know what?  99.99999% of software makers (and buyers) are more than happy with that, because they have come to expect each generation to be "faster" than the prior generation, even at the same clock speed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 16:41 UTC (Mon)
                               by <b>neggles</b> (subscriber, #153254)
                              [<a href="/Articles/922374/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How long a given instruction takes on a given CPU isn't the problem; the problem is that on chips with this feature enabled, how many cycles some instructions take will change depending on what the input data is. That's exactly what constant-time crypto is trying to avoid; you can't leak data though timing changes if your timing doesn't change.<br>
<p>
This is... potentially a Very Bad Idea. ARM's implementation is per-task, has an unprivileged userspace method to enable/disable, and the state is saved/restored when the stack is pushed/popped. If intel adjust their implementation to match, or at least made it opt in, that would be great, but...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions are not constant between processors, but rather constant regardless of data</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 18:20 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/922383/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Constant time code isn't about the code taking the same time (in any unit) as on past processors; rather, it's about adapting your code so that the time taken to execute code is <em>not</em> dependent on the inputs to that code. In other words, if I have a function f(x), the time taken to compute the value of f(x) does not depend on x, only on f. This is already not true of all instructions on all CPUs; for example, branch instructions take a variable amount of time depending on whether the branch predictor gets it right or wrong. But it is true of a useful subset - for example, MUL r32, r32 takes 9 clock cycles on the original Intel Pentium, and 3 on AMD Zen 4, which means that MUL takes constant time regardless of the register contents.
<p>The change is going to break that assumption for many more instructions than it's currently broken for. For example, taking MUL again, a future CPU might say that multiply by 0 or 1 is done by the register renamer and is "free" (subject to instruction decode limits) while multiply by 2 through 15 takes 1 clock cycle, multiply by 16 through 65535 takes 2 clock cycles, and multiply by 65536 through 2<sup>32</sup> - 1 takes 3 clock cycles.
<p>This is a problem for cryptography code; if each instruction takes time depending on the input data, then there's a timing side-channel opened up, where the exact values of the input data (plaintext, key, encrypted bytes) affect the runtime of the cryptographic algorithm. It's <em>not</em> a problem for most code, since we don't usually go to considerable effort to avoid any timing variance in running the code - we let branch predictors, caches etc all change the runtime based on the input data.



      
          <div class="CommentReplyButton">
            <form action="/Articles/922383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 0:17 UTC (Sat)
                               by <b>wujj123456</b> (subscriber, #84680)
                              [<a href="/Articles/922179/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Insecure by default" kinda has one's opinion baked in already. "Slow by default" likely wouldn't impress users either. At the end of the day, it really comes down to a balance and I supposed this one is particularly hard given the unknown future regressions. On the other hand, I believe arch specific defaults aren't new. Perhaps the answer would be clear once we have benchmark results.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor922156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 18:22 UTC (Fri)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/922156/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This discussion feels strange; my code (which is not cryptographic) does not become more secure by having x * 7 be just as slow as x * 777777777. That's really what's being discussed here, no?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 18:55 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/922162/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It already is today (apparently). It's more like future processors may now get a different timing because they're going to see `x * 7` and instead do `(x &lt;&lt; 3) - x` at the hardware level (or whatever).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 20:11 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/922168/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>A relatively recent survey of the topic is https://www.bearssl.org/constanttime.html Regarding multiplication they say,</p>

<blockquote>
Multiplications might be a problem in older systems. This one is very irksome: in almost all recent CPU designs, multiplications are constant-time, but some older CPU may have shortcuts that make multiplications faster when operands are small. In the Intel x86 line, the 80486 had a variable-time multiplication, while the Pentium has constant-time multiplication. One of the most recent yet significant CPU designs with variable-time multiplication is the ARM9.
</blockquote>



      
          <div class="CommentReplyButton">
            <form action="/Articles/922168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor922182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 0:17 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922182/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If your password was 777777777 and this was an important step in checking it, then the difference in execution time would definitely help an attacker guess it.<br>
<p>
The classical example is in password string comparison. Bailing out when you hit the first wrong character allows an attacker to guess your password one character at a time, which is very easy and fast to do. The same logic applies to virtually all secret-handling code in one way or another. You cannot allow the values being computed to affect the timing, or observing the timing will tell you the secret values.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 7:44 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/922199/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's fine, but 99% of my time isn't spent doing password checking of cryptography. And many places _even_ when doing crypto, it doesn't even matter; e.g. dm-crypt or my local password manager can leak as much timing it wants when decrypting my passwords, the only observer is me anyway (an external party cannot trigger testing of a given password, nor really observe how long it takes to test it).<br>
<p>
If you want to write code that doesn't leak timing information, you need to first make sure it doesn't branch, then that it doesn't reference memory, and only _then_ can you start worrying about things like non-constant multiplication. (Insert “…depending on secret information” if you want to nitpick.) The places that have these kinds of demands are already pretty closely marked up, and that's where you should enable DOITM. Not universally across your entire machine; that makes no sense, as most code isn't written to that kind of standard in the first place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922202"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 9:58 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/922202/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; That's fine, but 99% of my time isn't spent doing password checking of cryptography. And many places _even_ when doing crypto, it doesn't even matter; e.g. dm-crypt or my local password manager can leak as much timing it wants when decrypting my passwords, the only observer is me anyway (an external party cannot trigger testing of a given password, nor really observe how long it takes to test it).</span><br>
<p>
Are you really sure with the only observer thing? The timing of dm-crypt (and the AES especially) can be observed by anyone (and any piece of code) that is able to trigger writes to the filesystem. I would not really be surprised if this could be even observed from javascript when using client local storage. Ok, the noise will be horrible, but spectre like attacks have already been shown to work in principal from javascript. <br>
<p>
And the timing it takes to check a private key for ssh authentication can be easily observed from anyone on a local network.<br>
<p>
And 99% of the time, the computer is probably waiting for the slow user to hit the next key. It is also only a small fraction of software that really depends on the last bit of processing power, just as it is only a small fraction of code that depends on constant timing behaviour.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922202/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 11:42 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/922209/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And 99% of the time, the computer is probably waiting for the slow user to hit the next key. It is also only a small fraction of software that really depends on the last bit of processing power, just as it is only a small fraction of code that depends on constant timing behaviour.</span><br>
<p>
As someone who spends most of my day waiting for computers, I beg to differ. :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922216"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 17:46 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922216/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
:-)<br>
<p>
The problem is, is the computer working (a lot of the time it is), is it waiting for the user (not often), or is it waiting for the Snoracle server (in my case, yes a lot of the time).<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922216/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922217"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 18:47 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/922217/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So do you think the Oracle server you are waiting for should be default DOITM on or off?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922217/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 19:15 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922222/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Scrapped, and replaced with a real database like MultiValue :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 13:56 UTC (Mon)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/922312/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not nice to avoid a question like this.<br>
<p>
You should have either responded or not responded.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 18:51 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922160/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Half of this is probably just being aware of these problems ...<br>
<p>
If I didn't have constant-time instructions, I'd probably do something like sticking a guard hash in front of it. That's roughly constant time, requires an exact match to get past, and only then does the actual comparison.<br>
<p>
I doubt that's perfect, but it would certainly make attacks harder / take longer.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2023 21:42 UTC (Fri)
                               by <b>runekock</b> (subscriber, #50229)
                              [<a href="/Articles/922175/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know what a guard hash is, but I would think that a good solution often is to use a timer to delay to the worst-case time. Then you don't have to make your algorithms constant-time, which seem like a hard problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 0:35 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/922181/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think in practice it's the opposite: dynamic padding and delay loops are brittle and invariably broken without comprehensive compiler and OS support and augmentation. They don't and can't address exposure to, e.g., cache or power side-channels. So in the absence of constant-time ops you still need mitigations like page coloring, which require extensive support from the environment. See, e.g., <a href="https://arxiv.org/pdf/1506.00189.pdf">https://arxiv.org/pdf/1506.00189.pdf</a><br>
<p>
By contrast, constant-time operations not only solve the immediate problem of pacing your algorithm's logical operations, they implicitly address some of the trickier aspects of other side channels even when they don't make promises regarding, e.g., cache bypassing. That still leaves you with some work to do (e.g. removing conditional data dependencies), but now the problem is far more tractable *and* can be solved locally, without depending on the rest of the software stack and environment to implement complex mechanisms that for the most part still only exist in the literature and a few research systems.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 4:00 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922197/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I think in practice it's the opposite: dynamic padding and delay loops are brittle and invariably broken without comprehensive compiler and OS support and augmentation. </span><br>
<p>
And also disabling most of the IPC-improving advancements of the past few decades.  Like, oh, use of caches or branch prediction of any sort.<br>
<p>
That's not something you'd ever want to do globally or even by default, but it makes sense to disable it for the tiny handful of specific applications where true constant time actually matters.  Or just farm those specific operations off to a dedicated coprocessor.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor922203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 10:04 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922203/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I don't know what a guard hash is, but I would think that a good solution often is to use a timer to delay to the worst-case time. Then you don't have to make your algorithms constant-time, which seem like a hard problem.</span><br>
<p>
A guard hash is approximately constant time, which eliminates 99% of wrong attempts.<br>
<p>
Let's say your password is 16 chars. That's two int-32s. XOR the password and the password attempt together to give you two int-32s. Add them together. If the result isn't 0, the password is wrong (if I've got my maths right. It might be -1. Whatever. All correct passwords will give the same value). That's pretty much constant time, they've got a 1 in 4 billion chance of getting past it, and THEN you do the real password comparison.<br>
<p>
Chances are, if they get past the guard, they've already cracked the password. I'm sure someone will spot weaknesses in this, it's not meant to be foolproof, but it is meant to jack the cost up sharply.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922206"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 11:14 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922206/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A sufficiently clever compiler or CPU could recognise that your function will return exactly the same result if it deletes your XOR checks and only does the 'real' comparison. If you can trust that your compiler/CPU *won't* do that, then you can simply implement the entire comparison using XOR and no data-dependent branches, which is the standard way of implementing a constant-time comparison function - e.g. <a href="https://github.com/openssl/openssl/blob/323c47532ea7fc79d5e28a0fa58ea0cc4d5196b8/crypto/cpuid.c#L175-L195">https://github.com/openssl/openssl/blob/323c47532ea7fc79d...</a> (though they also have an assembly version to reduce the risk of compiler trickery: <a href="https://github.com/openssl/openssl/blob/323c47532ea7fc79d5e28a0fa58ea0cc4d5196b8/crypto/x86_64cpuid.pl#L281-L311">https://github.com/openssl/openssl/blob/323c47532ea7fc79d...</a>). There's no need to reinvent the wheel but worse.<br>
<p>
Constant-time comparison is the most trivial case anyway - it's far more interesting when you need e.g. constant-time elliptic curve scalar multiplication (<a href="https://minerva.crocs.fi.muni.cz/">https://minerva.crocs.fi.muni.cz/</a>). And even more interesting when you need protection against physical attacks (on smart cards etc), where an attacker can precisely measure the current going into the chip, so it has to be not just constant time but also constant power.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922206/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 16:27 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922215/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; it's far more interesting when you need e.g. constant-time elliptic curve scalar multiplication</span><br>
<p>
That's well out of my depth, but could you put a "constant time" guard in front of that? Anything that can eliminate most incorrect passwords in constant time before the real checks, instantly adds a hash-collision problem to the list of obstructions facing an attacker.<br>
<p>
Even storing the int_16 sum of all the bytes of a pass-phrase, and then rejecting if that fails, should surely increase the protection pretty heavily?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 2:35 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/922233/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If we're talking about "elliptic curve" anything, we're *well* out of the realm of "compare two passwords to see if they are the same." That's more along the line of generalized cryptographic primitives. There is no password. Instead, we have keying material, ciphertext, and/or plaintext, and we might also have key-exchange logic (like Diffie-Hellman, but with newer math), or the like. You absolutely cannot "just" fiddle with the protocol without consulting a team of expert cryptographers, who will promptly tell you that an attacker with a bit of string and a few bitwise XORs can trivially crack your entire implementation, because cryptography is hard and unforgiving like that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 9:57 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922246/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Except I'm NOT fiddling with the protocol AT ALL.<br>
<p>
All I'm asking is "is their a simple guard that will reject a large proportion of wrong attempts in constant time". Or am I wrong in assuming the attacker is in control of the "password" being fed in?<br>
<p>
The whole point of such a guard would be to tamper with any timing attacks, adding noise to fool an attacker into thinking a successful step has failed (or vice versa). Especially if the guard added jitter approximately equal to the last ten or twenty attacks that passed the guard ...<br>
<p>
So an attacker now has to worry about whether the attack should have succeeded in retrieving another character if it weren't for the guard, or whether the guard has made a failed attack look like it did successfully retrieve a character.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 10:10 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922249/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no password. <a href="https://minerva.crocs.fi.muni.cz/">https://minerva.crocs.fi.muni.cz/</a> is about signature generation algorithms leaking information which can be used to recover their private key.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 11:16 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks. Way over my head, but interesting ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor922286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 0:34 UTC (Mon)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/922286/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You would use a constant-time version of memcmp. OpenBSD added timingsafe_bcmp in 2009, and then timingsafe_memcmp a few years later. (<a href="https://man.openbsd.org/timingsafe_memcmp.3">https://man.openbsd.org/timingsafe_memcmp.3</a>) NetBSD has consttime_memequal. (<a href="https://man.netbsd.org/consttime_memequal.3">https://man.netbsd.org/consttime_memequal.3</a>) Apple and FreeBSD adopted the OpenBSD routines.<br>
<p>
I don't think either glibc or musl libc have adopted a similar interface. So on Linux or for portable software you'd probably want to use CRYPTO_memcmp from OpenSSL.<br>
<p>
You should of course be hashing the passwords with salts, and only comparing those hashes. In which case using a constant-time compare isn't that important as the attacker can't work backward from the short-circuiting compare to decipher the plaintext input. The hashing itself should be constant-time, assuming modern digests like SHA-256 or SHA-3, though it's possible the *length* of the input password would leak. But there are a gazillion ways for the length to leak, and when it comes to password-based authentication schemes that's the least of your worries.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 7:29 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/922289/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; All I'm asking is "is their a simple guard that will reject a large proportion of wrong attempts in constant time". Or am I wrong in assuming the attacker is in control of the "password" being fed in?</span><br>
<p>
You've just added another method to leak out information: attempts which get past this "guard" are "similar" to the real thing in some way (depending on the constant time algorithm involved). I feel like this is the case of layering invalidating cryptographic analysis of code (e.g., CRIME being one example of extracting information by figuring out how some piece of attacker-controlled data in the out affects compression ratios: more compression -&gt; something is more compressible -&gt; more redundancy between the input and the surrounding context).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 18:01 UTC (Mon)
                               by <b>stressinduktion</b> (subscriber, #46452)
                              [<a href="/Articles/922380/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The whole point of such a guard would be to tamper with any timing attacks, adding noise to fool an attacker into thinking a successful step has failed (or vice versa). Especially if the guard added jitter approximately equal to the last ten or twenty attacks that passed the guard ...</span><br>
<p>
I don't think adding noise will help.<br>
<p>
Maybe this particular construction helps, haven't thought too deeply about it, but I find it curiously interesting:<br>
<p>
sleep(hmac(attacker-supplied-passwd, const-hmac-secret-per-app) % max-time)<br>
// check password...<br>
<p>
... making the delay depending on the attacker supplied input/password value, which should defeat statistical analysis? The sleep could be simply spinning in a tight loop for a while, not a full-blown syscall.<br>
<p>
I don't know the source of it anymore, would be happy if someone has pointers or maybe an analysis of this construct. Regarding key generation, I am not sure if this idea could be expanded to hash the generated keys.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922386"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 18:19 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922386/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No. This is just a pseudo random sleep, which is effectively as bad as random sleep.<br>
Adding noise does not remove the signal, if you have enough tries. It will always eventually filter out, because real noise is just a constant value on average.<br>
Your hash-algorithm is indistinguishable from real noise.<br>
<p>
The only way to remove a signal is to actually remove it. e.g. adding an amount of time so that the overall execution is always the same. Which effectively is just a constant-time algorithm.<br>
You could also make your algorithm always take one second by use of a monotonic timer that is started before your algorithm runs and waited for after the algorithm finished. But that's just over complicated and fragile (what if the attacker can make the algorithm runtime be &gt;1s?) compared to the usual constant time practices.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922386/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 19:50 UTC (Mon)
                               by <b>stressinduktion</b> (subscriber, #46452)
                              [<a href="/Articles/922393/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Adding noise does not remove the signal, if you have enough tries. It will always eventually filter out, because real noise is just a constant value on average.</span><br>
<p>
I actually found a reference [1] (section 4.3) from 2011.<br>
<p>
I think the argumentation was something like, that an attacker is not able to probe for the worst case execution time so easily and thus rendering the attack more difficult in practice.<br>
<p>
[1] <a href="https://www.researchgate.net/publication/336209882_An_Efficient_Mitigation_Method_for_Timing_Side_Channels_on_the_Web">https://www.researchgate.net/publication/336209882_An_Eff...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 20:20 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922395/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think adding an f(input) delay doesn't help when the attacker knows there will be correlation between many different inputs. In the password-comparison example, an attacker could try inputs from "a#000000" to "a#999999" and record the average time; every input is distinct so the delays are effectively random and are as vulnerable to statistical analysis as usual. Then try "b#000000" to "b#999999", etc up to "z", and whichever letter gives the lowest average is the first letter in the password. So the mitigation in that paper seems pretty useless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 11:29 UTC (Tue)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/922442/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>
Presumably a fairly obvious additional mitigation would be to prevent attackers from cheaply trying a million or more passwords in a row, e.g., by increasing the delay exponentially depending on the number of attempts.
</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/922442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 11:41 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/922443/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>If you can prevent attackers from cheaply trying a very large number of passwords, then statistical attacks don't work. But you can't rely on that - if I steal a copy of the underlying data store that your password validator depends upon, then in the extreme, I can set things up so that I run each attempt in parallel on a separate unique VM, so that I'm trying 1 million passwords on independent validators, each of which thinks this is my only password attempt ever.


      
          <div class="CommentReplyButton">
            <form action="/Articles/922443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922761"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 15:09 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922761/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That may help in some cases, but it introduces the problem of securely storing the attempt counter. E.g. the iPhone 5C has a passcode retry counter which triggers long delays after 5 failed attempts, and optionally wipes all data after 10 failed attempts, so that you can't brute force even a 4-digit passcode. The counter is reportedly stored in external NAND flash (presumably encrypted). It's possible to unsolder the NAND chip and connect it to a custom circuit, back up the contents, enter 6 invalid passcodes, then restore the contents and retry unlimited times. (<a href="https://arstechnica.com/information-technology/2016/09/iphone-5c-nand-mirroring-passcode-attack/">https://arstechnica.com/information-technology/2016/09/ip...</a>)<br>
<p>
That could be fixed by storing the counter in internal flash in a tamper-resistant security chip (which I presume is what Apple does nowadays), but that makes the hardware more complex and expensive (which I presume is why the iPhone 5C didn't do that).<br>
<p>
(The iPhone thing isn't a timing attack, the passcodes are short enough that you can brute force even without any side channels; it's just relevant here because it depends on a counter and delay for security.)<br>
<p>
Even in cases where you don't have to worry about attackers with physical access, you might need to worry that an attacker can e.g. trigger an otherwise-mostly-harmless crash bug to restart your service that's storing the attempt counter in RAM, and it resets to 0 and lets them defeat your timing attack mitigation. Of course you could implement a fix for that too; my point is that you're making your security dependent on an increasingly large and complex part of the whole system (hardware and software and policy). It's also dependent on your statistical analysis of the random jitter vs the cost of the algorithm you're trying to protect (though because you're trying to avoid using a constant-time algorithm, you don't even know its worst-/best-case costs, and it may change radically on newer CPUs and invalidate your assumptions), and on your choice of threshold for the probability of an attacker being able to break it.<br>
<p>
On the other hand, if you (or some library developers) implement a constant-time comparison function, and carefully verify the assembly code and the timing guarantees provided by your CPU architecture so you're confident it's really constant-time, then you're done. No counters to store securely, no statistical analysis, no risk of your boss complaining that he keeps getting locked out when he mistypes his password and someone removing the limit without noticing the security implications; and no timing attacks. That seems to me like such an obviously better and reasonably straightforward solution that I'm honestly quite confused why people here keep proposing using variable-time algorithms and adding random delays instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922761/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2023 19:09 UTC (Sun)
                               by <b>stressinduktion</b> (subscriber, #46452)
                              [<a href="/Articles/923095/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; That seems to me like such an obviously better and reasonably straightforward solution that I'm honestly quite confused why people here keep proposing using variable-time algorithms and adding random delays instead.</span><br>
<p>
In my case (and because this is an answer to my comment), there is absolutely no need to convince myself about using proper constant time implementations in crypto code. I just remembered above paper from somewhere and found it just to be a gimmick maybe interesting enough to post (and discuss) here.<br>
<p>
That said, I am still not convinced this idea can so easily be beaten compared to just a random delay *in the case of passwords*, because it is not just noise. I would myself not deploy it anywhere, given the clearly better options. For all other operations on cryptographic material it is obvious to me, that it absolutely should not be deployed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 0:19 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922183/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doesn't work. An attacker only needs to subtract the constant time of the hash guard from their total observed time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick hash</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 10:09 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922205/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And then, for 3,999,999,999 attempts out of four billion, they get a time of 0. You can't get a meaningful statistical analysis analysing a string of zeros.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor922187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 0:33 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922187/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You would think that nobody at intel is thinking anything through when they are coming up with optimizations like these.<br>
<p>
This optimization must *obviously* be opt-in, for all the reasons stated above. It it simply not feasible to identify every place that should be protected, for any of several reasons. And yet, they push it as if it is everyone else's problem to pick up the slack and to that analysis work for 30+ years of software.<br>
<p>
The obvious course of events is as follows:<br>
- The kernel enables constant-time for both itself and userspace unconditionally, allowing opt-in to the optimizations either at boot or per-thread<br>
- Intel either<br>
A) reads the writing on the wall and makes it cheaper to *opt into* the optimization where safe (accepting safety as the default) or<br>
B) continues the current path, with everyone seeing slower performance growth in intel processors, while AMD etc focus on other areas<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 1:00 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922190/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it were up to me, I'd land a patch unconditionally turning these optimizations off (except maybe with mitigations=off) and backport it to all the currently supported kernels so that the intel CPUs *already in the field* that do this can get the security fix.<br>
<p>
Then look at whether this can be enabled on a per-thread basis, and backport that work if it makes sense to do so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 4:19 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922198/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And yet, they push it as if it is everyone else's problem to pick up the slack and to that analysis work for 30+ years of software.</span><br>
<p>
Yet somehow you feel the correct outcome is to punish everyone else's software instead.  (which outnumbers the former by several orders of magnitude!)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 9:43 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/922201/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Yet somehow you feel the correct outcome is to punish everyone else's software instead. (which outnumbers the former by several orders of magnitude!)</span><br>
<p>
You cannot punish software. Software is not self-aware (at least not yet). So you should not speak about software, but about users. So given the choice, how many users prefer a few extra percent of speed if they have to compromise the security of their home banking? And if you really prefer speed, nobody will stop you from disabling this switch.<br>
<p>
Also I strongly disbelieve in the several orders of magnitude. That would be at least a factor of 100 (only two orders of magnitude). In fact, for most existing software, there will not be a difference at all, as they neither need constant time execution nor the absolute maximal processing power of the newest hardware designs.<br>
<p>
However a change that makes existing software vulnerable to timing attacks is a clear regression, while existing software will most probably be fine with the processing power of future processor generations, even with the constant timing enabled. They will be much faster than the hardware the software runs on now, anyway.<br>
<p>
And for future software, this should be a non-issue, as the programmers will be aware of the switch and should be able to actively choose the mode.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 11:40 UTC (Sat)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/922208/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; So given the choice, how many users prefer a few extra percent of speed if they have to compromise the security of their home banking?</span><br>
<p>
Prior to making such heavy-handed analogies, could you please show that home banking (which happens inside of heavily sandboxed Javascript VMs within browsers) would _actually_ be affected?<br>
<p>
Otherwise this just reeks of "think of the children".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 12:11 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/922210/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since when does SSL encryption happen inside a Javascript VM? <br>
<p>
Also timing side channels are the things that usually go through all layers of virtualization. Spectre attacks against the kernel have been demonstrated even from within a Javascript VM. Not really the easiest thing to exploit. But using some correlation between several runs this is possible. Sandboxing does not help against timing attacks. It can make exploitation a bit harder, but that is all.<br>
<p>
The constant timing mode is designed especially to allow secure cryptography and mitigate possible attacks against cryptography. I cannot predict the future ans say which algorithm/software will be attacked this way. But home banking is sure a worthwhile target for the attackers. And it is secured by exactly those algorithms that rely on constant timing behavior of processors in order to preserve the secrecy of the keys.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2023 19:06 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/922219/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Since when does SSL encryption happen inside a Javascript VM?</span><br>
<p>
TLS encryption happens in browsers, of which there are two relevant browser engines on Linux, both having security teams perfectly capable of flipping such a mode when relevant, and whose users run them almost exclusively on the newest stable version.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 3:21 UTC (Sun)
                               by <b>stressinduktion</b> (subscriber, #46452)
                              [<a href="/Articles/922236/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  TLS encryption happens in browsers, of which there are two relevant browser engines on Linux, both having security teams perfectly capable of flipping such a mode when relevant, and whose users run them almost exclusively on the newest stable version.</span><br>
<p>
From reading the article, I understand Intel's design as a switch per process/address-space (either syscall or prctl) to toggle the privileged MSR of the process. Given the open ended coded nature and "leaking" of cryptographic primitives into the code which makes use of it (create crypto object; &lt;other code;&gt; update; &lt;other code;&gt; update; &lt;o.c.&gt; final), this seems hard to do in practice for a cryptographic library without performance tanking due to the additional syscalls. If you try to pair the "DOITM syscalls" to cover longer runs of crypto code, one must implement some kind of counting of how many overlapping cryptographic operations are currently going on...<br>
<p>
My guess is that browsers will enable DOITM on Intel anyway (different story for ARM, which feels more sensible designed in this regard).<br>
<p>
Also, I would prefer to plug a disk with an older distro with apache+openssl into a new server and have it not be vulnerable immediately. It sounds doable, maybe a flag being used during ELF image activation or whatever?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 5:45 UTC (Sun)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/922241/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Browsers don't seem like the best use case for "give me more *numeric operation* performance"; HPC is. Video decoding happens in dedicated hardware, graphics happens in dedicated hardware, a bit more *numeric* performance won't make or break your browser.<br>
<p>
But if you can toggle a setting and your HPC applications get 5% more performance, or maybe a lot more than that in the future? That seems like a selling point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 23:09 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/922281/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Browsers (including their associated JavaScript engines) use hash tables intensely, and those frequently use a lot of multiplications and divisions/modulo operations. DOITM is not about floating-point operations, which is what HPC is dealing with, it's about integer muls and divs. (And probably eventually also other instructions.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 3:46 UTC (Sun)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/922240/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The punishment at this point is essentially non-existent...<br>
<p>
...while the damage that can occur from failing to write constant-time code is extensively demonstrated, documented, and painfully remembered.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor922231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 1:48 UTC (Sun)
                               by <b>kunitz</b> (subscriber, #3965)
                              [<a href="/Articles/922231/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I just read the article about timing attacks on Wikipedia. One attack was against RSA and the other against crypt providing info about available user names. Nothing there convinces me to enable  DOITM for the whole kernel.  You might want to to enable DOITM in kernel crypto code and provide a facility for enabling/disabling it in user space, but why does it need to be enabled for the whole kernel? What is the threat model behind the requirement?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 7:48 UTC (Sun)
                               by <b>Tov</b> (subscriber, #61080)
                              [<a href="/Articles/922242/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
nchars = max(strlen(attempt), strlen(password));<br>
<p>
That is probably a bit too naively coded. You loop for the number of characters in the _longest_ string and then beyond the length of the shorter... <br>
<p>
C is just hard to get right :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 8:18 UTC (Sun)
                               by <b>zaitseff</b> (subscriber, #851)
                              [<a href="/Articles/922244/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>As in, shouldn't it be <tt>nchars = min(strlen(attempt), strlen(password)) + 1</tt>?  <tt>:-)</tt>.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/922244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 9:08 UTC (Sun)
                               by <b>Tov</b> (subscriber, #61080)
                              [<a href="/Articles/922247/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, that would ensure the lengths of the strings are equal, since you then also test the terminating 0. However, that is a bit subtle and a comment would be in place :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 12:06 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/922251/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And thus we are reminded why no serious string handling should be done using libc's string functions :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor922248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 10:00 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922248/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the code is fine because the strings are null-terminated. If the strings are different lengths, the loop will eventually read '\0' from the shorter and non-'\0' from the longer and will return false; it won't continue to read past the end of the shorter string.<br>
<p>
(Well, "fine" to the extent that any C string handling code can be fine, i.e. you have to think about it quite carefully to make sure there aren't terrible bugs in even the simplest operations.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 12:45 UTC (Sun)
                               by <b>Tov</b> (subscriber, #61080)
                              [<a href="/Articles/922253/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hah! Good point :-)<br>
<p>
However, it still leaves me wondering: Is the code subtly clever or just correct by accident? A comment would have been in order.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Terminating at NUL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 16:58 UTC (Sun)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/922264/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The loop obviously depends on the NUL at the end of the shorter string terminating the loop; that was intentional behavior and, I thought, not particularly subtle. Perhaps I'm showing that I learned C in the early 80's, when such code was commonplace.




      
          <div class="CommentReplyButton">
            <form action="/Articles/922264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor922256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Looks like a bad hardware design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 14:22 UTC (Sun)
                               by <b>david.a.wheeler</b> (subscriber, #72896)
                              [<a href="/Articles/922256/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This looks like a bad hardware design.<br>
<p>
Timing sensitivity should be part of the thread state that is quietly saved and restored when you switch to a thread, and easily enabled or disabled by a normal thread. If a thread turns it on to go slow, that is the thread's problem... it could also just run a slow algorithm, right?<br>
<p>
What am I missing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Looks like a bad hardware design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2023 15:06 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922259/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; This looks like a bad hardware design.</span><br>
<span class="QuotedText">&gt; What am I missing?</span><br>
<p>
My understanding is that Intel's implementation is intended to work in the way you described; ie a thread declares itself to be timing sensitive (eg via a one-off syscall that sets an appropriate flag in the thread state) and the kernel manages switching in and out when that thread is scheduled.<br>
<p>
It also seems that the intent is for these timing-sensitive threads be as focused/isolated as possible, which is the direction that security-concious software has been taking for some time now as to shrink its attack surface.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor922293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 8:30 UTC (Mon)
                               by <b>ale2018</b> (guest, #128727)
                              [<a href="/Articles/922293/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But why do we counter timing attacks by slowing CPUs to constant time execution?  It is obvious from the password comparison example that, as many observed, if the algorithm is not designed to avoid these attacks, slowing the CPU is useless.<br>
<p>
Rather than modifying old code, it seems much better to add a random tarpit whenever the authentication fails.  Adding a line after the algorithm call is easy and safe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 9:56 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922298/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But why do we counter timing attacks by slowing CPUs to constant time execution?</span><br>
<p>
Because, as others have noted, constant time is a pre-requisite for security.<br>
<p>
<span class="QuotedText">&gt; if the algorithm is not designed to avoid these attacks, slowing the CPU is useless.</span><br>
<p>
And constant-time is a pre-requisite for ANY successful defence against timing attacks. Adding random (or not so random) jitter just makes the attacker's life harder, it can't stop a timing attack.<br>
<p>
That was the idea behind my "hash guard" - it hides the signal behind a massive amount of noise. But constant time is the only way to destroy the signal.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922296"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 9:57 UTC (Mon)
                               by <b>marcel.oliver</b> (subscriber, #5441)
                              [<a href="/Articles/922296/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was just about to post a similar comment... I am not at all an expert in this area, but reading throught the article+comments, it appears that trying to achieve constant-time execution is a game of whack-a-mole.  It involves assumptions about the microarchitecture that are ultimately outside of the control of the programmer and may change arbitrarily with any new piece of hardware.<br>
<p>
Why not think about this in a fundamentally probabilistic manner?  The cryptographic code just needs to produce enough random jitter so the the noise/signal ratio is large enough it does not matter.  E.g. by weaving some unrelated computation, such as mixing an uncorrelated stream of data into a RNG entropy pool, into or close to the inner loop of the cryptographic code.   This could be measured at startup time, where some timing tests would determine the timing jitter of repeated invocations with known data (good) vs. the timing differences between different data streams (bad), then compute a noise/signal ratio large enough to mask the latter.  If it's carefully tuned, it should not be worse than forcing constant (thus slowest-case) timing for all operations, but could also adapt to the level of paranoia (e.g. is this a scenario where an attacker controls the data, or do I only need to defend against passive observers, how valuable an asset am I trying to protect, etc.).  <br>
<p>
I understand that this does not solve the problem with legacy code, but moving into the future this appears more safe and more flexible, especially given that hardware optimizations of this kind are likely the primary strategy to squeeze more performance out of existing architectures.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922296/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922303"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 11:31 UTC (Mon)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/922303/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This totally ignores that cryptographic code is performance critical. There is the trend to encrypt all storage (disk encryption) and all communications (tls). Making this much slower in order to defeat a possible attack vector that just exists because of some optimizations that make hardware a bit faster seems kind of backwards.<br>
<p>
It is not just the login procedure that would be slowed down by a fraction of a second. It is every disk access, all network communication and possibly a lot more that would be impacted. And to defeat the possible correlation of several tries, you need to add quite a lot of noise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922303/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 11:47 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922305/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;This totally ignores that cryptographic code is performance critical. There is the trend to encrypt all storage</span><br>
<span class="QuotedText">&gt;(disk encryption) and all communications (tls). Making this much slower in order to defeat a possible attack</span><br>
<span class="QuotedText">&gt;vector that just exists because of some optimizations that make hardware a bit faster seems kind of backwards.</span><br>
<p>
Disabling the technology from the article is not about making crypto slower.<br>
It's about not making certain parts of crypto faster (by making them non-const time).<br>
<p>
<span class="QuotedText">&gt;It is every disk access, all network communication and possibly a lot more that would be impacted.</span><br>
<p>
What attack vector do you see for disk encryption?<br>
Yes, maybe you could extract a tiny part of the cipher's lowest level key stream by injecting data patterns and measuring the encryption times.<br>
But where do you go from there?<br>
How do you compromise the master key? How do you decrypt more data then what already have access to?<br>
<p>
Could we please first have a plausible explanation about wide ranging or universal attack vectors, before we degrade performance for everybody by disabling this feature?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922307"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 12:14 UTC (Mon)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/922307/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Disabling the technology from the article is not about making crypto slower. It's about not making certain parts of crypto faster (by making them non-const time).</span><br>
<p>
Have you even looked at the comment, which I have replied to? This was about making crypto much slower in order to mitigate the security implications of the technology described in the article.<br>
<p>
<span class="QuotedText">&gt; Could we please first have a plausible explanation about wide ranging or universal attack vectors, before we degrade performance for everybody by disabling this feature?</span><br>
<p>
It might be too late if we wait for exploits. The possible attack vectors are clear. Whether they can actually be exploited is not so clear. However, the bad guys are usually quite creative when it comes to exploiting weaknesses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922307/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 12:20 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;This was about making crypto much slower in order to mitigate the security implications of the</span><br>
<span class="QuotedText">&gt;technology described in the article.</span><br>
<p>
Ok.<br>
I misunderstood then.<br>
Making it even slower than it is without this optimization obviously is a stupid idea.<br>
<p>
<span class="QuotedText">&gt;It might be too late if we wait for exploits.</span><br>
<p>
You should immediately shut down your PC, because there are most likely open security vulnerabilities.<br>
It might be too late, if we wait for exploits.<br>
<p>
<span class="QuotedText">&gt;The possible attack vectors are clear.</span><br>
<p>
Not to me. Could you explain?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 18:11 UTC (Mon)
                               by <b>lurk546</b> (guest, #17438)
                              [<a href="/Articles/922385/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As some one else commented, it's about a lot more than just crypto. The devil's always in the details, and in my opinion no one knows all the details about what all needs to be protected, or how bad the upcoming vulnerabilities are going to be. We just know that the timing of some operations are going to be more dependent on the data being processed. <br>
<p>
Browser session cookies are likely one of many examples showing it's not just about the crypto. You can argue that one really shouldn't try to do anything secure in a browser that runs code from external websites, but it's commonly done.<br>
<p>
I think it's much easier to identify and mark areas where things don't need to be secure (such as HPC), than where things might need to be secure. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 19:00 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922390/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;Browser session cookies are likely one of many examples showing it's not just about the crypto</span><br>
<p>
Can you please explain how such an attack using the cpu feature from the article would look like?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 21:03 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/922397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's pretty much only about crypto, and not about anything else. In particular, nothing else has taken the time and effort to identify a timing side channel and close it on any assumptions whatsoever.
<p>The crypto case is special because the cryptography community has gone to some effort to ensure that the time taken to perform primitive cryptography operations is independent of the key - and thus that an attacker in possession of a machine that will convert an attacker-supplied plaintext into a ciphertext cannot use that machine to learn the key - the best you can do with the machine is brute-force to find a matching plaintext for a supplied ciphertext or vice-versa.
<p>It's also worth noting that the goal of constant-time cryptographic operations is not to prevent all information leakage; rather, it's to prevent the attacker from acquiring new information that they did not possess before they attempted their attack. If you have a machine that will say "yes, that is the correct password" or "no, that is the wrong password", then it's fine for it to take time varying with the password you supply it - it is <em>not</em> fine for it to take time varying with the password it's checking against.
<p>The problem is that, absent DOIT mode, there will be no way to have any operations take constant time regardless of the value of the operands. This is a problem if you're trying to build a system whose time taken does not vary with the value of the key; if all operand values can make the time taken vary, then you can't avoid a timing side channel that reveals information about the key. DOITM fixes this, by allowing you to go into a special mode that forces ALU operations to take constant time, instead of going faster if the values are in certain ranges; you can then use this special mode when doing operations involving the key (or data derived from the key), so that the timing of operations is not correlated with the value of the key.


      
          <div class="CommentReplyButton">
            <form action="/Articles/922397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 22:56 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/922407/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The devil's always in the details, and in my opinion no one knows all the details about what all needs to be protected, or how bad the upcoming vulnerabilities are going to be. We just know that the timing of some operations are going to be more dependent on the data being processed.</span><br>
<p>
Why are you talking about “upcoming vulnerabilities”? It's documented on Intel's pages which instructions' timings are based on the DOIT mode (<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html">https://www.intel.com/content/www/us/en/developer/article...</a>); they are all integer multiplication instructions except for VPLZCNT*. This isn't some embargoed CPU vulnerability where we don't know what's ahead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 0:32 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/922408/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As an aside, you linked the list of instructions that might have data-dependent timing even in DOIT mode if MXCSR is set to the "wrong" value - <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/resources/data-operand-independent-timing-instructions.html">https://www.intel.com/content/www/us/en/developer/article...</a> lists all the instructions where Intel might have data-dependent timings if DOIT mode is not enabled, and it includes some you wouldn't expect, like AESENC and AESDEC.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 9:01 UTC (Tue)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/922430/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're reading the table backwards.<br>
<p>
The table "Documented Data Operand Independent Timing Instructions" if the "MCDT" column is false means that switching the MXCSR in question does NOT change the timing, meaning they're DOIT regardless.<br>
<p>
That's a table of every single instruction they could list, with an explicit "does DOIT matter?" column. Only the parallel multiplies and leading-zero-count instructions are currently subject to DOIT.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922435"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 9:45 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922435/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The table "Documented Data Operand Independent Timing Instructions" if the "MCDT" column is false means that switching the MXCSR in question does NOT change the timing, meaning they're DOIT regardless.</span><br>
<p>
I believe you're reading it wrong too. MXCSR is not the main DOIT flag; it's more of an erratum that you should be aware of (but might choose to ignore because it's quite minor) when you're trying to get data-independent timing.<br>
<p>
If you set IA32_UARCH_MISC_CTL[DOITM]=1, then the instructions in that table with MCDT=False will be data-independent on all CPUs.<br>
<p>
If you set IA32_UARCH_MISC_CTL[DOITM]=1, and either your CPU is new enough to have CPUID.(EAX=7H,ECX=2):EDX[5]=1 or it's one of the older CPUs listed by Intel or you set MXCSR=0x1fbf, then all the instructions in that table will be data-independent.<br>
<p>
<span class="QuotedText">&gt; That's a table of every single instruction they could list</span><br>
<p>
It's not - it's missing loads of instructions, notably any DIVs as well anything floating-point, plus a bunch of miscellaneous ones like BSR and BSWAP etc. For anything not in that table, Intel is making no guarantees about its timing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922435/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor922411"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 0:47 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922411/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you're reading that page wrong. The instructions listed under "Instructions That May Exhibit MCDT [MXCSR Configuration Dependent Timing] Behavior" (which are almost all vector integer multiplies) aren't the instructions that are affected by DOIT. Those are the instructions that may have (very slightly) data-dependent timing on certain CPUs even when DOIT is enabled. (That can be mitigated by modifying MXCSR to set a bunch of SSE status flags, for unclear reasons.)<br>
<p>
There's a separate list of the instructions which are guaranteed to be data-independent under DOIT: <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/resources/data-operand-independent-timing-instructions.html">https://www.intel.com/content/www/us/en/developer/article...</a><br>
<p>
As far as I can see, there's no list of instructions which are known to be *not* data-independent without DOIT. Intel wants you to assume that all instructions may be data-dependent if you don't enable DOIT, plus all instructions not on that list even if you enable do DOIT - that still doesn't imply they are, just that Intel doesn't want to constrain all their future CPUs and/or doesn't want to verify all their old CPUs in order to provide any wider guarantees.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922411/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 4:35 UTC (Tue)
                               by <b>draco</b> (subscriber, #1792)
                              [<a href="/Articles/922417/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you're right about that, then I feel like our computing infrastructure (compilers, now processors) developers have lost the plot in their chase for performance.<br>
<p>
If we ignore security in the name of performance, then attackers will take over our computers to run their software instead! Now our performance is **zero**, because our computers are no longer doing what we bought them to do!!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 10:58 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/922440/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>This is the opposite of ignoring security in the name of performance; CPUs have always had data-dependent optimizations (e.g. the variable time multiplies in the 8086 and 68000), which means in turn that it's never been the case that CPUs don't have timing side channels. However, cryptographers have found that by using a subset of operations, you can write code whose timing is not dependent on the value of the cryptographic key; this allows you to close the timing side channel that could be used to deduce the key given enough operations.
<p>Historically, this has been done on an ad-hoc basis; measure the CPU's behaviour, producing something like <a href="https://www.agner.org/optimize/">Agner Fog's instruction timing information</a>. With this information in hand, you can carefully choose operations whose timing is not correlated with information an attacker does not have; note, though, that if Agner has made a mistake putting together their tables, or when a new CPU comes out, you can have picked instructions that are not constant time for a given input source. Thus, every time a new CPU comes out, or whenever someone alleges that you've made a bad choice, you have to recheck everything in painstaking detail, since you're reverse-engineering the CPU's behaviour.
<p>DOITM changes things round - it says that there's an architectural guarantee that certain instructions will execute in constant time relative to some or all of their inputs. As long as you run in this mode, and use only the instructions that are specified as safe, you have a guarantee that not only is your code not vulnerable to timing side channels on current CPUs, but that it will also not be vulnerable on future CPUs - Intel will make sure that DOIT mode does the right thing.




      
          <div class="CommentReplyButton">
            <form action="/Articles/922440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2023 12:17 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922308/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why not think about this in a fundamentally probabilistic manner? The cryptographic code just needs to produce enough random jitter so the the noise/signal ratio is large enough it does not matter.</span><br>
<p>
I think the fundamental problem is that the attacker can repeat the computation many millions of times, and can use statistics against you. (Or at least the cryptographic primitives should assume they can, because the system would be unpleasantly fragile if the security of low-level operations was heavily dependent on high-level rate limiting etc. Modern cryptographic primitives seem to focus increasingly on robustness, because experience shows they can't rely on their users to meet any subtle security requirements; e.g. modern hashes tend to be inherently immune to length extension attacks because they know people won't pad their inputs properly.)<br>
<p>
Say your password comparison function takes 100ns if the nth character is incorrect, or 110ns if the nth character is correct, and then you add some random jitter with distribution N(μ, σ^2). If the attacker takes the average of a million measurements, then the averaged jitter will be N(μ, (σ/1000)^2), and you need to ensure σ/1000 is several times greater than the signal (10ns) to maintain a low SNR, so your jitter is &gt;100x more expensive than the actual computation. And it can still be easily broken if the attacker can do a hundred million measurements.<br>
<p>
These numbers are all made up, but (unless I'm calculating very wrong) they indicate the scale of the problem. The constant-time whack-a-mole approach isn't great but it's a lot more practical when performance matters, and it depends on relatively easily testable assumptions about the hardware rather than on assumptions about the security architecture of every system it's used in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 13:07 UTC (Thu)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/922701/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What if you make the random jitter deterministically calculated from the password and the attempt?  Like, wait an amount of time after each operation equal to the lower 8 bits of the SHA hash of "$PASSWORD+$ATTEMPT".  The value you get from that will be the same every time you try an attempt, but can't be correlated with that attempt unless you already have the password or have broken the encryption algorithm, which makes the whole problem moot. <br>
<p>
I suppose you could get around that by guessing loads of different passwords, and statistically associating the timing between them, but that makes the attack significantly more complicated.  Possibly even impossible if the time-dependent being blocked behavior requires that the attempts have a specific form to them.  And the more complex the inner loop of the timing attack needs to be (ie, generating lots of different attempts rather than trying the same one), the more likley that it will have data-dependent timing, which will in turn block it from spotting data-dependent timing of its own.<br>
<p>
Constant-time operations will obviously still be faster, but adding this delay as a step in any especially exposed timing observation points could make any incidental or minor data-dependent time behavior outside of the core algorithms unusable for attackers, and would protect against bugs in said constant-time code.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922712"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 14:44 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/922712/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds the same as <a href="https://lwn.net/Articles/922380/">https://lwn.net/Articles/922380/</a> , which (as discussed there) I think is useless for the password-comparison example - the attacker can just add a different suffix each.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922712/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 16:41 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/922714/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
 The value you get from that will be the same every time you try an attempt, but can't be correlated with that attempt unless you already have the password or have broken the encryption algorithm, which makes the whole problem moot. 
</blockquote>
<p>The problem is that the assumption under which constant time code is written is that the attacker knows everything but the secret key. So the attacker knows the algorithm in use, including the fact that your wait time is equal to the lower 8 bits of the SHA hash of "$PASSWORD+$ATTEMPT" - the only thing they don't know is $PASSWORD.
<p>They're then doing statistical analysis, where they know $ATTEMPT, and they're looking at the change in time it takes to run the algorithm; that change is correlated with $PASSWORD, and thus they can deduce $PASSWORD based on the different times it takes for an attempt.
<p>The threat model constant-time computation protects you against is an attacker who's stolen a copy of your password validation source code, and has managed to get the checker and password database into a restorable container - there's no way to do an attempt counter (because the attacker restores the container after each attempt, resetting the attempt counter), and the last line of defence is that the time taken to fail is purely a function of $ATTEMPT + NOISE, not of $ATTEMPT + $PASSWORD + NOISE. As soon as the time taken to fail an attempt is a function of $ATTEMPT + $PASSWORD + NOISE, the attacker can do statistical analyses that allow them to remove $ATTEMPT and NOISE, leaving only $PASSWORD in the data.


      
          <div class="CommentReplyButton">
            <form action="/Articles/922714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor923994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2023 22:42 UTC (Tue)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/923994/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It was my understanding that a hash could not be connected, even statistically, to its arguments: that even knowing SHA1($PASSWORD+$ATTEMPT), and being able to make arbitrary $ATTEMPTs, you still could not even constrain $PASSWORD to be more likley to have a 1 or a 0 as the first digit.<br>
<p>
Also, I thought constant-time was more about over-network attacks, where you don't have the (encrypted) password database: if you have the database, then any time dependence in the checker would need be derived from the encrypted passwords, since if the decrypted password is acquired at any point by the validation (a prerequisite for timing to depend on it), then the attacker can just... do that step to get the decrypted password.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor924027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2023 11:40 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/924027/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>While constant-time <em>is</em> about over the network attacks, the reason for defining the threat model as I defined it is  that this gives you a maximally sophisticated attacker - they have the source code, they have the hashed password database, they have control of the environment the password checker runs in. What they do <em>not</em> have is the decrypted password - and nor does the system that's validating passwords, since to do so, it has to have the password in plain text.
<p>As a result, I assumed that when you wrote $PASSWORD, you meant the hashed password, which the attacker <em>is</em> expected to possess, and not the user's plain text password. If you store the user's plain text password, then I can bypass the cryptography completely by stealing that instead.


      
          <div class="CommentReplyButton">
            <form action="/Articles/924027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor922422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Enough of de-optimizations!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 6:22 UTC (Tue)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/922422/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm really getting sick of all these attempts at ruining optimization efforts for everyone just because *some* users run in hostile environments.<br>
<p>
Originally "PC" meant "personal computer", i.e. you're alone on it, it's *your* PC, you do whatever you want with it.<br>
<p>
Nowadays there's always someone to tell you "be careful about speculation attacks which might allow someone in a concurrent VM on your machine to read your VM's memory" except I don't care about such a case, particularly when I'm developing and that my build time is essential to me, and I'm not running anything in a cloud (and no, I don't care either about the small risk of browser-induced timing attacks, there are so many more dramatic failures in a browser that these ones are rare).<br>
<p>
Likewise we used to hear "it's really time to disable hyperthreading". In fact cloud vendors took a smarter approach, they're always selling you the vCPUs by pairs so that you get both threads of the same core.<br>
<p>
And it seems that the new joke is going to be "please disable your CPU's optimizations, someone could possibly guess the private key you're generating". And what if I don't care because I'm not producing private keys all the day and instead am interesting in my CPU prefetching data faster and anticipating results to build faster ? In addition, while we're still having fun protecting ourselves against low-level attacks, the vast majority of malware continues to spread via the good old methods consisting in clueless users clicking links in HTML emails and starting infected executables that encrypt all their data... I definitely think we're trying hard to plug a tiny hole leaking water droplets next to the Niagara falls when it comes to end-user machines.<br>
<p>
I would prefer to have a global kernel parameter "ultra-secure" that turns on every protection for those running VMs in shared environments and that the vast majority of others don't care about. Maybe at one point they will figure that such environments have become so slow and insecure that it was a bad idea from the start to make sensitive code operate on private data on someone else's CPU and RAM, which is first and foremost the starting point of all of this...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922427"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Enough of de-optimizations!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2023 7:51 UTC (Tue)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922427/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very well said.<br>
<p>
And in addition to that I think people start to make up threat scenarios that are based on nothing.<br>
<p>
Oh look, there's your sensitive data! You wouldn't want that to come into control of the bad guys! Hurry up, disable $Feature system wide, before it's too late!<br>
<p>
That is just like snake oil selling.<br>
That is the same FUD mechanism that anti virus vendors use (successfully; as in their business) on Windows.<br>
<p>
It is good that Intel thought about timing attacks this time around and gave us a switch to control timing.<br>
There is nothing scary and absolutely nothing wrong with that concept.<br>
Maybe they could have been doing better with the switch implementation, but security wise I don't think this will break anything that's not already broken or is already known to need fixes for this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922427/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor922700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 12:47 UTC (Thu)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/922700/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Insecure by default" is probably the way to go for this.  If you want security, you're likely willing to to trade it off for speed, and make an additional syscall, running all crypto code in a separate thread, etc.  If you want performance, adding the cost of a syscall to every thread to disable the optimizations is a cost you don't want to pay.<br>
<p>
Does this mean existing constant-time code gets hit? Sure.  But constant time code is only in security-critical code on security-critical systems.  If the locations of that code isn't already known, and the programs that use that code being regularly upgraded, then it is all-but certain that they are already vulnerable to some exploit.  Perhaps not a timing side channel, but how old of a version of OpenSSL can you use without running into some exploit?<br>
<p>
It doesn't make sense to slow down all code in the name of preventing timing side channels in code that is out-of-date and thus already likely has serious bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 13:22 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/922704/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But constant time code is only in security-critical code on security-critical systems.</span><br>
<p>
In other words, at least all business laptops? Which probably outnumber all other laptops?<br>
<p>
There's too much "not my problem" here. It will be your problem if my work laptop is cracked and used to exfiltrate your credit cards, your NHS number, all the other sensitive info my employer holds on you ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor922713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 14:43 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/922713/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In other words, at least all business laptops? Which probably outnumber all other laptops?</span><br>
<p>
Hardly.  All that most laptops these days get used for ("business" or otherwise) is a container to run Chrome.  Granted, "business" laptops also tend to run all their traffic over a proprietary VPN tunnel and have five different "security" suites snooping/slowing everything down to a crawl..<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor922792"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2023 16:39 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/922792/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;It will be your problem if my work laptop is cracked and used to exfiltrate your credit cards,</span><br>
<span class="QuotedText">&gt;your NHS number, all the other sensitive info my employer holds on you ...</span><br>
<p>
And can you give an explanation of how that could actually happen in the real world?<br>
What is the mechanism you are thinking of?<br>
<p>
<span class="QuotedText">&gt;There's too much "not my problem" here.</span><br>
<p>
There's too much FUD here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/922792/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor923993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant-time instructions and processor optimizations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2023 22:36 UTC (Tue)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/923993/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Read the rest of the paragraph: I'm not saying that there isn't several layers of what I would consider to be security-critical constant-time code involved in the processing and sending of this message to your laptop from mine.  I'm saying that that security-critical constant-time code is located in areas that are known to be security-critical, and are thus receiving regular updates.<br>
<p>
The problem with this change to the chip is that existing compiled code will need to be updated, and source will need to have some new annotations sprinkled in.  But if the source is not being actively maintained for those updates to be done, and if the compiled binaries aren't receiving security updates, for the amount of time that will need to pass between now and when these processors start appearing even in new machines, then we can assume that it is already compromised.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/923993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
