        <!DOCTYPE html>
        <html lang="en">
        <head><title>Linux security non-modules and AppArmor [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/239962/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/239230/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/239962/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Linux security non-modules and AppArmor</h1>
<div class="Byline">[Posted June 27, 2007 by corbet]
               <p>
               </div>
</div>
<div class="ArticleText">
Long-time LWN readers will know that the Linux security module (LSM) API is
controversial at best.  To many, it has failed in its purpose, which is
enabling the development of competing approaches to hardened Linux system;
the only significant in-tree security module remains SELinux.  Meanwhile,
the LSM interface is easily abused; since it allows the insertion of hooks
into almost any system operation of interest, it can be used by other
modules to provide non-security functionality.  The LSM symbols are mostly
exported GPL-only, but it is still possible for binary-only modules to
abuse the LSM operations - and, apparently, some have done so.
<p>

SELinux hacker James Morris has been pondering this issue recently; he has
also noticed that the in-tree security modules (SELinux and the small
module implementing capabilities) cannot be unloaded.  So, he asked, why
implement a modular interface at all?  He has posted <a
href="http://lwn.net/Articles/239697/">a patch</a> which turns LSM into a
static API with no exported symbols.  With this patch applied, any needed
security "modules" must be built into the kernel; there is no longer any
way to add them at run time.
<p>

There have been a few complaints, but, from your editor's point of view, it
does not seem like anybody has come up with a compelling reason why it must
be possible to unload security modules.  Instead, it has been pointed out
that maintaining a coherent security state in the presence of unloadable
modules is nearly impossible.  So this patch would appear to have
reasonably good chances of being applied.  The only question, perhaps, is
whether the developers feel the need to provide an extended warning period
for developers and users of out-of-tree security modules.
<p>

One such module is AppArmor - the GPL-licensed security mechanism
distributed by Novell.  AppArmor has remained out of the tree for a long
time while its developers have tried to address the various comments which
have been posted over the years.  A <a
href="http://lwn.net/Articles/239951/">new AppArmor patch</a> has been
posted; many things have been fixed, but one of the core points remains:
AppArmor still uses a pathname-based mechanism for its policy enforcement.
This approach sits poorly with developers - especially those in the SELinux
camp - who think that pathnames are an inherently insecure method.  In
their view, the only truly secure way to control access to objects is to
put labels on the objects themselves.
<p>

It seemed that this dispute had been resolved at the 2006 kernel summit,
where it was determined that the use of pathnames was not enough to keep
AppArmor out of the kernel.  That has not stopped people from complaining,
though, and those complaints redoubled when another pathname-based approach
(TOMOYO Linux) was posted recently.  If AppArmor does get into the
mainline, it will have to be over the objections of developers who feel
that is providing false security to its users.
<p>

Andrew Morton appears to want to resolve this issue and get it off the
mailing lists; he <a href="/Articles/239964/">sees two alternatives</a>:
<p>
<div class="BigQuote">
	a) set aside the technical issues and grudgingly merge this stuff
   	as a service to Suse and to their users (both of which entities are
   	very important to us) and leave it all as an object lesson in
   	how-not-to-develop-kernel-features. [...]
<p>
	b) leave it out and require that Suse wear the permanent cost and
	quality impact of maintaining it out-of-tree.  It will still be an
	object lesson in how-not-to-develop-kernel-features.
</div>
<p>
It seems that Andrew would rather not be in the position of delivering
object lessons on how not to develop kernel code by whatever means; he
concludes with this request:
<p>
<div class="BigQuote">
	Sigh.  Please don't put us in this position again.  Get stuff
	upstream before shipping it to customers, OK?  It ain't rocket
	science.
</div>
<p>

At the 2006 summit, Linus took a clear position that the use of pathnames
for security policies seemed reasonable to him.  Given that, along with the
fact that AppArmor is being widely distributed, and it seems that, sooner
or later, this module should find a home in the mainline - even if it is no
longer in modular form.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#AppArmor">AppArmor</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Security_modules">Security/Security modules</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#AppArmor">AppArmor</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_Security_Modules_LSM">Linux Security Modules (LSM)</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/239962/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor240019"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 4:54 UTC (Thu)
                               by <b>jamesm</b> (guest, #2273)
                              [<a href="/Articles/240019/">Link</a>] (35 responses)
      </p>
      
      </div>
      </summary>
      There's more to this than pathnames.  Unfortunately, an important issue that has been lost in discussions is that of security architecture.<br>
<p>
SELinux is a security framework.  It's not simply one particular security model, but an architecture for composing different types of security models in a coherent manner.<br>
<p>
It is analogous to the VFS or the networking stack, rather than a specific filesystem or network protocol.<br>
<p>
One of the outstanding issues with AppArmor being merged upstream is how it relates to the kernel's security architecture.   The idea with SELinux, from the start, has to been to extend the old Unix DAC model with an extensible framework, to allow Linux to accomodate a wider variety of security models (such as RBAC and TE).<br>
<p>
One key concept with this framework is that it is "policy flexible". That is, it implements a clean separation of mechanism and policy.  So in addition to supporting multiple security models, each of these can be deployed in a manner suiting a wide range of requirements (including notions of "good enough" security which allow simpler policy).<br>
<p>
Another key concept is re-use of mechanisms.  The policy, auditing, labeling and enforcing frameworks are cleanly abstracted so that different types of security models can be integrated into the overall framework.  Policy for the entire system can be designed and analyzed in a complete and coherent manner, while a consistent set of APIs and abstractions are provided to applications, and a common set of libraries and tools are used for development and management.<br>
<p>
Note that the literature shows that composition of different security models is a potentially dangerous area, and that subtle and entirely unexpected security issues can be introduced without appropriate overall control.  LSM cannot thus be thought of a scheme for security module compostion, as it lacks any common infrastructure: it's just a large bunch of hooks littered throughout the kernel.  OTOH, SELinux was actually designed to do this in a way that allows the resulting compound security policy to be fully analyzed.  And by design, I mean the result of decades of advanced (NSA) research, with prototyping in several OSs followed by volumes of technical analysis.  What we see with SELinux is simply the decsion to transfer the results of all of this work into a general purpose operating system, and the fact that it was done upstream in Linux should tell you something about the level of clue.<br>
<p>
Anwyay, without going too deeply into the design, I hope I've now established the idea of SELinux as a security architecture and some aspects of its bona fides as an architecture.<br>
<p>
The problem, the deep problem we face now is that as long as LSM remains, SELinux will remain as "just another" security module, and it will never be considered a first class component of the kernel.  Kernel developers will forever have to deal with the weak semantics of LSM, without understanding what is supposed to be going on behind the hooks, and quite understandably, not bother thinking too deeply about extended security.  SELinux provides much stronger semantics as an in-kernel API, and can provide a consistent conceptual model for general kernel developers in the same way that the existing DAC code does now.  Related is the user experience, where again, application developers, sysadmins and other technical folk will generally see extended security as an optional pluggable idea with weak semantics, that they will continue not to buy into because of this.<br>
<p>
Linux needs to provide clear semantics and conceptual models; be it security, networking, filesystems, drivers or pretty much anything where different types of models can be deployed.<br>
<p>
If we continue the analogy of the network stack: imagine that a decision had been made years ago to make the whole stack pluggable.  What we would have now, I believe, the network kitchen-sink from hell, with no underlying design or consistency.  We'd likely have merged every bad idea to make it into a thesis or marketing brochure: sysv streams, TOE, hare-brained and half-assed research projects, and enough snake-oil to power the world for a decade.  And who would bother maintaining it all?  <br>
<p>
It simply would not have been possible to develop systemic network improvements such as Netfilter, IPsec, advanced routing &amp; traffic control, nor would there be a foundation for the performance work applied across the stack, or for genneral infrastructure improvements that people have been working on recently.<br>
<p>
To put it another way, we would not have been able to evolve what is arguably the best network stack ever.  Recall Van Jacobson's comments on it  at LCA06:  "The people who take care of the stack know what they're doing and do good work",  "... Linux has the fastest and most complete stack of any OS".  With the LSM approach, this is never going to be said for Linux's security core.<br>
<p>
Further imagine how pluggable stacks would have played out at the distro level, and where it would leave the users in terms of compatabilty and consistency with Linux networking.  It would also be unsupportable upstream:<br>
<p>
"Routing doesn't work!  I add the default route and everything stops." <br>
<p>
"Uh, which network stack are you using, and is it even in the kernel?" <br>
<p>
"I don't know :'-("     &lt;- note, user crying<br>
<p>
I think we're about to make this mistake with security: by not adopting SELinux as the security framework; by avoiding real architectural discussion; by allowing technical issues to be framed politically; and by not listening to people who know what they're talking about. <br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240019/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 5:28 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/240030/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      that's a good restatement of the SELinux pitch. A shorter version is that SELinux can do everything and nothing else is needed.<br>
<p>
except that the SELinux framework cannot reasonably implement the AppArmor semantics since a simple rename could require the relabeling of thousands of files before the system works properly.<br>
<p>
and no, I don't buy the answer from the SELinux camp of "well, don't do that then" as being reasonable<br>
<p>
for the record I am not a current user of AA, however I definantly see it as being useful and would start useing it within a couple of months of it being included.<br>
<p>
the arguments against keeping the LSM modular all assume a SELinux approach of tagging everything and worry about how to tag things on module insertion and what to do with the tags on module removal.<br>
<p>
if you look at other possible modules the answers are much clearer.<br>
<p>
for example, with App Armor when you unload the module everything is unconstrained. when you load a module all future accesses are checked (if the name of the program being run can only be found at execution time then it could only constrain programs executed after it's loaded, which could be an advantage under some conditions)<br>
<p>
another LSM I ran across recently allowed you to limit network use by programs. it also seems like the load/unload events would be clear (or at least straightforward)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 10:15 UTC (Thu)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/240052/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
Note that you did not actually answer to the essence of James' arguments.
<p>
it boils down to: the architecture of SELinux is there for a reason (and it is well documented), and the answer is not to ignore it and remove the "extra complexity" out of ignorance, but to understand the security issues behind them and provide an alternative solution (if you can).
<p>
You are in essence putting a chair into the fire-proof door to keep it open permanently, just because you find it inconvenient. Instead of designing an automatic fire-proof door that opens automatically when a human (with the right permission) approaches.
<p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/240052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 14:47 UTC (Thu)
                               by <b>jschrod</b> (subscriber, #1646)
                              [<a href="/Articles/240103/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Maybe he doesn't need fire-proof doors all the time, but is also not satisfied with a hole in a wall -- sometimes a door itself would be sufficient.<br>
<p>
Coming back from your analogy: Implementing "just a door" in SELinux is horrible work, and many users then take the hole in the wall instead, i.e., they shut it off. I see this daily at my customers' installations.<br>
<p>
Decisions about security mechanisms are not black and white, like all other security decisions. They are a compromise between effort, risk, and asset value. Sometimes the big hammer SELinux is the tool to use, but there are other situations, too -- and not all of them demand the big hammer.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor240031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 5:36 UTC (Thu)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/240031/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      While I don't automatically want to agree that SELinux is the One True Thing, I do agree that LSM was a mistake in hindsight.<br>
<p>
LSM was created because the security folks (many of whom were thinking of doing binary only proprietary things) couldn't agree. LInus decreed basically "I don't want to care so make it go away behind some interface". It made security stuff the 5th wheel of the kernel, with little visibility towards a real design... especially with most LSM stuff out of tree it's just hard to see how things really fit together.<br>
<p>
I'm sad to see that many of the original companies and groups that are the cause of the LSM debacle just never came forward. The only one who half came forward is AppArmor, and it's funny to see how that sort of gets posted once a year, just in time for the Kernel Summit to have another "don't remove LSM because we're still here" argument...<br>
<p>
<p>
Path based security has issues, and the one that Johnathan missed is the one where AppArmor has to reconstruct a full pathname by going backwards up the tree. That is just a major problem (and that is not the part that was seen at the last kernel summit as "ok"; only the "look at filenames" part was).<br>
<p>
<p>
Anyway today we have a set of random hooks that have relatively unclear semantics, of which all but one user are out of tree so we can't do a sweep to even check if they are the right interface.... and the hooks also add a performance cost due to the indirect function pointer calls. At least the proposed path is step 1 to getting rid of the indirect calls and just having a "CONFIG_SELINUX_ONLY" option which turns the calls into direct calls.... killing the not insignificant function pointer call overhead.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240186"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 19:56 UTC (Thu)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/240186/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      What about replacing those indirect function pointer calls with that strange new "alernative" thing, patching the right call in when needed?<br>
<p>
Sure, it's ugly, but if it's a real performance problem, then why not? Would mean that having LSM enabled without running any security module wouldn't cost anything either. Of course it isn't needed when LSM goes away, just an idea for when it isn't.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240186/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 29, 2007 5:00 UTC (Fri)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/240226/">Link</a>] 
      </p>
      
      </div>
      </summary>
      yes; the proposed patch is a good step in making that actually practical...<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor240047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 8:47 UTC (Thu)
                               by <b>ljt</b> (guest, #33337)
                              [<a href="/Articles/240047/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I agree fully: selinux must be included in the kernel the same way memory management, network or vfs are.<br>
<p>
I think though that selinux would gain a BIG user mindshare by becoming less opaque: Common mortal *cannot* know which constraints a process is under. <br>
There is tool to see the label in files, but there is no tools (that I am aware of) to see in which context a process is under and what it is allowed to do. <br>
Take the legacy DAC model: ps gives you the uid/gid, this is all you know to match the ressources it can manipulate.<br>
<p>
Make no mistake: inspecting .mod, .te, .pp objects is to selinux what forensic is to live debugging. We *must* have _live_ and _convenient_ tools to:<br>
-See process contexts and the relvant rules it is under<br>
-Apply or remove type enforcement rules the same way chcon works (think pscon)<br>
-Provoque transitions between process contexts while running<br>
<p>
It is currently a PITA to admin the thing in a mission critical environment<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 11:48 UTC (Thu)
                               by <b>jamesm</b> (guest, #2273)
                              [<a href="/Articles/240069/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Thanks for the feedback.  You can see what context a process is running under with -Z (this works for many tools, even things like netstat), but you're right that we need to do a lot more work on management.  Likely we'll be able to make use of the exported runtime policy idea you mentioned recently.
      
          <div class="CommentReplyButton">
            <form action="/Articles/240069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor240067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 11:42 UTC (Thu)
                               by <b>grandinj</b> (guest, #5057)
                              [<a href="/Articles/240067/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      And the reply from the AppArmour guys would be that SELinux tries to be too many things to too many people.<br>
<p>
You're effectively trying to win this debate by decree.<br>
<p>
AppArmour may not be perfect, and it may not provide perfect protection, but it provides a valuable amount of extra protection for a fairly minimal amount of work, and it does so in a way that mere mortals find reasonably easy to work with.<br>
<p>
It's a classic case of theory vs. practice. In theory, SELinux is the best choice, but in the Real World (tm), for the "invisible majority" of users, AppArmour is good enough.<br>
<p>
<p>
<p>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 11:59 UTC (Thu)
                               by <b>jamesm</b> (guest, #2273)
                              [<a href="/Articles/240070/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      This has been the problem all along.  People refuse to listen to technical arguments.<br>
<p>
Once again: you can implement an extremely wide range of policies in SELinux, including "good enough" schemes that trade correctness for simplicty.<br>
<p>
This is called policy-flexibility.<br>
<p>
You can also add different types of models, at the same time, and have them composed in a coherent manner using consistent kernel and user APIs.<br>
<p>
Have a look at the SEEedit project for an AA-like scheme implemented with SELinux.<br>
<p>
And before the pathname thing comes up again, please stop and think about what the actual _requirements_ of the user are, what the most appropriate way to model them are in the Linux kernel and what kind of abstraction would then be most appropriate for the user.<br>
<p>
Remember, horse before cart.<br>
<p>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 13:14 UTC (Thu)
                               by <b>grandinj</b> (guest, #5057)
                              [<a href="/Articles/240092/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      That may well be so.<br>
<p>
But if you're implementing a security scheme that aims to be "good enough", why would you drag in a project where<br>
<p>
(a) your intentions are continually derided i.e. you are treated as a second-class citizen<br>
(b) adds a HUGE chunk of extra complexity to a security project i.e. a project in which you really want to know how all the bits work.<br>
<p>
The pathname thing appears to work. __You__ may not like it, but the thing is, it works - maybe not perfectly, and there sure are cases where it can be tripped up, but it does pretty well.<br>
<p>
Remember, perfect is the enemy of good.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 14:01 UTC (Thu)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/240098/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <p>In a security context, "appears to work" is extremely dangerous.  If your security system appears to work, but in fact does not, it leads to a false sense of security, which is worse than no security at all.</p>

<p>Sure, AppArmor appears to work, but SELinux has been <i>proven</i>, through years of high-level research, to work.  That's a critical difference.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 15:14 UTC (Thu)
                               by <b>grandinj</b> (guest, #5057)
                              [<a href="/Articles/240108/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <p>
What we're dealing with here are straightforward engineering trade-offs.<br>
<p>
A highly-complex but very complete system <br>
   vs. <br>
A relatively simple but not complete system.<br>
<p>
This is why the LSM is a good idea - so that end-users get to make the choice that works for them.<br>
<p>
<p>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 15:40 UTC (Thu)
                               by <b>jamesm</b> (guest, #2273)
                              [<a href="/Articles/240113/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      You're simply not understanding the essence of the discussion.<br>
<p>
It's about architecture.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240118"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 16:16 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/240118/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      But people --- a lot of people, in real-world insecure environments --- are *turning SELinux off* and *running with no LSM at all* because it's simply too damn hard to understand a useful non-minimal SELinux configuration. (I have given up asking ordinary systems administrators to diagnose problems in SELinux configurations when SELinux gets in the way of something they're trying to do: you might as well ask them to fix kernel bugs on their own. They just turn it off, every time.)<br>
<p>
Useful AppArmor configurations are very much smaller and easier to comprehend without having to do the sort of vast whole-system data flow analyses you're so fond of (and which nobody on the coalface has the time or inclination to do). Yes, maybe AppArmor *is* less secure than SELinux, but it's a hell of a lot more secure than *nothing*.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240118/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240124"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 16:38 UTC (Thu)
                               by <b>jamesm</b> (guest, #2273)
                              [<a href="/Articles/240124/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      What you see deployed in Fedora/RHEL etc. is simply one possible combination of models and policies implemented using the SELinux framework.<br>
<p>
You can make SELinux as "simple" as AppArmor by devising a simpler policy.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240124/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 16:50 UTC (Thu)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/240133/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      It is true, though, that SELinux is kind of hard to use.  Some higher-level policy-editing tools would be really helpful, I think.<br>
<p>
Alternatively, since SELinux is an architecture, perhaps some of the policies built on it could be flexible abstractions themselves, so that they would define a simpler "language" for defining what the users want to do.  Sort of analogous to what glibc does with abstracting away kernel interfaces.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 21:06 UTC (Thu)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/240197/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      There are various higher level policy editing tools... they are just not well known. One of the issues comes down to what people want versus what they might need. People want the ability to not think about security because security is sold to them as being hard work, etc. This is why they will pay thousands of dollars for security systems that might only check to see if a door is open. Or they will pay for bars on their house windows, but then cant get out in a fire. Heck I have had to fix problems with several people who bought a small magnet that sits on top of their monitor that keeps out bad-guys. Everything else was tooo complicated.<br>
<p>
My two problems with either of the solutions is marketing. Selinux people  have been very good about reminding people that you need to think about things before you use them. Sometimes they are too good, and you feel that grandpa's old bomb-shelter is almost safe enough for your computers.<br>
<p>
And too many of the AppArmour fan-boys will tell you that you don't need to think.. just install it and you will never have a problem. <br>
<p>
At which point the religious wars about who is being the bigger idiot start up.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 22:19 UTC (Thu)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/240208/">Link</a>] 
      </p>
      
      </div>
      </summary>
      True enough.  What I'm thinking of is some kind of higher-level policy which (for instance) organizes programs and files into groups.  Then you add the group tag to a user, and that user has access (notwithstanding any DAC restrictions) to that set of programs and files.  Somewhat akin to how traditional UNIX groups are used, except with MAC enforcement.<br>
<p>
Or am I being silly?<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor240234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 29, 2007 7:50 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/240234/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      yes, some people don't know what they are talking about on all sodes of any topic.<br>
<p>
however there are many people who do make a living in security who do see value in AppArmor, but you just dismiss them as not thinking things through or not understanding security.<br>
<p>
you are trying to define security == SELinux<br>
<p>
by your definition, anyone who proposes anything else just doesn't know what they are talking about.<br>
<p>
there are applications where you really want the security context to follow the data file the way labels do in SELinux (think of a file containing your credit card number, you don't want the security on it to change just becouse you renamed it)<br>
<p>
however in other cases all that really matters is what you would access by a particular name. (for example, the contents of what used to be called /etc/resolv.conf is of no value, all that matters is the current contents)<br>
<p>
useing either approach to address the pther type of problem will only cause grief. SELinux was born in the NSA where they primarily deal with securing specific data, no matter where it moves. and there labeling data is the natural and best answer.<br>
<p>
AppArmor approaches the security from the opposite direction. instead of labeling all the data and then defining what can access what it instead takes the approach of useing a 'label' that is already on the system, the pathname you use to access the file. It then lets you set rules about which of these labels a program can access.<br>
<p>
another way of looking at AppArmor is that instead of being data-centric (identify the data you care about and list all the programs that access it) it's process-centric (identify the programs you care about and list all the data it can access)<br>
<p>
SELinux is better if you are trying to defend a system against hostile local users. but since re-labeling data is extremely expensive you need to do a lot of analysis first.<br>
<p>
Since AppArmor uses labels that already exist on the system, makeing radical changes to how any program can access any data doesn't require re-labeling any of the data (which can have secondary effects on policies for other programs that access the data), all you need to do is change the rules related to the program<br>
<p>
There are other technical trade-offs involved in the implementation.<br>
<p>
for AppArmor the hard thing (besides getting into the kernel) is determining the path for the thing being accessed.<br>
<p>
SELinux has different problems<br>
what to label new files that are created<br>
how to configure a policy to grant access to a new file automaticaly<br>
the need for special tools when manipulating data to change the label<br>
<p>
the need to figure out the path for AppAromor on one side vs the issues in figuring out what label a new file should have in SELinux<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 29, 2007 15:06 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/240255/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      AppArmor faces a much bigger problem; you've just said that you don't want a broken application to have unconstrained access to /etc/resolv.conf. <b?If</b> that application also needs to create files (e.g. log files, temporary files etc),  what stops it from doing something like <code>'ln /etc/resolv.conf /tmp/mytempfile &amp;&amp; echo broken >> /tmp/mytempfile'</code>? Bear in mind that the interesting applications to confine run as root for part of their lifecycle, so that you need your confinement solution to confine root, too.
<p>The basic issue with pathname based-security is the ease of accidentally breaking it. Most real-world programs that you want to secure (Apache, Mozilla, mutt) either have log files, or create temporary files, or both. Making it impossible to create hard links breaks expected UNIX functionality, so the reality is that unless you take an immense amount of care in writing policy, AppArmor ends up being security theatre, and easy to bypass.
      
          <div class="CommentReplyButton">
            <form action="/Articles/240255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 29, 2007 20:54 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/240302/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      OK, I'm missing something here. Mozilla, Apache, and mutt, your own <br>
examples, run as root for part of their lifecycle?!<br>
<p>
(The very *idea* of a suid root Mozilla gives me collywobbles.)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 1, 2007 9:32 UTC (Sun)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/240357/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Well, Apache on port 80 does...<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor240386"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2007 8:07 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/240386/">Link</a>] 
      </p>
      
      </div>
      </summary>
      My Apache runs on port 80, which can only be bound by root. My SMTP server runs on port 25, which can only be bound by root (not in the list of examples, but I did rather assume that you'd apply some intelligence). My SSH daemon runs as root briefly (setting up port 22, and changing user to the user who's logging in).
<p>Indeed, all the long-running services on my boxes <b>must</b> run as root for part of their lifetime, just to bind their well-known ports for listening. Mozilla and mutt obviously don't run as root at all, but they're not necessarily that interesting to confine (e.g. on a server).
      
          <div class="CommentReplyButton">
            <form action="/Articles/240386/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor240322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 30, 2007 6:34 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/240322/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      where did you get the idea that AppArmor can't constrain a process running as root?<br>
<p>
one of the things that AppArmor does is limit what links a constrained process can create, exactly to prevent the type of loophole that you are trying to make (IIRC they do something along the lines of 'you can't make a link to a file that you can't write to' or something along those lines)<br>
<p>
AppArmor is limiting what the httpd process can do, not what the apache user can do, it doesn't matter what userid the process is running as.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 30, 2007 16:33 UTC (Sat)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/240343/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Well there is a fundamental flaw in pathnames that he is trying to point out, abiet unsuccessfully. <br>
<p>
You see that is were the problem is. Absolute pathnames are not realy all that absolute. It's possible to have multiple names for the same files. It's possible to have weird directory setups were the same stuff appears multiple times in different directories and different paths.<br>
<p>
Plus when your dealing with kernel-level stuff pathnames are pretty much immaterial because the kernel deals with lower-level stuff then all that. I don't understand all of it myself, but your dealing with situations were the kernel has to continiously loop back into userspace to determine what Apparmor is talking about.<br>
<p>
So AppArmor is making things _deceptively_ simple instead of actually making it simple. It's just hiding complexity and control from the end user while setting you up for nasty security holes in corner cases. To actually effectively use it you have to actually understand everything that is going on, because it is easier to set rules does not make it actually simplier to effectively impliment versus SELinux.<br>
<p>
<p>
What he is saying is:<br>
* SELinux is a more realistic design based on the realities of how the software and machines work.<br>
* SELinux can do everything AppArmor can do.<br>
* AppArmor can't do everything that SELinux can do.<br>
* It's very possible that SELinux can be made to be as 'simple' as AppArmor is, probably through the use of user-land programs to help set it up for admins.<br>
<p>
I don't want to get into a big arguement about it. I don't know if he is right. If you have technical reasons why he is wrong then actually I would love to hear it because it would make it easier for myself to understand what is going on.<br>
<p>
But you saying "AppArmor is easy" and that's why some people need it doesn't realy have much to do with what he is talking about because (I suppose) SELinux can be made "easy" in that way also.<br>
<p>
It's like that Fire-proof door vs regular Door vs gaping hole thing that came up a few posts back.<br>
<p>
If your going to have a door, then why not make it a good and effective door? There is no reason why a effective firedoor door can't be as user-friendly as a less effective door. At least in software-land.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2007 8:52 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/240387/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You've read a bit too much into what I'm saying. All I'm trying to point out is that the use of pathnames as your stable identifiers is rather weak if you're not thinking things through; this becomes especially true if a program uses hard links in normal operation. If you're thinking things through in enough detail to catch all the corner cases, you're also thinking things through in enough detail to write a label-based policy that works.
<p>It's all too easy to write a policy like "Read /etc/resolv.conf, read/write/modify/hardlink in /tmp" without thinking about the details of what that allows; worse, the exact behaviour of that security policy depends on system partitioning. On my home machines, where /tmp is in its own partition, that policy is safe. On my work machines, where I have a single large /, that policy is dangerous.
<p>Note that it's the use of pathnames as stable identifiers in policy that concerns me, not the rest of the AppArmor kernel-side. A simpler policy format using file labels wouldn't worry me at all.
      
          <div class="CommentReplyButton">
            <form action="/Articles/240387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor240652"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2007 21:53 UTC (Wed)
                               by <b>skybrian</b> (guest, #365)
                              [<a href="/Articles/240652/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      It seems like this could be easily solved by disallowing the creation of additional hard links for protected files?  If a file is only in one place, mapping inodes to absolute paths might be easier too.<br>
<p>
<p>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240652/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240676"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2007 8:48 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/240676/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      You've just changed the problem round. What do you mean by protected files?
<p>If you mean files that AppArmor policy covers, then you're implying that you're banning hard links entirely, as in a full deployment of AppArmor, all files are covered by policy.
<p>If you mean files that this program cannot access under the current AppArmor policy, you now have to audit all pairs of programs, and ensure that there is no case where one program which has legitimate access to a sensitive file (e.g. dhcpd in the case of /etc/resolv.conf) can create a hardlink to that file in an area where another process (e.g. an Apache with a security flaw) can create a hardlink to it.
<p>Putting that into a concrete example:
<ol>
<li>You create policy that prevents Apache from writing /etc/resolv.conf
<li>You create policy that lets dhcpd write /etc/resolv.conf
<li>dhcpd (for whatever reason) creates a new file /tmp/dhcpdXXXXresolv in the process of operation, and fills in the data that will become /etc/resolv.conf
<li>Apache hardlinks to /tmp/dhcpdXXXXresolv, as the security flaw has been exploited
<li>dhcpd moves /tmp/dhcpdXXXXresolv to /etc/resolv.conf
</ol>
<p>Granted, I'd have had an exploit with or without AppArmor in this case (without AppArmor, Apache could have just overwritten /tmp/dhcpdXXXXresolv or /etc/resolv.conf), but this is <b>exactly</b> the sort of issue a system like AppArmor should protect against; note that I've only posited <b>one</b> buggy program (Apache), and a policy that should confine that process to being unable to edit /etc/resolv.conf, and yet my hypothetical bad guy can still break things.
<p>In contrast, with a label-based system, I'd have a label <tt>network-config-file</tt>, and all files created by dhcpd would get that label by default. Even though I've not noticed dhcpd's actions in /tmp, Apache can't get access, as it's not allowed to write to <tt>network-config-file</tt>s.
<p>Oh, and again note that the exploitability of this bug depends on partitioning. If I wrote this policy on my home machine (/tmp on a separate partition), I'd not see this flaw at all; if I used it at work (one big / partition), I'd be broken. There's also no easy way to audit a system setup, and confirm that I've not broken the policy; with a label-based system, I just have to check that all filesystems support labelling. With this pathname based system, I have to look at whether my partitioning layout matches the partitioning on the policy developer's system, <b>and</b> whether the differences open holes in policy.
      
          <div class="CommentReplyButton">
            <form action="/Articles/240676/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2007 16:15 UTC (Thu)
                               by <b>skybrian</b> (guest, #365)
                              [<a href="/Articles/240710/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      If policy is based on paths, then it seems like hard links between any two paths that have different security policies has to be disallowed (for example, between /etc and /tmp).  Otherwise you've got files that appear under more than one security level.  Any kind of copy between files at paths with different security levels untaints the data.<br>
<p>
A taint-based system does seem more appealing if it could be made to work.  It occurs to me that we have something close to that already, except that the security label is the owner and group of the file.  The issues with setting the label for new files are similar to deciding what the owner, group, and umask should be for a new file.  Maybe this would be more popular if security labels were something familiar?  A special kind of group?<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2007 8:29 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/240796/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You're still facing two problems with hard links:
<ol>
<li>I can create a hard link in /tmp to another file in /tmp, and then (assuming suitable partitioning), someone else can move the file or the hard link to /etc. The move creates a hard link from /tmp to /etc, so you'd have to ban use of rename(2) to atomically move files from one location to another.
<li>Security policy is per-application; any path has multiple different security policies applying to it, depending on which application is accessing it. Working out the union of policies, and only allowing hard links if the union of policies is "safe" is a hard task.
</ol>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor240266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 29, 2007 16:18 UTC (Fri)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/240266/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Thanks for the reasoned reply. I do not believe that security == SELinux, but I do have to worry about hostile local users... very very much so. So in that case I usually have to do all the work that is going on with an SELinux system.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor240170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 18:00 UTC (Thu)
                               by <b>vmole</b> (guest, #111)
                              [<a href="/Articles/240170/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p><i>The pathname thing appears to work.</i>
<p>Using the return from malloc() without checking it appears to work, too. Most of the time, anyway. And checking every returned pointer for NULL is complicated and tedious.
      
          <div class="CommentReplyButton">
            <form action="/Articles/240170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor240121"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 16:34 UTC (Thu)
                               by <b>akumria</b> (guest, #7773)
                              [<a href="/Articles/240121/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>One key concept with this framework is that it is "policy flexible". That is, it implements a clean separation of mechanism and policy.</blockquote>
<p>
I actually think this is a big problem with SELinux. As far as I know &mdash; and I could be wrong but that's never stopped me before! &mdash; the kernel is fairly inflexible with that what the superuser uid must be (i.e. 0).
</p>
<p>
So, why shouldn't there be an "in-kernel" RBAC security policy, or an "in-kernel" TE (Type Enforcement) security policy implemented directly on-top of LSM.
</p>
<p>
Your recent patch to disallow unloading of security modules give rise to the question, to me anyway, as to why anyone would want to have RBAC and TE security policy implemented at the same time.
</p>
<p>
Thanks,
Anand
      
          <div class="CommentReplyButton">
            <form action="/Articles/240121/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor240176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux security non-modules and AppArmor</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 28, 2007 18:53 UTC (Thu)
                               by <b>jamesm</b> (guest, #2273)
                              [<a href="/Articles/240176/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Traditional DAC is based on an extremely simple binary notion, where euid==0 represents full privilege.  The semantics of this are clear, and indeed, this policy may be hard-coded into the kernel.<br>
<p>
Beyond DAC (which is definitely inadequate for today's computing environment), the models and their semantics become more complicated.  With this complexity, it's important to maintain a separation of mechanism and policy (as a general principle, too), so that different sets of requirements can be met.  The policy-flexible design in SELinux arose directly from unsatisfactory experiences with earlier MAC security schemes where policy was hard-coded into the mechanism.  In particular, it's been extremely rare to see "trusted" Unix systems in anything other than very specialized situations such as handling classified information.<br>
<p>
Policy-flexibility is one of the characteristics of SELinux which makes it suitable not only for these situations, but also for general purpose computing such as a web server or cell phone.  This is with no code changes, just different policies loaded.<br>
<p>
I'd suggest reading some SELinux docs for more detailed background on the design and its rationale.<br>
<p>
e.g.  <a href="http://www.nsa.gov/selinux/papers/ottawa01/index.html">http://www.nsa.gov/selinux/papers/ottawa01/index.html</a><br>
<p>
(the introduction is very useful).<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/240176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2007, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
