        <!DOCTYPE html>
        <html lang="en">
        <head><title>Optimizing Linux with cheap flash drives [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/428584/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/428533/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/428584/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Optimizing Linux with cheap flash drives</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="GAByline">
           <p>February 18, 2011</p>
           <p>This article was contributed by Arnd Bergmann</p>
           </div>
Flash drives are getting larger and cheaper; as a result, they are showing
up in an increasing number of devices.  These drives are not the same as
the rotating-media drives which preceded them, and they have different
performance characteristics.  If Linux is to make proper use of of this class
of hardware, it must drive it in a way which is aware of its advantages and
disadvantages. 
<p>
This article will review the properties of typical flash devices and list
some optimizations that should allow Linux to get the most out of low-cost
flash drives. The kernel working group of the <a
href="http://www.linaro.org">Linaro project</a>  is currently
researching this topic as an increasing number of embedded designs move
away from raw NAND flash devices to embedded MMC or SD drives that hide the
NAND interface and provide a simplified linear block device.  This drives
down system design complexity and cost but also means that regular
block-oriented filesystems are used instead of the Linux MTD layer that
can talk to raw flash.

<p>
Most filesystems and the block layer in Linux are highly optimized
for rotating media, in particular by organizing all accesses to
avoid seeks. It has become clear that some of these optimizations
are pointless or even counterproductive with solid-state storage media.

In recent kernels, there is a per-device flag for non-rotational
devices that treats these slightly differently, by assuming that
all seeks are free, but is that really enough to get good I/O
performance on solid state drives? High-end drives are
getting fast enough to make optimizations for CPU load more interesting
than optimizations for ideal access patterns. In contrast, the
more common SD cards and USB flash drives are very sensitive
to specific access patterns and can show very high latencies for writes
unless they are used with the preformatted FAT32 file layout.
<p>

As an example, a desktop machine using a 16 GB, 25 MB/s CompactFlash
card to hold an ext3 root filesystem ended up freezing the user interface
for minutes during phases of intensive block I/O, despite having
gigabytes of free RAM available. Similar problems often happen on
small embedded and mobile machines that rely on SD cards for their file
systems.
<p>

To understand why this happens, it is important to find
out how the embedded controllers on these cards work. Since very
little information is publicly documented, most of the following
information had to be gathered using reverse engineering based
on timing data collected from a large number of SD cards and other
devices.
<p>

<h4>Pages, erase blocks and segments</h4>
<p>

All NAND flash chips are physically organized into "pages" and "erase blocks."
A page is the smallest unit that can be addressed in a single
read or write operation by the embedded microcontroller on a managed
flash device, and it has an effective size between 2KB and 32KB
in current consumer flash drives. This means that while a single
512-byte access is possible on the host interface (USB, ATA, MMC, ...),
it takes almost the same time as a full page access inside of the
drive.
<p>

Although it is usually possible to write single pages, the data cannot be
<i>over</i>written without being erased first, and erasing is only possible
in much larger units, typically between 128KB and 2MB.  The controllers
group these erase blocks into even larger segments, called "erase block
groups," "allocation units," or simply "segments." The most common size for
these segments is 4MB for drives in the multi-gigabyte class, and all
operations on the drive happen in these units; in particular, the drive
will never erase any unit smaller than a segment.

<p>

The drives have a single lookup table which contains a mapping between
logical segments 
and physical segments. On a typical 8GB SD card using 4MB segments,
this table 
contains a little under 2000 entries, which is small enough to be kept
in the RAM of the card's microcontroller at all times. A small number
of physical segments is set aside in a pool to handle wear leveling,
bad blocks and garbage collection.
<p>

Ideally, the drive expects all data to be written in full segments,
which is what happens when recording a live video or storing
a music collection on a FAT32 filesystem.
<p>

<a href="/Articles/428592/"><img
src="https://static.lwn.net/images/2011/arnd-ssd/extrememory-results-sm.png" width=300 height=204
alt="[Bar chart]" align="right" border=0 hspace=3 vspace=3></a>

The way the physical characteristics of the card make themselves felt can
be seen in the plot to the right (click on the thumbnail for the full-size
version), which summarizes the results of a number of tests on an SDHC
memory card.  The best-case read throughput is 13.5MB/s, while the linear
write throughput is 11.5MB/s.  The results show that the segment size is
4MB; any properly-aligned, 4MB write will be fast.  
The smallest
efficient block size for reads and writes is 64KB, all accesses smaller
than that are significantly slower.
Individual pages are 8KB; the costs of extra garbage collection caused by
smaller writes can be seen.  The card as a whole has been optimized for
linear write operations; random writes are much slower.  Additionally, only
one segment can be open at a time; alternating between two segments will
cause garbage collection at every access, slowing write speeds to a mere
33KB/s.  That said, the FAT file table area (from 4MB to 8MB) is managed
differently, enabling small writes to be done efficiently there.

<!--
[
 image:extrememory-results.png
 caption: Throughput measurements from an SDHC memory card
  Results that can be seen from these measurements:
  * Read throughput is 13.5 MB/s
  * Linear write throughput is 11.5 MB/s
  * Segments are 4 MB. Any aligned 4 MB write is fast.
  * Blocks are 64 KB. Smaller accesses are significantly slower.
  * Pages are 8 KB. Subpage writes cause extra garbage collection.
  * The card is optimized for linear write, random write is significantly slower.
  * Exactly one segment can be open for writing, alternating between two segments
    causes garbage collection at every access, down to 33 KB/s.
  * The FAT area (4MB-8MB) allows efficient small writes.
]
-->

<p> 

<a href="/Articles/428836/"><img
src="https://static.lwn.net/images/2011/arnd-ssd/panasonic-plot-sm.png" width=300 height=212
alt="[Performance plot]" border=0 align="right" hspace=5 vspace=3></a>

The second image to the right shows a plot of read access times, in page
granularity, on the first 32MB of a Panasonic Class&nbsp;10 SDHC card. This
plot 
illustrates various properties of the card. The segment size of 4MB can
clearly be seen from the various changes in performance at the boundaries
between segments.  All closed segments have the same read performance, as do
have all erased segments, which are a little faster to read. The FAT area
in the second segment is a bit slower when reading because it uses a block
remapping algorithm. One segment has been opened for writing by writing a
few blocks in the middle before the read test, that segment can be seen as
being a little faster to read on this specific card.  Also, an effect of
multi-level-cell (MLC) flash is that it alternates between slightly slower
and faster pages, which the plot shows as two parallel lines for some
segments.

<p>

<h4>Wear leveling</h4>
<p>

When a segment that already contains data is written to, a new segment is
allocated from the free pool and the drive writes the new data into
that segment. Once the segment has been written to from start to finish,
the lookup table will be updated to point to the new segment, while the old
segment is put into the free pool and erased in the background.
<p>

By always allocating a new segment, the drive can avoid wearing out a
single physical segment in cases where the host always writes to the same block
addresses. Instead, all writes are statistically distributed to all
the segments that get written to from time to time. The better memory cards
and SSDs also do static wear leveling, meaning they occasionally move
a logical segment that contains static data to a physical segment that
has been erased many times to even out the wear and increase the expected
lifetime of the card. However, the vast majority of cheap memory cards
do not do this but, instead, rely on the host software to write
to every segment of the drive at some time or other.
<p>

<a href="/Articles/428793/"><img
src="https://static.lwn.net/images/2011/arnd-ssd/segment-preview.png" width=350 height=132
alt="[Segment mapping diagram]" border=0 align="right" hspace=5
vspace=3></a>

The diagram to the right shows how this mapping works in a typical flash
drive; click on it for an animated version.

<!--
[
 image:segment.gif
 preview:segment-preview.png
 caption:Mapping from logical to physical segments
] -->
<p>

To improve wear leveling, the host can also issue trim or erase commands
on full segments to increase the size of the free pool. However, file
systems in Linux do not know the segment size and typically issue trim
commands on partial segments, which can improve write performance inside
that segment but not help wear leveling across segments.
<p>

<h4>Garbage Collection</h4>
<p>
<!-- [
 image:panasonic-plot.png
 caption:Plot of access times on a Panasonic Class 10 SDHC card
 This shows different types of segments:
 * The second segment contains the FAT and is slightly slower to read
 * The last two segments have been erased prior to testing
 * The fourth segment was opened by writing a few blocks in it
 * Most segments have alternating slow and fast blocks, typical for MLC flash
] -->
<p>

In real life, writing 4 MB segments at once is more the exception than
the rule, so drives need to cope with partial updates of segments.
While data gets written to a logical segment, the controller normally
has an old and a new physical segment associated with it. In order to
free up the extra segment, it has to combine all the logical blocks in
that segment into physical blocks on only one segment and discard
all the previously used physical blocks, a process called garbage
collection. A number of garbage collection techniques can be observed
in current drives, including special optimizations using caching in
RAM or NOR flash and dynamically adapting to the access patterns.
<p>

Most drives however use a very simple garbage collection method, typically
one of the following three.  Each description below is accompanied by a
diagram which, when clicked, will lead to an animated version showing how
the technique works.
<p>

<b>Linear-access optimized garbage collection</b>.

<!-- [
 image: linear.gif
 preview: linear-preview.png
 caption: Writes to a linear-access optimized segment
] -->

Drives that are advertised as being ideal for video storage usually expect
long, contiguous reads and writes. They always write a physical segment
from start to end, so, if the first write into a segment does not address
the first logical block inside it, the drive copies all blocks in front
of it from the old segment before writing the new data. Similarly,
a subsequent write to a block that is not logically contiguous to the
previously written one requires the drive to copy all intermediate blocks.

<p>


<a href="/Articles/428796/"><img
src="https://static.lwn.net/images/2011/arnd-ssd/linear-preview.png" width=350 height=103
alt="[Linear access diagram]" border=0 hspace=5 vspace=3 align="right"></a>

Garbage collection simply fills the new segment up to the end with copies
of the unchanged blocks from the old segment.

<p>
The advantage is optimum performance for all reads and for long writes, but
the disadvantage is that the drive ends up copying almost an entire segment
for each block that gets written in the wrong order, for instance when
the block elevator algorithm writes the blocks in reverse order
attempting to avoid long seeks. Also, writing linear data smaller than
the minimum block size of the drive makes it write the same block twice,
which forces an immediate garbage collection. The minimum block size that
the drive expects here is normally the cluster size of the preformatted
FAT32 filesystem, between 4KB and 32KB, but on SD cards, it can be
even larger than that.

<p>
Drives that are hardwired to linear-access optimized segments are basically
useless for ext3 and most other Linux filesystems because of this, because
they keep small data structures like inodes and block bitmaps in front
of the actual data and need to seek back to these in order to write new
small files.

<p>
<b>Block remapping</b>.

<!-- [
 image:random.gif
 preview:random-preview.png
 caption:Writes to a block remapping segment
] -->

Fortunately, a significant number of flash drives support random access
within a logical segment, by remapping logical blocks to free physical blocks

<a href="/Articles/428831/"><img
src="https://static.lwn.net/images/2011/arnd-ssd/random-preview.png" width=350 height=103
alt="[Block remapping diagram]" border=0 hspace=5 vspace=3 align="right"></a>

as they get written. Since this requires maintaining another lookup
mechanism, both read and write accesses are slightly slower than the
ideal linear-access behavior, and a small amount of out-of-band data
needs to be reserved to store the lookup table.
<p>

This method also does not allow efficient writing in any small units
when the manufacturers optimize for larger blocks in order to keep the
size of the lookup table small. Writing the same block repeatedly
still requires a full garbage-collection, which makes this method
unsuitable for storing an ext3 journal or any other data that
frequently gets written to the same area on the drive.

<p>
<b>Data logging</b>.
<!--
[
 image:logging.gif
 preview:logging-preview.png
 caption:Writes to a data logging segment
] -->

The best random-access behavior is provided by using the same approach 
that log-structured filesystems like jffs2, logfs or nilfs2 and
block-remappers like UBI in Linux use. Data that is written anywhere
in the logical segment always goes to the next free block in the
new physical segment, and the drive keeps a log of all the writes
cached. Once the last free block is used up, a garbage collection is
performed using a third physical segment.
<p>


<a href="/Articles/428832/"><img
src="https://static.lwn.net/images/2011/arnd-ssd/logging-preview.png" width=350 height=103
alt="[Data logging diagram]" border=0 hspace=5 vspace=3 align="right"></a>

In the end, writing this way is slower than the other two approaches
in the best case, because every block is written at least twice, but
the worst case is much better.

<p>
This approach is normally used only in the first few segments on the
drive, which contain the file allocation table in FAT32 preformatted
drives. Some drives are also able to use this mode when they detect
access patterns that match writes to a FAT32 style directory entry.

<p>
Obviously, any such optimizations don't normally do the right
thing when a different filesystem is used on the drive than it
was intended for, but there is some potential for optimization,
e.g. by ensuring that the ext3 journal uses the blocks that are
designed to hold the FAT.

<h4>Restrictions on open segments</h4>
<p>

One major difference between the various manufacturers is how many
segments they can write to at any given time. Starting to write
a segment requires another physical segment, or two in case of
a data logging algorithm, to be reserved, and requires some RAM
on the embedded microcontroller to maintain the segment. Writing

<a href="/Articles/428799/"><img
src="https://static.lwn.net/images/2011/arnd-ssd/thrashing-preview.png" width=350 height=132
alt="[SSD thrashing]" align="right" border=0 hspace=5 vspace=3></a>

to a new segment will cause garbage collection on a previously
open segment.  That can lead to thrashing as the drive must repeatedly
switch open segments; see the animation behind the diagram to the right for
a visualization of how that works.

<p>

<!-- [
 image:thrashing.gif
 preview:thrashing-preview.png
 caption:Example: Writing to a device with two open segments
] -->
<p>

On many of the better drives, five or more segments can be open
simultaneously, which is good enough for most use cases, but some
brands can only have one or two segments open at a time, which
causes them to constantly go through garbage collection when used
with most of the common filesystems other than FAT32.
<p>

When a drive reserves the segments specifically to hold the FAT,
these will always be open to allow updating it while writing streaming
data to other segments.
<p>

<h4>Partitioning</h4>

<p>
When a filesystem wants to optimize its block allocation to
the geometry of a flash drive, it needs to know the position of
the segments on the drive. On partitioned media, this also
implies that each partition is aligned to the start of a segment,
and this is true for all preformatted SD cards and other media
that require special care for segment optimizations.

<p>
Unfortunately, the fdisk and sfdisk tools from util-linux make it
particularly hard to do this correctly, because they try to
preserve an archaic geometry of 255 "heads" and 63 "sectors"
and, by default, align partitions to "cylinder" boundaries. None
of these units have any significance on today's hard drives or
flash drives, but they are kept for backwards compatibility with
existing software.

The result is that most partitions are as misaligned as possible,
they start on a odd-numbered 512-byte sector, which defeats
all optimizations that a filesystem can do to align its accesses
to logical blocks and segments inside of the partition.

<p>
The same problem has been discussed a lot in the light of hard
drives with 4KB sectors, but it is much more significant when
dealing with flash media. Current versions of fdisk ask the kernel
about physical sector (BLKPBSZGET) and optimum I/O size (BLKIOOPT),
but currently these are rarely reported correctly by the kernel
for flash drives, because the kernel itself does not have the
necessary information. SDHC cards report the segment size in
sysfs, but this is not used by any partitioning tools, and all
cards currently seem to report 4MB segments, even those that
actually use 2MB or 8MB segments internally.
<p>

The linaro-media-create tool (from <a
href="https://launchpad.net/linaro-image-tools">Linaro Image Tools</a>) 
has recently been changed to align partitions to 4 MB boundaries
when installing to a bootable SD card, to work around this problem.


<h4>Future work</h4>
<p>

There is a huge potential for optimizing Linux to better deal
with the deficiencies of flash media in various places in the
kernel and elsewhere. With the storage and filesystem summit
coming up this April, there is hopefully time to discuss these
and other ideas:
<p>
<ul>
<li> All partition tools should default to a much larger alignment,
  e.g. 4 MB or what the drive itself reports, for flash media
  and ignore cylinder boundaries.

<p>
<li> The page cache could benefit from the fact that larger accesses
  end up taking less time than accesses shorter than a flash page.
  When a drive reads 16KB, the kernel may as well add all of it to the page
  cache.

<p>
<li> The elevator and I/O scheduler algorithms can do much better
  than they do today for drives that only do linear access.
  Ideally, all outstanding writes to one segment should be
  submitted in order within a segment before moving to another
  segment.

<p>
<li> A stacked block device can be used to reorder blocks during
  write, creating a copy-on-write log-structured device on
  top of drives that can only write to one segment at a time.
  A first draft design for device is available on the  
  <a
  href="https://wiki.linaro.org/WorkingGroups/Kernel/Projects/FlashDeviceMapper">FlashDeviceMapper page</a> at Linaro.

<p>
<li> The largest potential is probably in the block allocation
  algorithm in the filesystem. The filesystem can ensure that
  it submits writes in the correct order to avoid garbage
  collection most of the time. Btrfs, nilfs2 and logfs get this
  right to a certain degree, but could probably get much better.
</ul>
<p>
<h4>Resources</h4>
<p>

More information about specific measurements can be found in the
Linaro <a href="https://wiki.linaro.org/WorkingGroups/KernelConsolidation/Projects/FlashCardSurvey">flash card survey</a>. Readers are welcome to add data about their
memory cards and USB drives to the list.
<p>

The tool that was used to do all measurements is available from
<tt>git://git.linaro.org/people/arnd/flashbench.git</tt>.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Solid-state_storage_devices">Solid-state storage devices</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Bergmann_Arnd">Bergmann, Arnd</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/428584/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor428846"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 22:02 UTC (Fri)
                               by <b>boog</b> (subscriber, #30882)
                              [<a href="/Articles/428846/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How depressing.<br>
<p>
I have a Dell laptop with an early flash drive. Performance is sometimes awful and I always suspected the drive. (It is still quiet, which is appreciated.)<br>
<p>
So I should reformat it as FAT to have any hope of a speed-up?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428846/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 22:39 UTC (Fri)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/428853/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And lose all the features of a modern POSIX filesystem? Starting with permissions... (unless you go via layers like posixovl)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 5:00 UTC (Sat)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/428877/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>And lose all the features of a modern POSIX filesystem?</i>
<p>
Just resurrect the UMSDOS filesystem!


      
          <div class="CommentReplyButton">
            <form action="/Articles/428877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 8:41 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/428882/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems that Samsung have done something like this with their RFS (Reliable FAT file system) that they use on a lot of phones with eMMC storage.<br>
<p>
Unfortunately, their implementation has a lot of other performance problems and, worse, it's not even available under a GPL compatible license.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 17:34 UTC (Tue)
                               by <b>ttonino</b> (guest, #4073)
                              [<a href="/Articles/429276/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My Samsung Galaxy S shows:<br>
<p>
On the NAND flash with a software translation layer:<br>
/ rootfs ro,relatime<br>
/mnt/.lfs j4fs rw,relatime<br>
/system rfs ro,relatime<br>
/dbdata rfs rw,relatime<br>
/cache rfs rw,relatime<br>
<p>
On the internal SD device:<br>
/data rfs rw<br>
/mnt/sdcard vfat rw,dirsync,noatime,nodiratime<br>
/mnt/sdcard/external_sd vfat rw,dirsync,noatime,nodiratime<br>
<p>
Thus, rfs and normal vfat are both used. The rfs description reminded me of the phase tree FAT implementation that was going around a long time ago.<br>
<p>
The software translation for the NAND flash is GPL.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor428858"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 23:26 UTC (Fri)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/428858/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe your partitons are unaligned?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428858/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">unaligned partitions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2011 12:11 UTC (Wed)
                               by <b>alex</b> (subscriber, #1355)
                              [<a href="/Articles/429416/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We found that write performance for small files improved by at least a factor of 10 on our embedded SSDs when we fixed the partition alignment. fdisk doesn't help when it tries to work with the fake geometry most SSDs report.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">unaligned partitions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2011 16:14 UTC (Thu)
                               by <b>mgedmin</b> (subscriber, #34497)
                              [<a href="/Articles/429718/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How do you check for partition alignment?  fdisk -u -l /dev/sdX?<br>
<p>
I'm guessing 63 sectors (of 512 bytes) is not a good alignment?<br>
<p>
Are there any tools for fixing partition alignment?  Does parted's "move" command shift the data in the partition, or just adjust the boundaries in the partition table?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">unaligned partitions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2011 18:53 UTC (Thu)
                               by <b>meyering</b> (guest, #48285)
                              [<a href="/Articles/429738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can make parted list the partition table in units of sectors,<br>
then ensure that (assuming 512-byte sectors) each partition's<br>
start sector is divisible by some round number, like 2048<br>
if you want them to be 1MiB-aligned.<br>
<p>
For example, here all partitions are MiB-aligned, except<br>
for the first one, which is only 32KiB-aligned.  But since it's<br>
only for grub, that is ok:<br>
<p>
$ parted -m -s -- /dev/sdb u s p free<br>
BYT;<br>
/dev/sdb:117231408s:scsi:512:512:gpt:ATA OCZ-VERTEX2;<br>
1:34s:63s:30s:free;<br>
1:64s:4095s:4032s:ext2:_grub_bios:bios_grub;<br>
2:4096s:1048575s:1044480s:ext3:_/boot:boot;<br>
3:1048576s:12582911s:11534336s:ext4:_/:;<br>
4:12582912s:16777215s:4194304s:linux-swap(v1):_/swap:;<br>
5:16777216s:37748735s:20971520s:ext4:_/usr:;<br>
6:37748736s:52428799s:14680064s:ext4:_/var:;<br>
7:52428800s:52449279s:20480s:ext4:_/full:;<br>
8:52449280s:117229567s:64780288s:ext4:_/h:;<br>
1:117229568s:117231374s:1807s:free;<br>
<p>
Please do not use parted's "move" command.  It is risky since it tries<br>
to be smart and is file-system aware.  In addition to moving the partition<br>
it may try to move an embedded file system, too, but its built-in FS-aware<br>
code is so old and unreliable that it is slated to be removed altogether.<br>
<p>
If you try to use that sub-command (or e.g., mkpartfs which is in the same<br>
boat), recent versions of parted will emit a big warning telling you some<br>
of the above.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor429804"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">unaligned partitions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2011 0:15 UTC (Fri)
                               by <b>jnh</b> (subscriber, #69758)
                              [<a href="/Articles/429804/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends on the physical sector size of the device.  If you have physical sectors of 512 bytes, then partitions measured in 512 logical sectors are aligned regardless of where they start; with larger physical sectors, starting a partition at LBA 63 isn't going to be aligned.  Annoyingly, many SSDs do not correctly report their true internal topology, so even modern partitioning tools which can use that information may need to be given hints, but that said, it isn't immediately clear to me exactly what an SSD should report its topology as given the current interfaces.<br>
<p>
I recommend reading Martin K. Petersen's advanced storage papers from<br>
<a href="http://oss.oracle.com/~mkp/">http://oss.oracle.com/~mkp/</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429804/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor428880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 8:29 UTC (Sat)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/428880/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IIRC early OEM drives may have poor controllers (like the Jmicron) with things like the so called "write stutter" problem.  Once you'ld run out of virgin pages (segments?).  A "secure erase" utility would be required to restore original performance.<br>
<p>
There should be some good articles on SSD performance issues (mainly or wholly used with Windows but still should be relevant enough), and you could perhaps see if an SSD upgrade to more modern firmware, might be beneficial. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 8:31 UTC (Sat)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/428881/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whoops, I left out the site name AndandTech <a href="http://www.anandtech.com/">http://www.anandtech.com/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor428884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 8:47 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/428884/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The CF card I mentioned in the article is similar to a lot of the really cheap SSDs. It can have three 4 MB segments open for linear writing and one for random access, which is apparently just not enough for ext3 with journal.<br>
<p>
Aligning the partition to 4 MB and changing to btrfs solved it for me for that card. I have not yet done thorough testing to find out what the specific requirements of the possible file systems are, but it's worth a try.<br>
<p>
I'd also be interested to see what flashbench shows about this drive. If you can create an empty 4 MB aligned partition on it, please run it and send the results to flashbench-results@lists.linaro.org.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 10:30 UTC (Sat)
                               by <b>aleXXX</b> (subscriber, #2742)
                              [<a href="/Articles/428887/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very nice article, but what is a bit unclear to me is whether these issues mostly apply to CF- and SD-cards and USB memory sticks or do they also apply to SSD drives ?<br>
<p>
Alex<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 10:40 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/428888/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The cheapest SSD drives are basically CF cards in a different form factor, or nowadays with a PATA-SATA converter. This will show the exact same behavior as good SD cards.<br>
<p>
High-end SSDs come with significant amounts of RAM that can be used to hide most of the nasty effects, or to do something much smarter altogether, such as implementing the entire drive as a log structured file.<br>
The caching unfortunately makes it a lot harder to reverse-engineer the drive through timing attacks, so it's much harder to tell what it really does.<br>
<p>
What we know is that the underlying NAND flash technology is very similar, so in the best case, an SSD will be able to hide the problems, but not completely avoid them. If I were to design an SSD controller, I'd do the same things that I'm suggesting in <a href="https://wiki.linaro.org/WorkingGroups/KernelConsolidation/Projects/FlashDeviceMapper">https://wiki.linaro.org/WorkingGroups/KernelConsolidation...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 18:23 UTC (Sat)
                               by <b>aleXXX</b> (subscriber, #2742)
                              [<a href="/Articles/428909/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You mention read/write speed around 15 MB/s.<br>
How does that fit together with the number between 150 and 350 MB/s which are listed for SSD drives e.g. on alternate.de ?<br>
<p>
Actually I can remember that when writing to raw NAND we had also rates somewhere in the 10 to 15 MB/s range.<br>
<p>
Alex<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 20:03 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/428915/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
15 MB/s is typical for good SD cards (e.g. Class 6), which are limited by design to 20-25 MB/s anyway (UHS-1 SDHC will be faster, but is still rare today). High-end SSDs can be much faster for a number of reasons:<br>
<p>
* SATA is a much faster interface than SD/MMC<br>
* NCQ and write caching allows optimizing the accesses by reordering and batching NAND flash accesses<br>
* Using SLC NAND instead of MLC improves raw accesses<br>
* Using multiple NAND chips in parallel gives a better combined throughput<br>
* Expensive microcontrollers on the drive can use smarter algorithms<br>
<p>
All of these cost money, so you don't find them on the low end drives that I analyzed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor428945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 9:12 UTC (Sun)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/428945/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Actually, according to information in <a href="http://www.anandtech.com/show/4159/ocz-vertex-3-pro-preview-the-first-sf2500-ssd">this AnandTech article</a>, some high-end controllers use even weirder techniques... (They mention specifically real-time compression and real-time deduplication, and there's likely a lot more)
      
          <div class="CommentReplyButton">
            <form action="/Articles/428945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor437201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2011 18:36 UTC (Wed)
                               by <b>taggart</b> (subscriber, #13801)
                              [<a href="/Articles/437201/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compression and deduplication of the Sandforce controller show big benefits over the controllers that don't have them. But those benefits are lost if your data isn't compressable/redundant like if it's encrypted :(<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/437201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor439528"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Live CD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2011 19:12 UTC (Wed)
                               by <b>dmarti</b> (subscriber, #11625)
                              [<a href="/Articles/439528/">Link</a>] 
      </p>
      
      </div>
      </summary>
      What about a live CD that you boot from, type "yes I want to trash my flash drive" and it automatically tries different partition schemes, runs benchmarks, and tells you which one is fast?  Don't trust what the drive says, just try it a bunch of possible ways and see what works for real.  (I'd pay $14.95 for the iso assuming the underlying code was Free.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/439528/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor428845"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 22:13 UTC (Fri)
                               by <b>ewen</b> (subscriber, #4772)
                              [<a href="/Articles/428845/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent article.  Thanks for the research and writing it up.<br>
<p>
Reading the article, it seems to me that we're going through another "abstracted by an IO controller" shift similar to what happened when SCSI and then IDE drives were introduced.  Before that -- back in the late 80s/early 90s hard drives ("MFM" and then the later "RLL" with 33% more storage!) -- were interfaced with motor control signals and analogue read/write head signals through to a controller card in the computer which managed the drive at a pretty low level (mostly took care of the digital to analogue signals, and a little bit of the timing requirements); the disk driver was required to do the rest in software, including things like remapping bad blocks.  As drives with SCSI (and later IDE) controllers on board were introduced, this detail was abstracted away -- it became "read block", "write block", etc, with quite a bit of abstraction as to how that was done.  And this abstraction has only increased over time, to the point where (as the article notes), things like heads/cylinders/sectors are completely hidden and irrelevant.  (And unlike the MFM/RLL days, there very much aren't the same number of sectors per track; old drives were used with constant angular velocity, and modern drives are used with constant linear velocity.)  So basically as things got more complicated, it was offloaded to a separate computer -- built onto the (SCSI/IDE) drive -- and it took a while to get those to the point of being optimally efficient.  It also took a _long_ time for OS developers to get over the idea that they could optimise for track layout, etc, the way they used to have to do so when "closer" to the media.<br>
<p>
With the shift from raw-NAND-storage to SSD/MMC/CF/IDE-attached/SCSI-attached flash, we seem to be at a similar point to where we were with magnetic storage in the early 1990s: everything is clearly moving in the direction of offloading the IO work to a separate controller (the flash controller), but the implementations in those separate controllers are either fairly inefficient and naive, or end up optimising for a particular benchmark ("FAT32 file system", "video recording/playback").  Hopefully given a few more years, and increasing uses in situations where FAT32 isn't the answer (eg, lots of non-Win-XX based embedded devices) the flash controller firmware will improve to be more generally optimised for scenarios other than FAT32/video.  (And presumably over the same time micro controller costs will come down a bit so that, eg, not everything has to be fitted into 2000 entries in RAM in a tiny micro controller.)<br>
<p>
Until then, knowing what the algorithms are inside these devices really does help in making more optimal choices of device for the workload, and in designing file systems to use on them.  (Finally there seems to be a media type that really cries out for a log based file system at either the flash controller level or the OS level -- or both.  On magnetic media the seeks required used to be a major problem, and flash eliminates that issue.)<br>
<p>
Ewen<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428845/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428852"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 22:36 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/428852/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The firmware in 2.5" SSDs is already at the advanced levels you are talking about. They can handle any sort of access pattern and maintain great performance while doing it.<br>
<p>
The problem is going to remain with CF and SD cards and memory sticks. These small devices cannot include the powerful processsing chips and/or 64 MB DRAM that some of the SSDs require for their magic.<br>
<p>
I think these small devices would be much better off to create a new bypass mode in the IDE/SCSI/USB that exposes the actual flash to the host system. Give the real block size, block error status, erase, read and write commands. Might also need commands to access special metadata write areas like block maps, last written block, etc. Then we could run real flash filesystems on them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428852/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428859"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 23:35 UTC (Fri)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/428859/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think these small devices would be much better off to create a new bypass mode</font><br>
<p>
I think everyone will agree with this.  But, short of waving a magic wand (i.e. Microsoft or Intel write specs), I don't see any way of making this happen.  It's a monster chicken-and-egg problem: OSes can't add support for devices that don't exist, and vendors won't bother implementing a raw interface until OSes can use it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428859/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 0:00 UTC (Sat)
                               by <b>saffroy</b> (guest, #43999)
                              [<a href="/Articles/428862/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also I suspect the patents on FTL (flash translation layer) algorithms still make it hard for free OSes to use similar approaches.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor428893"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 12:40 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/428893/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's thought to be too hard to "release specs".  The algorithms for handling any particular generation (and type) of Intel flash are substantially different from each other.  That's just one manufacturer ... Linux would have a horrendous time trying to keep up with the dozens of flash manufacturers each releasing a new generation of flash every 18 months, possibly in several different flavours (1, 2, 3 and 4 bit per cell).<br>
<p>
It's probably not even possible for Linux mainline to keep up with that frequency, let alone the enterprise distros or the embedded distros (I was recently asked "So what changed in the USB system between 2.6.10 and 2.6.37?").  And then there's the question about what to do for other OSes.<br>
<p>
It's not just a question of suboptimal performance if you use the wrong algorithms for a given piece of flash; there are real problems of data loss and the flash wearing out.  No flash manufacturer wants to be burdened with a massive in-warranty return because some random dude decided to change an '8' to a '16' in their OS that tens of millions of machines ended up running.<br>
<p>
So yes, as Arnd says, the industry is looking to abstract away the difference between NAND chips and run the algorithms down on the NAND controller.  I'm doing my best to help in the NVMHCI working group ... see<br>
<a href="http://www.bswd.com/FMS10/FMS10-Huffman-Onufryk.pdf">http://www.bswd.com/FMS10/FMS10-Huffman-Onufryk.pdf</a> for a presentation given last August.<br>
<p>
(I work for Intel, but these are just my opinions).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428893/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 19:06 UTC (Sat)
                               by <b>ewen</b> (subscriber, #4772)
                              [<a href="/Articles/428911/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps the middle ground is to come up with some (de facto?) standardised way for manufacturers to categorise how their flash algorithms are optimised.  (In addition to any minimum/maximum speed claims, etc.) "Optimised for video streaming", and "optimised for FAT32" being two raised by the article as relatively common, but there's a need for several more categories.  At least that way, even without knowing the exact details of how, one could attempt to match the media purchased to the intended workload.  Because at the moment it seems tricky as a purchaser to do that, outside perhaps video streaming and assuming everything else is optimised for the FAT file system on it at purchase.<br>
<p>
Ewen<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor428916"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 21:03 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/428916/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The NVMHCI concept (thanks for the Link!) makes a lot of sense at the high end where the drives can be smart enough to do a good job at providing high performance and low wear.<br>
<p>
However, at the low end that I looked at, most drives get everything wrong to start with: there is too little RAM and processing power to do the reordering that would be needed for ideal NAND access patterns, the drives only do dynamic wear leveling, if any, so they break down more quickly than necessary.<br>
The way that the SD card association deals with the problem is to declare all file systems other than FAT32 (with 32KB clusters) unsupported.<br>
<p>
What we'd instead need for these devices is indeed a way to be smarter in the host about what it's doing. The block discard a.k.a. trim logic is one example of this that sometimes works already, but is not really enough to work with dumb controllers. What I'd like to see is an abstraction on segment level, using commands like "open this segment for sequential writes", "garbage-collect this segment now", "report status of currently open segments", "how often has this segment been erased?".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428916/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428925"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 22:40 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/428925/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, these are quite different devices ... I would estimate a factor of 100+ difference in price, and probably similar factors in terms of capacity, speed, power, etc, etc.<br>
<p>
The API you're suggesting makes a ton of sense for the low end devices.  I don't think there's a whelk's chance in a supernova of it coming to anything, though.  You'd need the SD association to require it, and I can't see it being in the interest of any of their members.  When the reaction to "hey, your cards suck for this other filesystem" is "your filesystem is wrong", I can't see them being enthusiastic about something this radical.<br>
<p>
I do see that Intel are members.  I'll try to find out internally if something like this could fly.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428925/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor706942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2016 8:57 UTC (Mon)
                               by <b>Hi-Angel</b> (guest, #110915)
                              [<a href="/Articles/706942/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did you find?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/706942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor428941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 3:25 UTC (Sun)
                               by <b>Oddscurity</b> (guest, #46851)
                              [<a href="/Articles/428941/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So in summary, if I want to run an ext3 filesystem on a USB stick, I'm better off formatting the stick as FAT32 and then running the ext3 as a loop?<br>
<p>
Or would that be the wrong conclusion?<br>
<p>
Not that it's all I took away from this great article, but I'm wondering what I can do in the meantime to optimise my use with such devices.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 4:07 UTC (Sun)
                               by <b>ewen</b> (subscriber, #4772)
                              [<a href="/Articles/428943/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Alas, no, running ext3 in a loop on FAT32 doesn't magically change your file system access patterns from ext3 access patterns to FAT access patterns.  (Eg, in that scenario the FAT would hardly ever change since you allocate a huge file for the loop and then just write within it, versus native FAT32 with it changing with each file change, so the cheap flash drives optimisation for the 4MB holding the FAT would be wasted; and you'd still get random updates frequently in "unexpected" -- by the naive firmware -- locations.)<br>
<p>
It appears if you want to run ext3 on a cheap flash drive, you pretty much have to assume that it's going to be slower than advertised (possibly MUCH slower, especially for write), and that there's a very real risk of wearing out some areas of the flash faster than might be expected.  Probably okay for a mostly-read workload if you ensure that you turn off atime completely (or every read is also a write!), but not ideal for something with regular writes.<br>
<p>
If it's an option for your use case, then sticking with the original FAT file system -- and using it natively -- is probably the least bad option.  Certainly that's what I do with all my portable drives that see any kind of regular updates.  (It also has the benefit that I don't have to worry about drivers for the file system on any system I might plug it into.)<br>
<p>
Ewen<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 14:11 UTC (Sun)
                               by <b>Oddscurity</b> (guest, #46851)
                              [<a href="/Articles/428953/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the comprehensive answer.<br>
<p>
I may as well switch to just FAT32 for part of the use cases and the other ones are dominated by reads, so can stay on ext.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor706944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2016 9:10 UTC (Mon)
                               by <b>Hi-Angel</b> (guest, #110915)
                              [<a href="/Articles/706944/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I disagree, I think the best one can do is to dump offsets/cluster sizes that in use by the original FAT, and then to use them for formatting in a EXT. More over, one need to do it even for no intention of usage with other FS than FAT — because upon reformatting it's easy to get offsets wrong.<br>
<p>
I'm wondering btw, why didn't the article have a chapter about finding out those sizes from the original FS. Last time I searched (½year ago), I only found people trying out timing attacks to the stick for that kind of things, though getting info for FS just after the stick bought would be way simpler. I'll check it out, perhaps below in comments someone mentioned it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/706944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor429035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 14:41 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/429035/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's a monster chicken-and-egg problem: OSes can't add support for devices that don't exist, and vendors won't bother implementing a raw interface until OSes can use it.</font><br>
<p>
Agreed, and any way out of this situation would require (at least) a transition phase were some devices support either mode, letting the operating system choose.<br>
<p>
Is such a "dual-mode" technically feasible?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor429220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 14:44 UTC (Tue)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/429220/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do not know a lot about it, but there is specs at<br>
<a href="http://onfi.org/specifications/">http://onfi.org/specifications/</a><br>
There is even a connector for FLASH looking like the SDRAM connector.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Re: ONFI (Optimizing Linux with cheap flash drives)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2011 20:44 UTC (Wed)
                               by <b>frr</b> (guest, #74556)
                              [<a href="/Articles/440262/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for that link :-) I've noticed that industry group before, but didn't pay much attention. To me, it's been just another flash chip interface standard from the JEDEC stable - notably without Samsung :-) After your remark about the standard connectors, I've taken a better look...<br>
<p>
Since 2006 or 2007, there have been several revisions of the ONFI interface standard: 1.0, 1.1, 2.0, 2.1, 2.2, 2.3, and recently 3.0. The most visible differences are in transfer rate. <br>
The "NAND connector" spec from 2008 is a separate paper - not an integral part of the main standard document. The NAND Connector paper refers to ONFI 1.0 and 2.0 standards documents. But - have you ever seen some motherboard or controller board with an ONFI socket? I haven't. In the meantime, there's ONFI 3.0 - it postulates some changes to the set of electrical signals, for the sake of PCB simplification - but there's no update to the "NAND connector" paper. To me that would hint that the NAND connector is a dead end - a historical branch of evolution that has proved fruitless... Please correct me if I'm wrong there, as I'd love to be :-)<br>
<p>
ONFI 3.0 does refer to an LGA-style socket (maybe two flavours thereof), apart from a couple of standard BGA footprints. Which would possibly allow for field-replaceable/upgradeable chip packages, similar to today's CPU's. Note that the 3.0 spec doesn't contain a single occurrence of the word "connector" :-)<br>
<p>
As far as I'm concerned, for most practical purposes, ONFI remains a Flash chip-level interface standard. It seems ONFI is inside the current Intel SSD's - it's the interface between the flash chips and the multi-channel target-mode SATA Flash controller. The multiple channels are ONFI channels. The SATA Flash controller comprises the SSD's disk-like interface to the outside world, and does all the "Flash housekeeping" in a hidden way.<br>
<p>
Note that there's an FAQ at the ONFI web site, claiming that "No, ONFI is not another card standard."<br>
<p>
From a different angle, note that the ONFI electrical-level interface (set of signals, framing, traffic protocol) is different from the native busses you can typically see in today's computers, such as FSB/QPI/PCI-e/PCI/LPC/ISA/DDR123_RAM. ONFI is not "seamless" or "inherent" to today's PC's: you have nowhere to attach that bus to, such that you'd have the Flash memory e.g. linear-mapped into the host system's memory space - which doesn't look like a good idea anyway, considering the Flash capacities and the CPU cores' address bus width (no it's not a full 64 bits - it's more like 32, 36 or maybe slightly more with the Xeons). Getting a "NAND connector" slot in your PC is not just a matter of the bus and connector and some passive PCB routing to some existing chipset platform. You'd need a "bridge" or "bus interface", most likely from PCI-e to ONFI (less likely straight from the root complex / memory hub). For several practical purposes, the hypothetical PCI interface would likely use a MMIO window + paged access to the ONFI address space, or possibly SG-DMA for optimum performance. I could imagine a simple interface using a general-purpose "PCI slave bridge" with DMA capabilities, similar to those currently made by PLX Corp. - except that those cannot do DDR, the transfer rates are too low, the FIFO buffers are perhaps too small for a full NAND Flash page and the bridges can't do SG-DMA... The initiative would IMO have to come from chipset makers (read: Intel) who could integrate an ONFI port in the south bridge. I haven't found a single hint of any initiative in that vein. There are even no stand-alone chips implementing a dedicated PCI-to-ONFI "dumb bridge". Google reveals some "ONFI silicon IP cores" from a couple fabless silicon design companies - those could be used as the ONFI part of such a bridge, if some silicon maker should decide to go that way, or maybe some are "synthesizable" in a modern FPGA.<br>
<p>
As for the basic idea, which is to "present raw NAND chips to the host system and let the host OS do the Flash housekeeping in software, with full knowledge of the gory details": clearly ONFI isn't going that way. And quite possibly, it's actually heading in precisely the opposite direction :-) There is a tendency to hide some of the gory details even at the chip interface level. On the ONFI Specs page you can find another "stand-alone paper" specifying "Block Abstracted NAND", as an enhancement to the basic ONFI 2.1 standards document. The paper is also referred back to by the ONFI 3.0 standard (where it lists BA NAND opcodes). Looks like an "optional LBA access mechanism to NAND Flash" (does this correlate with the moment SanDisk got a seat at the ONFI table, by any chance?) And in the ONFI 3.0 spec, you can find a chapter on "EZ NAND", which is to hide some of the gory details of ECC handling (at the chip interface level).<br>
<p>
Ahh well...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor429777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2011 21:35 UTC (Thu)
                               by <b>ajb</b> (guest, #9694)
                              [<a href="/Articles/429777/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Possibly it would be easier, instead of exposing the internals of the SD card, for the OS to provide computation and memory services to the SD card. This would have to be optional, because the SD card might be plugged into a cheap camera or something with no memory either. But it would be a fairly simple interface, which would not need to change based on the card internals.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2011 22:27 UTC (Thu)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/429785/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps a Java class stored on the storage card. It could implement some well-defined interface type and its constructor could take some parameters for things like a hardware interface class, memory buffer, debug logger and a few other things.<br>
<p>
It could run from userspace with the right interface class. Or from the kernel if someone wrote a simplified Java interpreter or maybe a module compiler.<br>
<p>
I suppose instead of Java it could be written in whatever VM it is that ACPI uses. Kernels already have interpreters for that.<br>
<p>
It could be fairly nifty.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor428861"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 23:54 UTC (Fri)
                               by <b>ewen</b> (subscriber, #4772)
                              [<a href="/Articles/428861/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's good news about the 2.5" SSD flash drives.  From what I'd read to date it seemed like the better ones were using decent (random read/write performance oriented) algorithms, but the cheaper ones were still using a fairly naive approach (and, eg, getting much slower as soon as all the flash cells had been written at least once).  Perhaps we're further along the "adopt the IO controller" curve this time than I thought.<br>
<p>
As you say, the (physically) smaller devices (CF/SD/etc), especially at the low cost end of the market, are always going to be constrained by available processing resources.  So maybe some sort of "direct media control" API is the most optimal answer at the low end, especially if we can avoid the worst of the "fakeraid" situation (one-OS-version-only binary blobs).  (There's also a higher risk of bricking the drive if you're moving, eg, a SD card back and forth between something doing its own low level access and something using the higher level API and firmware access.  But like the NTFS driver presumably eventually enough the details will be right that people can trust it.  And embedded devices with, eg, internal SD, can mostly ignore that risk.)<br>
<p>
Ewen<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428861/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428883"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 9:03 UTC (Sat)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/428883/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I just can't see why or who in the industry is going to have enough interests in this to "make it so".  These cards that I come across are intended for storing camera type output, creating jpg and avi files or in embedded Sat Nav systems (replacing DVD).<br>
<p>
They may be slow (and especially on writes) but for intended purpose, they're quick enough, how is there ever going to be momentum to create a market standard to convenice the small minority "enthusiast" market segment, who want to "hack" around with the hardware.<br>
<p>
The SSD drive manufacturers see peformance block I/O support for NTFS, ext3/4, xfs and eventually btrfs as a way to add value and differentiate their product.  Any alternative to the ATA interface, requires widespread software &amp; hardware support, perhaps it would have happened if Flash had the kind of marketing hoop-la &amp; attention that CPU architecture receives.  The fact is, MS tried Readyboost feature in Vista to allow flash drives for fast virtual memory, and it flopped horribly in practice as the drives weren't quick enough, and memory prices fell fast enough to throw RAM at the paging problem.<br>
<p>
Now perhaps there has been an opportunity in smart Phones and embedded  manufacturers wanting to avoid MS patent taxes on use of FAT; but again when I read around on reviews, noone talks about filesystem performance, they're getting excited by multi-core, to resolve possible latency issues which show up as "UI sluggishness".  It seems again that either the performance of the flash drive is good enough, or they've mitigated the issues in products and that becomes part of the competitive advantage.<br>
<p>
Without encumbunts needing it, who's going to develop "direct media control"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428883/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor428854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 22:49 UTC (Fri)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/428854/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;and modern drives are used with constant linear velocity.)</font><br>
<p>
I beg to differ. CAV (with zoned recording), please. You know the horrid seek times of CLV as used with CD-ROM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2011 23:44 UTC (Fri)
                               by <b>ewen</b> (subscriber, #4772)
                              [<a href="/Articles/428860/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, "zoned CAV" was what I had in mind when I wrote "constant linear velocity" for modern hard drives: the idea being that in the areas where there's more media passing under the head, you can have higher bit density than in the areas where there's less media passing under the head.  But as you point out trying to optimise this on a per-track basis is horribly counter productive.<br>
<p>
I probably should have said "semi-constant" linear velocity (the "zoned CAV" term didn't even come to mind until you pointed it out).<br>
<p>
Ewen<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor583859"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2014 3:20 UTC (Sun)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/583859/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>It's not really constant linear <I>velocity</I>, as you can't speed up and slow down the rotation of the disk platter nearly fast enough.  That's what the early CD-ROMs used to do, and seeking sucked because not only did you have to move the head, you also had to accelerate the media.  Hard drives don't do that.  The only time I hear my hard drives change rotational velocity is when I power up or power down my machine.</P>
<P>Rather, the <I>bit-rates</I> speed up at the outer edge of the disk and slow down as you move in, giving you a relatively constant areal bit density.  The platter moves with constant angular velocity (ie. 5400 RPM, 7200 RPM, what-have-you), and the bit-rate varies by zone.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/583859/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor428865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 0:57 UTC (Sat)
                               by <b>jnh</b> (subscriber, #69758)
                              [<a href="/Articles/428865/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To be fair, recent versions of util-linux are improved with respect to partition alignment.  fdisk tries to get it right.  sfdisk uses whatever units you tell it to, so you've always had to know what you're doing if you use it, and I don't think its ever had any auto-alignment logic.  Unfortunately I don't think cfdisk has been updated to take topology clues from the kernel into account yet, so there it might be fair to say it makes it hard to do partitioning correctly.  But yes, the topology info is only useful if the device doesn't lie, as the article underscores.  Hardware RAID controllers are another sore spot when it comes to all this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 10:51 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/429022/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note that for FAT filesystems, the start of the partition has very few relation with the data block alignement, because the FAT itself is located at the beginning and is of variable size (depends on the number of clusters).<br>
When I have written the FAT creation support for the Gujin bootloader, I did try to adjust and display the alignment of data clusters, there is all fields needed in the FAT superblock to leave gaps to align anything you want.<br>
Obvioulsy you should not try to *move* the whole partition and change the alignment of the first sector, even if there are tools to do so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor707076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2016 11:57 UTC (Tue)
                               by <b>Hi-Angel</b> (guest, #110915)
                              [<a href="/Articles/707076/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would device lie about the topology? That makes no sense: the information exposed for a reason, so that somebody could use it. If for whatever reason the manufacturer didn''t want to expose the topology, wouldn't they just, well, not expose the info?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/707076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor428870"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">thanks, NTFS and utils</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 1:27 UTC (Sat)
                               by <b>pflugstad</b> (subscriber, #224)
                              [<a href="/Articles/428870/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
First and foremost, thank you for an excellent article.  This is why I pay for LWN and it's payed off again.  <br>
<p>
I would think that with more and more systems using WinXP/Vista/7, many of these drives would start optimizing for NTFS instead of FAT, especially the higher-end SSDs.  I don't know anything about NTFS, but presumably it doesn't have the same access pattens as FAT.  I believe it has a log like ext3, right?  Is this happening, or is that what the "data logging" drives are doing?  Anyway to tell other than by testing which algorithms a drive uses?<br>
<p>
Are there utils available for testing the layouts of drives and trying to optimize them for your usage pattern.  Even something like whatever scripts were created to create the plots from this article would be useful I think.  At a minimum, they can help you identify drives that are not optimized in a useful way. <br>
<p>
Finally, other than optimizing partitioning and layout, are there benefit to using a filesystem such as logfs, jffs2, etc?  (hmmm... can one even use them with a block device?)<br>
<p>
Again, thanks for the article. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428870/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">thanks, NTFS and utils</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 9:04 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/428885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the extreme low end (SD cards, specifically), NTFS does not help because the SD card standard mandates not only the exact type of file system to be used (FAT16 up to 2 GB, FAT32 from 4 to 32 GB, ExFAT from 64 GB to 2 TB), but also the specific layout.<br>
<p>
For USB sticks, the situation may be a little better because I've seen ads for ones that are allegedly optimized for NTFS. I have yet to get hold of those to find out what they do.<br>
<p>
On the negative side, I have seen one USB stick with the typical FAT optimization (the second 4 MB segment being optimized for random access), which came preformatted with the FAT in another segment.<br>
<p>
Regarding logfs, in theory it should be really well optimized for SSDs and it can work on a block device. Unfortunately, it's designed on the assumption that you can have around a dozen segments open at a time, which I have shown not to be possible on most media. However, if you can get the alignment and the layout right, logfs should still give you the best possible performance of the drive as long as you don't do a single fsync, at which point it will theoretically get into the worst case of thrashing.<br>
<p>
jffs2 is completely useless on multi-gigabyte media, and does not really work on block devices.<br>
<p>
ubifs on top of ubi on top of mtd on top of block2mtd on top of the block device might be an option, but stacking so many layers sounds scary to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor428872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Monitoring wear leveling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 2:20 UTC (Sat)
                               by <b>ayers</b> (guest, #53541)
                              [<a href="/Articles/428872/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I keep wondering whether there is a standard interface (SMART attribute?) which measures/monitors the wear leveling to indicate when it's time to replace the SSD/SD cards before the risk of data loss exceeds some probability.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Monitoring wear leveling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 0:47 UTC (Sun)
                               by <b>rwa</b> (subscriber, #69887)
                              [<a href="/Articles/428936/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Well not really standard but Intel SSDs support something like this. This is from one of our build servers:
<pre>
ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
  3 Spin_Up_Time            0x0020   100   100   000    Old_age   Offline      -       0
  4 Start_Stop_Count        0x0030   100   100   000    Old_age   Offline      -       0
  5 Reallocated_Sector_Ct   0x0032   100   100   000    Old_age   Always       -       11
  9 Power_On_Hours          0x0032   100   100   000    Old_age   Always       -       3516
 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       26
192 Unsafe_Shutdown_Count   0x0032   100   100   000    Old_age   Always       -       11
225 Host_Writes_32MiB       0x0030   200   200   000    Old_age   Offline      -       715312
226 Workld_Media_Wear_Indic 0x0032   100   100   000    Old_age   Always       -       3701
227 Workld_Host_Reads_Perc  0x0032   100   100   000    Old_age   Always       -       1
228 Workload_Minutes        0x0032   100   100   000    Old_age   Always       -       16928063
232 Available_Reservd_Space 0x0033   099   099   010    Pre-fail  Always       -       0
233 Media_Wearout_Indicator 0x0032   096   096   000    Old_age   Always       -       0
184 End-to-End_Error        0x0033   100   100   099    Pre-fail  Always       -       0
</pre>
The wearout indicator (233) started ad 100 and is no at 96 after writing 21TB in almost 5 Months. It's an 160GB X-25M from Intel.
      
          <div class="CommentReplyButton">
            <form action="/Articles/428936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor428942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Monitoring wear leveling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 3:33 UTC (Sun)
                               by <b>dougg</b> (guest, #1894)
                              [<a href="/Articles/428942/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
# smartctl -a /dev/sda<br>
...<br>
Model Family:     Intel X18-M/X25-M/X25-V G2 SSDs<br>
...<br>
  9 Power_On_Hours          0x0032   100   100   000    Old_age   Always       -       1028<br>
...<br>
233 Media_Wearout_Indicator 0x0032   099   099   000    Old_age   Always       -       0<br>
...<br>
<p>
No need to wonder.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor428874"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Firmware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 3:02 UTC (Sat)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/428874/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Firmware is top of the list of why we can't have nice things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428874/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor428891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Superb article</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 12:01 UTC (Sat)
                               by <b>kragilkragil</b> (guest, #72832)
                              [<a href="/Articles/428891/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I really hope most of the important kernel hackers have a LWN subcription.<br>
 BTW Does Linus read LWN?<br>
<p>
I think my 2 year old EeePC 901 will get a better second life when this work will be included in 2.6.39.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor428910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 18:32 UTC (Sat)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/428910/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm most interested in this in concerns of speeding up my general, fairly vanilla desktop system.  To wit, it'd be nice to grab a couple of 8GB or 16GB USB2 keys, and do something nice with them.<br>
<p>
Different parts of the filesystem have different access patterns - /etc ,  /bin , /sbin , and /usr are like 99% read, /tmp , /var , and /home are a lot of read/write mix, and something with swap would be nice too.<br>
<p>
What actually works for this if someone wanted to do something along these lines?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 19:24 UTC (Sat)
                               by <b>Richard_J_Neill</b> (subscriber, #23093)
                              [<a href="/Articles/428913/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's important to analyse this correctly: how much of the workload is<br>
  - first-time reads (at boot, or new data)<br>
  - cached reads<br>
  - in-principle-cached reads (if you had enough RAM)<br>
  - writes<br>
<p>
In terms of speeding up a Linux desktop system, the key benefit is going to arise from lots of RAM (8GB or more) to make perfect use of the filesystem cache. This won't speed up boot, but after a few day's uptime, all the apps will be starting from memory. USB flash disks really won't get you much. After that, the next important thing is to use ext4 (with relatime) rather than ext3. <br>
<p>
USB flash devices are great for low-cost, low-power, small size, silent systems. But they are still terrible for writes. Also, swap isn't something for "normal" use anymore: it's there so that when you run right out of RAM, your system doesn't OOMkill an app, but just gets very slow instead. So don't worry about it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 2:23 UTC (Sun)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/428938/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
*meh*<br>
<p>
Since I only *have* 4GB, and most of my apps seem to want to alloc it all and let none of it go, I'm usually filling up 2GB of swap on top of the RAM every day or two.<br>
<p>
So basically, what you're saying is that flash keys will remain the floppy disks of our age.<br>
<p>
I really wish I could turn off caching on some files - there's no good reason to read-cache an MP3 or video file - it's going in and out of the app, and pretty much wastes memory when it's done so.<br>
<p>
Frankly, I'm not sure it's worth going to 8GB of RAM - I'd have to move to 64-bit code, which from what I can tell, takes at least twice as much (and sometimes more) RAM to execute in with all of its alignment issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 2:33 UTC (Sun)
                               by <b>Richard_J_Neill</b> (subscriber, #23093)
                              [<a href="/Articles/428940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, if you are stuck with 4 GB only (and presumably 32-bit), the there might be some mileage in putting swap on USB keys - but may I advise you to RAID-1 them: (and use different root controllers). <br>
<p>
Incidentally, yes, 64-bit is worth having: it allows lots more RAM, it allows apps to *map* more than 4GB, and the architecture, though wasting some space on larger pointers, has more registers, so it's still a win.  It also lets firefox address 8GB of swap (this is purely for memory leaks, so it doesn't matter that it's slow: fx merely has to write the data successfully, it will never read it again).<br>
<p>
As for caching files, you *might* be able to do it with mplayer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor428951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 13:45 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/428951/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>I really wish I could turn off caching on some files - there's no good reason to read-cache an MP3 or video file - it's going in and out of the app, and pretty much wastes memory when it's done so.</blockquote>
<p>
It takes code changes, but posix_fadvise() takes a POSIX_FADV_NOREUSE which may be useful for mpg123 et al (if indeed they are actually using most of the data only once: I don't know enough about media formats to know if this is true). But mpg123 doesn't use it... and the kernel doesn't use it either. Oops.
      
          <div class="CommentReplyButton">
            <form action="/Articles/428951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 19:32 UTC (Mon)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/429074/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, oops.<br>
<p>
I'm looking at the fact that by far, the thing slowing my system down the most is my hard drives.  And looking at the specs of the newer hard drives, I'm not seeing any real advances in anything *BUT* capacity, and maybe in really large reads/writes.<br>
<p>
But the myriad of little reads and writes from Gnome/KDE putting snippets of XML into individual files, the .cache directory, the web browser and it's plethora of relatively tiny files, the often-times widely scattered reads and writes of swap...<br>
<p>
These are getting no loving what so ever.  Meanwhile, everyone's saying just add RAM.  Except my motherboard only goes up to 8GB of RAM, and I'm not so sure that's really going to improve things that much.<br>
<p>
And I'm caching stuff that it doesn't seem to make sense to - multi-megabyte audio files, half-gigabyte and up video files - and once a program allocates itself some RAM, it *SURE* doesn't seem to want to give it up.  (Of course, this is really hard to be sure of, because any long time linux user will tell you that the memory columns in ps don't really mean anything useful, and when you dig further - it's hard to be sure the *KERNEL* knows what memory belongs to who - although it does do a good job of cleaning up after the application crashes, so it knows *SOMETHING*.)<br>
<p>
So why not a two-pronged approach.  A file-system bit, like the sticky bit used to be to force caching of some kind (Linux nearly ignores it, apparently) - but to tell the kernel that said file is *NOT* to be cached.  With /etc/ , /bin, etc all on a flash drive, there'd really be little reason to cache them, so you could mark them so - and you could also mark media files likewise, and not need to change the apps.  There could be a flag for opening the file to force caching of it (though I'm not sure I can see why), allowing user space to handle things as it feels the need, but if it doesn't, the mostly right thing happens anyway.  updatedb - would use the call to open *EVERYTHING* in non-caching mode, vlc wouldn't need to worry about it - could do its own limited caching it needs to operate - since it could assume media files wouldn't be cached if the user doesn't want them to be - while other programs could say cache it - even if it doesn't think it needs to be.<br>
<p>
And for that matter - does the OOM killer create its own swap for some reason?  I turned off swap a few minutes ago, after a reboot, opened some memory hogs, and when memory filled up (according to XOSview - I'm sure not the most accurate system meter, but it sure makes sense to me!), I got *MASSIVE* hard drive I/O, which pretty much tied the whole system into knots for well over 15 minutes (before I gave X it's version of the vulcan nerve pinch - took it another 5 to recognize *THAT*).  What was the hard drive doing thrashing, since there was no designated swap for memory to be pushed off to temporarily?<br>
<p>
I'm going to admit it here - I'm a Linux *USER*.  I can - and have - done make clean ; make ; make install to build a kernel, or to install a program that didn't have a convenient package (and why can't I, as a user, install a package to *my* home directory, instead of having to go to root and install it system wide?  I know, I wander off topic...)  I just want a machine that runs nicely.  The recent bit that does some kind of ulimiting per console (some kind of easy kernel patch, that someone else showed could be almost as easily done with a few lines in .bashrc ?) helped a fair bit - but still, every day I gnash my teeth as I wait for my hard drives to catch up with everything else.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 19:44 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/429083/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You won't be seeing slowdowns from writes unless a lot is being written or you are terribly short of memory, as they can always be cached and written back later. It's blocking for reads that's killing you.<br>
<p>
The best way to speed up reads on current systems is probably to use RAID: add lots of disks and reads speed up enormously, given a fast enough bus (at a cost in write speed). e.g. my four-way RAID-5 here combines four fairly slow low-power disks to given an aggregate read speed between 190Mb/s and 250Mb/s. That knocks the socks off any single disk: even high-speed ones at the fast outer edge of the disk are slower than this RAID array is at the slow inside.<br>
<p>
It might also be worth trying cachefs, caching onto a USB key (and not caching the filesystem on which your media files are located), but I'm not sure that this will actually gain you anything. (Worth trying though.)<br>
<p>
If you turn off swap and the system is already short of memory performance will hit a wall, because all of a sudden rarely used but dirtied pages of non-file-backed memory *have* to be held in RAM, rather than being swapped to disk once and forgotten about. (glibc creates several hundred Kb of these for every program that might use locales, which pretty much means anything that calls printf(), i.e. everything). So all of a sudden your available memory plunges and lots of frequently-used but read-only pages of program text get forced out of memory, leading to major thrashing as they get pulled back off disk all the time. (So you will probably find iostat and/or blktrace reporting major *reads* in this situation, but not major *writes*.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 21:58 UTC (Mon)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/429095/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How do you tell Linux not to cache a filesystem?  I can't find it in mount options.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429116"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 0:24 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/429116/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This isn't about the page cache. I was talking about FS-Cache, which is a separate filesystem layer which can be used to cache other filesystems on local media (such as, well, flash drives, or, more often, hard drives).<br>
<p>
-- unfortunately it needs specific support for each filesystem, and it doesn't look like this has been added for any non-networked filesystems. Curses.<br>
<p>
(See Documentation/filesystems/caching/.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429116/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor429165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 10:22 UTC (Tue)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/429165/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; once a program allocates itself some RAM, it *SURE* doesn't seem to want to give it up.</font><br>
<p>
A program's allocations tend to be too fragmented, so functions like free() usually do not even try to give the memory back to the OS.<br>
<p>
<font class="QuotedText">&gt; Of course, this is really hard to be sure of, because any long time linux user will tell you that the memory columns in ps don't really mean anything useful, and when you dig further - it's hard to be sure the *KERNEL* knows what memory belongs to who - although it does do a good job of cleaning up after the application crashes, so it knows *SOMETHING*.</font><br>
<p>
The biggest problem are shared libraries; the kernel knows who uses them, but it's not clear how their memory should be counted. (Which process gets charged for that memory? And when it exits, does the memory usage of the other processes suddenly increase?)<br>
<p>
<font class="QuotedText">&gt; What was the hard drive doing thrashing, since there was no designated swap for memory to be pushed off to temporarily?</font><br>
<p>
Normal data can get swapped out, if there is swap.<br>
Code from executable files does not need to be saved to swap because it can be reloaded from the executable file. In other words, every executable file is a read-only swap file.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2011 21:39 UTC (Fri)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/429921/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The biggest problem are shared libraries; the kernel knows who uses them, but it's not clear how their memory should be counted. (Which process gets charged for that memory?</font><br>
<p>
Look at the PSS figures in /proc/PID/smaps file.<br>
<p>
Nice tool for that could be e.g. smem: <a href="http://www.selenic.com/smem/">http://www.selenic.com/smem/</a><br>
<p>
(You can just apt-get it and then do "smem --pie=name".)<br>
<p>
<p>
<font class="QuotedText">&gt; And when it exits, does the memory usage of the other processes suddenly increase?)</font><br>
<p>
If you're looking at PSS figures, yes.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor429198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Installing to your home drive</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 13:46 UTC (Tue)
                               by <b>pflugstad</b> (subscriber, #224)
                              [<a href="/Articles/429198/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
(and why can't I, as a user, install a package to *my* home directory, instead of having to go to root and install it system wide? I know, I wander off topic...)
</blockquote>
<pre>
$ ./configure --prefix=/my/home/dir 
$ make
$ make install 
</pre>
Beyond this, you need to dig into the Makefile (or whatever the build utility is) to figure out how it's installed.  Very often there is a install_prefix variable of some kind.  
      
          <div class="CommentReplyButton">
            <form action="/Articles/429198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Installing to your home drive</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 18:15 UTC (Tue)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/429298/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point was to install a *package*. To my knowledge no widely used package manager allows per-user package installation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Installing to your home drive</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2011 5:45 UTC (Wed)
                               by <b>idupree</b> (guest, #71169)
                              [<a href="/Articles/429387/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most package managers offer binary (already-compiled) packages.  Most Linux/Unix software can't have its prefix changed *after* compilation.  Everyone's user directory has a different path (thus, prefix).  Thus, problems.<br>
<p>
Options I've heard of &amp; played with: GoboLinux's "Rootless" project is a system for installing from source in your home directory (on any distro).  ZeroInstall I believe does source and binary (not sure how it manages binary) without root privileges.  Some NixOS research has looked into rewriting the paths in compiled packages (though not changing its total-number-of-characters length).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Installing to your home drive</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2011 9:34 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/429401/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, gnulib contains support code to make 'relocatable packages' work (by looking at argv[0], or, if this contains no path, by hunting along $PATH to find itself, then using relative paths everywhere in the knowledge of the location of the binary). GCC has worked this way for ever, but it's only fairly recently that relocatable support has started to find its way into other GNU programs. (Most non-GNU programs still don't care, but the GNU Project cares about keeping its stuff installable into people's home directories on random systems: that's how it started, after all.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor429495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Installing to your home drive</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2011 19:08 UTC (Wed)
                               by <b>talex</b> (guest, #19139)
                              [<a href="/Articles/429495/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>ZeroInstall I believe does source and binary (not sure how it manages binary) without root privileges.</blockquote>
<p>
In my experience (0install developer), a surprising number of programs are relocatable:

<ul>
<li> Anything that's been ported to Windows or Mac will be relocatable.
<li> Anything that encourages non-technical end-users to download beta versions will be relocatable.
<li> Things written in languages with built-in string concatenation (i.e. anything except C) are usually relocatable.
<li> Libraries always seem to be relocatable (not sure why this is; maybe to allow them to be bundled with other relocatable programs?).
</ul>

There were a few suggestions for supporting non-relocatable programs (e.g. using Plash to adjust paths at runtime, Klik-style binary rewriting, etc) but there don't seem to be many programs that need it these days.
      
          <div class="CommentReplyButton">
            <form action="/Articles/429495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429559"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Installing to your home drive</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2011 22:36 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/429559/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Libraries always seem to be relocatable (not sure why this is; maybe to allow them to be bundled with other relocatable programs?).
</blockquote>
That is definitely not always true. The KDE3 libraries, for instance, were not relocatable: they had $datadir and $libdir/kde3 baked into them. (I think the same is true of glib and gtk as well.)

      
          <div class="CommentReplyButton">
            <form action="/Articles/429559/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor429906"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2011 19:22 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/429906/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
How do you know you're caching these files?  I don't know exactly what Linux's page replacement policy is this week, but I'd be surprised if it caches video and music files.  It knows you're accessing these pages only once, so keeping them around in preference to something else would be a loss.  It usually takes two accesses to a page to get it any significant priority for memory allocation.  Linux also knows you're accessing the file sequentially, so it knows even sooner that it otherwise would that the pages won't be accessed a second time.
<p>
Of course, if there's absolutely nothing else worth using memory for, Linux will just go ahead and fill it with this data, just in case.  But that's not a problem.

      
          <div class="CommentReplyButton">
            <form action="/Articles/429906/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor429021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 10:06 UTC (Mon)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/429021/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the key benefit is going to arise from lots of RAM (8GB or more)</font><br>
<p>
At the price of slower suspend/resume and (slightly) increased power consumption. Also, it will speed things up "eventually", but will do nothing for you if you just turn on your computer for some quick lookups and turn it off again.<br>
<p>
No, it has to be a better way. <br>
<p>
If cheap flash cards are weak at writting but great at seeking and reading, why not use them for small sparingly written files?. I think /usr and /etc would be good candidates.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 11:50 UTC (Mon)
                               by <b>mgedmin</b> (subscriber, #34497)
                              [<a href="/Articles/429025/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The speed of suspend-to-RAM doesn't change with the amount of memory you have, as far as I know.  Did you mean suspend-to-disk aka hibernation?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429034"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 14:36 UTC (Mon)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/429034/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I meant hibernation, but I was not sure of the term for the reverse process (un-hibernation? thaw?) so I used the generic suspend/resume.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429034/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor428920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2011 20:57 UTC (Sat)
                               by <b>nhippi</b> (subscriber, #34640)
                              [<a href="/Articles/428920/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good article but I think we are settling for too little. We shouldn't accept a situation where you can<br>
<p>
1) buy cheap sd/cf/sata nand drives where you have to second guess how the card expects things to be written on it - basically trying forcing use to make our FS access look like FAT access. <br>
<p>
2) buy very expensive ssd drives where the said price is justified by embedded controller code that tries to guess what the host computer is trying to write and distributing it to the proprietary filesystem on the ssd drives cheap NAND chips.<br>
<p>
Instead, we should press to sd/sata standards to include a raw (or semiraw) NAND access channel.<br>
<p>
Else we'll get stuck, like in the BIOS/ACPI world, emulating windows behaviour.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor428939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 1:18 UTC (Sun)
                               by <b>rwa</b> (subscriber, #69887)
                              [<a href="/Articles/428939/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some time ago as I was pondering buying an SSD and while researching I came across the following two posts in Ted Ts'o blog:<br>
<p>
<a href="http://thunk.org/tytso/blog/2009/02/20/aligning-filesystems-to-an-ssds-erase-block-size/">http://thunk.org/tytso/blog/2009/02/20/aligning-filesyste...</a><br>
<a href="http://thunk.org/tytso/blog/2009/03/01/ssds-journaling-and-noatimerelatime/">http://thunk.org/tytso/blog/2009/03/01/ssds-journaling-an...</a><br>
<p>
The posts are from 2009 but are still interesting - including the numerous comments.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428950"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 13:37 UTC (Sun)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/428950/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ted has many great posts on this topic, also <a href="http://thunk.org/tytso/blog/2009/02/22/should-filesystems-be-optimized-for-ssds/">http://thunk.org/tytso/blog/2009/02/22/should-filesystems...</a> is really worth reading.<br>
<p>
There are two pieces of information that I only found during my research that he evidently also didn't know about:<br>
<p>
* Erase blocks are much larger these days than they used to be. Traditionally, erase blocks have always been 128 KB, but now they are effectively 4 MB in most cases (2 MB physical erase blocks with multi-plane accesses).<br>
<p>
* The question whether you should use ext3, ext2 or btrfs for best performance is highly media dependent. Ted showed that there was no performance penalty for ext3 over ext2 on his SSD, but for media with fewer open segments, the answer can be different. This is one area that I still need to analyze further.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428950/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor428946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux filesystems for cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 9:33 UTC (Sun)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/428946/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Is it possible to hack a special &ldquo;cheap flash mode&rdquo; into filesystems such as ext3/ext4/btrfs?
<p>
Such a mode could e.g. move the log + inode table + allocation bitmaps etc. to the "FAT" segment (either breaking the info apart from the block groups or maybe even using a single block group for the entire device).  Plus it could set the block size to the expected FAT cluster size (after all, these filesystems do know how to use block sizes != page size). Possibly other optimizations can be applied.
      
          <div class="CommentReplyButton">
            <form action="/Articles/428946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor428952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux filesystems for cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2011 13:47 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/428952/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds like a good idea, as many of the rationales for positioning most of these things in the middle of the disk is to reduce seek time, which hardly matters on an SSD.<br>
<p>
One downside, though: I suspect the FAT segment is (much) too small.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/428952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux filesystems for cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 13:15 UTC (Mon)
                               by <b>mchazaux</b> (guest, #64024)
                              [<a href="/Articles/429030/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Then do the opposite : add UID, GID, permissions and such to a FAT-like filesystem ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux filesystems for cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 15:21 UTC (Mon)
                               by <b>giggls</b> (subscriber, #48434)
                              [<a href="/Articles/429038/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One apon a time there has been the UMSDOS filesystem which did exactly this. I'm unaware if this is still available in current kernels though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux filesystems for cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 19:36 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/429082/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, it was removed some years ago.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor429081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux filesystems for cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 19:37 UTC (Mon)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/429081/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not, see the discussion about. I think we can do much better than FAT as well, even given the characteristics of the current drives. Ted Ts'o has some ideas for ext4, and my understanding of btrfs is that it does not rely on a specific block allocation at all, so that could be an excellent target as well.<br>
<p>
Starting out a completely new file system designed only for SD cards would of course make it possible to get the best result, but that would also be an enormous amount of work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor429013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 7:56 UTC (Mon)
                               by <b>HBM</b> (guest, #72284)
                              [<a href="/Articles/429013/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I really would hope that some Industry Consortium (like Linaro) pushes for more sane Smartcard Filesystems instead of fixing the stuff afterwards. I mean using FAT for flash storage seems pretty awkward to me.<br>
<p>
Besides having a abstraction layer for naked flash in kernel seems like a good idea. So shoving this stuff into the propretary firmware layer doesn't sound like a good idea to me.<br>
<p>
Tim<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 19:18 UTC (Mon)
                               by <b>xxiao</b> (guest, #9631)
                              [<a href="/Articles/429077/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I second this idea, SD cards are increasingly used in various embedded devices these days. I'm comparing various SD(SLC and MLC) using different file systems, the result is pretty random so it's hard to find the best SD with the best filesystem easily for certain applications these days.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2011 19:43 UTC (Mon)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/429084/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please contact me by email about your test work. It would be very good to correlate these high-level benchmarks with the low-level measurements that I started on <a href="https://wiki.linaro.org/WorkingGroups/KernelConsolidation/Projects/FlashCardSurvey">https://wiki.linaro.org/WorkingGroups/KernelConsolidation...</a> .<br>
<p>
Also everyone else, if you have a lot of SD cards or USB sticks, please run flashbench on it and send me the results.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor429128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Put the smarts in mkfs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 2:19 UTC (Tue)
                               by <b>sethml</b> (guest, #8471)
                              [<a href="/Articles/429128/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me it's always seemed like the best solution would be allowing raw flash access, but I've come to accept that anything which requires mass industry cooperation has roughly zero chance of happening. <br>
<p>
Now I think a practical good approach would be to tune the filesystem to the device. In particular, give, say, ext4 the ability to store various device characeristics (erase block size &amp; alignment, any good region of the partition for frequently-changing data, max concurrently open sectors, etc.) in the filesystem header, and then have the kernel filesystem code tune its accesses to work well with the limitations of the device. Then add a flag to mkfs and tunefs which cause them to spend a few minutes benchmarking the device and heuristically deciding what the device characteristics are. <br>
<p>
Even better of course would be to combine this approach with a log-structured fs, to really avoid the weaknesses of the hardware. <br>
<p>
Not perfect, but a heck of a lot more likely to be useful than petitioning device manufacturers to do anything different.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor429152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">partitioning tools</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2011 8:38 UTC (Tue)
                               by <b>rh-kzak</b> (guest, #51571)
                              [<a href="/Articles/429152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
fdisk supports partitions alignment according to I/O limits since util-linux[-ng] 2.17 (Jan 2010).<br>
<p>
fdisk ***does not use CHS addressing by default*** and it uses 1MiB grain for partitions since util-linux[-ng] 2.18 (Jun 2010).<br>
<p>
GNU Parted was also updated also one year ago.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor429403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Partitioning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2011 9:50 UTC (Wed)
                               by <b>shane</b> (subscriber, #3335)
                              [<a href="/Articles/429403/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Arch Linux distribution recommends using GPT for partitioning on the wiki:<br>
<p>
<a href="https://wiki.archlinux.org/index.php/Solid_State_Drives#Partition_Alignment">https://wiki.archlinux.org/index.php/Solid_State_Drives#P...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor429658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Partitioning</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2011 10:20 UTC (Thu)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/429658/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. Both the gdisk recommended there and the new fdisk mentioned by rh-kzak align partitions to 1 MB, which is much better than what the old fdisk does in many current distros.<br>
<p>
However, the alignment should really be 4 MB or higher, not 1 MB, at least on the low-end devices. I hope to get optimizations for 4 MB segments into btrfs, ext4 and other file systems, but they can only work if the file system is fully aligned.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor429664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2011 10:43 UTC (Thu)
                               by <b>jond</b> (subscriber, #37669)
                              [<a href="/Articles/429664/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When comparing filesystem performance, should Lvm be considered separately? I'm guessing it makes alignment Guarantees even more difficult or impossible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor429869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flash memory and partionning &quot;optimization&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2011 15:29 UTC (Fri)
                               by <b>meuh</b> (guest, #22042)
                              [<a href="/Articles/429869/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Is there any Flash devices using the "offset by one" trick used by some 4KBytes hard drives to get logically aligned on 255/63 partitions be physically on 4KBytes boundary, as reported on 
<a href="https://ata.wiki.kernel.org/index.php/ATA_4_KiB_sector_issues#S-1._Yet_another_workaround_from_the_firmware_-_offset-by-one.">
https://ata.wiki.kernel.org/index.php/ATA_4_KiB_sector_issues#S-1._Yet_another_workaround_from_the_firmware_-_offset-by-one.</a>

      
          <div class="CommentReplyButton">
            <form action="/Articles/429869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor431595"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2011 12:12 UTC (Sun)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/431595/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="http://blog.datalight.com/why-raw-nand-flash-with-hardware-based-ecc-is-the-way-to-go">http://blog.datalight.com/why-raw-nand-flash-with-hardwar...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/431595/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor431616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2011 18:06 UTC (Sun)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/431616/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All true but, until someone defines a workable API/ABI/software interface, it's never going to happen.<br>
<p>
Consider the esoteric optimization features that he mentions...  If the engineers writing the low-level API didn't anticipate multiplane access then unmanaged will still be slower than managed.<br>
<p>
Is anyone out there actually trying to write a high-performance, low-level Flash API that's intended to displace SSD controllers?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/431616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor439425"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Optimizing Linux with cheap flash drives</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2011 13:47 UTC (Wed)
                               by <b>Thom</b> (guest, #73471)
                              [<a href="/Articles/439425/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
By interface, do you mean a generic read and write that can handle the vagaries of all sorts of flash parts? Or do you mean a driver to handle the flash properly?<br>
<p>
Datalight's solution is the latter. By working with Flash vendors and creating custom Flash Interface Modules, our Flash Management software utilizes the optimizations of each flash part. This blog post calls for what ONFI specified as EZ-NAND, and the Datalight solution supports those modules also. A fully supported on-die ECC of chips like ClearNAND, plus Wear Leveling and Bad Block Management, both visible and customizable, is truly the best of both worlds.<br>
<p>
In order to displace an SSD controller, much more than throughput and endurance have to be considered - for example, hardware compression, or aggressive caching. With the right file system support, JEDEC's eMMC might be the best opponent for an SSD.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/439425/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor431603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Utility to find ideal blocksize.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2011 15:05 UTC (Sun)
                               by <b>gmatht</b> (subscriber, #58961)
                              [<a href="/Articles/431603/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If anyone in interested I wrote a utility to help detect the ideal blocksize and alignment for writing to a device (particularly cheap flash devices). It allows you to set the read pattern, blocksize, and offset (the offset may be useful on drives that correct for XP's weird alignment of partitions); it will then benchmark writes with those settings.<br>
   <a rel="nofollow" href="http://dansted.co.cc/scripts/detectblocksize.c">http://dansted.co.cc/scripts/detectblocksize.c</a><br>
<p>
For example, I found on my device if we write sequentially, writing of blocks of 64K is sufficient to maximize the data transfer rate, while if blocks are written randomly, 4MB is required.<br>
<p>
This utility was discussed on the linux-bcache list, but the old mail archives don't seem to be on the web. I could discuss this further if anyone is interested.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/431603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Utility to find ideal blocksize.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2011 15:50 UTC (Wed)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/432377/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The results you found are very typical, and match what the flashbench tool referenced in the last sentence of the article finds on many media. The other interesting number is how many (4MB) segments can be written to alternating, which you can find out with<br>
<p>
flashbench --open-au --open-au-nr=&lt;NR&gt; --erasesize=$[4096 * 1024] [ --random ]<br>
<p>
with varying values for NR. With low numbers, it will be fast for all block sizes, while with large numbers of open segments, the time to write all segments is basically independent of the block size, because every write forces a garbage collection on one of the other open segments.<br>
<p>
There is usually a very sharp contrast between the slow and fast results, e.g. five being very fast but six already being very slow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
