        <!DOCTYPE html>
        <html lang="en">
        <head><title>Progress on toolchain security features [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/996344/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/997294/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/996344/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Progress on toolchain security features</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>November 12, 2024</br>
           <hr>
<a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2024">LPC</a>
</div>
<p>
Over the years, there has been steady progress in adding security features to
compilers and other tools to assist with hardening the Linux kernel (and, of course, other
programs).  In something of a tradition in the <a
href="https://lpc.events/event/18/sessions/180/#20240918">toolchains
track</a> at the <a
href="https://linuxplumbersconf.org">Linux
Plumbers Conference</a>, Kees Cook and Qing Zhao have led a session on that progress and
further plans; this year, they were joined by Justin Stitt  (<a
href="https://www.youtube.com/watch?v=68PZz_9cPms">YouTube video</a>).
</p>

<h4>Rust</h4>

<p>
Cook said that he would begin by talking about Rust, rather than sprinkling it throughout the
talk, as he has in the past.  It seemed easier, he said, to
handle all of the Rust information on a single slide (<a
href="https://outflux.net/slides/2024/lpc/features.pdf">slides</a>).  It is
important to maintain parity between the security features of the GCC,
Clang, and Rust compilers in order to avoid <a
href="https://www.ndss-symposium.org/ndss-paper/auto-draft-259/">cross-language
attacks</a>.   To that end, the arm64 software-based shadow
call stack for Rust is <a
href="/ml/all/20240826-shadow-call-stack-v6-1-495a7e3eb0ef%40google.com/">getting
close</a> to being ready to merge into the kernel. 
Kernel <a
href="https://en.wikipedia.org/wiki/Control-flow_integrity">control-flow-integrity</a>
(CFI) support for Rust is also <a
href="https://github.com/rust-lang/rust/issues/123479">in progress</a>; it
is forward-edge protection against subverting indirect calls.
</p>

<p>
There are several things that have not really been looked at yet, including
zeroing registers used in calls and making <a
href="/Articles/722293/">structure layout randomization</a> work with Rust.  Cook
said that the <a href="/Articles/936728/"><tt>__counted_by()</tt>
attribute</a>, which is used to provide bounds information for flexible arrays, needs
some investigation to see how it interacts with Rust code.  He thinks that
the information provided by <tt>__counted_by()</tt> will already be
represented in the Rust bindings, so there will not be a need for any
explicit handling on the Rust side, but that should be confirmed.  
</p>

<p>
While Rust has native arithmetic-overflow handling, there is still not
parity with the behavior of the C code.  When an overflow occurs, the <a
href="https://www.kernel.org/doc/html/v4.19/dev-tools/ubsan.html">undefined
behavior sanitizer</a> (UBSAN) gives a different result than Rust does;
"<q>it would be nice to have <i>one</i> result</q>". 
</p>

<h4>Counted by</h4>

<p>
Moving on, the "<q>big news from the last year</q>" was all of the work done for
<tt>__counted_by()</tt>, which identifies a structure member that is tracking
the size of a flexible array in the structure.  Once the support for the
attribute landed in GCC and Clang, annotations needed to be added to the
kernel, which has been done for 391&nbsp;structures.  People are adding more of
these all the time, he said, and he hopes that it is becoming the default
for any new flexible arrays.
</p>

<a href="/Articles/997847/">
<img src="https://static.lwn.net/images/2024/lpc-cook-sm.png" border=0 hspace=5 align="right"
alt="[Kees Cook]" title="Kees Cook" width=229 height=280>
</a>

<p>
Something that was "<q>kind of a footnote</q>" in last year's update (<a
href="https://www.youtube.com/watch?v=OEFFqhP5sts">YouTube video</a>) has
been fixed in both GCC and Clang.  Due to some odd differences between the
C language specification and the compilers, <a
href="https://gcc.gnu.org/pipermail/gcc/2023-May/241426.html">unions could
contain flexible arrays</a>, as long as they specified <tt>[0]</tt> for the
size, because of GCC and Clang extensions to handle that case.  "<q>Sort of
accidentally</q>", flexible
arrays are  not supposed to be allowed in unions at all, according to the specification, though.  Meanwhile, removing
the zero from the size specification (leaving just <tt>[]</tt>), in
order to modernize the code, has been part of the flexible-array cleanup
work, but doing so in unions would not compile because of the
specification.  Now, modern flexible-array declarations will be accepted by
the extensions, which "<q>will simplify some really horrible hacks</q>" in
the kernel to work around the problem.
</p>

<p>
Next up was a slide showing the progress on getting flags for setting the
stack-protector-guard location added to GCC and Clang for five different
architectures; this will allow having different <a
href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">stack
canaries</a> for each process.  He had planned to talk about the lack of
progress for Clang on the RISC-V and PowerPC architectures over the last
four years, as all of the other architecture-compiler combinations have
been completed, but he had "<q>accidentally nerd-sniped</q>" Keith Packard
into fixing those holes, so that work is now in progress. "<q>My goal is
to not have to show this slide next year</q>", he said with a chuckle.
</p>

<h4>Control-flow integrity</h4>

<p>
There is work needed on the forward-edge CFI support, since no progress has
been made on that over the last year.  The support for hardware CFI protection
is basically done, and has been for a while, but the more fine-grained,
per-function-prototype software-based CFI protection needs to be added to
GCC.  Zhao said that she had talked with some RISC-V developers at <a
href="https://gcc.gnu.org/wiki/cauldron2024">GNU Tools Cauldron</a> who are
working on GCC support, starting from the <a
href="/ml/all/20230325081117.93245-1-ashimida.1990@gmail.com/">arm64 patch
set</a> that Cook had mentioned; some of that work may be applicable beyond
RISC-V.  Packard suggested that the arm32 <a
href="https://developer.arm.com/documentation/109576/0100/Pointer-Authentication-Code/Introduction-to-PAC">pointer
authentication code</a> (PAC) extension could be used for CFI protection on
that architecture; Cook was not opposed, but arm32 is not a major area of
focus for him.
</p>

<p>
Similarly, backward-edge CFI has stalled since last year.  The hardware
support exists for both x86 and arm64.  Getting x86 hardware support for
shadow call stacks to be used internally by the kernel looks difficult,
though Peter Zijlstra said that the Intel <a
href="https://docs.kernel.org/arch/x86/x86_64/fred.html">Flexible Return
and Event Delivery</a> (FRED) feature might provide a mechanism for that.
So far, Cook said, there has been no work on creating a software-based
hash-checking scheme for backward-edge CFI, similar to <a
href="/Articles/893164/">KCFI</a> that is used for forward-edge protection.
</p>

<h4>Pointers and bounds</h4>

<p>
There is work needed in order to add <tt>__counted_by()</tt> for general
pointer values; both GCC and Clang have started working on support.  It is
somewhat related to the <a
href="https://discourse.llvm.org/t/rfc-enforcing-bounds-safety-in-c-fbounds-safety/70854"><tt>-fbounds-safety</tt>
proposal</a> from Apple that he would go into more detail about later in the session.
</p>

<p>
Zhao came forward to talk about the work being done on pointer bounds in
GCC.  There are two main cases, pointers inside structures, where the bound
is contained in another structure field, and pointers passed as arguments,
where the bound is also passed as an argument.  The second case is already
handled in GCC by the <tt>access</tt> attribute, so GCC developers will
focus on the first case.  She has discussed adding <tt>__counted_by()</tt>
for pointers in structures with the GCC maintainers, who are amenable to
that approach.  Nick Alcock said that <tt>access</tt> is not currently used
to generate warnings for exceeding the bounds, however; it is, instead,
"<q>a promise to the optimizer</q>" that the bounds will not be exceeded,
which is somewhat different.  Zhao agreed that a different attribute might
be needed for checking the bounds on pointer arguments.
</p>

<a href="/Articles/997848/">
<img src="https://static.lwn.net/images/2024/lpc-zhao-sm.png" border=0 hspace=5 align="left"
alt="[Qing Zhao]" title="Qing Zhao" width=205 height=280>
</a>

<p>
Cook returned to talk about a problem that has been found as the
<tt>__counted_by()</tt> annotations have been added to the kernel.  In many
cases, the structures holding a flexible array are allocated at run time,
but there is a need to ensure that the field being used for bounds checking
gets initialized at the same time that the allocation is done.  He does not
like to have manually repeated information that must be kept in sync in two
places in the kernel, so he is working with the GCC and Clang developers to
get another to extension to <tt>__counted_by()</tt> so that the allocators can
set the counter without knowing which field, if any, is being used for bounds.
</p>

<p>
The <tt>__builtin_counted_by_ref()</tt> intrinsic function will return a
pointer to the field used in <tt>__counted_by()</tt> or NULL if there is no
bounds-checking annotation.  That allows wrappers to be written for
allocators that will initialize the count if there is one at the time the
allocation is done.  So the <tt>__counted_by()</tt> annotations can be made
"<q>without also having to go and check all of the allocation sites to make
sure that the counter has been set before we are accessing the array</q>".
That means a wrapper can be used for all structures that have flexible
arrays and when <tt>__counted_by()</tt> gets added to the structure, "<q>it
magically gets the size added as well</q>"; both GCC and Clang are working
on adding the feature.
</p>

<p>
Zhao said that the GCC developers have been <a href="/ml/gcc-patches/20240813153326.2834149-1-qing.zhao@oracle.com/">discussing the return type</a> for
<tt>__builtin_counted_by_ref()</tt>, in particular for the case where it
returns NULL because there is no <tt>__counted_by()</tt> information.
Originally the idea was to return a NULL <tt>size_t</tt> pointer, but it was
decided that a <tt>(void *)NULL</tt> would ease the use of the feature,
since some counting fields may not be <tt>size_t</tt>.
That has implications for the example wrapper that he showed, Cook said,
because the <tt>void</tt> pointer cannot be used to set the count
when there <i>is</i> a <tt>__counted_by()</tt> attribute.  So "<q>a little bit more
trickery</q>" needs to be added, which has been done, and works; it
"<q>generates better code but it's a little ugly to read</q>". 
</p>

<p>
The Apple <tt>-fbounds-safety</tt> proposal that Cook mentioned earlier
has "<q>a huge number of things covering all aspects of gaps in C's bounds
safety</q>", he said, including annotations for arrays that are counted by elements
or bytes, as well as those terminated by some constant (e.g. NUL-terminated
strings), and
more.  The proposal came up 
when the request was made to the Clang developers for a way to annotate
flexible arrays.  It is much more ambitious than just that; Cook thinks the kernel and
GCC will want to adopt more of those annotations, but he has been focusing on
the low-hanging fruit.
</p>

<p>
There is also work needed to <a
href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=109071">clarify the
<tt>-Warray-bounds</tt> warnings issued by GCC</a>, so that the flag can be
used in kernel builds.  The kernel "<q>unintentionally constructs code that
the compiler sees as obviously incorrect</q>", but the warnings do not
really help clarify what the problem is.  Zhao said that due to GCC value
tracking (which is done for optimization purposes), the array-bounds
checking can find real problems in the code, but the current diagnostics
make them look like false positives.  She has <a
href="/ml/gcc-patches/20241105163132.1922052-1-qing.zhao%40oracle.com/">done
some work</a> to make the warnings more understandable for developers.
</p>

<h4>Arithmetic overflow</h4>

<p>
There is a question about <a href="/Articles/979747/">what to do</a> for <a href="https://github.com/KSPP/linux/issues/26">unexpected arithmetic wraparound
(or overflow)</a> in the kernel, Stitt said.  If you filter CVEs based on overflow
and wraparound problems, there are multiple entries for the kernel; "<q>if
we could turn on the overflow sanitizers, then we're increasing
protection</q>". But the kernel essentially makes signed integer overflow into
defined behavior with the
<tt>-fno-strict-overflow</tt> flag, so UBSAN does not flag overflows.  In Clang&nbsp;19, the
signed-integer-overflow sanitizer <a
href="https://github.com/llvm/llvm-project/commit/81b4b89197a6be5f19f907b558540bb3cb70f064">has
been changed</a> so that it works with <tt>-fwrapv</tt> (which is
enabled by <tt>-fno-strict-overflow</tt>), though Zijlstra called that a
bug.  Stitt said that one could argue that it is a bug, since overflow is
not an undefined behavior for the kernel, but the change was made with an
eye toward detecting un<i>expected</i> overflows, which often cause problems.
</p>

<a href="/Articles/997849/">
<img src="https://static.lwn.net/images/2024/lpc-stitt-sm.png" border=0 hspace=5 align="left"
alt="[Justin Stitt]" title="Justin Stitt" width=190 height=280>
</a>

<p>
The kernel has "<q>what I'll call 'overflow-dependent code patterns'</q>",
such as code that is explicitly checking for overflow (e.g. <tt>a + b
&lt; a</tt>) in order to handle it in some fashion.  The sanitizer will
complain about that, even though it is not a real problem, so there are "<a
href="/ml/all/202404291502.612E0A10@keescook/">idiom exclusions</a>" that have been
added to Clang&nbsp;19 to ignore certain types of code.  For example,
<tt>-1UL</tt> "<q>will always overflow</q>", so it would cause a complaint,
making the sanitizer useless for the kernel; the Clang <a
href="https://github.com/llvm/llvm-project/commit/295fe0bd438209831071ffbacf003c4941f31b90">overflow
pattern exclusions</a> will tell the sanitizer to step out of the way for
three specific patterns.
</p>

<p>
Zijlstra said that he would like to see a qualifier akin to <tt>const</tt>
or <tt>volatile</tt> that could be attached to variables that should not wrap.
Stitt said he agreed but that the compiler developers are moving away from
that solution.  Cook noted that he and Zijlstra have a fundamental
disagreement on how to get coverage for unexpected overflow; he thinks
"<q>we have to mark the expected places where we're wrapping so that all
the rest will get caught</q>", though Zijlstra disagrees with that approach.
</p>

<p>
One way to proceed that works around the (somewhat conflicting) objections
from compiler and kernel developers would be to treat certain types,
<tt>size_t</tt> for example, differently in the sanitizer.  Zijlstra did
not like turning certain types into "magic" types; having a qualifier would
allow specifying that behavior more widely.  Cook would like to try to make
some progress given the current constraints and noted that the type
filtering is not mutually exclusive with adding a qualifier later once the
usefulness of the feature can be shown.  Stitt pointed out that the <a
href="https://github.com/llvm/llvm-project/pull/107332">Clang feature</a>
(possibly slated for Clang&nbsp;20) is not hard-coded in the compiler; it
will, instead, be some kind of configuration for the build system.  So it
will not appear at the source-code level, but will still be controlled by
the kernel community.
</p>

<p>
Track organizer José Marchesi noted that the unexpected overflow items were
listed as "needed" for GCC, so he wondered if they had all been added to
the project's Bugzilla.  Cook said that those items had not been added due
to "<q>some existing fundamental disagreements about the word 'undefined',
because 'undefined' has a very well defined meaning</q>", he said to chuckles. Some of that
needs to be resolved before progress can be made for GCC.  He would also
like to get some proof of the 
feature's usefulness, which will also help smooth the path.
</p>

<p>
Stitt said that GCC still needs an unsigned-integer-overflow
sanitizer.  Zhao said that she has raised the overflow/sanitizer problems in
the GCC community, so the developers are aware of the issues. The major
problem is with the idiom exclusions; she talked about it at Cauldron and
there was a lot of resistance to the feature.  She agrees: "<q>I don't like
it, I think it's
a hack</q>".  She has some ideas for other ways to approach the problem,
but needs to think some more on them.  Cook closed the session by noting
that the purpose of these sessions is to get the discussion going; he
does not claim that the right solutions have been found, but hopes to
make some progress on addressing the known problem areas.
</p>

<p>
[ I would like to thank LWN's travel sponsor, the Linux Foundation, for
travel assistance to Vienna for the Linux Plumbers Conference. ]
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Kernel_hardening">Security/Kernel hardening</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Hardening">Linux kernel/Hardening</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2024">Linux Plumbers Conference/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/996344/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor997981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 8:06 UTC (Wed)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/997981/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whenever there is a compiler warning, hopefully, the warnings are mostly useful but there are always going to be some which are not useful.  The idiom exclusion feature cuts down on the non-useful warnings.<br>
<p>
For example, it's mostly useful to have a warning about unsigned comparisons with zero.  But when the code looks has both and upper and lower bound like this:  "if (x &lt; 0 || x &gt;= 10) {", then the warning is not useful.  The code works 100% as intended.<br>
<p>
There are different strategies you could use to silence the warning.  In the unsigned example, you could just delete the "x &lt; 0" comparison.  But that's work which provides no benefit and arguably makes the code slightly less readable.<br>
<p>
For the integer overflows, presumably you would add a annotation like "if (wrap_ok(x + y)  &lt; x)".  And actually I don't hate that too much...  But probably other people do, and it's also a lot of work to do it retroactively over a giant project like the kernel.  It could be avoided if we use idiom exclusions.<br>
<p>
I understand why the GCC developers don't like idiom exclusions but compiler warnings are already a mostly random collection of warnings and they already miss 95% of bugs.  If the code looks fine, then it's okay to not print a warning.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor997985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 9:31 UTC (Wed)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/997985/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Coverity has a particularly irritating version of that "unsigned comparison with zero in a bounds check" warning, where it will do so when the type being bounds checked is an enum. Unless I have got confused (not unlikely where C standard minutiae are concerned :-)) enums with no negative values may be signed or unsigned as the compiler chooses, so for portability the greater-than-or-equal-to-zero check is necessary, but Coverity gripes about it because the implementation happens to have used an unsigned type for the enum...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor997986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 9:44 UTC (Wed)
                               by <b>magfr</b> (subscriber, #16052)
                              [<a href="/Articles/997986/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have a hand time understanding why <br>
<p>
x+y&lt;x<br>
<p>
is considered easier to read and better than <br>
<p>
INT_MAX-y&lt;=x<br>
<p>
Sure, the former is type agnostic and naïvely generates smaller code but I would expect both to end up checking the flag result of x+y.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor997991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 10:31 UTC (Wed)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/997991/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I have a hand time understanding why</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; x+y&lt;x</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; is considered easier to read and better than</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; INT_MAX-y&lt;=x</span><br>
<p>
It is considered better in the eyes of the language lawyers. Which, apparently, is enough to trump any kind of readability concerns.<br>
<p>
I'd ask a different question, though. With the amount of compiler extensions already part of "kernel C" (some of which are even in this article), I'm having a hard time understanding reasons for not adding a `__builtin_wraps(expr)` kind of thing that explicitly evaluates `expr` under `-fwrapv` rules and tests that for overflow.<br>
<p>
Surely an `if (__builtin_wraps(a + b))` is more readable than both `if (a + b &lt; a)` and `if (INT_MAX - b &lt;= a)`?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor997995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 10:36 UTC (Wed)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/997995/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compilers have had that for a while: see __builtin_add_overflow_p in <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Built...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor997996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 10:40 UTC (Wed)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/997996/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nope. Sorry, these builtins are a just a planetary abomination. The identity of the arithmetic operation is completely erased, making it absolutely in-obvious that it's in fact an arithmetic operation rather than a random function call.<br>
<p>
It needs to be a `__some_builtin(expr)`, where `expr` is a **regular** arithmetic expression using **regular** + and - symbols.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor997998"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 10:50 UTC (Wed)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/997998/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I certainly wouldn't use the naked builtin directly, but that's true of most GCC builtins. But I'll absolutely take "looks like a function call and has 'add' as a word rather than '+' as a symbol, but is extremely obviously doing an overflow check" over "has '+' in the expression but is ridiculously opaque about what it is actually doing", especially when the thing it is doing is important for correctness and often for security.<br>
<p>
No objections if you want to get nicer facilities added to the compiler, but in the interim I'll use the ones we have. And if I did have to work with a compiler where I had to use "x + y &lt; x" I would wrap it in a function so I could give it a clearer name...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997998/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 11:09 UTC (Wed)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/998000/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But I'll absolutely take "looks like a function call and has 'add' as a word rather than '+' as a symbol, but is extremely obviously doing an overflow check" over "has '+' in the expression but is ridiculously opaque about what it is actually doing"</span><br>
<p>
Who was saying anything about being opaque?<br>
<p>
I just proposed a `__builtin_overflows(expr)` thing which makes it equally obvious that it is a test for overflow. **And** that it is an arithmetic expression.<br>
<p>
All those builtins disguising arithmetic operations as function calls — no. Just no. The arithmetics are infix for a reason. This is C, not some kind of a Lisp or a reverse Forth.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/998000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 11:20 UTC (Wed)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/998001/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You seemed to me to be proposing that until this suggestion of yours is implemented in compilers we should continue to open-code "if (x + y &lt; x)". That open-coding is what I am describing as opaque. <br>
<p>
Your idea is clearly nicer than the existing builtins, but we don't have it yet and in the best case won't have it widely available for years, so the question of what is most legible and least bug prone given current compiler facilities still matters, I think.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/998001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor997999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 11:01 UTC (Wed)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/997999/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah.  That would be nice.  My idea is that it would be scope based.  The compiler would trap any integer overflows and goto the label.  I've left off \ characters and probably made typos but you get the idea:<br>
<p>
#define saturate(math...) (__attribute__(overflow overflowed_label) {<br>
    size_t result;<br>
    bool overflow = false;<br>
    result = (math);<br>
    goto done;<br>
<p>
overflowed_label:<br>
    overflow = true;<br>
done:<br>
    overflow ? SIZE_MAX : result;<br>
})<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor997994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 10:37 UTC (Wed)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/997994/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, apologies, I apparently misread that. My brain thought that you just missed a "not" somewhere in there because I didn't realize someone could be asking _that_ question.<br>
<p>
Well, `if (a + b &lt; a)` preserves the identity of participating arithmetic operations. When you see a `if (a + b &lt; a)`, it is immediately obvious that you are dealing with a sum of `a` and `b`, and if you are familiar with wrapping arithmetic, it's also almost immediately parsable as checking for overflow.<br>
<p>
On the other hand, `if (INT_MAX - a &lt;= b)` does not preserve neither the identity of the operation, nor the identity of operands. You need significant brain time to mentally carry over the operands to one side, invert the signs and realize that we are talking about `a + b`, not some weird arithmetic expression with unrelated `a`, `b` and a constant.<br>
<p>
Personally, it's a no-brainer which one is clearer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor997992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 10:32 UTC (Wed)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/997992/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Personally I think something like add_would_overflow(x, y) is easier to read than both and less susceptible to "looks almost like the idiom but isn't quite right" errors. (And you can implement it via the compiler builtins.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor997997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2024 10:54 UTC (Wed)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/997997/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Half of the time you want to both add and bail. Another half is to only check because operation in question will be done much later<br>
and passing the result is cumbersome or not necessary.<br>
<p>
The _right_ way is to not invent new idioms (which every project will do differently) but to use __builtin_add_overflow().<br>
<p>
T len;<br>
if (__builtin_add_overflow(a, b, &amp;len)) { return -E; };<br>
[use len]<br>
<p>
or (because clang doesn't do BAO_p)<br>
<p>
if (__builtin_add_overflow(a, b, &amp;(int[1]){})) { return -E; };<br>
<p>
Those who fear that BAO does addition differently and will make people break glass and cut hands may want to lobby for a warning if BAO is done on different types (especially with both different signedness _and_ length).<br>
<p>
BAO is cool for checking if result fits into some other type:<br>
<p>
if (__builtin_add_overflow(a, 0, &amp;(T[1]){})<br>
<p>
Just use BAO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/997997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor999982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2024 23:58 UTC (Wed)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/999982/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;The _right_ way is to not invent new idioms (which every project will do differently) but to use __builtin_add_overflow().</span><br>
<p>
It's in C23 as chk_add so instead of inventing your own, write chk_add as a simple wrapper around bao and then everybody agrees on a standard API.<br>
<p>
N.B. chk_add has the output pointer first, not last. Otherwise it's the same.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/999982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor998194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2024 16:13 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/998194/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
I would expect both to end up checking the flag result of x+y.
</blockquote>

Looking at <a href="http://al.howardknight.net/?ID=172694985600">&lt;2024Sep6.152642@mips.complang.tuwien.ac.at&gt;</a>, gcc-10 generates the "naïve" code (on AMD64 9 bytes for "b&lt;b=1" and 14 bytes for "b==LONG_MIN"), while gcc-12 generates the longer code from both idioms.  Neither checks the flag result.  You have to explicitly use __builtin_sub_overflow(b,1,&amp;c) to get that, and then both versions generate a 6-byte sequence using add instead of the 5-byte sequence using dec.  Whatever goes on in the minds of the gcc maintainers, there seem to be things on their agenda that are more important than generating short and fast code.


      
          <div class="CommentReplyButton">
            <form action="/Articles/998194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2024 16:51 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/998199/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Whatever goes on in the minds of the gcc maintainers, there seem to be things on their agenda that are more important than generating short and fast code. </span><br>
<p>
As the saying goes, "patches welcome"<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/998199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2024 8:53 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/998244/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Are you speaking for the gcc maintainers?

<p>If not, what makes you think so?  What makes you think that they would welcome a patch that reverts the change that pessimises the "b&lt;b-1" case rather than exercising one of the justification mechanisms for their deeds, as they have done in other cases?  Or simply ignoring the issue as in <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93811">Bug 93811</a> where I provided working code (not a patch, though).

<p>If yes, why should I do for free what most of you are paid to do?  Especially given your lack of fulfilling your part of the deal, as discussed above.



      
          <div class="CommentReplyButton">
            <form action="/Articles/998244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Idiom exclusion is really so important</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2024 12:15 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/998258/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Are you speaking for the gcc maintainers? </span><br>
<p>
I'm speaking as a maintainer of completely unrelated free software.<br>
<p>
<span class="QuotedText">&gt; If not, what makes you think so? What makes you think that they would welcome a patch that reverts the change that pessimises the "b&lt;b-1" case rather than exercising one of the justification mechanisms for their deeds, as they have done in other cases? Or simply ignoring the issue as in Bug 93811 where I provided working code (not a patch, though). </span><br>
<p>
What makes you think that complaining (and disparaging the GCC maintainers) on LWN is remotely productive or useful?<br>
<p>
Everyone involved with any free software project has far, far more things on their to-do lists than they can possibly accomplish; consequently they prioritize the things they care about.  <br>
<p>
If the GCC maintainers' priorities differ from yours, it is incumbent upon *you* do step up and contribute in some way (eg code/patches, funding, or advocacy).  Either way, disparaging the maintainers (and/or other active contributors) isn't going to accomplish anything productive.<br>
<p>
<span class="QuotedText">&gt; If yes, why should I do for free what most of you are paid to do? Especially given your lack of fulfilling your part of the deal, as discussed above. </span><br>
<p>
There is no "deal" here, or at least not one with *you*.  <br>
<p>
...The ones that pay the maintainers (if they are being paid at all -- most aren't!) get to decide the priorities.   <br>
<p>
You don't like that?  Patches welcome.  Heck, you can even keep that patch entirely to yourself if the GCC maintainers don't like it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/998258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998263"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Patches welcome&quot; means &quot;Shut up!&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2024 13:07 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/998263/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>What makes you think that complaining (and disparaging the GCC maintainers) on LWN is remotely productive or useful?
</blockquote>

My comment was productive or useful by correcting the expectation of magfr.

<blockquote>
Everyone involved with any free software project has far, far more things on their to-do lists than they can possibly accomplish; consequently they prioritize the things they care about.
</blockquote>

Certainly.  And, as I wrote, some gcc maintainer found the time to recognize the "b&lt;b-1" idiom, and found the time to transform it into longer code even when gcc is invoked with -Os.  So what makes you think that submitting a patch that reverts that change would achieve anything remotely productive or useful?

<blockquote>
If the GCC maintainers' priorities differ from yours, it is incumbent upon *you* do step up and contribute in some way (eg code/patches, funding, or advocacy).
</blockquote>

You think that I should provide a patch for a project maintained by people who will ignore the patch because their priorities differ from mine?  Why should that be remotely productive or useful?

<p>You think I should provide funding or advocacy for a project where the maintainers' priorities differ from mine?  I can see that the gcc maintainers would like that, but why should I?

<blockquote>
There is no "deal" here, or at least not one with *you*.
</blockquote>

In that case, what did you want to say with "patches welcome"?  As used by you it apparently means "I don't like what you are writing and I wish you would shut up, so I suggest a wild-goose chase".  Your last paragraph makes that even clearer.



      
          <div class="CommentReplyButton">
            <form action="/Articles/998263/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Patches welcome&quot; means &quot;Shut up!&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2024 14:35 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/998293/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Certainly. And, as I wrote, some gcc maintainer found the time to recognize the "b&lt;b-1" idiom, and found the time to transform it into longer code even when gcc is invoked with -Os. So what makes you think that submitting a patch that reverts that change would achieve anything remotely productive or useful? </span><br>
<p>
Because there may be very good intentional reasons for that change in GCC?  Or maybe this is an unintentional side effect of some other fix/improvement and can itself be fixed incrementally with sufficient elbow grease?<br>
<p>
(I can say from experience that micro-optimizations like that rarely make a meaningful difference in code size/performance.  Unless you're at the point of truly counting/shaving bytes, in which case you are going to have a real budget to throw at this)<br>
<p>
<span class="QuotedText">&gt; You think that I should provide a patch for a project maintained by people who will ignore the patch because their priorities differ from mine? Why should that be remotely productive or useful? </span><br>
<p>
You would create the patch because it makes things that much better for *you*.  Sharing/pushing it upstream is entirely optional.<br>
<p>
<span class="QuotedText">&gt; You think I should provide funding or advocacy for a project where the maintainers' priorities differ from mine? I can see that the gcc maintainers would like that, but why should I? </span><br>
<p>
I meant advocate for *your* use case/problems, not advocate for the project in general.  (And "advocate" means "persuade the audience", not "crap all over them")<br>
<p>
But in a more general sense, very little out there is ever fully aligned with one's personal priorities.  Welcome to life.<br>
<p>
<span class="QuotedText">&gt; In that case, what did you want to say with "patches welcome"? As used by you it apparently means "I don't like what you are writing and I wish you would shut up, so I suggest a wild-goose chase". Your last paragraph makes that even clearer. </span><br>
<p>
...You're the one expecting other folks to care about and perform (potentially very specialized) work on your behalf because *someone else* is paying them to work on other use cases.  That's some pretty serious entitlement.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/998293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Patches welcome&quot; means &quot;Shut up!&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2024 18:41 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/998326/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>I can say from experience that micro-optimizations like that rarely make a meaningful difference in code size/performance.</blockquote>

In that case, why have they made the change at all?  Or many other changes?  The usual claim is that each transformation by itself rarely makes any meaningful difference, but they add a whole lot of them, and together they usually result in smaller/faster code.  And it's certain that you cannot generate smaller code by compiling an individual idiom into larger code.

<blockquote>
You would create the patch because it makes things that much better for *you*. Sharing/pushing it upstream is entirely optional.
</blockquote>

I would not know how.  I distribute free software, i.e., as source code.  How would a patch that only I use make things better for me, much less "much better"?  Because I can then answer bug reports with "works for me"?  That's not how I prefer to work.

<blockquote>
You're the one expecting other folks to care about and perform (potentially very specialized) work on your behalf because *someone else* is paying them to work on other use cases.
</blockquote>

What makes you think so?  Concerning gcc, I have mostly given up on the idea that they feel bound by the social contract where users find and report bugs and gcc maintainers fix them, so no, I don't expect them to do anything, and therefore I have mostly stopped reporting gcc bugs.

<p>Concerning people who pay them, I doubt that Intel pays for gcc development with the intention that they implement transformations that make the code longer when using -Os.





      
          <div class="CommentReplyButton">
            <form action="/Articles/998326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor998379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Patches welcome&quot; means &quot;Shut up!&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2024 10:46 UTC (Sat)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/998379/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a nowadays inactive maintainer of a small corner of gcc, and speaking only for myself, largely I agree with what "pizza" has said in this subthread. GCC is a large project with a lot of stakeholders, and nobody gets exactly what they want. Those who put in more, be it in terms of funding developers, or individual contributors putting in elbow grease to scratch their own itches, get out more than those who contribute less.<br>
<p>
For some specific points you made:<br>
<p>
<span class="QuotedText">&gt; In that case, why have they made the change at all? Or many other changes? The usual claim is that each transformation by itself rarely makes any meaningful difference, but they add a whole lot of them, and together they usually result in smaller/faster code. And it's certain that you cannot generate smaller code by compiling an individual idiom into larger code. </span><br>
<p>
Nobody intentionally pessimizes code, unless it's to fix some correctness issue. There's obviously no conspiracy against people with passionate opinions about generating optimal code for "b &lt; b - 1". Without looking into specifics, my guess would be that this is an unintentional side-effect of some other work, and the effect it caused was insignificant in size/performance on the benchmark suites that are used to track the development of the compiler, mainly SPECcpu, but also other similar application benchmarks. Those are ultimately what people tend to care about, not some particular micro-optimization (unless that particular micro-optimization affects the size and/or performance of some larger application).<br>
<p>
That is not to say micro-optimizations aren't useful; they certainly are used for analyzing the impact of some particular optimization passes etc. But again, ultimately what matters to users is the size/performance of complete applications. In some cases it can mean a code transformation that pessimizes some particular aspect (like generating optimal code for "b &lt; b - 1") but makes some other code faster, for an ultimately positive result on SPEC, gets merged.<br>
<p>
<span class="QuotedText">&gt; Concerning gcc, I have mostly given up on the idea that they feel bound by the social contract where users find and report bugs and gcc maintainers fix them, so no, I don't expect them to do anything, and therefore I have mostly stopped reporting gcc bugs.</span><br>
<p>
Like so many other projects, GCC has many more bug reports than it has developers able to fix them.  Thus bugs have to be triaged, and if it so happens that your favourite bug isn't considered important enough to get the attention of the very limited developer time, then unfortunately it means it will languish.  If you're unable to convince the developers that your bug is very important and needs attention, then other ways around that conundrum are to fix it yourself or pay someone to do it, hence 'patches welcome'. To the extent that can be construed as "Shut up!", it's pointing out that complaining about poor code generation on comp.arch, lwn, or some other forum, fun as it may be as a way to pass your free time, is unlikely to cause other people to step up and fix your issue.<br>
<p>
<span class="QuotedText">&gt; Concerning people who pay them, I doubt that Intel pays for gcc development with the intention that they implement transformations that make the code longer when using -Os. </span><br>
<p>
Very true, but it's also likely true that out of the near infinite ways the compiler can be improved, Intel doesn't consider generating optimal code for "b &lt; b - 1" to be particularly high on the list of priorities.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/998379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor998361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">No only somewhat different </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2024 0:05 UTC (Sat)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/998361/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Nick Alcock said that access is not currently used to generate warnings for exceeding the bounds, however; it is, instead, "a promise to the optimizer" that the bounds will not be exceeded, which is somewhat different.</span><br>
<p>
That doesn't sound like "somewhat different", but the exact opposite. The first asks the compiler to check; the second makes a promise to a compiler, allowing it to silently do rubbish if the promise doesn't hold. The first one turns (some) erroneous or undefined behavior into a warning. The second one turns correct-at-the-language-level behavior into UB.<br>
<p>
The first one is good for diagnostics and checking. The second one is the opposite; it is good for optimization when you know something cannot happen and want the compiler to use that information as much as it can.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/998361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
