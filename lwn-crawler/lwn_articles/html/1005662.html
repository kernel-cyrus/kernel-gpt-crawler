        <!DOCTYPE html>
        <html lang="en">
        <head><title>The trouble with the new uretprobes [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/1005662/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/1005954/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/1005662/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The trouble with the new uretprobes</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 23, 2025</br>
           </div>
A "uretprobe" is a dynamic, user-space tracepoint injected by the kernel
into a running process; <a
href="https://docs.kernel.org/trace/uprobetracer.html">this document</a>
tersely describes their use.  Among other things, uretprobes are used by
the <tt>perf</tt> utility to time function calls.  The 6.11 kernel saw a
significant change to uretprobes that improved their performance, but that
change is also creating trouble for some users.  The best way to solve the
problem is not entirely clear.
<p>
Specifically, a uretprobe exists to gain information at the return from a
function in the process of interest.  Older kernels implemented uretprobes
by injecting code that, on entry to a function, changed the return address
to a special trampoline that, in turn, contained a breakpoint trap
instruction.  When the target process executed that instruction, it would
trap back into the kernel, which would then extract the information of
interest (such as the function's return value) and run any other attached
code (a BPF program, perhaps) before allowing the process to resume.  This
method worked, but it also had a noticeable performance impact on the
probed process.
<p>
In an attempt to improve uretprobe performance, Jiri Olsa put together <a
href="/ml/linux-kernel/20240611112158.40795-1-jolsa@kernel.org/">a patch
set</a> that changed the implementation on x86 systems.  The return
trampoline still exists but, rather than triggering a trap, it just calls
the new <tt>uretprobe()</tt> system call, which then takes care of all of
the associated work.  Since system-call handling is faster than taking a
trap, the cost to the probed process is lower when <tt>uretprobe()</tt> is
used.  This new system call takes no arguments, and it can only be called
from the kernel-injected special trampoline; otherwise it will just deliver
a <tt>SIGILL</tt> signal to the calling process.
<p>

Arguably, all system calls are special, but this one takes "special" to a
whole new level.  It is not something that a process can just call to
obtain a useful service from the kernel.  <tt>uretprobe()</tt> is thus
unlikely to be on anybody's list of "five new system calls that every
programmer should know".  It does, however, succeed in accelerating
uretprobes by as much as about 30%.  This change went into the 6.11
release, seemingly without ill effect.
<p>
On January 10, though, Eyal Birger <a
href="/ml/all/CAHsH6Gs3Eh8DFU0wq58c_LF8A4_+o6z456J7BidmcVY2AqOnHQ@mail.gmail.com">reported</a>
an ill effect; kernels that implement <tt>uretprobe()</tt> were causing
Docker containers to crash.  The problem is that Docker uses <a
href="https://man7.org/linux/man-pages/man2/seccomp.2.html"><tt>seccomp()</tt></a>
to impose a policy on which system calls a containerized system can
invoke.  The policy used by Docker is, as standard practice would suggest,
a default-deny arrangement; if a given system call has not been explicitly
enabled, it will be blocked.  <tt>uretprobe()</tt>, not being on any Docker
developer's list of new exciting system calls, is not found in the
allowlist.  As a result, the injection of a uretprobe into a process
running under Docker will result in that process's untimely and mysterious
death.  Docker users will, indeed, no longer notice a performance hit on a
traced process, but they are unlikely to express their gratitude for that.
<p>
Various possibilities for fixing the problem were suggested at the time.
Olsa put together <a href="/ml/all/Z4YszJfOvFEAaKjF@krava">a quick
patch</a> to detect a failure to execute <tt>uretprobe()</tt> and fall back
to the old implementation in that case.  He also <a
href="/ml/all/Z4eBs0-kJ3iVZjXL@krava">considered</a> simply disabling the
<tt>uretprobe()</tt> implementation entirely when <tt>seccomp()</tt> is in
use, or adding a sysctl knob to control whether <tt>uretprobe()</tt> is
used.  Birger, though, <a
href="/ml/all/CAHsH6Gs03iJt-ziWt5Bye_DuqCbk3TpMmgPbkYh64XBvpGaDtw@mail.gmail.com/">disliked
the sysctl idea</a>, saying: "<q>'Give me speed but potentially crash
processes I don't control' is a curious semantic</q>".
<p>
Oleg Nesterov, instead, <a
href="/ml/all/20250115150607.GA11980@redhat.com">suggested</a> patching
<tt>seccomp()</tt> to simply ignore calls to <tt>uretprobe()</tt>, making
that system call even more special.  Birger returned with <a
href="/ml/all/20250117005539.325887-1-eyal.birger@gmail.com">a patch</a>
implementing Nesterov's suggestion.  Kees Cook, however, <a
href="/ml/all/202501181212.4C515DA02@keescook">questioned this change</a>,
wondering why <tt>uretprobe()</tt> needs to be so special.  Docker, he
pointed out, already handles other weird system calls like <a
href="https://man7.org/linux/man-pages/man2/sigreturn.2.html"><tt>sigreturn()</tt></a>;
it should be able to do the same with <tt>uretprobe()</tt>:
<p>
<blockquote class="bq">
	Basically, this is a Docker issue, not a kernel issue. Seccomp is
	behaving correctly. I don't want to start making syscalls invisible
	without an extremely good reason.
</blockquote>
<p>
Birger <a
href="/ml/all/CAHsH6GuifA9nUzNR-eW5ZaXyhzebJOCjBSpfZCksoiyCuG=yYw@mail.gmail.com">responded</a>
that this case is indeed different:
<p>
<blockquote class="bq">
	I think the difference is that this syscall is not part of the
	process's code - it is inserted there by another process tracing
	it.  So this is different than desiring to deploy a new version of
	a binary that uses a new libc or a new syscall.
</blockquote>
<p>
That reasoning just <a
href="/ml/all/8B2624AC-E739-4BBE-8725-010C2344F61C@kernel.org">hardened</a>
Cook's position, though.  A process might want to defend against injection
of <tt>uretprobe()</tt> by blocking it with <tt>seccomp()</tt>, he said.
The whole point of <tt>seccomp()</tt> is to implement a policy given to it,
he added; there should not be a separate policy within <tt>seccomp()</tt>
itself.
<p>
This reasoning, sound as it may be, does little to solve Birger's problem,
which, <a
href="/ml/all/CAHsH6GtpXMswVKytv7_JMGca=3wxKRUK4rZmBBxJPRh1WYdObg@mail.gmail.com/">he
said</a>, is simply:
<p>
<blockquote class="bq">
	The problem we're facing is that existing workloads are breaking,
	and as mentioned I'm not sure how practical it is to demand
	replacing a working docker environment because of a new syscall
	that was added for performance reasons.
</blockquote>
<p>
This replacement, he said, would not be easy to accomplish.  He concluded
by wondering if the right solution might be to just revert the
<tt>uretprobe()</tt> change.  Olsa <a
href="/ml/all/Z4zXlaEMPbiYYlQ8@krava">said</a>, again, that it might be
better to introduce a new sysctl knob to control whether
<tt>uretprobe()</tt> is used, but Cook <a
href="/ml/all/202501201334.604217B7@keescook">answered</a> that reverting
may be the best choice, at least for now, while some thought goes into how
this implementation should interact with features like <tt>seccomp()</tt>.
Olsa then <a href="/ml/all/Z4-xeFH0Mgo3llga@krava">suggested</a> that the
best solution might be to disable <tt>uretprobe()</tt> temporarily, without
removing it from the kernel, until Docker can be updated to handle it
correctly.  Birger <a
href="/ml/all/CAHsH6GsXacPXiEz7amTcgBfWdiOJx2G3cAMdSdnkqOnJ+opqQg@mail.gmail.com">went
off</a> to consider that idea.
<p>
This approach may lead to a solution for this specific problem, though it
could take years before enough Docker installations have been updated to
make re-enabling <tt>uretprobe()</tt> safe.  But we will be seeing this
problem again.  Running systems within a sandbox that denies all system
calls that have not been explicitly enabled may well be good for security,
but that practice will run into trouble when the kernel underlying the
whole system routinely adds new system calls.  Beyond <tt>uretprobe()</tt>,
the x86 architecture saw the addition of nine new system calls in 2024:
<tt>setxattrat()</tt>, <tt>getxattrat()</tt>, <tt>listxattrat()</tt>,
<tt>removexattrat()</tt>, <tt>mseal()</tt>, <tt>map_shadow_stack()</tt>,
<tt>lsm_get_self_attr()</tt>, <tt>lsm_set_self_attr()</tt>, and
<tt>lsm_list_modules()</tt>.  There is no reason to believe that the
addition of system calls will stop now.
<p>
Something will have to give; in this case, that something would appear to
be the new uretprobe implementation.  But it is hard to imagine that the
development community will be pleased at the idea that it cannot add new
system calls lest existing Docker implementations break.  Perhaps there
will never be another system call as special as <tt>uretprobe()</tt>, with
its ability to break systems with just a kernel change but, as Cook <a
href="/ml/all/8B2624AC-E739-4BBE-8725-010C2344F61C@kernel.org">pointed
out</a>, there have been cases where the addition of a more "normal" system
call has caused similar crashes. In summary, it would be surprising if the
combination of "don't allow anything new" and "add lots of new things"
didn't explode every now and then.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-seccomp">Security/seccomp</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls">System calls</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/1005662/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor1006015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Surely default-deny should fail the syscall with ENOSYS?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 0:38 UTC (Fri)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/1006015/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's appropriate that a container runtime that wants to be a security boundary has a default-deny policy, but if it doesn't recognise a syscall, it should do the same thing the kernel does: make the syscall fail with ENOSYS, indistinguishable (except possibly by timing) from the effect of running on an older kernel that has no support for that syscall. That way, for ordinary syscalls (that are less odd than this one), well-behaved user-space can fall back to a less optimal implementation, for example emulating splice with read and write.<br>
<p>
I thought Docker had addressed this already, last time newer container payloads were broken by Docker default-denying a newly-added syscall with EPERM and glibc not expecting that result?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 2:53 UTC (Fri)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/1006021/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a term for that situation: ossification. It's the same shit we have to deal with when designing new network protocols, or extending existing ones: some middleware is going to assume everything it doesn't know (or even something it does know but misinterprets) is malicious and must be immediately discarded, rejected, or corrupted, sometimes also temporarily or permanently blocking the sender or the receiver, just in case.<br>
<p>
We are seeing the exact same dynamics with abusers of seccomp. New network protocols (io_uring) get blocked. Variations on existing network protocols (clone3) get corrupted (returning an invalid error code, as if it existed but failed) or blocked. Now we're seeing a new network protocol (uretprobe) being abandoned just because a firewall somewhere (seccomp) misbehaves. I wonder how long until we start playing games with system calls (pretending to be something else, like how the TLS 1.3 new connection handshake pretends to be a TLS 1.2 session resume; or doing GREASE with system call parameters, to ensure they are kept available for future use). Perhaps something like doing a write() with a bogus fd (above the runtime limit), and hoping Docker's seccomp policy doesn't look too closely at the fd number?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 7:16 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/1006031/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do not agree that this is an abuse of seccomp. It is the intended use case. The first version of seccomp actually imlemented exactly this: Just allow a handfull of kernel-decided hardcoded syscalls.<br>
<p>
Running seccomp with a deny list is just not going to work, given the current amount of syscalls and the constant ingress of new ones.<br>
<p>
This is a special case, because it breaks without updating the application. Seccomp filter updates on application updates are expected. On kernel updates the requirement of seccomp filter updates (that would mean app update) is unexpected.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 9:21 UTC (Fri)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/1006040/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would argue that it is an abuse of seccomp because seccomp was not intended to be used with a fixed allow list while both components in user space and kernels get updated. It is similar to using a firewall with deep packet inspection from the HTTP 1.0 days on today's HTTP 2.0 connections and complaining that things break while refusing to assign the blame to the one outdated component in the system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 14:12 UTC (Fri)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/1006069/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I would argue that it is an abuse of seccomp because seccomp was not intended to be used with a fixed allow list while both components in user space and kernels get updated.</span><br>
<p>
I'm not one of the designers of seccomp, but my reading of the original intention is that seccomp was supposed to be used by the final user space component (that is how it's used, for instance, in the Firefox/Chrome sandboxes). When that component gets updated, the seccomp policy naturally get updated at the same time. Separate dynamic libraries like glibc add an extra complication, and it's not always possible to avoid these libraries by doing system calls directly, but it's still the component being "protected" by seccomp that's defining the seccomp policy.<br>
<p>
Using seccomp to sandbox third-party components (like Docker does) is where it becomes more problematic, since the sandboxing code has no idea which system calls the third-party component requires, and it's easy for it to stay in an old version while both the kernel and the sandboxed code get updated. A light denylist-only use of seccomp would cause few issues (for instance, there's no need for a sandboxed process to call the reboot system call), but for security paranoia reasons their default policy blocks too much.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 11:40 UTC (Sat)
                               by <b>fw</b> (subscriber, #26023)
                              [<a href="/Articles/1006149/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
However, as things have turned out, the modern container approach (with ENOSYS) works more reliably than what the browser sandboxes are doing: software (whether it runs in containers or not) usually supports older kernels as well, so there is an existing run-time dispatch, or perhaps a performance penalty, or some fixed vulnerabilities and reliability issues come back.<br>
<p>
With browser sandboxes, the desire is to disable everything that the browser does not need, usually after the process has been created (and not outside the process, as with containers). There is in-process emulation/checking of some system calls via SIGSYS. And yet, browsers link in lots of system components, and their system call requirements keep changing. This is largely invisible because of early testing in distributions like Fedora rawhide. Incompatible things are temporarily reverted until browsers catch up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 13:59 UTC (Sat)
                               by <b>mokki</b> (subscriber, #33200)
                              [<a href="/Articles/1006152/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why can't docker have a dynamic allowlist that users can add the new syscalls without new docker version required?<br>
This has been a problem for 10+ years and still no solution from docker developers on this.<br>
Does podman handle this better?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 16:47 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/1006160/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see this (experimental) flag in podman's docs: <a href="https://docs.podman.io/en/v4.6.1/markdown/options/seccomp-policy.html">https://docs.podman.io/en/v4.6.1/markdown/options/seccomp...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor1006108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 16:24 UTC (Fri)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/1006108/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"This is a special case, because it breaks without updating the application. Seccomp filter updates on application updates are expected. On kernel updates the requirement of seccomp filter updates (that would mean app update) is unexpected."<br>
<p>
IMO, what you described *is* very much an ossification danger from the PoV of the kernel.  Kernel updates (and not only the kernel, there are also library updates of stuff like the libc and kernel-interface libraries, and no-libc runtimes like golang's) need to be able to change the syscalls they use, if ossification is to be avoided.<br>
<p>
I do agree that changes that would require seccomp updates on *stable* kernels (and minor/patch/stable-train updates of libraries and language runtimes) should be both a do-it-only-as-a-last-resort thing *and* very explicitly documented.<br>
<p>
Of course, there is no ossification issue with the original "restricted compute worker process" seccomp mode, because the hard-coded policy for that mode is in the kernel and it will be kept in sync with any changes to the syscalls.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 16:36 UTC (Fri)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/1006110/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(It is a pity one cannot edit posts).  A clarification: on this *specific* case of the restricted uretprobe syscall, I agree with others that it should just be hardcoded-allow-listed by seccomp (i.e. "invisible" to seccomp).   And my opinion is heavily based on the very specific detail that this syscall cannot be called by general code without triggering a SIGILL: this specific syscall is just an internal implementation detail of uretprobes.<br>
<p>
So, IMHO, if one wants to restrict uretprobes to an application (or even system-wide), it should be done in some other higher abstraction level that deals with uretprobes itself, or ptracing and the like.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 20:45 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/1006125/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMHO this is not unreasonable, but it would be helpful to make an explicit category for syscalls of this nature, with documentation and possibly new seccomp flags for dealing with it.<br>
<p>
Actually, I think it would probably be helpful to have multiple categories for syscalls of different types based on what they can do and whether they can affect things outside of the process. A seccomp BPF filter could, hypothetically, receive a bitmask indicating the properties of a given syscall, such as:<br>
<p>
* Whether it can read/modify state, and separate flags for the kind of state it reads or modifies. dup2 would be flagged differently from write, because dup2 modifies the process's file descriptor table, while write can modify the filesystem or do IPC (pipes etc.). (No, procfs is not "the filesystem" for the purposes of this discussion.)<br>
* Whether it is considered part of the kernel's userspace API. Yes for most syscalls, no for uretprobe. Denying syscalls where this flag is not set would be considered poor practice, and might result in compatibility issues on the next kernel release, but you can still do it if you really want to.<br>
* Whether it requires at least one capability to call with the specified arguments, for any reason other than filesystem permissions (because that would require looking them up, which slows things down a ton, and is also inherently racey).<br>
* Whether it would require a filesystem permission check, if executed by a non-privileged process (i.e. the flag is still set if you are root). Does not indicate what the result of that permission check would have been, only that it would have been done.<br>
<p>
The BPF filter could then use those flags to make an informed choice about unrecognized syscalls, and you could even pass some kind of mask to seccomp/prctl to indicate which syscalls you want to filter in the first place.<br>
<p>
I don't know how backwards compatible this is, or whether there is the will to implement something this complicated. But it would be nice to have.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor1006056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 13:41 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/1006056/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ossification is indeed a problem here, but seccomp didn't help itself by being designed in a way that's more or less guaranteed to ossify as I understand it.<br>
<p>
In TLS for example it was from the outset documented how to avoid ossifying, and what we saw each iteration is that the "Network Security" industry had not bothered because what they're actually selling is rocks that keep tigers away - the customers don't understand that this is impossible and aren't interested in learning what's actually for sale, I want your tiger rock and I want it immediately, take my money.<br>
<p>
You mentioned the workaround which was (had to be) sanctioned for TLS 1.3, but there's worse - one of the vendors was selling tiger rocks which would re-use a third party secret and pretend it's their secret, this destroys security but that's OK the customer isn't buying actual security they want a tiger rock and this says it's a tiger rock so all good - however in TLS 1.3 when their proxy tells a remote server, "Sorry, I don't know TLS 1.3, give me TLS 1.2" the server goes ok, that's cool, the random data I picked was some-random-data-DOWNGRADE-more-random-data†. If you're really a TLS 1.2 client this doesn't seem suspicious, it's extremely unlikely - but so is any particular value, so everything works. And the proxy isn't bothered.<br>
<p>
But when this idiot vendor's proxy copies the data into their reply to a client asking to perform TLS 1.3 that's a huge red flag for the client. Why is the server which claims it can't speak TLS 1.3 also telling me (as per TLS 1.3 protocol design)  that it was asked to downgrade from TLS 1.3? I didn't ask for a downgrade, clearly there's an attack -- and there is, it's your own systems attacking you because you (most likely the corporation you work for or at) bought a tiger rock.<br>
<p>
Anyway, so much to say, in TLS 1.3 we had these problems _despite_ the existence of obvious ways to never have the problem. seccomp is worse because it's not obvious how say Docker should magically avoid this problem. If you sat down in 2010 to write a "good" TLS proxy yours still works today. Of course you're out of business because unscrupulous, incompetent and greedy vendors will say their tiger rock (which doesn't work) is better, faster, cheaper, whatever, but that's too bad.<br>
<p>
Instead: Seccomp should have separate allow &amp; block lists. If you neither allow nor block a system call, what happens depends on the kernel, and so NOW there's an opportunity for a policy debate about what goes in which pile and why but it's not a magic special case it's just a kernel policy decision which is nothing new.<br>
<p>
† That's not the real data, but you can go read the RFC if you need details<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 20:55 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/1006131/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Instead: Seccomp should have separate allow &amp; block lists. If you neither allow nor block a system call, what happens depends on the kernel, and so NOW there's an opportunity for a policy debate about what goes in which pile and why but it's not a magic special case it's just a kernel policy decision which is nothing new.</span><br>
<p>
Seccomp does not have allowlists or blocklists (except for SECCOMP_SET_MODE_STRICT, which sets an extremely restrictive hard-coded allowlist for compute-only applications). If you want to customize its behavior, you have to use BPF filters. But a BPF filter is  just arbitrary-ish code. You can write whatever logic you want - if you want to have an allowlist, a blocklist, and some userspace-configurable behavior for unrecognized syscalls, you can do that today.<br>
<p>
In practice, everybody just writes a simple allowlist implementation for their BPF filter, but the kernel did not make them do that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 14:46 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/1006155/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's all very well to say the kernel didn't "make them" choose this, but what else was available? Imagine that next week we're adding a new kernel system call, you know nothing about it except it doesn't exist yet, now, what does your BPF filter say to ensure that this this call, in addition to the existing set, is callable, but no others?<br>
<p>
Actually wait, changed my mind, after you wrote that BPF, I'm actually adding three new calls, two obviously you need to allow and one you definitely must not, does that just work with the BFP you wrote for the original statement?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 14:58 UTC (Sat)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006156/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;&gt;&gt; Instead: Seccomp should have separate allow &amp; block lists. If you neither allow nor block a system call, what happens depends on the kernel, and so NOW there's an opportunity for a policy debate about what goes in which pile and why but it's not a magic special case it's just a kernel policy decision which is nothing new.</span><br>
<span class="QuotedText">&gt;&gt;</span><br>
<span class="QuotedText">&gt;&gt; In practice, everybody just writes a simple allowlist implementation for their BPF filter, but the kernel did not make them do that.</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; It's all very well to say the kernel didn't "make them" choose this, but what else was available? Imagine that next week we're adding a new kernel system call, you know nothing about it except it doesn't exist yet, now, what does your BPF filter say to ensure that this this call, in addition to the existing set, is callable, but no others?</span><br>
<p>
The problem isn't even that seccomp does not have a rigid whitelist/blacklist mechanic (as NYKevin says). You can, for instance, let the BPF program return a third verdict "defer to the kernel judgment" in addition to the "allow" and "deny" verdicts.<br>
<p>
However, in order to be able to have a meaningful "default policy" in the kernel, there has to be some agreed-upon overarching semantics for the entire seccomp mode 2 mechanism, and there isn't. Seccomp is just "a mechanism to mess with syscalls". Someone might use it for security, someone else might use it for debugging, or even a rudimentary form of fault injection. There is no way to have a meaningful default policy in the kernel when there is no predefined goal that this policy must fulfill.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor1006151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 12:42 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/1006151/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The obvious way to avoid this problem is to stop sandboxing things at the level of individual system calls. Access restrictions should be on *actions* applied to *objects*, not on the specific nouns and verbs you're using to talk about those objects. <br>
<p>
It's like I'm a bank teller (remember those?) and we're trying to solve the problem of bank robbery by installing an automated gun turret that shoots anyone saying "give me all your money". Robbers just say "give me all your currency", so now the automated gun turret, which can't enumerate every possible sentence, has to shoot anyone saying anything other than a few pre-defined sentences, like "I would like to make a deposit". Woe be to the client who instead says "I'd like to deposit a check" and gets shot.<br>
<p>
The right approach is to make a rule against bank robbery! <br>
<p>
Likewise, docker and others shouldn't be whitelisting specific system calls. They should talk about what actions processes can take on which objects.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 21:45 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/1006165/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But when this idiot vendor's proxy copies the data into their reply to a client asking to perform TLS 1.3 that's a huge red flag for the client. Why is the server which claims it can't speak TLS 1.3 also telling me (as per TLS 1.3 protocol design) that it was asked to downgrade from TLS 1.3? I didn't ask for a downgrade, clearly there's an attack -- and there is, it's your own systems attacking you because you (most likely the corporation you work for or at) bought a tiger rock.</span><br>
<p>
And this is where the European Computer Security Act (or whatever it was called) would come into effect. If the device claims to do TLS 1.3 and doesn't, it's clearly defective. And if it isn't fixed as per the CE mark ...<br>
<p>
This is where I would like the government to say "save money, buy COTS gear in bulk, but have a supplier blacklist. If you have to replace gear because the supplier welched on the CE mark, they go on the blacklist for the life of the REPLACEMENT gear".<br>
<p>
So if another supplier comes in and says "I'll give you a 10-year CE life instead of the standard 5", they're taking a risk, but they're also locking a competitor out of a lucrative market ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor1006023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 3:19 UTC (Fri)
                               by <b>JesseW</b> (subscriber, #41816)
                              [<a href="/Articles/1006023/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am confused why the performance improving patch was made using a new syscall at all. I am not very familiar with kernels, but are there really only two ways to get into the kernel -- a software interrupt/trap and a visible (and blockable) syscall? Since the kernel is injecting the code, can't it branch to itself without any visible ceremony?<br>
<p>
I'm sure I'm missing something obvious here, but hopefully others are too, so this question is useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 4:08 UTC (Fri)
                               by <b>tullmann</b> (subscriber, #20149)
                              [<a href="/Articles/1006024/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The syscall is the branch into the kernel.  To get the CPU into a state where kernel code can be executed the CPU needs to change protection levels and memory (or even the address space), and doing those things is basically the definition of a syscall.  Doing a branch without the protection level change would just trigger a fault of some kind.  (There are kernels, like DOS, where there is little to no protection and the branch is really all it takes.  But not Linux.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 7:05 UTC (Fri)
                               by <b>geuder</b> (guest, #62854)
                              [<a href="/Articles/1006029/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As already answered we are talking about a security boundary.<br>
<p>
The kernel has injected the code, but the user space process executes it. The fact that this code has somewhat special history is not sticky, it's just user space code. If it could cross the security boundary by some shortcut, there would he no way to prevent "original" user space code to use the same shortcut, i.e. cross the security boundary where it shouldn't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 7:19 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/1006033/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This kind of shortcut exists with vdso, but that is basically read-only and highly restricted to a couple of selected syscalls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 11:16 UTC (Fri)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/1006043/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which just raises the question: why not just have the trampoline use the vdso?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 13:59 UTC (Fri)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/1006060/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, the vdso doesn't cross any security boundary, it runs solely in user space; there's no shortcut. When it needs to cross the security boundary, the code in the vdso has to do a system call. The kernel does share some read-only data pages which the vdso can use to implement some system calls completely in user space, without entering the kernel; for instance, the adjustment variables necessary to convert the CPU clock (which is readable in user space, through the rdtsc instruction on x86 or equivalents in other architectures) into the real time or monotonic clocks. But it's still user-space only code, it could even be reimplemented outside the vdso (other than it being very kernel-version-specific, since the layout of the shared data pages is an implementation detail of the kernel and can change at any time).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006116"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 18:04 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/1006116/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you define the read access as "not crossing a security barrier", then yes.<br>
But that's a rather strange definition, IMO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006116/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 21:02 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/1006132/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The vDSO is userspace code reading userspace memory. True, the kernel does take care to set up those pages of memory with certain "magic" values, but those values are not sensitive (or if they are, the kernel does the relevant security checks at program startup before it maps the pages). After program startup, it's just another shared object, no different from libc or any other userspace library.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 21:08 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/1006134/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would you please read the thread I replied to?<br>
I never said that this was not userspace code. Quite contrary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 22:13 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/1006136/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If your definition of "crossing a security boundary" includes userspace code dereferencing a pointer into userspace memory, then we will have to agree to disagree.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 1:45 UTC (Sat)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/1006142/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So, why isn't vdso implemented as an actutal so file, if it's just an ordinary userspace thing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 2:37 UTC (Sat)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006143/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because it is dependent on the layout of the data page that the kernel maps into the process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 3:40 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/1006144/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Layout and logistics. It can be implemented as a shared object somewhere in /proc or /sys, but none of these are guaranteed to be available for the applications (and on Android neither of them are, btw).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 15:55 UTC (Sat)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/1006158/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Furthermore, on 32-bit x86 the fastest way to make syscalls depends on what the CPU supports - thus making syscalls is preferably done by calling into the VDSO. So you couldn't even make the syscalls to open/map the vdso without ugly hacks like having separate syscall stubs for early process startup code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1006077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why a syscall?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 14:32 UTC (Fri)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006077/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If it could cross the security boundary by some shortcut, there would he no way to prevent "original" user space code to use the same shortcut, i.e. cross the security boundary where it shouldn't.</span><br>
<p>
This is wrong, the article very explicitly says there *is* a way:<br>
<p>
<span class="QuotedText">&gt; it can only be called from the kernel-injected special trampoline; otherwise it will just deliver a SIGILL signal to the calling process.</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor1006032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why no sysctl?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 7:16 UTC (Fri)
                               by <b>geuder</b> (guest, #62854)
                              [<a href="/Articles/1006032/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I fail to see why they don't want a sysctl. Of course there are too many... But from a kernel perspective that seems the best solution to me. Just let the distro decide what user experience they want to give: Best performance, but legacy code might fail or maximum compatibility with a performance hit. And the expert user can switch if their need is different than what the distro chose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just accelerate traps?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 14:09 UTC (Fri)
                               by <b>bushdave</b> (subscriber, #58418)
                              [<a href="/Articles/1006070/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the problem is that the trap instruction is slower than a syscall, why not just make a trap() syscall documented to behave just like a trap instruction? This syscall should not be affected by seccomp(), since a trap instruction is not affected by seccomp(). A solution like this is also re-usable for other scenarios.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just accelerate traps?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 22:35 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/1006198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ironically, in the old days (386), it was the other way round: Traps were faster than syscalls.[1]<br>
<p>
<a href="https://devblogs.microsoft.com/oldnewthing/20041215-00/?p=37003">https://devblogs.microsoft.com/oldnewthing/20041215-00/?p...</a><br>
<p>
[1] To the degree “syscall” was a more sanctioned way to make a syscall, e.g., INT some_value. The SYSCALL instruction didn't exist yet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1006073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 14:27 UTC (Fri)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006073/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not a kernel maintainer, but I definitely disagree with Kees here.<br>
<p>
The uretprobe syscall is an implementation detail. The application does not contain it, the application has no choice about it (because uretprobes would be attached by an outside mechanism like a debugger), so why should the application know or care about adding it to its seccomp mask?<br>
<p>
Imagine if we had to authorize internal kernel functions via seccomp. Implementation of some other syscall changed in kernel X.Y? Too bad, if you don't add all of the new contents of the call graph, the application stops working.<br>
<p>
The security arguments don't appear to hold any water: the article says that uretprobe() syscall is guarded against unauthorized usage in its implementation, so if an application calls one itself, it'll just deliver a SIGILL.<br>
<p>
So yes, uretprobe() _is_ special: it's not used by the application, it's injected by the kernel dynamically as part of operation of another feature, it has its own protections... It *should* be invisible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 15:02 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/1006084/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are right.  But that suggests there should be a single syscall which is the only one the kernel will ever inject into processes (and which cannot ordinarily be called from user space).  The uretprobes will be the first application of this new call (passing 0 as the first parameter or something) but others may be added in future.  Then this call and this only can be ignored by seccomp.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1006120"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 19:59 UTC (Fri)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/1006120/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It does not matter if it was the kernel that injected the code. The code runs in the user space and so a malicious code can also try to call the uretprobe syscall. And the implementation may have bugs. As a defense in depth one may want to block all that functionality until the code mature and sufficiently tested to add it to the white list.<br>
<p>
The real trouble with secomp is that it is implemented as BPF code so uretprobe has no chance to know if it will be denied in advance before the code injection. If, for example, secomp API would apply per syscall, so one can check if a particular call has a filter associated with it, the implementation could check if can use uretprobe or should use older and less performant trap code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006120/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2025 20:28 UTC (Fri)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006126/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It does not matter if it was the kernel that injected the code. The code runs in the user space and so a malicious code can also try to call the uretprobe syscall.</span><br>
<p>
It does, though. As said above, the implementation handles this case.<br>
<p>
<span class="QuotedText">&gt; And the implementation may have bugs</span><br>
<p>
Just like any other functionality.<br>
<p>
<span class="QuotedText">&gt; As a defense in depth one may want to block all that functionality until the code mature and sufficiently tested to add it to the white list.</span><br>
<p>
As said elsewhere by another commenter, if the goal is "defense-in-depth" conservatism, then it's the wrong layer to make these restrictions at. If it's a defense-in-depth mechanism, then it must be handled with a more suitable mechanism, like a separate sysctl or in the same vein as other ptrace-related restrictions.<br>
<p>
In other words: if the goal is to protect against "immature not sufficiently tested code", then it's a policy decision that must be taken by the local administrator, not by every single application which **has nothing to do with the syscall being injected**.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 19:43 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/1006162/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In other words: if the goal is to protect against "immature not sufficiently tested code", then it's a policy decision that must be taken by the local administrator, not by every single application </span><br>
<p>
The problem was caused by Docker, not the application code. Configuration of default policy for the Docker is responsibility of administrator or at least the distribution, not applications.<br>
<p>
And Docker is absolutely right here. Its policy is about minimizing the attack surface against the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2025 20:12 UTC (Sat)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006164/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The problem was caused by Docker, not the application code.</span><br>
<p>
Well, that's even worse. That's double "spooky action at a distance".<br>
<p>
<span class="QuotedText">&gt; Its policy is about minimizing the attack surface against the kernel.</span><br>
<p>
You're making precisely zero sense. It's not Docker's business to accidentally restrict the administrator from injecting tracepoints using unrelated mechanisms into unrelated applications, and it's not Docker's business to enact such policy (even if it was intentional, which it is not, due to lousy architecture all around).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1006166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 1:39 UTC (Sun)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/1006166/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; &gt; And the implementation may have bugs</span><br>
<p>
<span class="QuotedText">&gt; Just like any other functionality.</span><br>
<p>
Right. That's the whole point of seccomp--that the software, both userspace *and* kernel, might have exploitable bugs, and that minimizing exposed kernel surface area is no less important (if not *more* important) than in-process mitigations for userspace code. seccomp has very little value as a defensive, mitigation layer if it's not deny by default.<br>
<p>
Someone else mentioned that everybody should be focused on capability systems, not seccomp. Well, I don't think many on the seccomp side would disagree that the community should be designing, implementing, and adopting capability systems more strongly. But that takes highly coordinated effort across all layers of the stack that the Linux software ecosystem in particular hasn't been particularly successful at. Afterall, what's the capability story with uretprobe? There's no file descriptor/token involved. How would it even work--the profiler is effectively injecting code in the application. And presuming there was some proper capability system involved, Docker's strategy here is to impose a jail without the cooperation of the application (it's the administrator, via Docker making a policy decision for an application that itself isn't even aware of the mechanism), and in a proper capability system Docker would likely be a broker that would presumably deny by default. Docker exists for the same reason seccomp exists--because administrative tooling is easier for the mainstream to adopt than to coordinate refactoring of application stacks.<br>
<p>
There are no easy answers, here. OpenBSD has pledge, a saner, more comprehensive seccomp, and it works very well there. But pledge is premised on the notion that each application is refactored to make proper use of it; it doesn't work much better as a practical matter than seccomp when imposed administratively. FreeBSD has Capsicum, a capability architecture. But FreeBSD has a much more diverse ecosystem, refactoring for Capsicum is a much heavier lift, and it's seen little uptake by non-core software.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 2:03 UTC (Sun)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006169/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Right. That's the whole point of seccomp--that the software, both userspace *and* kernel, might have exploitable bugs, and that minimizing exposed kernel surface area is no less important (if not *more* important) than in-process mitigations for userspace code. seccomp has very little value as a defensive, mitigation layer if it's not deny by default.</span><br>
<span class="QuotedText">&gt; &lt;...&gt;</span><br>
<span class="QuotedText">&gt; Docker's strategy here is to impose a jail without the cooperation of the application (it's the administrator, via Docker making a policy decision for an application that itself isn't even aware of the mechanism), and in a proper capability system Docker would likely be a broker that would presumably deny by default. Docker exists for the same reason seccomp exists--because administrative tooling is easier for the mainstream to adopt than to coordinate refactoring of application stacks.</span><br>
<p>
*What* capability would Docker be denying by default, if this was a capability-based system?<br>
<p>
There is no (hypothetical) capability that is being used by the target application. I, as the administrator (presumably in possession of root-equivalent privileges), am requesting the kernel to inject some code into the target application on my behalf. Nothing else in the system (not Docker, not the target application) has any business meddling with this request in any way.<br>
<p>
Seccomp has about as much reason to block this pseudo-syscall as it has to block, say, a trap instruction. Seccomp doesn't block trap instructions, now does it? They are entry points into the kernel too, after all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 2:10 UTC (Sun)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006171/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I, as the administrator (presumably in possession of root-equivalent privileges), am requesting the kernel to inject some code into the target application on my behalf.</span><br>
<p>
Slight correction: I am requesting the kernel to "do something" to let me trace the application. What this "something" is is an implementation detail of the kernel. This implementation detail has its own protections against being abused. So it makes even less sense that Docker can somehow interfere with this implementation detail.<br>
<p>
Like I said: it's as if we had to use seccomp to whitelist internal kernel functions that are being invoked during the course of execution of an (otherwise allowed) syscall, on the grounds that "if the kernel is calling some new functions, those represent untested code paths which we want to deny by default because they are untested and immature".<br>
<p>
It makes no sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 8:33 UTC (Sun)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/1006176/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The malicious userspace can execute the new syscall even if no system administrator has asked for it. One can argue that the implementation on the kernel side is bulletproof and clearly rejects such attempts, but the past experience is full of cases when this was false.<br>
<p>
So secomp is right to reject this case. The trap case is fundamentally different because that code is extremely mature and well-tested allowing secomp to trust that by default. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 14:40 UTC (Sun)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006184/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The trap case is fundamentally different because that code is extremely mature and well-tested allowing secomp to trust that by default. </span><br>
<p>
Seccomp never "distrusted" trap instructions. It cannot prevent trap instructions from being executed, never did. It's not because "seccomp trusts that by default", it's because trap instructions are out of scope of seccomp, always were, always would be.<br>
<p>
So no, this reasoning is invalid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1006182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 12:25 UTC (Sun)
                               by <b>glettieri</b> (subscriber, #15705)
                              [<a href="/Articles/1006182/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  This implementation detail has its own protections against being abused.</span><br>
<p>
I may be wrong, but I think you are missing a point here.  The protection is against calls coming from outside the injected trampoline (or even from the exact location in the trampoline). But an attacker who has hijacked the control flow in the traced application can make it jump into the trampoline and issue a uretprobe syscall that passes the protection check. Therefore, if there are bugs in the uretprobe implementation, the injected trampoline potentially exposes those bugs to the attacker.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 14:51 UTC (Sun)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1006185/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I think you are missing a point here</span><br>
<p>
I think you are missing mine. How is it different from an application hijacking control flow or whatever to jump to the previous implementation of this mechanism, i.e., a trap instruction? The answer is "it's not", and we were okay with it.<br>
<p>
This argument is clearly going in circles, so in order not to incur the wrath of our editors, I will stop participating in this subthread. (However, I must note that this is not equal to conceding.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hard disagree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2025 15:35 UTC (Sun)
                               by <b>glettieri</b> (subscriber, #15705)
                              [<a href="/Articles/1006189/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I think you are missing mine. How is it different from an application hijacking control flow or whatever to jump to the previous implementation of this mechanism, i.e., a trap instruction? The answer is "it's not", and we were okay with it.</span><br>
<p>
Good point, I see what you mean now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1006521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">update docker's seccomp policy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2025 18:50 UTC (Tue)
                               by <b>meyert</b> (subscriber, #32097)
                              [<a href="/Articles/1006521/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So the user did upgrade the Linux kernel, and docker did break because of the strict seccomp deny policy?<br>
So why didn't the user update the docker seccomp profile after kernel upgrade?<br>
I had to do that on an old rhel 7 system with very new jvms for similar reason.. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1006857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">update docker's seccomp policy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2025 6:54 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/1006857/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah I was also confused by this article too.  Updating the kernel is possible, but updating docker (or just seccomp policies) is impossible and will take years and years?  That's not any Linux distro that I'm familiar with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1006860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Effects on systemd service units</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2025 7:18 UTC (Thu)
                               by <b>kpfleming</b> (subscriber, #23250)
                              [<a href="/Articles/1006860/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is becoming common for systemd service units (shipped in packages) to use systemd's similar facilities for only allowing specified groups of syscalls, and the new uretprobe() syscall isn't going to be included in any of those lists in existing installations of systemd.<br>
<p>
see: <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#System%20Call%20Filtering">https://www.freedesktop.org/software/systemd/man/latest/s...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1006860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1007050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Effects on systemd service units</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2025 18:11 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/1007050/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I note that BIND removed its seccomp jail because of repeated instances of things like this hanging named and even hanging named before daemonization (often preventing boot from continuing).<br>
<p>
The OpenSSH seccomp jail is the only one I know of in core daemons that hasn't hit disastrous problems and been ripped out.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1007050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1007183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Effects on systemd service units</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2025 11:43 UTC (Fri)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/1007183/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A lot of those security technologies built into systemd can have some unexpected additional failure modes, e.g. the other day I had a failure in one of the services using some of the mount restrictions (PrivateTmp or something equally common, don't remember which one exactly) and the unit failed to start because the host also has a network mount that couldn't reach the CIFS server (was mounted and then lost contact rather) and so creating the new mount namespace failed.<br>
<p>
It is unfortunate since I would prefer to use more of them in as many units as possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1007183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2025, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
