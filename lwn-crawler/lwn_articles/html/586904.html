        <!DOCTYPE html>
        <html lang="en">
        <head><title>File-private POSIX locks [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/586904/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/586022/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/586904/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>File-private POSIX locks</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>February 19, 2014</p>
           <p>This article was contributed by Jeffrey T. Layton</p>
           </div>
<p>
File locks are heavily used by applications such as databases and
file servers. Whenever you have multiple programs accessing
files at the same time there is always the potential for data corruption
or other bugs unless that access is carefully synchronized. File locks solve that problem, but the existing
implementation can be difficult to use, especially for multi-threaded
programs.  File-private POSIX locks are an attempt to take elements of both
BSD-style and POSIX locks and combine them into a more threading-friendly
file locking API.

<p>
 Multiple
writers attempting to change a file at the same time can clobber each
other's changes. 
In addition, an update to a file may need to be done in more than one
place. If another thread of execution sees only part of the update,
it may trigger bugs in the program.

<p>
File locks are generally available in two flavors: read (also known as
shared) locks and write (also known as exclusive) locks. Multiple read
locks can be given out for a portion of a file, but only one write lock can be
handed out at any given time, and only if no other read or write lock for
that region
has been set.
While file locks on some operating systems are mandatory, on Unix-like
systems locking is generally advisory. Advisory locks are like
stoplights &mdash; they only work if everyone pays attention to them.
<p>
One of the primary mechanisms to handle file locking is the one
specified by the POSIX standard. POSIX defines a file-locking standard
that allows the ability to lock arbitrary byte ranges in a file for read
or write.
Unfortunately, they have a couple of serious problems that
make them unsuitable for use by modern applications.
<p>
<h4>The problems with POSIX locking</h4>

<p>
Whenever a program attempts to acquire a lock, that lock is either
granted or denied based on whether there is already a conflicting lock
set over the given range. If there is no conflicting lock present, the
lock will be granted. If there is then it will be denied.
<p>
Classic POSIX lock requests from the same process never conflict with one
another. When a request for a lock comes in that would conflict with an
existing lock that the process set previously, the kernel treats it as a
request to modify the existing lock.
Thus, classic POSIX locks are useless for synchronization between threads
within the same process. Given the prevalence of threaded applications in
modern computing, this renders POSIX locks fairly useless as a synchronization
mechanism.
<p>
More troublingly, the standard states that all locks held
by a process are dropped any time the process closes <i>any</i> file descriptor
that corresponds to the locked file, even if those locks were made using a
still-open file descriptor. It is this detail that catches
most programmers by surprise as it requires that a program take extra care not to close a file
descriptor until it is certain that locks held on that file are able to
be dropped.
<p>
That's not always a simple question to answer. If a program opens two
different links of a hardlinked file, takes a lock on one file
descriptor and then closes the other, that lock is implicitly dropped
even though the file descriptor on which the lock was originally
acquired remains open.
<p>
This is a particular problem for applications that use complex libraries
that do file access. It's common to have a library routine that opens a
file, reads or writes to it, and then closes it again, without the calling
application ever being aware that has occurred. If the application
happens to be holding a lock on the file when that occurs, it can lose
that lock without ever being aware of it.

That sort of behavior can lead to silent data corruption, and loss of
developer sanity.
Jeremy Allison has an <a href="http://www.samba.org/samba/news/articles/low_point/tale_two_stds_os2.html">excellent writeup of this problem</a> and of how such a broken standard came into being (see the section entitled
"First Implementation Past the Post").
<p>
There is however, another competing (or complementary) file locking standard
that has its roots in BSD Unix. These locks (which are manipulated via the
<tt>flock()</tt> system call) have more sane semantics.  Whereas POSIX
locks are owned by the process, BSD locks are owned by the open file.


If a process opens a file twice and tries to set exclusive locks on both, the
second one will be denied. Thus, BSD locks are usable as a synchronization mechanism
between threads as long as each thread has a separate opened file. Note
that cloning a file descriptor with <tt>dup()</tt> is not sufficient since that simply takes a reference to the same opened file.
<p>
Also, BSD locks are only released when the last reference to the open
file on which they were acquired is closed. Thus if a program opens a
file, takes a lock on it and then uses <tt>dup()</tt> to duplicate the file
descriptor, the lock will only be released automatically when both file
descriptors are closed.
<p>
The only real problem with BSD locks is that they are whole-file locks.
POSIX locks, on the other hand can operate on arbitrary byte ranges
within a file.
While whole-file locks are useful (and indeed, many applications just
lock entire files even with POSIX locks), they are not sufficient for many
cases. Applications such as databases need granular locking in
order to allow for better parallelism.
<p>
<h4>File-private POSIX locks</h4>
<p>
I will assert that what is needed is a new type of lock that
is a hybrid of the two &mdash; a byte-range lock that has BSD-like semantics
for inheritance across <tt>fork()</tt> and on <tt>close()</tt>.
Furthermore, since there is a large legacy codebase of programs that use
"classic" POSIX locks, these new locks need to be aware of the classic locks so
that programs using the new locks will interoperate correctly with those
applications.
<p>
Classic POSIX locks are manipulated using a set of command values passed to
the <tt>fcntl()</tt> system call:
<p>
<ul>
    <li><tt>F_GETLK</tt>  - test whether a lock is able to be applied
    <li><tt>F_SETLK</tt>  - attempt to set a lock. Return error if unable to do so
    <li><tt>F_SETLKW</tt> - attempt to set a lock and block until able to do so
</ul>
<p>
These commands are accompanied by a pointer to a binary <tt>struct
flock</tt>
argument that looks something like this:
<p>
<pre>
    struct flock {
        short int l_type;   /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
        short int l_whence; /* Where `l_start' is relative to (like `lseek').  */
        off_t l_start;      /* Offset where the lock begins.  */
        off_t l_len;        /* Size of the locked area; zero means until EOF.  */
        pid_t l_pid;        /* Process holding the lock. (F_GETLK only) */
    };
</pre>
<p>
Similarly, file-private POSIX locks are manipulated with a similar set
of commands, this time appended with 'P':
<ul>
    <li><tt>F_GETLKP</tt>  - test whether a lock is able to be applied
    <li><tt>F_SETLKP</tt>  - attempt to set a file-private lock
    <li><tt>F_SETLKPW</tt> - attempt to set a file-private lock and block until able to do so
</ul>
<p>
The new commands should look very familiar to those used to working
with classic POSIX locks and they take the same <tt>struct flock</tt> argument.
The only real difference between file-private and classic POSIX locks
is their "ownership". Classic POSIX locks are owned by the process
whereas file-private POSIX locks are owned by the opened file.
<p>
<h4>Using file-private POSIX locks</h4>
<p>
It is currently necessary to define the <tt>_GNU_SOURCE</tt> preprocessor macro
in order to get the new command definitions as file-private locks are not
yet part of POSIX.
Using file-private locks is very similar to using classic POSIX locks.
In many cases, one can simply replace the command value with the file-private
equivalent.
There are subtle differences, however.

<p>
Since one of the most troublesome aspects of classic POSIX locks is their
behavior on close, there should be no surprise that file-private locks
behave differently. File-private locks are only released automatically
when the last reference to the open file is released.
<p>
It's tempting to then consider file-private locks to be "owned" by the file
descriptor, but that's not technically true. If a file descriptor is cloned
via <tt>dup()</tt>, the kernel will simply take an extra reference to the
open file and assign it to a new slot in the open file descriptor table.
File-private locks set on a cloned file descriptor will not conflict
with locks set on the original file descriptor. The kernel will treat
such a lock request as a request to modify the existing lock.
Furthermore, file-private locks set using either file descriptor would
only be released automatically once both file descriptors are closed,
though one can always release a lock manually with an <tt>F_UNLCK</tt> request.
<p>
Interaction across <tt>fork()</tt> is very similar. When <tt>fork()</tt>
is called, the kernel takes an extra reference to each open file and
assigns it to the same slot in the new process's file descriptor table.
Locks set by either process on the same open file would not conflict with
one another, and would only be automatically released once
both processes have closed it.

<p>
Classic and file-private locks will always conflict with one another,
even when used in the same process and/or on the same file descriptor. I
don't expect that many programs will mix the two, but given the pain
that undefined behaviors can cause I think it's prudent to declare that
explicitly.
<p>
<h4>Whither <tt>F_GETLK</tt>?</h4>
<p>
<tt>F_GETLK</tt> would probably have been better named
<tt>F_TESTLK</tt>. While it does technically fetch the existing status
of a locked range, its real purpose is to allow one to test whether a given lock
request could be set without actually setting it. If there happens to be
a conflicting lock already set within that range, the kernel will
overwrite the <tt>struct flock</tt> with information about that lock
and set <tt>l_pid</tt> to the value of the process that owns that lock.
<p>
The <tt>l_pid</tt> field is a bit of a dilemma for file-private locks.
File-private locks are not owned by processes. A file descriptor could
have been inherited across a <tt>fork()</tt>, so the <tt>l_pid</tt>
value is somewhat meaningless if the conflicting lock is a file-private
one.
Still, when a program using classic POSIX locks calls <tt>F_GETLK</tt>, we do
need to put something in the <tt>l_pid</tt> field. That something is
<tt>-1</tt>.
<p>
This precedent comes from BSD. On Linux, POSIX and BSD locks operate in a
completely different namespace. On BSD, however, they operate in the same
namespace and, thus, will conflict with each other. If a program holds a
BSD lock on a file, and 
another does a <tt>F_GETLK</tt> request against it, the BSD kernel will set the
<tt>l_pid</tt> to <tt>-1</tt>.
Since portable programs already need to contend with such behavior,
using the same behavior for file-private locks seems like a reasonable
choice.
<p>
<h4>Using file-private locks with threads</h4>
<p>
It's common for modern applications to use a threading model instead
of forking to create a new thread of execution. This is problematic
with classic POSIX locks. They are associated with a process, so locks
acquired by threads within the same process cannot conflict.
<p>
With file-private locks however we can circumvent that restriction by
giving each thread its own open file. Here's an example (note that
I've left out proper error handling for the sake of brevity):
<p>
<pre>
    #define _GNU_SOURCE
    #include &lt;stdio.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/stat.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;fcntl.h&gt;
    #include &lt;pthread.h&gt;

    #define FILENAME    "/tmp/foo"
    #define NUM_THREADS 3
    #define ITERATIONS  5

    void *
    thread_start(void *arg)
    {
        int i, fd, len;
        long tid = (long)arg;
        char buf[256];
        struct flock lck = {
            .l_whence = SEEK_SET,
            .l_start  = 0,
            .l_len    = 1,
        };

        fd = open(FILENAME, O_RDWR|O_CREAT, 0666);

        for (i = 0; i &lt; ITERATIONS; i++) {
            lck.l_type = F_WRLCK;
            fcntl(fd, F_SETLKPW, &amp;lck);

            len = sprintf(buf, "%d: tid=%ld fd=%d\n", i, tid, fd);

            lseek(fd, 0, SEEK_END);
            write(fd, buf, len);
            fsync(fd);

            lck.l_type = F_UNLCK;
            fcntl(fd, F_SETLKP, &amp;lck);

            usleep(1);
        } 
        pthread_exit(NULL);
    }

    int
    main(int argc, char **argv)
    {
        long i;
        pthread_t threads[NUM_THREADS];

        truncate(FILENAME, 0);

        for (i = 0; i &lt; NUM_THREADS; i++)
            pthread_create(&amp;threads[i], NULL, thread_start, (void *)i);

        pthread_exit(NULL);
        return 0;
    }
</pre>

<p>
This example spawns three threads and has each do five iterations of
appending to 
a file. Access to that file is serialized via file-private locks. If we
compile and run the above program, we end up with <tt>/tmp/foo</tt> that has 15
lines in it.
<p>
If we, however, were to replace the <tt>F_SETLKP</tt> and
<tt>F_SETLKPW</tt> commands with their classic POSIX lock equivalents,
the locking essentially becomes a noop since it is all done within the
context of the same process. That leads to data corruption (missing
lines) as some threads race in and overwrite the data from others.
<p>
<h4>Conclusion</h4>
<p>
File-private locks can solve many of the problems experienced with
classic POSIX locks, but programmers intending to use them should take
heed of the differences.
<p>
Developers from several projects including Samba, NFS Ganesha, SQLite,
and OpenJDK have expressed interest in using file-private locks since
they help simplify the code for many of their use cases, and help eliminate data
corruption issues that can occur when files are closed.
<p>
The kernel patchset is available in  the linux-kernel <a
href="http://thread.gmane.org/gmane.network.samba.internals/74464">
mailing list posting</a>, or via the <a
href="http://git.samba.org/?p=jlayton/linux.git;a=shortlog;h=refs/heads/linux-next">linux-next
branch of my git tree</a>. I plan to keep that branch updated with the latest
version until it gets merged into mainline kernels. The kernel
patches are currently being pulled into the linux-next tree as well. Anyone
using linux-next kernels can use these now.

There is also a (fairly trivial) <a
href="http://git.samba.org/?p=jlayton/glibc.git;a=shortlog;h=refs/heads/file-private">GNU
C library (glibc)
patchset</a> which implements the definitions needed to access these
locks.
<p>
I'm currently aiming to have the kernel patches merged into
mainline in v3.15, and glibc patches to add the new command definitions
along with an update to the glibc manual should hopefully be merged soon
afterward. 
Assuming that these patches are merged, I also intend to submit an update to
the POSIX specification to make these a formal part of POSIX.  I have
opened a <a href="http://austingroupbugs.net/view.php?id=768">request</a> to
have it considered. There have already been some helpful suggestions
and The Austin Group (who oversees POSIX) seems receptive to the general idea.
<p>
Hopefully other operating systems will follow suit and implement these
as well so that programmers dealing with those platforms can reap the same
benefits.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-POSIX_locks">Filesystems/POSIX locks</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Layton_Jeffrey">Layton, Jeffrey</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/586904/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor587383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2014 17:10 UTC (Thu)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/587383/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"With file-private locks however we can circumvent that restriction by giving each thread its own open file."<br>
<p>
Are there cases where we'd want to use file locking to coordinate access to a file that we only know by file descriptor?<br>
<p>
For example, you can open a file, unlink it, fork, and then use posix locks to coordinate parent and child, but that's something file-private locks can't do.  (Unless I'm misunderstanding something.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2014 14:40 UTC (Fri)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/587533/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, the simple workaround is to have the parent open the file twice, unlink it and then fork. Designate one fd for the parent and one for the child.<br>
<p>
I'm not sure what we can do about the case where all we have is a fd though. Do we have an actual use-case for that?<br>
<p>
If so, then one possibility would be to add something like a fd_to_handle() syscall and then use open_by_handle_at() to reopen it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587544"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2014 15:13 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/587544/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can already reopen a file given an fd by calling open on "/proc/self/fd/%d"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587544/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2014 15:46 UTC (Fri)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/587552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I forgot about that.  OK, that would be simpler!
      
          <div class="CommentReplyButton">
            <form action="/Articles/587552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor587547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2014 15:38 UTC (Fri)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/587547/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Do we have an actual use-case for that?</blockquote>

<p>I don't.

<blockquote>If so, then one possibility would be to add something like a fd_to_handle() syscall</blockquote>

<p>Oh, good idea, looks like we already have that--it should work to do

<pre>
  ret = name_to_handle_at(fd, NULL, &amp;handle, &amp;mnt_id, AT_EMPTY_PATH)
  if (!ret)
    newfd = open_by_handle_at(fd, &amp;handle, O_RDWR);
</pre>

<p>(untested.)  So that gives a way to create arbitrary "owners" for the purpose of file lock conflicts, good.

<p>I wonder why there isn't some way to do an AT_EMPTY_PATH open?  Then you could do it with one syscall

<pre>  newfd = openat(fd,..., AT_EMPTY_PATH)</pre>

<p>and there'd be no need to require an exportable filesystem or involve the filehandle code.
      
          <div class="CommentReplyButton">
            <form action="/Articles/587547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2014 16:04 UTC (Fri)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/587555/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hah, I had forgotten about /proc/pid/fd too...thanks, foom!<br>
<p>
An AT_EMPTY_PATH open sounds like a neat idea, but as always we'd have to think through the security implications.<br>
<p>
What happens if you open the file, drop privs such that it would no longer be reachable by lookup and then do an AT_EMPTY_PATH open? Is that bad juju?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2014 16:09 UTC (Fri)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/587556/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>What happens if you open the file, drop privs such that it would no longer be reachable by lookup and then do an AT_EMPTY_PATH open? Is that bad juju?</blockquote>

<p>Commit f0cc6ffb8ce8961db587e5072168cac0cbc25f05 on the comparable problem for link is interesting:

<pre>
    Revert "fs: Allow unprivileged linkat(..., AT_EMPTY_PATH) aka flink"
    
    This reverts commit bb2314b47996491bbc5add73633905c3120b6268.
    
    It wasn't necessarily wrong per se, but we're still busily discussing
    the exact details of this all, so I'm going to revert it for now.
    
    It's true that you can already do flink() through /proc and that flink()
    isn't new.  But as Brad Spengler points out, some secure environments do
    not mount proc, and flink adds a new interface that can avoid path
    lookup of the source for those kinds of environments.
    
    We may re-do this (and even mark it for stable backporting back in 3.11
    and possibly earlier) once the whole discussion about the interface is done.</pre>

Looks like an unanswered question?
      
          <div class="CommentReplyButton">
            <form action="/Articles/587556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587562"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2014 16:39 UTC (Fri)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/587562/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I'm not sure. I guess it's usually best to err on the side of caution (and that's what that patch does). For now it's probably best to simply suggest reopening /proc/pid/fd in that sort of situation.<br>
<p>
We're wandering off into theoretical territory here anyway...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587562/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587653"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2014 9:46 UTC (Sat)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/587653/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi Jeff,<br>
It's great to see that this might actually be happening at last!<br>
<p>
In Jeremy Allison's writeup that you linked he observes:<br>
<p>
<font class="QuotedText">&gt; A simple amendment to the original primitive allowing a user-defined "locking context" (like a process id) to be entered in the struct flock structure used to define the lock would have fixed this problem</font><br>
<p>
"this problem" being much the same as you and Bruce are discussing above.  i.e. rather than requiring separate opens, you could require 'l_pid' to be set either to 0 or a negative number.  Each negative number would be a separate locking sub-context within the context of a given file open. (positive numbers of course being reserved for posix lock pids).<br>
<p>
Did you give any thought to implementing something like this?<br>
<p>
(even if not, it might be worth rejecting setlk requests with l_pid!=0 as a future-proofing measure).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587653/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2014 13:16 UTC (Sun)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/587726/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Overloading the l_pid's meaning sounds pretty difficult to implement in practice and would lead to convoluted semantics:<br>
<p>
Suppose I lock two adjacent bytes in two F_SETLK requests and set the l_pid in both to '-1'. I then go and do an F_UNLCK request that encompasses both bytes (while setting l_pid to 0). Which ones get released?<br>
<p>
I think that we could implement something like different lock contexts within a single fd, but that would probably require a new API. At the very least we'd need a "struct flock2" that has an opaque l_owner field or something.<br>
<p>
One of the other things that the Samba and Ganesha devs have said they would like is an asynchronous locking API. Something that allows you to set a blocking lock and be called back when it's free, leaving the calling thread free to go off and do other things. That's a much more complex problem to handle.<br>
<p>
I did consider both, but I think there's value in simplicity with this sort of thing. Maintaining extra fds is not terribly difficult in most cases, and having a 1:1 lock context to fd ratio is simple to conceptualize.<br>
<p>
Note that this work does not preclude us adding a new API onto the file locking layer in the future that does these things.<br>
<p>
That said, rejecting F_SETLKP[W] requests with a non-zero l_pid sounds like a good idea. I may respin this again and add that.<br>
<p>
One of my main goals here is to leave as little undefined behavior as possible since that's almost always a recipe for trouble later.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2014 13:49 UTC (Sun)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/587731/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hah, sorry -- I shouldn't post before I've had my morning coffee. I misunderstood what you were asking, so let me try again...<br>
<p>
Ok, so in your above example the answer is that no locks would be released. So yeah, we could (in principle) overload the l_pid field with a lock context like you suggest.<br>
<p>
Still, that seems like one of those subtle things that would be easy to mess up. What might be better is to simply add a "struct flock2" that adds a separate l_owner value.<br>
<p>
I guess the question is whether the extra complexity of juggling opaque contexts is really any better than juggling separate fds. You would avoid having to do extra open()s, but using file locking at all sort of implies that you're dealing with long-lived fds anyway, so would it be worthwhile?<br>
<p>
I still think if we want to add something like the l_owner field, it'd be best to do so in the context of a new API altogether that allows you to do this asynchronously as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor589259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2014 18:17 UTC (Tue)
                               by <b>sethml</b> (guest, #8471)
                              [<a href="/Articles/589259/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>One of the other things that the Samba and Ganesha devs have said they would like is an asynchronous locking API. Something that allows you to set a blocking lock and be called back when it's free, leaving the calling thread free to go off and do other things. That's a much more complex problem to handle.</blockquote>

Isn't this the type of problem that poll() and select() solve? Provide a way to convert a file range lock into an FD, and then you can poll() for taking the lock or other things.

This is one thing I feel the Win32 api got right and POSIX got wrong: in Win32 there's a HANDLE type for mutexes, open files, and generally anything you might want to block for, and a variety of WaitForHandles() type calls. In POSIX, if a thread wants to block until either of two mutexes is available, or either a mutex or a file read is available, you're out of luck. Or you have to play crazy games with sending a single byte through a pipe to the thread.
      
          <div class="CommentReplyButton">
            <form action="/Articles/589259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor591892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2014 16:35 UTC (Tue)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/591892/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's an interesting idea. I'm certainly not opposed to a new API for driving file-private locks, but that can (and should, IMO) live in conjunction with the fcntl() interface. I think adding such an interface is a separate project however.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/591892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor587685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2014 22:26 UTC (Sat)
                               by <b>MegabytePhreak</b> (guest, #60945)
                              [<a href="/Articles/587685/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It isn't clear to me why the obvious approach of having the lock being linked to the FD isn't used. (As opposed to here where the lock is linked to the FD and any copies such as made by dup).<br>
What is gained by the more complicated approach? It seems to violate the principle of least surprise,<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor587687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2014 23:03 UTC (Sat)
                               by <b>Jonno</b> (subscriber, #49613)
                              [<a href="/Articles/587687/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It isn't clear to me why the obvious approach of having the lock being linked to the FD isn't used. (As opposed to here where the lock is linked to the FD and any copies such as made by dup).</font><br>
From my understanding copies made by dup and copies made by fork are indistinguishable, so tying file-private locks to the fd rather than to the open file table entry would make it unusable in multi-process scenarios.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor587690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2014 23:37 UTC (Sat)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/587690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Tying anything to an FD is just broken conceptually. An FD is supposed to be purely a refcounted handle to a "file description" -- an open file.  You should be able to renumber fds, copy, close, etc to your heart's content without it causing any other side effects, until you close the last one.<br>
<p>
The only exception to that right now is POSIX locks -- which is one of the ways it's completely stupidly broken.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor587727"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">File-private POSIX locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2014 13:22 UTC (Sun)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/587727/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As others have responded, an "fd" is really just a slot in the opened file table that points to an opened file object. It's very difficult to tie *anything* to that slot, and I think that trying to do so would lead to a mess similar to how classic POSIX locks work today.<br>
<p>
One of the main reasons for settling on these semantics is that we already have experience with them. BSD (flock()) locks work like that today.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/587727/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor588063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Will interface be back-filled in glibc?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2014 19:15 UTC (Mon)
                               by <b>ms-tg</b> (subscriber, #89231)
                              [<a href="/Articles/588063/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Will it be possible for later versions of glibc to support this interface via backfilling the feature on older linux kernels?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/588063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor588074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Will interface be back-filled in glibc?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2014 20:09 UTC (Mon)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/588074/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure I understand the question, but I'll try to answer it anyway.<br>
<p>
The glibc patches are really quite trivial -- they just add the F_*LKP definitions. All of the "real work" is done by the kernel. The patches would need to be backported to the older kernel.<br>
<p>
The good news is that it is possible to determine whether these new cmd values are supported at runtime. fcntl() always returns -EINVAL if passed a cmd value that it doesn't recognize.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/588074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor589008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Will interface be back-filled in glibc?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2014 19:34 UTC (Sun)
                               by <b>ChrisDolan</b> (guest, #41017)
                              [<a href="/Articles/589008/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ms-tg, I'd say no. There's no way for userspace to emulate this feature in older kernels without deep out-of-band userspace cooperation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/589008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor628549"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">now available as &quot;Open File Description (OFD) Locks&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2015 21:11 UTC (Mon)
                               by <b>zack</b> (subscriber, #7062)
                              [<a href="/Articles/628549/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
According to <a href="http://austingroupbugs.net/view.php?id=768">http://austingroupbugs.net/view.php?id=768</a> (note 0002508), these locks have been merged into Linux v3.15 are are documented in the glibc manual at <a href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks">http://www.gnu.org/software/libc/manual/html_mono/libc.ht...</a><br>
<p>
Pretty amazing!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/628549/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor640404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Open File Description Locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2015 15:43 UTC (Wed)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/640404/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This comment should be considered an "errata" for this article. After this article was written, later discussions pointed out the "file-private" was really too ambiguous. The name we finally settled on was "open file description locks" (aka OFD locks).<br>
<p>
The constants were also similarly renamed:<br>
<p>
    # define F_OFD_GETLK    36<br>
    # define F_OFD_SETLK    37<br>
    # define F_OFD_SETLKW   38<br>
<p>
...it should also be noted that glibc currently requires that __GNU_SOURCE be defined before including fcntl.h in order to get these macros.<br>
<p>
When trying to set a lock, the API now requires that l_pid value in the flock struct be set to 0. This is in response to Neil Brown's suggestion, in the event that we decide to overload the meaning of that field in the future.<br>
<p>
Other than the above, the facility basically works as this article describes. <br>
<p>
Those folks wanting to use this facility should probably refer to a recent version of the glibc manual which now has a section on OFD locks, and examples of how to use them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/640404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
