        <!DOCTYPE html>
        <html lang="en">
        <head><title>An io_uring-based user-space block driver [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/903855/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/903819/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/903855/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>An io_uring-based user-space block driver</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 8, 2022</br>
           </div>
The addition of the ublk driver during the 6.0 merge window would have been
easy to miss; it was buried deeply within an io_uring pull request and is
entirely devoid of any sort of documentation that might indicate why it
merits a closer look.  Ublk is intended to facilitate the implementation of
high-performance block drivers in user space; to that end, it uses <a
href="/Articles/776703/">io_uring</a> 
for its communication with the kernel.  This driver is considered
experimental for now; if it is successful, it might just be a harbinger of
more significant changes to come to the kernel in the future.
<p>
Your editor has spent a fair amount of time beating his head against <a
href="/ml/io-uring/20220713140711.97356-1-ming.lei@redhat.com/">the source
for the ublk driver</a>, as well as the <a
href="https://github.com/ming1/ubdsrv">ubdsrv server</a> that comprises the
user-space component.  The picture that has emerged from this exploration
of that uncommented
and vowel-deficient realm is doubtless incorrect
in some details, though the overall shape should be close enough to
reality.
<p>
<h4>How ublk works</h4>
<p>
The ublk driver starts by creating a special device called
<tt>/dev/ublk-control</tt>.  The user-space server (or servers, there can
be more than one) starts by opening that device and setting up an io_uring
ring to communicate with it.  Operations at this level are essentially
<tt>ioctl()</tt> commands, but <tt>/dev/ublk-control</tt> has no
<tt>ioctl()</tt> handler; all operations are, instead, sent as commands
through io_uring.  Since the purpose is to implement a device behind
io_uring, the reasoning seems to be, there is no reason to not use it from
the beginning.
<p>
A server will typically start with a <tt>UBLK_CMD_ADD_DEV</tt> command; as
one might expect, it adds a new ublk device to the system.  The server can
describe various aspects of this device, including the number of hardware
queues it claims to implement, its block size, the maximum transfer size,
and the number of blocks the 
device can hold.  Once this command succeeds, the device exists as far as
the ublk driver is concerned and is visible as <tt>/dev/ublkc<i>N</i></tt>,
where 
<tt><i>N</i></tt> is the device ID returned when the device is created.
The device has not yet been added to the block layer, though.
<p>
The server should open the new <tt>/dev/ublkc<i>N</i></tt> device for the
following steps, the first of which is to map a region from the device into
the server's 
address space with an <tt>mmap()</tt> call.  This region is an array of
<tt>ublksrv_io_desc</tt> structures describing I/O requests:
<p>
<pre>
    struct ublksrv_io_desc {
	/* op: bit 0-7, flags: bit 8-31 */
	__u32		op_flags;
	__u32		nr_sectors;
	__u64		start_sector;
	__u64		addr;
    };
</pre>
<p>
Notification of new I/O requests will be received via io_uring.  To
get to that point, the server must enqueue a set of
<tt>UBLK_IO_FETCH_REQ</tt> requests on the newly created device; normally
there will be one for each "hardware queue" declared for the device, which
may also correspond to each thread running within the server.  Among other
things, this request must provide a memory buffer that can hold the maximum
request size declared when the device was created.
<p>
Once this setup is complete, a separate <tt>UBLK_CMD_START_DEV</tt>
operation will cause the ublk driver to actually create a block device
visible to the rest of the system.  When the block subsystem sends a
request to this device, one of the queued <tt>UBLK_IO_FETCH_REQ</tt> operations
will complete.  The completion data returned to the user-space server will
include the index of the 
<tt>ublkserv_io_desc</tt> structure describing the request, which the
server should now execute.  For a write request, the data to be written
will be in the buffer that was provided by the server; for a read, the data
should be placed in that same buffer.
<p>
When the operation is complete, the server must inform the kernel of that
fact; this is done by placing a <tt>UBLK_IO_COMMIT_AND_FETCH_REQ</tt>
operation into the ring.  It will give the result of the operation back to
the block subsystem, but will also enqueue the buffer to receive the next
request, thus avoiding the need to do that separately.
<p>
There are the expected <tt>UBLK_CMD_STOP_DEV</tt> and
<tt>UBLK_CMD_DEL_DEV</tt> operations to make existing devices go away, and
a couple of other operations to query information about existing devices.
There are also a number of details that have not been covered here, mostly
aimed at increased performance.  Among other things, the ublk protocol is
set up to enable zero-copy I/O, but that is not implemented in the current
code.
<p>
The server code implements two targets: null and loop.  The null target is,
as one might expect, an overly complicated, block-oriented version of
<tt>/dev/null</tt>; it is useless but makes it possible to see how things
work with a minimum of unrelated details.  The loop target uses an existing
file as the backing store for a virtual block device.  According to author
Ming Lei, with this loop implementation, "<q>the performance is
is even better than kernel loop with same setting</q>".
<p>
<h4>Implications</h4>
<p>
One might wonder why this work has been done (and evidently supported by
Red Hat); if the world has been clamoring for an io_uring-based,
user-space, faster loop block device, it has done so quietly.  One
advantage cited in the patch cover letter is that development of
block-driver code is more easily done in user space; another is
high-performance <a href="https://en.wikipedia.org/wiki/Qcow">qcow2</a>
support.  The patch cover letter also cites interest expressed by other
developers in having a fast user-space block-device mechanism available.

<p>
An interesting question, though, is whether this mechanism might ultimately
facilitate the movement of a number of device drivers out of the kernel —
perhaps not just block drivers.  Putting device drivers into user-space
code is a fundamental concept in a number of secure-system designs,
including microkernel systems.  But one of the problems with those designs
has always been the communication overhead between the two components once
they are no longer running within the same address space.  Io_uring might
just be a convincing answer to that problem.
<p>
Should that scenario play out, kernels of the future could look
significantly different from what we have today; they could be smaller,
with much of the complicated logic running in separate, user-space
components.  Whether this is part of Lei's vision for ublk is unknown, and
things may never get anywhere near that point.  But ublk is clearly an
interesting experiment that could lead to big changes down the line.
Something will need to be done about that complete absence of
documentation, though, on the way toward world domination.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer-Block_drivers">Block layer/Block drivers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.0">Releases/6.0</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/903855/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor904198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2022 15:45 UTC (Mon)
                               by <b>sbates</b> (subscriber, #106518)
                              [<a href="/Articles/904198/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am both intruiged and confused by this addition to the kernel ;-). One part that is missing for me is how we assigned a physical storage device (like a NVMe namespace or a SCSI LUN) to this ublk driver? Thanks for writing this article to add some info to the (rather) disapointing documentation but more clarification on the link between ublk and physical storage devices would be welcome.<br>
<p>
Cheers<br>
<p>
Stephen<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2022 16:00 UTC (Mon)
                               by <b>NHO</b> (guest, #104320)
                              [<a href="/Articles/904200/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Currently, you don&#x27;t.<br>
<p>
You just have the loop and the null, physical devices have drivers in kernelspace<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2022 20:26 UTC (Mon)
                               by <b>sbates</b> (subscriber, #106518)
                              [<a href="/Articles/904221/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the clarification!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor904530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2022 11:01 UTC (Fri)
                               by <b>stefanha</b> (subscriber, #55072)
                              [<a href="/Articles/904530/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Userspace can use the Linux VFIO API to implement an NVMe PCI or SCSI HBA PCI driver in userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor904632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2022 15:29 UTC (Sat)
                               by <b>ming.lei</b> (subscriber, #74703)
                              [<a href="/Articles/904632/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ublk can be used to implement some &#x27;virtual&#x27; block device in userspace, such as loop,<br>
nbd, iscsi, qcow2, .....<br>
<p>
And so far it can&#x27;t move physical device driver out of kernel, but turns out io_uring<br>
passthrough command is one very efficient communication channel between user<br>
and kernel space. In future, it may be extended for other userspace drivers or<br>
components.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor906538"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2022 9:59 UTC (Wed)
                               by <b>Darkstar</b> (guest, #28767)
                              [<a href="/Articles/906538/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could use that framework to write your own user-space driver to access a physical device.<br>
<p>
Say you have some fancy EEPROM hooked up to the GPIO pins to your RaspberryPi. You could write a Python or C program that drives the GPIO pins correctly and uses ublk to make the EEPROM&#x27;s data accessible to the kernel as block device.<br>
<p>
You could use a KryoFlux or SCP device to build an io_uring-based replacement for the floppy driver, which would probably be a fun exercise :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906538/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor904207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2022 17:58 UTC (Mon)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/904207/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could this be used by SPDK project?<br>
 <a href="https://spdk.io/">https://spdk.io/</a><br>
<p>
or is it a parallel effort?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor904230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2022 22:51 UTC (Mon)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/904230/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do we have a comparison of this vs. VDUSE/TCMU?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2022 23:28 UTC (Mon)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/904232/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is VDUSE/TCMU?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 1:53 UTC (Tue)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/904237/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well these are not a &quot;combined VDUSE/TCMU&quot;, but VDUSE and TCMU.  VDUSE is VDPA devices in user-space, and TCMU is target-core module in user-space; both can be used as an interface to a user-space daemon to provide block devices or SCSI targets.  But IIRC VDUSE has implemented only virtio-blk so far, although IMO it can be extended to support virtio-scsi protocol.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor904239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 2:25 UTC (Tue)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/904239/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is that a rhetorical question?  Seems they have a lot in common then.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor904243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 3:16 UTC (Tue)
                               by <b>hsiangkao</b> (guest, #123981)
                              [<a href="/Articles/904243/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
honestly, apart from other concerns, I have the same question of this. vDPA is also easy for offloading.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor904246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 4:27 UTC (Tue)
                               by <b>old-memories</b> (guest, #160155)
                              [<a href="/Articles/904246/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
TCMU and UBLK are both userspace block drivers. TCMU provides block devices such as /dev/sdX and the backend could be file/rdb/qcow/optical_file.<br>
I have tested performance of TCMU and UBLK. And TCMU results in longer I/O lantency since it uses SCSI protocol while UBLK needn&#x27;t it. Besides, TCMU does not support multiqueue(only one command ring with a coarse-grained lock) so it behaves worse with multiple FIO jobs. UBLK does support multiqueue and there is one io_uring instance per queue so it benefits from blk-mq.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 4:39 UTC (Tue)
                               by <b>hsiangkao</b> (guest, #123981)
                              [<a href="/Articles/904248/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMO, an alternative approach of iouring ublk is over VIRTIO (IOWs) if we consider device offloading as well since VIRTIO has an mature ecosystem with even longer time. I don&#x27;t think TCMU is worth comparing as of today, but you&#x27;d better to compare it with vDPA/vDUSE from performance and ecosystem [such as device offloading, virtual machine support, etc.] perspective.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor904251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 7:36 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/904251/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can see value in this for punting most of the exotic/elderly/removable disk drivers in the kernel to userspace.<br>
<p>
(Ideally any hardware that lives beyond the boundary of an external port would never have a driver stack running as root, but that&#x27;s a way off)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904278"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 15:04 UTC (Tue)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/904278/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But I&#x27;m just about to use CXL to expose all my lanes to external connectors..!<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904278/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 21:36 UTC (Tue)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/904301/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You owe me a keyboard.  ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor904255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Missing documentation</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 9:32 UTC (Tue)
                               by <b>imphil</b> (subscriber, #62487)
                              [<a href="/Articles/904255/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn&#x27;t it be nice if maintainers would at least require basic documentation before pulling a feature? The kernel requires open source userspace drivers for GPUs to ensure the driver code can be tested, but something even more basic such as &quot;just write a couple of words how the feature works&quot; seems to be not necessary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904629"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Missing documentation</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2022 15:23 UTC (Sat)
                               by <b>ming.lei</b> (subscriber, #74703)
                              [<a href="/Articles/904629/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ublksrv README provides one simple doc on ublk, but yes, we can make one<br>
with more details, will do it in 6.0 release if no one is working on it.<br>
<p>
Another reason is that the idea &amp; implementation is pretty simple &amp; straightforward.<br>
<p>
<a href="https://github.com/ming1/ubdsrv/blob/master/README">https://github.com/ming1/ubdsrv/blob/master/README</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904629/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor904256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2022 10:01 UTC (Tue)
                               by <b>ddevault</b> (subscriber, #99589)
                              [<a href="/Articles/904256/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Last year I mused to Greg K-H that a microkernel using an io_uring-style interface would probably be able to overcome the performance differences between micro- and monolithic kernels. Nice to see that thought validated :)<br>
<p>
One thing I suspect will come out of this work is support for TLS with nbd. Right now, as I understand it, the kernel half of the nbd subsystem cannot handle encrypted connections.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2022 1:34 UTC (Wed)
                               by <b>willmo</b> (guest, #82093)
                              [<a href="/Articles/904310/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Apple’s DriverKit framework uses submission/completion queue pairs to communicate with userspace network drivers, although apparently not block drivers. Of course they have a lot more microkernel heritage already.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor904311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2022 3:36 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/904311/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Last year I mused to Greg K-H that a microkernel using an io_uring-style interface would probably be able to overcome the performance differences between micro- and monolithic kernels. </font><br>
<p>
This is what microkernel people have been shouting for years. The model seL4 settled on (IIUC) was synchronous, short, typed messages copied and routed through the kernel for standard IPC, complemented by a generic, untyped page sharing facility permitting two or more processes to setup direct message passing a la io_uring. There&#x27;s also an asynchronous signaling mechanism to assist with the latter, but ultimately you&#x27;re given a simple, synchronous IPC mechanism, along with the basic tools to build your own high-performance IPC mechanism without the microkernel getting in your way. As far as I understand, this model is more practical and much less opinionated than earlier common approaches among microkernels, and also more closely parallels where Linux is headed.<br>
<p>
What seL4 and other microkernels lack is the mindshare and incentive to actually build things atop these layers, regardless of their merit. seL4 especially demands huge, upfront time investments because of its build system. (Genode.org might alleviate much of this pain, though.)  It&#x27;s unsurprising these architectures will be replicated haphazardly on Linux, especially given the demands of multicore scaling, which heavily favor message passing architectures. But that&#x27;s the age-old tech story, a consequence of path dependency, et al. Maybe io_uring will create an ecosystem of software more readily portable to microkernels, and maybe the increasing complexity of Linux will motivate such migrations. But probably not.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2022 8:04 UTC (Wed)
                               by <b>ddevault</b> (subscriber, #99589)
                              [<a href="/Articles/904316/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I happen to be working on a microkernel of my own:<br>
<p>
<a href="https://git.sr.ht/~sircmpwn/helios">https://git.sr.ht/~sircmpwn/helios</a><br>
<p>
I definitely agree with the shortcomings of seL4, both the ones you mentioned and the ones you left out. Most serious new kernel projects these days are micro-kernels, so it&#x27;s clear that if there&#x27;s a future after Linux it will be in micro-kernels. The main issue is getting to that future. There&#x27;s a reason we&#x27;re all still using Unix systems after so long.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor904318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2022 10:08 UTC (Wed)
                               by <b>guus</b> (subscriber, #41608)
                              [<a href="/Articles/904318/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps ideal would be to have all communication between processes and the kernel go via io_urings, including system calls, ioctls, signals, and so on. However, that requires a big mindset change from userspace programmers if they want to make effective use of it. Consider calling printf() twice and then a scanf(): how should these be ordered with respect to each other? The printf()s probably should be done in the order they were enqueued, but the scanf() could start before the printf()s finish. Do we want to make everything completely synchronous by default, or completely asynchronous, have implicit dependencies between operations or require the programmer to provice explicit dependencies?<br>
<p>
I see parallels with OpenGL and Vulkan here, and I know even experienced programmers find thinking about this hard. So it&#x27;s no wonder io_uring is currently only used for some specific cases where performance is critical.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2022 0:03 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/904415/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most common use-cases can be wrapped into synchronous submit-then-wait helper functions. If you don&#x27;t care about performance, you just can use them instead of low-level messaging stuff.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor905469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2022 20:54 UTC (Sat)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/905469/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That issue was always present in stdio, correct programs would flush printf output when isatty(stdout) before input for prompts, so users could see them.<br>
If the stdin/stdout are unrelated why would synchronous behaviour be needed?<br>
It&#x27;d not be practical to change buffered i/o, but there was never any guarantee unflushed output reached a device so I am not really sure what the point really is if read(2)/write(2) were implemented differently in user space using io_uring.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/905469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor910117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2022 13:36 UTC (Mon)
                               by <b>scientes</b> (guest, #83068)
                              [<a href="/Articles/910117/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
TLS is a horrible protocol. Have you ever looked at ASN.1? And without RFC 7250 x509 is mandatory. How about using WIreGuard?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor910209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2022 19:54 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/910209/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ASN.1 is not too bad if you need to limit yourself to X.509 parsing. It&#x27;s pretty compact and you need to write it only once.<br>
<p>
But yeah, X.509 should be replaced. JWK is not too bad as the base for the replacement and it&#x27;s slowly evolving in this direction anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor904429"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2022 10:58 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/904429/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Intrigued by how this compares to the existing approaches which all use the NBD driver in the kernel.  (Disclaimer: I&#x27;m one of the authors of nbdkit).<br>
<p>
Of course we also use the NBD protocol for its intended purpose too since connecting applications with NBD either over Unix or TCP sockets is very useful for shipping huge disk images around.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904429/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2022 16:26 UTC (Sat)
                               by <b>ming.lei</b> (subscriber, #74703)
                              [<a href="/Articles/904638/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Intrigued by how this compares to the existing approaches which all use the NBD driver in the </font><br>
<font class="QuotedText">&gt; kernel. (Disclaimer: I&#x27;m one of the authors of nbdkit).</font><br>
<p>
I am working on ublk-qcow2[1], so far read only is working, my simple fio test(randread, 4k, libaio, dio, ...) shows ublk-qcow2 is ~2X IOPS of qemu-nbd.<br>
<p>
<font class="QuotedText">&gt; Of course we also use the NBD protocol for its intended purpose too since connecting</font><br>
<font class="QuotedText">&gt; applications with NBD either over Unix or TCP sockets is very useful for shipping huge</font><br>
<font class="QuotedText">&gt; disk images around.</font><br>
<p>
NBD driver can be re-implemented in userspace via ublksrv/io_uring, then better<br>
performance may be reached.  Even many cases can be implemented via ublk directly.<br>
<p>
[1] <a href="https://github.com/ming1/ubdsrv/tree/qcow2-devel">https://github.com/ming1/ubdsrv/tree/qcow2-devel</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor904509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An io_uring-based user-space block driver</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2022 2:07 UTC (Fri)
                               by <b>motiejus</b> (subscriber, #92837)
                              [<a href="/Articles/904509/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I keep gettng impressed on what John finds in the firehose of Linux commits. Sometimes even unmerged ones and without any documentation.<br>
<p>
John, if you are reading this message: how do you do it? Do you subscribe and read everything in lkml?<br>
<p>
Thank you for a great article.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How it's done</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2022 3:44 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/904514/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      I follow a few dozen kernel mailing lists, not just linux-kernel.  I certainly don't <i>read</i> everything, though.  After a while you get pretty good at figuring out what's actually worth looking at.
<p>
The key tools are gnus and nntp; it wouldn't be possible otherwise.  When projects move off of email to centralized services they become much harder to follow; fortunately for me, the kernel seems in no danger of doing that.


      
          <div class="CommentReplyButton">
            <form action="/Articles/904514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How it's done</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2022 9:53 UTC (Fri)
                               by <b>rcampos</b> (subscriber, #59737)
                              [<a href="/Articles/904529/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What do you mean with gnus?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How it's done</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2022 13:07 UTC (Fri)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/904532/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Gnus is an Emacs package that allows you to read email and NNTP (Usenet) from within Emacs.  It has a ton of very powerful features for managing especially large amounts of incoming mail/news.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor904569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How it's done</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2022 15:20 UTC (Fri)
                               by <b>rcampos</b> (subscriber, #59737)
                              [<a href="/Articles/904569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ohh, didn&#x27;t know. Thanks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/904569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
