        <!DOCTYPE html>
        <html lang="en">
        <head><title>A security fix briefly breaks DMA [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/889593/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/889854/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/889593/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A security fix briefly breaks DMA</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 1, 2022</br>
           </div>
In theory, direct memory access (DMA) operations are simple to understand;
a device transfers data directly to or from a memory buffer managed by the
CPU.  Almost all contemporary devices perform DMA, since it would not be
possible to obtain the needed performance without it.  Like so many things,
DMA turns out to be a bit more complicated in practice.  That complexity
led to an erroneous patch, intended to improve security, breaking DMA for
some devices in 5.17 and some stable kernels.
<p>
The simple model of a DMA transfer looks something like this:
<p>
<blockquote>
<img src="https://static.lwn.net/images/2022/bounce-buffer1.png" alt="[DMA model]" class="photo"
width=472>
</blockquote>
<p>
There is a buffer in memory that can be accessed — for either reading or
writing — by both the CPU and the peripheral device, and either side can
access the buffer at will.  Some systems actually
work this way but, in most others, various complications come into play.  For
example, there is almost certainly a set of caches between the CPU and the memory
buffer.  If the CPU writes data to the buffer with the intent of
transferring it to the device, that data may be resident in the cache
for some time before being flushed to main memory.  If the device is
instructed to read the data from the 
buffer, it may not see the data in cache, resulting in incorrect
(corrupted) data being written to the device.
<p>
Similarly, on many architectures, the CPU cache may be entirely unaware of
data written to the DMA buffer by the device.  If the CPU tries to read
that data, it could instead get stale data from the cache, once again
resulting in corrupted data.  Long experience in the kernel-development
community has shown that users have a certain tendency to become irate when
that happens.
<p>
<h4>Ownership, direction, and bounce buffers</h4>
<p>
The kernel's DMA-support layer has grown a set of mechanisms designed to
prevent data corruption and the unhappiness that follows from it.  In
particular, the DMA API can avoid the pitfalls that come with systems that
are not <a
href="https://en.wikipedia.org/wiki/Cache_coherence">cache-coherent</a> —
where copies of data in different locations may not be synchronized with
each other.  When
dealing with non-cache-coherent (or "streaming") mappings, driver code must
keep track of two important attributes: the ownership of the buffer and the
direction that the data is moving.  Ownership describes which side (the CPU
or the device) is able to access the buffer at any given time; while data
direction describes what the owner will be doing with the buffer.  There
are two functions (among others) that manage these attributes for a given
DMA buffer:
<p>
<pre>
    void dma_sync_single_for_device(struct device *dev, dma_addr_t addr,
				    size_t size, enum dma_data_direction dir);
    void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size,
				 enum dma_data_direction dir);
</pre>
<p>
When a DMA buffer is first mapped, the ownership belongs to the CPU.
A call to <tt>dma_sync_single_for_device()</tt> sets the ownership to the
device, while <tt>dma_sync_single_for_cpu()</tt> brings the ownership back
to the CPU.  The <tt>dir</tt> argument to both functions describes the
direction that data is moving; it is one of <tt>DMA_NONE</tt>,
<tt>DMA_TO_DEVICE</tt>, <tt>DMA_FROM_DEVICE</tt>, or
<tt>DMA_BIDIRECTIONAL</tt>.  Note that terms like "read" and "write" are
not used here, since in almost any DMA transaction one side is reading from
the buffer while the other is writing to it.
<p>
The combination of the ownership and the direction tells the DMA layer what
needs to be done at any given time.  If the CPU is passing ownership to the
device, and the direction is <tt>DMA_TO_DEVICE</tt>, then the DMA layer
must take care to flush any data from the CPU caches to the buffer so that
the device sees the correct data.  When
taking ownership back from the device, with a direction of
<tt>DMA_FROM_DEVICE</tt>, the DMA layer should instead invalidate any
cached data, since it may well be incorrect.  As long as the driver is careful
to set the ownership and direction of the 
buffer properly at all times, there should be no problems with data
corruption.
<p>
There is one other complication to cover in order to understand what went
wrong.  There are times when the device can perform DMA, but it cannot
directly access the buffer that the CPU is using.  The buffer may be in a
region of memory that the device cannot reach, it may be split into too
many discontiguous pieces, or there may be an I/O memory-management unit (IOMMU)
complicating the picture.  When this happens, a separate DMA-layer module
(called the "software I/O translation lookaside buffer" or SWIOTLB) allocates a
"bounce buffer" that is accessible to the device:
<p>
<blockquote>
<img src="https://static.lwn.net/images/2022/bounce-buffer2.png" alt="[DMA model]" class="photo"
width=472>
</blockquote>
<p>
In this situation, data must often be copied between the two buffers.  If the CPU
is sending data to the device, for example, data must be copied ("bounced")
from the CPU's buffer to the bounce buffer, and the address of the bounce
buffer handed to the device.  Data will be copied in the opposite direction
when data is being received from the device.
The good news is that the DMA API is able to
handle this case transparently as long as the ownership calls described
above are properly used.  Device drivers need not know whether a bounce
buffer is in use or not.
<p>
<h4>A problem with bounce buffers</h4>
<p>
There is a potential security problem with bounce buffers, though.  If data is
being transferred from the device to the CPU, the DMA code will, when
ownership of the DMA buffer returns to the CPU, copy the contents of the
bounce buffer back to the CPU's buffer.  If, however, the device did not
write a full buffer's worth of data, then some of the data copied out of
the bounce buffer will have originated from somewhere else.  It may come
from a previous I/O operation, or from an entirely unrelated kernel
subsystem.  The device driver is then likely to copy this data back to user
space; indeed, the buffer might be directly mapped into user space to begin
with.  The end result is that data is leaked from the kernel to user space.
<p>
It makes sense to zero the bounce buffer before setting it up, but DMA
buffers are often used many times, and it is not normal to zero them
between operations.  So even a bounce buffer that was zeroed at the
beginning may accumulate unrelated data and expose it to user space.  A
real-world example of this problem was deemed <a
href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000204">CVE-2018-1000204</a>
and <a
href="https://github.com/torvalds/linux/commit/a45b599ad808c3c982fdcdc12b0b8611c2f92824">fixed</a>
in 2018, but that fix is only partial, since it only zeroes the buffer at
allocation time.
<p>
Halil Pasic wrote a more complete fix that was <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ddbd89deb7d3">merged</a>
in February; a <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=aa6f8dcbab47">followup
fix</a> was added in early March.  It works by changing the behavior of
<tt>dma_sync_single_for_device()</tt>.  If the data direction is
<tt>DMA_TO_DEVICE</tt>, the contents of the CPU's buffer must be copied to
the bounce buffer, and the DMA API has always done that.  Pasic's patch
caused that same copy to happen for all operations, even when the direction
is <tt>DMA_FROM_DEVICE</tt>.
<p>
Normally, it would not make sense to copy data into the bounce buffer for
<tt>DMA_FROM_DEVICE</tt>; the device is just going to overwrite it anyway.
But this copy ensures that, if the device only writes part of the bounce
buffer, the remainder of the CPU's buffer will not be overwritten by random
data when the bounce buffer is copied back; instead, it will get back a
copy of the data that was already there.  In a sense, it makes the end
result reflect what the device has actually done, in that only data written
by the device will change in the CPU's buffer.
<p>
The latter fix was merged for the 5.17-rc8 development kernel — less than
two weeks before the final 5.17 release — and quickly found its way into
the 5.16.15 and 5.15.29 stable updates.
<p>
<h4>Regression</h4>
<p>
On March 23, Oleksandr Natalenko <a
href="/ml/linux-kernel/1812355.tdWV9SEqCh@natalenko.name/">reported</a>
that this change broke the ath9k wireless driver.  There followed an
extended discussion where it took a while to figure out what was really
going on.  Robin Murphy was initially <a
href="/ml/linux-kernel/27b5a287-7a33-9a8b-ad6d-04746735fb0c@arm.com/">incredulous</a>:
<p>
<blockquote class="bq">
	I'm extremely puzzled how any driver could somehow be dependent on
	non-device-written data getting replaced with random crap, given
	that it wouldn't happen with a real IOMMU, or if SWIOTLB just
	didn't need to bounce, and the data would hardly be deterministic
	either.
</blockquote>
<p>
The source of the problem was eventually narrowed down to some code in <a
href="https://elixir.bootlin.com/linux/v5.17.1/source/drivers/net/wireless/ath/ath9k/recv.c#L627"><tt>ath_edma_get_buffers()</tt></a>.
This code executes a sequence that looks like this:
<p>
<pre>
    dma_sync_single_for_cpu(..., DMA_FROM_DEVICE);
    if (! a_packet_is_ready()) {
        dma_sync_single_for_device(..., DMA_FROM_DEVICE);
	return false;
    }
</pre>
<p>
The code is taking ownership of the buffer, checking to see if the device
has put a packet there, then returning ownership to the device if there is
no packet available.  The key point here is that, while this is happening,
the device is still writing to the buffer; that packet could be arriving
while the driver is checking for it.  This procedure worked just fine until the
change went in; with the new behavior, the
<tt>dma_sync_single_for_device()</tt> call copies the CPU buffer into the
bounce buffer, potentially overwriting data that was just placed there by the device.
This happens often enough, it seems, to reliably break the device.
<p>
Developers like Christoph Hellwig initially <a
href="/ml/linux-kernel/20220325163204.GB16426@lst.de/">saw the ath9k
behavior as a bug</a>, and felt that the problem should be fixed there.
Murphy <a
href="/ml/linux-kernel/e077b229-c92b-c9a6-3581-61329c4b4a4b@arm.com/">described</a>
this behavior as "<q>a violation of the DMA API</q>".  The problem
was that the device was allowed to keep writing to the DMA buffer even
though the ownership had shifted to the CPU.  It seemed, for a moment, that
the ath9k driver could be fixed and the bounce-buffering change could
remain.
<p>
Linus Torvalds <a
href="/ml/linux-kernel/CAHk-=wippum+MksdY7ixMfa3i1sZ+nxYPWLLpVMNyXCgmiHbBQ@mail.gmail.com/">disagreed
strongly</a>, though, for a few different reasons.  He noted that ath9k
might not be the only driver that shows this kind of problem; it just
showed up first there because those adapters are widely used.  If other
drivers do similar things, users and developers could end up chasing bugs
for a long time.  Some of those bugs might well make it into production
kernel releases before being noticed.
<p>
More to the point, though, he stated that the ath9k
driver's behavior was correct, and the bounce-buffer change was not.
Specifically, he pointed out that the <tt>dma_sync_single_to_device()</tt>
call specified <tt>DMA_FROM_DEVICE</tt>.  In that situation, he claimed,
the bounce-buffer implementation should do nothing at all; the data is
coming from the device, so the CPU has no business copying data into the
bounce buffer.  So the only right thing to do is to revert the patch.
<p>
In the end, reverting the commit is exactly what happened, though it was
later <a href="https://git.kernel.org/linus/901c7280ca0d">partly
reinstated</a> to preserve the parts of the patch that were not
problematic.  So the ath9k driver works again, and potential bugs in an
unknown number of other drivers have been avoided.  The problem of leaking
random data out of the bounce buffer remains unsolved; a different
approach will need to be found to resolve that one.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Direct_memory_access">Direct memory access</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#swiotlb">swiotlb</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/889593/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor889995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 14:46 UTC (Fri)
                               by <b>post-factum</b> (subscriber, #53836)
                              [<a href="/Articles/889995/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I sincerely hoped LWN would make a nice summary of that LKML thread, and here we are :). Thank you a lot!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/889995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor889997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 15:15 UTC (Fri)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/889997/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Couple of notes, having participated in the thread:
<ul>
<li>According to the documentation, the call(s) shouldn't even specify DMA_FROM_DEVICE, it/they should specify DMA_BIDIRECTIONAL as the buffer is documented that way. That would probably break ath9k too, haven't checked the exact code though.
<li>According to Linus's thinking on it, however, the DMA_FROM_DEVICE actually makes sense ...
<li>The ownership model doesn't work as documented, at least not for devices such as ath9k, since here the device is writing while the driver is reading (which you touch upon), but that implies sort of "dual ownership" or weaking the ownership to "write ownership" perhaps?
<li>There was a whole sub-discussion about cache invalidate etc., e.g. with a reference to the ARC (I think?) documentation, which was also quite worthwhile IMHO.
</ul>

In any case, for me one of the take-aways from the thread was that the documented DMA model is actually not applicable in practice (i.e. it's wrong), which might've been worth going into even if nobody has stepped up yet to try to fix it.








      
          <div class="CommentReplyButton">
            <form action="/Articles/889997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 18:32 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/890013/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the additional insight.<br>
<p>
But could you please elaborate, why DMA_BIDIRECTIONAL should be used? I don&#x27;t quite get why.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2022 12:49 UTC (Sat)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/890054/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Oh, it probably *shouldn't* be used in this case, practically speaking.

But (and credit goes to Halil for quoting this to me in https://lore.kernel.org/r/20220327051502.63fde20a.pasic@linux.ibm.com) the <a href="https://www.kernel.org/doc/html/latest/core-api/dma-api.html">documentation</a> states:
<pre>
        void
        dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,
                                size_t size,
                                enum dma_data_direction direction)

        void
        dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle,
                                   size_t size,
                                   enum dma_data_direction direction)

        void
        dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
                            int nents,
                            enum dma_data_direction direction)

        void
        dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
                               int nents,
                               enum dma_data_direction direction)

Synchronise a single contiguous or scatter/gather mapping for the CPU
and device. With the sync_sg API, all the parameters must be the same
as those passed into the single mapping API. With the sync_single API,
you can use dma_handle and size parameters that aren't identical to
those passed into the single mapping API to do a partial sync.
</pre>

Which, at least in our reading, seems to imply that for SG all must be the same, for single all but handle/size must be the same.

Practically, that doesn't seem to be desired, and it's not even entirely clear what these should mean for DMA_BIDIRECTIONAL.



      
          <div class="CommentReplyButton">
            <form action="/Articles/890054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor890004"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 16:56 UTC (Fri)
                               by <b>larkey</b> (guest, #104463)
                              [<a href="/Articles/890004/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s a small typo in the index link of the article: &quot;DIrect memory access&quot; (note the capital &quot;I&quot;).<br>
<p>
Really great writeup!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890004/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typo reports</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 16:59 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/890005/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Fixed.  For future reference, please send typo reports to lwn@lwn.net so as to not clutter the comment stream.


      
          <div class="CommentReplyButton">
            <form action="/Articles/890005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor890009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 17:43 UTC (Fri)
                               by <b>mario-campos</b> (subscriber, #152845)
                              [<a href="/Articles/890009/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That actually made a lot of sense! THIS is why I read LWN :)<br>
<p>
On the matter at hand, though... Why not just create an additional `size_t` parameter in the DMA API and only bounce/copy the necessary data (instead of the full buffer)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2022 18:30 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/890011/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In most cases it&#x27;s probably unknown how much the device actually wrote, unless the driver actually looks at the data written.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2022 3:20 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/890042/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This sounds a lot like terrible hardware design.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2022 8:17 UTC (Mon)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/890144/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That doesn&#x27;t really matter, if you are the kernel and essentially want a design that works with all hardware you have to expect some terribly designed hardware too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor890632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2022 15:16 UTC (Thu)
                               by <b>kpfleming</b> (subscriber, #23250)
                              [<a href="/Articles/890632/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not sure that&#x27;s fair.<br>
<p>
You tell a NIC it can receive a packet directly into a buffer. It does so. You don&#x27;t know how large the packet was until you look into the buffer to find out.<br>
<p>
The NIC could conceivably communicate the &#x27;bytes written&#x27; amount in some other location outside the buffer, but that significantly complicates the data handling.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor890045"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2022 6:24 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/890045/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would tend to expect that the vast majority of hardware falls into one of two cases:<br>
<p>
* It&#x27;s something like a NIC, and the data is eventually going to end up in some sort of userspace buffer (e.g. via read() or recv()). This implies that some part of the kernel is going to have to figure out the size at some point, because you can&#x27;t leak extraneous data to userspace, so you might as well do it in the driver.<br>
* It&#x27;s something like a keyboard or capture card, and the data has a fixed or configurable size and/or format, which the driver should already know because it presumably configured the size/format in the first place.<br>
<p>
Is there really a lot of variable-sized input hardware where the input *doesn&#x27;t* eventually end up in userspace?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890045/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor890059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2022 16:46 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/890059/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Because it wouldn't solve anything: DMA mechanism itself has no way to check how many bytes were actually written, only the driver can know that.</p>

<p>And using value passed along from the driver to make information unavailable to said driver… what would that achieve? The driver already can ignore the part that it doesn't need.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/890059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor890062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2022 19:55 UTC (Sat)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/890062/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t see how the bounce buffer copy and the ongoing DMA avoid interacting in such a way that a_packet_is_ready() can return true when not all of the packet was in the bounce buffer in time to get copied out. It seems like you&#x27;d need a sync operation that let you specify the order that the bounce buffer is read in a way that wouldn&#x27;t be optimal for a sync operation that was only reliable if the device was no longer writing when you called it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2022 8:36 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/890077/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>In the bounce buffer case, it can't. But on a lot of systems, especially those in WiFi APs, the DMA is happening into the CPU buffer directly (no bounce buffer), and there it's an optimization to say "hey, packet copied in, resync and continue".


      
          <div class="CommentReplyButton">
            <form action="/Articles/890077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor890080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2022 8:54 UTC (Sun)
                               by <b>dvrabel</b> (subscriber, #9500)
                              [<a href="/Articles/890080/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The device writes the status word (with its RxDone bit) _after_ writing the packet and other metadata. Thus, if the CPU sees RxDone it knows all the other data has been written.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2022 17:40 UTC (Sun)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/890102/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s what I thought, but how does the CPU know that none of the sync happened before the status word was written, with the copy of the status word happening after it was written? You&#x27;d need to make sure that the first thing that gets copied during the sync is the status word, and I&#x27;m not finding any documentation that the sync happens in any particular order.<br>
<p>
I expect that the copy actually happens from low to high, and the status word is at the beginning, so it always works, but relies on a property of the core API that was never promised.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor890082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2022 9:38 UTC (Sun)
                               by <b>Flow</b> (subscriber, #82408)
                              [<a href="/Articles/890082/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great summary, as always. However<br>
<p>
<font class="QuotedText">&gt; It makes sense to zero the bounce buffer before setting it up, but DMA buffers are often used many times, and it is not normal to zero them between operations. So even a bounce buffer that was zeroed at the beginning may accumulate unrelated data and expose it to user space.</font><br>
<p>
I would be thankful if someone could elaborate on the process that is causing unrelated data to accumulate. This is not immediately obvious to me. I suspect that is potentially the device or its driver that is re-using the buffer for further purposes?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890202"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2022 14:51 UTC (Mon)
                               by <b>imMute</b> (guest, #96323)
                              [<a href="/Articles/890202/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;I suspect that is potentially the device or its driver that is re-using the buffer for further purposes?</font><br>
<p>
This.  It&#x27;s fairly common for drivers to setup a ring of buffers that get reused.  As for how the data can be &quot;unrelated&quot; imagine a NIC driver pulling packets off the device - each packet may very well be destined for entirely different processes, but they all use the same set of buffers over and over again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890202/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor890204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A security fix briefly breaks DMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2022 15:33 UTC (Mon)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/890204/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well in this case we&#x27;re talking about swiotlb, so imagine driver 1 maps a buffer A and gets buffer A&#x27; in swiotlb, fills some data into it (perhaps it&#x27;s a crypto driver and there&#x27;s some key data). Then it unmaps because it&#x27;s no longer in use. Some time later driver 2 maps a buffer B and also gets A&#x27; in the swiotlb shadow data, so now all of the stale data from driver 1 is exposed to driver 2&#x27;s device for DMA.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
