        <!DOCTYPE html>
        <html lang="en">
        <head><title>Bounded loops in BPF programs [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/773605/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/773311/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/773605/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Bounded loops in BPF programs</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 3, 2018</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2018-Linux_Plumbers_Conference">Linux
Plumbers Conference</a>
</div>
The BPF verifier is charged with ensuring that any given BPF program is
safe for the kernel to load and run.  Programs that fail to terminate are
clearly unsafe, as they present an opportunity for denial-of-service
attacks.  In current kernels, the verifier uses a heavy-handed technique to
block such 
programs: it disallows any program containing loops. This works, but at the
cost of disallowing a wide range of useful programs; if the verifier could
determine whether any given loop would terminate within a bounded time,
this restriction could be lifted.  John Fastabend presented a plan for
doing so during the <a href="http://vger.kernel.org/lpc-bpf.html">BPF
microconference</a> at the 2018 <a 
href="https://linuxplumbersconf.org">Linux Plumbers 
Conference</a>.
<p>
Fastabend started by noting that the lack of loops hurts; BPF developers
are doing "crazy things" to work around their absence.  He is working to
enable the use of 
simple loops that can be modeled by the verifier.  There is academic work
on ways to verify more complex loops, but that is a problem for later.  For
now, the objective is to detect simple loops and verify that they will
terminate; naturally, it's important that the verifier, too, is able to
terminate in a reasonable amount of time.
<p>
The key to determining the behavior of a loop is to find the induction
variable that controls it.  For a simple loop like:
<p>
<pre>
    for (i = 0; i &lt; MAX; i++)
	/* loop body */
</pre>
<p>
the induction variable is <tt>i</tt>.  If the variable can be shown to be
both monotonically increasing and bounded in value, then the verifier can
conclude that the loop will terminate.  Once the induction variable and its
bounds have been identified, the verifier can also check that any memory
references using that variable remain in range.
<p>
This kind of verification could be done relatively easily with knowledge of
where the loops are.  But BPF is an unstructured virtual machine language
that doesn't contain information about loops, so the verifier has to figure

<a href="/Articles/773612/"><img
src="https://static.lwn.net/images/conf/2018/lpc/JohnFastabend-sm.jpg" alt="[John Fastabend]"
title="John Fastabend" class="rthumb"></a>


out where they are itself.  This is done by creating a <a
href="https://en.wikipedia.org/wiki/Dominator_(graph_theory)">dominator
tree</a> that describes the program to be examined; it will identify tests
that control the execution of specific blocks of code.  From there, it is
possible to identify loops (by looking for reverse jumps to the dominator
node) and the blocks of code that belong to each loop.
<p>
Doing so is not entirely easy.  The use of a dominator tree requires that
there be a single entry point into every loop; code that jumps into the
middle of a loop cannot be verified.  Identifying the looped-over code is
also an expensive (O(n<sup>2</sup>)) algorithm.
<p>
Fastabend outlined a few approaches to this problem, describing the first
as the "by the book" method.  This algorithm builds the dominator tree,
then works to detect (and abort on) loops that cannot be reduced to a
verifiable case.  For each loop, it finds the induction variable, and
verifies that variable's bounds; the execution of the loop is then
simulated with the induction variable's largest and smallest values.  The
problem here is that the induction variable must be found with pattern
matching, and the LLVM optimizer creates a wide variety of patterns that
change with every release.  That makes the code fragile.
<p>
The next approach is to get the compiler to help by limiting the number of
loop types  that it generates.  That makes the pattern-matching task
easier, since the patterns that identify loops will be reduced in number
and less prone to change.  The verifier still has to do all of the work,
but it becomes quite a bit more robust.
<p>
But the best solution, he said, would be to create a new set of BPF
instructions specifically to implement loops.  They would mark the
beginning and end of each loop, and include the test of the induction
variable; the verifier would replace those instructions with actual tests
and jumps.  With these markers to denote the loop blocks, there would be no
need for the dominator tree, since the markers themselves would make it
clear which code is controlled by the loop.  That would keep the verifier
code minimal which, he said, is the right tradeoff in the end.
<p>
The description of the session said that the goal "<q>to come to a
consensus on how to proceed to make progress on supporting bounded
loops</q>".  That did not happen, but there was some discussion about the
options and the development community is more aware of how this complex
work is proceeding.  In the end, real consensus is likely to come about in
the usual way: through the posting of code that shows how the idea is
implemented in the real world.
<p>
The <a
href="http://vger.kernel.org/lpc_bpf2018_talks/bounded-loops.pdf">slides
from this talk [PDF]</a> and <a href="https://www.youtube.com/watch?v=PR4hpxWzPfo&t=4215
">a video recording [YouTube]</a>
are available.  Curious readers can also see <a
href="/ml/netdev/20180601092646.15353.28269.stgit@john-Precision-Tower-5810/">the
implementation of the first alternative</a> as it was posted in June.
<p>
[Thanks to the Linux Foundation, LWN's travel sponsor, for supporting my
travel to the event.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF-Loops">BPF/Loops</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2018">Linux Plumbers Conference/2018</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/773605/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor773697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2018 23:16 UTC (Mon)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/773697/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But BPF is an unstructured virtual machine language that doesn't contain information about loops, so the verifier has to figure out where they are itself.</font><br>
<p>
This is why WebAssembly is explicit about control flow nesting and doesn't allow arbitrary jumps. Wouldn't be surprised at all if eventually BPF gets replaced with some fancy formally-verified minimal WebAssembly JIT from Google or something.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2018 23:52 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/773707/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the key steps in compiling arbitrary C code to asm.js/Webassembly is/was the Relooper algorithm to turn unstructured control flow back into structured control flow. That's probably relevant here: <a href="http://mozakai.blogspot.com/2012/05/reloop-all-blocks.html">http://mozakai.blogspot.com/2012/05/reloop-all-blocks.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773712"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 0:48 UTC (Tue)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/773712/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The nice thing is that with WebAssembly this work is performed by the compiler, so for the BPF use case that would mean userland instead of in the kernel.<br>
<p>
Either way there is still the problem of doing something with those loops to make sure they complete within a certain number of iterations though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773712/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 8:18 UTC (Wed)
                               by <b>edeloget</b> (subscriber, #88392)
                              [<a href="/Articles/773909/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The nice thing is that with WebAssembly this work is performed by the compiler, so for the BPF use case that would mean userland instead of in the kernel.</font><br>
<p>
That, in turn, means that if I handcraft the code I send to the kernel, it will then have no way to perform the needed verifications :) Does not sound that great :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2018 1:05 UTC (Sun)
                               by <b>nteon</b> (subscriber, #53899)
                              [<a href="/Articles/774371/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you misunderstand things -- you cannot encode unstructured control flow in WebAssembly, it doesn't have the primitives (which is why the compiler has to turn unstructured control flow into structured).  If you handcraft WebAssembly, by definition it would be using structured control flow and would be in a format that allows easy verification.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor774010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 23:30 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/774010/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>The Relooper algorithm isn't much better, if at all. Per the original paper, Emscripten: an LLVM-to-JavaScript compiler:

<blockquote>
In general though, this is not always easy or even practical â€“
there may not be a straightforward high-level loop structure
corresponding to the low-level one, if for example the original
C code relied heavily on goto instructions. In practice,
however, almost all real-world C and C++ code tends to be
amenable to loop recreation.
</blockquote>

<p>Of course "almost all" code is amenable because very little code comprises the more critical, performant inner loops and state machines--the parts which often heavily rely on goto.

<p>Arguably if JavaScript had goto there likely never would have been a need to create and rely on the Relooper, and WebAssembly may have turned out differently. Lua 5.2 added a goto construct precisely because it made code generation so much easier. I suspect that eventually much BPF code will be generated from high-level DSLs. Not everybody will be using the same toolchains and libraries, and not having a goto construct is a serious headache when machine generating code. Generating performant assembly from a task-specific, declarative DSL is often trivial; much less so if you now need to implement a relooper or integrate a relooper library.

<p>WebAssembly was originally envisioned as a simple, pure stack-based VM where variable scoping and structured blocks naturally aligned with the overall design. A goto construct was unfathomable. But then WebAssembly got much more complex and the simple stack-based design fell away. I suspect adding a goto construct could have been possible after the original, simpler concept gave way, and I wouldn't rule out its addition in the future. Gotos (including computed gotos) are still very useful in performant C code because optimizing compilers still can't do the job--in real-world code the best switch-statement optimizations still can't come close to idiomatic use of gotos and computed gotos. Like with JIT compiling, microbenchmarks and theoretical optimizations never quite make the transition to the real-world undiminished. Performance demands may still necessitate goto.

      
          <div class="CommentReplyButton">
            <form action="/Articles/774010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 0:30 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/774014/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; WebAssembly was originally envisioned as a simple, pure stack-based VM where variable scoping and structured blocks naturally aligned with the overall design.</font><br>
<p>
What I had in mind here was the transition from the AST-based bytecode format to the structured stack machine format. The transition shifted WASM in the direction of a model where you could contemplate adding gotos. The transition happened because implementations were *already* using modern compiler techniques, like SSA transforms. Adding a goto construct with a sophisticated verifier is much less of a leap than when your machine model is based directly on ASTs.<br>
<p>
For more context see <a href="https://github.com/WebAssembly/design/issues/755">https://github.com/WebAssembly/design/issues/755</a> and <a href="https://docs.google.com/document/d/1CieRxPy3Fp62LQdtWfhymikb_veZI7S9MnuCZw7biII/edit">https://docs.google.com/document/d/1CieRxPy3Fp62LQdtWfhym...</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor788171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2019 11:16 UTC (Sun)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/788171/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of design goals of WebAssembly was fast verification to minimize loading time. Explicit goto significantly increase complexity of the verifier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/788171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor773770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 12:20 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/773770/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That would mean redoing all the JITters and everything, and breaking userspace and everything else that's grown up aroud the BPF world unless you also implement a BPF-&gt;kWASM translator. Honestly, compared to adding a few instructions (that the verifier replaces, so they don't even need JIT or interpreter support) this seems like a ridiculously heavy hammer.<br>
<p>
(And why would Google have a WASM JITter suitable for running in *kernelspace* anyway?)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 12:31 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/773773/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a pathological pattern that might be at work here.<br>
<p>
1) We have a framework X.<br>
2) X is missing a small feature. Framework Y has that feature, and is overall great, but it's more complex than we need right now, and besides the cost of migrating from X to Y for just this one feature can't be justified.<br>
3) Add feature to X.<br>
4) Goto 1.<br>
<p>
Duplicating effort along the path of least resistance, one feature at a time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773791"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;duplicating effort along the path of least resistance&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 14:30 UTC (Tue)
                               by <b>Herve5</b> (subscriber, #115399)
                              [<a href="/Articles/773791/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, this was a perfect comment, that I can see applying in a dozen industrial areas other than software, just around myself... I'll retain your wording :-D<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773791/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor773844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 20:02 UTC (Tue)
                               by <b>simcop2387</b> (subscriber, #101710)
                              [<a href="/Articles/773844/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This raises the question, and it's a big one.  Does framework Y have things we don't want in framework X?  If that answer is yes then that's a reason we can't use it directly.  And at least with WebAssembly and BPF that answer is probably yes, there's a lot of foreign call support in webassembly that'd have to be removed and then other bits that would have to be reimplemented from BPF to make it work for the use cases where BPF is used in the kernel.  I think in the end you'd end up with an incompatible with either hybrid framework Z that's a mishmash of X and Y, and I'm not sure that's better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor773705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2018 23:50 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/773705/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seems to me that beyond just termination, you actually need to bound the number of iterations or the total execution time somehow. A loop that executes a billion iterations is probably unsuitable in many BPF usage contexts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773727"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 8:32 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/773727/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Seems to me that beyond just termination, you actually need to bound the number of iterations or the total execution time somehow. A loop that executes a billion iterations is probably unsuitable in many BPF usage contexts.</font><br>
<p>
In my naivety, I wonder whether it would be possible simply to bound BPF programme execution time, and make it the user's responsibility to provide something which can finish within the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773727/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 8:39 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/773730/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be possible. The BPF compiler will need to add the timeout checks before each backwards jump but somehow I doubt the kernel developers want this.<br>
<p>
BPF is moving with a rapid speed towards a completely generic in-kernel virtual machine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 8:45 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/773732/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It would be possible. The BPF compiler will need to add the timeout checks before each backwards jump but somehow I doubt the kernel developers want this.</font><br>
<p>
I was more thinking of something in the execution engine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773740"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 9:27 UTC (Tue)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/773740/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no execution engine in modern eBPF; it's statically compiled to machine code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773740/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor773742"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 9:33 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/773742/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BPF is JITted these days so there is no boundary between the compiler and execution engine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773742/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 10:33 UTC (Tue)
                               by <b>sdalley</b> (subscriber, #18550)
                              [<a href="/Articles/773762/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So, there's no identifiable thread or task doing the BPF that could be watchdogged ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 10:48 UTC (Tue)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/773763/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      There is no separate thread, no.  One could always set a timer to bring an end to runaway execution, but that would be an expensive thing to do.
      
          <div class="CommentReplyButton">
            <form action="/Articles/773763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 18:43 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/773834/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can keep track of "remaining instructions" in a register that is decremented on every backwards jump by the number of instructions in the jump. Then just compare it with zero.<br>
<p>
The comparison will be branch-predicted most of the time and will be fast.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor773775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 12:34 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/773775/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One problem with timers is that they make things nondeterministic. BPF programs may start failing under heavy load for example.<br>
<p>
It might be significantly better to bound the number of BPF instructions executed by some (configurable?) constant. Then running the same program on the same input data should always either succeed or fail, which would make  debugging easier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 13:00 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/773776/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It might be significantly better to bound the number of BPF instructions executed by some (configurable?) constant.</font><br>
<p>
Right.  I used the word "time", but I was also more thinking of instruction count or similar.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor773713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 1:19 UTC (Tue)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/773713/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not mentioning the halting problem in this article was quite a feat. I am amused by the "academic work" reference.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 5:04 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/773716/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed!<br>
<p>
It's not mentioned in the (three) slides either, just: "Lots of academic work on complex loops... fun but lets stick to basic ax+c for now."<br>
<p>
<font class="QuotedText">&gt; &gt; In the end, real consensus is likely to come about in the usual way: through the posting of code that shows how the idea is implemented in the real world.</font><br>
<p>
Scarier and scarier :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor773717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 7:20 UTC (Tue)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/773717/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      Nobody is trying to solve the halting problem in any kind of general sense, so it's not really relevant here.  After all, current BPF can guarantee that all programs it accepts will halt, no problem...
      
          <div class="CommentReplyButton">
            <form action="/Articles/773717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 8:26 UTC (Tue)
                               by <b>vbabka</b> (subscriber, #91706)
                              [<a href="/Articles/773724/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly. Halting problem means that there will always exist programs where you can't prove that they will halt. That might also include programs that would actually halt (but you are not able to prove it). But when you can prove halting for some class of programs (e.g. because they are sufficiently constrained), then (modulo bugs in the prover itself :) you do have the guarantee, regardless of the general halting problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 8:52 UTC (Tue)
                               by <b>amacater</b> (subscriber, #790)
                              [<a href="/Articles/773733/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Once, enigmatically<br>
Alan Mathison Turing<br>
Said to his colleagues<br>
"It's now us or them.<br>
Now, if you will<br>
Help me hedge<br>
Programatically<br>
Goedel's insoluble<br>
Entscheidungsproblem"<br>
<p>
[If Turing machines are obsolete, when do you stop production? ]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor773761"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 10:32 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/773761/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Halting problem means that there will always exist programs where you can't prove that they will halt.</font><br>
<p>
And by "programs", it specifically means programs in a system equivalent to a Turing machine, which has infinite memory and infinite time. That means it doesn't apply to any practical computer - they will have limited memory, so it's trivial to prove whether a program will halt by just enumerating all possible states. (Of course that's also a practically useless thing to prove - the BPF verifier wouldn't want to accept a program that definitely halts but might take a million years to do so.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773761/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 12:35 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/773772/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Only a million years? We have an upper bound for all-possible-states enumeration, the busy beaver problem. I'm fairly sure a six-symbol program would exceed any likely bound for a mere million-year verification, and that's *way* below the likely size of BPF programs. (Hell, the max size of BPF programs has *always* been above the limit at which Aaronson et al hav shown that finding the busy beaver becomes noncomputable, though most BPF programs are probably much smaller than that.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 14:27 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/773790/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the busy beaver problem assumes infinite tape (i.e. memory). When you have finite memory, you can consider the contents of memory (including registers etc) to be the machine's state, and then it's just a finite state machine. If it has N bits of memory, then after 2^N cycles it must have either halted or found a cycle from one state back to itself (in which case it will never halt). From a theoretician's perspective, that solves the halting problem for this machine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 16:31 UTC (Tue)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/773828/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Well, you know that N is so large that 2^N might as well be infinite for all practical purposes.  Also, you assume that the computation is deterministic.  In real-world situations where external events can change the state (a network packet arriving, for example), a program might terminate even if it repeats a state it has been in before.

<p>Actually, it's trivial to prove that all programs on computers on earth <em>will</em> eventually halt, becuase the Sun will eventually expand and destroy the earth, thereby halting the program.  That's the ultimate example of an external event affecting the state.

      
          <div class="CommentReplyButton">
            <form action="/Articles/773828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 17:40 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/773831/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, sure - I think what I'm trying to get at is that there are two completely separate realms, one of theoretical computer science (which is really just computer-themed mathematics) where the halting problem and busy beavers and Turing machines are relevant, and most finite things are trivial; and one of practical reality where the difference between "1 msec" and "after the heat death of the universe" is an important distinction. Applying theoretical tools to practical problems doesn't give useful results, and that's why the halting problem isn't relevant to BPF.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773842"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 19:35 UTC (Tue)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/773842/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I wouldn't say the halting problem isn't relevant at all to BPF, but it's not the only problem with trying to make it work practically.

<p>But yeah, mostly it's just fun to point out weird edge cases that distinguish theory from practice. :)

      
          <div class="CommentReplyButton">
            <form action="/Articles/773842/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor773882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 23:53 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/773882/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, except that this stuff is also tied up with complexity theory, and that *is* extremely relevant (a lot of algorithms exist that would be really nice to use in compilers except that their time or space complexity is in very much the wrong class, should we say... so one uses approximations, or a less optimal algorithm, and wishes we lived in a perfect world.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor773929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 10:46 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/773929/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's also not relevant because the halting problem says that you can't sort <em>all</em> programs into "does not halt" and "does halt". If you accept a third bucket - "may or may not halt", then the problem falls away; you can sort all programs into those three buckets in theory, and then it's just a practical problem.
<p>This is not a new insight - it's basically a conservative approximation to the halting problem (where you treat "may or may not halt" as "does not halt", and accept that you are rejecting some programs that do halt), and is a common process in compilers.
      
          <div class="CommentReplyButton">
            <form action="/Articles/773929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor773944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 14:16 UTC (Wed)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/773944/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Million years? You can do it in constant time! Just precompute all possible states of the machine and stash all that terminate to a hash set. As added bonus the computation can be used to replace bogomips loop.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor773771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 12:25 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/773771/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah. The problem here is not the halting problem: the problem here is always finding an approximation that lets useful stuff past but isn't too complex to be worth it. The high time- or sometimes space-complexity of many algorithms needed by compilers is a routine cause of foul curses in developers of normal ahead-of-time compilers that don't run in kernel space: the approximations needed by something that runs in the kernel seem likely to be even harder.<br>
<p>
(Really, it's a shame the verifier and JITters have to run in kernel space: this sort of work seems like the sort of thing far better done by an upcall to something in userspace, unprivileged but only installable by root -- only that would stop BPF from being used to protect the system *from* root, and it wouldn't help with the time problem at all since the kernel would still have to block the process installing the BPF to wait for verification/JITing anyway...)<br>
<p>
It just makes me icky seeing that people are basically writing compilers that run in kernelspace. Surely there must be a better way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 14:05 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/773785/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe the kernel should use KVM to launch a minimal Linux distro, and use that as the userspace to run the compiler/JIT/verifier in, so it's unprivileged and not constrained by kernel programming requirements. The distro and applications can be encoded as a blob in a signed kernel module as part of the secure boot chain, so the VM is as secure as the kernel itself and can be protected against the root user.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor773800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 16:18 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/773800/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>This actually sounds like a potential application for <a href="https://en.wikipedia.org/wiki/Proof-carrying_code">proof-carrying code</a>. The user-space verifier could attach a simple-to-verify proof to the program it's about to attach (even if it's an arbitrary program with loops and other such weirdnesses) that the kernel can check.
      
          <div class="CommentReplyButton">
            <form action="/Articles/773800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 23:49 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/773880/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It really does. Heck the original Necula and Lee paper might as well have had 'BPF' written all over it in letters of fire ten miles high :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773927"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 10:16 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/773927/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>It would be rather surprising if a researcher at Berkeley working on Packet Filters was completely unaware of BPF :-)
      
          <div class="CommentReplyButton">
            <form action="/Articles/773927/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774598"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2018 17:45 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/774598/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh yeah, that's true. I had forgotten their affiliation. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774598/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor774331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Halting problem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2018 7:02 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/774331/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The problem here is not the halting problem:</font><br>
<p>
Did anyone say it was?<br>
<p>
<font class="QuotedText">&gt; the problem here is always finding an approximation...</font><br>
<p>
The "feat" was just to never mention once the name of what this approximates.<br>
<p>
The misunderstanding and overreaction is even more interesting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor773725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 8:28 UTC (Tue)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/773725/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Itanium processor has dedicated instructions for loops as well: <a href="https://blogs.msdn.microsoft.com/oldnewthing/20150806-00/?p=91161">https://blogs.msdn.microsoft.com/oldnewthing/20150806-00/...</a>. I wonder if there is some code from the Itanium backend in LLVM that could be repurposed if the approach of dedicated looping instructions were taken.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 9:37 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/773743/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So does x86 (LOOP)! That's not really helpful here though because those instructions don't guarantee nothing jumps into the middle of the loop.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 19:55 UTC (Wed)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/773987/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the compiler would generate loop instructions for loops, there would be no need to reconstruct loops from jump instructions. There is no problem with jumps in the middle of the loop. The verifier can easily detect those and forbid them. The hard part is not not forbidding illegal jumps the hard part is to detect legal jumps and proof that they do no harm. This part would be much easier if loops would be explicitly marked instead of created by general purpose jump instructions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor773767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 11:50 UTC (Tue)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/773767/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One can always replace a bounded loop by repeating the code up to max allowed number of iterations. So I suppose BPF can be extended with simple bytecodes for a loop that repeats the code, say, 100, times. If one wants to stop it earlier, one just use jumps. But proving that it cannot be subverted can be tricky.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 14:19 UTC (Tue)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/773789/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>A few nested loops and once again you can execute billions of iterations...
      
          <div class="CommentReplyButton">
            <form action="/Articles/773789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2018 22:46 UTC (Tue)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/773867/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no need to support nested loops. Any such loop can be re-written as single loop.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 2:24 UTC (Wed)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/773898/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That would work if BPF programs couldn't call subroutines, or if the verifier chased subroutines down to make sure anything called within a loop didn't contain its own loop.  Sounds pretty tricky and tedious. I don't envy those doing this work.
      
          <div class="CommentReplyButton">
            <form action="/Articles/773898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor773946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 14:25 UTC (Wed)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/773946/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This seems to be the actual issue. For practical purposes, BPF program which terminates after an hour is just as unsafe as one which never terminates. Perhaps instead of trying to prove things about the program, itâ€™d be better to simply limit how many instructions a program can execute and terminate it if it takes too long.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 20:10 UTC (Wed)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/773990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This might be a valid catch all solution for situations where the proof aproach does not work. However, the verifier approach has many advantages. If the code can be proven to never execute more than the allowed number of instructions, there is no need to count instructions and place conditional jumps all over the code that will abort once the counter reaches zero. Apart from the performance boost, this also gives certainty that the code is never aborted due to taking too much time. If I rely on BPF programs that do not fail, I would anyway need a tool that can proof that the code does not use too many instructions. Then why not integrating this into the verifier? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor773931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 10:51 UTC (Wed)
                               by <b>pctammela</b> (guest, #126687)
                              [<a href="/Articles/773931/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As time goes, the BPF project is getting closer to the Lua kernel port. A port that exists since 2008.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor773932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2018 10:52 UTC (Wed)
                               by <b>pctammela</b> (guest, #126687)
                              [<a href="/Articles/773932/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also incorporated in some BSDs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/773932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor774015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 0:53 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/774015/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interestingly, in the transition from Lua 5.1 to Lua 5.2 the authors *removed* bytecode verification. This decision was made after several holes in the verifier were discovered. Because the VM relied on the verifier these holes were easily exploitable. The decision was made that time and attention would be better spent focusing on the VM and the compiler, but particularly on writing a VM that was intrinsically safe. The interplay between the VM, the verifier, and the compiler added unnecessary complexity and opacity. (IME such a decision is not simply a matter of moving invariant checks; without a verification step you tend to design things in a way less sensitive to malicious input.)<br>
<p>
Not sure exactly how that relates to eBPF as the parallels aren't exact. eBPF is already bytecode, but because it's destined to be JIT-compiled it's similar to Lua script in terms of the pipeline. And unlike Lua where the VM and compiler are developed completely separately (except coordinated releases), in eBPF I presume the verifier and JIT compiler are more intimately bound.<br>
<p>
Still, the rule of thumb in security engineering is that verification should be disfavored as it duplicates and disassociates logic in a way that increases the risk for bugs. It can be difficult to keep track of the places where the JITer and the runtime depend on the verifier. Even with a safe-by-design bytecode spec, bugs happen, and they're more likely when invariants are expressed thousands of lines apart than when they're expressed a few lines apart.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 12:30 UTC (Thu)
                               by <b>pctammela</b> (guest, #126687)
                              [<a href="/Articles/774047/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; *removed* bytecode verification</font><br>
<p>
Lua doesn't need a bytecode verifier if the interpreter exposed is already sandboxed by the developer, which was the real decision why the bytecode verifier was removed. Some people need it, some don't.<br>
<p>
<font class="QuotedText">&gt; Not sure exactly how that relates to eBPF as the parallels aren't exact.</font><br>
<p>
Both are virtual machines running inside the operating system.<br>
<p>
<font class="QuotedText">&gt;  Lua where the VM and compiler are developed completely separately</font><br>
<p>
Lua has matured enough to be able to release new versions of both separately. It's just a matter of time to eBPF catch up to this pace.<br>
<p>
This is also a design goal of Lua, allowing developers to tune/rewrite the VM without interfering with the compiler and maximizing portability of Lua scripts.<br>
<p>
<font class="QuotedText">&gt; Even with a safe-by-design bytecode spec, bugs happen, and they're more likely when invariants are expressed thousands of lines apart than when they're expressed a few lines apart.</font><br>
<p>
Bugs happen because "Errare humanum est". The likeliness of bugs are intrinsically connected to software architecture and bugs can be minimized with a good test suite, which Lua has.<br>
<p>
Lua is extremelly small, in fact the entire Lua language implementation (VM/Interpreter/C API) is just ~20k lines of logical C code, with the C API dominating a huge chunk of this. Last time I checked, this was smaller than (e)BPF itself. I don't understand your point here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor774136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bounded loops in BPF programs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2018 20:29 UTC (Thu)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/774136/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the execution of the loop is then simulated with the induction variable's largest and smallest values</font><br>
<p>
char x[1];<br>
int i;<br>
for( i=0; i&lt;=10; ++i )<br>
  x[ i &lt; 5 ? i : 10-i ] = 0;<br>
<p>
Checking only the larges and smallest value of the induction variable isn't enough.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
