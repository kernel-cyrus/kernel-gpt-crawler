        <!DOCTYPE html>
        <html lang="en">
        <head><title>Delaying the OOM killer [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/432223/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/430945/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/432223/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Delaying the OOM killer</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 9, 2011</br>
           </div>
The out-of-memory (OOM) killer is charged with killing off processes in
response to a severe memory shortage.  It has been the source of
considerable discussion and numerous rewrites over the years.  Perhaps that
is inevitable given its purpose; choosing the right process to kill at the
right time is never going to be an easy thing to code.  The extension of
the OOM killer into control groups has added to its flexibility, but has
also raised some interesting issues of its own.
<p>
Normally, the OOM killer is invoked when the system as a whole is
catastrophically out of memory.  In the control group context, the OOM
killer comes into play when the memory usage by the processes within that group
exceeds the configured maximum and attempts to reclaim memory from those
processes have failed.  An out-of-memory situation which is contained to a
control group is bad for the processes involved, but it should not threaten
the rest of the system.  That allows for a little more flexibility in how
out-of-memory situations are handled.
<p>
In particular, it is possible for user space to take over OOM-killer duties
in the control group context.  Each group has a control file called
<tt>oom_control</tt> which can be used in a couple of interesting ways:
<p>
<ul>
<li> Writing "1" to that file will disable the OOM killer within
     that group.  Should an out-of-memory situation come about, the
     processes in the affected group will simply block when attempting to
     allocate memory until the situation improves somehow.
<p>
<li> Through the use of a special <tt>eventfd()</tt> file descriptor, a
     process can use the <tt>oom_control</tt> file to sign up for
     notifications of out-of-memory events (see <a
     href="/Articles/432224/">Documentation/cgroups/memory.txt</a> for the
     details on how that is done).  That process will be informed whenever
     the control group runs out of memory; it can then respond to
     address the problem.
</ul>
<p>
There are a number of ways that this user-space OOM killer can fix a
memory issue that affects a control group.  It could simply raise the limit
for that group, for example.  Alternatives include killing processes or
moving some processes to a different control group.  All told, it's a
reasonably flexible way of allowing user space to take over the
responsibility of recovering from out-of-memory disasters.
<p>
At Google, though, it seems that it's not quite flexible enough.  As has
been widely reported, Google does not have very many machines to work with,
so the company has a tendency to cram large numbers of tasks onto each
host.  That has led to an interesting problem: what happens if the
user-space OOM killer is, itself, so starved for memory that it is unable
to respond to an out-of-memory condition?  What happens, it turns out, is
that things just come to an unpleasant halt.
<p>
Google operations is not overly fond of unpleasant halts, so an attempt has
been made to find another solution.  The outcome was <a
href="/Articles/432226/">a patch from David Rientjes</a> adding another
control file to the control group called <tt>oom_delay_millisecs</tt>.
Like <tt>oom_control</tt>, it holds off the kernel's OOM killer in favor of
a user-space alternative.  The difference is that the administrator can
provide a time limit for the kernel OOM killer's patience; if the
out-of-memory situation persists after that much time, the kernel's OOM
killer will step in and resolve the situation with as much prejudice as
necessary.
<p>
To David, this delay looks like a useful new feature for the memory control
group mechanism.  To Andrew Morton, instead, it looks like a kernel hack
intended to work around user-space bugs, and he is not that thrilled by
it.  In <a href="/Articles/432230/">Andrew's view</a>, if user space has
set itself up as the OOM handler for a control group, it needs to ensure
that it is able to follow through.  Adding the delay looks like a way to
avoid that responsibility which could have long-term effects:
<p>
<div class="BigQuote">
	My issue with this patch is that it extends the userspace API.
	This means we're committed to maintaining that interface *and its
	behaviour* for evermore.  But the oom-killer and memcg are both
	areas of intense development and the former has a habit of getting
	ripped out and rewritten.  Committing ourselves to maintaining an
	extension to the userspace interface is a big thing, especially as
	that extension is somewhat tied to internal implementation details
	and is most definitely tied to short-term inadequacies in userspace
	and in the kernel implementation.
</div>
<p>
Andrew would rather see development effort put into fixing any kernel
problems which might be preventing a user-space OOM killer from doing its
job.  David, though, <a href="/Articles/432232/">doesn't see a way</a> to
work without this feature.  If it doesn't get in, Google may have to carry
it separately; he predicted, though, that other users will start asking for
it as usage of the memory controller increases.  As of this writing, that's
where the discussion stands.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Out-of-memory_handling">Memory management/Out-of-memory handling</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#OOM_killer">OOM killer</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/432223/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor432671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 8:27 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/432671/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Writing "1" to that file will disable the OOM killer within that group. Should an out-of-memory situation come about, the processes in the affected group will simply block when attempting to allocate memory until the situation improves somehow.</blockquote>I understand some of the reasons for overcommitting memory when it's not known how much is really available or needed, but blocking on a definite out-of-memory seems just plain daft.  If the kernel knows that no more memory is available why can't it pass that information on to user space?

      
          <div class="CommentReplyButton">
            <form action="/Articles/432671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 8:28 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/432673/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>why can't it pass that information on to user space? </blockquote>I should have said, why can't it pass the info back to the process that requested more memory?  (rather than a third userspace OOM-killer process)
      
          <div class="CommentReplyButton">
            <form action="/Articles/432673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 11:06 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/432700/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think about the same. I see value in having a higher level control on which process get dumped, for instance, in systems composed of many processes where some are more expendable than others. <br>
<p>
But you can "easily" simulate this with conventional means: in precious programs, use a custom version of malloc() that, on error, sends a kill signal to some of the processes on the expendable list.<br>
<p>
Or I'm missing something?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432709"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 11:56 UTC (Thu)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/432709/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      Yes, you are missing something.
<p>What you miss is that in modern Linux, <tt>malloc()</tt> practically never fails. It only allocates virtual space, which is not yet backed by physical memory.
<p>Memory is only actually allocated when the process first touches it&#8212;which can be arbitrarily late. (Plus there are many other kinds of memory allocation: breaking of COW pages created by <tt>fork()</tt>, allocation of page structures in the kernel, <tt>skb</tt>s, &hellip;)

      
          <div class="CommentReplyButton">
            <form action="/Articles/432709/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 14:39 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/432737/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>What you miss is that in modern Linux, malloc() practically never fails.</blockquote>Right, but here is an instance where it does fail to allocate memory.  It is known that the memory is not available right now (although of course it might become available at some point in the future).  The malloc() API has provision for letting that be known to the application, by returning null.  If the application wants to just hang until memory becomes available, that can easily be implemented in user-space (perhaps at the cost of a little busy-waiting or sleeping); but on the other hand if the application would like to find out when no more memory is available and do something, it's impossible to implement that on top of a malloc() interface that just blocks indefinitely.
      
          <div class="CommentReplyButton">
            <form action="/Articles/432737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2011 14:22 UTC (Fri)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/433009/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point is that malloc never does block indefinitely with overcommit enabled.  It (essentially) always succeeds, and what blocks indefinitely is when you try to write to that shiny new virtual address space that was provided to you by malloc.  At this point, the kernel realizes that there aren't any pages to provide you with, but it's too late for malloc to do anything to help you out, since malloc already succeeded.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor432750"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 16:15 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/432750/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see. So much complexity... but is it worth it? Is there someone really using overcommit? <br>
<p>
On a production environment it has to be a maintenance nightmare to have random tasks killed without warning. I would disable it right away. And the same on desktops. I just looked and Ubuntu disables it by default.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432750/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory overcommit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 16:48 UTC (Thu)
                               by <b>rvfh</b> (guest, #31018)
                              [<a href="/Articles/432771/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not just worth it, it's practically impossible to live without it. If you needed to have the total amount of real memory you malloc, most systems would need twice as much RAM.<br>
<p>
Think about memory pools for example...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory overcommit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 21:49 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/432866/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>If you needed to have the total amount of real memory you malloc, most systems would need twice as much RAM.</blockquote>Or just twice as much swap space - which is not an issue on a typical desktop or laptop hard disk these days.  (On an SSD or mobile phone it may be different.)
<p>
If you have a huge swapfile but no overcommit, and if some applications allocate lots of memory and then unexpectedly start using all the memory they asked for, then your system will start swapping and running slowly.  If you just overcommit memory, then when apps start using all the memory they allocated the system will become unstable and processes will be killed without warning by the OOM killer.  It's clear which is preferable.
      
          <div class="CommentReplyButton">
            <form action="/Articles/432866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory overcommit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2011 0:37 UTC (Fri)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/432905/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>If you just overcommit memory, then when apps start using all the memory they allocated the system will become unstable and processes will be killed without warning by the OOM killer. It's clear which is preferable.</I><p>

Surely you've run into the situation where you've been unable to log into a machine because it's swapping like crazy, and are thus unable to kill the offending process? Is that really preferable to being able to go in and fix things immediately? Of course, things are easier when you've got a desktop and are already logged in, but even then I've seen situations where just switching to a terminal took many, many minutes, not to suggest the possibility of opening a new terminal.
<p>The large majority of OOM-killer experiences I've had have been situations where there was a memory leak involved.  In such cases, the OOM killer is usually quite good at identifying the culprit and killing it.  If you add enough swap, then the system freezes up indefinitely (or until you're able to get a killall typed into a terminal).  Not a huge improvement in my book.  In any case, it's not clear which is preferable.
      
          <div class="CommentReplyButton">
            <form action="/Articles/432905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory overcommit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2011 12:17 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/433757/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      You're right, it is sometimes preferable to have applications be killed rather than being unable to log into the machine.  But even here the OOM killer seems like a useful sticking plaster rather than fixing the real problem.  It would be better to have 5% of physical memory reserved for root (or for an interactive 'task manager' that lets you kill misbehaving apps), in the same way that 5% of disk space was traditionally reserved.
<p>
If the I/O scheduler were a bit smarter, then the swapping activities of processes would count against their I/O usage, so a single bloated Firefox process would not be able to monopolize the disk to the exclusion of everything else.  Similarly there could be more fairness in physical RAM allocation, so it wouldn't be possible for one app to consume all the physical memory pushing everything else into swap; it would be limited to say 80%.  (This is reasonable for desktop systems, of course for servers or number-crunching you don't care so much about interactive performance so you'd increase that figure.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/433757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory overcommit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2011 17:43 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/433871/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd say that you want to require 5% or whatever for root-owned apps *that belong to a terminal*. This stops a maddened root-owned daemon from bloating up and leaving you unable to log in again.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor432939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory overcommit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2011 7:10 UTC (Fri)
                               by <b>rvfh</b> (guest, #31018)
                              [<a href="/Articles/432939/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why use loads of swap space when I have 3GB of RAM to run a bunch of services?<br>
<p>
A quick look at top:<br>
Mem:   3095608k total,  2405948k used,   689660k free,   292560k buffers<br>
Swap:   722920k total,    43508k used,   679412k free,  1034276k cached<br>
<p>
So there are 689 MB of unused memory! Not to mention 1 GB+ of of cached stuff for the system to grab in case of need.<br>
<p>
Now let's see the memory usage (top two):<br>
238m 126m  26m /usr/bin/systemsettings<br>
294m  95m  23m /usr/lib/firefox-3.6.14/firefox-bin<br>
<p>
So the two main memory users (systemsettings!?!) have committed more than half a gig of RAM, but use less than a quarter (I know these numbers are not perfect, but the idea remains).<br>
<p>
And you want me to get rid of overcommit???<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory overcommit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2011 12:19 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/433758/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't that the point?  You have three gigabytes of RAM, more than enough to give every application all it needs and do so in a guaranteed way - not 'you can probably have this but you might be randomly killed later on depending on what else happens'.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor432868"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 21:50 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/432868/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My firewall is a swapless embedded system with 512Mb RAM. Do I want overcommit turned on? I thought for perhaps as long as a microsecond before deciding 'hell, yes'.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432868/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor432906"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2011 1:05 UTC (Fri)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/432906/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hate to reply to myself, but I just got it wrong. Overcommit in Ubuntu uses the kernel default, that is, do overcommit. As an experiment I turned it off (setting /proc/sys/vm/overcommit_memory to 2) and after that I couldn't start a new instance of chromium in a not very loaded system (a couple of terminals and Nautilus).<br>
<p>
So apparently it's not only useful but critical.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432906/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2011 7:19 UTC (Fri)
                               by <b>Darkmere</b> (subscriber, #53695)
                              [<a href="/Articles/432943/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Blame chrome there. They allocate a fair chunk of RAM to start with for their javascript memorypool. ( That wants to be continuous, iirc)<br>
  <br>
Basically, Chrome is designed around Overcommit. As are a few other apps.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor433111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2011 23:57 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/433111/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
So apparently it's not only useful but critical.
</blockquote>
<p>
Isn't the problem just that you adjusted /proc/sys/vm/overcommit_memory without making the corresponding adjustment in the amount of swap space?

      
          <div class="CommentReplyButton">
            <form action="/Articles/433111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor432734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 14:17 UTC (Thu)
                               by <b>Tuna-Fish</b> (guest, #61751)
                              [<a href="/Articles/432734/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How would you pass that information? Remember that memory is not allocated on malloc, but when you access a page. Any memory access can fail due to lack of memory -- how do you handle that in userspace?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 14:42 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/432739/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>How would you pass that information?</blockquote>By returning null, as is the documented interface for malloc().
<blockquote>Any memory access can fail due to lack of memory -- how do you handle that in userspace?</blockquote>This is true, you can get errors on accessing memory that was previously 'allocated'.  But that's not a reason for doing the wrong thing in this specific case.  If it is quite certain that the memory isn't available, why not return that to the application using the documented interface?  If the app wants to just sleep waiting for memory to become available, it can do so at its own choice.
      
          <div class="CommentReplyButton">
            <form action="/Articles/432739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2011 0:15 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/433112/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
This is true, you can get errors on accessing memory that was previously 'allocated'. But that's not a reason for doing the wrong thing in this specific case.
</blockquote>
<p>
Which specific case are you referring to?  The article is about the OOM killer, which comes into play when a process accesses memory (for example, executes a STORE instruction), not when a process does malloc().  In that case, how would you have the kernel notify the application program?
<p>
And even if we're talking about a case where the the user space program could be told that the system is out of memory and given the option to do something other than block, that wouldn't be acceptable because the user space programs have already been written.  We want to do the best possible thing given existing programs.  And even if we were talking about programs not yet written, there's something to be said for freeing the coder from worrying about these tedious, extremely rare situations.

      
          <div class="CommentReplyButton">
            <form action="/Articles/433112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2011 12:22 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/433759/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Which specific case are you referring to?</blockquote>
I was referring to this from the article (my italics):
<blockquote>Should an out-of-memory situation come about, the processes in the affected group will simply block <i>when attempting to allocate memory</i> until the situation improves somehow.</blockquote>
Rather than blocking indefinitely on malloc(), it would make more sense to just return null when there is no new memory available.  The application can then decide whether it wants to keep retrying indefinitely, report the error to the user, just die in a big cloud of smoke, or do something else like freeing some of its own data (e.g. the JVM could do a garbage collection pass).  If malloc() just blocks forever, the app doesn't have that choice.
      
          <div class="CommentReplyButton">
            <form action="/Articles/433759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433813"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 16, 2011 15:22 UTC (Wed)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/433813/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Should an out-of-memory situation come about, the processes in the affected group will simply block <em>when attempting to allocate memory</em> until the situation improves somehow.
</blockquote>

Right.  The process here does not block in malloc().  It blocks typically on a store instruction, but also on any of various system calls, such as open().  A malloc() at this time would succeed.
<p>
The process <em>is</em> attempting to allocate memory, as it is the process that is doing the system call or triggering the page fault in which kernel code attempts to allocate physical memory.  malloc(), in contrast, doesn't, from the kernel's point of view, allocate memory &mdash; just addresses for it.
<p>
The article probably should have made a clearer distinction between memory as seen by user space code and memory as seen by the kernel.

      
          <div class="CommentReplyButton">
            <form action="/Articles/433813/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor434063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2011 11:51 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/434063/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the explanation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/434063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor433114"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking on allocation failure - WTF?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2011 0:22 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/433114/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
I understand some of the reasons for overcommitting memory when it's not known how much is really available or needed, but blocking on a definite out-of-memory seems just plain daft. If the kernel knows that no more memory is available why can't it pass that information on to user space?
</blockquote>
<p>
The idea is that the out of memory situation is only temporary.  The OOM killer or one of its user space henchmen will make more memory available eventually, probably by killing some process the administrator <em>didn't</em> say should be immune.

      
          <div class="CommentReplyButton">
            <form action="/Articles/433114/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor432714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 12:41 UTC (Thu)
                               by <b>misiu_mp</b> (guest, #41936)
                              [<a href="/Articles/432714/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"To Andrew Morton, instead, it looks like a kernel hack intended to work around user-space bugs, and he is not that thrilled by it."<br>
<p>
I tend to agree. Wouldn't it be possible for a process that implements an OOM killer, to physically allocate the needed memory on startup? A proper out-of-memory handler should be limited to some (conservative) exact memory requirement.<br>
<p>
The simplest way is to run malloc followed by a memset (for systems with overcommit). This would guarantee the pages are physically allocated or terminate/OOM at an early stage.<br>
Now if such handler would use a kernel call or a system library that requires memory (which would be out of control of the handler's programmer), that call should simply not be made, or the said call be fixed in the kernel/library, possibly also by reserving memory for this. This behavior should also be documented. E.g. free() should never fail. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 12:52 UTC (Thu)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/432717/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I might actually need mlockall(), but even that seems feasible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 13:07 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/432724/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems very dangerous to have anything whose purpose is to respond to out-of-memory conditions and *not* lock it into memory. (What we really need is a way to say 'make this process less overcommitted'. If you do that and then do all the work in a thread, or do a bit of mprotect() work, you can even avoid stack expansions causing OOM.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor432746"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 15:18 UTC (Thu)
                               by <b>nowster</b> (subscriber, #67)
                              [<a href="/Articles/432746/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As has been widely reported, Google does not have very many machines to work with...</font><br>
<p>
Irony not marked?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432746/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2011 21:49 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/432867/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's the trademark dry Corbet wit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2011 17:53 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/433063/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm sure it must be rough for Google, with their rack of aging 386SX's populated almost entirely of SIMMs ganked from retired LaserJets from the local Uni.<br>
<p>
;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor433197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2011 18:15 UTC (Sat)
                               by <b>Per_Bothner</b> (subscriber, #7375)
                              [<a href="/Articles/433197/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <i>It's the trademark dry Corbet wit.</i>
<p>
Imagine 100 years from now somebody updating the HyperPedia article on Google, to note that Google ran on a small number of machines, and using this sentence as a reference.
<p>
History could be re-written because of careless sarcasm.
      
          <div class="CommentReplyButton">
            <form action="/Articles/433197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2011 4:23 UTC (Sun)
                               by <b>dmag</b> (guest, #17775)
                              [<a href="/Articles/433230/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Imagine 100 years from now [..] using this sentence as a reference.</font><br>
<p>
Riiight. A future in which LWN is the only known text of this time? And just this page so future historians don't notice his penchant for witty comments like this?<br>
<p>
Besides, Google hasn't even hit 10M machines yet, so I think Corbet is spot on.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2011 5:39 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/433235/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed.<br>
<p>
Further, it is widely reported that google go to some efforts to squeeze as much work as they possibly can out of the computers that they do have, which is the real point of background to this article.<br>
<p>
So it certainly appears that they do not have spare computing resources.. is that the same as "not many computers" - It's hard to say.  Many is a relative term:<br>
<p>
I do have many computers at home - 7 or 8.<br>
Google doesn't have many computers in their data centers - less than 10 million.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor433306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2011 13:14 UTC (Mon)
                               by <b>alextingle</b> (guest, #20593)
                              [<a href="/Articles/433306/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
*fewer* than 10 million.<br>
<p>
;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor433309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Delaying the OOM killer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2011 13:43 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/433309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The future historians would also have to be unaware of the existence of Google, its size, and probably also of the existence of sarcasm. Given that we can spot sarcasm in the works of Chaucer and in Beowulf, I'd say that these future historians are remarkably implausible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/433309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
