        <!DOCTYPE html>
        <html lang="en">
        <head><title>Blocking straight-line speculation — eventually [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/877845/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/878144/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/877845/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Blocking straight-line speculation — eventually</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 9, 2021</br>
           </div>
The Spectre class of vulnerabilities was given that name because, it was
thought, these problems would haunt us for a long time.  As the fourth
anniversary of <a href="/Articles/742702/">the disclosure of Meltdown and
Spectre</a> approaches, there is no reason to doubt the accuracy of that
name.  One of 
the more recent Spectre variants goes by the name "straight-line
speculation"; it was first disclosed in June 2020, but fixes are still
trying to find their way into the compilers and the kernel.
<p>
Straight-line speculation differs somewhat from the other Spectre
vulnerabilities.  To review, the classic Spectre problem afflicts code like
this:
<p>
<pre>
    if (offset &lt; obj-&gt;array_length)
       do_something_with(obj-&gt;array[offset]);
</pre>
<p>
On its face, this code is safe; it will only attempt to index into
<tt>obj-&gt;array</tt> if the given offset is within bounds.  A CPU running
this code, though, may be unable to fetch <tt>obj-&gt;array_length</tt>
from cache, meaning that it will have to wait for that value to come from
memory.  Rather than do nothing, the CPU can make a guess as to how the
comparison will turn out and continue execution in a speculative mode; it
may guess wrong and index <tt>obj-&gt;array</tt> with an out-of-bounds
<tt>offset</tt>.  Again, this shouldn't be a problem; once the array length
shows up and it becomes clear that the branch was not correctly predicted,
the speculative work will be thrown away.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
The problem, of course, is that this speculative execution can leave traces
elsewhere in the system (most often the memory caches) that can be used to
exfiltrate data that an attacker would otherwise be unable to access.  In
the worst cases, Spectre vulnerabilities can be used to attack the kernel or to
carry out attacks between virtual machines running on the same physical
host.  They are a real threat, which is why numerous mitigations have been
adopted to thwart these attacks despite a high performance cost.
<p>
Straight-line speculation, which was initially disclosed in <a
href="https://developer.arm.com/support/arm-security-updates/speculative-processor-vulnerability/downloads/straight-line-speculation">this
white paper from Arm</a>, differs in that it does not depend on erroneous
branch prediction; indeed, no conditional branches are involved at all.
Instead, it
takes advantage of some strange behavior around <i>unconditional</i>
control-flow changes.  There are a lot of instructions that will result in
a change to the program counter; on Arm, these include instructions that
generate exceptions, but also unconditional direct branches and the
<tt>RET</tt> instruction to return from a function call.
<p>
One would think that it would not be all that hard for a
speculative-execution mode to do the right thing (stop speculation, if
nothing else) when it encounters one of these instructions.  But, as it
turns out, on some CPUs, in some situations, the CPU can execute
speculatively right past one of those instructions as if it were not there
— in a straight line, as it were.
If an attacker can place code that will carry out the desired access
immediately after one of these instructions, that code may be executed
speculatively, with the usual effects elsewhere in the system.  It is a
hard vulnerability to exploit (it's not clear that anybody has done it in
the real world), but it is still a vulnerability that is worth fixing.
<p>
This vulnerability in Arm CPUs was assigned <a
href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-13844">CVE-2020-13844</a>.
Patches were quickly added to GCC and LLVM to address the problem; the new
<tt>-mharden-sls</tt> flag can be used to turn the new mitigations on.
Happily, this problem is relatively easy to fix; placing a barrier
instruction after
the unconditional jumps will do the trick.  Since the jumps are, as noted,
unconditional, those barriers will not actually be executed for real, but
they will be encountered during straight-line speculative execution, at
which point the speculation will stop.
So there is no real
performance impact, other than a slight increase in executable size, from
this change.
<p>
As it happens, this is not just an Arm problem; some x86 processors can
speculatively execute past <tt>RET</tt> instructions as well.  The solution
in this case is to place an <tt>INT3</tt> instruction after the
<tt>RET</tt> to stop speculation.  <tt>INT3</tt> is a single-byte
instruction normally used by debuggers to set breakpoints; once again, it
will not actually be executed when used in this way.
<p>

The compiler changes are in place to deal with this vulnerability (though
they do not yet appear in released versions), but the kernel has not yet
been updated to match.  Among other things, the difficulty in exploiting
this vulnerability has made addressing it seem less than fully urgent.

<p>
Jian Cai posted <a
href="/ml/linux-kernel/20210212051500.943179-1-jiancai@google.com/">a patch
series</a> in February adding protection for Arm, but that work has not
been merged.  Arm developer Will Deacon was <a
href="/ml/linux-kernel/20210305095256.GA22536@willie-the-truck/">opposed to
the patch</a>:
<p>
<blockquote class="bq">
	I still don't see why SLS is worth a compiler mitigation which will
	affect all CPUs that run the kernel binary, but Spectre-v1 is
	not. In other words, the big thing missing from this is a
	justification as to why SLS is a problem worth working around for
	general C code.
</blockquote>
<p>
That patch series has not returned since.
<p>
The x86 side has seen more recent work in the form of <a
href="/ml/linux-kernel/20211204134338.760603010@infradead.org/">this patch
series</a> from Peter Zijlstra.  It, too, uses the new compiler options
(when available) to insert the needed instructions, but (as Deacon had
<a
href="/ml/linux-kernel/20210217094859.GA3706@willie-the-truck/">noted</a>
in response to the Arm patches) that is only part of the problem.
There is quite a bit of assembly code in the kernel, none of which will be
addressed by changes to the compilers.  So Zijlstra laboriously went
through that code, replacing all <tt>RET</tt> instructions with a macro
that can, when the right configuration options are selected, expand to
include the <tt>INT3</tt> instruction as well.  For good measure, the
<tt>objtool</tt> utility is also enhanced to check that <tt>INT3</tt>
instructions have been inserted where needed as a way of preventing
potential vulnerabilities from being added in the future.
<p>
Given that nearly a year and a half has passed since this vulnerability was
disclosed, it is clear that nobody is feeling that it must be addressed
urgently.  The slow progress toward protection from straight-line
speculation is a far cry from the scrambling that took place prior to the
initial Meltdown and Spectre disclosures.  But one thing we should have
learned by now is that attackers will eventually figure out a way to make
use of any opening, no matter how difficult it is to exploit.  So
protection from straight-line speculation vulnerabilities with little
performance penalty is welcome, even if it comes late.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Meltdown_and_Spectre">Security/Meltdown and Spectre</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/877845/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor878175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2021 17:37 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/878175/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There are a lot of instructions that will result in a change to the program counter</font><br>
<p>
Which instructions do not result in a change to the program counter?<br>
Even HLT eventually results in a PC increment after waking up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2021 17:49 UTC (Thu)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/878177/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Clearly &quot;other than the default PC increment&quot; is meant, and the speculation problem is that the processor might be already churning along in a straight line, prefetching instructions and speculatively executing parts of them before it figures out that it has a return instruction or an unconditional branch.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor878200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2021 19:31 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/878200/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;jmp .&quot; does not increment PC :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2021 19:34 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/878201/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
perfect answer :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor878209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2021 22:32 UTC (Thu)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/878209/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is ASTOUNDING to me that the BSDs (eg NetBSD, OpenBSD) still have *no* mitigation *whatsoever* for spectre v1.<br>
<p>
Other variants? yes! Net even pokes a chicken bit on K10 (to disable the branch predictor) that linux (except RHEL) doesn&#x27;t touch.<br>
<p>
The original excuse was that the only tool which could scan for v1 gadgets was Synopsis&#x27; Coverity tool (which costs money), but there are open source tools available now. It appears to be more a question of manpower, finding gadgets but also implementing the infrastructure (user pointer sanitization/barriers/etc) that are needed for a comprehensive mitigation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 12:56 UTC (Fri)
                               by <b>jrigg</b> (guest, #30848)
                              [<a href="/Articles/878248/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It is ASTOUNDING to me that the BSDs (eg NetBSD, OpenBSD) still have *no* mitigation *whatsoever* for spectre v1.</font><br>
<p>
I may be misunderstanding something here, but OpenBSD disabled hyperthreading on Intel CPUs in 2018 to prevent some spectre-type exploits. Does that not count?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878351"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2021 6:40 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/878351/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Different spectre variants exploit different microarchitectural units or behavior. Disabling hyperthreading will mitigate only a small number of spectre vulnarabilities (eg MDS), and even then only when combined with other changes. Disabling hyperthreading will do nothing at all for Spectre v1 (or spectre v2 or spectre v3, or v3a or v4 or many others). It is also no longer required due to Linux&#x27;s core-scheduling work, which controls what threads can be hyperthread siblings.<br>
<p>
Spectre v1 is essentially where a bounds check is speculated past, allowing unauthorized memory reading. The correct mitigation is to locate vulnerable gadgets (which could be anywhere in a codebase) using static analysis and add guards or memory barriers to them.<br>
<p>
This was a long an arduous process for the linux kernel. They started with the obvious gadgets in the syscall interfaces which directly handle user-supplied pointers, but eventually turned to static analysis to locate the remaining sites.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878351/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor878361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2021 12:56 UTC (Sat)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/878361/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding was that the only way Spectre can actually be exploited is if you have the ability to run arbitrary code on the system you are attacking. Frankly, if you&#x27;re in that situation you&#x27;re basically screwed from a security perspective anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2021 13:28 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/878363/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Like JavaScript?<br>
<p>
<a href="https://security.googleblog.com/2021/03/a-spectre-proof-of-concept-for-spectre.html?m=1">https://security.googleblog.com/2021/03/a-spectre-proof-o...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2021 7:40 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/878704/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would I run untrusted Javascript?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2021 9:02 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/878708/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So you really trust each and every website you visit?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878712"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2021 10:00 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/878712/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is not what milesrout said, and you know it.<br>
<p>
And while I haven&#x27;t got a mental list of who does or doesn&#x27;t, I do know that some regulars in the LWN comments section don&#x27;t trust websites and don&#x27;t run the javascript on them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878712/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor879268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2021 23:53 UTC (Mon)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/879268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m the one outlier that&#x27;s been using web content blockers with a whitelist since the days of IE6 security zones, but that&#x27;s besides the point.<br>
<p>
Given the options available here, I readily pay the cost of a few extra microseconds of CPU time to mitigate the fallout of Intel prioritising anticompetitive ratfxxking over security for 20 years, since it helps maintain the herd immunity that makes exploiting this at internet scale not worth the effort. The last thing we need in this situation is encouraging some fool to try NetSpectre attacks in the wild through broadcasting intent of inaction, unlikely as that may sound.<br>
<p>
It&#x27;s not hard (nowadays) to imagine other examples where the complacency of the commons led to someone permanently making the world a little worse for everyone via a previously-unthinkable global misuse of computing resources.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/879268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor878366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2021 17:47 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/878366/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But to satisfy that requirement, I understood all that was necessary was for you to be running a virtual machine on the same hardware ...<br>
<p>
In other words, if you&#x27;re worried about Spectre, the cloud is off-limits. A BIG problem for a lot of companies nowadays ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2021 21:26 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/878371/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One can still rent a dedicated server. Some of those are rather cheap.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor878374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2021 0:54 UTC (Sun)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/878374/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For all the grand-standing they did over hyperthreading, and the partial mitigations they did bother to put into place, you&#x27;d think they could at least finish covering the basics.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor878238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 9:53 UTC (Fri)
                               by <b>jorgegv</b> (subscriber, #60484)
                              [<a href="/Articles/878238/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder why the filler instruction in X86 is an INT3? Wouldn&#x27;t a NOP be equally valid and less distracting?<br>
<p>
If for nothing else, it would not induce questions about why there are INT3 instructions all over the place, when examining an assembly listing. I mean, if I find lots of NOPs, I&#x27;ll think &quot;well, these NOPs must be here for a reason, let&#x27;s investigate&quot;, but with INT3 I would think &quot;well, why does this program need to be breakpointed all over the place?&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 10:03 UTC (Fri)
                               by <b>slu</b> (subscriber, #92473)
                              [<a href="/Articles/878240/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that&#x27;s because NOP does not cease speculative execution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 10:47 UTC (Fri)
                               by <b>ale2018</b> (guest, #128727)
                              [<a href="/Articles/878242/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The next question is why int stops speculative execution while ret does not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 12:43 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/878246/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      There is no guarantee in either case.  farnz provides some speculation, but there could theoretically also be microarchitectures where ret stops speculation and int3 does not.

<p>My own speculation is that some CPU designer considered stopping speculation in all these cases don't-care outputs of the decoder, and the logic optimizer found that it could save some transistors and/or latency by producing "stop" for int3 and "go ahead" for ret.  If that is the case, then for a similar decoder the result will likely be the same, while for a quite-different microarchitecture it can be different.

<p>An alternative speculation is: Ok, so the branch predictor failed to predict the RET correctly and the instruction fetcher just fetches in a straight line beyond it.  The next stages consider the arriving instructions to be from the right places, and speculate past the RET (which appears almost like a NOP at this point (exception: changes RSP and the branch prediction needs to be checked)) for good performance.  INT3 could be treated in the same way, but it has not been the object of optimization efforts by CPU designers, leading us back to my first speculation.


      
          <div class="CommentReplyButton">
            <form action="/Articles/878246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 16:27 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/878284/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>There's a simple reason why <tt>INT3</tt> won't stop speculation, where <tt>RET</tt> will - <tt>Jcc next; RET; .next</tt> is not an uncommon sequence for a compiler to want to emit, while<tt>INT3</tt> is almost always encountered as a breakpoint into a debugger.
<p>If the predictor mispredicts <tt>Jcc next</tt>, there are wins to be had by speculating past the <tt>RET</tt> as if it's not taken; these wins would be lost if <tt>RET</tt> was a speculation barrier. Thus, by ensuring that speculation continues past <tt>RET</tt>, you get speculative execution wins in the case where <tt>Jcc next</tt> is mispredicted, at the expense of having to unwind speculation when the <tt>RET</tt> was not preceded by a condition.
<p>In contrast, <tt>INT3</tt> as the debugger breakpoint is never seen in traces where performance matters - almost by definition, if you want to stop and let the debugger inspect, you're in a slow path. While it's possible that the slow path will be optimized by mistake, it'd be unexpected. Assuming that all extant CPUs don't optimize this slow path, you'd be surprised if a post-Spectre design permitted speculation through debugger breakpoints.


      
          <div class="CommentReplyButton">
            <form action="/Articles/878284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878288"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 18:06 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/878288/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Maybe some CPU designer followed the same reasoning as you did.  I doubt that your scenario makes a significant difference, for the following reasons:

<ol>
<li> Branch mispredictions are rare; in particular, mispredicting RET is rare (unless intentional, as in the retpoline).

<li> Branch mispredictions are speculation barriers in current microarchitectures (and because of reason 1, this is not going to change); the only thing that gets through this barrier are side channels and they should not.  I.e., once Spectre is fixed in hardware, the "wins to be had" will no longer exist (of course we don't have such hardware fixes yet; but do we really assume that (before Spectre was revealed) CPU designers considered potential performance benefits of persisting speculative changes in the caches but did not consider the security consequences; well, given that CPUs compete on performance, not on security, it's plausible).

<li>The "wins to be had" are that the speculatively executed code loads some data into the cache, and when rerunning the code non-speculatively you access the same data. OTOH, by speculating past a RET the CPU might also load data into the cache that is not used later and that evicts useful data, so there are also losses to be had.

</ol>

As for the commonality of <code>Jcc next; RET; .next</code>: In the code I looked at (mostly from gcc), it tends to convert <code>if (...) return;</code> into a conditional branch to common return code at the end of the function; and the return is often more than just a single RET.



      
          <div class="CommentReplyButton">
            <form action="/Articles/878288/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor878389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2021 15:01 UTC (Sun)
                               by <b>draco</b> (subscriber, #1792)
                              [<a href="/Articles/878389/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t understand why we&#x27;re speculating about the behavior? Intel should be able to document it and then we&#x27;ll know if the mitigation works or not (and in what cases).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2021 22:06 UTC (Sun)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/878408/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They do. The docs explicitly state that you should use int3 or lfence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor878368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2021 20:10 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/878368/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Because <code>ret</code> handled specially. Usually <code>ret</code> is well-predictable jump (CPU has separate hidden stack which keeps track of <code>ret</code> targets). But if your function if <b>very</b> short (one or two instructions) then address pushed into that stack by <code>call</code> wouldn't be ready in time for the predictor to use it.</p>

<p>If that happens it's usually better (from performance POV) to predict that next address would be targeted instead if doing no prediction at all: yes, usually you would be wrong, but “<code>ret</code> is always predicted” simplifies the logic and in some cases you would be executing code which not entirely useless.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/878368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor878241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 11:15 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/878241/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>INT3 is about the only choice you have in the x86 instruction set to cease straight line speculative execution. You want a single byte instruction, to minimise wasted space in the instruction cache; it needs to unconditionally change the CPU's execution flow, so that speculation knows not to continue past it.
<p>Single byte instructions that could affect execution order in x86 and x86-64 (so ignoring the ones that have been removed by x86-64 like <tt>INTO</tt>) are:
<ul>
<li><tt>HLT</tt>. This is one that appears in CPU idle loops, and thus it's not unreasonable to assume that it's worth speculating past this in a straight line - assume an external interrupt, and get the caches hot for the post-idle work.
<li><tt>ICEBP</tt>. Break into a debugger attached to your In Circuit Emulator. Undocumented behaviour involved if you don't have an ICE attached.
<li><tt>INT3</tt>. This is for breakpoints, so the assumption is that a human will be looking at state before resuming execution. No point optimizing this; we expect to sit in the debugger for a while, possibly changing state, before resuming.
<li><tt>RET</tt>. We know this one is speculated - so not a good choice.
<li><tt>RSM</tt>. A variant on <tt>RET</tt> - plausibly speculated.
<li><tt>UD</tt>. Explicitly an undefined instruction, jumping to the undefined instruction trap.
<li><tt>WAIT</tt>. Waits for the x87 FPU; does not change instruction flow unconditionally, so not a good choice.
</ul>
<p>Other instructions that change control flow are multi-byte, and thus not a great choice for instruction cache utilization.
<p>From that list, we have three candidates; <tt>ICEBP</tt>, <tt>INT3</tt> and <tt>UD</tt>. <tt>ICEBP</tt> is not a good choice, because its behaviour is undocumented if an ICE is not attached, which makes it plausible that it's speculated as a NOP if an ICE is not attached. <tt>UD</tt> is similarly a risky choice; as it's a guaranteed undefined instruction, speculating past it seems reasonable on the basis that it should never be hit, and the history of Spectre is of CPU vendors speculating past things they shouldn't on the basis that it won't hurt.
<p>This leaves <tt>INT3</tt>, where the defined behaviour is to enter the debugger, and thus while it's plausible that you'd want to speculate past it into the debugger code, it's unlikely that you'd speculate instructions in the stream after an <tt>INT3</tt> - you'd go via the <tt>INT3</tt> vector and speculate along that path instead. Plus, optimizing for fast code execution after the debugger isn't worthwhile; expectations are that a human is in the loop at this point, and humans are slow, so it's unlikely that a past CPU designer ever thought to speculate past it, while future CPU designers know to worry about speculation.


      
          <div class="CommentReplyButton">
            <form action="/Articles/878241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 15:27 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/878282/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your reasoning is all very reasonable. The problem is that the same kind of reasoning should apply to RET. It obviously doesn&#x27;t, which begs the question why it should apply to any of the other alternatives.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 16:10 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/878283/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>I think the bit of my reasoning that you're missing is that <tt>INT3</tt> (and <tt>ICEBP</tt>) are not normally seen in code, where <tt>RET</tt> is. AIUI, the underlying mechanism that goes wrong is that <tt>RET</tt> and equivalents are not marked as speculation barriers, since code of the form <tt>Jcc next ; RET; .next</tt> isn't uncommon in real programs. If <tt>RET</tt> blocks speculation past it, then you don't get the benefits of speculating past this sort of sequence, because you assume the <tt>Jcc</tt> is not taken, then <tt>RET</tt> gets in the way of further (useful) speculation in the event that the <tt>Jcc</tt> is taken.
<p>Breakpoints, on the other hand, are rare, and the presence of a breakpoint is an indication that performance is less relevant than predictable behaviour. I would thus not expect a processor designer to optimize for performance in the face of breakpoints, where I would expect them to optimize for performance in the face of instructions compilers output, including UD, RET and others.


      
          <div class="CommentReplyButton">
            <form action="/Articles/878283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 18:17 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/878289/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm. I have to admit that don&#x27;t really buy your &quot;Jcc .next&quot; argument because that depends on branch prediction. If the branch is predicted correctly (i.e. to allow speculation past the RET), said RET isn&#x27;t even seen. If it is not, the misprediction causes a pipeline stall which is plenty expensive on its own, and while the very next instruction MIGHT occasionally pull a value into the cache a little earlier than it would otherwise do, any performance improvement gained from that is likely to be lost in the noise.<br>
<p>
Also, function post-ambles tend to be a bit longer than a simple RET.<br>
<p>
Anyway. We might assume that the default is to run speculative execution no matter what the instruction does to the PC, by the simple fact that there&#x27;s a lot more instructions which don&#x27;t affect the PC than those which do.<br>
<p>
Thus there&#x27;s IMHO no reason for anybody to have done the work to set the do-not-speculate-past-me flag for any of the aforementioned opcodes. What would be the point, if they&#x27;re so infrequent that optimizing for them is a non-issue?<br>
<p>
Somebody might want to test that, one way or the other. Until then I would NOT assume that any of these really do block speculation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2021 19:33 UTC (Fri)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/878315/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Somebody might want to test that, one way or the other. Until then I would NOT assume that any of these really do block speculation.</font><br>
<p>
You should be careful with what you say. This implies that you thinks the people taking care of this are total idiots. For sure this already has been checked before the patch was proposed. Everything else would be ridiculous. We can speculate (pun indented) a lot on why the CPU threats one instruction different from the other, but we will not come to a conclusion. Maybe Intel/AMD have some idea.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor878369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2021 20:21 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/878369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; AIUI, the underlying mechanism that goes wrong is that RET and equivalents are not marked as speculation barriers</font>

<p>Not only RET is is not a speculation barrier, there are, actually, the whole huge machinery in CPUs which is designed to speculate past RET (not to the next instruction, but back to the caller, of course). That's why we have retpolines.</p>

<p>It doesn't make it hard to imagine that if such predictor is broken (by use of retpolines to mitigate other Spectre variants) it would start pointing to the next instruction after RET, instead.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/878369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor965199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2024 7:14 UTC (Wed)
                               by <b>changbin</b> (guest, #87107)
                              [<a href="/Articles/965199/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
UD2 can stop the fall-through speculation, but it takes two bytes.<br>
<p>
"Assembly/Compiler Coding Rule 13. (M impact, L generality) When indirect branches are<br>
present, try to put the most likely target of an indirect branch immediately following the indirect<br>
branch. Alternatively, if indirect branches are common but they cannot be predicted by branch<br>
prediction hardware, then follow the indirect branch with a UD2 instruction, which will stop the<br>
processor from decoding down the fall-through path."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/965199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor878822"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2021 10:16 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/878822/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was thinking UD2 would be better.  (Doesn&#x27;t INT3 speculate into the interrupt handler - it is, after all, a kind of unconditional jump).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/878822/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor878823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking straight-line speculation — eventually</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 16, 2021 10:38 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/878823/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I'm assuming people have checked before implementing this, but I'd expect to see more speculation weirdness around UD2 than around INT3; compilers output UD2 in codepaths that should never be reached, while INT3 is only ever put in the instruction stream by a debugger. If you're looking at a corpus of real code to see what  gains you get from a given bit of speculation, UD2 will be in there, INT3 will not.
<p>And the latest issue is related to speculating past a RET instruction, which is also an unconditional jump. We basically can't trust our instincts on which instructions speculate in which fashion :-(


      
          <div class="CommentReplyButton">
            <form action="/Articles/878823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
