        <!DOCTYPE html>
        <html lang="en">
        <head><title>Who's afraid of a big bad optimizing compiler? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/793253/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/793456/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/793253/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Who's afraid of a big bad optimizing compiler?</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>July 15, 2019</p>
           <p>(Many contributors)</p>
           </div>
This article was contributed by
	   Jade Alglave, Will Deacon, Boqun Feng, David Howells, Daniel
	   Lustig, Luc Maranget, Paul E. McKenney, Andrea Parri, Nicholas
	   Piggin, Alan Stern, Akira Yokosawa, and Peter Zijlstra.

<p>

When compiling Linux-kernel code that does a plain C-language load or
store, as in "<tt>a=b</tt>", the C standard grants the compiler the right
to assume that the affected variables are neither accessed nor modified by
any other thread at the time of that load or store.  The compiler is
therefore permitted to carry out a large number of transformations, a
couple of which were discussed in this <a
href="/Articles/508991/"><tt>ACCESS_ONCE()</tt> LWN article</a>, and
another of which is described in <a
href="https://github.com/google/ktsan/wiki/READ_ONCE-and-WRITE_ONCE">Dmitry
Vyukov's KTSAN wiki page</a>.  However, our increasingly aggressive modern
compilers produce increasingly surprising code optimizations.  Some of
these optimizations might be especially surprising to developers who assume
that each plain C-language load or store will always result in an
assembly-language load or store.  Although this article is written for
Linux kernel developers, many of these scenarios also apply to other
concurrent code bases, keeping in mind that "concurrent code bases" also
includes single-threaded code bases that use interrupts or signals.

<p>
The ongoing trend in compilers makes us wonder:
"Just how afraid should we be?".
The following sections should help answer this question:

<ol>
<li>	<a href="#Load Tearing">Load tearing</a>
<li>	<a href="#Store Tearing">Store tearing</a>
<li>	<a href="#Load Fusing">Load fusing</a>
<li>	<a href="#Store Fusing">Store fusing</a>
<li>	<a href="#Code Reordering">Code reordering</a>
<li>	<a href="#Invented Loads">Invented loads</a>
<li>	<a href="#Invented Stores">Invented stores</a>
<div class="tlr">
<a name="Quick Quiz 1"><b>Quick quiz 1</b>:</a>
	But we shouldn't be afraid at all for things like
	on-stack or per-CPU variables, right?
<br><a href="#qq1answer">Answer</a>
</div>
<li>	<a href="#Store-to-Load Transformations">
	Store-to-load transformations</a>
<li>	<a href="#Dead-Code Elimination">Dead-code elimination</a>
<li>	<a href="#How Real Is All This?">How real is all this?</a>
</ol>

<p>

This is followed by the ineludible
<a href="#Answers to Quick Quizzes">answers to the quick quizzes</a>.


<h4><a name="Load Tearing">Load tearing</a></h4>

<p>
Load tearing occurs when the compiler uses multiple load
instructions for a single access.
For example, the compiler could, in theory, compile the load from
<tt>global_ptr</tt> on line&nbsp;1 of 
the following code
as a series of one-byte loads.

<pre>
  1 ptr = global_ptr; /* BUGGY if load tearing possible. */
  2 if (ptr != NULL &amp;&amp; ptr &lt; high_address) /* BUGGY!!! */
  3         do_low(ptr);
</pre>

If some other thread was concurrently setting <tt>global_ptr</tt> to
<tt>NULL</tt>, the result might have all but one byte of the pointer
set to zero, thus forming a "wild pointer".
Stores using such a wild pointer could corrupt arbitrary
regions of memory, resulting in rare and difficult-to-debug crashes.


<p>
Worse yet, on (say) an eight-bit system with 16-bit pointers, the compiler
might have no choice but to use a pair of eight-bit instructions to access
a given pointer.
And even on today's 32-bit and 64-bit systems, a misaligned or too-large
access could tear.
Because the C standard must support all manner of systems, the standard
cannot rule out load tearing in the general case.

<p>
<div class="tlr">
<a name="Quick Quiz 2"><b>Quick quiz 2</b>:</a>
	But there are lots of plain loads from shared variables in the
	Linux kernel.
	These cannot possibly all be buggy, can they?
<br><a href="#qq2answer">Answer</a>
</div>


However, the remainder of this article will assume properly aligned
and machine-word-sized accesses, in which case <tt>READ_ONCE()</tt>
will prevent load tearing.
(In the Linux kernel, tearing of plain C-language loads
<a href="http://lkml.kernel.org/r/CAHk-=wj2t+GK+DGQ7Xy6U7zMf72e7Jkxn4_-kGyfH3WFEoH+YQ@mail.gmail.com">has been observed</a>
even given properly aligned and machine-word-sized loads.)


<h4><a name="Store Tearing">Store tearing</a></h4>

<p>
Store tearing occurs when the compiler uses multiple store
instructions for a single access.
For example, one thread might store <tt>0x12345678</tt> to a four-byte integer
variable at the same time as another thread stored <tt>0xabcdef00</tt>.
If the compiler used 16-bit stores for either access, the result
might well be <tt>0x1234ef00</tt>, which could come as quite a surprise to
code loading from this integer.
Nor is this a strictly theoretical issue.
For example, there are CPUs that feature small immediate values,
and on such CPUs, the compiler can be tempted
to split a 64-bit store into two 32-bit stores in order to reduce the overhead
of explicitly forming the 64-bit constant in a register, even on a 64-bit CPU.
There are historical reports of this actually happening in the wild,
but there is also a
<a href="https://lore.kernel.org/lkml/20190821103200.kpufwtviqhpbuv2n@willie-the-truck/">recent report</a>.
Note that this tearing can happen even on properly aligned and
machine-word-sized accesses, and in this particular case, even for
volatile stores.
Some might argue that this behavior constitutes a bug in the compiler,
but either way it illustrates the perceived value of store tearing from
a compiler-writer viewpoint.


<p>
Of course, the compiler simply has no choice but to tear some stores
in the general case, given the possibility of code using 64-bit integers
running on a 32-bit system.
But for properly aligned machine-sized stores, <tt>WRITE_ONCE()</tt>
will prevent store tearing.

<h4><a name="Load Fusing">Load fusing</a></h4>

<p>
Load fusing occurs when the compiler uses the result of a
prior load from a given variable instead of repeating the load.
Not only is this sort of optimization just fine in single-threaded
code, it is often just fine in multithreaded code.
Unfortunately, the word "often" hides some truly annoying
exceptions, including the one called out in
the <tt>ACCESS_ONCE()</tt> article.


<p>
For example, suppose that a realtime system needs to invoke a
function named <tt>do_something_quickly()</tt> repeatedly until the
variable <tt>need_to_stop</tt> is set, and that the compiler can see
that <tt>do_something_quickly()</tt> does not store to <tt>need_to_stop</tt>.
One (unsafe) way to code this might look like:

<pre>
  1 while (!need_to_stop) /* BUGGY!!! */
  2     do_something_quickly();
</pre>
<p>

The compiler might reasonably unroll this loop sixteen times in order
to reduce the per-invocation overhead of the backwards branch at the
end of the loop.
Worse yet, because the compiler knows that <tt>do_something_quickly()</tt>
does not store to <tt>need_to_stop</tt>, the compiler could quite reasonably
decide to check this variable only once, resulting in the code shown below:
<p>
<pre>
  1 /* Optimized code */
  2 if (!need_to_stop)
  3     for (;;) {
  4         do_something_quickly();
  5	    do_something_quickly();
  6	    do_something_quickly();
  7	    do_something_quickly();
  8	    do_something_quickly();
  9	    do_something_quickly();
 10	    do_something_quickly();
 11	    do_something_quickly();
 12	    do_something_quickly();
 13	    do_something_quickly();
 14	    do_something_quickly();
 15	    do_something_quickly();
 16	    do_something_quickly();
 17	    do_something_quickly();
 18	    do_something_quickly();
 19	    do_something_quickly();
 20     }
</pre>
<p>

Once entered, the loop on
lines&nbsp;3-20 will never stop, regardless of how
many times some other thread stores a non-zero value to <tt>need_to_stop</tt>.
The result will at best be disappointment, and might also
include severe physical damage.

<p>
The compiler can fuse loads across surprisingly large spans of code.
For example, in this code:

<pre>
  1 int *gp;
  2
  3 void t0(void)
  4 {
  5     WRITE_ONCE(gp, &amp;myvar);
  6 }
  7
  8 void t1(void)
  9 {
 10     p1 = gp; /* BUGGY!!! */
 11     do_something(p1);
 12     p2 = READ_ONCE(gp);
 13     if (p2) {
 14         do_something_else();
 15         p3 = *gp; /* BUGGY!!! */
 16     }
 17 }
</pre>

<tt>t0()</tt> and <tt>t1()</tt> run concurrently, and
<tt>do_something()</tt> and <tt>do_something_else()</tt> are inline functions.
Line&nbsp;1 declares the pointer <tt>gp</tt>, which C initializes to
<tt>NULL</tt> by default.
At some point, line&nbsp;5 of <tt>t0()</tt> stores a non-<tt>NULL</tt>
pointer to <tt>gp</tt>.
Meanwhile, <tt>t1()</tt> loads from <tt>gp</tt> three times on
lines&nbsp;10, 12, and&nbsp;15.
Given that line&nbsp;13 finds that <tt>gp</tt> is non-<tt>NULL</tt>, one might
hope that the dereference on line&nbsp;15 would be guaranteed never
to fault.
<p>
Unfortunately, the compiler is within its rights to fuse the reads on
lines&nbsp;10 and&nbsp;15 which means that if line&nbsp;10
loads <tt>NULL</tt> and line&nbsp;12 loads <tt>&amp;myvar</tt>,
line&nbsp;15 could dereference <tt>NULL</tt>, resulting in a fault.
Note that the intervening <tt>READ_ONCE()</tt> does not prevent the other
two loads from being fused, despite the fact that all three are loading
from the same variable.
It might seem that no real compiler would ever do this, but
Will Deacon reports that this has
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a7b100953aa3">actually happened in the Linux kernel</a>.

<p>
<div class="tlrw">
<a name="Quick Quiz 3"><b>Quick quiz 3</b>:</a>
	Why does it matter whether <tt>do_something()</tt> and
	<tt>do_something_else()</tt> 
	are inline functions?
<br><a href="#qq3answer">Answer</a>
</div>

Avoid load fusing by either using <tt>READ_ONCE()</tt> for the other
accesses to <tt>gp</tt> or by placing at least a Linux kernel
<tt>barrier()</tt> between each of these three accesses.


<h4><a name="Store Fusing">Store fusing</a></h4>

<p>
Store fusing can occur when the compiler notices a pair of successive
stores to a given variable with no intervening loads from that variable.
In this case, the compiler is within its rights to omit the first store.
This is never a problem in single-threaded code, and in fact it is usually
the case that it is not a problem in correctly written concurrent code.
After all, if the two stores are executed in quick succession, there is
very little chance that some other thread could load the value from the
first store.

<p>
However, there are exceptions, for example as shown below:
<p>

<pre>
  1 void shut_it_down(void)
  2 {
  3     status = SHUTTING_DOWN; /* BUGGY!!! */
  4     start_shutdown();
  5     while (!other_task_ready) /* BUGGY!!! */
  6         continue;
  7     finish_shutdown();
  8     status = SHUT_DOWN; /* BUGGY!!! */
  9     do_something_else();
 10 }
 11
 12 void work_until_shut_down(void)
 13 {
 14     while (status != SHUTTING_DOWN) /* BUGGY!!! */
 15         do_more_work();
 16     other_task_ready = 1; /* BUGGY!!! */
 17 }
</pre>

<p>
The function <tt>shut_it_down()</tt> stores to the shared
variable <tt>status</tt> on lines&nbsp;3 and&nbsp;8.
Assuming that neither
<tt>start_shutdown()</tt> nor <tt>finish_shutdown()</tt> access <tt>status</tt>,
the compiler could reasonably remove the store to <tt>status</tt> on
line&nbsp;3.
Unfortunately, this would mean that <tt>work_until_shut_down()</tt> would
never exit its loop spanning
lines&nbsp;14 and&nbsp;15, and thus would never set
<tt>other_task_ready</tt>, which would in turn mean that <tt>shut_it_down()</tt>
would never exit its loop spanning lines&nbsp;5 and&nbsp;6, even if
the compiler chooses not to fuse the successive loads from
<tt>other_task_ready</tt> on line&nbsp;5.
Although <tt>WRITE_ONCE()</tt> prevents store fusing,
<tt>smp_store_release()</tt> (or stronger) is often preferable,
to ensure that other changes made before the store will be visible
to other threads that see the store.

<p>
And there are other problems with that code,
including code reordering.

<h4><a name="Code Reordering">Code reordering</a></h4>

<p>
Code reordering is a common compilation technique used to
combine common subexpressions, reduce register pressure, and
improve utilization of the many functional units available on
modern superscalar microprocessors.
It is also another reason why the code above
is buggy.
For example, suppose that the <tt>do_more_work()</tt> function on
line&nbsp;15 does not access <tt>other_task_ready</tt>.
Then the compiler would be within its rights to move the assignment
to <tt>other_task_ready</tt> on
line&nbsp;16 to precede line&nbsp;14, which might
be a great disappointment for anyone hoping that the last call to
<tt>do_more_work()</tt> on line&nbsp;15 happens before the call to
<tt>finish_shutdown()</tt> on line&nbsp;7.

<p>
It might seem futile to prevent the compiler from changing the order of
accesses in cases where the underlying hardware is free to reorder them.
For example, even on a single-CPU machine,
what would happen if the hardware reorders
two accesses and then an interrupt occurs right in the middle?
What values would the interrupt handler see?

<p>
As it turns out, this isn't a problem.
Modern machines have "exact exceptions" and
"exact interrupts", meaning that any interrupt or exception will
appear to have happened at a specific place in the instruction
stream.
Consequently, the handler will see the effect of all prior
instructions, but won't see the effect of any subsequent instructions.
<tt>READ_ONCE()</tt>, <tt>WRITE_ONCE()</tt>, and <tt>barrier()</tt>
can therefore be used to
control communication between interrupted code and interrupt handlers,
independent of any reordering carried out by the underlying hardware.
That said, should you write user-space code, the various standards
committees would prefer that you use atomics or variables of
type <tt>sig_atomic_t</tt> instead of <tt>READ_ONCE()</tt> and
<tt>WRITE_ONCE()</tt>.

<p>
However, when interacting with some other CPU, stronger primitives
are required, such as <tt>smp_load_acquire()</tt> and
<tt>smp_store_release()</tt>.

<h4><a name="Invented Loads">Invented loads</a></h4>

<p>
Invented loads are illustrated by the code below,
in which the compiler has optimized away a temporary variable
from the code shown in the load-tearing example above.
<p>



<pre>
  1 /* Optimized code */
  2 if (global_ptr != NULL &amp;&amp;
  3     global_ptr &lt; high_address)
  4         do_low(global_ptr);
</pre>
<p>
<div class="tlr"><a name="Quick Quiz 4"><b>Quick quiz 4</b>:</a>
	But line&nbsp;2 
	specifically checks for <tt>NULL</tt>.
	So how can <tt>do_low()</tt> possibly be invoked with a
	<tt>NULL</tt> pointer?
<br><a href="#qq4answer">Answer</a>
</div>

This optimization causes <tt>global_ptr</tt> to be loaded three times,
which could cause <tt>do_low()</tt> to be invoked with a <tt>NULL</tt>
pointer.


<p>
Invented loads can also be a performance hazard.
These hazards can occur when a load of variable in a "hot"
cacheline is hoisted out of an <tt>if</tt> statement.
These hoisting optimizations are not uncommon, and can cause significant
increases in cache misses, and thus significant degradation of
both performance and scalability.

<p>
Avoid invented loads by using <tt>READ_ONCE()</tt>.

<h4><a name="Invented Stores">Invented stores</a></h4>

<p>
Invented stores can occur in a number of situations.
For example, a compiler emitting code for <tt>work_until_shut_down()</tt> in
the store-fusing example above
might notice that <tt>other_task_ready</tt> is stored to on line&nbsp;16
and is not accessed by <tt>do_more_work()</tt>.
If <tt>do_more_work()</tt> was a complex inline function, it might be
necessary to do a register spill, in which case one attractive
place to use for temporary storage is <tt>other_task_ready</tt>.
After all, there are no accesses to it, so what is the harm?

<p>
Of course, a non-zero store to this variable at just the wrong time
would result in the <tt>while</tt> loop on
line&nbsp;5 terminating
prematurely, again allowing <tt>finish_shutdown()</tt> to run
concurrently with <tt>do_more_work()</tt>.
Given that the entire point of this <tt>while</tt> appears to be to
prevent such concurrency, this is not a good thing.

<p>
Using a stored-to variable as a temporary might seem outlandish,
and we are not aware of any compilers that actually invent stores,
but invented stores really are permitted by the standard.
Nevertheless, readers might be justified in wanting a less
outlandish example, which is duly provided below:

<pre>
  1 if (condition)
  2     a = 1; /* BUGGY!!! */
  3 else
  4     do_a_bunch_of_stuff();
</pre>
<p>
A compiler emitting code for
this example
might know that the value of <tt>a</tt> is initially zero,
which might tempt the compiler to optimize away one branch
by transforming this code to something like:
<p>
<pre>
  1 /* Optimized code */
  2 a = 1;
  3 if (!condition) {
  4     a = 0;
  5     do_a_bunch_of_stuff();
  6 }
</pre>

<div class="tlrw"><a name="Quick Quiz 5"><b>Quick quiz 5</b>:</a>
	Ouch!
	So can't the compiler invent a store to a normal variable pretty
	much any time it likes?
<br><a href="#qq5answer">Answer</a>
</div>

Here, line&nbsp;2 of the optimized version unconditionally stores
one to <tt>a</tt>, then resets the value back to zero on
line&nbsp;4 if <tt>condition</tt> was not set.
This transforms the if-then-else into an if-then, saving one branch.


<p>
Pre-C11 compilers could invent stores to unrelated
variables that happened to be adjacent to written-to
variables (see Section 4.2 of Hans Boehm's classic
<a href="https://dl.acm.org/citation.cfm?id=1065042">Threads cannot be implemented as a library</a>).
This variant of invented stores has been outlawed by the C11 prohibition
against compiler optimizations that create data races.

<div class="tlr"><a name="Quick Quiz 6"><b>Quick quiz 6</b>:</a>
	What exactly is a "data race"?
<br><a href="#qq6answer">Answer</a>
</div>

<p>
Unfortunately, there is an exception to this rule:
if there is a later plain store without some sort of ordering directive
beforehand, then a data race involving an invented store necessarily
implies that there was already a data race involving that later plain
store.
In this case, the compiler believes that it is not introducing a data
race, but rather expanding on an already-existing data race.
And the compiler is OK with this, even if your code is not.
For example:

<pre>
  1 struct foo {
  2     short a;
  3     char b;
  4     char c;
  5 };
  6
  7 void do_something(struct foo *fp)
  8 {
  9     fp-&gt;a = 0x1234;
 10     fp-&gt;b = 0x56;
 11     do_something_else();
 12     fp-&gt;c = 0x42;
 13 }
</pre>

<p>
If the definition of <tt>do_something_else()</tt> is visible to the
compiler, and if it contains no ordering directives like
<tt>barrier()</tt> or stronger, then the developer's write to
<tt>fp-&gt;c</tt> tells the compiler that there are no concurrent
reads or writes to that field, whether that was the developer's
intention or not.
The compiler would then be within its rights to do the following
optimization (assuming a big-endian system):

<pre>
  1 struct foo {
  2     short a;
  3     char b;
  4     char c;
  5 };
  6
  7 void do_something(struct foo *fp)
  8 {
  9     *(long *)fp = 0x123456ff;
 10     do_something_else();
 11     fp-&gt;c = 0x42;
 12 }
</pre>

<p>
The momentary appearance of <tt>0xff</tt> might come as quite a surprise
to any concurrent loads from <tt>fp-&gt;c</tt>.
Please note that this is not a theoretical transformation:  A later
store to a variable is taken as permission to clobber that variable.

In addition, older compilers can and do invent stores to unrelated variables,
even without the provocation of a later plain C-language store to such
an unrelated variable.
Use <tt>barrier()</tt> or <tt>WRITE_ONCE()</tt> to avoid all of these
types of invented stores.

<h4><a name="Store-to-Load Transformations">
Store-to-load transformations</a></h4>

<p>
Store-to-load transformations can occur when the compiler notices
that a plain C-language store might not actually change the value in memory.
For example, consider this code:
<p>
<pre>
  1 int r1, x, y;
  2
  3 void cpu1(void)
  4 {
  5     WRITE_ONCE(y, 1);
  6     smp_mb();
  7     WRITE_ONCE(x, 1);
  8 }
  9
 10 void cpu2(void)
 11 {
 12     r1 = READ_ONCE(x);
 13     if (r1 == 1)
 14         y = 0; // BUGGY!!!
 15 }
</pre>
<p>
Here CPU&nbsp;1 executes <tt>cpu1()</tt>, which uses <tt>WRITE_ONCE()</tt>
to store the value one to each of <tt>y</tt> and then <tt>x</tt>, separated
by a full memory barrier.
CPU&nbsp;2 executes <tt>cpu2()</tt>, which uses <tt>READ_ONCE()</tt> to
load <tt>x</tt>, and only if the result is 1, line&nbsp;14 does a plain
store of zero to <tt>y</tt>.
One would expect that if <tt>r1</tt> ends up with the value one, that
the final value of <tt>y</tt> must necessarily be zero.


<p>
Unfortunately, the compiler is within its rights to transform line&nbsp;14
into the load-compare-store sequence shown on lines&nbsp;14 and&nbsp;15
below: 
<p>
<pre>
  1 int r1, x, y;
  2
  3 void cpu1(void)
  4 {
  5     WRITE_ONCE(y, 1);
  6     smp_mb();
  7     WRITE_ONCE(x, 1);
  8 }
  9
 10 void cpu2(void)
 11 {
 12     r1 = READ_ONCE(x);
 13     if (r1 == 1)
 14         if (y != 0)
 15             y = 0;
 16 }
</pre>

<p>
Given this code, CPU&nbsp;2 may reorder the load of <tt>y</tt> on
line&nbsp;14 before the <tt>READ_ONCE</tt>.
If it does so, it might observe the original zero value of <tt>y</tt>
and therefore skip the store on line&nbsp;15.
Thus <tt>y</tt> could indeed end up containing one.

<p>
Why would the compiler do such a thing?
Please understand that to the best of our knowledge, this
transformation is strictly theoretical.
However, it does not take too much imagination to see how this might
occur given feedback-driven optimization.

So if you want your store to remain a store, for current and any future
compilers, use <tt>WRITE_ONCE()</tt> or stronger.

<h4><a name="Dead-Code Elimination">Dead-code elimination</a></h4>

<p>
Dead-code elimination can occur when the compiler notices that
the value from a load is never used, or when a variable is stored to,
but never loaded from.
This can of course eliminate an access to a shared variable, which
can in turn defeat a memory-ordering primitive, which could cause your
concurrent code to act in surprising ways.
Experience thus far indicates that relatively few such surprises will
be at all pleasant.
Elimination of store-only variables is especially dangerous in cases
where external code locates the variable via symbol tables; the
compiler is necessarily ignorant of such external-code accesses, and
might thus eliminate a variable that the external code relies on.

<p>
Reliable concurrent code clearly needs a way to cause the compiler to
preserve the number, order, and type of important accesses to shared
memory, which is why the Linux kernel provides
<tt>READ_ONCE()</tt>, <tt>WRITE_ONCE()</tt>, <tt>barrier()</tt>,
and a wide variety of memory barriers and atomic read-modify-write
operations.

<h4><a name="How Real Is All This?">How real is all this?</a></h4>

<p>
Some of the transformations called out in the preceding sections are
more likely to actually occur than are others.

<table class="OddEven" align="center"><tbody>
<tr>	<th></th>
	<th>Occurs in the Wild?</th>
</tr>
<tr>	<th align="left">Transformation</th>
	<th>(Properly Aligned, Machine-Word Sized)</th>
</tr>
<tr>	<td>Load Tearing</td>
	<td><a href="http://lkml.kernel.org/r/CAHk-=wj2t+GK+DGQ7Xy6U7zMf72e7Jkxn4_-kGyfH3WFEoH+YQ@mail.gmail.com">Yes</a></td>
</tr>
<tr>	<td>Store Tearing</td>
	<td>Yes, for constants (to be fixed?)</td>
</tr>
<tr>	<td>Load Fusing</td>
	<td>Yes</td>
</tr>
<tr>	<td>Store Fusing</td>
	<td>Yes</td>
</tr>
<tr>	<td>Code Reordering</td>
	<td>Yes</td>
</tr>
<tr>	<td>Invented Loads</td>
	<td>Yes</td>
</tr>
<tr>	<td>Invented Stores</td>
	<td>In some cases</td>
</tr>
<tr>	<td>Store-to-Load Transformations</td>
	<td>Unknown</td>
</tr>
<tr>	<td>Dead-Code Elimination</td>
	<td>Yes</td>
</tr>
</tbody></table>

<p>
So what is a Linux kernel developer to do?
There is a range of possibilities, each of which applies
<tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> in different situations:

<ul class="spacylist">
<li>	Never.
<li>	For any access to any shared variable for which there is a
	possibility of a data race, and for which it can be clearly
	shown that specific compiler optimizations could result in bugs.
<li>	For any access to a shared variable for which there is a
	possibility of a data race for at least one of those accesses.
<li>	For all accesses to all shared variables.
</ul>

<p>
There is without doubt some code somewhere in the Linux kernel corresponding
to each of these possibilities.
However, developers and maintainers opting for one of the first two
possibilities are taking on the responsibility of ensuring that new
releases of the compiler won't break their code.
For these developers and maintainers, a significant level of fear
of the big bad optimizing compiler is a very healthy thing, and
the rest of us should hope that they continue to maintain an
appropriate level of fear.

<div class="tlrw"><a name="Quick Quiz 7"><b>Quick quiz 7</b>:</a>
	This paper has covered all of the transformations that an
	optimizing compiler can carry out, right?
<br><a href="#qq7answer">Answer</a>

<p><a name="Quick Quiz 8"><b>Quick quiz 8</b>:</a>
	Given the risk, why not simply require that all accesses to
	shared variables use <tt>READ_ONCE()</tt> and
	<tt>WRITE_ONCE()</tt>?
<br><a href="#qq8answer">Answer</a>
</div>
<p>
On the other hand, developers and maintainers who instead opt for one of
the last two possibilities need not fear the big bad optimizing compiler,
or at least they need not fear it quite so much.
However, they could benefit from a tool that determines when
<tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> (or stronger) are needed
to defend not just against present-day optimizing compilers, but also
the bigger and badder optimizing compilers that the future will bring.
The next article in this series describes a recent change to
the Linux kernel memory model that does just that.

</p><h4>Acknowledgments</h4>

<p>We owe thanks to a surprisingly large number of compiler writers and
members of the C and C++ standards committees who introduced us to some
of the things a big bad optimizing compiler can do,
and to Junchang Wang, SeongJae Park,
and Slavomir Kaslev for their help making an earlier draft
of this material human-readable.
We are also grateful to Mark Figley and Kara Todd for their support of
this effort.


<h4><a name="Answers to Quick Quizzes">
Answers to quick quizzes</a></h4>

<a name="qq1answer"></a>
<p><b>Quick quiz 1</b>:
	But we shouldn't be afraid at all for things like
	on-stack or per-CPU variables, right?


</p><p><b>Answer</b>:
	Although on-stack and per-CPU variables are often guaranteed
	to be untouched by other CPUs and tasks, the kernel really
	does allow them to be concurrently accessed in many cases.
	You do have to go out of your way to make this happen,
	say by explicitly passing the address of such a variable
	to another thread, but it's certainly not impossible.

	<p>
	For example, the <a
	href="https://elixir.bootlin.com/linux/latest/source/include/linux/rcupdate_wait.h#L24"><tt>_wait_rcu_gp()</tt></a>
	macro uses an
	on-stack <tt>__rs_array[]</tt> array of <tt>rcu_synchronize</tt>
	structures that, in turn, contain <tt>rcu_head</tt>
	and <tt>completion</tt> structures.
	The address of the <tt>rcu_head</tt> structure is passed
	to <tt>call_rcu()</tt>, which results in concurrent
	accesses to this structure, and eventually also to the
	<tt>completion</tt> structure.

	<p>
	Similar access patterns may be found for per-CPU variables.


</p><p><a href="#Quick%20Quiz%201"><b>Back to quick quiz 1</b>.</a>

<a name="qq2answer"></a>
<p><b>Quick quiz 2</b>:
	But there are lots of plain loads from shared variables in the
	Linux kernel.
	These cannot possibly all be buggy, can they?


</p><p><b>Answer</b>:
	This turns out to be a matter of the context in which these plain
	loads execute and just how vigilant the developers and maintainers
	wish to be.

	<p>
	Starting with context, if a given variable is only ever accessed
	under the protection of a given exclusive lock or mutex, then use
	of plain loads (and stores, for that matter) is perfectly safe.

	<p>
	Less restrictive contexts also suffice.
	If stores to a given variable can never execute concurrently
	with any other accesses to that variable, then use of plain
	loads and stores is again perfectly safe.
	For example, if all loads from a given variable are under the
	protection of a reader-writer lock or mutex, and if all stores
	to that same variable are under the write-side protection of
	that same reader-writer lock or mutex, use of plain loads and
	stores is perfectly safe.
	Alternatively, if all stores to a given variable are carried out
	by a given kernel thread, and that same variable is only ever loaded
	by subsequently spawned child threads, plain loads and stores
	are yet again perfectly safe.
	Similarly, if all stores to a given structure
	happen before it is made visible to readers via
	<tt>rcu_assign_pointer()</tt>, and the readers, having gained
	access via <tt>rcu_dereference()</tt>, only ever load from that
	structure, plain loads and stores are once more perfectly safe.
	There are numerous additional variations on this theme.

	<p>
	But there is no shortage of plain loads in the kernel that
	really can execute concurrently with stores to that same variable,
	which brings us to vigilance.
	For example, if the variable only ever transitions from zero to
	one, no matter how the compiler
	<a href="http://lkml.kernel.org/r/20190606061438.nyzaeppdbqjt3jbp@gondor.apana.org.au">dices and slices</a>
	the load, the result will be either a zero or a one.
	Give or take the possibility of
	<a href="#Invented Loads">invented loads</a>,
	which could get the effect of both a zero and a one being loaded,
	though if the value loaded is only used once, one would hope that
	this confusing possibility would be avoided.

	<p>
	In other words, when using plain loads from shared variables, it
	is the developers' and maintainers' responsibility to either
	prevent concurrent stores to that same variable on the one hand
	or to ensure that the compiler cannot optimize their algorithms
	out of existence on the other.

	<p>
	So are the Linux kernel's plain loads from shared variables buggy?
	If the relevant developers and maintainers are either carefully
	controlling the contexts from which those variables are accessed
	on the one hand or vigilantly considering what optimizing
	compilers can do to their code on the other, perhaps not!


</p><p><a href="#Quick%20Quiz%202"><b>Back to quick quiz 2</b>.</a>

<a name="qq3answer"></a>
<p><b>Quick quiz 3</b>:
	Why does it matter whether <tt>do_something()</tt> and
	<tt>do_something_else()</tt> 
	are inline functions?


</p><p><b>Answer</b>:
	Because <tt>gp</tt> is not a static variable, if either
	<tt>do_something()</tt> or <tt>do_something_else()</tt> were separately
	compiled, the compiler would have to assume that either or both
	of these two functions might change the value of <tt>gp</tt>.
	This possibility would force the compiler to reload <tt>gp</tt>
	on line&nbsp;15, thus avoiding the <tt>NULL</tt>-pointer dereference.

	<p>
	In the absence of
	<a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">link-time</a>
	<a href="https://gcc.gnu.org/wiki/LinkTimeOptimization">optimizations</a>
	<a href="https://llvm.org/docs/LinkTimeOptimization.html">(LTO)</a>,
	that is.
	As optimizing compilers become more aggressive, developers and
	maintainers must become aggressive about disabling destructive
	optimizations, whether that be via command-line arguments to the
	compiler or via source-code decorations such as <tt>barrier()</tt>,
	<tt>READ_ONCE()</tt>, and <tt>WRITE_ONCE()</tt>.


</p><p><a href="#Quick%20Quiz%203"><b>Back to quick quiz 3</b>.</a>

<a name="qq4answer"></a>
<p><b>Quick quiz 4</b>:
	But line&nbsp;2 
	specifically checks for <tt>NULL</tt>.
	So how can <tt>do_low()</tt> possibly be invoked with a
	<tt>NULL</tt> pointer?


</p><p><b>Answer</b>:
	Imagine the following sequence of events:

	<ol>
	<li>	Line&nbsp;2 loads a non-<tt>NULL</tt> pointer from
		<tt>global_ptr</tt>.
	<li>	Some other CPU stores <tt>NULL</tt> to <tt>global_ptr</tt>.
	<li>	Line&nbsp;3 loads the newly stored <tt>NULL</tt> from
		<tt>global_ptr</tt>, and this compares less than
		<tt>high_address</tt>.
	<li>	Surprise!  There is now a call to <tt>do_low()</tt>
		with a <tt>NULL</tt> pointer.
	</ol>


</p><p><a href="#Quick%20Quiz%204"><b>Back to quick quiz 4</b>.</a>

<a name="qq5answer"></a>
<p><b>Quick quiz 5</b>:
	Ouch!
	So can't the compiler invent a store to a normal variable pretty
	much any time it likes?


</p><p><b>Answer</b>:
	Thankfully, the answer is no.
	This is because the compiler is forbidden from introducing data races.
	The case of inventing a store just before a normal store is
	quite special:  It is not possible for some other entity,
	be it CPU, thread, signal handler, or interrupt handler, to be
	able to see the invented store unless the code already has
	a data race, even without the invented store.
	And if the code already has a data race, it already invokes
	the dreaded specter of undefined behavior, which allows the
	compiler to generate pretty much whatever code it wants,
	regardless of the wishes of the developer.

	<p>
	But if the original store is volatile, as in <tt>WRITE_ONCE()</tt>,
	for all the compiler knows, there might be a side effect
	associated with the store that could signal some other thread,
	allowing data-race-free access to the variable.
	By inventing the store, the compiler might be introducing a
	data race, which it is not permitted to do.
	And this is one reason why <a
	href="https://github.com/torvalds/linux/blob/master/Documentation/memory-barriers.txt"><tt>memory-barriers.txt</tt></a>
	requires
	<tt>WRITE_ONCE()</tt> for stores that are to be ordered by
	control dependencies.
	Another reason may be gleaned from the
	<a href="#Store-to-Load Transformations">Store-to-Load Transformations</a>
	section.

	<p>
	In the case of <tt>volatile</tt> and atomic variables, the compiler
	is specifically forbidden from inventing writes.


</p><p><a href="#Quick%20Quiz%205"><b>Back to quick quiz 5</b>.</a>

<a name="qq6answer"></a>
<p><b>Quick quiz 6</b>:
	What exactly is a "data race&rdquo;?


</p><p><b>Answer</b>:
	A <i>data race</i> occurs when there are multiple concurrent
	accesses to a given variable, at least one of which is a
	plain C-language access and at least one of which is a store.


</p><p><a href="#Quick%20Quiz%206"><b>Back to quick quiz 6</b>.</a>

<a name="qq7answer"></a>
<p><b>Quick quiz 7</b>:
	This paper has covered all of the transformations that an
	optimizing compiler can carry out, right?


</p><p><b>Answer</b>:
	Wrong.

	<p>
	There are a great many more, which should not be a surprise
	given the large number of situations where the C standard
	specifies undefined behavior, each of which potentially
	points the way to interesting compiler optimizations.
	There are some efforts under way to rein in compiler optimizations
	to at least some extent (for example,
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1797r0.html">here</a>,
	<a
	href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2369.pdf">here
	[PDF]</a>,
	and
	<a
	href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1756r0.pdf">here
	[PDF]</a>),
	but compiler developers and standards-committee members are
	not necessarily as supportive of such efforts as might be
	hoped by maintainers and developers working with concurrent code.


</p><p><a href="#Quick%20Quiz%207"><b>Back to quick quiz 7</b>.</a>

<a name="qq8answer"></a>
<p><b>Quick quiz 8</b>:
	Given the risk, why not simply require that all accesses to
	shared variables use <tt>READ_ONCE()</tt> and
	<tt>WRITE_ONCE()</tt>?


</p><p><b>Answer</b>:
	One can certainly argue that they should be used more
	heavily than they currently are, but it is not all that
	hard to get too much of a good thing.
	For example, as mentioned in the answer to an earlier
	quick quiz, any number of in-kernel mechanisms, perhaps
	most notably locking, can provide mutual exclusion so
	that <tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> are
	not needed.

	<p>
	In addition, although <tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt>
	are low cost, they are not free due to the fact that they
	constrain compiler optimizations.
	For example, the compiler is required to emit the accesses
	for a pair of consecutive <tt>READ_ONCE()</tt> invocations
	in order, and it might well be just fine (and perhaps also
	cheaper) for those to invocations to be reordered.
	Some fast paths might therefore need plain C-language
	accesses, though one would hope that the developers and
	maintainers would see fit to take pity on people reading
	their code by providing appropriate comments.

	<p>
	And there are guarantees that the Linux kernel relies on that
	are provided by usage restrictions rather than by compiler
	directives.
	Examples include address and data dependencies, for which
	the usage restrictions are documented in
	<a href="https://github.com/torvalds/linux/blob/master/Documentation/RCU/rcu_dereference.txt">rcu_dereference.txt</a>
	as well as control dependencies, for which the usage restrictions
	are documented in the <tt>CONTROL DEPENDENCIES</tt> section of
	<a href="https://github.com/torvalds/linux/blob/master/Documentation/memory-barriers.txt">memory-barriers.txt</a>.

	<p>
	However, we should continue to expect increasingly aggressive
	compiler optimizations over time.
	This will likely increase the development and maintenance burden
	incurred by those making use of plain C-language loads and stores
	to shared variables in cases where data races exist.
	This prospect might help explain why the use of things like
	<tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> has been
	increasing steadily within the Linux kernel.


</p><p><a href="#Quick%20Quiz%208"><b>Back to quick quiz 8</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#ACCESS_ONCE">ACCESS_ONCE()</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/793253/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor793773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 3:10 UTC (Tue)
                               by <b>ariagolliver</b> (subscriber, #85520)
                              [<a href="/Articles/793773/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Spent a week recently re-implementing __builtin_add_overflow (et al) on Windows to work around the compiler eliding someone's if checks. It's... complicated to get right. I found two satisfactory solutions:<br>
- just use assembly (really easy on AMD64)<br>
- cast to uint64_t, do the operation, and cast back. This only triggers implementation defined behavior, not undefined behavior. So it's easy to write a test to ensure a compiler upgrade doesn't break things silently in the future.<br>
<p>
Creating a thorough unit test suite and running w/ ubsan is great for catching any subtleties (like surprising char conversion behaviors)<br>
<p>
Everyone I talked to assumed they understood the implications of signed integer overflow being undefined behavior, but by the end I realized no one really did (and I'm certain I don't)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 6:41 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793780/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This C++ (not C, sadly) working paper might be of interest: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r3.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793803"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 8:42 UTC (Tue)
                               by <b>Lekensteyn</b> (guest, #99903)
                              [<a href="/Articles/793803/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your linked paper also points out that there is interest from C as well:<br>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r3.html#WG14">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793803/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793805"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 9:42 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793805/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here is hoping!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793805/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor793814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 14:01 UTC (Tue)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/793814/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
However, note that it keeps the status quo in one major aspect:<br>
   "If a signed operation would naturally produce a value that is not within the range of the result type, the behavior is undefined. The author had hoped to make this well-defined as wrapping (the operations produce the same value bits as for the corresponding unsigned type), but WG21 had strong resistance against this."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 14:19 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793816/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True enough!  (And I did miss this in my initial excitement, so thank you for pointing it out.)<br>
<p>
However, there is at least the "is_modulo" type trait, which allows an implementation to indicate that it will wrap on overflow.<br>
<p>
Other than that, I guess you have to use atomics to make signed overflow defined.  :-/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor793859"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 16:25 UTC (Tue)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/793859/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me the failure of the C committee is that they came with arbitrary rules (unsigned wrap,signed do not wrap) instead of allowing the user to specify the behavior they want: i.e. allows<br>
signed wrapping long x;<br>
unsigned nonwrapping long x;<br>
<p>
the same for aliasing rules, store rules, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793859/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 16:48 UTC (Tue)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/793862/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      The reason that C makes integer overflow undefined was for loop optimization, they wanted to make it possible for loops to be as fast as those in Fortran.
<p>
Consider</p>
<pre>
void add_vector(double* c, const double* a, const double* b, int size) {
  int i;
  for (i = 0; i &lt; size; i++) {
     c[i] = a[i] + b[i];
  }
}
</pre>
<p>
They wanted the compiler to be able to assume that a+size, b+size, c+size (which are really p+size*sizeof(double)) do not overflow, which was an issue on small address space machines (I'm old, and started out on PDP-11 machines which were 16 bit, and even resorted to programming with overlays to make things fit).  Part of the difficulty is that C passes arrays as pointers to the first element, and the compiler otherwise doesn't know whether c, a, or b is at the very end of the address space so a two's-complement wraparound requirement results in many special cases if we attempt to vectorize.  At least, that was the thinking back when we got into this mess.  So the "undefined" assumption means that a loop optimizer is allowed to assume that overflow does not happen.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/793862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 19:27 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/793877/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That argues for making overflow an undefined behaviour on pointers. Not so much on integers. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 6:47 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793924/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There was a lot more variety in systems back in the day, including some in which signed integer overflow did interesting things.  So from the viewpoint of someone in 1990, requiring wrap on signed integer overflow would have required substantial clairvoyance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 7:25 UTC (Wed)
                               by <b>dunlapg</b> (guest, #57764)
                              [<a href="/Articles/793929/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p><blockquote>There was a lot more variety in systems back in the day, including some in which signed integer overflow did interesting things.</blockquote>
<p>But saying, "We'll do an add instruction, but we can't really guarantee what the processor will do" is a completely different thing than saying "Since we don't make any promises about what add does in this circumstance, we'll do something surprising and dangerous which corrupts data and allows people to exploit your system."
<p>The GPL literally says that it makes no warranties about fitness for a particular purpose; but that doesn't give software authors the right to make software that behaves however they want.  Imagine if the response to all bug reports was, "Our license literally says that we make no guarantees.  This behavior is more convenient for us, so just put up with it."  It's a preposterous position to take.
      
          <div class="CommentReplyButton">
            <form action="/Articles/793929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 14:31 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793955/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For a given computer system, yes, the results of an add instruction should be defined.  However, even hardware has the equivalent of undefined behavior, especially in supervisor mode.<br>
<p>
But the standard needs to say what will happen in on all systems, including systems that have not yet been defined.  Me, I join epa in preferring implementation-specified behavior to undefined behavior in this case, but either way, portable software would need to avoid signed-integer overflow.  So one can argue that for a lot of software, there isn't much practical difference between implementation-specified behavior and undefined behavior.<br>
<p>
But there is a lot of software that isn't intended to be universally portable!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 14:46 UTC (Wed)
                               by <b>dunlapg</b> (guest, #57764)
                              [<a href="/Articles/793956/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p><blockquote>For a given computer system, yes, the results of an add instruction should be defined.</blockquote>
<p>Not sure what it is that you're replying to.  I never said anything about the results of an add instruction being defined; I'm quibbling with the range of actions that compiler authors seem to think "undefined" allows them to do. 
<p>"Since we don't know what hardware will do on signed integer overflow, we can't promise signed integer overflow will work in any particular way" is reasonable.  "Since we don't promise signed integer overflow works in any particular way, we are free to make signed integer overflow behave in completely pathological ways" is not.
      
          <div class="CommentReplyButton">
            <form action="/Articles/793956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 1:54 UTC (Thu)
                               by <b>brooksmoses</b> (guest, #88422)
                              [<a href="/Articles/794031/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From the point of view of a compiler implementer, here's the fundamental problem with that: The underlying logic here is that the compiler can deduce that this signed integer operation will not overflow (because the C program would be ill-formed if it did) and can use that deduction to make optimization choices, but the compiler is not anywhere near smart enough to distinguish between the times that the result is benign and the times when it's completely pathological.  (I would doubt that humans are that smart either, in the general case, if given the same information the compiler is given.)<br>
<p>
You could say that you would prefer that the compiler _never_ make optimization choices based on a deduction of "undefined behavior means that this can never happen", but it turns out that this deduction has been useful in quite a lot of ways (only one of which is making small loops fast) and people in practice turn out to object strenuously to significant performance regressions from their compiler.<br>
<p>
Beyond this, a problem is that compiler optimization engines generally don't have an idea of "I know this information only for purposes of this optimization but not that one", and defining this would require a quite involved "tainted" model to know what information is allowed when.  Without that knowledge, the compiler can't distinguish between logical statements that it learned from "this is required for the program to be well-formed" and "this has to be true for the program to be on this code path" or other entirely solid things.<br>
<p>
The pathological cases are almost always the result of entirely-reasonable small pieces of logic combining to create something that wasn't expected by either the compiler author or the code author, not something that was intentionally designed in, and determining a small piece of logic to eliminate to prevent the pathological behavior without preventing useful behavior is quite difficult, if not impossible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2019 13:31 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/794221/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>You could say that you would prefer that the compiler _never_ make optimization choices based on a deduction of "undefined behavior means that this can never happen", but it turns out that this deduction has been useful in quite a lot of ways (only one of which is making small loops fast) and people in practice turn out to object strenuously to significant performance regressions from their compiler.</blockquote>

You are insinuating that not performing such "optimizations" produces significant performance regressions.  Funnily, for all their talk about the performance advantages of such "optimizations", the advocates of "optimizations" hardly ever produce numbers (and the one time I have seen numbers, they were from an unnamed source for another compiler).  One would expect that, if there were significant performance benefits from "optimizations", their advocates would parade them up and down.

<p>If there is no significant performance benefit from "optimizations", there is also no need to keep any "knowledge" around that is derived from the assumption that undefined behaviour does not occur.

<p>In any case, the better approach would be to give optimization hints to programmers.  That requires changes in just a few places instead of "sanitizing" the whole program all the time, and the consequences of not doing it are far less severe.  E.g., if the use of wraparound int for a local variable would lead to sign-extension operations in hot code, the compiler could suggest to change that local variable to, say, (wraparound) long.


      
          <div class="CommentReplyButton">
            <form action="/Articles/794221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor794063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 9:01 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/794063/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Since we don't know what hardware will do on signed integer overflow</font><br>
<p>
You're writing C for a C abstract machine. That machine has undefined behavior for signed integer overflow. Undefined behavior in C means "all bets are off". If this is not what you want, don't use C, convince compilers to provide a "sensible C" dialect, or change C via the standards committee.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 17:48 UTC (Thu)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/794128/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the particular case of signed integer overflow, of course, compilers already provide two "sensible C" dialects (gcc calls them -fwrapv and -ftrapv).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor794302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2019 12:06 UTC (Mon)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/794302/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The C standard uses an abstract machine to define the semantics of the language. But real code is certainly not written to run on "abstract machines" and the C standard also contains the nice statement that "a conforming program is one acceptable to a conforming implementation". That's not the same as a strictly conformimg program (another term from the C standard) which would restrict itself to the functionality defined in this document.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor793952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 13:52 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/793952/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right, so for integers the behaviour should be implementation-defined (or should have been back in 1990).  Not undefined, as in "anything at all, including destroying the whole universe, so the compiler is allowed to reason backwards from the fact that the universe continues to infer that the overflow case can never be reached".<br>
<p>
For pointer overflow there are performance speedups from allowing the semantics to be undefined, as the loop example shows.  That doesn't apply to integer overflow, as far as I can tell.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor794220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2019 13:07 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/794220/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>So from the viewpoint of someone in 1990, requiring wrap on signed integer overflow would have required substantial clairvoyance.
</blockquote>

Not at all.  No significant new architecture with something other than twos-complement representation for signed integers was introduced after 1970.  They sure saw during C standardization that the future was twos-complement , but they wanted to support the (then) present which included descendants of architectures from the 1960s.

<p>That being said, even on these architectures implementing twos-complement would not be that expensive.  They already support unsigned integers with wraparound (or C would not have standardized that).  For +, -, and *, the same operations can be used for twos-complement arithmetics; inequality comparisons and possibly division would become a little more expensive, though.
      
          <div class="CommentReplyButton">
            <form action="/Articles/794220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2019 11:11 UTC (Sun)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/794253/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was using ones-complement systems in the 1980s, and there were ones-/two-complement debates at that time, but fair enough on your point about the introduction dates.<br>
<p>
If I remember correctly, the usual way to do unsigned arithmetic on ones-complement-only systems was to force the sign bit clear after each addition and subtraction operation.  And the ones-complement CDC 6600 systems used floating point to do integer multiplication and division, which required tricks normally used in multiple-precision arithmetic to get a 60-bit unsigned result out of floating-point operations with 48-bit mantissas.  One reason that this worked was that there was a separate instruction for normalizing floating-point numbers, as well as another instruction that produced the lower 48 bits of the 96-bit product of two 48-bit mantissas.<br>
<p>
Fun times!  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor793886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 21:07 UTC (Tue)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/793886/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At most it makes sense to be able to tell the compiler, I rely on two's complement wrapping, don't treat it as undefined.<br>
<p>
It would be impossible to implement any well-defined notion of non-wrapping (eg unsigned arithmetic that overflows gets absorbed at 2^n-1) efficiently anyway. No sense in pretending otherwise, if you want that, implement a custom C++ class.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Saturating arithmetic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 3:21 UTC (Wed)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/793915/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Impossible? Nonsense!  It has existed for decades: saturating addition and subtraction, which are particularly useful when processing vectors of audio samples and video pixels ("multimedia").  x86* has instructions for saturating addition and subtraction of both signed and unsigned, 8-bit and 16-bit vectors: P{ADD,SUB}{S,US}{B,W}; as well as saturated PACKing of wider values into narrower width.  Similar instructions exist in the NEON set for ARM cpus.  The x86* instructions are integrated into gcc via the *mmintrin.h header files.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor793919"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Saturating arithmetic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 3:52 UTC (Wed)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/793919/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For unsigned saturation at full register width, all that's needed is Carry.  On 32-bit x86:<br>
    ADDL EAX, EDX   /* EAX += EDX */<br>
    SBCL  ECX, ECX  /* Each bit of ECX gets the Carry from above */<br>
    ORL    EAX, ECX  /* EAX |= ECX;  Saturate */<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793919/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor794719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 18:03 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/794719/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Spent a week recently re-implementing __builtin_add_overflow (et al) on Windows to work around the compiler eliding someone's if checks. It's... complicated to get right. I found two satisfactory solutions:</font><br>
<p>
Indeed. I did the same for postgres, and it's quite hard to get it right *and* performant. Especially when you want to support 64bit integers and you do not want to rely on casting to unsigned. While I think I got it right on a high-level, I'm far from certain that I avoided all subtly possible breakages. IIRC we have three different implementations of e.g. signed 64bit integer multiplication (__builtin_mul_overflow, cast to 128 bit integers, pre-multiplication check for all dangers). I really hate having to do that, when it's imo the languages job to provide something reasonable.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2019 9:36 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/794748/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you mean the compiler optimised away the tests for overflow, on the basis that overflow couldn't happen? Crazy! :-)<br>
<p>
Surely a simple way for the standards committee would simply be to define a bunch of pragmas that said "this implementation-defined feature is required", and say that the compiler must terminate with a fatal error if it's not supported.<br>
<p>
Okay, that then means that the poor programmer needs to add a bunch of requirements at the start of his program, but it also means that if he attempts to port to a different architecture that doesn't support his assumptions, the compiler will refuse to compile. Much better than everything appearing to work and then falling over in a heap in production.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor803161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2019 15:14 UTC (Fri)
                               by <b>plugwash</b> (subscriber, #29694)
                              [<a href="/Articles/803161/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just curious, why did you "not want to rely on casting to unsigned"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/803161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor793813"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 13:49 UTC (Tue)
                               by <b>vegard</b> (subscriber, #52330)
                              [<a href="/Articles/793813/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've always wondered this about proc/sysctl variables, which seem to rely heavily on a pattern of unprotected single ints, which may typically be modified by root by writing to a proc file and used without any kind of locking/synchronisation in the code which it parameterises.<br>
<p>
I guess it just doesn't pose much of problem since you need the combination of "compiler does something unexpected" (which may not happen at all in this case) AND "root writes this value at exactly the wrong moment" (which also may not happen at all).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793813/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 14:26 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793817/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suppose that the other mitigating factor is that a natural response to strange output is to ask for it again?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793925"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 6:49 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793925/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Of course, entries that are commonly read by software might not be so tolerant of strange values.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793925/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor794054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 7:44 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/794054/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed sysctls and writable module parameters should be protected by locks or READ_ONCE.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor793821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 14:47 UTC (Tue)
                               by <b>fuhchee</b> (guest, #40059)
                              [<a href="/Articles/793821/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting article.  The context of kernel programming justifies the unstated background that apprx. all these situations noted here are problematic only because of concurrency, and because the dangerous bare use of shared data without explicit concurrency control mechanisms.  With linux's pursuit of performance, traditional locks for critical sections are sometimes eschewed, so one must wade deep into memory model minutiae.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 16:09 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793860/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True enough!<br>
<p>
But those of us eschewing traditional mechanisms must take care to eschew them only when really needed, attractive though dangerous living might be.  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 3:14 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/793917/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This raises a point that bothered me as I was reading the article:<br>
Who is the audience?<br>
<p>
Even kernel developers writing parallel code (I am one, I work on the Lustre parallel file system, which is concurrent all over the place, both within and across nodes) should almost never use most of the discussed primitives, nor make many of the discussed assumptions.  Don’t assume loads or stores are atomic (even in the sense of not torn) unless you are using an explicit mechanism to make them so (Compilers aside, it’s a kernel, it runs on multiple architectures.) or perhaps if you’re writing arch specific code, which is rare even for kernel developers.  In general, it’s a shortsighted assumption.<br>
<p>
To my reading, the article also implicitly suggests the use of various advanced concurrency mechanisms like READ/WRITE_ONCE.  These are powerful, but they are much harder to reason about than traditional locks with their heavyweight barriers, and the vast majority of the time, their use is not required for performant code.  (And of course complexity should only be introduced when necessary.)<br>
<p>
I guess this is all to say it seems like an article written for people who are doing work that is just shy of actually implementing concurrency control primitives.  And I hope there are very few of those people, since it’s A) very hard to get that sort of thing right, and B) usually irrelevant to performance.  In my day job, most of the times I’ve seen memory barriers explicitly invoked in new code have been mistakes or unnecessary cleverness in non-sensitive areas.<br>
<p>
Apologies for getting on my soap box, and thank you for another excellent article.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 7:20 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793928/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, if you carefully use primitives such as locking, then you do not need to worry about the issues discussed in this article.  However, computers are getting larger, which is forcing the Linux kernel to use more aggressive concurrency.  And so the issues discussed in this article are becoming increasingly important.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor793930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 7:34 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/793930/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When you're working out of the kernel, you suddenly don't have this collection of tools that were brought by kernel developers anymore, and you figure you have to start the "standard" way, using the pthread API. Then you see that your code is excessively slow, that you're using mutexes every now and then for almost nothing so you switch to good old __sync operations that are compatible between many generations of compilers. You still find them slow because most of the time you manipulate multiple independent variables that don't need barriers in between but you need groups of changes to be atomic respective to other groups. Then you start to play with barriers by hand and resort to the more modern __atomic stuff which drops compatibility with older compilers and/or some less common architectures. At this point you tend to navigate in a gray area where most of the performance sensitive stuff is done by hand using complex macros involving ifdefs and fallbacks for unsupported archs and compilers, where the less sensitive stuff is done using more portable, safer, but slower __sync stuff or spinlocks when there are multiple, and the rare slow operations can be dealt with using mutexes.<br>
<p>
So no, it's not irrelevant to performance nor does it only concern those who need to implement their own concurrency primitives. In fact it should be for any developer of concurrent code who notices that his code either gets 20% slower on single-thread performance by just using mutexes at the wrong place, or that the code doesn't scale at all due to excessive cache lines bouncing between cores caused by excess of atomic ops. And sadly there are many people concerned by this, who often discover this the first time from a user report of very bad performance in a corner case.<br>
<p>
Please also note that the points there are also valid with signals. And whoever plays with signals to perform various actions (state dump, config reload etc) should be really aware of this before manipulating half-written variables.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor793861"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 16:34 UTC (Tue)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/793861/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Excellent article, thanks for sharing this!

Actually we've come to the same questions quite a few times inside haproxy (which is purely userland) because once you start to try to reduce the cost of a lock, you quickly fall into that foggy area where you don't clobber the whole memory after each and every small operation and you have to count on the compiler not to do bad things on you after you managed to work around the most obvious cases. And I clearly remember a few times saying "oh, if it would do this it would break so much code that it wouldn't make sense"...  Probably some areas need to revisited.

Regarding the stores that become load+store, I'm pretty sure I've seen this a long time ago. I remember being surprised to discover a 32-bit read followed by a 32-bit write instead of just a 8-bit write. I don't remember the exact context but it was probably something around this :

<pre>
    union {
        unsigned int i;
        unsigned char c;
    } u;

    u.c = a;
    return u.i;
</pre>
This would result in something like this :
<pre>
    mov eax, [u]
    mov al, [a]
    mov [u], eax
    return eax
</pre>
In fact it would then be a partial load reordering since the load was expected at the end. But we could imagine architectures where some instructions are only available on full-sized registers and not smaller ones.

      
          <div class="CommentReplyButton">
            <form action="/Articles/793861/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 16:43 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Glad you liked it!<br>
<p>
And thank you for the example optimization from a simple store to a non-atomic read-modify-write.  That could get one's attention!  And ruin one's software's day!!!  ;-)<br>
<p>
There have been a number of systems lacking small accesses, including early DEC Alpha, CDC 6600, and probably quite a few others.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor793895"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Load/Store tearing in this day and age?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 22:11 UTC (Tue)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/793895/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>I don't understand how/why, in this day and age, that load tearing and storing still occur.  At least when loading/storing an <em>n</em>-bit value on an <em>n</em>-bit architecture.  Isn't that what the &quot;beauty&quot; of larger-bit architectures is for?</p>

<blockquote><font class="QuotedText">For example, the compiler could, in theory, compile the load from global_ptr on line 1 of the following code as a series of one-byte loads.</font></blockquote>

<p>70 years of electronic computers, 64-bit architectures are the norm now, and we're <em>still</em> putzing around one byte at a time? Ugh.</p>

<p>IMO loads and stores should be atomic at the assembly level (if not at the metal) for an <em>n</em>-bit value on an <em>n</em>-bit architecture.  Just my $0x02.</p>

<p>Thank you to all the contributors for this article. Very enlightening (if not depressing).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/793895/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793903"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Load/Store tearing in this day and age?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2019 22:58 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/793903/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In this day and age, we still use chips and CPU architectures that were designed in a previous day and age, because they're widely available and well supported and (most importantly) cheap. They might not support misaligned loads (because that's a lot of hardware complexity, which was an issue in olden times), and if the compiler isn't certain that a load will be aligned (e.g. it's reading a field from an __attribute__((packed)) struct, which are pretty common in Linux) it'll have to read individual bytes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793903/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Load/Store tearing in this day and age?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 6:58 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793926/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All good points!  Plus modern CPUs often have store-immediate instructions with restricted-size immediate values, which can tempt the compiler to emit a series of store-immediate instructions for a larger store.  As noted in the article, this is not a theoretical scenario.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor794037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Load/Store tearing in this day and age?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 4:21 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/794037/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is very, very common on x86 for a value to straddle cache lines, which the hardware necessarily splits. An atomic that straddles cache lines presents the memory hardware a messy and typically slow job -- if you cared, you would have aligned! -- possibly even involving a kernel trap on simpler hardware.<br>
<p>
On x86 they devote another few million transistors for each case to help avoid what would be a kernel trap. All the extra transistors strengthen Intel's (and, lately, AMD's and Samsung's) competitive position vs cheaper hardware. It's not free, because that enables a monopoly or oligopoly that may then extract rent or (worse) limit your choices.<br>
<p>
In the US, only the former is ever considered actionable harm, despite the law recognizing both.  It is artificially difficult to demonstrate the latter, where logically it should instead be assumed.<br>
<p>
So, exercising care with alignment affords you more choice in hardware that can run your code fast enough, and safely, which might also enable saving money, too, and also power and heat, because those millions of transistors burn power.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor793932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Load/Store tearing in this day and age?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 9:32 UTC (Wed)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/793932/">Link</a>] 
      </p>
      
      </div>
      </summary>
      &gt; IMO loads and stores should be atomic at the assembly level (if not at the metal) for an n-bit value on an n-bit architecture. Just my $0x02.
<p>
They typically *are* guaranteed to be atomic at the assembly level, but only if the pointer is properly aligned.
<p>
You can see this more easily if you use C11 atomics, which are more explicit about what guarantees they provide.  For example, this source code:

<pre>
	#include &lt;stdatomic.h&gt;
	int load(_Atomic int *ptr) {
		return atomic_load_explicit(ptr, memory_order_relaxed);
	}
</pre>
<p>
compiles to this assembly (GCC targeting x86-64):
<p>
<pre>
	load:
			mov     eax, DWORD PTR [rdi]
			ret
</pre>
<p>
All C11 atomic loads/stores are guaranteed to be, well, atomic, but GCC has decided to emit a plain mov instruction.  In fact this is valid, because x86 has an architectural guarantee that regular movs (64-bit and smaller) to and from aligned pointers are atomic.  (And GCC is allowed to assume that `ptr` is aligned, because using it is undefined behavior if not.)  Most common architectures work the same.
<p>
On the other hand, many uses of atomics want a stronger memory ordering, e.g. memory_order_acquire.  On x86, this *still* just generates a plain mov instruction, because x86 has very strong ordering guarantees for all accesses.  But on other architectures it tends to require additional synchronization or a different instruction.
      
          <div class="CommentReplyButton">
            <form action="/Articles/793932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor793969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 15:58 UTC (Wed)
                               by <b>ghorbanian</b> (guest, #129503)
                              [<a href="/Articles/793969/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"The compiler might reasonably unroll this loop sixteen times in order to reduce the per-invocation overhead of the backwards branch at the end of the loop."<br>
<p>
Why, specifically, 16 times?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor793989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 18:45 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/793989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It might also reasonably unroll the loop two, four, ten, or 20 times.  The compiler could consider loop overhead, cache footprint, branch taken/not-taken penalties, inter-iteration optimization opportunities, and so forth when deciding how many times to unroll the loop.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor793999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2019 20:14 UTC (Wed)
                               by <b>law@redhat.com</b> (guest, #31677)
                              [<a href="/Articles/793999/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sadly, most user space code should be looking at the C11/C++11 memory model where objects which are accessed concurrently are to be appropriately marked at the source level.  That marking in turn drives what the compiler is allowed to do with those memory references and should avoid the multitude of problems referenced by this article.<br>
<p>
Twiddling optimization flags, or worse yet, writing source that is specific to a set of transformations the compiler does or does not do today is a losing proposition.  Such techniques may work today, they may work tomorrow, but they're really a case of writing code to a particular compiler implementation and could well fail in the future as compilers continue to evolve and more aggressively optimize.<br>
<p>
The right thing, particularly for user space code, is to learn the C11/C++11 memory model and use those facilities.   Do this and you're light years ahead on making code that works today, tomorrow and into the future regardless of what the compiler developers do.<br>
<p>
I realize the kernel is special and kernel developers are going to do their own thing, but what they do should not be held up as an example of "the right way" in the general case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/793999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 4:31 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/794039/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This could be fine when developing new software that doesn't care much about deployed systems. But for existing software and for software having to run on servers this is not yet an option. C11 was introduced in gcc 4.7 which is fairly recent when it comes to the server world (RHEL6 ships 4.4 and is still not that rare in field).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 19:33 UTC (Thu)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/794136/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, I think RHEL6 is still the majority in my experience, but I don't think it's the majority of compile-environments.<br>
<p>
The point is still a concern, of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor794148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 21:19 UTC (Thu)
                               by <b>law@redhat.com</b> (guest, #31677)
                              [<a href="/Articles/794148/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Red Hat has made newer compilers available to its customers free of charge via the developer toolset (DTS) for several years now.   So if you want newer compilers on RHEL 6, that's trivially possible.   The current version is DTS 8 which includes gcc-8.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor794151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2019 21:38 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/794151/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
RHEL6 has newer versions of GCC via the Developer Toolset add-on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor794670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 10:53 UTC (Fri)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/794670/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;[...] the C11/C++11 memory model where objects which are accessed concurrently are to be appropriately marked at the source level.</font><br>
<p>
I'd like to point out that it's not sufficient to tag values subject to concurrent write, but rather all consumers of those values should be marked by use of explicitly atomic primitives. Such as those in stdatomic.h, which will presumably stay consistent[0] despite e.g. future ultra-LTO exposing damage previously hidden by an intermodule boundary. This is because the semantics of concurrently-written data are generally different from those of data in a single-threaded or "classic C" program where it isn't intended that changes to shared state are visible outside of the current thread or the reverse, so it's necessary to indicate non-classic usage to the reader at point of interaction and declaration both.<br>
<p>
<font class="QuotedText">&gt;The right thing, particularly for user space code, is to learn the C11/C++11 memory model and use those facilities.</font><br>
<p>
The C11 memory model can also be studied as first the "classic C" of single-threaded programs, where the compiler may yield an unrecognizably bizarre but correct result for reasons in the article; and by then laying over a set of diffs for "concurrently interacting C", which is just as the old but allows source to indicate that certain parts expect to publish or consume and should appear accordingly from out-of-thread[1]. Most importantly the latter allows execution of the former unmodified when it's known that concurrent interactions won't occur, such as between callsites of POSIX-style mutexes where synchronization is hidden behind a function call boundary, or indicated to a deeply LTO compiler by syscall or atomic primitive.<br>
<p>
This is in contrast to ideas about forcing correct concurrent interactions through manipulation of the compiler output (sans memory-clobbering asm volatile), which seem like a sediment of bubblegum fixes compared to C11 atomics, or to even the C99 idea of the standard language as semantics that constrain the compiler over a naïve 1:1-ish mapping between statement and machine code.<br>
<p>
[0] unimplementable ordering semantics aside; how come nobody smelled the cr^Wsufficiently smart compiler from a mile away? (and how come I used a born-defunct option in real code, thinking it'd one day do something besides introduce subtle breakage?)<br>
[1] e.g. in a shared memory segment<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor794720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 18:11 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/794720/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree. Although I still don't understand why the C11/C++11 memory model chose to provide barriers not tied to variables in such an oddly defined way.  IIRC - and it's been a while since I tried to parse the standard's language - you can't really use them to incrementally upgrade from compiler-specific barriers, without also converting all other memory to go through C11/C++11 atomics.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2019 19:15 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/796357/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There were some concerns about specific machines that have since proved groundless, so the atomic_thread_fence() wording has (quite) recently been upgraded.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor794599"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2019 14:13 UTC (Thu)
                               by <b>jerojasro</b> (guest, #98169)
                              [<a href="/Articles/794599/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
all of these caveats seem to me such a huge, and needless, burden on C programmers.<br>
<p>
I know, the first thing the article says is: "the C standard grants the compiler the right to make some assumptions that end up causing these weird/non-obvious things if you don't guard against them", but I must ask: why can't the compiler grow an optimization mode that does the right thing (and thus avoid all of the issues documented here) in the presence of global variables and concurrent execution? that situation (globals+concurrence) is so common, that solving it in the compiler would benefit most, if not all, C users, in both kernel and user space.<br>
<p>
are there any reasons for not fixing this issue (once) in the compiler, other than the amount of work involved (which I guess must be ... not trivial, of course), and this new optimization mode not being standards-compliant?<br>
<p>
(I'm not attempting to troll anybody; it just seems to me that what I propose is an obvious solution, and since it's not being used, I'd like to know what obvious thing I'm missing that prevents us from using it)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794599/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2019 18:09 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/794632/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I expect one of the main reasons is that it's extremely difficult to define "the right thing". Firstly because different people will have different ideas of what's right; and secondly because concurrency and memory models are inherently complex and subtle topics, so it's always difficult to reason about them precisely. See how modern C++ tries to specify it with terminology like "is sequenced before", "carries a dependency to", "inter-thread happens before", etc, all with precise meanings that are almost impossible for a normal human to remember. Java tried to specify a memory model from the start, but got it wrong, and it took a decade to understand the mistakes and fix them.<br>
<p>
Probably the other main issue is performance. Particularly with concurrency where CPUs often require explicit memory barriers if you want guaranteed ordering, and if the compiler added memory barriers around every memory access just in case you were using the same memory in another thread, it would be pretty slow. Even if it was only a tiny performance regression, many C programmers care a lot about performance (especially microbenchmark performance) and won't be happy with a new compiler that's measurably slower, and users won't be happy if their application runs slower after updating their kernel. They'd rather have a dangerous but fast compiler, and rely on the programmer being smart enough to avoid those dangerous cases.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor817096"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Example, read once may or may not be the &quot;right thing&quot;.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2020 5:45 UTC (Thu)
                               by <b>gmatht</b> (subscriber, #58961)
                              [<a href="/Articles/817096/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      We even have an example in the article of different code making incompatible assumptions. Here the code assumes the variable <code>need_to_stop</code> will be read many times.  <p/>

<pre><code>1 while (!need_to_stop) /* BUGGY!!! */
2     do_something_quickly();</code></pre><p/>

The following code is instead assuming that <code>global_ptr</code> won't change. This could be ensured by only reading <code>global_ptr</code> once. 

<pre><code>2 if (global_ptr != NULL &amp;&amp;
3     global_ptr &lt; high_address)
4         do_low(global_ptr);</code></pre><p/>

In general it might be hard to determine which of these two contradictory assumptions the code is making. 


      
          <div class="CommentReplyButton">
            <form action="/Articles/817096/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor817097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Example, read once may or may not be the &quot;right thing&quot;.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2020 8:30 UTC (Thu)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/817097/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't this the reason for the existence of the "volatile" keyword, and why need_to_stop should be annotated with it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor817248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Example, read once may or may not be the &quot;right thing&quot;.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2020 17:22 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/817248/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The "volatile" keyword is almost completely useless. It's good for reading memory mapped hardware and signal handlers. And not even signal handlers if you're using multiple threads.<br>
<p>
In any thread situation you want an atomic access. Which might be implemented using volatile, but requires more than that such as memory barrier operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor794625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2019 19:01 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/794625/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>The short answer is performance; each of the eight transforms in the article permits the generated code to be optimized into much, much faster code, as long as the original C code did what the programmer intended it to do.
<p>That statement ("as long as the original C code did what the programmer intended it to do") is the source of all the pain. The C standard specifies an abstract C machine that directly executes C code, and the job of a compiler is to translate C code into a machine code that has the same semantics as C running on the abstract C machine. However, most C programmers are ignorant of the abstract C machine (not all, but most, including me); instead, they either rely on "my compiler turns it into machine code that does what I want", or "the obvious translation to my preferred machine code does what I want". Each of these interpretations of "what my C means" leads to its own set of problems:
<ol>
<li>"My compiler turns it into machine code that does what I want" ignores compiler bugs, portability issues, optimizations that produce reasonable results for your test vectors but not inputs you're not testing etc. In other words, writing a compiler that complies with this level of expectation means being bug-for-bug compatible with all old versions; if that's what you want/need, why are you updating your compiler to begin with? Even new CPU support can break this level.
<li>"The obvious translation to my preferred machine code does what I want" is more insidious; the issue is that they're reading their C code as-if it's implemented as assembly macros that generate the machine code they want. The problem here is that C is not a macro assembler - it's a full blown portable programming language - and while their assumptions probably hold true for a specific compiler version and optimization settings on a single processor model, they fall over on other processor models and with other optimizations that are allowed by the C language.
</ol>
<p>In short, it's hard, because of C's legacy as "basically one step above a macro assembler for the PDP-11".
      
          <div class="CommentReplyButton">
            <form action="/Articles/794625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 15:08 UTC (Fri)
                               by <b>jerojasro</b> (guest, #98169)
                              [<a href="/Articles/794708/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
hmm, I was thinking that the compiler only had to look for "global variables" (things syntactically declared as global), and add barriers/avoid reordering/etc.<br>
<p>
but after reading both of your comments, I realized (hope I'm correct), that globals are *both*: things declared as global, *and also* anything allocated in the heap. And that last part is what makes automating all of these checks/guards such a performance hit, and worth bothering the programmer with handling manually the unsafe situations.<br>
<p>
Man I'm glad I just concatenate strings for a living.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794709"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 15:32 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/794709/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's a bit worse than that - things in C are global in the sense of "need concurrency-awareness baked-in" if they are syntactically global, or if there is ever a pointer to the thing. That last covers all heap allocations, and any stack allocations whose address you take with <tt>&amp;</tt>, and in turn means that you have to add barriers etc to all heap allocations plus some stack allocations.
<p>And, of course, this is only going to help code that does not execute correctly on the C machine, as it ignores the semantics of the C machine. We don't want to strengthen the semantic guarantees of the C machine, since that results in the output code running slower (it needs more barriers, as more of the "internal" effects are now externally visible). So it only actually helps developers who dont actually understand what they're telling the computer to do - while this may be a common state, it's not necessarily something to encourage.
      
          <div class="CommentReplyButton">
            <form action="/Articles/794709/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor794721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 18:18 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/794721/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  I know, the first thing the article says is: "the C standard grants the compiler the right to make some assumptions that end up causing these weird/non-obvious things if you don't guard against them", but I must ask: why can't the compiler grow an optimization mode that does the right thing (and thus avoid all of the issues documented here) in the presence of global variables and concurrent execution? that situation (globals+concurrence) is so common, that solving it in the compiler would benefit most, if not all, C users, in both kernel and user space.</font><br>
<p>
I'd say that C11/C++11 made a large step in that direction, by having a formalized memory model, and builtin atomics. Before that there really was no way to not rely on compiler implementation details to get correctly working (even though formally undefined) concurrent programs.<br>
<p>
It does require you however to actually use the relevant interfaces.<br>
<p>
I don't quite see how you'd incrementally get to a language that doesn't have any of these issues, without making it close to impossible to ever incrementally move applications towards that hypothetical version of C. I mean there's basically no language that allows to use shared memory and doesn't require escape hatches from its safety mechanisms to implement fast concurrent datastructures (e.g. rust needing to go to unsafe for core pieces). And the languages that get closes require enough of a different approach that it's hard to imagine C going towards it.<br>
<p>
That's not to say that C/C++ have sufficiently progressed towards allowing to at least opt into safety. The C11/C++11 memory model and the atomics APIs are a huge step, but it's happened at the very least 10 years too late (while some of the formalisms where developed somewhat more recently, there ought to at least have been some progress before then).  And there's plenty other issues where no proper ways are provided (e.g. signed integer overflow handling, mentioned in nearby comments).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2019 16:44 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/794854/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would say 30 years too late rather than just 10, but yes.  There was a surprisingly large amount of concurrent C code written during that 30 years prior to C11.  It is only natural for people to want to discount that code as "broken" so it can be ignored, but some of that code is rather important.  The problem is that we do not have a reasonable way to identify the problem areas, even for the small fraction of that code for which source code is publicly available.<br>
<p>
So there are great opportunities for innovations in the area of locating old concurrent C code in need of an upgrade!  :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor794674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 13:09 UTC (Fri)
                               by <b>topimiettinen</b> (guest, #133428)
                              [<a href="/Articles/794674/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article mentions that 'volatile' and atomic variables are exempt from the optimizations. If the variables are accessed concurrently, wouldn't it be better to use 'volatile' or atomic variables then instead of using these macros? If use of 'volatile' or atomic variables pessimizes the code too much, couldn't that be improved instead (also for the benefit of non-kernel code)? Maybe the effects of 'volatile' could be split to a number more fine grained GCC attributes which could be used in place of 'volatile', so the accesses obey desired rules?<br>
<p>
-Topi<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 17:18 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/794713/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that's related to the answer to Quick Quiz 8. Not all accesses to a shared variable require this protection, and the protection is not free. If the variable is declared as volatile or atomic then every access will be effectively READ_ONCE/WRITE_ONCE, which prevents a sufficiently clever programmer from only paying the performance cost of READ_ONCE/WRITE_ONCE when it is strictly necessary.<br>
<p>
E.g. for any shared data structure, there's probably some single-threaded initialisation code that sets it up before it's exposed to other threads. If the structure was declared with volatile/atomic fields, the compiler may add barriers in the initialisation code that the programmer knows are unnecessary. So the programmer might choose to explicitly use READ_ONCE/WRITE_ONCE, improving performance but increasing the risk of missing a case where it's actually required. Which way is "better" depends on how you weigh performance vs correctness.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor794717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2019 17:57 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/794717/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  E.g. for any shared data structure, there's probably some single-threaded initialisation code that sets it up before it's exposed to other threads. If the structure was declared with volatile/atomic fields, the compiler may add barriers in the initialisation code that the programmer knows are unnecessary. So the programmer might choose to explicitly use READ_ONCE/WRITE_ONCE, improving performance but increasing the risk of missing a case where it's actually required. Which way is "better" depends on how you weigh performance vs correctness.</font><br>
<p>
More important than initialization are probably all the accesses inside sections of code holding a lock, where you likely do not want  unnecessary repeat accesses to memory, just because a variable is referenced twice.  Because acquiring spinlock/mutex/whatever   commonly acts as a barrier of some sorts (depending on the implementation somewhere between a full memory barrier, acquire/release barrier, compiler barrier and nothing), it is *often* unnecessary to use READ_ONCE / WRITE_ONCE from within.  Although if there's other accesses working without that lock, or if you have more fine grained locking schemes (say exclusive, exclusive write, read), it's possibly still necessary to use them even within a locked section.<br>
<p>
There's also the fact that volatile on datastructures itself often ends up requiring annoying casts to get rid of it, which then makes the code more fragile too (lest you use some other type of smart macro that keeps the type the same except for removing the volatile).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/794717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor795875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2019 13:28 UTC (Sat)
                               by <b>dcoutts</b> (subscriber, #5387)
                              [<a href="/Articles/795875/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would seem that the fundamental problem here is that C does not distinguish between private variables and variables that may be shared with other threads.<br>
<p>
You have this combination<br>
 * C semantics doesn't talk about shared variables<br>
 * almost all variables are private<br>
 * C compilers want to optimise everything<br>
 * assuming variables are shared would destroy many optimisations<br>
<p>
Which ends up as a mess when you do have shared variables. If they were explicitly identified then the compiler could do the right things with them (given the machine's memory model) and since there's so few of them it would not affect optimisations in general.<br>
<p>
A language which gets imperative programming with shared mutable variables right, ironically, is the functional language Haskell. It has two types of shared mutable variables, MVars which are like a mutable variable protected by a lock, and TVars which are part of the Software Transactional Memory concurrency feature. Of course these also are library APIs, that are able to enforce safe access (reading the MVar and taking the lock are inseparable, and TVars can only be read inside STM transactions).<br>
<p>
But even in a low level language where you don't try to enforce safe concurrency, simply distinguishing shared variables from other variables seems like it would go a long way to resolving this confusion and the C compiler's difficulties.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2019 15:17 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/796095/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A language which gets imperative programming with shared mutable variables right, ironically, is the functional language Haskell.</font><br>
<p>
And, I would guess, Rust. Which is not surprising because this was an explicit design goal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2019 19:19 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/796358/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I will feel better about Rust's concurrency model when I start hearing something other than "unsafe" in response to queries about implementing advanced synchronization techniques.  Don't get me wrong, there is much to like about Rust's notion of ownership, but Rust appears to also need the notion of existence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2019 10:10 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/796389/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>I wonder if there's a human language barrier here; Rust uses "unsafe" code to mean "the human in front of the computer is responsible for proving absence of data races and invalid pointer dereferences". The <a href="https://doc.rust-lang.org/nomicon/index.html">Nomicon"</a> describes what, exactly, <tt>unsafe</tt> opens up to you - basically, safe Rust contains no way to trigger the dreaded Undefined Behaviour, while unsafe Rust <a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">provides for 6 ways to trigger UB</a> <em>if</em> you misuse language features. The idea is that you carefully encapsulate the risk of UB into well-validated and tested code, and provide a safe Rust interface on top that is guaranteed to not have UB no matter how it's used.
<p>For example, the <a href="https://doc.rust-lang.org/src/std/sync/rwlock.rs.html">implementation of a <tt>RwLock</tt></a> is full of <tt>unsafe</tt> code. It has to be to implement a concurrency primitive - the underlying platform is a C ABI, which is implicitly unsafe in Rust, as the compiler cannot verify that your C is free of UB. However, as a user of <tt>RwLock</tt>s, I don't need to care about the unsafety of <tt>RwLock</tt> internals - I can trust that the humans who've reviewed and tested that code ensured that safety guarantees are met.
<p>I would expect the same to apply to advanced synchronization - you have to use <tt>unsafe</tt> to implement it, because you're doing things the compiler cannot verify are defined behaviour, but the resulting primitives are safe because there's no way to misuse them. There is an implementation of <a href="https://crates.io/crates/rcu_cell">RCU in Rust</a> that shows how this works - internally, it's unsafe; for starters, it uses the bottom 2 bits of a pointer as tag values, and it keeps raw pointers around, converting them back and forth to references (effectively safe pointers), but the external interface is entirely safe Rust.
      
          <div class="CommentReplyButton">
            <form action="/Articles/796389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2019 12:54 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/796396/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; safe Rust contains no way to trigger the dreaded Undefined Behaviour</font><br>
<p>
It may be more accurate to say it can't *directly* trigger Undefined Behaviour. It can still indirectly trigger UB if it calls into imperfectly-implemented Unsafe code with an interface that's marked as Safe.<br>
<p>
I expect it takes a lot of discipline and skill to write non-trivial Unsafe modules that guarantee it's absolutely impossible to trigger UB through their Safe interface. <a href="https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html">https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html</a> gives the example of BTreeMap with a Safe-but-incorrect Ord, which is the kind of subtlety that seems likely to trip up many programmers writing their own Unsafe code in pursuit of performance. And there's the situation described in <a href="https://dev.to/deciduously/the-trials-and-tribulations-of-actix-web-and-the-oss-community-53ee">https://dev.to/deciduously/the-trials-and-tribulations-of...</a> where a popular Rust framework had "an understanding gap regarding what unsafe means in Rust", leading to much unhappiness.<br>
<p>
(It still seems better than C/C++ where you have to apply discipline and skill to *all* code, if you don't want your application to crash all the time. Rust tells you where that attention needs to be focused. But you still need good programmers and good review processes to avoid safety problems sneaking in.)<br>
<p>
Based on zero practical experience of Rust, I imagine there are cases where it's infeasible to provide a guaranteed-Safe interface to an interesting bit of Unsafe code (like particularly clever synchronisation primitives, though RcuCell may be a counterexample). You can give it an Unsafe interface and make it the caller's responsibility to guarantee safety, because it's easier to make guarantees at a higher level, but the tradeoff is you've now got more code running unsafely. Rust seems to rely on the hypothesis that, in practice, unsafe code can be kept small and isolated, so a large majority of the codebase gets the benefits of guaranteed safety - is there much evidence for or against that yet? (particularly when writing kernel-like code that has to deal with a lot of fundamentally unsafe hardware)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2019 13:24 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/796398/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>In terms of evidence for unsafety not growing, there's <a href="https://www.redox-os.org/">Redox OS</a>, which has so far been successful at encapsulating unsafe code (at least in terms of apparent safety - it'd take a formal audit to be confident that there are no erroneous safe wrappers). Similarly, Servo (and the parts backported to Firefox) show that it's also practical to keep unsafe to a small area when working in a big project like a web browser.
<p>My practical experience of Rust is that I have yet to encounter a piece of code which has to be unsafe and cannot provide a safe interface to the rest of your project; I have encountered several places where <tt>unsafe</tt> is used because it's easier to violate UB guarantees than to design a good interface. As an example, I've written several FFIs to internal interfaces where the C code has a "flags tell you which pointers in this structure are safe to access" design, and I've ended up creating a new datastructure that has nested Rust structs and makes use of <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a> to identify which sub-structs are valid right now.
<p>Personally, I see "unsafe" as a review marker; it tells you that in this block of code, the programmer is making use of features that could lead to UB if abused (the Rust compiler warns about unnecessary use of unsafe), and that you need to be confident that they are upholding the "no UB via Safe code" guarantee that the compiler expects. It's by no means a perfect system, and as Actix shows, it can be abused, but it does show you where you need to hold the code author to a higher standard than normal.
<p>FWIW, having spent the last 2 years working in Rust, I think it's a decent advance on C; I spend longer getting code to actually compile than I did with C11 or C++17, but it then works (both when tested and in production) more often than my C11 or C++17 did.
      
          <div class="CommentReplyButton">
            <form action="/Articles/796398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2019 14:06 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/796456/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I spend longer getting code to actually compile than I did with C11 or C++17, but it then works (both when tested and in production) more often than my C11 or C++17 did.</font><br>
<p>
A note is that the amount of *thinking* is decreased overall. Rust front-loads it on the compilation phase (with a decent amount of hand holding) while C likes to back-load it on the debugging phase with a possibly unbounded timesink (where I, at times, feel like gdb is watching me like the Chesire cat). The number of times our Rust stuff has fallen over (mostly "unresponsive"[1] or hook deserialization errors[2]) is less than a dozen. But, an error (not a crash!) in the deserializer is much easier to diagnose than "someone threaded a `NULL` *here*‽" questions I find myself asking in C/C++.<br>
<p>
[1] Someone pushed a branch as a backport that caused the robot to go checking ~1000 commits with ~30 checks each. The thinking here was actually about how to detect that we should avoid checking so much work (since the branch is obviously too new to backport). It was churning through it as best it could, but it was still taking ~20 minutes to do the work.<br>
[2] GitLab (and GitHub) webhook docs are so anemic around the types they are using for stuff, so that a field is nullable is sometimes surprising. I can't wait for GraphQL to become more widespread :) .<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor796459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2019 14:10 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/796459/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I imagine there are cases where it's infeasible to provide a guaranteed-Safe interface to an interesting bit of Unsafe code</font><br>
<p>
I suspect things like RcuCell are fine because you can still teach Rust about them through an API. For my keyutils library[1], it's a bit harder because, while there's no pointer juggling, the lifetime of things are tied to kernel objects outside of the Rust code's control. Luckily synchronization is handled by the kernel as well, so I don't have to worry about *that*, but it does mean that your "owned" data is not really such since they're just handles. It does mean that pretty much every function needs to return a Result&lt;&gt; because basically any operation can end up with a `ENOKEY` result if something else ends up deleting it out from underneath you.<br>
<p>
[1] <a href="https://github.com/mathstuf/rust-keyutils">https://github.com/mathstuf/rust-keyutils</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796467"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2019 15:06 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/796467/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It will be interesting to see <a href="https://www.linuxplumbersconf.org/event/4/sessions/38/#all">Writing A Kernel Driver in Rust</a> at the upcoming <a href="https://www.linuxplumbersconf.org/">Linux Plumbers Conference</a>.  From what I have seen, things like split counters, sequence locks, and base RCU (as opposed to RCU use cases like RcuCell) have been carefully avoided in earlier Rust-language Linux-kernel drivers.  Maybe they will take them head-on in this talk.  Either way, looking forward to it!

<p>I agree that encapsulating difficult-to-get-right things into libraries is a most excellent strategy where it applies, but there are often things that don't fit well into a safe API.  Again, I find a number of Rust's approaches to be of interest, but I do not believe that Rust is quite there yet.  As I have said in other forums, my current feeling is that current Rust is to the eventual low-level concurrency language as DEC Alpha is to modern microprocessors.
      
          <div class="CommentReplyButton">
            <form action="/Articles/796467/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor796356"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2019 19:11 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/796356/">Link</a>] 
      </p>
      
      </div>
      </summary>
      But both C and C++ do now allow shared variables to be designated as such, for example, using C _Atomic and C++ atomic&lt;T&gt;.  Although these are <a href="https://lwn.net/Articles/691128/">not</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0422r0.html">perfect</a>, they can be quite helpful.  Especially given that they allow easy use of lighter-weight and more-scalable synchronization mechanisms than MVars and TVars appear to enable.

<p>The problem is that these C and C++ features were not introduced into either standard until 2011, some decades after both languages were first used to write concurrent code.  So there is quite a bit of production code that does not mark shared variables, because there was no way to do so at the time that code was written.

<p>So again, this is a golden opportunity for people who can come up with ways of locating vulnerable concurrent code in large production concurrent C and C++ code bases!
      
          <div class="CommentReplyButton">
            <form action="/Articles/796356/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor820104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 10, 2020 16:39 UTC (Sun)
                               by <b>rep_movsd</b> (guest, #100040)
                              [<a href="/Articles/820104/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Forgive me for being so dense, but why is there an ACCESS_ONCE macro rather than declaring objects that are accessed by multiple threads as volatile?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/820104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor820109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Who's afraid of a big bad optimizing compiler?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 10, 2020 21:16 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/820109/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Couple of reasons:
<ol>
<li>volatile is not necessarily defined clearly enough on all architectures to be what you want. In the event that it's not sufficient on a given architecture, you can make ACCESS_ONCE do the right thing. I don't believe this applies to the kernel, but it's something to be aware of.
<li>Even on architectures where volatile does do the right thing, it causes pessimisation of all accesses to that object, not just those that need ACCESS_ONCE semantics.
'</ol>
<p>A different coding style wouldn't need to worry about the second case, as it would cast away volatile instead of using ACCESS_ONCE for cases that don't need ACCESS_ONCE semantics, but for better or worse, the Linux coding style doesn't work that way.
      
          <div class="CommentReplyButton">
            <form action="/Articles/820109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
