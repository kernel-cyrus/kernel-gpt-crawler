        <!DOCTYPE html>
        <html lang="en">
        <head><title>Domesticating applications, OpenBSD style [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/651700/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/651269/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/651700/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Domesticating applications, OpenBSD style</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 21, 2015</br>
           </div>
One of the many approaches to improving system security consists of
reducing the attack surface of a given program by restricting the range of
system calls available to it.  If an application has no need for access to
the network, say, then removing its ability to use the <tt>socket()</tt> system
call should cause no loss in functionality while reducing the scope of the
mischief that can be made should that application be compromised.  In the
Linux world, this kind of sandboxing can be done using a security module or
the <tt>seccomp()</tt> system call.  OpenBSD has lacked this capability so
far, but it may soon gain it via a somewhat different approach than has
been seen in Linux.
<p>
It is fair to characterize the sandboxing features in Linux as being
relatively complex.  The complexity of the security module options, and
SELinux in particular, is legendary.  The <tt>seccomp()</tt> system call
has two modes: very simple (in which case almost nothing but
<tt>read()</tt> and <tt>write()</tt> is allowed), or rather complex (a
program written in the Berkeley packet filter (BPF) language makes
decisions on system call availability).  There is a great
deal of flexibility available with both security modules and
<tt>seccomp()</tt>, but it comes at a cost. 
<p>
OpenBSD leader Theo de Raadt is <a href="/Articles/651701/">particularly
scornful</a> of the BPF-based approach:
<p>
<div class="BigQuote">
	Some BPF-style approaches have showed up.  So you need to write a
	program to observe your program, to keep things secure?  That is
	insane.
</div>
<p>
His posting contains a work-in-progress implementation of a simpler
approach to sandboxing (mostly written by Nicholas Marriott, it seems)
in the form of a system call named <tt>tame()</tt>.
<p>
The core idea behind <tt>tame()</tt> is that most applications run in two
phases: initialization and steady-state execution.  The initialization
phase typically involves opening files, establishing network connections,
and more; after initialization is complete, the program may not need to do
any of those things.  So
there is often an opportunity to reduce an application's privilege level as
it moves out of the initialization phase.  <tt>tame()</tt> performs that
privilege reduction; it is thus meant to be placed within an application,
rather than (as with SELinux) imposed on it from the outside.
<p>
The system call itself is simple enough:
<p>
<pre>
    int tame(int flags);
</pre>
<p>
If <tt>flags</tt> is passed as zero, the only system call available to the
process thereafter will be <tt>_exit()</tt>.  This mode is thus suitable
for a process cranking on data stored in shared memory, but not much else.
For most real-world applications, the reduction in privilege will need to
be a bit less heavy-handed.  That is what the flags are for.  If any flags
at all are present, a base set of system calls, with read-only
functionality like <tt>getpid()</tt>, is available.  For additional
privilege, specific flags must be used:
<p>
<ul>

<li> <tt>TAME_MALLOC</tt> provides access to memory-management calls like
     <tt>mmap()</tt>, <tt>mprotect()</tt>, and more.
<p>
<li> <tt>TAME_RW</tt> allows I/O on existing file descriptors, enabling
     calls like <tt>read()</tt>, <tt>write()</tt>, <tt>poll()</tt>,
     <tt>fcntl()</tt>, <tt>sendmsg()</tt> and, interestingly,
     <tt>pipe()</tt>. 
<p>
<li> <tt>TAME_RPATH</tt> enables system calls that perform pathname lookup
     without changing the filesystem: <tt>chdir()</tt>, <tt>openat()</tt>
     (read-only),
     <tt>fstat()</tt>, etc.
<p>
<li> <tt>TAME_WPATH</tt> allows changes to the filesystem: <tt>chmod()</tt>,
     <tt>openat()</tt> for writing, <tt>chown()</tt>, etc.
     Note that 
     <tt>TAME_RPATH</tt> and <tt>TAME_WPATH</tt> both implicitly set
     <tt>TAME_RW</tt> as well.
<p>
<li> <tt>TAME_CPATH</tt> allows the creation and removal of files and
     directories via <tt>rename()</tt>, <tt>rmdir()</tt>, <tt>link()</tt>,
     <tt>unlink()</tt>, <tt>mkdir()</tt>, etc.
<p>
<li> <tt>TAME_TMPPATH</tt> enables a number of filesystem-related system
     calls, but only when applied to files underneath <tt>/tmp</tt>.
<p>
<li> <tt>TAME_INET</tt> allows <tt>socket()</tt> and related calls needed to
     function as 
     an Internet client or server.
<p>
<li> <tt>TAME_UNIX</tt> allows networking-related system calls restricted
     to Unix-domain sockets.
<p>
<li> <tt>TAME_DNSPATH</tt> is meant to allow hostname lookups; it gives
     access to a few system calls like <tt>socket()</tt>, but only after
     the program successfully opens <tt>/etc/resolv.conf</tt>.  So the
     kernel has to track whether a few "special" files like
     <tt>resolv.conf</tt> have been opened during the lifetime of the tamed
     process. 
<p>
<li> <tt>TAME_GETPW</tt> enables the read-only opening of a few specific
     files needed for <tt>getpwnam()</tt> and related functions.  It will
     also turn on <tt>TAME_INET</tt> if the program succeeds in opening
     <tt>/var/run/ypbind.lock</tt>. 
<p>
<li> <tt>TAME_CMSG</tt> allows file descriptors to be passed with
     <tt>sendmsg()</tt> and <tt>recvmsg()</tt>.
<p>
<li> <tt>TAME_IOCTL</tt> turns on a few specific, terminal-related
     <tt>ioctl()</tt> commands. 
<p>
<li> <tt>TAME_PROC</tt> allows access to <tt>fork()</tt>, <tt>kill()</tt>,
     and related process-management system calls.
</ul>
<p>

A process may make multiple calls to <tt>tame()</tt>, but it can only
restrict its current capabilities.  Once a particular flag has been
cleared, it cannot be set again.
<p>
The patch includes changes to a number of OpenBSD utilities.  The
<tt>cat</tt> command is restricted to <tt>TAME_MALLOC</tt> and
<tt>TAME_RPATH</tt>, for example; never again will <tt>cat</tt> be able to
run amok on the net.  The <tt>ping</tt> command gets access to the net,
instead, but loses the ability to access the filesystem.  And so on.
<p>
This system call has a number of features that may look a bit strange to
developers used to Linux.  It encodes quite a bit of policy in the kernel,
including where the password database is stored and the use of <a
href="https://en.wikipedia.org/wiki/Network_Information_Service">Yellow 
Pages/NIS</a>; one would grep in vain for <tt>ypbind.lock</tt> in the Linux
kernel 
source.  <tt>tame()</tt> may seem limited in the range of restrictions that
it can apply to a process; it will almost certainly allow more than what is
strictly needed in most cases.  It thus lacks the flexibility that Linux
developers typically like to see.
<p>
On the other hand, using <tt>tame()</tt>, it was evidently possible to add
restrictions to a fair number of system commands with a relatively small
amount of work and little code.  Writing <i>ad hoc</i> BPF programs or
SELinux policies to accomplish the same thing would have taken quite a bit
longer and would have been more error-prone.  <tt>tame()</tt>, thus, looks
like a way to add another layer of defense to a program in a quick and
standardized way; as such, it may, in the end, be used more than something
like <tt>seccomp()</tt>.
<p>
If the <tt>tame()</tt> interface proves to be successful in the BSD world,
there is an interesting possibility on the Linux side: it should be
possible to completely implement that functionality in user space using the
<tt>seccomp()</tt> feature (though it would probably be necessary to merge one
of the <a href="/Articles/590436/">patches</a> adding extended BPF
functionality to <tt>seccomp()</tt>).  We would then have the simple
interface for situations where it is adequate while still being able to
write more flexible filter policies where they are indicated.  It could be
the best of both worlds.
<p>
The first step, though, would probably be to let the OpenBSD project
explore this space and 
see what kind of results it gets.  The ability to try out different models
is one of the strengths that comes from having competing kernels out
there.  The ability to quickly copy that work is, instead, an advantage
that comes from free software.  If this approach to attack-surface
reduction works out, we in the Linux world may, too, be able to
<tt>tame()</tt> our <tt>cat</tt> in the future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security">Security</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Sandboxes">Sandboxes</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/651700/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor651889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 21:17 UTC (Tue)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/651889/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"it is thus meant to be placed within an application, rather than (as with SELinux) imposed on it from the outside."<br>
<p>
That there is a bit of a major difference.  <br>
<p>
Could someone please tell me how this differs from "capabilities" in Linux, apart from the lack of a direct equivalent to CAP_SYS_ADMIN?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652089"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 23:37 UTC (Wed)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/652089/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AIUI, the main difference is that true capabilities involve token-based access (this requires changes to the application in order to acquire the appropriate permissions) while selinux involves an acl (policy-based, and little/no app changes).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652089/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor655073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2015 4:50 UTC (Thu)
                               by <b>vapier</b> (guest, #15768)
                              [<a href="/Articles/655073/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
not sure what you mean by tokens, but i think the question was "how is tame() different from capabilities", not "how is selinux different from capabilities".  there isn't really anything different conceptually between tame and caps afaict.<br>
<p>
at least with filecaps, capabilities can be applied externally w/out needing to modify code.  although programs can update themselves to use caps syscalls to drop perms on the fly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/655073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor651891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 21:25 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/651891/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The initialization phase typically involves opening files, establishing network connections, and more; after initialization is complete, the program may not need to do any of those things. </font><br>
<p>
until the program is sent a HUP and needs to close/reopen files (log rotation, etc)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 23:23 UTC (Tue)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/651901/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The vast majority of programs are not those kind of long-lived programs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 23:25 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/651902/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
but the ones that are "this kind of long-lived programs" are the ones that you need to worry about the most because they are the ones that provide services to other programs (or other systems).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 1:10 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/651907/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Until Shellshock happened, and people realized that a huge pool of potential exploits was lying under their noses the entire time in the form of the various command-line utilities. Just because defenders are focused on one area doesn't mean attackers aren't exploiting other areas. Are you going to to audit utilities like awk, sed, and grep for exploits related to environment variables, data structures buffer bugs, etc? Executing utilities this way is poor form these days, but unfortunately still quite common. Occasionally it still makes sense, such as when executing a configurable command to perform some check or make some policy decision; and in that case you never know how it's implemented.<br>
<p>
Regarding the usefulness in complex programs, note that OpenBSD developers tend to implement their services using a rigorous privilege separation and message passing pattern. In particular, they often use subprocesses to implement very specific operations which require no or minimal access to the environment. For example, the TLS private key in OpenSMTPd is only kept in memory in a subprocess, so that bugs in the protocol stack cannot expose the private key. (Yes, they hacked and extended the signature routines in OpenSSL to do this.) After startup, the subprocess doesn't need any privileges except the ability to read and write to the IPC messaging socket and perhaps the /dev/crypto driver. The point of tame(2) is to make it a one-liner to drop privileges after an application-specific initialization procedure.<br>
<p>
The utility is limited from the perspective of trying to lock down every conceivable application out there. But that's not the goal. The goal is much more specific, oriented toward the needs of OpenBSD services and OpenBSD developers.<br>
<p>
I'm not sold on the concept. But it's hardly useless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 22:02 UTC (Wed)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/652069/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This can't do much for awk and can't do anything for GNU awk. Awk is an interpreter, and doesn't know what the program is going to do, and GNU awk is an interpreter with the ability to load arbitrary shared libraries at runtime.<br>
<p>
I'm less then impressed with cat. I acknowledge it's an easy example, but it implies that cat isn't trustable. If in 2015 C programmers can't write a cat without buffer overflows, maybe they should stop writing cat in C. A correct cat is better then one that is limited in what it can do when it fails. Other programs are more complex, but a program that fails with an exception on a buffer overflow is better then one that can corrupt local files but not reach the network on a buffer overflow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2015 8:53 UTC (Sun)
                               by <b>mti</b> (subscriber, #5390)
                              [<a href="/Articles/652469/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see at least two ways of making this useful for awk. One is to expose the tame() call to awk scripts to be able to write safer awk scripts. The other is to add a command line option to awk to set the flags awk should use in its call to tame(). Most awk scripts I have seen doesn't need more than simple file I/O.<br>
<p>
As for cat it is not quite as simple as you think it is. For one thing it includes calls to several multi-byte character string functions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor651928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 6:55 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/651928/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess that's another argument for having log rotation handled externally to the process, which can just write its log messages to a pipe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 11:26 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/651949/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Imagine putting all the logs in a single file, with metadata and the ability to do fast queries for all the messages produced by a particular daemon... kind of a replacement for /var/log/messages... you could call that the system journal :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 18:24 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652030/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
putting all logs in a single file isn't going to let you rotate them, and having everything in a single file is a horrible thing to do for scalability and performance.<br>
<p>
So please, stop dictating the policy of how logs should be handled and instead just provide mechanisms and let me decide how logs should be handled.<br>
<p>
traditional /dev/log works. The metadata is available (if you want it), but I'm not locked into the "all logs in one file on the local system" mentality of journald and don't have to deal with the failure modes of binary logs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 19:35 UTC (Wed)
                               by <b>plundra</b> (guest, #51099)
                              [<a href="/Articles/652050/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On a related note, since OpenBSD 5.6 syslog(3) uses the new syscall sendsyslog(2), no longer requiring opening /dev/log which helps when you're in a chroot or out of fds.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 20:01 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652051/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
how does it deliver the message? (the man page just says it delivers it directly to syslogd) does it use /dev/log but just not count it as an open file? send it over localhost? something else?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 21:38 UTC (Wed)
                               by <b>plundra</b> (guest, #51099)
                              [<a href="/Articles/652077/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Never looked into the details before, but as I understand it, when syslogd is started a fd is set in the kernel via an ioctl (LIOCSFD), that sendsyslog then uses, if set.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 22:21 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652082/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
so it's effectively a backdoor around fd limits.<br>
<p>
writing to /dev/log with chroot is actually better because the syslog daemon can create a /dev/log in each sandbox and tell which one was written to (as well as gathering metadata across the unix socket, something that I assume is lost when you are just writing to a magic fd)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor652035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 19:39 UTC (Wed)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/652035/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><em>… but I'm not locked into the "all logs in one file on the local system" mentality of journald …</em></blockquote>
<p>
I'm pretty sure we have been over this before but that is not actually how journald works. Read <a href="http://www.freedesktop.org/software/systemd/man/journald.conf.html">journald.conf(5)</a>.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/652035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 20:04 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652052/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
we had not covered this particular aspect before, but the options listed (SplitMode= One of "uid", "login" and "none") is still pretty limited.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652086"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 23:31 UTC (Wed)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/652086/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Journald will rotate log files as required to limit their size, or at fixed intervals. Very old journal files can be automatically discarded. Querying still works across all the reachable files. Also, journald does support remote logging – the journal files do not need to remain on the local machine.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/652086/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor652075"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 21:26 UTC (Wed)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/652075/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; with metadata and the ability to do fast queries for all the messages produced by a particular daemon... kind of a replacement for /var/log/messages... you could call that the system journal</font><br>
<p>
I call that a "filesystem". You can see it implemented properly in the likes of daemontools, runit, s6 and so on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652075/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 22:18 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652081/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
for fast lookups of log data what you want is a database, not a filesystem or a file.<br>
<p>
And if you are going to make it 'the' way of dealing with logs, you need to make it scale well to handle people's logging needs.<br>
<p>
if you are just offering it as an optional thing that can be turned off, the requirements are not as high.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 11:35 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/652135/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It all depends on what you mean by "lookup". Logs are essentially sequential, both in how you write and how you use them. I have dealt with such problems and often found that simply sequentially scanning the data is faster than jumping from here to there following pointers through the index and then the data itself, specially when you keep related data together. Additionally, sequential data structures are more compact and less prone to corruption if you take the precaution of adding synchronization points.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 12:42 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652142/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This thread on logging is off-topic for the article, but I'm willing to continue discussing things<br>
<p>
When I say that logs need to be in a database for searchability, I'm not meaning a traditional SQL database, but something optimized for time-series data like ElastiSearch/splunk. Something that can deal not just with the raw text of the logs, but also with parsing the logs and creating indexes to make searching them more efficient than grep.<br>
<p>
Grep is a great took if you have small logs (or know where to search in yout large logs and have them split into small enough chunks. but when you start combining the logs from even dozens, let alone hundreds or thousands of servers together, the sort of split options that the journal provides don't help you.<br>
<p>
You don't want to do reports from the database as that's inefficent and doesn't scale well. this doesn't matter for a single laptop or 5-server company, but as you get up into tens or hundreds of gigs/day of logs it matters more. I've been in environments where we've seriously had to deal with Gig-E not being fast enough to handle all the logging traffic if it was done the 'obvious' way.<br>
<p>
and splitting the logs, but then searching across all of them is counterproductive<br>
<p>
<font class="QuotedText">&gt;  I have dealt with such problems and often found that simply sequentially scanning the data is faster than jumping from here to there following pointers through the index and then the data itself, specially when you keep related data together. Additionally, sequential data structures are more compact and less prone to corruption if you take the precaution of adding synchronization points.</font><br>
<p>
I strongly agree, and in part this is part of why I dislike the journald implementation. Reading the logs out of journald isn't a sequential read through the data, it's following pointers from one message to the next (and these pointers can get corrupted, which has led to cases where following the pointers gives you a loop)<br>
<p>
I like to keep my logs organized in multiple ways<br>
<p>
1. I keep an authoritative copy for audit/legal reasons that's a simple sequential text file, gzipped and chunked into 'reasonable' sizes (typically per-minute files that then get signed/archived at larger intervals)<br>
<p>
2. I parse the messages extensively and store them in something that makes it possible to do fast ad-hoc searches of data (splunk or elasticsearch) being able to do a query like 'show me every log containing this IP address' across hundreds of TB of data in just a couple minutes is a great security tool.<br>
<p>
3. I categorize the logs and write them out in per-category files, sometimes in different formats (and one log can be written multiple places) so that reporting tools for each category can efficiently process what they need to get at.<br>
<p>
4. some of the destinations that are written to are event correlation engines that do different things with the logs. Some generate summary data (that then feeds back into the logging system so that report generators and dashboards can use it, usually from ES/Splunk). Some generate alerts based on the absence of logs. And some generate alerts based on spotting logs or combinations of log messages.<br>
<p>
I've done a bit more writing on the topic:<br>
<a rel="nofollow" href="https://www.usenix.org/publications/login/david-lang-series">https://www.usenix.org/publications/login/david-lang-series</a><br>
<a rel="nofollow" href="https://www.usenix.org/publications/login/feb14/logging-reports-dashboards">https://www.usenix.org/publications/login/feb14/logging-r...</a><br>
<a rel="nofollow" href="https://www.usenix.org/conference/lisa12/technical-sessions/presentation/lang_david">https://www.usenix.org/conference/lisa12/technical-sessio...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 15:16 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/652182/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As you pointed out this is clearly off topic, but I want to thank you for sharing your articles. Very interesting reading.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 15:59 UTC (Thu)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/652189/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>This is great but at the same time we should keep in mind that, as the wide world of logging applications are concerned, dlang is something of an outlier.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/652189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 19:15 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652215/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This is great but at the same time we should keep in mind that, as the wide world of logging applications are concerned, dlang is something of an outlier.</font><br>
<p>
while I'm an outlier in the total volume of logs I've had to deal with, it's not by as much as you think.<br>
<p>
the 100K logs/sec traffic was the 3-year projection at a 800 person SaaS company in 2006. When you take 100K logs/sec @ ~250 bytes/log (our measured average), delivering the logs to 4 destinations exceeds 1Gb/s. the company did not continue expanding at the predicted rate after it was purchased by a much larger company in 2007, but the log volume did continue to grow.<br>
<p>
I spent some time at Google, and while I wasn't in their logging division, there's a lot in common between their logging architecture and what I advocate (although they do everything through their own APIs, a lot of NIH and some 'they were at a large scale before the tools got good enough for that scale')<br>
<p>
At my new job, we 'only' have ~500 systems right now, and I find that these approaches work much better than many others that are talked about and tried. There are a LOT of companies that are at this scale and larger.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 21:16 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/652239/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe I'm just unfamilar with this level of sysadmining, but what do you *do* with all these logs? Dump them to disk and rotate out disks for archaeological use later (breach, debugging, etc.)? Scan them for "interesting" bits and toss out anything outside the context of those bits? It seems that, to me, these log databases are larger than the actual meat of the data being manipulated in many cases (LHC and scientific simulations being the ones that come to mind where the data would still outsize a log flow like that).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 21:59 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652243/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Maybe I'm just unfamilar with this level of sysadmining, but what do you *do* with all these logs?</font><br>
<p>
Fair question<br>
<p>
different things have different uses.<br>
<p>
The archive is to recreate anything else as needed and to provide an "authoritative source" in case of lawsuits. How long you keep the logs depends on your company policies, but 3-7 years are common numbers (contracts with your customers when doing SaaS may drive this)<br>
<p>
being able to investigate breeches, or even just fraud are reasons for the security folks to care.<br>
<p>
for outage investigations (root cause analysis), you want to have the logs from the systems for the timeframe of the outage (and this is not just the logs from the systems that were down, you want the logs from all other systems in case there are dependencies you need to track down). For this you don't need a huge timeframe, but being able to look at the logs during a time of similar load (which may be a week/month/year ago depending on your business) to see what's different may help.<br>
<p>
by generating rates of logs of different categories you can spot trends in usage/load/etc<br>
<p>
By categorizing the logs and storing them by category you can notice "hey, normally these logs are this size, but they were much larger during the time we had problems" and by doing it per type in addition to per server you can easily see if different servers are logging significantly differently when one is having problems.<br>
<p>
Part of categorizing the logs can be normalizing them. If you parse the logs you can identify all 'login' messages from your different apps and extract the useful info from them and output a message that's the same format for all logins, no matter what the source. This makes it much easier to spot issues and alert on problems.<br>
<p>
A good approach is what Marcus Ranum coined "Artificial Ignorance"<br>
<p>
start with your full feed of logs, sort it to find the most common log messages, If they are significant categorize those longs and push them off for something that knows that category to report on.<br>
<p>
Remember that the number of times that an insignificant thing happens can be significant, so generate a rate of insignificant events and push that off to be monitored.<br>
<p>
repeat for the next most common log messages.<br>
<p>
As you progress through this, you will very quickly get to the point where you start spotting log messages that indicate problems. Pass those logs to an Event Correlation engine to alert on them (and rate limit your alerts so you don't get 5000 pages)<br>
<p>
Much faster than you imagine, you will get to the point that the remaining uncategorized logs are not that significant, but also that there aren't very many of them and you can do something like generate a daily/weekly report of the uncategorized messages and have someone eyeball them for oddities (and keep an eye out for new message types you should categorize)<br>
<p>
This seems like a gigantic amount of work, but it actually scales well. The bigger your organization the more logs you have, but the number of different _types_ of logs that you have grows much slower than the total log volume.<br>
<p>
<font class="QuotedText">&gt; It seems that, to me, these log databases are larger than the actual meat of the data being manipulated in many cases.</font><br>
<p>
That's very common, but it doesn't mean the log data isn't valuable. Remember that I'm talking about a SaaS type environment, not HPC. Even if the service is only being provided to your employees. HPC and scientific simulations use a lot of cpu and run through a lot of data, but they don't generate much in the way of log info.<br>
<p>
For example, your bank records are actually very small (what's your balance, what transactions took place), but the log records of your banks systems are much larger because they need to record every time that you accessed the system and what you did (or what someone did with your userid). When you then add the need to keep track of what your admins are doing (to be able to show that they are NOT accessing your accounts and catch any who try), you end up with a large number of log messages for just routine housekeeping.<br>
<p>
But text logs are small, and they compress well (xz compression is running ~100:1 for my logfiles), so it ends up being a lot easier to store the data than you initially think. If you are working to do this efficiently, you can also use cheap storage and end up finding that the amount of money you are spending on the logs is a trivial amount of your budget.<br>
<p>
It doesn't take many problems solved, or frauds tracked down to pay for it (completely ignoring the value of logs in the case of lawsuits)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2015 1:12 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/652270/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The archive is to recreate anything else as needed and to provide an "authoritative source" in case of lawsuits. How long you keep the logs depends on your company policies, but 3-7 years are common numbers (contracts with your customers when doing SaaS may drive this)</font><br>
<p>
You aren't using "logs" in the same sense that most sysadmins mean "logs" -- your definition is more akin to what journalling filesystems (or databases) refer to as logs -- ie a serial sequence of all transactions or application state changes.<br>
<p>
I think that's why so many folks (myself included) express incredulity at your "logging" volume.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2015 1:49 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652273/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When I say logs, I'm talking about the stuff generated by operating systems and appliances into syslog + the logs that the applications write (sometimes to syslog, more frequently to local log files that then have to be scraped to be gathered). This includes things like webserver logs (which I find to be a significant percentage of the overall logs, but only ~1/3)<br>
<p>
I do add some additional data to the log stream, but it's low volume compared to the basic logs I refer to above (A few log messages/min per server)<br>
<p>
Also, keep in mind that when I talk about sizing a logging system, most of the time I'm talking about the peak data rate. What it takes to keep up with the logs at the busiest part of the busiest day.<br>
<p>
I want to have a logging system that can process all logs within about 2 min of when they are generated. This is about the limit as far as I've found for having the system react to log entries or having changes start showing up in graphs.<br>
<p>
<p>
There is also the average volume of logs per day. This comes into play when you are sizing your storage.<br>
<p>
so when I talk about 100K logs/sec or 1Gb of logs being delivered, this is the peak time.<br>
<p>
100K logs/sec @256 bytes/log = 25MB/sec (1.5GB/min, 90GB/hour) If you send this logging traffic to four destinations (archive, search, alerting, reporting), you are at ~100MB/sec of the theoretical 125MB/sec signalling rate that gig-E gives you. In practice this is right about at or just above the limit of what you can do with default network settings (without playing games like jumbo frames, compressing the network stream, etc). The talk I posted the link to earlier goes into the tricks for supporting this sort of thing.<br>
<p>
But it's important to realize that this data rate may only be sustained for a few min per day on a peak day, so the daily volume of logs can be &lt;1TB/day on a peak day (which compresses to ~10GB), and considerably less on off-peak days. Over a year, this may average out to 500GB/day (since I'm no longer there I can't lookup numbers, but these are in the ballpark)<br>
<p>
This was at a company providing banking services for &gt;10M users.<br>
<p>
now, the company that I recently started at is generating 50GB of windows eventlog data per day most weekdays, (not counting application logs, firewall logs, IDS logs, etc) from a couple hundred production systems. I don't yet have a feed of those logs, so I can't break it down any more than that yet, but the type of business that we do is very cyclical, so I would expect that peak days of the month/year the windows eventlog log volume will easily be double/triple that.<br>
<p>
If you parse the log files early and send both the parsed data and the raw data, the combined parsed data can easily be 2x-3x the size of the original raw data (metadata that you gather just adds to this)<br>
<p>
As a result, ElasticSearch needs to be sized to handle somewhere around 500G/day (3*3*50GB/day) for it's retention period to handle the peak period with a little headroom.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2015 1:55 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/652280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
as always, your log sizes and patterns may vary, measure them yourself. but I'll bet that you'll be surprised at how much log data you actually have around.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor652253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 22:30 UTC (Thu)
                               by <b>job</b> (guest, #670)
                              [<a href="/Articles/652253/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Anyone who works under regulations, such as SOX, needs to keep an archive of logs in their sequential form. By far the easiest way to do that is to chunk them up, gzip them, sign if necessary, and file away. That should be quite a common use case in larger organizations, if not perhaps not the same volume of it. It's also a good idea to keep a (pruned) copy in elasticsearch for your daily bug hunting activities...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor652453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2015 19:20 UTC (Sat)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/652453/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's nice to know that even an article on openbsd can trigger a systemd flamewar...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor651892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 21:29 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/651892/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With this sort of thing the devil is in the details. It's really easy to get something that looks good and works some of the time. It's when you start getting to the edge cases or the ground shifts under you (different ways of looking up hostnames for example) that things start getting ugly<br>
<p>
but since there is no clearly good solution to this problem, it will be good to get another group experimenting with it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 7:05 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/651929/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Well yeah.  Like most security measures it's not a 100% solution and not intended to be.  If a few one-line <code>tame()</code> calls scattered among the system utilities' code can prevent just one or two bugs from being exploitable in the future then it will be worthwhile.
<p>
I think it would be cool to declare sections of code which can be executed once and then forgotten.  For example the initialization code in <code>init()</code> would open files, then the program calls something like <code>scrub_code(&amp;init)</code>.  This C library routine, with support from the compiler and the kernel, overwrites the <code>init()</code> in the process's text segment so it can never again be executed during the process's lifetime (whether deliberately or through some stack-smashing attack).  As long as self-modifying code is prohibited the rest of the time, you can be certain that no further calls to <code>open()</code> can happen simply because they aren't physically present in the program code.
<p>
Hmm, thinking about it this would only work for toy programs that don't have any shared libraries.  It doesn't solve the problem of a stack smashing attack jumping to some place in a shared library.  So masking out allowed system calls is probably a better approach, combined with some general countermeasures against memory trampling and stack smashing.
      
          <div class="CommentReplyButton">
            <form action="/Articles/651929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 15:38 UTC (Wed)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/651971/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think it would be cool to declare sections of code which can be executed once and then forgotten.</font><br>
<p>
This is pretty useless defense as exploits can just use return-oriented programming or be data-only, <a href="http://www.securitee.org/files/valueguard_iciss2010.pdf">http://www.securitee.org/files/valueguard_iciss2010.pdf</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor652080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 22:21 UTC (Wed)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/652080/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Worthwhile is a lot more complex tradeoff then that. It can and probably will cause bugs; a misplaced or miswritten tame() may cause a program to be unable to read or write files it needs to, or make a net communication it needs to. The tame() code itself could be buggy, ranging from providing false security to actually opening up features the program shouldn't have an option to. At the least it wasn't worthwhile if the same amount of time used for another more feature would have prevented the bugs instead of stopping them from being exploitable, or made more bugs unexploitable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor652531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2015 16:17 UTC (Mon)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/652531/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's the most interesting aspect IMHO. We can wait 2-3 years and see how many programs will have been tame()d and how.<br>
At least, it will offer some very interesting experience on the usefulness of such pragmatic ideas, especially in opposition to mandatory policies implementations.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor651894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 22:04 UTC (Tue)
                               by <b>spender</b> (guest, #23067)
                              [<a href="/Articles/651894/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
TAME_WPATH allows the whole feature to be defeated -- httpd under their policy (or any other binary with this "capability", and it will be a majority of them) will be able to both write to a file and chmod it as setuid.  This then allows a local attacker with access to that path to gain the full privilege of the user running httpd without any restrictions, including ability to ptrace existing processes to steal private keys, etc.<br>
<p>
Naive minimalistic syscall-based approaches will always run into this problem: any sufficiently complex program will need enough of these seemingly minor privilege buckets to shoot itself in the foot.  The above is just one of several problems with this DOA idea.  Maybe it'll work great for the non-interactive 386s running only a firewall typical of OpenBSD installations, but it simply doesn't translate to the real world with real applications and actual attack surface.  If it can't handle even simple exploit scenarios crafted in five minutes, what's the point of it other than to further the illusion of OpenBSD's security relevance?<br>
<p>
This is nothing other than another entry in OpenBSD's storied history of arriving late to the game with weak re-inventions and acting like they've created something new and amazing, and lazy articles like this drink the kool-aid, ignore critical thought, and perpetuate the mythology of OpenBSD being the pinnacle of security innovation.<br>
<p>
-Brad<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 22:38 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/651899/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is one situation in which TAME_WPATH can be used safely: if the only filesystems the user running a program using it can write to have been mounted nosuid.<br>
<p>
How common this is in a typical OpenBSD installation I don't know. It would certainly suffice for me (with /var and /home separate filesystems, httpd only able to write to at most one of those, and both mounted nosuid).<br>
<p>
Of course, this is a local administration policy decision, which fits rather badly with the 'wire it into the application' approach that is tame()... but of course the sysadmin has always been able to degrade the security of applications by making bad decisions, and mounting filesystems that anything but root can write to without nosuid has long been regarded as a bad administrative decision. So maybe this falls under "works if sysadmin isn't stupid".<br>
<p>
(I don't think the article is drinking the kool-aid or ignoring critical thought, but I will write this off as you being simply incapable of writing anything that isn't an attack on your interlocutor. Attacking Jon like that? You should be ashamed of yourself.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor651937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 9:44 UTC (Wed)
                               by <b>djm</b> (subscriber, #11651)
                              [<a href="/Articles/651937/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you can execute arbitrary code in httpd then being able to write a setuid file that gives you execute permissions as httpd doesn't get you anything you didn't already have.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 10:16 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/651942/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
you don't need to be able to execute arbitrary code for this (<a href="https://www.usenix.org/conference/14th-usenix-security-symposium/non-control-data-attacks-are-realistic-threats">https://www.usenix.org/conference/14th-usenix-security-sy...</a>).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 10:41 UTC (Wed)
                               by <b>djm</b> (subscriber, #11651)
                              [<a href="/Articles/651944/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're trying to fit a camel through a pinhole now.<br>
<p>
You're saying that TAME_WPATH can be exploited for actual gain in cases where the attacker <br>
<p>
1) has an attack which can cause an application to misbehave enough to write arbitrary contents to a file and then chmod it with arbitrary permissions, but is somehow less than full codeexec; and<br>
<p>
2) is local to the host<br>
<p>
That's a bit of a step back from "omg broken"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 12:44 UTC (Wed)
                               by <b>spender</b> (guest, #23067)
                              [<a href="/Articles/651956/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So what's the point of a system to deny obscure syscalls where under trivial exploit scenarios an attacker can gain the ability to call those syscalls under the privileged account that was supposed to be protected?  With your poo-pooing of the scenario you've dismissed the entire multi-billion dollar webhosting industry.  In what scenario other than an exploit condition can an application just start calling random unrelated system calls?  You want to give the appearance that this confines exploits, but when they're actually presented want to pretend it's got nothing to do with exploits.  You can't have your cake and eat it too.<br>
<p>
-Brad<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 16:20 UTC (Wed)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/652010/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point applies to the vast majority of systems where the attacker does not have (legitimate) control of another local user; though being able to create SUID files while tamed is arguably a bug, considering the general willingness to disable broad swaths of kernel functionality for tamed processes - a bug which, especially since the feature is a work in progress, you would do well to attempt to report.<br>
<p>
That said, as far as I can tell, the idea of using TAME_WPATH or TAME_CPATH without chroot is just fundamentally broken, considering home directory dotfiles etc.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor651900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 23:17 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/651900/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It sounds like these options have been tailored to specific applications and scenarios that Theo de Raadt has thought about and the kernel will have to be relentlessly extended to handle more applications and scenarios. That may be fine for OpenBSD but not for a general-purpose OS that people want to innovate on. For example, rr uses seccomp in interesting ways that are totally unrelated to what tame() provides. Still, this experiment will produce useful data.<br>
<p>
And yes, if this approach is useful at all, creating a user-space library that provides this functionality on top of seccomp seems ideal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 3:01 UTC (Thu)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/652104/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's already quite painless to use seccomp-bpf via the libseccomp library. It has a very nice API and abstracts over most of the architecture portability issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652115"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 5:53 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/652115/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The issues that tame() abstracts over are not so much architecture portability issues, but having to understand the whole system-call interface to figure out which syscalls to block.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652115/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652508"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2015 1:41 UTC (Mon)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/652508/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You also have to understand subtleties about the system calls whitelisted by tame to use it safely, such as the gotchas pointed out by spender. It only provides convenient (or inconvenient, if your goal is minimal attack surface) groupings of related system calls. It doesn't prevent you from shooting yourself in the foot at all.<br>
<p>
Anyway, in most sandboxes, seccomp-bpf (or tame) is for reducing the kernel attack surface. Other mechanisms are used to implement the sandboxing semantics (uid/gid separation, chroot, FreeBSD jail, Linux namespaces).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652508/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor651924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 6:28 UTC (Wed)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/651924/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See <a href="http://0pointer.net/public/systemd-nluug-2014.pdf">http://0pointer.net/public/systemd-nluug-2014.pdf</a><br>
<p>
ftp.nluug.nl/video/nluug/2014-11-20_nj14/zaal-2/5_Lennart_Poettering_-_Systemd.webm<br>
<p>
Essentially inserting some statements in services' unit files about CapabilityBoundingSet, NoNewPrivileges and RestrictAddressFamilies and the like are easy ways to create restrictions similar to those implemented by tame().     I'm too lazy to learn about SELinux, but have found the systemd capabilities control facilities quite manageable both to configure and to test.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 10:16 UTC (Wed)
                               by <b>djm</b> (subscriber, #11651)
                              [<a href="/Articles/651943/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's quite different. The point of tame()/seccomp-bpf/seatbelt, etc is that they can be applied *part-way* through an application's life, after most of the privilege-needing operations have been completed.<br>
<p>
Restricting a program "from the outside" would need to include all the privileges that are only needed at initialisation time and would yield a much less restrictive policy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 10:48 UTC (Wed)
                               by <b>fishface60</b> (subscriber, #88700)
                              [<a href="/Articles/651946/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If your process set-up is common stuff like setting up sockets, then you could handle that in systemd by declaratively describing what you want in a .socket unit, and using socket activation of your service, so your process doesn't need to do setup before dropping capabilities.<br>
<p>
I don't think this has a way to set up an outgoing connection, but that's more common in outgoing client applications, which you wouldn't necessarily be able to use systemd for anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 20:21 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/652049/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Private keys. Sensitive configuration files. Filesystem initializations. It's not only about having read access to specific resources, but often times initializing those resources, or even re-initializing after failure. Any complex program will either need to manage dropping capabilities on its own, or it will have to be architected as a collection of multiple independent processes invoked separately. In such cases, systemd doesn't simplify things; it complicates them.<br>
<p>
Socket activation existed for decades before systemd in the form of inetd, and almost nobody bothered to use it. Why? Because opening a socket is but one of many ad hoc initialization tasks complex services implement. Instead of trying to abstract away these patterns and trying to provide a One True Interface only suitable for imaginary or proof-of-concept programs, it makes more sense to provide a simple, powerful primitive which takes care of 80% of the work, leaving the finer ad hoc details to the application. fork is like this. tame tries to be like this, but only time will tell whether how useful it really is.<br>
<p>
The problem with systemd is that it makes easy things easier, but complex things more convoluted, assuming it's useful at all. systemd isn't _composable_ in the sense of being able to build another layer atop it. It's a tool for system administrators wrangling poorly written software. It's not a solution for implementing correctly written software in the first instance. Likewise for something like journald. It's a nice piece of engineering. But it's not composable. A composable logging approach would be logging to stderr on a file descriptor specifiable via the invocation options, so that users can direct log messages however and where ever they see fit, including but not limited to journald. Composability allows you to programmatically extend and repurpose the functionality, without having to know about the internal details of the implementation, and without needing the cooperation of the implementation beyond the simple interface it provides--logging to a specified file descriptor. journald and how-to-properly-implement-logging-in-your-application are unrelated from a programmer's perspective, yet sadly conflated by system administrators and developers alike.<br>
<p>
I personally favor moving developers toward something like Capsicum. Tame and seccomp seem more like interim measures, and I would hate to see the slow shift to Capsicum (or the Capsicum-like model) stall out. Systemd is irrelevant in the context of such approaches. It's more relevant for approaches like VMs or containers, which not coincidentally are approaches especially preferred by system administrators as it allows them to wrangle poorly written and misbehaved software.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Capsicum</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 8:46 UTC (Thu)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/652128/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, I was disappointed that Capsicum was not mentioned in the original article, as it is already available in FreeBSD:<br>
  <a href="https://www.cl.cam.ac.uk/research/security/capsicum/freebsd.html">https://www.cl.cam.ac.uk/research/security/capsicum/freeb...</a><br>
<p>
<p>
It seems that the development of a Linux port is still ongoing:<br>
  <a href="https://github.com/google/capsicum-linux">https://github.com/google/capsicum-linux</a><br>
but I'm worried that people would reject it as overlapping existing mechanisms (while it seems rather hard to combine the same expressivity and simplicity with existing mechanisms, bpf-seccomp included).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor652153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 15:39 UTC (Thu)
                               by <b>fishface60</b> (subscriber, #88700)
                              [<a href="/Articles/652153/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whoa there. I'm not claiming that systemd replaces the need for applications to do their own setup, just that in some cases you can move the setup out.<br>
<p>
<font class="QuotedText">&gt; Private keys. Sensitive configuration files. Filesystem initializations.</font><br>
<p>
For the filesystem initialization bit you could potentially use a different process. Systemd has a system-wide filesystem initialization service that runs on boot, which it uses to initialize some of its services' filesystem paths, and other services can drop in a config file if they choose to do setup this way.<br>
<p>
<font class="QuotedText">&gt; It's not only about having read access to specific resources, but often times initializing those resources, or even re-initializing after failure. Any complex program will either need to manage dropping capabilities on its own, or it will have to be architected as a collection of multiple independent processes invoked separately. In such cases, systemd doesn't simplify things; it complicates them.</font><br>
<p>
You can still have your service do its own capability dropping, systemd isn't forcing you to use its capability dropping mechanism, so it can't be complicating matters here.<br>
<p>
If you *do* choose to split your service up, then I think systemd unit files are simpler, though if you disagree nobody is stopping you using an old sysv init script.<br>
<p>
<font class="QuotedText">&gt; Socket activation existed for decades before systemd in the form of inetd, and almost nobody bothered to use it. Why? Because opening a socket is but one of many ad hoc initialization tasks complex services implement. Instead of trying to abstract away these patterns and trying to provide a One True Interface only suitable for imaginary or proof-of-concept programs, it makes more sense to provide a simple, powerful primitive which takes care of 80% of the work, leaving the finer ad hoc details to the application. fork is like this. tame tries to be like this, but only time will tell whether how useful it really is.</font><br>
<p>
As a counter-point, I've repeatedly been frustrated by services that insist on doing their own socket initialization, and are insufficiently flexible about what I need to do with the sockets.<br>
Usually binding it to an ephemeral port, so I can start up the service multiple times, to run isolated tests against the service in parallel, or binding the service to a specific interface, so I'm not relying on binding to the IP address that the interface I want to bind it to happens to currently have.<br>
<p>
<font class="QuotedText">&gt; The problem with systemd is that it makes easy things easier, but complex things more convoluted, assuming it's useful at all.</font><br>
<p>
I don't understand your point, since as far as I'm aware it's not preventing you doing it the old way.<br>
<p>
<font class="QuotedText">&gt; systemd isn't _composable_ in the sense of being able to build another layer atop it.</font><br>
<p>
I don't follow.<br>
<p>
The rkt guys are building container management on top of systemd-nspawn and service management.<br>
As I understand it, desktop environment developers are building on top of systemd-logind's session management.<br>
The Cockpit guys are building server administration interfaces on top of systemd's APIs.<br>
<p>
<font class="QuotedText">&gt; It's a tool for system administrators wrangling poorly written software.</font><br>
<p>
You've described most software there, aren't tools for dealing with it valuable?<br>
<p>
<font class="QuotedText">&gt; It's not a solution for implementing correctly written software in the first instance. Likewise for something like journald. It's a nice piece of engineering. But it's not composable.</font><br>
<p>
Given your previous definition of composable software being something you can build on, then I think it is, as rsyslog builds on journald to provide the traditional interface on top of journald by reading messages out of the journal.<br>
<p>
<font class="QuotedText">&gt; A composable logging approach would be logging to stderr on a file descriptor specifiable via the invocation options, so that users can direct log messages however and where ever they see fit,</font><br>
<p>
How is this standard interface for providing logging descriptors to processes composable, but setting up other resources like sockets not?<br>
<p>
<font class="QuotedText">&gt; including but not limited to journald.</font><br>
<p>
Indeed. journald gives you the option of setting up an extra file descriptor, which messages written to get appropriately labelled.<br>
<p>
The application or an ancestor program can set this up with sd_journal_stream_fd(), or from a shell you can do:<br>
<p>
    my_command --log-fd=100 100&gt; &gt;(systemd-cat --identifier=my_command_log)<br>
<p>
<font class="QuotedText">&gt; Composability allows you to programmatically extend and repurpose the functionality, without having to know about the internal details of the implementation, and without needing the cooperation of the implementation beyond the simple interface it provides--logging to a specified file descriptor.</font><br>
<p>
Systemd isn't stopping you doing that.<br>
<p>
<font class="QuotedText">&gt; journald and how-to-properly-implement-logging-in-your-application are unrelated from a programmer's perspective, yet sadly conflated by system administrators and developers alike.</font><br>
<p>
Are you saying neither system administrators or developers are programmers<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor652219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 20:14 UTC (Thu)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/652219/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Private keys.</font><br>
<p>
The right way to handle private keys is to have a separated process that handle cryptography for the main application over a pipe with private keys loaded via separated programs over another pipe. This way the crypto process would not need any file system access and the main application would not need to access private keys. It is interesting that recent OpenSSHD comes rather close to this model with sshd gaining ability to use host keys stored in ssh-sgent. I wrote "almost" as ssh-agent has to create its unix socket requiring minimal filesystem access rather accepting it on stdin.<br>
<p>
<font class="QuotedText">&gt; Sensitive configuration files.</font><br>
<p>
It is better to have a unix socket in the application where administrator or scripts can send those config files. This also eliminates the need for any signals and races when the application has to be notified about changes in the files.<br>
<p>
<font class="QuotedText">&gt; Filesystem initializations.</font><br>
<p>
Why not to have a separated process that does this?<br>
<p>
In any case, I think the main purpose of tame is to add *quickly* another layer of security to existing codebase. But I am not convinced that in the long term this a right approach.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor652073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 21:16 UTC (Wed)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/652073/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Caps actually control access to facilities "above" what a normal user has, i.e. stuff that normally only root has. OpenBSD's tame() stuff otoh limits access to facilities that even normal users have, hence systemd's CapabilitiesBoundingSet= cannot cover what tame() covers.<br>
<p>
That said, I am pretty sure the tame() API is frickin' crazy, and seccomp() actually a ton more useful, especially if you use it in conjunction with some namespacing tricks like they are exposed with systemd's PrivateTmp=, ProtectSystem= or PrivateNetwork=.<br>
<p>
I find Theo's comment on seccomp controlling programs with other programs particularly weird, given the the seccomp filters are not turing complete, and hence hardly more than a fancy parameter check, and hardly something I would really call a "program".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Aren't systemd's security capabilities in userspace simpler to use?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 21:10 UTC (Thu)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/652238/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To be honest, I think it's mostly Theo's noted disdain for Linux, combined with a heaping helping of NIH syndrome.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor651939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 10:12 UTC (Wed)
                               by <b>Lionel_Debroux</b> (subscriber, #30014)
                              [<a href="/Articles/651939/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the one hand, it's a good thing that there's something simpler than SELinux and seccomp.<br>
On the one hand, it's fairly coarse-grained, and would give some false sense of security... but it's not the first time OpenBSD implements a half-measure, as outlined by spender above.<br>
<p>
Technically, why a single parameter of int type ? Two int parameters, or a 64-bit parameter, would be more future-proof.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 12:36 UTC (Wed)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/651957/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
s/as outlined by spender above/as asserted (without proof) by spender above<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 13:05 UTC (Wed)
                               by <b>spender</b> (guest, #23067)
                              [<a href="/Articles/651958/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh sorry, I forgot LWN readers require me to do all their homework for them:<br>
<p>
Everything you want to know is here: <a href="https://grsecurity.net/~spender/exploits/exp_moosecox.c">https://grsecurity.net/~spender/exploits/exp_moosecox.c</a><br>
<p>
To continue the "innovation" not mentioned there, they've recently also ripped off PAX_MPROTECT from 2001 (14 years late), labeled it "now or never exec":<br>
<a href="http://www.tedunangst.com/flak/post/now-or-never-exec">http://www.tedunangst.com/flak/post/now-or-never-exec</a><br>
with no mention anywhere of PAX_MPROTECT, despite being keenly aware of it since this famous thread: <a href="http://www.monkey.org/openbsd/archive/misc/0304/msg01146.html">http://www.monkey.org/openbsd/archive/misc/0304/msg01146....</a><br>
I guess they had to wait 12 years since that point to let their obvious hypocrisy be less visible about having to "break POSIX".<br>
<p>
With the exception of perhaps the extension of privilege separation (already demonstrated in Postfix prior to Niels Provos' paper), not one original useful idea has come out of OpenBSD in 15 years, and it's time to stop feeding the delusions of these plagiarists.<br>
<p>
-Brad<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 17:17 UTC (Wed)
                               by <b>SEJeff</b> (guest, #51588)
                              [<a href="/Articles/652018/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So I've got to ask Brad, you hate OBSD security, you hate Linux security (which is fair), what system do you use? A heavily locked down PAX / grsecurity enabled Linux distro? As much as I see you pull the rug out from under so many of these security features, generally in Linux, I'm curious what you would consider to be "secure".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 17:39 UTC (Wed)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/652022/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't know what he's using now but at the time of this LinuxFR interview (<a href="http://linuxfr.org/nodes/24807/comments/1052695">http://linuxfr.org/nodes/24807/comments/1052695</a>) he said :<br>
<p>
I know this will probably upset some of your readers, but I actually<br>
am running Windows 7 RC right now. Prior to that I had been running<br>
Windows Vista. I haven't used Linux as a primary desktop since college<br>
or so. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 18:05 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/652026/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
i'll see that interview and raise you <a href="https://microsoft.com/emet">https://microsoft.com/emet</a> ;).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 18:26 UTC (Wed)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/652032/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK I fold :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor652490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2015 19:47 UTC (Sun)
                               by <b>ploxiln</b> (subscriber, #58395)
                              [<a href="/Articles/652490/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wow... so Brad cares 100% about security features and 0% about software quality... he cares so much about security (features, apparently) that he uses WINDOWS!<br>
<p>
<p>
Just to state the obvious, MS / Windows had most "mitigation" features first, like ASLR and sandboxing, but it was just checkbox features to use for sales purposes, and didn't fix their security problems. There's always the most widely used software on the platform not opting into the security feature or opting out of it, like flash plugin having a root-level helper service to get it out of the browser sandbox, or acrobat reader not opting into ASLR (and running javascript and such), or Office's VB macros and OLE hilariousness, or font kerning scripts running in the kernel. And to top it all off it's all closed source so there's no telling how much ridiculous crap is in there, and no one but Microsoft can do anything about it. Exploits for Windows continue to appear regularly in the wild, despite the industry-leading mitigation features.<br>
<p>
Brad has good ideas, and does a lot of work to create working exploits, but has always come off as rather unbalanced in how he values different qualities of software, and wow does this confirm it. Wow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor652101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 2:55 UTC (Thu)
                               by <b>busterb</b> (subscriber, #560)
                              [<a href="/Articles/652101/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why a single int in the first iteration? I asked the same thing directly: It was a challenge in simplicity, to find the minimum that could be useful, with the implicit warning that a call with dozens of flags is going to devolve from its goal of simplicity.<br>
<p>
That said, tame is actively evolving beyond the description in this article, based on experience converting more programs to use it. It will likely take months to convert enough things in order to fully understand and refine all of the macro-level use cases.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor652108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 3:07 UTC (Thu)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/652108/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
seccomp is very simple from an application's perspective. The libseccomp API is quite nice. Some projects roll their own BPF handling code (Firefox, Chromium, rr), but that's entirely their fault.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor651960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 12:44 UTC (Wed)
                               by <b>richmoore</b> (guest, #53133)
                              [<a href="/Articles/651960/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It might be interesting to try implementing this in userspace using the linux sandbox facility.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor652034"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 18:36 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/652034/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Experimenting with other approaches makes sense, and it's *definitely* a good idea to have an easy way to declare high-level policies, but I don't see any obvious reason why tame() is written in the kernel, rather than providing a general-purpose mechanism in the kernel (whether BPF or some other way of checking syscalls and parameters), and then writing a policy in userspace.  The entirety of tame() could be written using seccomp BPF rules assembled based on the flags provided, and then submitted to the kernel.  And the next time a new flag needs adding, or someone wants to build a locked-down sandbox that doesn't exactly match what the OpenBSD kernel assumed people would want, the kernel doesn't need to change.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652034/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 20:42 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/652063/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems like Theo is too suspicious of loading user-defined code into the kernel, no matter that the BPF byte code and VM is designed to be verifiable. I'm not so averse to BPF, even when considering the possibility of bugs. It's so incredibly useful and flexible, and yet so well contained and discrete, that the complexity and risk is more than tolerable IMO.<br>
<p>
Plus, you have to be root to load the programs[1]. And OpenBSD already supports traditional BPF, anyhow. On further consideration, I'm not sure if Theo's apparent position is even defensible.<br>
<p>
[1] Or have have set PR_SET_NO_NEW_PRIVS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor652072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 21:21 UTC (Wed)
                               by <b>spender</b> (guest, #23067)
                              [<a href="/Articles/652072/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Plus, you have to be root to load the programs[1]</font><br>
<p>
This isn't true.  It's only correct for the new bpf syscall (which currently requires CAP_SYS_ADMIN) because it's a direct interface to the new eBPF code (as well as an extra "map" interface).  Unprivileged users can create sockets and attach BPF code to them, which resulted in this (once JIT was implemented): <a href="http://mainisusuallyafunction.blogspot.com/2012/11/attacking-hardened-linux-systems-with.html">http://mainisusuallyafunction.blogspot.com/2012/11/attack...</a> and then the creation of a grsecurity feature to defeat the technique, and then additional grsecurity code to harden the (at that time) writable BPF interpreter buffers, as it was previously possible to turn a linear buffer overflow into a BPF interpreter buffer into arbitrary memory read/write (and after BPF was extended with eBPF and before I hassled them enough to make the interpreter buffer read-only, easy arbitrary code execution as well).  Nowadays BPF programs written by unprivileged users get translated behind the scenes into eBPF programs, but retain the limitations imposed by the BPF language.  While "verifiable", it shouldn't be confused with "verified" -- if you've been following eBPF development you would have noticed several vulnerabilities over several architectures where the "verifiable" code wasn't acting as intended.<br>
<p>
-Brad<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor652106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Domesticating applications, OpenBSD style</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2015 3:06 UTC (Thu)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/652106/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's no use case for it without PR_SET_NO_NEW_PRIVS, so I don't see how that's a problem. It requires it because otherwise it could be abused as a way to attack setuid/setgid/setcap binaries. For example, consider a buggy program not checking the return value of setuid(...) being exploited by disallowing that system call. Note that the PR_SET_NO_NEW_PRIVS feature is only relevant at exec boundaries.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/652106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
