        <!DOCTYPE html>
        <html lang="en">
        <head><title>Flags as a system call API design pattern [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/585415/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/584511/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/585415/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Flags as a system call API design pattern</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="GAByline">
           <p>February 12, 2014</p>
           <p>This article was contributed by <a href="http://man7.org/">Michael Kerrisk</a>.</p>
           </div>
<p>
The <tt>renameat2()</tt> system
call <a href="/Articles/569134/">recently proposed</a> by Miklos
Szeredi is a fresh reminder of a category of failures in the design of
kernel-user-space APIs that has a long history on Linux (and, going
even further back, Unix). A closer look at that history yields a lesson
that should be kept in mind for all future system calls added to the
kernel.

<p>
The <tt>renameat2()</tt> system call is an extension of <tt>renameat()</tt> 
which, in turn, is an extension of the ancient
<tt>rename()</tt> system call.  All of these system calls perform the
same general task: manipulating directory entries to give an existing file a new
name on the same filesystem.

The original <tt>rename()</tt> system call took just two 
arguments: the old pathname and the new
pathname. <a
href="http://man7.org/linux/man-pages/man2/renameat.2.html"><tt>renameat()</tt></a>
added two arguments, one associated with each pathname argument.  Each
of the new arguments can be a file descriptor that refers to a
directory: if the corresponding pathname argument is relative, then it
is interpreted relative to the associated directory file descriptor,
rather than the current working directory (as is done by
<tt>rename()</tt>).

<p>
<tt>renameat()</tt> was one of a raft of thirteen new system calls
 added to Linux in kernel 2.6.16 to perform various
operations on files.  The twofold purpose of the directory file
descriptor argument is elaborated in the
<a href="http://man7.org/linux/man-pages/man2/openat.2.html#NOTES"><tt>openat(2)</tt></a>
manual page: 
<P>
<ul>
<li> to avoid race conditions that could occur with the
     corresponding traditional system calls if one of the directory
     components in a (relative) pathname was changed at the same time as
     the system call, and 
<p>
<li> to allow the implementation of per-thread "current working
     directories" via directory file descriptors.
</ul>
<p>
The next step,
<tt>renameat2()</tt>, extends the functionality of <tt>renameat()</tt>
to support a new use case: atomically <i>swapping</i> two existing
pathnames.  Although that use case is related to the earlier system
calls, it was necessary to define a new system call for one simple
reason: <tt>renameat()</tt> lacked a mechanism for the kernel to
support (and the caller to request) variations in its behavior.  In other
words, it lacked the kind of <tt>flags</tt> bit-mask argument that is
provided by system calls such
as <tt>clone()</tt>, <tt>fcntl()</tt>, <tt>mremap()</tt>,
and <tt>open()</tt>, all of which allow a varying number of arguments,
depending on the bits specified in the <tt>flags</tt> argument.

<p>
<tt>renameat2()</tt> implements the new "swap"
functionality <i>and</i> adds a new <tt>flags</tt> argument whose bits
can be used to select variations in behavior of the system call.  The
first of these bits is <tt>RENAME_EXCHANGE</tt>, which selects the
"swap" functionality; without that flag,
<tt>renameat2()</tt> behaves like
<tt>renameat()</tt>.  The addition of the <tt>flags</tt> arguments
hopefully forestalls the need to one day create a
<tt>renameat3()</tt> system call to add other new functionality.  And
indeed, Andy Lutomirski
<a href="http://thread.gmane.org/gmane.linux.file-systems/78606/focus=78843">soon
observed</a> that another flag could be
added: <tt>RENAME_NOREPLACE</tt>, to prevent a rename operation from
overwriting an existing file.  Formerly, the only race-free way of
preventing an existing file from being clobbered was to
use <tt>link()</tt> (which fails if the target pathname exists) to
create the new name, followed by <tt>unlink()</tt> to remove the old
name.
<p>
<h4>Mistakes repeated</h4>
<p>
There is, of course, a sense of <i>d&eacute;j&agrave; vu</i> about the
<tt>renameat2()</tt> story, since the reason that the earlier
<tt>renameat()</tt> system call was required was that
<tt>rename()</tt> lacked the extensibility that would have been
allowed by a <tt>flags</tt> argument.  Consideration of this example prompts
one to ask: "How many times have we made that particular mistake?"
The answer turns out to be "quite a few."

<p>
One does not need to go far to find some other examples.  Returning to
the thirteen "directory file descriptor" system calls that were added
in Linux 2.6.16, we find that, with no particular rhyme or reason, four
of the new system calls (<tt>fchownat()</tt>, <tt>fstatat()</tt>, <tt>linkat()</tt>, and
<tt>unlinkat()</tt>) added a <tt>flags</tt> argument that was not
present in the traditional call, while eight others
(<tt>faccessat()</tt>, <tt>fchmodat()</tt>, <tt>futimesat()</tt>,
<tt>mkdirat()</tt>, 
<tt>mknodat()</tt>, <tt>readlinkat()</tt>,
<tt>renameat()</tt>, and <tt>symlinkat()</tt>) did not.  (The
remaining call, <tt>openat()</tt>, retained the <tt>flags</tt>
argument that was already present in <tt>open()</tt>.)

<p>
Of the new calls that did not include a <tt>flags</tt> argument,
one, <tt>futimesat()</tt>, was soon superseded by a new call
that <i>did</i> have a <tt>flags</tt> argument (<tt>utimensat()</tt>,
added in Linux 2.6.22), and <tt>renameat()</tt> seems poised to suffer
the same fate.  One is left wondering: would any of the remaining
calls also have benefited from the inclusion of a <tt>flags</tt>
argument?  Studying this set of functions further, it is soon evident
that the answer is "yes", in at least three cases.

<p>
The first case is the <tt>faccessat()</tt> system call.  This system
call lacks a <tt>flags</tt> flags argument, but the GNU C Library
(glibc) wrapper function adds one.  If bits are specified in that
argument, then the wrapper function instead uses
the <tt>fstatat()</tt> system call to determine file access
permissions. It seems clear that the lack of a <tt>flags</tt> argument
was realized too late, and the design problem was subsequently papered
over in glibc. (The implementer of the "directory file descriptor"
system calls was the then glibc maintainer.)

<p>
The second case is the <tt>fchmodat()</tt> system call.  Like
the <tt>faccessat()</tt> system call, it lacks a <tt>flags</tt>
argument, but the glibc wrapper adds one. That wrapper function allows
for an <tt>AT_SYMLINK_NOFOLLOW</tt> flag. However, the flag is not
currently supported, because the kernel doesn't provide the necessary
support. Clearly, the glibc wrapper function was written to allow for
the possibility of an <tt>fchmodat2()</tt> system call in the future.
	 
<p>
The third case is the <tt>readlinkat()</tt> system call.
To understand why this system call would have benefited from
a <tt>flags</tt> argument, we need to consider
three of the system calls that were added in Linux 2.6.13 that do permit a
<tt>flags</tt> argument&mdash;<tt>fchownat()</tt>, <tt>fstatat()</tt>,
and <tt>linkat()</tt>. Those system calls added the
<tt>AT_EMPTY_PATH</tt> flag in Linux 2.6.39.  If this flag is
specified in the call, and the pathname argument is an empty string,
then the call instead operates on the open file referred to by the
"directory file descriptor" argument (and in this case, that argument
can refer to file types other than directories).  This allows these
system calls to provide functionality analogous to that provided by
<tt>fchmod()</tt> and <tt>fstat()</tt> in the traditional Unix API.
(There is no "<tt>flink()</tt>" in the traditional API.)

<p>
Strictly speaking, the <tt>AT_EMPTY_PATH</tt> functionality could have
been supported without the use of a flag: if the
pathname argument was an empty string, then these calls could have
assumed that they are to operate on the file descriptor
argument. However, the requirement to use a flag serves the dual
purposes of documenting the programmer's intent and preventing
accidents that might occur if the pathname argument was
unintentionally specified as an empty string.
		 
<p>
The "operate on a file descriptor" functionality also turned out to be
useful for <tt>readlinkat()</tt>, which likewise added that
functionality in Linux 2.6.39. However, <tt>readlinkat()</tt> does not
have a <tt>flags</tt> argument; the call simply operates on the file
descriptor if the pathname argument is an empty string, and thus does
not have the benefits that the <tt>AT_EMPTY_PATH</tt> flag confers on
the other system calls.  Thus <tt>readlinkat()</tt> is another system
call where a <tt>flags</tt> argument would have been desirable.
	 
<p>
In summary, then, of the eight "directory file descriptor" system
calls that lacked a <tt>flags</tt> argument, this lack has turned out
to be a mistake in at least five cases.

<p>
Of course, Linux developers were not the first to make this kind of
design error. Long before Linux appeared, there was
<tt>wait()</tt> without <tt>flags</tt> and then <tt>wait3()</tt>
with <tt>flags</tt>.  And Linux has gone on to fix some instances of
this design error in APIs inherited from Unix, adding, for
example, <tt>dup3()</tt> as a successor to <tt>dup2()</tt>, and
<tt>pipe2()</tt> as the successor to <tt>pipe()</tt> (both new system
calls added in kernel 2.6.27).

<p>
<h4>Latter-day missing-flags examples</h4> 
<p>
But, given the lessons of history, we've managed to repeat the mistake
far too many times in Linux-specific system calls. As well as the
directory file descriptor examples mentioned above, here are some
other examples:
		

<blockquote>
<table cellspacing=3>
	<tr>
	    <th align="left">Original system call&nbsp;&nbsp;</th> <th align="left">Successor</th>
	</tr>
	<tr class="Odd">
	    <td><tt>epoll_create()</tt> (2.6.0)</td> <td><tt>epoll_create1()</tt> (2.6.27)</td>
	</tr>
	<tr class="Even">
	    <td><tt>eventfd()</tt> (2.6.22)</td> <td><tt>eventfd2()</tt> (2.6.27)</td>
	</tr>
	<tr class="Odd">
	    <td><tt>inotify_init()</tt> (2.6.13)</td> <td><tt>inotify_init1()</tt> (2.6.27)</td>
	</tr>
	<tr class="Even">
	    <td><tt>signalfd()</tt> (2.6.22)</td> <td><tt>signalfd4()</tt> (2.6.27)</td>
	</tr>
</table>
</blockquote>

<p>
The realization that certain system calls might need a <tt>flags</tt>
argument sometimes comes in waves, as developers realize that multiple
related APIs may need such an argument; one such wave occurred in
Linux 2.6.13, when four of the "directory file descriptor" system
calls added a <tt>flags</tt> argument.  
	  
<p>
As can be seen from the other examples shown
just above, another such wave occurred in kernel 2.6.27, when a total
of six new system calls were added. All of these new calls, as well
as <tt>accept4()</tt>, which was added for the same reasons in Linux
2.6.28, return new file descriptors.
The main reason for the
addition of the new calls was to allow the caller the option of
requesting that the close-on-exec flag be set on the new file
descriptor at the time it is created, rather than in a separate step
using the <tt>fcntl(F_SETFD)</tt> operation. This allows user-space
applications to avoid certain race conditions when using the
traditional counterparts of these system calls in multithreaded
applications. Those races could occur when one thread tried to create a
file descriptor and use <tt>fcntl(F_SETFD)</tt> to set its
close-on-exec flag at the same time as another thread happened to
perform a <tt>fork()</tt>
plus <tt>execve()</tt>. 
	 
(The <tt>socket()</tt>
and <tt>socketpair()</tt> system calls also added this new
functionality in 2.6.27. However, somewhat bizarrely, this was done by
jamming bit flags into the high bytes of these calls' socket type
argument, rather than creating new system calls with a <tt>flags</tt>
argument.)


<p>
Turning to more recent Linux development history, we see that a number
of new system calls added since kernel 2.6.28 have all included
a <tt>flags</tt> argument,
including <tt>fanotify_init()</tt>, <tt>fanotify_mark()</tt>,
<tt>open_by_handle_at()</tt>, and <tt>name_to_handle_at()</tt>.
However, in all of those cases,
the <tt>flags</tt> argument was required at the outset, so no decision
about future-proofing this aspect of the API was required.

<p>
On the other hand, there have been some misses or near misses for
other system calls. The <tt>syncfs()</tt> system call added in Linux
2.6.39 does not have a <tt>flags</tt> argument, although one wonders
whether some filesystem developer might have taken advantage of such a
flag, if it existed, to allow the caller to vary the manner in which a
filesystem is synced to disk. And the <tt>finit_module()</tt> system
call added in Linux 3.8 only got a <tt>flags</tt> argument after
some <a href="http://thread.gmane.org/gmane.linux.kernel/1362095/focus=1374617">last
minute prompting</a>; once added, the flag
<a
href="http://thread.gmane.org/gmane.linux.kernel/1362095/focus=1379995">proved 
immediately useful</a>.
			
<p>
The conclusion from this oft-repeated pattern of creating new
incarnations of system calls that add a <tt>flags</tt> argument is
that a suitable question to ask during the design of every new system
call is: "Is there a reason <em>not</em> to include a <tt>flags</tt>
argument in the API?"  Considering the question from that perspective
is likely to more often lead developers to default to following the
wise example of the <tt>process_vm_readv()</tt>
and <tt>process_vm_writev()</tt> system calls added in Linux 3.2.  The
developers of those system calls included a (currently unused)
<tt>flags</tt> argument on the suspicion that it may prove useful in
the future. History suggests that they'll one day be proved right.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-Patterns">Development model/Patterns</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls">System calls</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Kerrisk_Michael">Kerrisk, Michael</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/585415/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor585905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 8:16 UTC (Thu)
                               by <b>blackwood</b> (guest, #44174)
                              [<a href="/Articles/585905/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So step 1 is to add a flags parameter everywhere, then step 2 is to have a testcase to check that the kernel indeed rejects still unused bits with -EINVAL. Since otherwise some userspace piece _will_ put random gunk in there, rendering your shiny new flags parameter immediately useless. At least that's been my experience with driver-private command submission interfaces for gpu drivers.<br>
<p>
So nowadays this is one of the iron rules I have when adding new ioctls. We're not yet at the "actually bother to document the ioctl" stage because this is drm and we need to protect our claim of fame ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/585905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor585915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 9:17 UTC (Thu)
                               by <b>kugel</b> (subscriber, #70540)
                              [<a href="/Articles/585915/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree, step 2 is equally important. This should be in some syscall cook book :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/585915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor586077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 17:26 UTC (Thu)
                               by <b>meuh</b> (guest, #22042)
                              [<a href="/Articles/586077/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That could be article "Botching up ioctls", by Daniel Vetter:<br>
<p>
<a href="http://blog.ffwll.ch/2013/11/botching-up-ioctls.html">http://blog.ffwll.ch/2013/11/botching-up-ioctls.html</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/586077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor585924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 10:14 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/585924/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Step 3 you need some way distinguish between mandatory flags and optional flags. So then you have to consider how to deal with that. E.g., yet another variant of the syscall, e.g. to have 2 different arguments for each set of flags?<br>
<p>
See the O_TMPFILE open fun in: <a href="https://lwn.net/Articles/558940/">https://lwn.net/Articles/558940/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/585924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor585997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 14:35 UTC (Thu)
                               by <b>kugel</b> (subscriber, #70540)
                              [<a href="/Articles/585997/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nah, O_TMPFILE is a showcase why step 2 is important and that it hasn't been done for open().<br>
<p>
Optional flags (those that you would like to be ignored if unknown or unsupport for whatever reason) should can be handled in user space, for example by retrying the syscall without the flag, without adding more measures into syscall interface.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/585997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor586007"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 15:08 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/586007/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with open() and O_TMPFILE was that the kernel treated unknown flags as optional, but an application using O_TMPFILE would want it as *mandatory*. Such an application would have no way to tell whether O_TMPFILE actually was honoured, because the open() would succeed, regardless of whether kernel recognised that flag (e.g. if you run the application on an older kernel). You can't test and retry, because open generally didn't treat unknown flags as a failure.<br>
<p>
Generally, to be able to introduce new mandatory flags, while allowing optional flags, you need either to distinguish between mandatory flags and optional in the API in some way, or you need some other way to allow the application to feature-test at runtime (but what if it forgets to do this, and then gets run on an old kernel?).  <br>
<p>
Otherwise, you need to rely on being able to find an API useage-specific hack that happens to work, as was done for open/O_TMPFILE, by also setting some other unrelated flags that *would* together cause an error on older kernels. ;) These kind of API-specific hacks might not always be available.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/586007/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor586366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 14, 2014 18:28 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/586366/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
So then you have to consider how to deal with that. E.g., yet another variant of the syscall, e.g. to have 2 different arguments for each set of flags?
</blockquote>
<p>
I'm not sure what issue this describes, but what I do when I design an interface with extra flags for forward compatibility is I add a word of flag space and declare the first half to be for mandatory flags and the second half to be for optional flags.  The recipient rejects any nonzero reserved bits in the first half and ignores any reserved bits in the second half.
<p>
The mandatory/optional flag forward compatibility issue hasn't received much attention, but it's really just a special case of a larger compatibility validation issue.  Imagine a web server written by someone who knows only Firefox and tested only with Firefox.  The server detects at run time that the browser is "Iceweasel."  The author never heard of Iceweasel.  Should the program send the Firefox-oriented data to Iceweasel and assume it is smart enough to emulate Firefox, or tell the user it doesn't know how to drive Iceweasel and avoid a possible disaster?
<p>
I know storage servers that refuse to use a SCSI disk drive of a model number not in a list with which the server is known to work.  And SCSI is a standard carefully designed to make that never necessary.  These designers, working on a system call processor, might refuse to recognize any unknown flag as optional.

      
          <div class="CommentReplyButton">
            <form action="/Articles/586366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor586399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 14, 2014 20:01 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/586399/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The recipient rejects any nonzero reserved bits in the first half and ignores any reserved bits in the second half.</font><br>
<p>
While I appreciate the elegance of this approach, it does have a major flaw: since the recipient ignores anything it doesn't recognize in the second half, senders are free to put whatever random data they want there. Later, when new optional flags are defined, these applications break.<br>
<p>
This has happened multiple times in the Linux userspace APIs, and since breaking previously-working user applications isn't allowed no matter how they abuse the APIs, you effectively can't redefine any bit you've previously ignored. If you don't require a specific value for unused bits, you won't be able to use them in any later versions. Better to just reject unrecognized bits and leave userspace to implement a fallback when the syscall fails.<br>
<p>
<font class="QuotedText">&gt; Imagine a web server written by someone who knows only Firefox and tested only with Firefox. The server detects at run time that the browser is "Iceweasel." The author never heard of Iceweasel. Should the program send the Firefox-oriented data to Iceweasel and assume it is smart enough to emulate Firefox, or tell the user it doesn't know how to drive Iceweasel and avoid a possible disaster? </font><br>
<p>
To answer that you would need a protocol specification. Doing this properly requires senders and receivers to work from the same spec. If you're just inferring one possible spec from the way you've seen Firefox behave then you can make up whatever arbitrary rules you want, so long as Firefox passes them, though it's safest to bail out early rather than continue after seeing something unexpected.<br>
<p>
Normally, of course, you'd write your web server to the HTTP specification, not a particular browser, and a browser reporting itself as "Iceweasel" is still acting within the spec and thus not giving you any reason to error out.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/586399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor586409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 14, 2014 20:34 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/586409/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How do you reject unrecognised flags while still allowing for optional flags?  <br>
<p>
That isn't really optional then. Rather, using the API becomes potentially a hand-shaking process ("let me try see if the kernel knows this new flag.. Hmm, no. What about this one ..." etc.). Better then to have a single call that lets the application query for the accepted flags once.<br>
<p>
In network protocols too, specifying unused flags as "Must Be Zero" has meant that later, when people wanted to use them, they often effectively could not (sometimes it is not possible to fall-back, there may be no opportunity to probe for supported flags). MBZ bits often end up being completely useless and wasted.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/586409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor586503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2014 11:41 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/586503/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">How do you reject unrecognised flags while still allowing for optional flags?</font></blockquote>

<p>Optional flags do not exist period. There are only “flags you don't care about” and “flags you do care about”. Think FUTEX_PRIVATE. It was added as very much “optional” flag to make pthreads faster. For pthreads implementation it's “optional” flag. But for something like <a href="https://developers.google.com/native-client/">NaCl</a> that same flag is very much a mandatory flag because it's use prevents information leaks.</p>

<blockquote><font class="QuotedText">Better then to have a single call that lets the application query for the accepted flags once.</font></blockquote>

<p>Why? “Let me try see if the kernel knows this new flag” is very simple and cheap if you do it right (take a look on GLibC—it contains dozeons of such cases).
      
          <div class="CommentReplyButton">
            <form action="/Articles/586503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor586434"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 14, 2014 22:42 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/586434/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
This has happened multiple times in the Linux userspace APIs, and since breaking previously-working user applications isn't allowed no matter how they abuse the APIs, you effectively can't redefine any bit you've previously ignored.
</blockquote>
<p>
Has this really happened with fields that are documented as "reserved for future use - must be zero" and someone put random garbage in there?
<p>
It isn't really true that you can't break previously-working user applications with new kernel code.  There are a few cases of API abuse becoming the standard that make the news because the abuse was so widespread to be worth tolerating, but I'm sure there are thousands of instances where some application bug that was innocuous in Linux N expressed itself in Linux N+1 and everyone agreed breaking the application was appropriate.
<p>
The widespread abuses usually were somewhat deliberate - it saved someone significant effort or seemed to be legal.  In contrast, failing to initialize memory is more likely to be in the rare and unforgiven category.

      
          <div class="CommentReplyButton">
            <form action="/Articles/586434/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor585948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 12:49 UTC (Thu)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/585948/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder why function for atomically swapping two existing files is renameat2() with special flag and not swapat().<br>
<p>
Using flags to completely change function semantic is a bad thing I suppose.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/585948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor585990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 14:25 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/585990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is renameat2's behavior with paths that reside on different filesystems? I'd assume it fails due to the atomicity guarantees it can no longer make. Since rename already has some restrictions in that regard, swapat sounds, to me, like it might not care by default (and would need a flag for atomicity).<br>
<p>
As for behavior change based on flags, one coworker was working with a tool which output to stdout/stderr by default, was silent with -E (no argument), but -EE took an argument for where to write the output (but just the output data from the conversion, not logging), so there's some insanity out there. I hope the kernel avoids such...behavior for a single syscall (outside of *ctl calls).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/585990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor585994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Flags as a system call API design pattern</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2014 14:31 UTC (Thu)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/585994/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I look at the escalating list of combined filesystem operations which do more and more things atomically, and I think that they surely must have considered (and rejected?) filesystem transactions? :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/585994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
