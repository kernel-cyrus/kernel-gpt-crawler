        <!DOCTYPE html>
        <html lang="en">
        <head><title>The Linux graphics stack in a nutshell, part 1 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/955376/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/955133/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/955376/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The Linux graphics stack in a nutshell, part 1</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>December 19, 2023</p>
           <p>This article was contributed by Thomas Zimmermann</p>
           </div>
<p>
Linux graphics developers often speak of <em>modern</em> Linux graphics
when they refer to  a number of individual software components and how they
interact 
with each other.
Among other things, it's a mix of kernel-managed display resources, 
Wayland for compositing, accelerated 3D rendering, and decidedly not X11.
In a two-part series, we will take a fast-paced journey
through the graphics code to see how it converts application data
to pixel data and displays it on the screen. In this installment, we look
at application rendering, Mesa internals, and the
necessary kernel features.
</p>

<h4>
Application rendering
</h4>

<p>
Graphics output starts in the application, which processes and
stores formatted data that is to be visualized.
The common data structure for visualization is the
<a href="https://en.wikipedia.org/wiki/Scene_graph">scene graph</a>, which
is 
a tree where each node stores either a model in 3D space or its
attributes. Model nodes contain the data to be visualized, such as a
game's scenery or elements of a scientific simulation. Attribute
nodes set the orientation or location of the models. Each attribute
node applies to the nodes below. To render its scene graph into an
on-screen image, an application walks the tree from top to
bottom and left to right, sets or clears the attributes and renders
the 3D models accordingly.
</p>

<p>
In the example scene graph shown below, rendering starts at the root node,
which prepares the renderer and sets the output location. The application
first takes the branch to the left and renders "Rectangle&nbsp;1" at
position (0,&nbsp;0) with the surface pattern stored in texture&nbsp;1.
The application then moves back to the root node 
and takes the branch to the right where it enters the attribute node named
"Transform". Applications describe transformations, 
such as positioning or scaling, in&nbsp;4x4 matrices that the algorithm
applies during 
the rendering process. In the example, the transform node
scales all of its child nodes by a factor of&nbsp;0.5. So rendering
"Rectangle&nbsp;2" 
and "Rectangle&nbsp;3" displays them at half their original sizes, with their
positions adjusted to (10,&nbsp;10) and (15,&nbsp;15), respectively. Both
rectangles
use different textures:&nbsp;2 and&nbsp;3, respectively.
</p>

<blockquote>
<img src="https://static.lwn.net/images/2023/scenegraph.png" class="photo" alt="[Scene graph]"
title="Scene graph">
</blockquote>


<p>
To simplify rendering and make use of hardware acceleration, most
applications utilize one of the standard APIs, such as
<a href="https://opengl.org/">OpenGL</a>
or
<a href="https://vulkan.org/">Vulkan</a>.
Details vary among the individual APIs, but each provides interfaces
to manage graphics memory, fill it with data, and render the
stored information. The result is an image that the application can
either display as-is or use as input data to further processing.
</p>

<p>
All graphics data is held in buffer objects, each of which is a
range of graphics memory with a handle or ID attached. For example,
each 3D model is stored in a
<a href="https://en.wikipedia.org/wiki/Vertex_buffer_object">vertex-buffer object</a>,
each texture is stored in a <a href="https://www.khronos.org/opengl/wiki/Texture">texture-buffer object</a>, each object's <a href="https://en.wikipedia.org/wiki/Normal_(geometry)">surface
normals</a> are stored in a buffer object, and so on. The output image
is itself <a href="https://www.khronos.org/opengl/wiki/Framebuffer_Object">stored in a buffer object</a>. So graphics rendering is, in large
part, an exercise in memory management.
</p>

<p>
The application can provide input data in any format, as long as
the graphics shader can process it. A
<a href="https://en.wikipedia.org/wiki/Shader">shader</a>
is a program that contains the instructions to transform the input
data into an output image. It is provided by the application and executed by the
graphics card.
</p>

<p>
Real-world shader programs can implement
complex, multi-pass algorithms, but for this example we break it
down to the minimum required. Probably the two most common operations
in shaders are vertex transformations and texture lookups. We can think
of a vertex as a corner of a polygon. Written in
<a
href="https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language">OpenGL
Shading Language</a> (GLSL),
transforming a vertex looks like this:
</p>

<p>
<pre>
    uniform mat4 Matrix; // same for all of a rectangles's vertices
    in vec4 inVertexCoord; // contains a different vertex coordinate on each invocation

    gl_Position = Matrix * inVertexCoord;
</pre>
</p>

<p>
The variable <tt>inVertexCoord</tt> is an input coordinate coming from the
application's scene graph. The variable <tt>gl_Position</tt>
is the coordinate within the application's output buffer. In broad terms,
the former coordinate is within the displayed scenery, while the latter is
within the application window.
<tt>Matrix</tt> is the&nbsp;4x4 matrix that describes the transformation between
the two coordinate systems. This shader operation runs for each vertex in
the scene graph. In the example of the application's scene graph of
rectangles above, <tt>inVertexCoord</tt> contains each vertex of each rectangle
at least once. The matrix <tt>Matrix</tt> then contains that vertex's
transformation, such as moving it to the correct position or scaling it by
the factor of&nbsp;0.5 as specified in the transform node.
</p>

<p>
Once the vertices are transformed to the output coordinate system, the
shader program computes the values of the covered "fragments",
which is graphics jargon for an output pixel with a depth value along the Z
axis and
maybe other information. Each fragment requires a color. In GLSL, the
shader's <tt>texture()</tt> function retrieves the color from a texture
like this:
</p>

<p>
<pre>
    uniform sampler2D Tex; // the texture object of the current rectangle
    in vec2 vsTexCoord; // interpolated texture coordinate for the fragment

    Color = texture(Tex, vsTexCoord);
</pre>
</p>

<p>
Here, <tt>Tex</tt> represents a texture buffer. The value <tt>vsTexCoord</tt>
is the texture coordinate; the position where to read within the texture.
Using both values, <tt>texture()</tt> returns a
color value. Assigning it to <tt>Color</tt> writes a colored pixel to the
output buffer. To fill the output buffer with pixel data, this shader code runs
for each individual fragment. The texture buffer is designated by the model
that is being drawn, the texture coordinate is provided by OpenGL's
internal computation. For the example scene graph, the application invokes
this code for each of the rectangles using that rectangle's texture buffer.
</p>

<p>
Running these shader instructions on the whole scene graph generates the
complete output image for the application.
</p>

<h4>
Mesa
</h4>

<p>
Nothing we have discussed so far is specific to Linux, but it gives us the
framework to look at how it's all implemented. On Linux, the
<a href="https://mesa3d.org/">Mesa&nbsp;3D</a>
library, Mesa for short, implements 3D rendering interfaces and support
for various graphics hardware. To applications, it provides OpenGL or
Vulkan for desktop graphics,
<a href="https://www.khronos.org/opengles/">OpenGL ES</a>
for mobile systems, and
<a href="https://www.khronos.org/opencl/">OpenCL</a>
for computation. On the hardware side, Mesa implements drivers for most
of today's graphics hardware.
</p>

<p>
Mesa drivers generally do not implement these application interfaces by
themselves as Mesa contains plenty of helpers and abstractions.
For stateful interfaces, such as OpenGL, Mesa's
<a href="https://www.freedesktop.org/wiki/Software/gallium/">Gallium3D</a>
framework connects interfaces and drivers
with each other. This is called a state tracker. Mesa contains
state trackers for various versions of OpenGL, OpenGL ES, and OpenCL. When the
application uses 
the API, it modifies the state tracker for the given interface.
</p>

<p>
A hardware driver within Mesa further converts the state-tracker information
to hardware state and rendering instructions.
For example, calling OpenGL's
<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTexture.xhtml"><tt>glBindTexture()</tt></a>
selects the current texture buffer within the OpenGL
state tracker. The hardware driver then installs the texture-buffer
object in graphics memory and links the active shader program to
refer to the buffer object as its texture. In our example above, the
texture becomes available as <tt>Tex</tt> in the
shader program.
</p>

<p>
Vulkan is a stateless interface, so Gallium3D is not useful
for those drivers; Mesa instead offers the <a
href="https://docs.mesa3d.org/vulkan/index.html">Vulkan runtime</a> to help
with their 
implementation. If there is a Vulkan driver available, though, there
might not be a need for Gallium3D-based OpenGL support at all for
that hardware.
<a href="https://docs.mesa3d.org/drivers/zink.html">Zink</a>
is a Mesa driver that maps Gallium3D to Vulkan. With Zink, OpenGL state
turns into Gallium3D state, which is then forwarded to hardware via standard
Vulkan interfaces. In principle, this works with any hardware's Vulkan
driver. One can imagine that future drivers within Mesa only implement
Vulkan and rely on Zink for OpenGL compatibility.
</p>

<p>
Besides Gallium3D, Mesa provides more helpers, such as winsys or GBM, to
its hardware 
drivers. Winsys wraps the details of the
window system. GBM, the Generic Buffer Manager, simplifies buffer-object
allocation.
There are also a number of shader languages, such as
GLSL
or
<a href="https://www.khronos.org/spir/">SPIR-V</a>,
available to the application.  Mesa compiles the
application-provided shader code to the "New Interface Representation" or
NIR, which Mesa drivers turn into 
hardware instructions. To get the shader instructions and the associated
data processed by Mesa's hardware acceleration, their buffer objects have
to be stored in memory locations accessible to the graphics card.
</p>

<h4>
Kernel memory management
</h4>

<p>
Any memory accessible to the graphics hardware is commonly subsumed under
the umbrella term of graphics memory; it is the graphics
stack's central resource, as all of the stack's components interact with
it. On the hardware side, graphics memory comes in a variety of
configurations that range from dedicated memory on discrete graphics
adapters to regular system memory of system-on-chip (SoC) boards. In between are
graphics chips with DMA-able or 
<a href="https://en.wikipedia.org/wiki/Shared_graphics_memory">shared graphics memory</a>,
<a
href="https://en.wikipedia.org/wiki/Graphics_address_remapping_table">graphics
address remapping table</a> (GART) memory
of discrete devices, or the so-called stolen graphics memory
of on-board graphics.
</p>

<p>
Being a system-wide resource, graphics memory is maintained by the kernel's
<a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager">Direct
Rendering Manager</a> (DRM)
subsystem. To access DRM functionality, Mesa opens
the graphics card's device file under <tt>/dev/dri</tt>, such as
<tt>/dev/dri/renderD128</tt>. As required by its
user-space counterparts, DRM exposes graphics memory in the form
of buffer objects, where each buffer object represents a slice of the
available memory.
</p>

<p>
The DRM framework provides a number of memory managers for the most
common cases. The DRM drivers for the discrete graphics cards
from AMD, NVIDIA, and (soon) Intel use the <a href="https://docs.kernel.org/gpu/drm-mm.html">Translation Table Manager</a>
(TTM). It supports discrete graphics memory, GART memory, and system memory.
TTM can move buffer objects between these areas, so if the device's
discrete memory fills up, unused buffer objects can be swapped out to
system memory.
</p>

<p>
Drivers for simple framebuffer devices often use the
SHMEM helpers, which allocate buffer objects in shared memory. Here,
regular system memory acts as a shadow buffer for the device's
limited resources. The graphics driver maintains the device's
graphics memory internally, but exposes buffer objects in system memory
to the outside. This also makes it
possible to memory-map buffer objects of devices on the USB or I2C bus,
even though these buses do not support page mappings of
device memory;  the shadow buffer can be mapped instead.
</p>

<p>
The other common
allocator, the DMA helper, manages buffer
objects in DMA-able areas of the physical memory. This design is often used
in SoC boards, where graphics chips fetch and store data via DMA operations.
Of course, DRM drivers with additional requirements have the option of extending
one of the existing memory managers or implementing their own.
</p>

<p>
The <tt>ioctl()</tt> interface for managing buffer objects is called the <a
href="https://docs.kernel.org/gpu/drm-mm.html#the-graphics-execution-manager-gem">Graphics 
Execution Manager</a> (GEM). Each DRM driver implements GEM according to its
hardware's 
features and requirements.
The GEM interface allows mapping a buffer object's memory pages to user-space
or kernel address space, allows pinning the pages at a certain location, or
exporting them to other drivers. For example, an application in user space
can get access to a buffer object's memory pages by invoking <tt>mmap()</tt>
with the
correct offset on the DRM device file's file descriptor. The call will eventually
end up in the DRM driver's GEM code, which sets up the mapping. As we will see
below, it's a useful feature for software rendering.
</p>

<p>
The one common operation that GEM does not provide is buffer allocation.
Each buffer object has a specific use case, which affects and is affected by
the object's allocation parameters, memory location, or hardware constraints.
Hence, each DRM driver offers a dedicated <tt>ioctl()</tt> operation for buffer-object
allocation that captures these hardware-specific settings. The DRM driver's
counterpart in Mesa invokes said <tt>ioctl()</tt> operation accordingly.
</p>

<h4>
Rendering operations
</h4>

<p>
Just having buffer objects for storing the output image, the input data, and
the shader programs is not enough. To start rendering, Mesa instructs DRM to
put all necessary buffer objects in graphics memory and invokes the
active shader program. It's again all specific to the hardware and provided
as <tt>ioctl()</tt> operations by each DRM driver individually. As with buffer allocation,
the hardware driver within Mesa invokes the DRM driver's <tt>ioctl()</tt> operations.
For Mesa drivers based on Gallium3D, this happens when the driver converts the
state tracker information into hardware state.
</p>

<p>
The graphics driver ideally acts only as a proxy between the application
in user space and the hardware. The hardware renderer runs asynchronously to
the rest of the graphics stack and reports back to the driver only in
case of an error or on successful completion; much like the system CPU
informs the operating system on page faults or illegal instructions. As long
as there's nothing to report, driver overhead is minimal. There are
exceptions; for example, older models of Intel graphics chips do not
support 
vertex transformations, so the driver within Mesa has to implement them in
software. On the Raspberry Pi, the kernel's DRM driver has to validate each
shader's memory access, as the VideoCore&nbsp;4 chip does not contain
an I/O MMU to isolate the shader from the system.
</p>

<h4>
Software rendering
</h4>

<p>
So far, we have assumed hardware support for graphics rendering. What if
there's no such support or the user-space application cannot use it? For
example, a user-space GUI toolkit might prefer rendering in
software because hardware-centric interfaces like OpenGL do not fit its needs.
And there's Plymouth, the program that displays the boot-up logo and prompts
for disk-encryption passwords during boot, which usually does not have a full
graphics stack available. For these scenarios, DRM offers the dumb-buffer
<tt>ioctl()</tt> interface.
</p>

<p>
By utilizing dumb buffers, an application allocates
buffer objects in graphics memory, but without support for hardware
acceleration. So any returned buffer object is only usable with software
rendering. The application in user space, such as a GUI
toolkit or Plymouth, maps the buffer object's pages into its address space
and copies over the output image. Mesa's software renderer works similarly:
the input buffer objects all live in system memory and the system CPU
processes the shader instructions. The output buffer is a dumb-buffer
object that stores the rendered image. While that's neither fast nor fancy,
it's good enough to run a modern desktop environment on simple hardware that
does not support accelerated rendering.
</p>

<p>
We have now gone through the application's graphics stack for rendering. After
having completed the traversal of the scene graph, the application's output
buffer object contains the visualized scenery or data that it wants to
display. But the buffer is not 
yet on the screen. Whether accelerated or dumb, putting the buffer on the
screen requires compositing and mode setting, which form the other half of
the graphics stack. In <a href="/Articles/955708/">part&nbsp;2</a>, we will look at Wayland
compositing, setting display modes with DRM, and a few other features of the
graphics stack.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Device_drivers-Graphics">Device drivers/Graphics</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Zimmermann_Thomas">Zimmermann, Thomas</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/955376/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor955697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2023 17:55 UTC (Tue)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/955697/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For those who are going to try Vulkan: it takes like 1000 LOC in C to hello world a triangle from scratch.<br>
Add few hundred LOC more for a textured triangle.<br>
<p>
After Vulkan you'll never look at API design the same way again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955699"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2023 20:06 UTC (Tue)
                               by <b>randomguy3</b> (subscriber, #71063)
                              [<a href="/Articles/955699/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the impression i've always had is that direct application use isn't what vulkan was designed for - and as such, how complex it is to use in that way isn't really an interesting statement on whether it is a "good" api or not<br>
<p>
the way i understand it, it would be a bit like complaining that it's hard to program in LLVM's intermediate representation - sure, but what did you expect?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955699/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2023 20:17 UTC (Tue)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/955701/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I've heard that everyone should be using some kind of 3d engine.<br>
<p>
But who is going to write 3d engine if everyone should be using one?<br>
<p>
My comment is a warning for the uninitiated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2023 22:27 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/955711/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The engines would be written by the same kind of people who write OpenGL engines. Those people would likely also take a large fraction of 1000 LOC to draw a single triangle in OpenGL, because they'd draw it with VBOs and VAOs and UBOs and MultiDrawIndirect and whatever, since that's the modern high-performance dialect of OpenGL.<br>
<p>
I think most of the verbosity of Vulkan is because it exposes the complex architecture of modern GPUs; but if you're trying to write a decent engine in OpenGL then you'll have to use various OpenGL features and extensions that similarly expose the architecture of modern GPUs, so there's not so much difference. There is a big difference in learning curves though: you need to learn quite a lot about how GPUs work before drawing that first triangle in Vulkan (but then you can steadily progress to rendering many more triangles), whereas OpenGL provides many shortcuts so you can get something onto the screen quickly (and then rewrite your code several times as you learn new concepts and realise those shortcuts were actually traps).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 12:55 UTC (Wed)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/955744/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Creating a VAO, a VBO, some shaders and generally what you need to draw a triangle in modern OpenGL (4.6, core profile) is more like 100 lines. Not 1000.<br>
<p>
AFAIU, Khronos intended for there to be some sort of middle layer for those who didn't want to use a full engine, but it never really materialized. The situation is pretty atrocious, and it means we can basically never kill OpenGL even though it doesn't get any new features.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 14:26 UTC (Wed)
                               by <b>pta2002</b> (guest, #168664)
                              [<a href="/Articles/955748/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would say it has actually materialized now though, in the form of WebGPU! It's a much nicer abstraction over Vulkan (or DX12, or Metal, depending on the OS, which are basically the same as Vulkan capability-wise), and despite the name doesn't really have to be used from the web. Namely, you can use it from most programming languages and bind to the WebGPU engines from either Chromium (dawn, written in C++) or Firefox (wgpu, written in Rust), and it'll just... work, mostly everywhere.<br>
<p>
WebGPU's API, from what people seem to say, is basically identical to Apple's Metal, which most people also seem to agree is the nicest of the three, and massively reduces the boilerplate.<br>
<p>
Took a bit, but I think we finally do have the graphics API to rule them all now :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor955822"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 16:32 UTC (Wed)
                               by <b>kolAflash</b> (subscriber, #168136)
                              [<a href="/Articles/955822/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding:<br>
<span class="QuotedText">&gt; I think most of the verbosity of Vulkan is because it exposes the complex architecture of modern GPUs;</span><br>
<p>
Hmm. Sounds like there's a higher risk, that outdated Vulkan applications might not run on newer GPUs. At least higher than it is with OpenGL or WebGL.<br>
Is that correct?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955822/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2023 5:50 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/955856/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, if future GPU architecture turns out to be drastically different from contemporary GPU, sure, there might be a lot of impedance mismatch between Vulkan and the HW.<br>
<p>
Then again, it's hard to imagine OpenGL with all its implicit state and fundamentally single threaded architecture, being a particularly good match to any conceivable future GPU architecture either, despite being a somewhat higher level interface than Vulkan. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor955872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2023 11:16 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/955872/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Not really. OpenGL comes from an era where the GPU was expected to have a lot of stateful, fixed-function hardware, and thus the only way to program it was to set the state in registers and trigger the hardware to do its thing. That's not the current direction of travel for any form of compute, and hasn't been for a long time, and we have emulated this model by having all the state live in software that sends GPU programs over to the GPU to execute.
<p>Vulkan's underlying model is of multiple execution engines processing queues of commands, where the state for each engine is stored in a block of memory, and the execution engine is responsible for managing state changes when the state pointer is changed. This is a common model for compute acceleration hardware like GPUs, because it's trivial to context-switch; change the state pointer associated with the engine, and you've changed contexts. And in practice, this also works well if your hardware is designed to be stateless; when you submit a block of work to the hardware, you include the necessary state from a software copy.
<p>Further, Vulkan's model works well if the GPU is a shared resource; you submit work in batches, and can wait for a batch to complete; the underlying drivers and hardware can choose which batches to execute when. The OpenGL model doesn't work in this case; you are expected to claim the hardware, do your graphics stuff, release the hardware.


      
          <div class="CommentReplyButton">
            <form action="/Articles/955872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor955700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2023 20:18 UTC (Tue)
                               by <b>randomguy3</b> (subscriber, #71063)
                              [<a href="/Articles/955700/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
to clarify my previous comment, i have have always understood vulkan to be basically designed as the lowest level cross-hardware interface (hence the comparison to LLVM's intermediate representation), with the assumption that you build frameworks on top of it (whether that's opengl as zink does, or a game engine, or a gui toolkit), and you do all the interesting stuff using those frameworks<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor955707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2023 22:14 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/955707/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; the way i understand it, it would be a bit like complaining that it's hard to program in LLVM's intermediate representation - sure, but what did you expect?</span><br>
<p>
I don't think this is a perfect analogy. Vulkan is actually pretty fine to program it once you've got it set up. There is just a lot to configure, because it turns out that displaying a triangle on a screen is actually an incredibly complex task. The beauty of GPUs and the Vulkan API compared to it's predecessors is that once you've done all of that work to set things up, displaying a single triangle is about as hard as displaying a billion triangles. Once you've got a triangle, it's up to you what you want to fill your buffers with.<br>
<p>
It kind of actually is like LLVM IR in that respect actually. Making a code generator that outputs the basic arithmetic instructions and control flow is a lot of work. But once you've got that, it's 90% of what you'll ever need.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 9:41 UTC (Wed)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/955733/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah I've written some code directly in WASM bytecode before because what I needed was so small it was faster to just... bang out the three dozen instructions directly into a file somewhere than setup a whole whatever-to-WASM compiler for the web project.<br>
<p>
Vulkan is nothing like that or LLVM intermediate, it's just... not hiding ANY complexity. It's like writing code for a PSX era hardware where you literally have to track EVERYTHING.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor955720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Useful levels above Vulkan</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 1:11 UTC (Wed)
                               by <b>animats</b> (guest, #168630)
                              [<a href="/Articles/955720/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Few code directly to Vulkan. <br>
<p>
I use Rend3/WGPU.  WGPU is an abstraction layer which supports Vulkan, Direct-X 11 and 12, and Apple's Metal. This is a standard 3D graphics library for Rust.<br>
<p>
Above that, you have a choice of game engines and libraries. Godot is widely used for C++ game dev. There's Bevy, for Rust game dev, and the somewhat bleeding edge Rend3, which offers a clean, safe interface for Rust 3D graphics but is not a full game engine. All open source, of course.<br>
<p>
Here's some video generated with Rend3, running on Ubuntu Linux 22.04.3 LTS with an NVidia 3070 GPU.<br>
<p>
<a rel="nofollow" href="https://video.hardlimit.com/w/tp9mLAQoHaFR32YAVKVDrz">https://video.hardlimit.com/w/tp9mLAQoHaFR32YAVKVDrz</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Useful levels above Vulkan</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 16:29 UTC (Wed)
                               by <b>kolAflash</b> (subscriber, #168136)
                              [<a href="/Articles/955820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Antarctica engine from SuperTuxKart-1.4 also has initial Vulkan support. So I guess it can also be used for building arbitrary Vulkan applications.<br>
<a href="https://www.phoronix.com/news/SuperTuxKart-1.4">https://www.phoronix.com/news/SuperTuxKart-1.4</a><br>
And there are a lot of commercial engines with Vulkan support like Unity3D or the Unreal Engine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor955721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 0:54 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/955721/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Conversely, if you're writing a complicated game, with Vulkan you will never have to deal with working around texture lifetimes and locking in the OpenGL driver. Vulkan is a very low-level API that exposes raw graphics pipelines, kinda like graphics assembly.<br>
<p>
In practice, you'll probably be using some kind of a wrapper around it (I like <a href="https://github.com/GPUOpen-LibrariesAndSDKs/V-EZ">https://github.com/GPUOpen-LibrariesAndSDKs/V-EZ</a> ) or a full-blown engine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor955726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 4:01 UTC (Wed)
                               by <b>tshow</b> (subscriber, #6411)
                              [<a href="/Articles/955726/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>&gt; For those who are going to try Vulkan: it takes like 1000 LOC in C to hello world a triangle from scratch. Add few hundred LOC more for a textured triangle.

<p>Vulkan <i>is</i> very verbose, but a lot of this can be mitigated with some macro magic if you're using relatively recent C (and if you're building for Vulkan, why wouldn't you be?).  There's a bunch of pure boilerplate you can macro away.

<p>In particular, a lot of the functions take pointers to structures as arguments.  This means you wind up doing a lot of:

<pre>
vkCreateFoo(&amp;(VkFooCreateInfo)
    {
      .sType  = VK_STRUCTURE_TYPE_FOO,
      .thing  = VK_TRUE,
      .answer = 42
    });
</pre>

<p>In my game engine I've got <tt>#defines</tt> of the form:

<pre>
#define STVK(_name, _type) &amp;(Vk##_name) { .sType = VK_STRUCTURE_TYPE_##_type
#define ARG_VkFooCreateInfo(...) STVK(FooCreateInfo, FOO_CREATE_INFO), __VA_ARGS__ }
</pre>

<p>The above could be done without the <tt>STVK()</tt> macro by expanding it inline in the <tt>ARG_</tt> macro, but unless you're going to autogenerate the macros (say, with a ruby script that greps <tt>vulkan_core.h</tt> for <tt>VK_STRUCTURE_TYPE</tt>...) it's less prolix to have the helper macro.

<p>With that, the call becomes:

<pre>
vkCreateFoo(ARG_VkFooCreateInfo(.thing = VK_TRUE, .answer = 42));
</pre>

<p>or if you like maximal vertical spread:

<pre>
vkCreateFoo(
  ARG_VkFooCreateInfo(
    .thing  = VK_TRUE,
    .answer = 42
  )
);
</pre>

<p>I'm simplifying a bit (most vulkan calls want an allocator pointer, for instance, though you can probably macro that away too unless you plan to use different allocators in different places), but the macro scheme above gets rid of a lot of the boilerplate and makes the code a lot easier to read, IMO.  Particularly when you get to things like <tt>vkCreateGraphicsPipeline()</tt> which takes very large structures.

<p>There's a lot of other places you can do that as well.  For example, are you planning to have custom names for your shader entry points?  If not, you can macro <tt>.pName = "main"</tt> into all your <tt>VkPipelineShaderStageCreateInfo</tt> structures.

<p>You can also clean things up a <i>lot</i> by remembering that when you init a structure inline in C, all members not explicitly mentioned are zeroed, so if you have any lines like <tt>.flags = 0,</tt> (hint: you do; there are a lot of flag fields with no flags defined yet in Vulkan...) you can get rid of them unless you think it's needed for clarity.

<p>Being low level, Vulkan gives you a lot of flexibility you'll probably never use.  Nailing down the bits you won't care about in macros behind the scenes makes it much simpler to work with, though I obviously advise heavily documenting your macros wherever they live in case your assumptions change.



      
          <div class="CommentReplyButton">
            <form action="/Articles/955726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 10:25 UTC (Wed)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/955736/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I ended up not doing macrology. With IDE autocompletion verbosity it slightly less of a problem.<br>
<p>
It is just that "ha-ha-ha you forgot to set VkPipelineColorBlendAttachmentState::blendEnable -- enjoy black screen."<br>
<p>
What about rasterizerDiscardEnable?<br>
<p>
What about "get physical device which this X instance is running at?".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 10:35 UTC (Wed)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/955737/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Article is about modern graphics stack. X is not a part of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 10:47 UTC (Wed)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/955738/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Vulkan initialisation requires enumerating physical devices, picking one, and then creating logical device to issue commands.<br>
<p>
Now imagine there are 2 GPUs in the system, one is connected to monitor with X running, and the other one is not. There is fake Mesa llvmpipe device lying around too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor955750"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 14:42 UTC (Wed)
                               by <b>makendo</b> (guest, #168314)
                              [<a href="/Articles/955750/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; There is fake Mesa llvmpipe device lying around too.</span><br>
<p>
Lavapipe should identify itself as a software renderer (VK_PHYSICAL_DEVICE_TYPE_CPU), which can help a lot in kicking it away.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955750/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor956067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 23, 2023 13:39 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/956067/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The answer seems to be:<br>
<p>
Enumerate queue family properties, at least one of them will be able to present to the window surface<br>
(vkGetPhysicalDeviceSurfaceSupportKHR will report Supported == VK_TRUE).<br>
<p>
All other GPUs driving or not driving other X servers will not be able to Present to the surface.<br>
<p>
Which is good enough.<br>
<p>
qfp 0 G 1, P 0    &lt;= no cookie<br>
qfp 1 G 0, P 0<br>
qfp 2 G 0, P 0<br>
qfp 3 G 0, P 0<br>
<p>
qfp 0 G 1, P 1    &lt;= GPU which shows the window<br>
qfp 1 G 0, P 0<br>
qfp 2 G 0, P 1<br>
qfp 3 G 0, P 0<br>
<p>
I must say, this is simple and not simple at the same time. Every single tutorial assumes 1 GPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/956067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor956068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 23, 2023 13:52 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/956068/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK, this is funny. lavapipe is here, ready to help. Filtering by GPU type is required apparently:<br>
<p>
# 1070 (active)<br>
qfp 0 G 1, P 1  ***<br>
qfp 1 G 0, P 0<br>
qfp 2 G 0, P 1<br>
qfp 3 G 0, P 0<br>
<p>
# 1030 (passive)<br>
qfp 0 G 1, P 0<br>
qfp 1 G 0, P 0<br>
qfp 2 G 0, P 0<br>
qfp 3 G 0, P 0<br>
<p>
(lavapipe)<br>
qfp 0 G 1, P 1 ***        # P=1 !!!<br>
-p 0    NVIDIA GeForce GTX 1070<br>
-p 1    NVIDIA GeForce GT 1030<br>
-p 2    llvmpipe (LLVM 16.0.6, 256 bits)<br>
<p>
Enumeration order varies by distro too!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/956068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960544"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 8:34 UTC (Fri)
                               by <b>daenzer</b> (subscriber, #7050)
                              [<a href="/Articles/960544/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Enumeration order varies by distro too!</span><br>
<p>
The enumeration order isn't well-defined, and in practice partially depends on the order in which the filesystem enumerates the corresponding *_icd.*.json files (which isn't well-defined either). So the order may differ between otherwise mostly identical systems with the same set of VkPhysicalDevices, and may change after modifications to the *_icd.*.json files.<br>
<p>
Unfortunately, many (most?) Vulkan applications just use the first enumerated device by default. To prevent such apps from accidentally using an undesirable device such as a lavapipe one, Mesa ships a device selection layer which moves the "default" device to be enumerated first.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960544/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor955712"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2023 22:40 UTC (Tue)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/955712/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice overview, lookiing forward to part 2.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955712/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor955724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 3:18 UTC (Wed)
                               by <b>timrichardson</b> (subscriber, #72836)
                              [<a href="/Articles/955724/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Appreciate this article. Good summer reading (for me).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor955739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2023 10:55 UTC (Wed)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/955739/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A big thank you for the article! A year of lwn subscription just got paid off completely. There was almost no introductory overview of it, and you did it.<br>
<p>
Thank you very much.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor955965"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Linux graphics stack in a nutshell, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2023 20:09 UTC (Thu)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/955965/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Author here. Thanks for the kind replies and the interesting discussion. On the topic of Vulkan, I have to admit that I preferred OpenGL for the article's examples, as it's much easier. Dealing with Vulkan's complexity probably makes sense for AAA games or the high-profile 3d engines that need the additional control and performance over GL. For other software, the trade-off might be different.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/955965/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
