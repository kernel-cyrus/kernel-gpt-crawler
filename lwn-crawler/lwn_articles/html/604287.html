        <!DOCTYPE html>
        <html lang="en">
        <head><title>Anatomy of a system call, part 1 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/604287/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/604218/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/604287/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Anatomy of a system call, part 1</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>July 9, 2014</p>
           <p>This article was contributed by David Drysdale</p>
           </div>
<p>
      System calls are the primary mechanism by which user-space programs
      interact with the Linux kernel.  Given their importance, it's not
      surprising to discover that the kernel includes a wide variety of
      mechanisms to ensure that system calls can be implemented generically
      across architectures, and can be made available to user space in an
      efficient and consistent way.
    </p>

    <p>
      I've been <a href="/Articles/603929/">working</a>
      on <a href="/Articles/604015/">getting</a> FreeBSD's <a
      href="http://www.freebsd.org/cgi/man.cgi?query=capsicum&sektion=4">Capsicum
      security framework</a> onto Linux and, as this involves the
      addition of several new system calls
      (including the slightly unusual <a
      href="/Articles/601378/"><tt>execveat()</tt> system call</a>), I
      found myself investigating the details of their implementation.
      As a result, this is the first of a pair of articles that explore the
      details of the kernel's implementation of system calls (or syscalls).
      In this 
      article we'll focus on the mainstream case: the mechanics of a normal
      syscall (<tt>read()</tt>), together with the machinery that allows
      x86_64 user programs to invoke it.  The second article
      will move off the mainstream case to cover more unusual syscalls, and
      other 
      syscall invocation mechanisms.
    </p>

<p>
System calls differ from regular function calls because the code
being called is in the kernel. Special instructions are needed to make
the processor perform a transition to ring 0 (privileged mode). In
addition, the 
kernel code being 
invoked is identified by a syscall number, rather than by a function address.
</p>


    <h4>Defining a syscall with <tt>SYSCALL_DEFINE<i>n</i>()</tt></h4>

    <p>The <tt>read()</tt> system call provides a good initial example to explore the kernel's syscall machinery.
      It's implemented in <a href="https://elixir.bootlin.com/linux/v3.14/source/fs/read_write.c#L511"><tt>fs/read_write.c</tt></a>, as a
      short function that passes most of the work to <tt>vfs_read()</tt>. From an invocation standpoint the most
      interesting aspect of this code is way the function is defined using the <tt>SYSCALL_DEFINE3()</tt> macro.  Indeed,
      from the code, it's not even immediately clear what the function is called.
    </p>
<pre>
    SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
    {
    	struct fd f = fdget_pos(fd);
    	ssize_t ret = -EBADF;
    	/* ... */
</pre>
    <p>
      These <tt>SYSCALL_DEFINE<i>n</i>()</tt> macros are the standard way for kernel code to define a system call,
      where the <tt><i>n</i></tt> suffix indicates the argument count.  The definition of these macros
      (in <a href="https://elixir.bootlin.com/linux/v3.14/source/include/linux/syscalls.h#L175"><tt>include/linux/syscalls.h</tt></a>)
      gives two distinct outputs for each system call.
    </p>
<pre>
    SYSCALL_METADATA(_read, 3, unsigned int, fd, char __user *, buf, size_t, count)
    __SYSCALL_DEFINEx(3, _read, unsigned int, fd, char __user *, buf, size_t, count)
    {
    	struct fd f = fdget_pos(fd);
    	ssize_t ret = -EBADF;
    	/* ... */
</pre>
    <p>
      The first of these, <tt>SYSCALL_METADATA()</tt>, builds a collection of metadata about the system call for tracing
      purposes. It's only expanded when
      <a href="https://elixir.bootlin.com/linux/v3.14/source/kernel/trace/Kconfig#L238"><tt>CONFIG_FTRACE_SYSCALLS</tt></a> is defined for the kernel
      build, and its expansion gives boilerplate definitions of data that describes the syscall and its
      parameters. (A <a href="/Articles/604406/">separate page</a> describes these definitions in more detail.)
    </p>
    <p>
      The <a href="https://elixir.bootlin.com/linux/v3.14/source/include/linux/syscalls.h#L187"><tt>__SYSCALL_DEFINEx()</tt></a> part is more interesting, as it
      holds the system call implementation.  Once the various layers of macros and
      <a href="http://gcc.gnu.org/onlinedocs/gcc/Typeof.html#Typeof">GCC type extensions</a> are expanded, the resulting
      code includes some interesting features:
    </p>
<pre>
    asmlinkage long sys_read(unsigned int fd, char __user * buf, size_t count)
    	__attribute__((alias(__stringify(SyS_read))));

    static inline long SYSC_read(unsigned int fd, char __user * buf, size_t count);
    asmlinkage long SyS_read(long int fd, long int buf, long int count);

    asmlinkage long SyS_read(long int fd, long int buf, long int count)
    {
    	long ret = SYSC_read((unsigned int) fd, (char __user *) buf, (size_t) count);
    	asmlinkage_protect(3, ret, fd, buf, count);
    	return ret;
    }

    static inline long SYSC_read(unsigned int fd, char __user * buf, size_t count)
    {
    	struct fd f = fdget_pos(fd);
    	ssize_t ret = -EBADF;
    	/* ... */
</pre>
    <p>
      First, we notice that the system call implementation actually has the name <tt>SYSC_read()</tt>, but
      is <tt>static</tt> and so is inaccessible outside this module.  Instead, a wrapper function,
      called <tt>SyS_read()</tt> and
      <a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">aliased</a> as <tt>sys_read()</tt>, is visible
      externally.  Looking closely at those aliases, we notice a difference in their parameter types
      &mdash; <tt>sys_read()</tt> expects the explicitly declared types
    (e.g. <tt>char __user *</tt> for the second argument),
      whereas <tt>SyS_read()</tt> just expects a bunch of (long) integers.  Digging into
      the <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1a94bc34768e463a93cb3751819709ab0ea80a01">history</a>
      of this, it turns out that the <tt>long</tt> version ensures that 32-bit values are correctly sign-extended for
      some 64-bit kernel platforms, preventing a historical
      <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0029">vulnerability</a>.
    </p>
    <p>
      The last things we notice with the <tt>SyS_read()</tt> wrapper are
    the <tt>asmlinkage</tt> directive
      and <tt>asmlinkage_protect()</tt> call.  The <a href="http://kernelnewbies.org/FAQ/asmlinkage">Kernel Newbies
      FAQ</a> helpfully explains that <tt>asmlinkage</tt> means the function should expect its arguments on the stack
      rather than in registers, and the <a href="https://elixir.bootlin.com/linux/v3.14/source/include/linux/linkage.h#L51">generic definition</a> of
      <tt>asmlinkage_protect()</tt> explains that it's used to prevent the
    compiler from assuming that it can safely reuse
  those areas of the stack.
    </p>
    <p>
      To accompany the definition of <tt>sys_read()</tt> (the variant with accurate types), there's also a
      <a href="https://elixir.bootlin.com/linux/v3.14/source/include/linux/syscalls.h#L545">declaration</a> in <tt>include/linux/syscalls.h</tt>, and this
      allows other kernel code to call into the system call implementation directly (which happens in
      <a href="http://lxr.free-electrons.com/ident;i=sys_read">half
    a dozen places</a>).  Calling system calls directly from elsewhere in the kernel is
    generally discouraged and is not often seen.
    </p>

    <h4>Syscall table entries</h4>
    <p>
      Hunting for callers of
      <a href="http://lxr.free-electrons.com/ident;i=sys_read"><tt>sys_read()</tt></a>
      also points the way toward how user space reaches this function.  For "generic" architectures that don't provide
      an override of their own, the <tt>include/uapi/asm-generic/unistd.h</tt> file includes an
      <a href="https://elixir.bootlin.com/linux/v3.14/source/include/uapi/asm-generic/unistd.h#L199">entry</a> referencing <tt>sys_read</tt>:
    </p>
<pre>
    #define __NR_read 63
    __SYSCALL(__NR_read, sys_read)
</pre>
    <p>
      This defines the generic syscall number <tt>__NR_read</tt> (63) for <tt>read()</tt>, and uses
      the <tt>__SYSCALL()</tt> macro to associate that number with <tt>sys_read()</tt>, in an architecture-specific way.
      For example, arm64
      uses the <tt>asm-generic/unistd.h</tt> header file to
      <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/arm64/kernel/sys.c#L53">fill out a table</a> that maps syscall
      numbers to implementation function pointers.
    </p>
    <p>
      However, we're going to concentrate on the x86_64 architecture, which does not use this generic table.
      Instead, x86_64 defines its own mappings in <tt>arch/x86/syscalls/syscall_64.tbl</tt>,
      which has an
      <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/syscalls/syscall_64.tbl#L9">entry</a> for <tt>sys_read()</tt>:
    </p>
<pre>
    0	common	read			sys_read
</pre>
    <p>
      This indicates that <tt>read()</tt> on x86_64 has syscall number 0
      (not 63), and has a <tt>common</tt> implementation for
      both of the ABIs for x86_64, namely <tt>sys_read()</tt>. (The
    different ABIs will be discussed in the second part of this series.)
The <a
    href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/syscalls/syscalltbl.sh"><tt>syscalltbl.sh</tt></a> 
  script generates <tt>arch/x86/include/generated/asm/syscalls_64.h</tt>
  from the <tt>syscall_64.tbl</tt> table, specifically generating
  an invocation of the <tt>__SYSCALL_COMMON()</tt> macro
  for <tt>sys_read()</tt>.  This header file is used, in turn, to
  populate the syscall table,
      <tt>sys_call_table</tt>, which is the key data structure that maps syscall numbers to <tt>sys_<i>name</i>()</tt>
      functions.
    </p>


    <h4>x86_64 syscall invocation</h4>
    <p>
      Now we will look at how user-space programs invoke the system call.  This is inherently
      architecture-specific, so for the rest of this article we'll concentrate on the x86_64 architecture
      (other x86 architectures will be examined in the second article of the series).  The invocation process
      also involves a few steps, so a clickable diagram, seen at left, may help with the navigation.
    </p>
    <img src="https://static.lwn.net/images/2014/syscall_x86_64.png" usemap="#syscall_x86_64"
    align="left" alt="[System call diagram]"/>
<map id="syscall_x86_64" name="syscall_x86_64">
<area shape="rect" id="node2" href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/entry_64.S#L593" title="system_call()\nkernel/entry_64.S" alt="" coords="38,211,164,259"/>
<area shape="poly" id="edge1" href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/cpu/common.c#L1134" title="Via MSR for\nMSR_LSTAR" alt="" coords="104,106,104,197,99,197,99,106"/>
<area shape="rect" id="edge1-label" href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/cpu/common.c#L1134" title="Via MSR for\nMSR_LSTAR" alt="" coords="101,129,183,159"/>
<area shape="rect" id="node3" href="https://elixir.bootlin.com/linux/v3.14/source/fs/read_write.c#L511" title="sys_read()\nfs/read_write.c" alt="" coords="47,364,156,412"/>
<area shape="poly" id="edge2" href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/syscalls/syscall_64.tbl#L9" title="sys_call_table\n[0]" alt="" coords="104,259,104,350,99,350,99,259"/>
<area shape="rect" id="edge2-label" href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/syscalls/syscall_64.tbl#L9" title="sys_call_table\n[0]" alt="" coords="101,283,185,312"/>
</map>

    <p>In the previous
      section, we discovered a table of system call function pointers;
      <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/syscall_64.c#L25">the table for x86_64</a> looks
      something like the following (using a
      <a href="http://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">GCC
        extension for array initialization</a>
      that ensures any missing entries point to <tt>sys_ni_syscall()</tt>):</p>
<pre>
    asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
    	[0 ... __NR_syscall_max] = &amp;sys_ni_syscall,
    	[0] = sys_read,
    	[1] = sys_write,
    	/*... */
    };
</pre>
    <p>
      For 64-bit code, this table is accessed
      from <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/entry_64.S#L629"><tt>arch/x86/kernel/entry_64.S</tt></a>, from
      the <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/entry_64.S#L593"><tt>system_call</tt></a> assembly entry point; it uses
      the RAX register to pick the relevant entry in the array and then calls it.  Earlier in the function, the
      <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/include/asm/calling.h#L88"><tt>SAVE_ARGS</tt></a> macro pushes various registers onto
      the stack, to match the <tt>asmlinkage</tt> directive we saw earlier.
    </p>
    <p>
      Moving outwards, the <tt>system_call</tt> entry point is itself
      <a
      href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/cpu/common.c#L1134">referenced</a> in <tt>syscall_init()</tt>, a function that is
      <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/kernel/cpu/common.c#L1277">called</a> early in the kernel's startup sequence:
    </p>
<pre>
    void syscall_init(void)
    {
    	/*
    	 * LSTAR and STAR live in a bit strange symbiosis.
    	 * They both write to the same internal register. STAR allows to
    	 * set CS/DS but only a 32bit target. LSTAR sets the 64bit rip.
    	 */
    	wrmsrl(MSR_STAR,  ((u64)__USER32_CS)&lt;&lt;48  | ((u64)__KERNEL_CS)&lt;&lt;32);
    	wrmsrl(MSR_LSTAR, system_call);
    	wrmsrl(MSR_CSTAR, ignore_sysret);
    	/* ... */
</pre>
    <p>
      The <tt>wrmsrl</tt> instruction writes a value to a
      <a href="http://wiki.osdev.org/Model_Specific_Registers">model-specific register</a>; in this case, the address of
      the general <tt>system_call</tt> syscall handling function is written to register
      <a href="https://elixir.bootlin.com/linux/v3.14/source/arch/x86/include/uapi/asm/msr-index.h#L9"><tt>MSR_LSTAR</tt></a> (0xc0000082),
      which is the x86_64 model-specific register for handling the <tt>SYSCALL</tt> instruction.
    </p>
    <p>
      And this gives us all we need to join the dots from user space to the kernel code.  The standard ABI for how x86_64 user programs
      invoke a system call is to put the system call number (0 for <tt>read</tt>) into the RAX register, and
      the other parameters into specific registers (RDI, RSI, RDX for the first 3 parameters), then issue the
      <tt>SYSCALL</tt> instruction.  This instruction causes the processor to transition to ring 0 and invoke the code
      referenced by the <tt>MSR_LSTAR</tt> model-specific register &mdash; namely <tt>system_call</tt>.
      The <tt>system_call</tt> code pushes the registers onto the kernel stack, and calls the function pointer at
      entry RAX in the <tt>sys_call_table</tt> table &mdash; namely <tt>sys_read()</tt>, which is a
      thin, <tt>asmlinkage</tt> wrapper for the real implementation in <tt>SYSC_read()</tt>.
   </p>

<p>
Now that we've seen the standard implementation of system calls
on the most common platform, we're in a better position to
understand what's going on with other architectures, and with less-common cases.  That will be the subject of the second article in
the series.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls">System calls</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#User-space_API">User-space API</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Drysdale_David">Drysdale, David</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/604287/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor604971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bravo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 12:56 UTC (Thu)
                               by <b>smitty_one_each</b> (subscriber, #28989)
                              [<a href="/Articles/604971/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bravo, thank you, and may Fortune smile on your day, Drysdale.<br>
This is precisely the sort of well-written intermediate material that is needed to help<br>
(a) the n00bs like me, and<br>
(b) the ninjas who haven't reviewed it lately.<br>
More of this!<br>
Cheers,<br>
Chris<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/604971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor605053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Calling syscalls from the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2014 22:21 UTC (Thu)
                               by <b>bourbaki</b> (guest, #84259)
                              [<a href="/Articles/605053/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hello David,<br>
<p>
Thanks for this article, it looks like the start of a very promising series. I have question though, that you or other kernel hackers may answer :<br>
<p>
<font class="QuotedText">&gt; Calling system calls directly from elsewhere in the kernel is generally discouraged and is not often seen.</font><br>
<p>
I have searched about this a bit but couldn't find a specific reason for why it's "generally discouraged". Could someone enlighten me ?<br>
<p>
Thanks<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Calling syscalls from the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 11:33 UTC (Fri)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/605109/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One general principal reason would be, that lower layer software, breaking out and calling higher layer software, turns a "calling tree" into a "network graph", much harder to analyse and reason about it's performance.<br>
<p>
More simply, a system call is designed for user space interaction, in general something in kernel, ought to be using an in-kernel service, rather than re-purposing a user space interface.<br>
<p>
[ As noone answered this question yet ]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Calling syscalls from the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2014 9:33 UTC (Mon)
                               by <b>drysdale</b> (guest, #95971)
                              [<a href="/Articles/605331/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's roughly my understanding too.  System calls typically check all their (user-provided) arguments carefully, and also copy any needed chunks of memory from __user * pointers -- all of which is inefficient for internal usage.  So it's more common to have an inner function that the rest of the kernel calls, and the syscall wraps.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Calling syscalls from the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2014 14:32 UTC (Wed)
                               by <b>YogeshC</b> (guest, #49966)
                              [<a href="/Articles/606234/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In that case, why has this particular syscall been used in half a dozen places inside the kernel? Is there any specific (or general) reason(s) for read/write syscalls to be called from within the kernel space on so many occasions?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor608365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Calling syscalls from the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2014 12:45 UTC (Mon)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/608365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      No one answered your question so I'll have a go.
<p>
The main user of sys_read at the moment is the code for unpacking the initramfs.  You could imagine this "should" be done by a userspace process, because it's doing a lot of userspace-type stuff, like uncompressing a cpio file and then creating a tree of directories and files from it.  It's nearly the equivalent of running:
<pre>
  zcat initramfs | cpio -id
</pre>
However because the initramfs is needed before userspace is up -- because creating the initramfs <i>is</i> creating the initial userspace -- they have to do this userspace-type stuff in the kernel instead.
<p>
So it's a layering violation, but for understandable reasons.
      
          <div class="CommentReplyButton">
            <form action="/Articles/608365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor605088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 9:01 UTC (Fri)
                               by <b>geuder</b> (guest, #62854)
                              [<a href="/Articles/605088/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you for the very detailed description. Occasionnally I had to track down (parts of) this from the source for debugging some issue and it can be very tedious.<br>
<p>
A little detail, but a nuisance for humans, especially if you debug an emebedded target and compare to your desktop known to work correctly: What is the technical reason to have partially architecture specific syscall number? Passing a number in a register does not look like anything inherently architecture specific.<br>
<p>
If you quickly need to see the syscall numbers for a given architecture I have seen the hint to look at strace source. I'm just at my phone now, so I don't compare the source now, but I vaguely remember it was indeed easier to navigate than the kernel source proper. Was it so that strace distributes ready lists while for the kernel they need to be built for each architecture?  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 9:53 UTC (Fri)
                               by <b>sasha</b> (guest, #16070)
                              [<a href="/Articles/605099/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What is the technical reason to have partially architecture specific syscall number?</font><br>
<p>
For "compatibility" with other, older OSes used on the architecture.  No, I do not understand what kind of "compatibility" you can get in such a way, but it is the main reason.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 16:55 UTC (Fri)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/605185/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I believe by now the reason is mainly historical.<p>
Originally (in the days of Linux 1.x / 2.0) Linux attempted to be binary compatible to existing Unices on common hardware (the <tt>personality(2)</tt> system call is also part of this). As time passed, compatibility with other Unices became mostly a non-issue&nbsp;&ndash; but now we do need to maintain binary compatibility with older Linux binaries&hellip;
      
          <div class="CommentReplyButton">
            <form action="/Articles/605185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 22:12 UTC (Fri)
                               by <b>geuder</b> (guest, #62854)
                              [<a href="/Articles/605201/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Originally (in the days of Linux 1.x / 2.0) Linux attempted to be binary compatible to existing Unices on common hardware</font><br>
<p>
That sounds like a reasonable explanation. Besides that back in those days what Unices were running on x86_64 and ARM? And these 2 differ. Yeah well, maybe the dependencies are not direct, but somehow indirect over other platforms?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2014 22:22 UTC (Fri)
                               by <b>sfeam</b> (subscriber, #2841)
                              [<a href="/Articles/605204/">Link</a>] 
      </p>
      
      </div>
      </summary>
      As I recall, linux binaries for alpha would run under Digital Unix on alpha.
      
          <div class="CommentReplyButton">
            <form action="/Articles/605204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor605262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2014 0:00 UTC (Sun)
                               by <b>gb</b> (subscriber, #58328)
                              [<a href="/Articles/605262/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why such a strange implementation taken - put values into registers, switch to ring 0, than put this values into stack? Isn't it make more sense to keep values in the registers till real syscall function which may, if it wants, push values to the stack?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2014 9:45 UTC (Mon)
                               by <b>drysdale</b> (guest, #95971)
                              [<a href="/Articles/605332/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
Having the arguments in registers for the ring transition means that there's no need for fancy footwork to get at the userspace stack memory (compare the innards of <tt>copy_from_user()</tt>).
<p>
Storing the registers on the kernel stack allows the state of the registers to be restored on the return to userspace.  But once the parameters are available on the stack, there's no need to preserve them in the registers too &ndash; the syscall can get its arguments from the stack (i.e. be <tt>asmlinkage</tt>) and can immediately use (and clobber) the registers.
      
          <div class="CommentReplyButton">
            <form action="/Articles/605332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor605636"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2014 17:03 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/605636/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite. Keeping the args on the stack is a non-starter: userspace stacks are swappable, and you *don't* want to have to go checking to see if the args have been swapped out in the instant of ring transition: it's the sort of terribly narrow race that leads to code that rots and then silently breaks in almost-impossible-to-debug ways, and for almost no gain.<br>
<p>
But obviously the args have to end up on the stack -- or, rather, have to end up whereever the C ABI for the platform says they should (possibly optimized by asmlinkage, but still, something the compiler supports).<br>
<p>
Thanks for this article: I too have wasted entirely too much time tracking this down in pieces now and then: it's nice to have a reference here for next time. Looking forward to the next one.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/605636/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor801054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Broken link</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 2:34 UTC (Wed)
                               by <b>emceeMC</b> (guest, #134734)
                              [<a href="/Articles/801054/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Your link to <a rel="nofollow" href="http://lxr.free-electrons.com/source/fs/read_write.c?v=3.14#L511"> fs/read_write.c</a>  (http://lxr.free-electrons.com/source/fs/read_write.c?v=3.14#L511) is broken :(

      
          <div class="CommentReplyButton">
            <form action="/Articles/801054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Broken link</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 2:35 UTC (Wed)
                               by <b>emceeMC</b> (guest, #134734)
                              [<a href="/Articles/801056/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Consider replacing it with <a rel="nofollow" href="https://elixir.bootlin.com/linux/v3.14.79/source/fs/read_write.c#L511">this</a>.

      
          <div class="CommentReplyButton">
            <form action="/Articles/801056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2020 12:55 UTC (Thu)
                               by <b>vishwajith_k</b> (guest, #140997)
                              [<a href="/Articles/829658/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I could not find implementation for a syscall named clock_nanosleep;<br>
As per this article, name used to implement must be sys_clock_nanosleep, but I found some header files when searched for this identifier (used <a rel="nofollow" href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a> site); Am using arm64 machine and syscall number must be 115.<br>
Can you help me?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Anatomy of a system call, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2020 21:14 UTC (Thu)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/829734/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s in kernel/time/posix-stubs.c :<br>
<p>
SYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,<br>
		const struct __kernel_timespec __user *, rqtp,<br>
		struct __kernel_timespec __user *, rmtp)<br>
{<br>
....<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
