        <!DOCTYPE html>
        <html lang="en">
        <head><title>RCU part 3: the RCU API [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/264090/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/263717/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/264090/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>RCU part 3: the RCU API</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="GAByline">
           <p>January 7, 2008</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
[<i>Editor's note: this is the third and final installment in Paul
McKenney's "What is RCU?" series.  The <a
href="http://lwn.net/Articles/262464/">first</a> and <a
href="http://lwn.net/Articles/263130/">second</a> parts remain available
for those who might have missed them.  Many thanks to Paul for letting LWN
run these articles.</i>]
<p>

<h3>Introduction</h3>

<P>Read-copy update (RCU) is a synchronization mechanism that was added to
the Linux kernel in October of 2002.
RCU is most frequently described as a replacement for reader-writer locking,
but has also been used in a number of other ways.
RCU is notable in that RCU readers do not directly synchronize with
RCU updaters,
which makes RCU read paths extremely fast, and also
permits RCU readers to accomplish useful work even
when running concurrently with RCU updaters.

<P>This leads to the question "what exactly is RCU?", a question that this
document addresses from the viewpoint of the Linux kernel's RCU API.

<OL>
<LI>	<A HREF="#RCU has a Family of Wait-to-Finish APIs">
	RCU has a Family of Wait-to-Finish APIs</A>
<p>
<LI>	<A HREF="#RCU has Publish-Subscribe and Version-Maintenance APIs">
	RCU has Publish-Subscribe and Version-Maintenance APIs</A>
<p>
<LI>	<A HREF="#So, What is RCU Really?">
	So, What is RCU Really?</A>
</OL>

<P>These sections are followed by a
<A HREF="#References">references</A> section and the
<A HREF="#Answers to Quick Quizzes">answers to the Quick Quizzes</A>.

</p><h3><A NAME="RCU has a Family of Wait-to-Finish APIs">
RCU has a Family of Wait-to-Finish APIs</A></h3>

<P>The most straightforward answer to "what is RCU" is that RCU is
an API used in the Linux kernel, as summarized by the pair of tables
in this section
(the first table shows the wait-for-RCU-readers portions of the API,
while the second table shows the publish/subscribe portions of the API).
Or, more precisely, RCU is a family of APIs as shown in the first table,
with each column corresponding to a member of the RCU API family.

<P>If you are new to RCU, you might consider focusing on just one
of the columns in the following table.
For example, if you are primarily interested in understanding how RCU
is used in the Linux kernel, "RCU Classic" would be the place to start,
as it is used most frequently.
On the other hand, if you want to understand RCU for its own sake,
"SRCU" has the simplest API.
You can always come back for the other columns later.

<P>If you are already familiar with RCU, the following pair of tables can
serve as a useful reference.

<P>
<table cellpadding=3>
<tr><th>Attribute</th>
    <th>RCU Classic</th>
	<th>RCU BH</th>
	    <th>RCU Sched</th>
		<th>Realtime RCU</th>
		    <th>SRCU</th>
			<th>QRCU</th>
</tr>
<tr class="Odd"><th align="left">Purpose</th>
    <td>Original</td>
	<td>Prevent DDoS attacks</td>
	    <td>Wait for hardirqs and NMIs</td>
	        <td>Realtime response</td>
		    <td>Sleeping readers</td>
		        <td>Sleeping readers and fast grace periods</td>
</tr>
<tr class="Even"><th align="left">Availability</th>
    <td>2.5.43</td>
	<td>2.6.9</td>
	    <td>2.6.12</td>
	        <td>Aug 2005 -rt</td>
		    <td>2.6.19</td>
		        <td></td>
</tr>
<tr class="Odd"><th align="left">Read-side primitives</th>
    <td bgcolor="lightgreen">
        <code>rcu_read_lock()</code> <br> <code>rcu_read_unlock()</code></td>
	<td><code>rcu_read_lock_bh()</code> <br>
	    <code>rcu_read_unlock_bh()</code></td>
	    <td><code>preempt_disable()</code> <br>
	        <code>preempt_enable()</code> <br>
		(and friends)</td>
	        <td><code>rcu_read_lock()</code> <br>
		    <code>rcu_read_unlock()</code> </td>
		    <td><code>srcu_read_lock()</code> <br>
		        <code>srcu_read_unlock()</code></td>
		        <td><code>qrcu_read_lock()</code> <br>
			    <code>qrcu_read_unlock()</code></td>
</tr>
<tr class="Even"><th align="left">Update-side primitives <br> (synchronous)</th>
    <td><code>synchronize_rcu()</code> <br>
        <code>synchronize_net()</code></td>
	<td></td>
	    <td><code>synchronize_sched()</code></td>
	        <td><code>synchronize_rcu()</code> <br>
		    <code>synchronize_net()</code></td>
		    <td><code>synchronize_srcu()</code></td>
		        <td><code>synchronize_qrcu()</code></td>
</tr>
<tr class="Odd"><th align="left">Update-side primitives <br> (asynchronous/callback)</th>
    <td bgcolor="lightgreen">
        <code>call_rcu()</code></td>
	<td><code>call_rcu_bh()</code></td>
	    <td></td>
	        <td><code>call_rcu()</code></td>
		    <td bgcolor="pink">N/A</td>
		        <td bgcolor="pink">N/A</td>
</tr>
<tr class="Even"><th align="left">Update-side primitives <br> (wait for callbacks)</th>
    <td><code>rcu_barrier()</code></td>
	<td></td>
	    <td></td>
	        <td><code>rcu_barrier()</code></td>
		    <td bgcolor="pink">N/A</td>
		        <td bgcolor="pink">N/A</td>
</tr>
<tr class="Odd"><th align="left">Read side constraints</th>
    <td>No blocking</td>
	<td>No irq enabling</td>
	    <td>No blocking</td>
	        <td>No blocking except preemption and lock acquisition</td>
		    <td>No <code>synchronize_srcu()</code></td>
		        <td>No <code>synchronize_qrcu()</code></td>
</tr>
<tr class="Even"><th align="left">Read side overhead</th>
    <td>Preempt disable/enable (free on non-PREEMPT)</td>
	<td>BH disable/enable</td>
	    <td>Preempt disable/enable (free on non-PREEMPT)</td>
	        <td>Simple instructions, irq disable/enable</td>
		    <td>Simple instructions, preempt disable/enable</td>
		        <td>Atomic increment and
			    decrement of shared variable</td>
</tr>
<tr class="Odd"><th align="left">Asynchronous update-side overhead
			(for example, <code>call_rcu()</code>)</th>
    <td>sub-microsecond</td>
	<td>sub-microsecond</td>
	    <td></td>
	        <td>sub-microsecond</td>
		    <td bgcolor="pink">N/A</td>
		        <td bgcolor="pink">N/A</td>
</tr>
<tr class="Even"><th align="left">Grace-period latency</th>
    <td>10s of milliseconds</td>
	<td>10s of milliseconds</td>
	    <td>10s of milliseconds</td>
	        <td>10s of milliseconds</td>
		    <td>10s of milliseconds</td>
		        <td>10s of <i>nanoseconds</i> in absence of readers</td>
</tr>
<tr class="Odd"><th align="left">Non-PREEMPT_RT implementation</th>
    <td>RCU Classic</td>
	<td>RCU BH</td>
	    <td>RCU Classic</td>
	        <td>N/A</td>
		    <td>SRCU</td>
		        <td>N/A</td>
</tr>
<tr class="Even"><th align="left">PREEMPT_RT implementation</th>
    <td>N/A</td>
	<td>Realtime RCU</td>
	    <td>Forced Schedule on all CPUs</td>
	        <td>Realtime RCU</td>
		    <td>SRCU</td>
		        <td>N/A</td>
</tr>
</table>

<P><A NAME="Quick Quiz 1"><B>Quick Quiz 1</B>:</A>
Why are some of the cells in the above table colored green?

<P>The "RCU Classic" column corresponds to the original RCU implementation,
in which RCU read-side critical sections are delimited by
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>, which
may be nested.
The corresponding synchronous update-side primitives,
<code>synchronize_rcu()</code>, along with its synonym
<code>synchronize_net()</code>, wait for any currently executing
RCU read-side critical sections to complete.
The length of this wait is known as a "grace period".
The asynchronous update-side primitive, <code>call_rcu()</code>,
invokes a specified function with a specified argument after a
subsequent grace period.
For example, <code>call_rcu(p,f);</code> will result in
the "RCU callback" <code>f(p)</code>
being invoked after a subsequent grace period.
There are situations,
<A HREF="http://lwn.net/Articles/217484/">
such as when unloading a module that uses <code>call_rcu()</code></A>,
when it is necessary to wait for all
outstanding RCU callbacks to complete.
The <code>rcu_barrier()</code> primitive does this job.

<P>In the "RCU BH" column, <code>rcu_read_lock_bh()</code> and
<code>rcu_read_unlock_bh()</code> delimit RCU read-side critical
sections, and <code>call_rcu_bh()</code> invokes the specified
function and argument after a subsequent grace period.
Note that RCU BH does not have a synchronous <code>synchronize_rcu_bh()</code>
interface,
though one could easily be added if required.

<P><A NAME="Quick Quiz 2"><B>Quick Quiz 2</B>:</A>
What happens if you mix and match?
For example, suppose you use <code>rcu_read_lock()</code> and
<code>rcu_read_unlock()</code> to delimit RCU read-side critical
sections, but then use <code>call_rcu_bh()</code> to post an
RCU callback?

<P>In the "RCU Sched" column, anything that disables preemption
acts as an RCU read-side critical section, and <code>synchronize_sched()</code>
waits for the corresponding RCU grace period.
This RCU API family was added in the 2.6.12 kernel, which split the
old <code>synchronize_kernel()</code> API into the current
<code>synchronize_rcu()</code> (for RCU Classic) and
<code>synchronize_sched()</code> (for RCU Sched).
Note that RCU Sched does not have an asynchronous
<code>call_rcu_sched()</code> interface,
though one could be added if required.

<P><A NAME="Quick Quiz 3"><B>Quick Quiz 3</B>:</A>
What happens if you mix and match RCU Classic and RCU Sched?

<P>The "Realtime RCU" column has the same API as does
RCU Classic, the only difference being that RCU read-side critical
sections may be preempted and may block while acquiring spinlocks.
The design of Realtime RCU is described in the LWN article
<A HREF="http://lwn.net/Articles/253651/">
The design of preemptible read-copy-update</A>.

<P><A NAME="Quick Quiz 4"><B>Quick Quiz 4</B>:</A>
What happens if you mix and match Realtime RCU and RCU Classic?

<P>The "SRCU" column displays a specialized RCU API that permits
general sleeping in RCU read-side critical sections, as was
described in the LWN article
<A HREF="http://lwn.net/Articles/202847/">Sleepable RCU</A>.
Of course,
use of <code>synchronize_srcu()</code> in an SRCU read-side
critical section can result in
self-deadlock, so should be avoided.
SRCU differs from earlier RCU implementations in that the caller
allocates an <code>srcu_struct</code> for each distinct SRCU
usage.
This approach prevents SRCU read-side critical sections from blocking
unrelated <code>synchronize_srcu()</code> invocations.
In addition, in this variant of RCU, <code>srcu_read_lock()</code>
returns a value that must be passed into the corresponding
<code>srcu_read_unlock()</code>.

<P>The "QRCU" column presents an RCU implementation with the same
API structure as SRCU, but optimized for extremely low-latency
grace periods in absence of readers, as described in the LWN article
<A HREF="http://lwn.net/Articles/243851/">
Using Promela and Spin to verify parallel algorithms</A>.
As with SRCU, use of <code>synchronize_qrcu()</code> can result in
self-deadlock, so should be avoided.
Although QRCU has not yet been accepted into the Linux kernel, it
is worth mentioning given that it is the only RCU implementation
that can boast deep sub-microsecond grace-period latencies.

<P><A NAME="Quick Quiz 5"><B>Quick Quiz 5</B>:</A>
Why do both SRCU and QRCU lack asynchronous <code>call_srcu()</code>
or <code>call_qrcu()</code> interfaces?

<P><A NAME="Quick Quiz 6"><B>Quick Quiz 6</B>:</A>
Under what conditions can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?

<P>The Linux kernel currently has a surprising number of RCU APIs and
implementations.
There is some hope of reducing this number, evidenced by the fact
that a given build of the Linux kernel currently has at most
three implementations behind four APIs (given that RCU Classic
and Realtime RCU share the same API).
However, careful inspection and analysis will be required, just as
would be required for one of the many locking APIs.

</p><H3><A NAME="RCU has Publish-Subscribe and Version-Maintenance APIs">
RCU has Publish-Subscribe and Version-Maintenance APIs</A></H3>

<P>Fortunately, the RCU publish-subscribe and version-maintenance
primitives shown in the following
table apply to all of the variants of RCU discussed above.
This commonality can in some cases allow more code to be shared,
which certainly reduces the API proliferation that would otherwise
occur.

<table cellpadding=3>
<tr><th>Category</th>
	<th>Primitives</th>
		<th>Availability</th>
			<th>Overhead</th>
</tr>
<tr class="Odd"><th align="left">List traversal</th>
	<td><code>list_for_each_entry_rcu()</code></td>
		<td>2.5.59</td>
			<td>Simple instructions (memory barrier on Alpha)</td>
</tr>
<tr class="Even"><th align="left" rowspan=5>List update</th>
	<td><code>list_add_rcu()</code></td>
		<td>2.5.44</td>
			<td>Memory barrier</td>
</tr>
<tr class="Even">
	<td><code>list_add_tail_rcu()</code></td>
		<td>2.5.44</td>
			<td>Memory barrier</td>
</tr>
<tr class="Even">
	<td><code>list_del_rcu()</code></td>
		<td>2.5.44</td>
			<td>Simple instructions</td>
</tr>
<tr class="Even">
	<td><code>list_replace_rcu()</code></td>
		<td>2.6.9</td>
			<td>Memory barrier</td>
</tr>
<tr class="Even">
	<td><code>list_splice_init_rcu()</code></td>
		<td>2.6.21</td>
			<td>Grace-period latency</td>
</tr>
<tr class="Odd"><th align="left">Hlist traversal</th>
	<td><code>hlist_for_each_entry_rcu()</code></td>
		<td>2.6.8</td>
			<td>Simple instructions (memory barrier on Alpha)</td>
</tr>
<tr class="Even"><th align="left" rowspan=5>Hlist update</th>
	<td><code>hlist_add_after_rcu()</code></td>
		<td>2.6.14</td>
			<td>Memory barrier</td>
</tr>
<tr class="Even">
	<td><code>hlist_add_before_rcu()</code></td>
		<td>2.6.14</td>
			<td>Memory barrier</td>
</tr>
<tr class="Even">
	<td><code>hlist_add_head_rcu()</code></td>
		<td>2.5.64</td>
			<td>Memory barrier</td>
</tr>
<tr class="Even">
	<td><code>hlist_del_rcu()</code></td>
		<td>2.5.64</td>
			<td>Simple instructions</td>
</tr>
<tr class="Even">
	<td><code>hlist_replace_rcu()</code></td>
		<td>2.6.15</td>
			<td>Memory barrier</td>
</tr>
<tr class="Odd"><th align="left">Pointer traversal</th>
	<td><code>rcu_dereference()</code></td>
		<td>2.6.9</td>
			<td>Simple instructions (memory barrier on Alpha)</td>
</tr>
<tr class="Even"><th align="left">Pointer update</th>
	<td><code>rcu_assign_pointer()</code></td>
		<td>2.6.10</td>
			<td>Memory barrier</td>
</tr>
</table>

<P>The first pair of categories operate on Linux
<code>struct&nbsp;list_head</code> lists, which are circular, doubly-linked
lists.
The <code>list_for_each_entry_rcu()</code> primitive traverses an
RCU-protected list in a type-safe manner, while also enforcing
memory ordering for situations where a new list element is inserted
into the list concurrently with traversal.
On non-Alpha platforms, this primitive incurs little or no performance
penalty compared to <code>list_for_each_entry()</code>.
The <code>list_add_rcu()</code>, <code>list_add_tail_rcu()</code>,
and <code>list_replace_rcu()</code> primitives are analogous to
their non-RCU counterparts, but incur the overhead of an additional
memory barrier on weakly-ordered machines.
The <code>list_del_rcu()</code> primitive is also analogous to its
non-RCU counterpart, but oddly enough is very slightly faster due to the
fact that it poisons only the <code>prev</code> pointer rather than
both the <code>prev</code> and <code>next</code> pointers as
<code>list_del()</code> must do.
Finally, the <code>list_splice_init_rcu()</code> primitive is similar
to its non-RCU counterpart, but incurs a full grace-period latency.
The purpose of this grace period is to allow RCU readers to finish
their traversal of the source list before completely disconnecting
it from the list header -- failure to do this could prevent such
readers from ever terminating their traversal.

<P><A NAME="Quick Quiz 7"><B>Quick Quiz 7</B>:</A>
Why doesn't <code>list_del_rcu()</code> poison both the <code>next</code>
and <code>prev</code> pointers?

<P>The second pair of categories operate on Linux's
<code>struct&nbsp;hlist_head</code>, which is a linear linked list.
One advantage of <code>struct&nbsp;hlist_head</code> over
<code>struct&nbsp;list_head</code> is that the former requires only
a single-pointer list header, which can save significant memory in
large hash tables.
The <code>struct&nbsp;hlist_head</code> primitives in the table
relate to their non-RCU counterparts in much the same way as do the
<code>struct&nbsp;list_head</code> primitives.

<P>The final pair of categories operate directly on pointers, and
are useful for creating RCU-protected non-list data structures,
such as RCU-protected arrays and trees.
The <code>rcu_assign_pointer()</code> primitive ensures that any
prior initialization remains ordered before the assignment to the
pointer on weakly ordered machines.
Similarly, the <code>rcu_dereference()</code> primitive ensures that subsequent
code dereferencing the pointer will see the effects of initialization code
prior to the corresponding <code>rcu_assign_pointer()</code> on
Alpha CPUs.
On non-Alpha CPUs, <code>rcu_dereference()</code> documents which pointer
dereferences are protected by RCU.

<P><A NAME="Quick Quiz 8"><B>Quick Quiz 8</B>:</A>
Normally, any pointer subject to <code>rcu_dereference()</code> should
always be updated using <code>rcu_assign_pointer()</code>.
What is an exception to this rule?

<P><A NAME="Quick Quiz 9"><B>Quick Quiz 9</B>:</A>
Are there any downsides to the fact that these traversal and update
primitives can be used with any of the RCU API family members?

</p><h3><A NAME="So, What is RCU Really?">
So, What <i>is</i> RCU Really?</A></h3>

<P>At its core, RCU is nothing more nor less than an API that supports
publication and subscription for insertions, waiting for all RCU readers
to complete, and maintenance of multiple versions.
That said, it is possible to build higher-level constructs
on top of RCU, including the reader-writer-locking, reference-counting,
and existence-guarantee constructs listed in the companion article.
Furthermore, I have no doubt that the Linux community will continue to
find interesting new uses for RCU,
just as they do for any of a number of synchronization
primitives throughout the kernel.

<P>Finally, a complete view of RCU would also include
all of the things you can do with these APIs.

<H3>Acknowledgements</H3>

<P>We are all indebted to Andy Whitcroft, Jon Walpole, and Gautham Shenoy,
whose review of an early draft of this document greatly improved it.
I owe thanks to the members of the Relativistic Programming project
and to members of PNW TEC for many valuable discussions.
I am grateful to Dan Frye for his support of this effort.

<P>This work represents the view of the author and does not necessarily
represent the view of IBM.

<P>Linux is a registered trademark of Linus Torvalds.

<P>Other company, product, and service names may be trademarks or
service marks of others.

<H3><A NAME="References">
References</A></H3>

<P>This section gives a short annotated bibliography describing using RCU,
Linux-kernel RCU implementations, background, and historical perspectives.
For more information, see
<A HREF="http://www.rdrop.com/users/paulmck/RCU/">
Paul E. McKenney's RCU Page</A>.


<H4>Using RCU</H4>

<OL>
<LI>	<A HREF="http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2167.pdf">
	Overview of Linux-Kernel Reference Counting (McKenney,
	January 2007) [PDF]</A>.
	Overview of Linux-kernel reference counting (including RCU)
	prepared for the
	Concurrency Working Group of the C/C++ standards committee.
<p>
<LI>	<A HREF="http://lwn.net/Articles/217484/">
	RCU and Unloadable Modules (McKenney, January 2007)</A>.
	Describes how to unload modules that use <code>call_rcu()</code>,
	so as to avoid RCU callbacks trying to use the module after it
	has been unloaded.
<p>
<LI>	<A HREF="http://www.livejournal.com/users/james_morris/2153.html">
	Recent Developments in SELinux Kernel Performance</A>.
	James Morris describes a performance problem in the SELinux
	Access Vector Cache (AVC), and its resolution via RCU in
	a patch by Kaigai Kohei.
<p>
<LI>	<A HREF="http://www.rdrop.com/users/paulmck/RCU/rcu.FREENIX.2003.06.14.pdf">
	Using Read-Copy-Update Techniques for System V IPC in the
	Linux 2.5 Kernel (Arcangeli et al., June 2003) [PDF]</A>.
	Describes how RCU is used in the Linux kernel's System V IPC
	implementation.
</OL>

<H4>Linux-Kernel RCU Implementations</H4>

<OL>
<LI>	<A HREF="http://lwn.net/Articles/253651/">
	The design of preemptible read-copy-update (McKenney, October 2007)</A>.
	Describes a high-performance RCU implementation for realtime use.
<p>
<LI>	<A HREF="http://lwn.net/Articles/202847/">Sleepable RCU (McKenney,
	October 2006)</A>.
	Description of SRCU.
<p>
<LI>	<A HREF="http://lwn.net/Articles/243851/">
	Using Promela and Spin to verify parallel algorithms (McKenney,
	August 2007)</A>.
	Description of the QRCU patch.
<p>
<LI>	<A HREF="http://www.rdrop.com/users/paulmck/RCU/RCUdissertation.2004.07.14e1.pdf">
	RCU dissertation (McKenney, July 2004) [PDF]</A>.
	<UL>
	<LI>	Section 2.2.20 (pages 62-64) gives a history of RCU-like
		mechanisms, a very brief summary of which can be found
		below.
	<LI>	Chapter 4 (pages 71-98) and Appendix C (pages 326-345) review
		a number of different types of RCU implementations, summarizing
		a number of earlier papers.
	<LI>	Chapter 5 (pages 137-178) gives an overview of a number of
		"design patterns" guiding use of RCU.
	<LI>	Chapter 6 (pages 179-234) describes some early uses of RCU.
	</UL>
<p>
<LI>	<A HREF="http://www.linuxjournal.com/article/6993">
	Using RCU in the Linux 2.5 Kernel (October 2003)</A>.
	Brief summary of why RCU can be helpful, along with
	an analogy between RCU and reader-writer locking.
<p>
<LI>	Anyone who is laboring under the misapprehension that
	the Linux community would never have
	independently invented RCU should read this
	<A HREF="http://oss.sgi.com/projects/netdev/archive/2000-06/msg00250.html">
	netdev posting</A> and
	<A HREF="http://oss.sgi.com/projects/netdev/archive/2000-06/msg00254.html">
	this one as well</A>.
	Both postings pre-date the earliest known introduction of RCU to the
	Linux community.
</OL>

<H4>Background</H4>

<OL>
<LI>	<A HREF="http://rt.wiki.kernel.org/index.php/Main_Page">
	Real-Time Linux Wiki</A>.
	Provides much valuable information on the -rt patchset for both
	kernel and application developers.
<p>
<LI>	<A HREF="http://www.kernel.org/pub/linux/kernel/projects/rt/">
	Home of the -rt kernel patchsets</A>.
<p>
<LI>	<A HREF="http://www.rdrop.com/users/paulmck/scalability/paper/ordering.2007.09.19a.pdf">
	Memory Ordering in Modern Microprocessors (McKenney, August 2005) [PDF]</A>.
	Gives an overview of how Linux's memory-ordering primitives work
	on a number of computer architectures.
</OL>

<H4>Historical Perspectives on RCU and Related Mechanisms</H4>

<OL>
<LI>	<A HREF="http://www.usenix.org/events/osdi99/full_papers/gamsa/gamsa.pdf">
	Tornado: Maximizing Locality and Concurrency in a
	Shared Memory Multiprocessor Operating System
	(Gamsa et al., February 1999) [PDF]</A>.
	Independent invention of a mechanism very similar to RCU.
	Tornado is a research operating system developed at the
	University of Toronto.
	This operating system uses its analog to RCU pervasively.
	Some of the University of Toronto students brought this operating
	system with them to IBM Research, where it was developed as part of the
	K42 project.
<p>
<LI>	<A HREF="http://www.rdrop.com/users/paulmck/RCU/rclockpdcsproof.pdf">
	Read-Copy Update: Using Execution History to Solve Concurrency
	Problems (McKenney and Slingwine, October 1998) [PDF]</A>.
	First non-patent publication of DYNIX/ptx's RCU implementation.
<p>
<LI>	<A HREF="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=4809168.PN.&amp;OS=PN/4809168&amp;RS=PN/4809168">
	Passive Serialization in a Multitasking Environment
	(Hennessey et al., February 1989)</A>.
	This patent describes an RCU-like mechanism that was apparently
	used in IBM's VM/XA mainframe hypervisor.
	This is the earliest known production use of an RCU-like mechanism.
<p>
<LI>	<A HREF="http://portal.acm.org/citation.cfm?id=320619&amp;dl=GUIDE,">
	Concurrent Manipulation of Binary Search Trees (Kung and Lehman,
	September 1980)</A>.
	The earliest known publication of an RCU-like mechanism,
	using a garbage collector to implicitly compute grace periods.
</OL>

<H3><A NAME="Answers to Quick Quizzes">
Answers to Quick Quizzes</A></H3>

<P><B>Quick Quiz 1</B>:
Why are some of the cells in the above table colored green?

<P><B>Answer</B>: The green API members (<code>rcu_read_lock()</code>,
<code>rcu_read_unlock()</code>, and <code>call_rcu()</code>) were the
only members of the Linux RCU API that Paul E. McKenney was aware of back
in the mid-90s.
During this timeframe, he was under the mistaken impression that
he knew all that there is to know about RCU.

<P><A HREF="#Quick Quiz 1"><B>Back to Quick Quiz 1</B>.</A>

<P><B>Quick Quiz 2</B>:
What happens if you mix and match?
For example, suppose you use <code>rcu_read_lock()</code> and
<code>rcu_read_unlock()</code> to delimit RCU read-side critical
sections, but then use <code>call_rcu_bh()</code> to post an
RCU callback?

<P><B>Answer</B>: If there happened to be no RCU read-side critical
sections delimited by <code>rcu_read_lock_bh()</code> and
<code>rcu_read_unlock_bh()</code> at the time <code>call_rcu_bh()</code>
was invoked, RCU would be within its rights to invoke the callback
immediately, possibly freeing a data structure still being used by
the RCU read-side critical section!
This is not merely a theoretical possibility: a long-running RCU
read-side critical section delimited by <code>rcu_read_lock()</code>
and <code>rcu_read_unlock()</code> is vulnerable to this failure mode.

<P>This vulnerability disappears in -rt kernels, where
RCU Classic and RCU BH both map onto a common implementation.

<P><A HREF="#Quick Quiz 2"><B>Back to Quick Quiz 2</B>.</A>

<P><B>Quick Quiz 3</B>:
What happens if you mix and match RCU Classic and RCU Sched?

<P><B>Answer</B>: In a non-PREEMPT or a PREEMPT kernel, mixing these
two works "by accident" because in those kernel builds, RCU Classic and RCU
Sched map to the same implementation.
However, this mixture is fatal in PREEMPT_RT builds using the -rt
patchset, due to the fact that Realtime RCU's read-side critical
sections can be preempted, which would permit
<code>synchronize_sched()</code> to return before the
RCU read-side critical section reached its <code>rcu_read_unlock()</code>
call.
This could in turn result in a data structure being freed before the
read-side critical section was finished with it,
which could in turn greatly increase the actuarial risk experienced
by your kernel.

<P>In fact, the split between RCU Classic and RCU Sched was inspired
by the need for preemptible RCU read-side critical sections.

<P><A HREF="#Quick Quiz 3"><B>Back to Quick Quiz 3</B>.</A>

<P><B>Quick Quiz 4</B>:
What happens if you mix and match Realtime RCU and RCU Classic?

<P><B>Answer</B>: That would be up to you, because you would have
to code up changes to the kernel to make such mixing possible.
Currently, any kernel running with RCU Classic cannot access
Realtime RCU and vice versa.

<P><A HREF="#Quick Quiz 4"><B>Back to Quick Quiz 4</B>.</A>

<P><B>Quick Quiz 5</B>:
Why do both SRCU and QRCU lack asynchronous <code>call_srcu()</code>
or <code>call_qrcu()</code> interfaces?

<P><B>Answer</B>: Given an asynchronous interface, a single task
could register an arbitrarily large number of SRCU or QRCU callbacks,
thereby consuming an arbitrarily large quantity of memory.
In contrast, given the current synchronous
<code>synchronize_srcu()</code> and <code>synchronize_qrcu()</code>
interfaces, a given task must finish waiting for a given grace period
before it can start waiting for the next one.

<P><A HREF="#Quick Quiz 5"><B>Back to Quick Quiz 5</B>.</A>

<P><B>Quick Quiz 6</B>:
Under what conditions can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?

<P><B>Answer</B>: In principle, you can use
<code>synchronize_srcu()</code> with a given <code>srcu_struct</code>
within an SRCU read-side critical section that uses some other
<code>srcu_struct</code>.
In practice, however, doing this is almost certainly a bad idea.
In particular, the following could still result in deadlock:

<blockquote>
<pre>
idx = srcu_read_lock(&amp;ssa);
synchronize_srcu(&amp;ssb);
srcu_read_unlock(&amp;ssa, idx);

/* . . . */

idx = srcu_read_lock(&amp;ssb);
synchronize_srcu(&amp;ssa);
srcu_read_unlock(&amp;ssb, idx);
</pre>
</blockquote>

<P><A HREF="#Quick Quiz 6"><B>Back to Quick Quiz 6</B>.</A>

<P><B>Quick Quiz 7</B>:
Why doesn't <code>list_del_rcu()</code> poison both the <code>next</code>
and <code>prev</code> pointers?

<P><B>Answer</B>: Poisoning the <code>next</code> pointer would interfere
with concurrent RCU readers, who must use this pointer.
However, RCU readers are forbidden from using the <code>prev</code>
pointer, so it may safely be poisoned.

<P><A HREF="#Quick Quiz 7"><B>Back to Quick Quiz 7</B>.</A>

<P><B>Quick Quiz 8</B>:
Normally, any pointer subject to <code>rcu_dereference()</code> <i>must</i>
always be updated using <code>rcu_assign_pointer()</code>.
What is an exception to this rule?

<P><B>Answer</B>: One such exception is when a multi-element linked
data structure is initialized as a unit while inaccessible to other
CPUs, and then a single <code>rcu_assign_pointer()</code> is used
to plant a global pointer to this data structure.
The initialization-time pointer assignments need not use
<code>rcu_assign_pointer()</code>, though any such assignments that
happen after the structure is globally visible <i>must</i> use
<code>rcu_assign_pointer()</code>.

<P>However, unless this initialization code is on an impressively hot
code-path, it is probably wise to use <code>rcu_assign_pointer()</code>
anyway, even though it is in theory unnecessary.
It is all too easy for a "minor" change to invalidate your cherished
assumptions about the initialization happening privately.

<P><A HREF="#Quick Quiz 8"><B>Back to Quick Quiz 8</B>.</A>

<P><B>Quick Quiz 9</B>:
Are there any downsides to the fact that these traversal and update
primitives can be used with any of the RCU API family members?

<P><B>Answer</B>: It can sometimes be difficult for automated
code checkers such as "sparse" (or indeed for human beings) to
work out which type of RCU read-side critical section a given
RCU traversal primitive corresponds to.
For example, consider the following:

<blockquote>
<pre>
rcu_read_lock();
preempt_disable();
p = rcu_dereference(global_pointer);

/* . . . */

preempt_enable();
rcu_read_unlock();
</pre>
</blockquote>

<P>Is the <code>rcu_dereference()</code> primitive in an RCU Classic
or an RCU Sched critical section?
What would you have to do to figure this out?

<P><A HREF="#Quick Quiz 9"><B>Back to Quick Quiz 9</B>.</A><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/264090/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor266388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU part 3: the RCU API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2008 9:46 UTC (Thu)
                               by <b>jarkao2</b> (guest, #41960)
                              [<a href="/Articles/266388/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Hi, here are my doubts and suggestions of tiny fixes:

1. Probably in part 1 there was mention of using RCU pointers after their read-side block
being illegal; maybe it was explained later, but I would like to be sure about such cases:

  RCU Classic
================
preempt_disable()
or spin_lock()
    ...
rcu_read_lock()
    ...
p = rcu_dereference()
    ...
rcu_read_unlock()
    ...
rcu_read_lock()
    ...
r = p-&gt;something
    ...
rcu_read_unlock()
    ...
preempt_enable()
or spin_unlock()

(this code could be divided between 2 functions, BTW)

or similarly with RCU BH, but with local_bh_disable/enable() instead of
preempt_disable/enable() and with rcu_read_lock/unlock_bh()

So, is it 'legal' if we don't care about RT problems with this?

2. In the first table here for RCU BH shouldn't this be "No soft irq enabling"? (And why
rcu_barrier() missing?)

3. And traditionally 'an' fix proposal: (under second table) "but incur an the overhead".
(Quick Quiz 10?)

Many thanks again!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/266388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU part 3: the RCU API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 2:04 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/267237/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Good questions!  Point-by-point answers:
<OL>
<LI> Your example might or might not be legal, depending on what
	primitive you used to wait for a grace period.	If you are using
	<code>call_rcu()</code> or <code>synchronize_rcu()</code>,
	your example is technically illegal for Classic RCU
	and prone to failure for realtime RCU.	If you are
	using <code>synchronize_srcu()</code>, your example
	is technically illegal, but will work given the current
	implementation.  If you are using <code>call_rcu_bh()</code>
	or <code>synchronize_qrcu()</code>, your example is
	illegal and prone to failure.  Finally, if you are using
	<code>synchronize_sched()</code>, your example is entirely
	legal, because <code>preempt_disable()</code> introduces an RCU
	read-side critical section.  You could create a similar list for
	your <code>_ bh</code> example.  But please note that if I see
	anyone submitting a patch in the "technically illegal but works"
	category, I will NACK it.
<LI> One could indeed have listed more things in that cell: no _bh
	enabling, no blocking, and, as you say, no softirq enabling.
	The reason that there is not yet an rcu_bh_barrier() is that
	there has not been a clear need for it yet -- which might change
	if someone needs call_rcu_bh() in a module.
<LI> Good catch!  s/an the/the/
</OL>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU part 3: the RCU API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 2:34 UTC (Thu)
                               by <b>ris</b> (subscriber, #5)
                              [<a href="/Articles/267240/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt; Good catch! s/an the/the/</font>

Fixed!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU part 3: the RCU API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 11:18 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/267279/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thank you very much!!!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2008, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
