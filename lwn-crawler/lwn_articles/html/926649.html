        <!DOCTYPE html>
        <html lang="en">
        <head><title>User-space shadow stacks (maybe) for 6.4 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/926649/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/926933/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/926649/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>User-space shadow stacks (maybe) for 6.4</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 24, 2023</br>
           </div>
Support for shadow stacks on the x86 architecture has been long in coming;
LWN <a href="/Articles/758245/">first covered this work</a> in 2018.  After
five years and numerous versions, though, it would appear that
user-space shadow stacks on x86 might just be supported in the 6.4 kernel
release.  Getting there has required a few changes since we last <a
href="/Articles/885220/">caught up with this work</a> in early 2022.
<p>
Shadow stacks are a defense against <a
href="https://en.wikipedia.org/wiki/Return-oriented_programming">return-oriented
programming (ROP)</a> attacks, as well as others that target a process's
call stack.  The shadow stack itself is a hardware-maintained copy of the
return addresses pushed onto the call stack with each function call.  Any
attack that corrupts the call stack will be unable to change the shadow
stack to match; as a result, the corruption will be detected at
function-return time and the process terminated before the attacker can
take control.  The above-linked 2022 article has more details on how x86
shadow stacks, in particular, work.
<p>
The <a
href="/ml/linux-kernel/20230319001535.23210-1-rick.p.edgecombe@intel.com/">current
version</a> of the patch set is the eighth revision posted by Rick
Edgecombe (who took it over after some 30&nbsp;revisions posted by Yu-cheng
Yu).
<p>
<h4>API changes</h4>
<p>
The user-space API for working with shadow stacks has not changed much in
the last year.  Most operations are done with <a
href="https://man7.org/linux/man-pages/man2/arch_prctl.2.html"><tt>arch_prctl()</tt></a>
calls, specifically:
<ul class="spacylist">
<li> <tt>ARCH_SHSTK_ENABLE</tt> turns on the shadow stack for the current
     thread; shadow stacks are not enabled by the kernel when a process
     starts.
<li> <tt>ARCH_SHSTK_DISABLE</tt> disables the use of the shadow stack for
     the current thread.
<li> <tt>ARCH_SHSTK_LOCK</tt> prevents any further changes to a thread's
     shadow-stack status.  Among other things, this operation can keep an
     attacker from somehow disabling the shadow stack before corrupting the
     call stack.
<li> <tt>ARCH_SHSTK_UNLOCK</tt> undoes the effect of
     <tt>ARCH_SHSTK_LOCK</tt>. This option was added to <a
href="/ml/linux-kernel/20221203003606.6838-1-rick.p.edgecombe@intel.com/">version&nbsp;4</a>
     of the patch set in December; it exists to support functionality like
     <a href="https://criu.org/Main_Page">Checkpoint/Restore in User
     Space</a> that needs to be able to change the shadow-stack status
     after a process has launched.  This option is only available when
     invoked via <a
     href="https://man7.org/linux/man-pages/man2/ptrace.2.html"><tt>ptrace()</tt></a>;
     a process cannot use it on itself directly.
<li> <tt>ARCH_SHSTK_STATUS</tt> returns the current shadow-stack status.
</ul>
<p>
Normally, the kernel handles the allocation and placement of shadow stacks,
but there are occasions where an application will need to manage its shadow
stacks directly.  The <tt>map_shadow_stack()</tt> system call exists for
this purpose; its prototype has changed a bit over the course of the last
year:
<p>
<pre>
    void *map_shadow_stack(unsigned long address, unsigned long size,
    			   unsigned int flags);
</pre>
<p>
<div class="tlr">
	<b>Same old SHSTK</b><br>
	At one point, Andrew Morton <a
	href="/ml/linux-kernel/20230119142602.97b24f3cdba75f20f97786d3@linux-foundation.org/">complained</a>
	about the "shstk" abbreviation, saying that it "<q>sounds like me
	trying to swear in Russian while drunk</q>".  As a result, that
	term was pulled out of much of the generic code, but remains in the
	x86 portion.
</div>

This call will attempt to set up a shadow stack at the given
<tt>address</tt> of the requested <tt>size</tt>, returning the actual
mapped address on success.  The one possible value for <tt>flags</tt> is
now called <tt>X86_FEATURE_USER_SHSTK</tt>; it requests that the necessary
"restore token" — which, among other things, prevents multiple threads from
sharing the same shadow stack — be stored into the newly created stack.  
<p>
There is one other subtle change to <tt>map_shadow_stack()</tt> that
affects how shadow stacks are handled in general.  The shadow-stack feature
has incompatibilities with 32&#8209;bit code, especially when signals are
involved.  
The kernel will refuse to enable a shadow stack for a thread that is
running in the 32-bit mode and, in <a
href="/ml/linux-kernel/20221203003606.6838-1-rick.p.edgecombe@intel.com/">version&nbsp;4</a>
of the patch set, code was added to simply disable any signal handlers
if a process switched to 32-bit mode after the shadow stack was enabled.
<p>
Beyond seeming like a bit of a hack, this approach did not fully solve the
problem. As it turns out, a 64-bit thread can switch to the 32-bit mode
without the kernel's knowledge or permission — meaning that the disabling
of signal handlers can be circumvented.  After some deliberation on how to
avoid subtle problems when this happens, the decision was made (for <a
href="/ml/linux-kernel/20230119212317.8324-1-rick.p.edgecombe@intel.com/">version&nbsp;5</a>)
to just always map the shadow stack at a virtual address above 4GB, making
it inaccessible to 32-bit code.  As a result, any attempt to switch to the
32-bit mode when a shadow stack is enabled will cause an immediate crash.
<p>
This change resulted in a new <a
href="https://man7.org/linux/man-pages/man2/mmap.2.html"><tt>mmap()</tt></a>
flag, <tt>MAP_ABOVE4G</tt>, which forces the mapping to be created above
the 4GB virtual-address boundary.  The <tt>address</tt> passed to
<tt>map_shadow_stack()</tt> (if not zero, indicating no preference) must
also be above 4GB or the call will fail.  Someday, somebody with sufficient
motivation could perhaps find a way to make 32-bit code work with shadow
stacks, but given how little interest there is in 32-bit code in general,
that seems unlikely to happen.
<p>
<h4>The glibc problem</h4>
<p>
While it might be nice to run all programs with shadow stacks enabled,
there are applications that would break in that environment.  Anything that
manipulates its own call stack — just-in-time compilers, for example — will
find itself out of sync with the shadow stack and brought to an untimely
end.  So the enabling of the shadow stack must be limited to code that can
handle it.
<p>
The scheme that was developed, some time ago, was to place a special note
in the <tt>.note.gnu.property</tt> ELF section of the program's executable
image.  If that note exists (as the result of compiler options provided
when the program was built), that indicates that it is safe to run the
program with the shadow stack enabled.  That note is not sufficient for the
kernel to make the decision, though, so the enabling of the shadow stack is
left to user space, and to the C library's program loader in particular.
<p>
Enthusiastic developers in the GNU C Library (glibc) community quickly
wired up support for turning on the shadow stack when it seemed
appropriate; current versions of glibc are poised to turn on the shadow
stack as soon as the kernel supports the feature.  There is only one little
problem: the glibc support was written with an early version of the
user-space API in mind.  That API no longer exists; trying to use it would
result in crashing programs and a 
failure to boot.  That will indeed secure it against ROP attacks, but users
can be picky about just how that kind of security was achieved and may
complain.
<p>
That problem was resolved early on by changing the API enough that glibc
simply doesn't find it anymore and thinks that the shadow-stack
functionality is not present.  The glibc developers have said, though, that
they intend to implement the new shadow-stack API once it is merged;
thereafter, when an updated glibc shows up on a system, any program that
indicates a readiness for a shadow stack will get one.
<p>
That leads to a new problem, as noted in the version-3 cover letter: not
all applications that are marked as being ready really are.
<p>
<blockquote class="bq">
	But many application binaries with the bit marked exist today, and
	critically, it was applied widely and automatically by some popular
	distro builds without verification that the packages actually
	support shadow stack. So when glibc is updated, shadow stack will
	suddenly turn on very widely with some missing verification.
</blockquote>
<p>
Applications that will break in this environment evidently include node.js
and PyPy, so this seems like a real problem.  A quick check on a
Fedora&nbsp;37 system shows that PyPy is indeed built with the shadow stack
enabled:
<p>
<pre>
    $ readelf -n /usr/bin/pypy
    Displaying notes found in: .note.gnu.property
      Owner                Data size        Description
      GNU                  0x00000040       NT_GNU_PROPERTY_TYPE_0
          Properties: x86 feature: IBT, <b>SHSTK</b>
    [...]
</pre>
<p>
Even if the root cause lies
in user space, it can be provoked by upgrading to a new kernel, and thus
looks like a kernel regression.  Kernel developers generally prefer to
avoid breaking systems, even if that breakage can be said to be somebody
else's fault.
<p>
The ideal solution, according to Edgecombe, would be to simply move to a
new ELF bit to identify <i>real</i> shadow-stack readiness and have glibc
use that.  Distributors could then be encouraged to be more careful about
marking applications as being shadow-stack ready.  But, he said, "<q>it
doesn’t seem like the glibc developers are interested in working on a
solution</q>", so something else is needed.  In version&nbsp;3, that
something else was <a
href="/ml/linux-kernel/20221104223604.29615-38-rick.p.edgecombe@intel.com/">a
patch</a> disabling the shadow-stack API when the ELF bit is detected.  The
idea was that distributors would eventually disable that check once they
had confirmed that all of the packages they ship included correctly marked
binaries.
<p>
The patch was described as "<q>a bit dirty</q>" and included for the sake
of discussion — which indeed resulted.  H.J. Lu <a
href="/ml/linux-kernel/CAMe9rOpfSccXVWmgK6E0Y0DXC=VX3PpdxXookN1Ty8soeAxrKw@mail.gmail.com/">suggested</a>
that the right approach was just to avoid upgrading glibc until the system
was ready for it.  Florian Weimer <a
href="/ml/linux-kernel/87h6zaiu05.fsf@oldenburg.str.redhat.com/">added</a>
that most of the incompatible code is to be found in libraries that are
loaded after a process starts; the kernel test would not detect those, and
it may be too late to disable the shadow stack in any case.
<p>
After a while, Edgecombe <a
href="/ml/linux-kernel/7d8133c7e0186bdaeb3893c1c808148dc0d11945.camel@intel.com/">asked
Linus Torvalds</a> what he thought should be done about this problem.
Torvalds <a
href="/ml/linux-kernel/CAHk-=wgP5mk3poVeejw16Asbid0ghDt4okHnWaWKLBkRhQntRA@mail.gmail.com/">answered</a>
that he did not want to preemptively disable shadow-stack support without a
reason:
<p>
<blockquote class="bq">
	Once [shadow-stack functionality] is enabled in the kernel, and it
	turns out that people complain that it breaks existing binaries, at
	that point I guess it gets disabled again. Possibly at that point
	using something like your suggested patch. But I'm not doing it
	until actual problems appear, and until we actually have this code
	in the kernel.
</blockquote>
<p>
The patch disabling the shadow-stack API was duly taken out of the series.
Weimer <a
href="/ml/linux-kernel/87a645prpj.fsf@oldenburg.str.redhat.com/">described</a>
a couple of plans for ensuring that shadow stacks could be safely enabled
in distributions, claiming that adopting a new ELF bit would delay that
process considerably.  Shadow-stack support, he said, is not much different
from supporting a new system call; that, too, can break existing
applications, mostly as the result of <a
href="https://man7.org/linux/man-pages/man2/seccomp.2.html"><tt>seccomp()</tt></a>
filters that do not understand the new call.
<p>
<h4>On to 6.4</h4>
<p>
The result of the discussion is that the kernel will take no special steps
to avoid breaking binaries that were incorrectly marked as being ready for
shadow stacks — at least, not before a problem is demonstrated.  Most of
the other outstanding issues appear to be resolved, to the point
that Edgecombe prefixed the current version with a remark that "<q>we have
a pretty good initial shadow stack implementation here</q>". There are a
number of desired enhancements, but those might be done better, he said,
after there has been some real-world use of the code that exists now.
<p>
So, after all this work, the 40 shadow-stack patches have been added to the
<a
href="https://www.kernel.org/doc/html/latest/process/maintainer-tip.html">tip
tree</a>, which feeds them into linux-next.  If no show-stopping problems
turn up over the course of the next month or so, user-space shadow-stack
support for x86 systems will, most likely, move upstream during the 6.4
merge window.  Finally, after a long development period, the shadow (stack)
will truly know what evil lies in the heart of ROP attackers.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.6">Releases/6.6</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Control-flow_integrity">Security/Control-flow integrity</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/926649/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor927219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 14:57 UTC (Fri)
                               by <b>syrjala</b> (subscriber, #47399)
                              [<a href="/Articles/927219/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can understand the need for this shadow stack approach for a platform such as x86 that has legacy compatibility needs. But the thing I don't really understand is why something fairly new such as RISC-V didn't just go for a totally separate return stack from the start...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 15:50 UTC (Fri)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/927224/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The more weird things you do in your CPU architecture and ABI, the more barriers you have to adoption. Exceed your weirdness budget and you fail to get widespread adoption. So everything you pick that isn't "same way everybody else does it" has to be pretty carefully considered and should be something you think really matters for the use cases you're targeting. Should RISC-V have used some of their weirdness budget on having a separate return stack? Maybe, but it shouldn't be a big surprise that they went with the default answer of "no, don't be weird"...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 17:08 UTC (Fri)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/927234/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think this argument is a bit less strong for something like RISCV which has a design that has generally ignored most advancements in RISC ISAs since the 1980s and has spent most of it's novelty points on questionable things like having do-everything instructions like jalr instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor928091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2023 21:49 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/928091/">Link</a>] 
      </p>
      
      </div>
      </summary>
      JALR is a venerable MIPS instruction (already present in the R2000 (the first MIPS CPU)), no novelty points there.  And it does not do everything, it's an instruction for indirect calls (used, e.g., for calling a method in an object-oriented language).

<p>RISC-V follows in the footsteps of the MIPS heritage (Alpha and DLX).  RISC-V does support 64-bit variants, not available in the 1980s, but yes, it does not have many novelties, that's not it's purpose.  What advancements of RISC since the 1980s are you thinking about?


      
          <div class="CommentReplyButton">
            <form action="/Articles/928091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor927260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 21:18 UTC (Fri)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/927260/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
risc-V ABI is so outdated that it looks weird already...<br>
What a new ABI need to provide is separated kernel and userspace address space as in sparc and s390.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 22:47 UTC (Fri)
                               by <b>jrtc27</b> (subscriber, #107748)
                              [<a href="/Articles/927274/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you keep userspace positive and kernel space negative then that doesn't buy you much other than perhaps some hardening against speculative execution attacks, since you don't get any more address space bits to use (and x86 SMAP / AArch64 PAN / RISC-V SUM stops accidental dereferencing of userspace addresses. If you allow the address spaces to overlap then it's a lot more dangerous, since you go from being able to discriminate between user and kernel addresses to not being able to, and being at risk of dereferencing a (valid) userspace address as a (valid) kernel address.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2023 13:39 UTC (Sat)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/927298/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fortunately that is not how it is done on sparc and s390.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 26, 2023 15:40 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/927361/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <p>So how is it done on SPARC and S390?
<p>The claim is that there's only two ways to do it, neither of which bring huge advantages:
<ol>
<li>One bit of virtual address space is used to indicate whether this is a kernel address or a userspace address; given a virtual address, I can thus immediately see if it's meant to be a kernel space address or a user space address.
<li>Two separate address spaces, where the pointer values can overlap. Given a virtual address, I can't tell whether it's meant to be kernel or user space, and I need to look at out-of-band information to determine which it is.
</ol>
<p>What's the third mechanism?


      
          <div class="CommentReplyButton">
            <form action="/Articles/927361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 26, 2023 21:37 UTC (Sun)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/927372/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The extra bits are only in the MMU, that is why this requires hardware support, see<br>
&lt;<a href="https://lwn.net/Articles/742245/">https://lwn.net/Articles/742245/</a>&gt;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2023 8:46 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/927390/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <p>But you just said that SPARC and S/390 don't do it that way - this is claim version 2, where external data in the MMU determines whether a physical address is interpreted as a kernel address or a user address.



      
          <div class="CommentReplyButton">
            <form action="/Articles/927390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2023 20:54 UTC (Wed)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/927733/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was replying to "you go from being able to discriminate between user and kernel addresses to not being able to, and being at risk of dereferencing a (valid) userspace address as a (valid) kernel address."<br>
<p>
This is not the case, the kernel can use the MMU to discriminate between user and kernel addresses.<br>
The point is that userspace cannot create kernel pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927766"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 8:59 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/927766/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <p>OK, so how exactly, using the MMUs, do I determine if 0x1ffff is a kernel or a user address on SPARC? Take as read that I have valid page table mappings for 0x10000 to 0x80000 in both user and kernel ASIDs.
<p>Your claim continues to be that with the SPARC setup, while in kernel mode, I can determine if the address 0x1ffff is meant to be a kernel or a user address, and I just don't see how you can do that without knowing which address space I'm meant to use.
<p>The original claim is that using in-band signalling (top bit of address) for kernel versus user is valuable, since then I can do a trivial check on all addresses coming from userspace to confirm that they are not kernel addresses. This then means that I can fail very quickly if I attempt to use a user address as a kernel address, since I'm using different ASIDs for accesses, and when I use the kernel ASID to access a user address, it'll fault.


      
          <div class="CommentReplyButton">
            <form action="/Articles/927766/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 10:15 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/927777/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You distinguish it based on the "Address Space Identifier", a separate 8-bit tag, of which the first 0x80 are restricted to privileged code. The CPU can do a trivial check on the ASI before passing an address to the MMU. The MMU has to be supplied with the ASI and the address, so the address can be translated acccording to the correct context.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 10:22 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/927780/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>Yes, but the original claim that ballombe made was that with just the VA, no ASID, you can distinguish SPARC kernel and user mode addresses.
<p>He was responding to a comment that said that there were two ways of handling the kernel user split:
<ol>
<li>Use one bit from the VA space to distinguish kernel from user, and make sure that accesses with the wrong ASID fail if that bit is set to the wrong value. This means you can distinguish kernel and user addresses by the VA alone, and you can use the ASID hardware to make sure that accessing a kernel address with a user access ASID (either userspace or kernel accessing what it thinks is user address space) will fail.
<li>Permit the two spaces to overlap, and require the ASID alone to distinguish the two classes of address space. This has the disadvantage that you can no longer look at a VA and determine whether it's "meant" to be a kernel address or a user address, and thus when you have your "bad access" fault, you cannot look at the address and go "that's clearly bad - the VA is a kernel VA, but the ASID in use is a user ASID" or vice-versa.
</ol>
<p>The assertion made was that S/390 and SPARC don't work in either of those two ways, and that you neither use bits in the VA space to distinguish the two addresses, nor do you have a possible overlap between the two address spaces. I'm asking how SPARC and S/390 make that work.



      
          <div class="CommentReplyButton">
            <form action="/Articles/927780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 11:04 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/927787/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, sorry, I missed that aspect.<br>
<p>
Having just skimmed the SPARCv9 Architecture Manual to look up the ASID stuff, the ASID appears to be intrinsically required to translate addresses correctly with the right context. You can't tell from the VA, you need the ASID - that's the point. The ASID is always there as part of the translation, given implicitly or explicitly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 11:08 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/927788/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Yeah, that's what I'm familiar with from SPARCv8, where the CPU automatically uses different ASIDs for instruction and data fetches crossed with user or kernel, for 4 default ASIDs, plus has an override option for data fetches to use any ASID - but I was really hoping to hear about some clever trick in later SPARC definitions that gets me the benefits of both worlds, and the cost of neither.
<p>Otherwise, with large enough VAs, what you end up wanting is to use in-band signalling (top bit like in x86-64, for example) to indicate kernel or user address, with the separate ASIDs ensuring that if I'm fetching with a kernel-mode instruction fetch, I can't fetch from user addresses at all, nor can I fetch kernel data, while if I'm fetching with a user-mode overriden data fetch, I can't fetch from kernel addresses at all.


      
          <div class="CommentReplyButton">
            <form action="/Articles/927788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927792"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 11:38 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/927792/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The ASID space is expanded in v9 basically, it seems like - judging from what you've written and my (very cursory) skim of the v9 manual.<br>
<p>
I like the explicit tag of the ASID in SPARC. CPU can easily apply basic checks. If you're going to reserve bits to identify address space contexts, you might as well make it explicit. SPARC VAs can use the full address space, cause the ASID tag can be set in a separate register and left implicit for a stream of instructions (IIUC).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927792/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 12:38 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/927796/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That sounds similar to SPARCv8 - 256 ASIDs, 4 of which are predefined and used by default for all instructions that don't override ASID. The MMU is between CPU and L1 cache, and maps ASIDs to either context IDs for paging, or another memory map if there's a predefined mapping (e.g. if you follow SPARC recommendations, some ASIDs are used for 36 bits of direct map, others are used to access MMU register space). Caches track the context ID and virtual address, so that you don't have to flush caches when you change ASID to context ID mapping.
<p>For 32 bit systems, where VA space is at a premium, I get not reserving one bit for kernel/user distinction. But in 64 bit systems, where you have a very large VA space, I don't see that reserving one bit for kernel/user is a huge price to pay for the debuggability and security check simplification it gives you (you know up-front that any top-bit-set address is a kernel address, and top-bit-clear is a user address, even without knowing the context ID that you're going to use with that address). And you can program SPARC hardware with contexts that fault if user accesses are used for kernel addresses or vice-versa.


      
          <div class="CommentReplyButton">
            <form action="/Articles/927796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor927896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 15:36 UTC (Thu)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/927896/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think there's a big misunderstanding: the kernel does not mix kernel and user pointers. The latter are always tagged with __user, and always used with special accessors (e.g. copy_{from,to}_user()).  Hence there is no need to find out if a random VA points to kernel or user space.<br>
<p>
I assume the SPARC and s390 feature is similar, or an extension to what m68k provides: separate function codes for user and kernel (and for program and data, but that doesn't matter here).  M68k also has two sets of page tables: one for the kernel (supervisor), one for userspace.<br>
Hence userspace accesses are always translated by the user page tables.<br>
Kernel space accesses are translated by the kernel page tables, except when using the special MOVES instruction, which will access based on a preset function code.<br>
This mechanism supports having the full 4 GiB address space available to both kernel and user space ("4G/4G split"), without the need to split the address space in separate parts for kernel and user memory (e.g. "1G/3G" split) to let the kernel access user memory and kernel memory.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 15:41 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/927899/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>The kernel does not <em>deliberately</em> mix kernel and user pointers. However, it's not hard to find past bugs where the kernel has been tricked into reading from a pointer supplied by user space; being able to validate early on that this pointer is supposed to be an __user pointer, but has the VA format of a kernel pointer (or that this pointer has the VA format of a user pointer, but is not tagged as an __user pointer) is useful for actually finding such bugs.
<p>It's a non-issue as long as the kernel is completely free of bugs, which is the case you've described. But that's, unfortunately, not the world I live in.


      
          <div class="CommentReplyButton">
            <form action="/Articles/927899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor927523"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2023 11:22 UTC (Tue)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/927523/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But the thing I don't really understand is why something fairly new such as RISC-V didn't just go for a totally separate return stack from the start...</span><br>
<p>
1) RISC-V is an evolution of MIPS , so it isn't "really new".<br>
<p>
2) RISC-V creators targeted micro-controllers at the beginning, so if you expect any security improvement in RISC-V, you're going to be quite disappointed..<br>
They even removed the "trap on overflow" integer arithmetic operations that the MIPS had :-(<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927523/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2023 14:59 UTC (Thu)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/927892/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Minor nit: Krste and crew *published* against micro-controllers because those were the most reasonable comparisons. There was plenty of high-performance work, but no private funding interest at *that* time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor928338"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 5, 2023 12:00 UTC (Wed)
                               by <b>andy_shev</b> (subscriber, #75870)
                              [<a href="/Articles/928338/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe because the human being nature is to be lazy and not repeat ourselves? That trend usually visible in pharmacy and medicine when MDs are trying to reuse the old drugs against new deseases.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/928338/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor927230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 16:23 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/927230/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The quote-box ("Same old SHSTK") here looks quite bad under default dark mode colors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2023 20:59 UTC (Sat)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/927319/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Try these colours instead, it looks fine:<br>
<p>
Page background color:	#ffffff<br>
Left column color:	#ffcc99<br>
Middle column background:	#ffffff<br>
Headline background:	#ffcc99<br>
Form/byline background:	#eeeeee<br>
Sidebar background:	#ffcc99<br>
Text color:	black<br>
Link color:	DarkBlue<br>
Visited link color:	#444<br>
Quoted text (in email) color:	#990099<br>
Old (seen) comment background color:	#cccccc<br>
Logo color: green<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor927738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Dark mode colors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2023 22:45 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/927738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      So the color messup was the result of a dumb typo in the definitions of those colors; I have fixed it now.  You will probably have to go into the customization area and re-select the dark-mode colors to get the fix, unfortunately; apologies for that.


      
          <div class="CommentReplyButton">
            <form action="/Articles/927738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor927231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 16:33 UTC (Fri)
                               by <b>stop50</b> (subscriber, #154894)
                              [<a href="/Articles/927231/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why was pypy compiled already with the shadowstack elf info?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927297"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2023 12:55 UTC (Sat)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/927297/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compiler adds it by default to all of the object files it produces. That is okay if there is even a single assembly source file, but not if the runtime compilation or stack switching is done entirely with C code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927297/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor927233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 16:59 UTC (Fri)
                               by <b>old</b> (subscriber, #154324)
                              [<a href="/Articles/927233/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Shadow stack is also a real pain for dynamic instrumentation in userspace when changing the return address on the stack to instrument function's entry/exit like kretprobe does.<br>
<p>
Great to see the ARCH_SHSTK_UNLOCK thanks to CRIU.  That should be enough to ease the pain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor928442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2023 8:36 UTC (Thu)
                               by <b>andrey.turkin</b> (guest, #89915)
                              [<a href="/Articles/928442/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also every fiber implementation out there has to be retrofitted with shadow stack support.<br>
On the other hand, it is very handy to have a separate stack filled only with the actual call flow - it could allow for a very quick and reliable way to get a stack trace (without the stack frames but many tools don't actually need it).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/928442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor927249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2023 19:28 UTC (Fri)
                               by <b>fredex</b> (subscriber, #11727)
                              [<a href="/Articles/927249/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SHSTK. add a VCH at the end and you (almost) have Shostakovich. Speaking of Russian...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor927291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2023 9:27 UTC (Sat)
                               by <b>dottedmag</b> (subscriber, #18590)
                              [<a href="/Articles/927291/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Shadow stack virtual channel, hmmm<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/927291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor927343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PTRACE_ARCH_PRCTL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 26, 2023 11:03 UTC (Sun)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/927343/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <a href="https://lwn.net/ml/linux-kernel/20221203003606.6838-39-rick.p.edgecombe@intel.com/">[PATCH v4 38/39] x86/shstk: Add ARCH_SHSTK_UNLOCK</a> mentions "the ptrace arch_prctl interface," which I hadn't heard of before and appears to be undocumented - the arch_prctl(2) and ptrace(2) manpages don't mention each other.
<p>
It looks like this is an x86_64-specific extension. From arch/x86/kernel/ptrace.c:
<p>
<pre>
#ifdef CONFIG_X86_64
                /* normal 64bit interface to access TLS data.
                   Works just like arch_prctl, except that the arguments
                   are reversed. */
        case PTRACE_ARCH_PRCTL:
                ret = do_arch_prctl_64(child, data, addr);
                break;
#endif
</pre>
<p>
That is, to call <tt>arch_prctl(code, addr)</tt> on a proces you're tracing, run <tt>ptrace(PTRACE_ARCH_PRCTL, pid, addr, code)</tt>. For the specific operation in this patch, it would be <tt>ptrace(PTRACE_ARCH_PRCTL, pid, features, ARCH_SHSTK_UNLOCK)</tt>, I think.




      
          <div class="CommentReplyButton">
            <form action="/Articles/927343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor929633"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2023 13:34 UTC (Thu)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/929633/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A 64-bit thread may switch to 32-bit mode without the kernel's knowledge? How does that happen?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/929633/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930520"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2023 20:36 UTC (Sat)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/930520/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whether you're in the 32bit or 64bit submode of long mode is configured via attributes on the current code segment.<br>
<p>
On Linux, code segments with both attributes are available for all processes, so you can flip back and forth with just:<br>
ljmp $0x33, label ; jump to label in 64bit mode<br>
ljmp $0x23, label ; jump to label in 32bit mode<br>
<p>
The numbers correspond to __USER_CS and __USER32_CS from <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/segment.h">https://github.com/torvalds/linux/blob/master/arch/x86/in...</a><br>
<p>
I don't know if there's any real non-exploit code which actually does this, though...<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930520/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space shadow stacks (maybe) for 6.4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2023 21:49 UTC (Sat)
                               by <b>dtlin</b> (subscriber, #36537)
                              [<a href="/Articles/930521/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That must be how Wine's WoW64 works (<a href="https://www.winehq.org/announce/8.0">https://www.winehq.org/announce/8.0</a>). 32-bit code running inside a 64-bit process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
