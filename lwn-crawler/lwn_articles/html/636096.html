        <!DOCTYPE html>
        <html lang="en">
        <head><title>Progress on persistent memory [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/636096/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/635612/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/636096/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Progress on persistent memory</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>March 11, 2015</br>
           <hr>
<a href="/Articles/lsfmm2015">LSFMM 2015</a>
</div>
<p>
It has been "the year of persistent memory" for several years now, Matthew
Wilcox said with a chuckle to open his plenary session at the 2015 <a
href="http://events.linuxfoundation.org/events/linux-storage-filesystem-and-mm-summit">Storage,
Filesystem, and Memory Management summit</a> in Boston on March&nbsp;9.  
Persistent memory refers to devices that can be accessed like RAM, but will
permanently store any data written to them.
The
good news is that there are some battery-backed DIMMs already available,
but those have a fairly small capacity at this point (8GB, for example).
There are much larger devices coming, 400GB was mentioned, but it is
not known when they will be shipping.  From Wilcox's talk, it is
clear that the two different classes of devices will have different use
cases, so they may be handled differently by the kernel.
</p>

<p>
It is good news that there are "exciting new memory products" in
development, he said, but it may still be some time before we see them on
the market.  He is not sure that we will see them this year, for example. It turns out that development delays sometimes happen when
companies are dealing with "new kinds of physics".
</p>

<a href="/Articles/636260/">
<img src="https://static.lwn.net/images/2015/lsf-wilcox-sm.jpg" border=0 hspace=5 align="left"
alt="[Matthew Wilcox]" title="Matthew Wilcox" height=250 width=235>
</a>

<p>
Christoph Hellwig jumped in early on in the talk to ask if Wilcox's
employer, Intel, would be
releasing its driver for persistent memory devices anytime soon.  Wilcox
was obviously unhappy with the situation, but said that the driver could
not be released until the ACPI specification for how the device describes
itself to the system is released.  That is part of the ACPI&nbsp;6 process,
which will be released "when ACPI gets around to it".  As soon as that
happens, Intel will release its driver.  

<p>
James Bottomley noted that there
is a process within UEFI (which oversees ACPI) to release portions of
specifications if there is general agreement by the participants to do
so.  He encouraged Intel to take advantage of that process.
</p>

<p>
Another attendee asked whether it was possible to write a driver today that would
work with all of the prototype devices tested but wouldn't corrupt any other
of the other prototypes that had not been tested.   Wilcox said no; at
this point that isn't the case. "It is frustrating", he said.
</p>

<h4>Persistent memory and <tt>struct page</tt></h4>

<p>
He then moved on to a topic he thought would be of interest to the memory-management folks in attendance. With a 4KB page size, and a <tt>struct
page</tt> for each page, the 400GB device he mentioned would require 6GB just to
track those pages in the kernel.  That is probably too much space to "waste" for those
devices.
But if the kernel tracks the memory with page structures, it can be treated
as normal memory.  Otherwise, some layer, like a block device API, will be
needed to access the device.

<p>
Wilcox has been operating under the assumption that those
kinds of devices won't use <tt>struct page</tt>.  On the other hand, Boaz
Harrosh (who was not present at the summit) has been pushing <a href="/Articles/608538/">patches</a> for
other, smaller 
devices, and those 
patches do use <tt>struct page</tt>.  That makes sense for that use case,
Wilcox said, but it is not the kind of device he has been targeting.
</p>

<p>
Those larger devices  have wear characteristics that
are akin to those of NAND 
flash, but it isn't "5000 cycles and the bit is dead".  The
devices have wear lifetimes of 10<sup>7</sup> or 10<sup>8</sup>
cycles.  In terms of access times, some are even faster than DRAM, he said.
</p>

<p>
Ted Ts'o suggested that the different capacity devices might need to be
treated differently.  Dave Chinner agreed, saying that the battery-backed
devices are effectively RAM, while the larger devices are storage, which
could be handled as block devices.
</p>

<p>
Wilcox said he has some preliminary patches to replace calls to
<tt>get_user_pages()</tt> for these devices with a new call, <tt>get_user_sg()</tt>,
which gets a scatter/gather 
list, rather than pages.  That way, there is no need to have all those page
structures to handle these kinds of devices.  Users can treat the device as
a block device.  They 
can put a filesystem on it and use <tt>mmap()</tt> for data access.
</p>

<p>
That led to a discussion about what to do to handle a
<tt>truncate()</tt> on a file that has been mapped with <tt>mmap()</tt>.
Wilcox thinks that Unix, thus Linux, has the wrong behavior in that
scenario.  If a program accesses memory that is no longer part of the
mapped file due to the truncation, it gets a
<tt>SIGSEGV</tt>.  Instead, he thinks that the <tt>truncate()</tt> call
should be made to wait until the memory is unmapped.
</p>

<p>
Making <tt>truncate()</tt> wait is trivial to implement, Peter Zijlstra
said, but it certainly changes the current behavior.  He suggested adding a
flag to <tt>mmap()</tt> to request this mode of operation.  That should
reduce the surprise factor as it makes the behavior dependent on what is
being mapped.  Ts'o said that he didn't think the kernel could
unconditionally block truncate operations for hours or days without
breaking some applications.
</p>

<p>
Getting back to the question of the drivers, Ts'o asked what decisions
needed to be made and by when.  The battery-backed devices are out there
now, so patches to support them should go in soon, one attendee said.
Hellwig said that it would make sense to have Harrosh's driver and the
Intel driver in the kernel.  People could then choose the one that made
sense for their device.  In general, that was agreeable, but the driver for
the battery-backed devices still needs some work before it will be ready to
merge.  Bottomley noted that means that the group has decided to have two
drivers, "one that needs cleaning up and one we haven't seen".
</p>

<h4>New instructions</h4>

<p>
Wilcox turned to three new instructions that Intel has announced for
its upcoming processors that can be used to better support persistent
memory and other devices.  The first is <tt>clflushopt</tt>, which adds
guarantees to the cache-line flush (<tt>clflush</tt>) instruction.  The
main benefit is that it is faster than 
<tt>clflush</tt>.  Cache-line writeback (<tt>clwb</tt>) is another, which
writes the cache line back to memory, but still leaves it in the cache.  The
third is <tt>pcommit</tt>, which acts as a sort of barrier to ensure that
any prior cache flushes or writebacks actually get to memory. 
</p>

<p>
The effect of <tt>pcommit</tt> is global for all cores.  The idea is to do
all of the flushes, then <tt>pcommit</tt>; when it is done, all that data
will have been written. On current processors, there is no way to be sure
that everything has been stored.  He said that <tt>pcommit</tt> support
still needs to be added to DAX, the <a href="/Articles/591779/">direct
access block layer</a> for persistent memory devices that he developed.
</p>

<p>
Ts'o asked about other processors that don't have support for those kinds
of instructions, but Wilcox didn't have much of an answer for that.  He
works for Intel, so other vendors will have to come up with their own
solutions there.
</p>

<p>
There was also a question about adding a per-CPU commit, which Wilcox said
was under internal discussion.  But Bottomley thought that if there were
more complicated options, that could just lead to more problems.  Rik van
Riel noted that the scheduler could move the process to a new CPU halfway through a
transaction anyway, so the target CPU wouldn't necessarily be clear.
In answer to another question, Wilcox assured everyone that the flush
operations would not be slower than existing solutions for SATA, SAS, and others.
</p>

<h4>Error handling</h4>

<p>
His final topic was error handling.  There is no status register that
gives error indications when you access a persistent memory device, since
it is treated like memory.  An error causes a machine check, which typically
results in a reboot.  But if the problem persists, it could just result in
another reboot when the device is accessed again, which will not work all
that well.
</p>

<p>
To combat this, there will be a log of errors for the device that can be
consulted at startup.  It will record the block device address where
problems occur and filesystems will need to be able to map that back to a
file and offset, which is "not the usual direction for a filesystem".
Chinner spoke up to say that XFS would have this feature "soon".  Ts'o 
seemed to indicate ext4 would also be able to do it.
</p>

<p>
But "crashing is not a great error discovery technique", Ric Wheeler said;
it is "moderately bad" for enterprise users to have to reboot their systems that
way.  But handling the problems when an <tt>mmap()</tt> is done for that
bad region in the device is not easy either.  Several suggestions were
made (a signal from the <tt>mmap()</tt> call or when the page table entry
is created, for example), but any of them mean that user space needs to be able to
handle the errors.  

<p>
In addition, Chris Mason said that users are going to
expect to be able to <tt>mmap()</tt> a large file that has one bad page and
still access all of the other pages from the file.  That may not be
reasonable, but is what they will expect.  At that point, the discussion
ran out of time without reaching any real conclusion on error handling.
</p>

<p>
[I would like to thank the Linux Foundation for travel support to Boston
for the summit.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Nonvolatile_memory">Memory management/Nonvolatile memory</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_and_Memory-Management_Summit-2015">Storage, Filesystem, and Memory-Management Summit/2015</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/636096/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor636471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Progress on persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2015 13:52 UTC (Thu)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/636471/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I had 400GB of main memory in my computer, I wouldn't care about 'wasting' 6GiB for page handling.<br>
<p>
If this really is a problem for some people, the device could be partitioned into 'memory' and 'storage.' 16 GiB might be used for memory and the rest is storage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/636471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor636475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Progress on persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2015 14:22 UTC (Thu)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/636475/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The low cache hit ratio (tlb, l1-l3) die to the massive page tables might end up annoying you considerably though. Page faults are often a significant contributor to runtime.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/636475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor636483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Progress on persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2015 15:22 UTC (Thu)
                               by <b>mtanski</b> (guest, #56423)
                              [<a href="/Articles/636483/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I really hope IO errors in new memory technologies translate to similar semantics as the current IO errors in mmap regions. Eg a SIGBUS to the process / thread making the call.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/636483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor636695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Progress on persistent memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2015 15:37 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/636695/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; battery-backed DIMMs</font><br>
<p>
Obviously those are DIMMs, someone knows if the 400 Gbytes devices are DIMMs too, or do they hide behind a PCIe bus?<br>
Does DIMMs have enough "address lines" for such a range?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/636695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor636708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking truncate()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2015 17:07 UTC (Fri)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/636708/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; He suggested adding a flag to mmap() to request this mode of operation. That should reduce the surprise factor as it makes the behavior dependent on what is being mapped.</font><br>
<p>
Having truncate() block potentially forever, without a special flag to the truncate() call, would still be surprising behavior. Say a sysadmin notices a "hung" process; how would he find that it was a truncate() waiting for a mmap(), and most important, how would he find which are the files involved and which process he should kill so the truncate() goes ahead?<br>
<p>
It would be as annoying as "mandatory locking".<br>
<p>
We already sort of have that problem with NFS, but with NFS it's easy to find (check the server for all mounted filesystems to see if any isn't responding) and solve (reboot the hung server).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/636708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor636743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking truncate()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2015 21:16 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/636743/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
strace would show the program blocking on truncate(14) for example.<br>
<p>
Then lsof would show that file handle 14 is /nvm/datafile.<br>
<p>
fuser -v /nvm/datafile shows the programs using it.<br>
<p>
I think that sequence of commands would do the trick.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/636743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor636839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking truncate()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2015 14:52 UTC (Sun)
                               by <b>pflugstad</b> (subscriber, #224)
                              [<a href="/Articles/636839/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And wouldn't you want to use huge pages for something like that?  That would cut down on overhead quite a bit...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/636839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor639828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blocking truncate()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2015 18:53 UTC (Thu)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/639828/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMHO it's not good to block the truncate() syscall instead remember the intended file-size.  I seen it like an unlink() on a file which has an open fd, the resource is released after the last usage ended.<br>
<p>
What happens if a write enlarges the file to have a new backing for the mmapped region?  If the truncate is blocked, would it revert this enlargement after unmap()?<br>
<p>
Blocking the truncating process opens needlessly a can of worms.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/639828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor637331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Swap memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2015 21:34 UTC (Thu)
                               by <b>Tov</b> (subscriber, #61080)
                              [<a href="/Articles/637331/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK, so we will soon get a really fast Non-Volative Random Access Memory with wear characteristics.<br>
<p>
Wouldn't that be an excellent candidate for a "swap-like" memory with random read-only access and execute in place?<br>
<p>
That would mean:<br>
- Really fast suspend/resume!<br>
- Read-only memory (like code segments) can be swapped out immediately on load<br>
- Swap out based on "least written" semantics instead of "least accessed"<br>
- Fault to DRAM on write instead of fault on access (to avoid excessive wear)<br>
- ECC should be used together with some BadRAM-like blacklisting<br>
<p>
It would really be a shame to convert this fast random access memory to a block storage - something like using your hard drive as a tape storage :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/637331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
