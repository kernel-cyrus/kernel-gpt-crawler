        <!DOCTYPE html>
        <html lang="en">
        <head><title>Shrinking the scheduler [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/725376/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/724935/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/725376/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Shrinking the scheduler</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 14, 2017</br>
           </div>
The ups and downs of patching the kernel to wedge Linux into tiny systems has been
debated numerous times over the years, most recently in the context of
Nicolas Pitre's <a href="/Articles/721074/">alternative TTY layer
patches</a> posted in April.  Pitre is driving the debate again, this time by <a
href="/Articles/724768/">trying to shrink the kernel's CPU scheduler</a>.
In the process, he has exposed a couple of areas of fundamental
disagreement on the value of this kind of work.
<p>
Pitre's goal is to make it possible to run a system based on a Linux kernel
on a processor with as little as 256KB of memory.  Doing so requires more
than just making code and data structures smaller; he has to
simply eliminate as much code as possible.  With the TTY patches, he
replaced the TTY subsystem outright with a much smaller (and less capable)
alternative.  His approach with the scheduler is different: the kernel's
core scheduler remains when his patches are active, but a number of
features, including the realtime and deadline scheduler classes, are
compiled out.  The resulting scheduler is 25% smaller at the cost of
features that will almost certainly not be used on tiny systems anyway.
<p>
As is often the case with "tinification" patches, the scheduler patches
were given a chilly reception, with Ingo Molnar <a
href="/Articles/725378/">rejecting</a> them outright.  In the ensuing
discussion, it became clear that there were two points of core disagreement
on the value of these patches.
<p>
Alan Cox <a href="/Articles/725379/">argued</a> that a kernel configured
for such small systems isn't really Linux anymore:
<p>
<div class="BigQuote">
	So once you've rewritten the tty layer, the device drivers, the VFS
	and removed most of the syscalls why even pretend it's Linux any
	more. It's something else, and that something else is totally
	architecturally incompatible with Linux. That's btw a good thing -
	trying to fit Linux directly into such a tiny device isn't sensible
	because the core assumptions you make about scalability are just
	totally different.
</div>
<p>
His suggestion was to create an entirely new kernel, borrowing bits of
Linux source where it helps.  Pitre's <a
href="/Articles/725380/">response</a> was that this approach has been tried
many times without success.  Special-purpose kernels tend to be small
projects with few developers; they progress slowly, are poorly maintained,
and suffer from a lack 
of code review.  By making it possible to use much of the Linux kernel,
including, importantly, its device drivers, Pitre hopes to pull together
the tiny-systems community around a single, well-supported alternative.
<p>
Molnar's <a href="/Articles/725382/">argument</a>, instead, was that the
value obtained by supporting such small systems is not worth the cost, as
measured in code complexity.  Moore's law may be slowing down, he said, but
these systems will still become more capable over time.  Given the time
that passes between the application of a scheduler patch and its appearance
in distributions and products — between two and five years — there may be
no need for this work by the 
time it becomes widely available.  Given that, he argued, it is far more
important to reduce the complexity of the scheduler than to reduce its
size:
<p>
<div class="BigQuote">
	So while it obviously the "complexity vs. kernel size" trade-off
	will always be a judgment call, for the scheduler it's not really
	an open question what we need to do at this stage: we need to
	reduce complexity and #ifdef variants, not increase it.
</div>
<p>
Pitre <a href="/Articles/725385/">disagreed</a> with Molnar on every
point.  The smallest systems, he said, will remain small for economic
reasons:
<p>
<div class="BigQuote">
	Your prediction is based on a false premise. There is simply no
	money to be made with IoT hardware, especially in the low end.
	Those little devices will be given away for free because it is in
	the service subscription that the money is. So the hardware has to,
	and will be, extremely cheap to produce.
</div>
<p>
The need for extremely low power consumption, so that a system can run for
months or years on a single battery, will also keep these systems small.
With regard to the time lag for adoption of the changes, he pointed out
that much of the Android-related code that has gone into the mainline has
been merged years <i>after</i> being deployed in products; the timing tends to be
reversed in that part of the market.  He also argued that his patches
actually reduce the complexity of the scheduler code by factoring out the
different scheduler classes and making it possible to remove them.
<p>
The conversation did not progress much beyond that point.  There was one
important bit of progress, though: Molnar <a
href="/Articles/725388/">agreed</a> that Pitre's code-movement patches make
the scheduler more maintainable.  He requested that those patches be posted
on their own so that they can be merged; that, he said, "<q>should make
future arguments easier</q>".  Pitre <a href="/Articles/725389/">has
obliged</a>, but there has been no discussion of the new patches as of this
writing.  Should they be accepted, the remaining changes, which actually
compile out those scheduler classes, should be quite small.
<p>
It is clear that getting core kernel maintainers to accept the costs
associated with supporting tiny systems will always be a hard sell.  In
this case, the tiny-systems community has a developer who is determined to
get the job done, but who is also familiar with how kernel development
works and is willing to make the changes needed to get his patches merged.
That still doesn't guarantee success in this inherently difficult — if not
quixotic — endeavor, but the odds this time around would seem to be better
than with previous attempts which, as can be seen <a
href="/Articles/597529/">here</a> or <a href="/Articles/624258/">here</a>,
have not always gone well.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Embedded_systems">Embedded systems</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler">Scheduler</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/725376/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor725404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2017 20:01 UTC (Wed)
                               by <b>atelszewski</b> (guest, #111673)
                              [<a href="/Articles/725404/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
<p>
I support Pitre's work. But that's probably something that only embedded systems developers can truly understand.<br>
<p>
The availability of drivers is the key.<br>
<p>
--<br>
Best regards,<br>
Andrzej Telszewski<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2017 21:07 UTC (Wed)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/725416/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree that his work is important, but I think Alan Cox is onto the right thing here. I expect that if the code were put into Linux, the code reviews that Pitre expects would not happen as much in the areas that he needs them to be. Instead it would be a continual slog about how this 'little' thing was holding back Linux. Doing a 'fork' and rebase may be a lot less work over time because the politics about patching will be about "does this make X better" versus "why is X even in the kernel in the first place."<br>
<p>
I would say the best way to get people focused on uPitrix would be to just say "This is focused on hardware like the Raspberry Pi.  " :). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2017 21:38 UTC (Wed)
                               by <b>atelszewski</b> (guest, #111673)
                              [<a href="/Articles/725418/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I like the initiative itself. I hope it'll make it into mainline this or the other way.<br>
And by the way, RPi is a beast compared to what we are talking about here ;-)<br>
<p>
Take a look at some STM32 parts, some of them are already supported by the mainline kernel.<br>
Since I've been working a lot with STM32s, I'm very enthusiastic about everything that can possibly make mainline Linux run on them.<br>
<p>
I think the keyword here is _mainline_.<br>
We love devices that are supported by mainline :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor725407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2017 20:13 UTC (Wed)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/725407/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not a kernel, IoT, or bit-banging dev, so I may be missing important context..  However, it sounds as if there is an important tangential topic that wasn't directly discussed: what level of code maintenance trade off is reasonable for supporting modularity/plugability for out of tree components?  "hyper" plugability has been a real asset for keeping the core size manageable for some projects.  Jenkins may be a good example of that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 9:53 UTC (Thu)
                               by <b>edeloget</b> (subscriber, #88392)
                              [<a href="/Articles/725457/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; what level of code maintenance trade off is reasonable for supporting modularity/plugability for out of tree components?</font><br>
<p>
For what I understand about the Linux kernel, the balance goes towards "if you want to make out-of-tree components, do it, but don't bother us with them  ; you're on your own, dude". Which is quite a good answer. I'm not sure I want a LHQL sticker on the products I buy :). You want your device to be supported in Linux, you'd better send a patch to the LKML :)<br>
<p>
On the base discussion: I've worked for many years in the embedded world, and I tend to think that Pitre is at least a bit right here. Small devices will remain small devices for decades. That does not mean that they won't have large quantity of RAM (by today standards) or an ultra-fast CPU (again, by today standard). But In 50 years, you'll still find devices running with 8 cores at 2GhZ, with 2GB or RAM -- and I expect these devices to be very small when compared to the behemots we'll have in our pockets (smartphones) and on our desks. I'm pretty sure you'll have even smaller ones (by today standard ; who needs a quad core A72 to control a light?) And in 50 years, Linux will still be developed on desk computers, targeting servers, workstations, and handsets. Meaning that you'll have the same kind of debates : "these machines are too small, there is no real interest for supporting them when you consider the support cost". <br>
<p>
We are already blessed. We can select the features the kernel supports with a simple make menuconfig. There should be a way to be even more modular in core areas of the kernel without producing difficult-to-maintain code. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 15:13 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/725475/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Actually, I expect that even the 256KB spot that Pitre targets will be relevant for many years to come.  It may be that the applications that today run on 256KB machines will run on 1MB machines a few years down the road, and 4MB some more years later, because the hardware becomes cheaper and the application developers want to make use of that to put more functionality in, but at the same time you get 256KB machines at a cheaper price point, and the developers for systems at this price point will feel the need for something (such as Linux) more advanced than they use now (which was adequate for 64KB systems) in order to make good use of the increased amount of RAM.

<p>Mainframes had 256KB in the 60s, minicomputers in the 70s, microcomputers in the 80s, and now it's 50 years later, and we still have systems with 256KB RAM.  We actually even have stuff like the <a href="http://www.microchip.com/wwwproducts/en/ATTINY4">ATTINY4</a> with 256B (not KB) of RAM.
      
          <div class="CommentReplyButton">
            <form action="/Articles/725475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 11:09 UTC (Thu)
                               by <b>mbar</b> (guest, #73813)
                              [<a href="/Articles/726195/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I ran Slackware on a 486 with 4MB of RAM like 20 years ago.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor725415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2017 21:11 UTC (Wed)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/725415/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Molnar's argument, instead, was that the value obtained by supporting such small systems is not worth the […]code complexity [cost].</font><br>
<p>
That is discriminating small systems efforts: Supporting the huge systems also has had an impact on code complexity. 4- and 5-level page tabling comes to mind, for example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 9:03 UTC (Thu)
                               by <b>Lionel_Debroux</b> (subscriber, #30014)
                              [<a href="/Articles/725452/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed. The difference is that this kind of complexity sells easily to core kernel devs, who don't seem to be accustomed to / care about the needs of some embedded platforms.<br>
They're right that hardware is cheap, and that from a technical POV, higher-powered hardware makes sense, unless it reduces battery life in unacceptable ways. However, the decisions are often non-technical, made by non-engineers. As a matter of fact, adding some RAM / storage space in order to be able to use a tiny Linux and reap benefits such as lower cost at _development_ time, raises the cost of every item by a small fraction of a dollar at _production_ time, yielding a much higher toll on the price tag for end consumers (companies or individuals) and subsequently making the product harder to sell than less powerful competing products...<br>
<p>
The tinification work by Nicolas Pitre and others yields good results, but unfortunately, it has to be maintained out of tree...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 15:54 UTC (Thu)
                               by <b>perlwolf</b> (guest, #46060)
                              [<a href="/Articles/726242/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It makes sense that supporting features for huge systems can be sold to the kernel developers - the features of today's huge systems will be standard features on tomorrow's personal large systems, and ubiquitous on non-embedded systems a cycle after that, so they will need to be added to the kernel at some point.  Letting the large systems people get the bugs out so that the features are ready for adoption by the masses makes sense.  Adding support for retrograde capabilities does not have any obvious positive payback in the area that most developers care about, only negative issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor725465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 14:04 UTC (Thu)
                               by <b>rgmoore</b> (<b>&#x272D; supporter &#x272D;</b>, #75)
                              [<a href="/Articles/725465/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>I think there are two important points that make supporting huge systems more sensible than supporting tiny ones.  The first is simple developer availability.  Huge systems are expensive and have high margins, which means the companies making them have the money to afford plenty of developer time, while tiny devices are cheap and have low margins, which means companies can't afford the same number of developers to work on them.  That makes a huge practical difference.  Look at the kernel developer stats, and you'll see a lot of companies that are either developing big iron or software that runs on big iron compared to the number who are developing IOT devices.

<p>The other important point is that systems in general are getting bigger and more powerful.  That means development effort put into systems that look unreasonably high end today will pay off for more ordinary systems five or ten years from now.  A good example of this kind of thing is the effort that was put into NUMA years ago.  There was some criticism of it back then because it was seen as an exotic configuration, but those features are used on ordinary desktop systems today.  There's no similar driving force for ever smaller systems, so there's much less reason to work on shrinking the kernel as a way of preparing for the future.
      
          <div class="CommentReplyButton">
            <form action="/Articles/725465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2017 17:11 UTC (Fri)
                               by <b>svenkatr</b> (guest, #73356)
                              [<a href="/Articles/725594/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
|Look at the kernel developer stats, and you'll see a lot of companies that are either developing big iron or software <br>
<p>
That's sampling bias. A lot of embedded device companies don't participate in upstream kernel development because of these kind of emphasis on big iron.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor725654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2017 16:16 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/725654/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Or maybe it's just that big systems need or can afford that much more developer effort.  E.g., if you have only 256KB, you do not need a scheduler that scales up to millions of tasks; a relatively simple scheduler will suffice, and you consequently will not be investing that much developer effort in it; you can also not afford such a scheduler, because it would consume too much memory.  So the amount of developer time spent on big systems might be seen as the cost of supporting big systems rather than as benefit.

<p>BTW, ordinary desktop systems have only one socket and therefore don't have NUMA, and this will stay that way in the foreseeable future.  Affordable (Opteron) systems with NUMA appeared in 2003, as did the 2.6 kernel, the first stable kernel with NUMA support, so these developments were not 5-10 years apart.
      
          <div class="CommentReplyButton">
            <form action="/Articles/725654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2017 5:36 UTC (Sun)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/725680/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; BTW, ordinary desktop systems have only one socket and therefore don't have NUMA</font><br>
Newer Intel/AMD chips are NUMA internally. You'll get very poor performance out of them if you assume all 16/22/32/whatever cores have equal latency to RAM and each other.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2017 13:57 UTC (Sun)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/725695/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
[reliable source needed]<br>
<p>
I heard this claim a lot from self-appointed YouTube CPU reviewers who used this as justification why Ryzen's performance was poor in Windows games. It's true that the scheduler may need tuning for new CPUs. But it's an unjustified leap to claim that it's because they are NUMA systems, which I have seen no good evidence for.<br>
<p>
NUMA implies that there are multiple memory controllers in the system. And some cores have faster access to some memory (controllers) than the others. But nowhere in the tech specs of these CPUs I have seen multiple memory controllers. If all cores are attached to a single memory controller, how can you call the memory non-uniform? For example this diagram shows a single "Unified Memory Controller": <a href="https://i1.wp.com/thetechaltar.com/wp-content/uploads/2017/03/C6eUL0DWAAAeCQG.jpg">https://i1.wp.com/thetechaltar.com/wp-content/uploads/201...</a><br>
<p>
It's true that cores have different latency/performance to different caches. But it has been like this since the beginning of multi-core CPUs -- L1 cache is always per-core and obviously accessing that memory from another core is going to cost more. I dunno if anything has significantly changed in this area. To make up terms, you can call it a NUCA (non-uniform cache access) architecture of NUMA-like cache, if you like, but it does not make it a NUMA system.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2017 14:45 UTC (Sun)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/725697/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is correct for typical desktop CPUs, but apparently when you get into high-core-count systems (&gt;= 10 cores per socket) using Haswell or later Intel CPUs there actually are multiple independent memory controllers on the die and NUMA effects  can come into play. From &lt;<a href="https://www.starwindsoftware.com/blog/numa-and-cluster-on-die">https://www.starwindsoftware.com/blog/numa-and-cluster-on...</a>&gt;:<br>
<p>
<font class="QuotedText">&gt; Basically, with MCC and HCC CPUs Intel started to run into the same issue of “too many CPUs on the same shared bus”. So it went further to split sockets into logical domains. ... Therefore, MCC and HCC have two memory controllers per CPU socket whereas LCC CPUs has one only. ... COD can be enabled on MCC and HCC due to double number of memory controllers. ... The NUMA node with enabled COD is split into two NUMA domain and then – each owns half of the cores, memory channels and last level cache. Each domain, which includes memory controller and cores, is called a cluster.</font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor725749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2017 7:51 UTC (Mon)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/725749/">Link</a>] 
      </p>
      
      </div>
      </summary>
      16+-core chips are not used in "ordinary desktop systems".  There is even a marketing term "HEDT" (high-end desk top) for non-server systems that use such chips that makes it obvious that they are not "ordinary".

<p>Concerning the claims of "very poor performance", I would like to see some empirical support for that.

<p>Concerning caches, the difference between main memory and caches is that the hardware migrates the data to the local caches of the CPU.  By contrast, the hardware does not do that for main memory, so OS NUMA support contains stuff like page migration that tries to provide that property for main memory.  What is useful for caches is to keep threads on the same core, but I don't think that the Linux NUMA optimizations are about that.
      
          <div class="CommentReplyButton">
            <form action="/Articles/725749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor725450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Cutting out code without crufting up #ifdefs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 6:48 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/725450/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As an outsider to kernel development this sounds like a great project (it appeals to a sense of "back when I were a lad") but I can appreciate why kernel developers don't want lots of #ifdef conditional compilation crufting up their code.  Is there a way to cut out unused blocks of object code without making big changes to the source?<br>
<p>
Perhaps the compiler could become smarter given a few hints.  If you could declare that one of the possible values of an enum is never used, then the compiler would know that any code conditional on that value could be eliminated.  Similarly, if the code that reads the scheduler configuration (from files in /proc or wherever it comes from) had a small change so it can never switch to the realtime scheduler, a smart enough compiler or linker would see that this code is never called.<br>
<p>
Going a step further, partial evaluation might be used to specialize the code given fixed values for certain configuration settings.<br>
<p>
(All this assumes that the work consists of removing code and restricting the allowed configuration options for existing features.  That's not the case for the earlier TTY work, which was a new implementation.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Cutting out code without crufting up #ifdefs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 9:24 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/725454/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As an outsider to kernel development this sounds like a great project (it appeals to a sense of "back when I were a lad") but I can appreciate why kernel developers don't want lots of #ifdef conditional compilation crufting up their code. Is there a way to cut out unused blocks of object code without making big changes to the source?</font><br>
<p>
"back when I were a lad" - Linux on a Spectrum?<br>
<p>
I can see that lots of conditional compilation might not go down well, but sensible restructuring and simplification might do (and the end of the article suggests that it is).  In that case this project could potentially benefit, not burden the rest of the kernel.  Perhaps the project should go along the lines of the real-time tree, as a permanent fork but with a permanent focus on reducing the gap.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Cutting out code without crufting up #ifdefs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 9:38 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/725456/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was thinking of Minix 1 on 640 kilobyte systems or even the early days of Linux with four megabytes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor725506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Cutting out code without crufting up #ifdefs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 15:55 UTC (Thu)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/725506/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Like you, from a user perspective and not a developer perspective - smaller kernel means more memory available for my applications to use, and more of the functionality tending to stay in the CPU cache.  Let's face it - the simple fact of the speed of light means the CPU cache is *always* going to be faster than any external memory, and no matter how much RAM I have, I'm always going to want more.<br>
<p>
Working monolithic is better than theoretical modular, but working modular that is adjustably smaller and faster is better yet - and can be done once the monolithic version is working.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor725662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Cutting out code without crufting up #ifdefs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2017 17:49 UTC (Sat)
                               by <b>imMute</b> (guest, #96323)
                              [<a href="/Articles/725662/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;As an outsider to kernel development this sounds like a great project (it appeals to a sense of "back when I were a lad") but I can appreciate why kernel developers don't want lots of #ifdef conditional compilation crufting up their code. Is there a way to cut out unused blocks of object code without making big changes to the source?</font></br>
</br>
Yes, the kernel's Makefile system can conditionally compile entire source files.  Depending on configuration (and how the Makefiles are setup) a file could be entirely skipped, compiled into the kernel image, or compiled into a loadable module.</br>
</br>
See the Kconfig <a href="http://elixir.free-electrons.com/linux/latest/source/drivers/i2c/algos/Kconfig">here</a> and the Makefile <a href="http://elixir.free-electrons.com/linux/latest/source/drivers/i2c/algos/Makefile">here</a>.  If the I2C_ALGOBIT config option isn't selected, then i2c-algo-bit.c won't be compiled.</br>
</br>
I'm not sure how the kernel handles runtime-swappable components, but I'd imagine that it's mostly orthogonal to compile-time selectability.
      
          <div class="CommentReplyButton">
            <form action="/Articles/725662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor725515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2017 18:08 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/725515/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder how MuQSS would do in a fair comparison, `size`-wise. Part of the reason it's faster than CFQ is that it does less.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor725553"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2017 9:23 UTC (Fri)
                               by <b>armin.van.catovic</b> (guest, #115505)
                              [<a href="/Articles/725553/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can see merits in both Pitre's and Molnar's arguments, though IMHO the trend and estimates concerning IoT and small devices favours Pitre, i.e. see here: <a href="https://www.forbes.com/sites/louiscolumbus/2017/01/29/internet-of-things-market-to-reach-267b-by-2020/#41978b46609b">https://www.forbes.com/sites/louiscolumbus/2017/01/29/int...</a><br>
<p>
So even though all the shrinking-down will turn Linux into something different, why not have a Linux fork that's optimised for small devices? At its heart it will still be Linux and developers who've already worked with the kernel will have an easy entry, rather than having to adapt to a brand new kernel, like Zephyr. Or worse, seeing this market slip away into proprietary domain and have a whole bunch of companies making IoT kernels and OSes with licensing fees.<br>
<p>
My comment on Pitre's scheduler shrinkage - I was under the impression (and from my own experience in the embedded world) that RT schedulers would be more suitable than the default/CFS scheduler. Is it extremely complicated (impossible???) to only leave e.g. SCHED_RR?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725553/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2017 21:54 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/725733/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  why not have a Linux fork that's optimised for small devices?</font><br>
<p>
because that fork will diverge from mainline, and will lose much of the benefit of being Linux.<br>
<p>
Linux has long had a policy for device drivers that if just one person has a device that needs a particular driver, then that driver can be included in the mainline kernel (providing it is well written and follows guidelines and is well maintained). <br>
<p>
It appears that the threshold number of schedulers is somewhat higher than "one".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor725875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2017 23:30 UTC (Mon)
                               by <b>ttelford</b> (guest, #44176)
                              [<a href="/Articles/725875/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's comically unlikely that IoT will turn to proprietary OSes. The margins are razor thin, and there's no money to spend on a proprietary OS that still doesn't have the drivers they need/want.<br>
<p>
There are many good free OSes for embedded work - just because it's not Linux doesn't mean it's not free or open source.<br>
<p>
More to the point: designers will be able to make more capable devices with even cheaper hardware if they use a tool better suited for their environment - Zephyr, FreeRTOS, and others are cruft-free and tailor made for the purpose. Many useful drivers already exist.<br>
<p>
IoT is all about volume: it's worth an extra $10-50k of developer time to make your device $2.00 cheaper per unit.<br>
<p>
Use the right tool for the job. Dumping the Linux kernel on IoT is like using a six-axis fully articulated CNC mill when you're only cutting a line. You wind up with capabilities that aren't even useful, at great cost.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 21:45 UTC (Thu)
                               by <b>armin.van.catovic</b> (guest, #115505)
                              [<a href="/Articles/726277/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's comically unlikely that IoT will turn to proprietary OSes. The margins are razor thin, and there's no money to spend on a proprietary OS that still doesn't have the drivers they need/want</font><br>
<p>
Windows 10 IoT Core is gaining momentum. Necleus RTOS is apparently used on 3 billion devices already. ARM has its own mbed IoT. Wind River has its own VXWorks. ENEA has its own RTOS. Etc.<br>
<p>
<font class="QuotedText">&gt; IoT is all about volume: it's worth an extra $10-50k of developer time to make your device $2.00 cheaper per unit.</font><br>
<p>
You just said the margins are razor thin. Your second statement is spot on - it's about volumes. Which means spending developer time on rolling your own kernel/OS could be money well spent - especially since you could then start charging licensing fees for developing or integrating in its ecosystem.<br>
<p>
<font class="QuotedText">&gt; Dumping the Linux kernel on IoT is like using a six-axis fully articulated CNC mill when you're only cutting a line. You wind up with capabilities that aren't even useful, at great cost.</font><br>
<p>
Not really true. I will contradict myself and the article a bit here - we have NB-IoT and CAT-M devices, which happily run Android (and hence Linux). IoT is predominantly about low power. And on devices the power is mostly used by radio hardware, and displays. IoT is all about using minimal amount of spectrum, and using tx/rx only when it's needed, hence drastic reduction in power consumption. However we then have even smaller devices, with limited memory and cycles per sec. For both these smaller devices, and for "larger" IoT devices, it's always beneficial to have as small footprint as possible - it means more space for features and hacking.<br>
<p>
Not directed at anyone in particular here, just a general comment - I'm mainly questioning the protectionism/conservatism here. We have people spending effort on shrinking the kernel, reducing the footprint, and the reaction is typically a populist one. If you do this and that, then it won't be Linux any more, all hell will break loose. I see parallels of such statements with today's politics. Which is a shame since this is meant to be free and open software. Hacking the kernel should be encouraged. Sure there are other kernels/OSes  out there, and sure maybe it will start to diverge, but it drives innovation, and new improvements will be uncovered which will benefit all, as Ingo pointed out. Just saying.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 22:10 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/726280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Windows 10 IoT Core is gaining momentum. Necleus RTOS is apparently used on 3 billion devices already. ARM has its own mbed IoT. Wind River has its own VXWorks. ENEA has its own RTOS. Etc.</font><br>
<p>
And those are all OSes are, if not outright proprietary to begin with, effectively so unless the vendor supplies source code.  (I'm speaking from an end-user perspective; from a purely developer/oem/manufacturer perspective, that's another matter..)<br>
<p>
<font class="QuotedText">&gt; You just said the margins are razor thin. Your second statement is spot on - it's about volumes. Which means spending developer time on rolling your own kernel/OS could be money well spent - especially since you could then start charging licensing fees for developing or integrating in its ecosystem.</font><br>
<p>
Not to mention that highly optimized software means you can reduce the hardware requirements, allowing you to knock precious pennies off of your BOM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor727226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2017 22:19 UTC (Wed)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/727226/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      So many things in such a short article:
<ul>
<li>Yeah, 256 KB is a very real thing. It will be coupled with simple processors, i.e. single issue pipelines, small caches, etc. Cost rules in much of the embedded market--pennies matter.</li>
<li>In many tiny applications, SCHED_OTHER isn't really interesting, SCHED_FIFO is what you want, or possibly SCHED_DEADLINE. SCHED_FIFO, at least, is fairly simple.</li>
</ul>
<p>Having said that, I support tinification, but I'm not sure how successful it will be. The drivers that are so desirable will generally support things like many ioctls() that are unnecessary but pulling them out one driver at a time is going to be awful. The same thing applies, but to a lesser degree, to system call options/flags.<p>
<p>There is another direction: building on a micro-kernel. Before you respond from a '90s view of micro-kernels, know that the micro-kernel community has been busy for the past two decades. Performance is not, and never will be, equivalent to a unikernel, but for markets like IoT, it is quite good. SeL4 is small enough to be provably correct (for reasonable definitions of correct), something no unikernel can claim now or in the forseeable future. Of course, micro-kernels are presently one step above toys, but that's what people said about Linux, too.</p>
<p>So, the seL4 people are putting pieces of BSD on top and getting demoware that actually runs pretty well. There are a few examples of massive micro-kernel deployment. There is nothing preventing putting pieces of Linux on a micro-kernel except figuring out how to share the pieces in a technically, organizationally, and politically efficient fashion. (Yeah, just those little things.) But, the key is that you get to sidestep as much of the Linux kernel as you want. This means writing mini-versions of drivers or system calls, if necessary.</p>
<p>Please try to limit responses to those from personal knowledge, but I've got a stick and a big ole bag of marshmallows here. Flame away!</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/727226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor728167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2017 1:41 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/728167/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
microkernels tend to need more memory for the different modules to sit in (message passing memory, inefficient packing into pages, etc), so I have serious doubts about their value in the resource constrained IoT space<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/728167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor728170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shrinking the scheduler</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2017 3:57 UTC (Tue)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/728170/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I agree. What I don't know is how the additional memory required by micro-kernels compares with that consumed by kernel features that remain in the kernel because:</p>
<ul>
<li>It is too much work to conditionalize all those features.</li>
<li>The complexity of the configuration files becomes unmanageble because each little feature to be configured requires a new configuration entry.</li>
</ul>
<p>I don't know know the answer to this one, but the pain people are encountering with tinification suggests nobody else knows the answer, either.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/728170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
