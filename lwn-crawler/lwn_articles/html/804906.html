        <!DOCTYPE html>
        <html lang="en">
        <head><title>LSM stacking and the future [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/804906/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/804785/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/804906/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>LSM stacking and the future</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>November 20, 2019</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2019-Linux_Security_Summit_Europe">LSS EU</a>
</div>
<p>
The idea of stacking (or chaining) Linux
security modules (LSMs) <a href="/Articles/114588/">goes back 
15 years</a> (at least) at this point; <a href="/Articles/635771/">progress</a>
has definitely been made along 
the way, especially in the last decade or so.  It has been possible to
stack "minor" LSMs with one major LSM (e.g. SELinux, Smack, or AppArmor) for
some time, but mixing, say, SELinux and AppArmor in the same 
system has not been possible.  Combining major security solutions may not
seem like a truly important feature, but there is a use case where it is
pretty clearly needed: containers.  Longtime LSM stacker (and Smack
maintainer) Casey Schaufler
gave a presentation at the <a
href="https://events19.linuxfoundation.org/events/linux-security-summit-europe-2019/">2019
Linux Security Summit Europe</a> to report on the status and plans for
allowing arbitrary LSM stacking.
</p>

<p>
LSMs allow adding more restrictions to Linux than those afforded by the
traditional security policies.  For the most part, those policies reflect
the existing mechanisms, such as permissions bits on files.
But there are also other security concerns, such as binding to a network
socket, that are outside of the usual permissions, so mechanisms to
restrict access to them have
been added to the LSM interface.
</p>

<a href="/Articles/805190/">
<img src="https://static.lwn.net/images/2019/lsseu-schaufler-sm.jpg" border=0 hspace=5
align="left" width=219 height=280 alt="[Casey Schaufler]"
title="Casey Schaufler">
</a>

<p>
Prior to the advent of the <a
href="https://www.kernel.org/doc/Documentation/security/Yama.txt">Yama
LSM</a>, only one security module could be active in a running kernel; Yama
was originally manually stacked, which "didn't really sit very well".  To
support adding the Yama restrictions on top of other LSMs in a dynamic
fashion, lists of modules 
were added to the kernel, which would allow multiple LSMs to be active.
But there was a problem for the "bigger" LSMs that need security
"blobs"—context data associated with various kernel objects—in which to
store their state.  There is only one pointer available to 
use, so only one blob-using LSM could be active, though multiple minor LSMs
that did not need the blobs could be stacked with it.
</p>

<p>
At this point, an LSM attribute has been added to tag LSMs;
<tt>LSM_FLAG_EXCLUSIVE</tt>.  The
"exclusive" tag is applied to the blob-using LSMs: SELinux, Smack, and
AppArmor.  
The idea is to remove that tag from those LSMs over time.
</p>

<p>
There can only be one exclusive LSM active in a running kernel.
"That's
bad", Schaufler said, but for a long
time that was not seen as a serious problem. That was
before containers became so widespread, however.  Now there are some people
who run, for 
example, Ubuntu in their data centers (with AppArmor) and who want to run
Android (SELinux) containers on top.  So the goal of the work he and others
have been doing is to get rid of the exclusive bit for "as many modules as
we possibly can".
</p>

<p>
The 5.1 kernel added "infrastructure-managed blobs" for a number of
different kernel objects: tasks, credentials, files, inodes, and the
System&nbsp;V interprocess-communication mechanisms (semaphores, shared
memory, and message queues).  An LSM will tell the kernel how much space it
needs to store its information and the kernel will take care of allocating,
managing, 
and freeing the blob.  So, any LSM that only uses blobs on those object types
can be marked as non-exclusive at this point.
</p>

<p>
That means a variety of LSMs can be used alongside SELinux, so "the IT
people are really happy" since SELinux does not have to be turned off to
get the protections afforded by some other module that only uses those
blobs.  There are also a number of smaller LSMs that are headed toward the
mainline that could benefit from this.  Those, or some custom module, can
be run with one of the 
exclusive LSMs, mostly without interference; so "everybody's happy", he said.
</p>

<h4>Next up</h4>

<p>
"But not everybody's happy", he continued, because there are still
limitations, which leads to the plans for an 
upcoming kernel, possibly&nbsp;5.5.  The <a href="/ml/netdev/20191119224714.13491-1-casey@schaufler-ca.com/">code to remove the exclusive flag
for AppArmor</a> is basically ready.  AppArmor is different than Smack and
SELinux, "in that it is path-name-based-ish", though it is less so now than it
used to be.  It has a different fundamental security model; Smack
and SELinux are both based on subjects and objects, while AppArmor mostly focuses
on path names.  The use cases for AppArmor are also different than those of
the others, so it makes sense to start with it.
</p>

<p>
In order to make non-exclusive stacking work for AppArmor, kernel
socket-object security blobs have to join the other
infrastructure-managed blobs so that 
multiple LSMs can have them.  That is fairly easily done, since it already
has been done for the other objects.  There are also more difficult pieces; when
you get to those, that's where people start to bikeshed, he said.
</p>

<p>
The first problem is sharing <tt>/proc/PID/attr/current</tt>, which is used
by AppArmor and other major LSMs to report the security context for the
process identified by PID.  So SELinux and AppArmor would both want
to put their contexts in that file, but that is impossible.  Similarly,
the <tt>SO_PEERSEC</tt> socket option to retrieve the security context of
the other endpoint of a Unix socket also cannot be shared.  The solution
for both is to introduce a new interface, so that the existing interfaces
stay backward compatible.
</p>

<p>
A number of different ideas for the format of
<tt>/proc/PID/attr/context</tt> and <tt>SO_PEERCONTEXT</tt> (the new
interfaces) were proposed along the way, but the developers "finally did
the intelligent thing" and asked the user community, the D-Bus developers
in particular.  They suggested a simple string with pairs of
null-terminated strings of the form "LSM-name\0value\0"; the full length of
the string will be known, so pulling out the individual LSM contexts will
be straightforward. There is something of a lesson there, Schaufler said:
instead of debating something like this, ask the people who will be using
the information.
</p>

<p>
But adding interfaces doesn't really solve the problem, since there are
numerous system utilities that will use the existing interfaces—and for a
long time to come.  So there is a new <tt>/proc/self/attr/display</tt>
setting that can be used to determine which LSM's context information is
reported via the existing interfaces.  An SELinux container could set its
<tt>display</tt> to ensure that the container sees the SELinux information
even if it is running on a kernel with AppArmor active as well; the rest of
the system could set the <tt>display</tt> to AppArmor so that it would look
like that was the only LSM active.
</p>

<p>
The permissions required to change the <tt>display</tt> attribute also
needed to be worked out.  He thought there should be no checks
on switching the value, but SELinux developer Stephen Smalley came up with
some problems with that approach.  So Schaufler suggested requiring the
<tt>CAP_MAC_ADMIN</tt> capability, but it turns out that SELinux developers
do not want to rely on capabilities, they want SELinux to be able to weigh
in on the choice.  So there is now a hook for <tt>display</tt> changes;
SELinux and AppArmor have added ways to set a policy for changing
<tt>display</tt>, while Smack just 
says "sure, go ahead". 
</p>

<p>
It turns out that Android's binder security mechanism also uses the
contexts, so the code needed to ensure that the processes at both ends of
the bind see the same context; it doesn't matter which it is, he said, but
it needs to be the same.  There was also a need to add new audit fields to
support subject contexts on a per-LSM basis, while still
maintaining the "<tt>subj=</tt>" entries for backward
compatibility.  The same thing can be done with object contexts
(i.e. "<tt>obj=</tt>") if that is 
needed down the road.
</p>

<h4>Before too long</h4>

<p>
The next major step is to remove the exclusive tag entirely, by getting rid
of it for Smack and SELinux, so that you can use any set of arbitrary LSMs
in the same running kernel  That is targeted for the&nbsp;5.8 kernel or
so.  It is more challenging, in part because the two LSMs do a lot of the
same things; in particular, both interact with the networking subsystem
extensively, he said. 
</p>

<p>
Two more kernel objects, for keys and superblocks, need to be added to the
infrastructure-managed list.  Part of the reason that superblocks need
blobs for Smack and SELinux is that both process mount options, which is a
bit messy to do.  Instead of simply handing the options to a single LSM, they
will need to be sent to a series of LSMs; each LSM needs to only deal with
the options it knows about, ignoring those it doesn't, but then any options
that are not handled by any LSM need special treatment.
</p>

<p>
"The networking stuff has a wonderful set of challenges", Schaufler said.
The <a
href="https://www.kernel.org/doc/html/latest/netlabel/introduction.html">NetLabel</a>
interface is useful to allow an LSM to put <a
href="https://tools.ietf.org/html/draft-ietf-cipso-ipsecurity-01">CIPSO</a>
or <a href="https://tools.ietf.org/html/rfc5570">CALIPSO</a> labels on
packets, but two LSMs cannot put different labels on the same packets.
After much "gnashing of teeth", it was decided that unless all of the
relevant LSMs could agree on the labels, packet sending would fail.  It may
be a bit harsh, but it makes sense: "If
you can't get people to agree, you probably shouldn't send it".
</p>

<p>
The label is set when the socket is created, so that is the operation that
should fail, even though it doesn't really matter until a packet is
actually sent. 
Making that work requires some changes in NetLabel and SELinux, but more in
Smack.  NetLabel is used differently by Smack, which "makes things more
complicated", he said.
</p>

<p>
The <a href="https://james-morris.livejournal.com/11010.html">secmark
facility</a> allows associating a 32-bit number with a packet; it is added
to the socket buffer (sk_buff or SKB) object
by nftables.  However, 32 bits is not enough to be able to handle two,
three, or even more LSMs that want to use secmarks.  It is not clear what
to do about that, yet.  A hash-table mapping might work or only allowing a
single LSM to use the facility is another option, though "it's kind of a
cop-out".  Another possibility is an SKB extension, but he is a bit leery
of going that route because he anticipates some opposition from the
networking developers.
</p>

<p>
<a href="https://tools.ietf.org/html/rfc7204">Labeled NFSv4</a> presents an
"interesting conundrum", he said.  It was defined with a format for
the label data that is passed back and forth, which "Linux very carefully
ignores".  The Linux implementation doesn't add the labels or read them; it
just assumes that any data that is there is reasonable for whatever is
actually going to use it.  The NFS developers are looking into that at this point.
</p>

<p>
Schaufler wrapped up by reiterating that the first set of changes for
AppArmor are targeting Linux&nbsp;5.5.  The second set needs more work and
there are some solutions to be found, but it will hopefully make its way into the
mainline in&nbsp;5.8 or thereabouts.  Interested readers can view his <a
href="https://static.sched.com/hosted_files/lsseu2019/84/201910-LSS-EU-xxx-Stacking.pdf">slides
[PDF]</a> and the <a
href="https://www.youtube.com/watch?v=XtKodXBxY6U">YouTube video</a> of the
talk.
</p>

<p>
[I would like to thank LWN's travel sponsor, the Linux Foundation, for
travel assistance to attend the Linux Security Summit Europe in Lyon,
France.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Security_modules">Security/Security modules</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_Security_Modules_LSM">Linux Security Modules (LSM)</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Security_Summit_Europe-2019">Linux Security Summit Europe/2019</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/804906/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor805242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2019 22:19 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805242/">Link</a>] (39 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LSM people need to rethink their approach to security. Right now it's simply unusable crap that fails dangerously if turned off.<br>
<p>
Instead of only limiting access it needs to be able to widen it. This way the files can just have the most files can have very restrictive permissions (600 with root owner) and LSM can be used to grant additional ones as needed. <br>
<p>
Mind you, I don't propose removing the ability to narrow permissions. It is still useful. For example, to confine a browser so it won't be able to access arbitrary files.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2019 14:38 UTC (Thu)
                               by <b>sruffell</b> (subscriber, #42212)
                              [<a href="/Articles/805260/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do not agree that the LSM framework is unusable crap.<br>
<p>
I believe your suggestion would *require* a user to understand the configured LSM / Mandatory Access Control implementation to do anything on their system, which for most users is much more difficult than understanding the classic UNIX file permission model. If you do that, the kernel might as well pick an implementation and make it mandatory.<br>
<p>
The way it is now, you can have a usable system, and an administrator is able to remove permissions from a file by adjusting the classic file permission bits.  If everything was 600 with root owner by default, the file permission bits would, in effect, be meaningless.<br>
<p>
So perhaps what you're suggesting is a kernel config option to disable discretionary access control?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2019 18:48 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805311/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I do not agree that the LSM framework is unusable crap.</font><br>
Yes, it is.<br>
<p>
SELinux works badly, it's not modular, not composable. So even in Fedora it requires serious hacks to be usable. For example, Apache's CGI scripts are controlled by a global boolean switch.<br>
<p>
The the whole "labeling" nonsense. A file already has a label - its path. Yet SELinux still barely supports it.<br>
<p>
<font class="QuotedText">&gt; I believe your suggestion would *require* a user to understand the configured LSM / Mandatory Access Control implementation to do anything on their system</font><br>
Indeed. This would make it at least effective and force LSM developers to cut the crap and actually provide a usable system.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2019 14:51 UTC (Fri)
                               by <b>sruffell</b> (subscriber, #42212)
                              [<a href="/Articles/805343/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; SELinux works badly, it's not modular, not composable. So even in Fedora it requires serious hacks to be usable. For example, Apache's CGI scripts are controlled by a global boolean switch.</font><br>
<p>
So it sounds to me like you have a problem with SELinux and not the LSM framework?<br>
<p>
<font class="QuotedText">&gt; The the whole "labeling" nonsense. A file already has a label - its path. Yet SELinux still barely supports it.</font><br>
<p>
This sounds like another complaint against SELinux specifically since labeling is an SELinux (and Smack) requirement. TOMOYO and AppArmor use paths, not file system attributes, to specify domain/type information on files.<br>
<p>
<font class="QuotedText">&gt; &gt; I believe your suggestion would *require* a user to understand the configured LSM / Mandatory Access Control implementation to do anything on their system</font><br>
&gt;<br>
<font class="QuotedText">&gt; Indeed. This would make it at least effective and force LSM developers to cut the crap and actually provide a usable system.</font><br>
<p>
I admit, thinking about what it would look like to completely disable DAC is an interesting thought exercise. My gut feeling is that this would be better than allowing LSMs to expand permissions on a case-by-case basis. I think it would be better to ensure that the user is not under any misconceptions that the classic permission bits mean anything if you went this route.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2019 20:08 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805399/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So it sounds to me like you have a problem with SELinux and not the LSM framework?</font><br>
Partially. I'm not familiar with TOMOYO - it has essentially ZERO documentation and Smack has always looked stupid to me (it's "SELinux but different").<br>
<p>
I like the _idea_ of AppArmor, but so far it's not gaining any real traction. It also was not usable by unprivileged users the last time I checked.<br>
<p>
<font class="QuotedText">&gt; I admit, thinking about what it would look like to completely disable DAC is an interesting thought exercise. My gut feeling is that this would be better than allowing LSMs to expand permissions on a case-by-case basis. </font><br>
MAC-only access control would resemble capability-based security a bit. It would also be different from the current state of the art. <br>
<p>
<font class="QuotedText">&gt; I think it would be better to ensure that the user is not under any misconceptions that the classic permission bits mean anything if you went this route.</font><br>
Indeed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 23, 2019 20:53 UTC (Sat)
                               by <b>jamielinux</b> (subscriber, #82303)
                              [<a href="/Articles/805431/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I'm not familiar with TOMOYO - it has essentially ZERO documentation</font><br>
<p>
For anybody else reading, there is quite thorough documentation on the main project website:<br>
<a href="http://tomoyo.osdn.jp/documentation.html.en">http://tomoyo.osdn.jp/documentation.html.en</a><br>
<a href="http://tomoyo.osdn.jp/2.6/index.html.en">http://tomoyo.osdn.jp/2.6/index.html.en</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805437"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2019 0:09 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805437/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, I did look at it at the time documentation looked like this: <a href="http://tomoyo.osdn.jp/2.2/index.html.en">http://tomoyo.osdn.jp/2.2/index.html.en</a><br>
<p>
The current one is a bit better, but it's still not nearly good enough. For example, there are pretty much no sample policies anywhere on the Web. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805437/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 28, 2019 8:41 UTC (Thu)
                               by <b>jamielinux</b> (subscriber, #82303)
                              [<a href="/Articles/805752/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It sounds like “zero” was a slightly unfair exaggeration ;-) But I think we’re not really in disagreement! I agree the documentation could be better, and there could be more, and there isn’t really much of a community. Which is a shame because I think it’s a neat project. (I haven’t used tomoyo in a long time in favour of SELinux.)<br>
<p>
Disclaimer: I rewrote tomoyo’s docs and redesigned the website about 8 years ago as my first contribution to free software ... it was also the first time I’d written docs or designed a website at all, so be gentle ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2019 8:23 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805793/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you!<br>
<p>
Documentation can also be really improved simply by adding a handful of sample policies.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor806609"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2019 22:25 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/806609/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, they've got me going both "those permission-validation penguin cartoons are incredibly cute" and "this whole design looks fascinating", and got me playing with it in a VM where before I'd never touched it for complete lack of understanding of how it worked and what it was for: so I'd say they're pretty good docs.<br>
<p>
They have quite a few examples, too -- enough to be getting started with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/806609/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor805370"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2019 15:33 UTC (Fri)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805370/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; SELinux works badly, it's not modular, not composable. So even in Fedora it requires serious hacks to be usable. For example, Apache's CGI scripts are controlled by a global boolean switch.</font><br>
<p>
You mean the setsebool stuff? That's quite intentional.<br>
<p>
SELinux is intended to sandbox applications. The problem is that Apache can do many things, not all of which are desirable in all situations. For instance if I don't run any CGI scripts, then making it so that Apache can't possibly run any even if it tries ensures nobody can sneak a CGI in and exploit the system that way. The booleans are quite useful for things like that.<br>
<p>
<font class="QuotedText">&gt; The the whole "labeling" nonsense. A file already has a label - its path. Yet SELinux still barely supports it.</font><br>
<p>
It's part of the design. Personally, I want to control objects, not paths. It should be impossible to work around security by accessing a file through another path. Also, applying labels means I can place appropriate labelled files anywhere, and things will work without having to adjust the SELinux configuration, just like under the old permissions system a program can read anything with read permissions, no matter where it is.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805370/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2019 20:02 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805400/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You mean the setsebool stuff? That's quite intentional.</font><br>
Yep.<br>
<p>
<font class="QuotedText">&gt; SELinux is intended to sandbox applications. The problem is that Apache can do many things, not all of which are desirable in all situations.</font><br>
Then it should be a setting within Apache. Not essentially a system-global non-namespaced variable.<br>
<p>
<font class="QuotedText">&gt; It's part of the design. Personally, I want to control objects, not paths. It should be impossible to work around security by accessing a file through another path.</font><br>
Yep. And I'm arguing that this whole design is flawed. It looks OK in academic papers but not in real life.<br>
<p>
All Fedora/RHEL users that I know of have SELinux off. I can't find any recent reliable statistics, though. It would be nice if Fedora could gather it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2019 20:49 UTC (Fri)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805402/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Then it should be a setting within Apache. Not essentially a system-global non-namespaced variable.</font><br>
<p>
That makes no sense. The point of SELinux is that it imposes my (the administrator's) policy upon the system. It can't be in Apache's config because Apache doesn't get to have an opinion. The rule is set and enforced before it even gets to parse its config file.<br>
<p>
This means that if I say Apache will not run CGIs then it won't, no matter the config, internal defaults or even if somebody finds an exploit and runs their own code.<br>
<p>
<font class="QuotedText">&gt; Yep. And I'm arguing that this whole design is flawed. It looks OK in academic papers but not in real life.</font><br>
<p>
Works for me. How is it flawed?<br>
<p>
<font class="QuotedText">&gt; All Fedora/RHEL users that I know of have SELinux off. I can't find any recent reliable statistics, though. It would be nice if Fedora could gather it.</font><br>
<p>
Hi. Been running with it on since Fedora 18. On my desktop, laptop, work laptop, server, firewall, and multiple VMs.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor805426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 23, 2019 15:18 UTC (Sat)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/805426/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I run with SELinux on always. I learned the booleans and even write my own policies when necessary. This stuff isn't that hard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2020 23:02 UTC (Mon)
                               by <b>indolering</b> (guest, #102865)
                              [<a href="/Articles/816928/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; All Fedora/RHEL users that I know of have SELinux off. I can't find any recent reliable statistics, though. It would be nice if Fedora could gather it.</font><br>
<p>
I don't really understand SELinux but I never had much of a problem with it, the SELinux troubleshooter fixed most problems with minimal fuss.  I also tend to use Flatpak and other isolation mechanisms, however, so maybe I just never ran across it very much.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor805335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2019 8:55 UTC (Fri)
                               by <b>maxfragg</b> (subscriber, #122266)
                              [<a href="/Articles/805335/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
what exactly do you hope to gain from this?<br>
LSMs are intended to be used as a layer on top of unix permissions, what besides a lot of potential information leaks would you hope to gain from your proposal?<br>
Currently, if DAC checks fail, MAC will never be invoked, thus also no audit logs, how should this work, if MAC would be able to widen access?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2019 19:56 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805398/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; LSMs are intended to be used as a layer on top of unix permissions, what besides a lot of potential information leaks would you hope to gain from your proposal?</font><br>
Force people to either make LSMs usable or abandon them altogether. Either one works.<br>
<p>
<font class="QuotedText">&gt; Currently, if DAC checks fail, MAC will never be invoked, thus also no audit logs, how should this work, if MAC would be able to widen access?</font><br>
Just like that - an optional ability to override the DAC.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805435"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 23, 2019 23:10 UTC (Sat)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805435/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Force people to either make LSMs usable or abandon them altogether. Either one works.</font><br>
<p>
What do you mean by 'make LSMs usable'? Security is inherently complicated.<br>
<p>
<font class="QuotedText">&gt; Just like that - an optional ability to override the DAC.</font><br>
<p>
You could just chmod 777 everything. I remember there used to be a demo server somewhere that demonstrated SELinux by allowing you to log in as root, but kept you confined enough that you still couldn't break anything.<br>
<p>
That said, IIRC there's a central point in the kernel for permissions check, so this is probably not hard to implement.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805435/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805438"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2019 1:00 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805438/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What do you mean by 'make LSMs usable'?</font><br>
Just that.<br>
<p>
<font class="QuotedText">&gt; Security is inherently complicated.</font><br>
It's academy-inspired uber-complicated all-powerful monsters that are inherently complicated.<br>
<p>
It's not like we haven't see alternatives. OpenBSD has very practical and extremely useful unveil()/pledge() support, for example. Which is STILL impossible to express completely in Linux even with unholy brew of eBPF and SELinux.<br>
<p>
<font class="QuotedText">&gt; You could just chmod 777 everything. I remember there used to be a demo server somewhere that demonstrated SELinux by allowing you to log in as root, but kept you confined enough that you still couldn't break anything.</font><br>
No. My point would be to set permissions to 600 (or even 000) and then use LSMs to grant additional access. If one then turns off LSM they lose access.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805438/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805565"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2019 22:14 UTC (Mon)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805565/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's academy-inspired uber-complicated all-powerful monsters that are inherently complicated.</font><br>
<p>
Because interactions are complicated. Eg, I want Apache to listen on port 80, but not on port 22 under any circumstance. I want Apache to serve files from my home directory, but not my GPG keys.<br>
<p>
Then you have messes like PAM, which are pretty tricky to secure.<br>
<p>
<font class="QuotedText">&gt; It's not like we haven't see alternatives. OpenBSD has very practical and extremely useful unveil()/pledge() support, for example. Which is STILL impossible to express completely in Linux even with unholy brew of eBPF and SELinux.</font><br>
<p>
Linux has seccomp, and while helpful it's a blunt and problematic instrument. For instance trouble comes when somebody makes a new version of open(), and now there's a new syscall that's now in the allow list, yet being used by glibc. Things like that.<br>
<p>
But more importantly, this completely misses the point. The point of something like SELinux isn't that Apache politely declares what it will do and won't, but that I, being the sysadmin, am the one authority on the system, and Apache doesn't get any say in anything. <br>
<p>
<p>
<font class="QuotedText">&gt; No. My point would be to set permissions to 600 (or even 000) and then use LSMs to grant additional access. If one then turns off LSM they lose access.</font><br>
<p>
What's the point? You can already make it impossible to turn a LSM off, since they're controlled by things like files and syscalls, which can be disabled.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805565/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2019 23:01 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805569/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Because interactions are complicated. Eg, I want Apache to listen on port 80, but not on port 22 under any circumstance. I want Apache to serve files from my home directory, but not my GPG keys.</font><br>
pledge()/unveil() do both just fine in practice.<br>
<p>
<font class="QuotedText">&gt; Linux has seccomp, and while helpful it's a blunt and problematic instrument. For instance trouble comes when somebody makes a new version of open(), and now there's a new syscall that's now in the allow list, yet being used by glibc. Things like that.</font><br>
The problem is, even with all its brokenness, seccomp still can not express full pledge()/unveil() semantics.<br>
<p>
This is an entirely self-inflicted issue. A simple targeted security subsystem that would just do what pledge() does would help immensely. It won't be uber-flexible NSA-Flask-compatible, and it would require extensions on case-by-case basis, sure. But it also would be much more usable.<br>
<p>
<font class="QuotedText">&gt; But more importantly, this completely misses the point. The point of something like SELinux isn't that Apache politely declares what it will do and won't, but that I, being the sysadmin, am the one authority on the system, and Apache doesn't get any say in anything.</font><br>
In reality this doesn't matter much, since you're likely using Apache from the distro-provided package with a distro-provided policy. So putting the permissions inside Apache "namespace" doesn't really matter.<br>
<p>
<font class="QuotedText">&gt; What's the point? You can already make it impossible to turn a LSM off, since they're controlled by things like files and syscalls, which can be disabled.</font><br>
You're missing the point. If users or application developers see SELinux interfering with their work, they simply turn SELinux off instead of fixing whatever is wrong. There's no downside to doing this as LSMs fail open.<br>
<p>
The ONLY way to fix this in the long term is to make LSMs mandatory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 0:12 UTC (Tue)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805573/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; pledge()/unveil() do both just fine in practice.</font><br>
<p>
I'm not an user of *BSD, how do you implement those policies with pledge/unveil?<br>
<p>
<font class="QuotedText">&gt; This is an entirely self-inflicted issue. A simple targeted security subsystem that would just do what pledge() does would help immensely.</font><br>
<p>
Sure, improvements can be made. <br>
<p>
<font class="QuotedText">&gt; In reality this doesn't matter much, since you're likely using Apache from the distro-provided package with a distro-provided policy. So putting the permissions inside Apache "namespace" doesn't really matter.</font><br>
<p>
It matters because:<br>
<p>
1. I can modify the policy without touching the source code.<br>
2. If something sets its own policy, the possibility exists of subverting security before the policy can be applied because there is a point before the policy is set.<br>
3. An application's own author isn't necessarily the best person to be in charge of knowing what it should or not be doing.<br>
4. Tools like 'sandbox' that sandbox arbitrary applications.<br>
<p>
<font class="QuotedText">&gt; The ONLY way to fix this in the long term is to make LSMs mandatory.</font><br>
<p>
Ohh. I finally get it.<br>
<p>
That's a pointless waste of time. You can't fix willful stupidity by technical measures, it never worked and never will. If somebody wants to disable security, they will do so. People will disable it, not compile it, patch the kernel, choose another distribution, run everything as root, whatever.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 0:26 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805574/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I'm not an user of *BSD, how do you implement those policies with pledge/unveil?</font><br>
I don't use OpenBSD but I installed it in a VM just to check this. <br>
<p>
You do:<br>
1. unveil() directories that you want to be readable, this will automatically make everything else closed off.<br>
2. Open port 80 as a superuser, pass the socket to Apache. This actually can be done by systemd without any SELinux.<br>
<p>
<font class="QuotedText">&gt; 1. I can modify the policy without touching the source code.</font><br>
How often this actually happens? Fedora should try to gather stats. I haven't seen it done once in my experience.<br>
<p>
<font class="QuotedText">&gt; 2. If something sets its own policy, the possibility exists of subverting security before the policy can be applied because there is a point before the policy is set.</font><br>
We have systemd for that. The wrapper code to set policy fits with it perfectly. Heck, it's already being used to allow rootless daemons listening on &lt;1024 ports.<br>
<p>
<font class="QuotedText">&gt; 3. An application's own author isn't necessarily the best person to be in charge of knowing what it should or not be doing.</font><br>
Realistically neither is the policy writer.<br>
<p>
<font class="QuotedText">&gt; 4. Tools like 'sandbox' that sandbox arbitrary applications.</font><br>
unveil()/pledge() them from wrapper scripts. Add more pledges as needed on case-by-case basis.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">rootless &lt;1024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 8:04 UTC (Tue)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/805584/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
By the way, is the rule of requiring root for lower ports even sensible today? Seems like cargo culting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">rootless &lt;1024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 8:08 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805585/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Correct. It makes no sense at all in the modern world. Up until recently (before the advent of systemd) it had actual _negative_ security as it forced all kinds of programs to be launched as root only to listen on a privileged port.<br>
<p>
These days it also can be worked around using ambient caps acquired in a helper wrapper (regular caps are lost on exec).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805611"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">rootless &lt;1024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 14:27 UTC (Tue)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/805611/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Isn't the point of requiring root for ports less than 1024 that they can be trusted to some degree? So you can say <tt>ssh some-well-known-host</tt>, and rely on that some random joker with an ordinary account on the host hasn't discovered that port 22 is free and started his or her own password stealer.
      
          <div class="CommentReplyButton">
            <form action="/Articles/805611/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">rootless &lt;1024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 14:53 UTC (Tue)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805616/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's not very much security, since most any random joker can run a VM with a sshd on port 22, and then get people to connect there by say, messing with DNS, registering domain names that are off by one character, and such things.<br>
<p>
Also due to said VMs the scenario of people being given shell accounts is becoming rarer by the day, anyway.<br>
<p>
Also there's plenty important stuff on ports &gt; 1024, such as administrative consoles like Cockpit on port 9090. So if you've got user access, there's nothing much preventing you for putting up a fake Cockpit page of your own.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor805666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">rootless &lt;1024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 19:57 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805666/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That was the idea way back then, but in practice it's not really relevant anymore. Moreover, it resulted in daemons like MySQL or Postgres actually standardizing on ports &gt;1024 to avoid doing the open-the-socket-then-drop-privs dance.<br>
<p>
Had there been something like systemd from the start (heck, even a better designed inetd) then this might have turned out differently.<br>
<p>
Even for ports &lt;1024 you shouldn't really trust them implicitly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor805675"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">rootless &lt;1024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 21:24 UTC (Tue)
                               by <b>rodgerd</b> (guest, #58896)
                              [<a href="/Articles/805675/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe in 1982, when you could still count the number of Unix machines in the world, and have a reasonable chance of knowing who was configuring them.<br>
<p>
Since Unix became popular in, oh, the mid-nineties, it's been a toxic heritage that causes more harm than good, leading programs to run as root simply because they wanted a well-known port, while providing absolutely no security benefit whatsoever.<br>
<p>
This is a classic example where mindless adherence to "Unix tradition" has cause more harm than good, all for a lack of critical thinking.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805675/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor805738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">rootless &lt;1024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 28, 2019 2:49 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/805738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Its security value over the internet is nil, especially in the face of things like win32, but in a closed system (loopback or authenticated VPN) it still provides some assurance that the other end is what you think it is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor805583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 8:24 UTC (Tue)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805583/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 1. unveil() directories that you want to be readable, this will automatically make everything else closed off.</font><br>
<p>
I see. Well, that's far worse than SELinux.<br>
<p>
One big problem I see is that you can only sandbox once. Unveil requires blocking off further changes at the end. So you both can't confine further something in an already confined environment, and can't expand the confinement either.<br>
<p>
The first is problematic because now your rule set encompasses anything that could possibly be called by the main process. Eg, you can confine Apache to /home/user/public_html, but what if you call a CGI that reads something in /home/user/.cgi? Now you need to allow that, and you can't give the permission to that particular CGI because once Apache or its wrapper finished with the pledge stuff, it's set in stone. So you give that permission to Apache, adding it to a heap of stuff that Apache can do, because something that it calls needs that. Hardly pretty, very manageable, or very secure.<br>
<p>
The second is problematic because you make things that operate with above normal permissions impossible. Eg, think about tools like ping that execute with more privileges than their caller, but that are coded in a way that their usage is safe. Think for instance of a CGI calling scp. You must now allow Apache access to your ssh keys, which makes it able it to serve them to anyone who succeeds in tricking Apache into doing it.<br>
<p>
Also this would seem not to allow for new users to be created, unless one can pledge("/home/*/foo")<br>
<p>
<font class="QuotedText">&gt; 2. Open port 80 as a superuser, pass the socket to Apache. This actually can be done by systemd without any SELinux.</font><br>
<p>
Sure, if you have cooperation from the program, in that it allows to work on a socket passed on stdin at all. And if you need more than one of those now you need systemd support in that program. And what about port 8080?<br>
<p>
Let's see what we're up to by now:<br>
<p>
1. Write a wrapper that will forbid Apache from making listen() calls, and unveil() anything needed.<br>
2. Write a systemd service that will listen on 80 and 8080, and pass those sockets to Apache<br>
3. Ensure Apache is happy with not being able to listen to anything but what is passed to it from systemd<br>
4. Ensure Apache can get multiple sockets from systemd<br>
5. Ensure that neither Apache nor anything it calls will ever try to unveil anything, because that won't work.<br>
6. Ensure that either anything Apache calls is fine with the pledge() being made, or that it's okay for the pledge() being rescinded on exec (there goes our listen() security!)<br>
7. Accept that adding new users will require completely shutting down and restarting Apache<br>
<p>
I don't know, this doesn't look particularly elegant to me. Lots of potential trouble already, and we've not even done much yet!<br>
<p>
<font class="QuotedText">&gt; How often this actually happens? Fedora should try to gather stats. I haven't seen it done once in my experience.</font><br>
<p>
Anybody using setroubleshoot is effectively doing it<br>
<p>
<font class="QuotedText">&gt; We have systemd for that. The wrapper code to set policy fits with it perfectly. Heck, it's already being used to allow rootless daemons listening on &lt;1024 ports.</font><br>
<p>
Again, the point is confinement, not allowing formerly root-only things safely. I don't see why a thing should be able to open ports &gt;= 1024 without my permission<br>
<p>
<font class="QuotedText">&gt; Realistically neither is the policy writer.</font><br>
<p>
There's no perfection for sure, but at least the policy's writer is ideally an uninvolved third party who will ask useful questions like "Why does it want to do that?". Because if the developer of a thing is up to no good, or just not concerned about security, then clearly we benefit from an outside opinion.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 20:53 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805668/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The first is problematic because now your rule set encompasses anything that could possibly be called by the main process.</font><br>
Nope. You can have multiple wrappers that run multiple Apache copies. As I said, I'm interested in reliable _practical_ solutions that just work.<br>
<p>
Now let's see what you need to do in SELinux to do the same: Apache listening on port 80 and serving the ~/public directory while denying access to everything else. It's a simple task, right?<br>
<p>
First, you need to create a label. Let's call it apache_file_t. And add it to ~/public. This will have an unfortunate side-effect of disabling user_home_t label on it, so if you have policies targeted for user_home_t then they might need an adjustment. For example, your backup utility might _lose_ access to ~/public if its policy just says "allow user_home_t read".<br>
<p>
OK. From here on, files created in ~/public will have the apache_file_t label. However, since "file is an object blah-blah" if you move a file into ~/public it will NOT be automatically accessible. You need to remember to relabel it. The reverse is also true, if you move a file from ~/public it will still retain its labels and remain accessible.<br>
<p>
But wait, there's more! SELinux can only take away rights. Typically home directories are set to 770 mode, so that they are accessible only for their users and user groups. So you need to make sure Apache is in the same group as yourself. <br>
<p>
But OK, let's move on to listening on port 80. SELinux can... do nothing! It's only used to restrict access, not to grant it. So you have to start Apache as root and then let it drop privs. SELinux does allow taking away most of root's capabilities, so that's fine.<br>
<p>
Now suppose that SELinux is turned off. Suddenly your home directory becomes accessible for Apache, which is in the same user group as your home directory. Whoops. And Apache is also started as root.<br>
<p>
Let's compare with unveil(). You need to add access for ~/public, so you write a helper wrapper that does unveil() for that directory. Nothing else is affected, you don't need to modify your backup utility's policy. And unveil() can't be turned off, it's a core kernel feature.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805676"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 22:03 UTC (Tue)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805676/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <q> Nope. You can have multiple wrappers that run multiple Apache copies.</q>

<p>
No, I'm not talking about multiple Apache copies. I'm talking about Apache calling other binaries. That is, a situation where you have:
</p>

<pre>
Wrapper -&gt; Apache -&gt; CGI_1
                  -&gt; CGI_2
                  -&gt; CGI_3
</pre>

<p>What I'm saying is that you have several problems there:</p>

<ol>
<li>The Wrapper makes it impossible for any of its children (Apache, or Apache's children) to pledge/unveil anything, because pledge/unveil work by listing what you will do, and closing off the rest, after which the functionality is closed off to any children. This means that if anything wants to drop privileges further, now it can't. If it thinks that's an error, it won't run. Otherwise it'll run with more privileges than it needs, and the Wrapper is actually compromising the security of it.</li>
<li>This system means that you need to pledge/unveil everything Apache or any of its children might ever want, and grant that access to that Apache instance and every child.  Which means Wrapper must pledge/unveil  everything Apache, CGI_1, CGI_2, and CGI_3 at once. You can't allow things for Apache and deny them to the CGIs, or lockdown each CGI in its own particular way... unless you skip on locking down Apache of course.</li>
<li>For pledge() specifically you can drop the lockdown on exec, but of course that now means the CGIs are free to do whatever they want.</li>
<li>It's also an inflexible system in that it requires a full restart to change what you unveil. You must either unveil a subdirectory under which anything will be accessible regardless of what it is, or if you are selective, you only get to do it once in Wrapper, after which it's set in stone and requires a full restart of the Apache instance.</li>
</ol>

<q>As I said, I'm interested in reliable _practical_ solutions that just work.</q>
<p>And I'm explaining why it's not very practical in practice</p>


<q>
OK. From here on, files created in ~/public will have the apache_file_t label. However, since "file is an object blah-blah" if you move a file into ~/public it will NOT be automatically accessible. You need to remember to relabel it. The reverse is also true, if you move a file from ~/public it will still retain its labels and remain accessible.
</q>
<p>That's not a bug, that's a feature. I mean that 100% seriously. SELinux doesn't work on paths, and isn't supposed to. This is exactly the behavior I want my system to have.</p>

<q>
Let's compare with unveil(). You need to add access for ~/public, so you write a helper wrapper that does unveil() for that directory. Nothing else is affected, you don't need to modify your backup utility's policy. And unveil() can't be turned off, it's a core kernel feature.
</q>

<p>
Of course it can be turned off, what nonsense is that? "Core" nothing. It didn't exist once upon a time, so just install an older kernel. Or just hack it up. <a href="https://github.com/openbsd/src/blob/a239dbafd306dd2599142bc9edb07d072cf12fee/sys/kern/kern_unveil.c#L826">This looks like a promising place</a> for a "return 0". Or perhaps <a href="https://github.com/openbsd/src/blob/a317344c2d4a053d3b336d76d4b6068c861dcd47/sys/kern/vfs_syscalls.c#L964">here</a>. Took me about 10 minutes and I never even touched BSD.
</p>

<p>Besides which, look at that lovely BYPASSUNVEIL constant. And oh dear, there's a hardcoded list of bypassed rules right in the kernel source.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/805676/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805677"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2019 22:47 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805677/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 1. This means that if anything wants to drop privileges further, now it can't. If it thinks that's an error, it won't run. Otherwise it'll run with more privileges than it needs, and the Wrapper is actually compromising the security of it.</font><br>
Nothing stops you from making unveil() nestable. Each successful invocation can further reduce the access. I think that's how pledge() works as well.<br>
<p>
<font class="QuotedText">&gt; 2. This system means that you need to pledge/unveil everything Apache or any of its children might ever want, and grant that access to that Apache instance and every child.</font><br>
Sure. So does SELinux. Just at the labeling phase and the policy creation phase. I'm assuming that Apache simply runs the CGI scripts.<br>
<p>
<font class="QuotedText">&gt; 3. For pledge() specifically you can drop the lockdown on exec, but of course that now means the CGIs are free to do whatever they want.</font><br>
Uh? Nope. pledge() is inherited across exec() calls.<br>
<p>
<font class="QuotedText">&gt; 4. It's also an inflexible system in that it requires a full restart to change what you unveil.</font><br>
So does SELinux. You can't change labels of a running process.<br>
<p>
<font class="QuotedText">&gt; And I'm explaining why it's not very practical in practice</font><br>
Well, no you have not.<br>
<p>
<font class="QuotedText">&gt; That's not a bug, that's a feature. I mean that 100% seriously. SELinux doesn't work on paths, and isn't supposed to.</font><br>
And that's why it's dumb and is turned off in most cases.<br>
<p>
<font class="QuotedText">&gt; Of course it can be turned off, what nonsense is that? "Core" nothing. It didn't exist once upon a time, so just install an older kernel.</font><br>
Nope. unveil() can't be turned off. You need to replace the kernel and reboot the system. Running unveil() on an older kernel also results in -ENOSYS.<br>
<p>
Meanwhile, SELinux can be turned off with one command.<br>
<p>
Want to convince me? Show me a simple script that does what you're proposing: creates a public directory and runs Apache with access to it. No need for CGIs. I'll show the corresponding unveil/pledge based wrapper.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805677/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2019 1:19 UTC (Wed)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805679/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Nothing stops you from making unveil() nestable. Each successful invocation can further reduce the access. </font><br>
<p>
Sure does: the interface. What unveil() does is first to forbid everything, then allow whatever you pass to unveil. <br>
<p>
This means that if you don't block off unveil after making your list of exceptions, a child process or an exploit could just unveil("/") and unblock everything.<br>
<p>
<font class="QuotedText">&gt; I think that's how pledge() works as well.</font><br>
<p>
pledge() has two modes:<br>
<p>
1. Pass on the restrictions to the child. Great, unless your child can't work with those. So if you block something major, you're going to have a hard time exec()ing much after that.<br>
2. Remove all restrictions from the child. Which means you restricted yourself, but your child can do whatever it wants.<br>
<p>
<font class="QuotedText">&gt; Sure. So does SELinux. Just at the labeling phase and the policy creation phase. I'm assuming that Apache simply runs the CGI scripts.</font><br>
<p>
Nope! See, SELinux has the concept of transition rules: <a href="https://danwalsh.livejournal.com/23944.html">https://danwalsh.livejournal.com/23944.html</a><br>
<p>
Which means, I can do this:<br>
<p>
1. Confine apache, so that it can only do apache things.<br>
2. Confine CGI, so that it can only do CGI things.<br>
3. Write an apache -&gt; CGI transition rule. Which means CGI rules don't pollute my Apache rules, and the CGI doesn't get to listen on ports.<br>
<p>
This means I can have a setup where every piece is locked down to be able to do no more than it's supposed to. <br>
<p>
<font class="QuotedText">&gt; So does SELinux. You can't change labels of a running process.</font><br>
<p>
But you can change the labels of files on disk, which means for instance I can take a running libvirt, and give it a disk image on a removable drive. All I need to do is to label it, and it works. I don't need to bring libvirt down and all my VMs with it, so that it can have /mnt/external added to its allowed paths list.<br>
<p>
<p>
<font class="QuotedText">&gt; Meanwhile, SELinux can be turned off with one command.</font><br>
<p>
Which can be disabled with SELinux itself, if you want to. After that, reboot time.<br>
<p>
<font class="QuotedText">&gt; Want to convince me? Show me a simple script that does what you're proposing: creates a public directory and runs Apache with access to it. No need for CGIs. I'll show the corresponding unveil/pledge based wrapper.</font><br>
<p>
<p>
setsebool -P httpd_enable_homedirs 1<br>
chcon -R -t httpd_sys_content_t ~user/public_html<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2019 1:23 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/805680/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  This means that if you don't block off unveil after making your list of exceptions, a child process or an exploit could just unveil("/") and unblock everything.</font><br>
Uhh, no? unveil("/") will simply return -EPERM. So for example, you can only call unveil("~/public/www") if the parent unveiled("~/public"). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2019 10:49 UTC (Wed)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805688/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, interesting. Are you saying unveil works differently after a fork()? Eg, as I understand it:<br>
<p>
    // the whole filesystem is available at the start<br>
<p>
    unveil("/tmp", "r"); // now only /tmp is visible<br>
    unveil("/var", "r"); // now I can see both /tmp and /var<br>
<p>
Are you saying the second statement will fail if I insert a fork() (perhaps with an exec) in the middle?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805689"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2019 11:48 UTC (Wed)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/805689/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you have to call unveil(NULL, NULL) to "stop" the ability to unveil more, but typically you would of course do that since it's otherwise useless?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805689/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2019 12:11 UTC (Wed)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/805690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And that's exactly the point I'm making:<br>
<p>
unveil is a nice, handy mechanism. But it doesn't nest well. Since unveil builds a list of what you want to allow, you need to lock it up with unveil(NULL, NULL). Once you do so, any further unveil(), whether under a currently locked directory or not fails.<br>
<p>
This means it's not a good thing for things that could nest. Sample scenario:<br>
<p>
We have a "convert_image" program that does some conversion. We secure it with unveil to ensure it doesn't touch anything it's supposed to, if say, libjpeg happens to have an exploit. Great. It works the way it should from the commandline.<br>
<p>
Now that we have a well protected tool, we can call it from Apache and not worry much. Wonderful!<br>
<p>
But, let's suppose that since it's so awesome, we've now applied unveil to apache too, which calls convert_image through a CGI. apache calls unveil(NULL, NULL) as it should, and eventually runs convert_image. At that point, one of two things happens: <br>
<p>
A. convert_image notices it can't secure itself and refuses to work<br>
B. convert_image ignores the failure and plows ahead, allowing an exploit to work within what Apache is allowed to do.<br>
<p>
So, while an interesting tool, it's a limited one, with gotchas like the above.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor816930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LSM stacking and the future</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 0:00 UTC (Tue)
                               by <b>indolering</b> (guest, #102865)
                              [<a href="/Articles/816930/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree with you that LSMs are not composable and would love to discuss cool alternatives ... but your comment comes across as trollish and it's hijacked the discussion : (<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
