        <!DOCTYPE html>
        <html lang="en">
        <head><title>XDC2012: Graphics stack security [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/517375/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/517088/">Return to the Development page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/517375/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>XDC2012: Graphics stack security</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Michael Kerrisk</b><br>September 25, 2012</br>
           <hr>
<a href="/Articles/XDC2012/">2012 X.Org Developers' Conference</a>
</div>
<p> Martin Peres and Timothée Ravier's session on day one of XDC2012 looked
at security in the graphics stack. They considered user expectations around
security in the graphical user interface (GUI), reviewed these expectations
against the implementations in X11 and Weston (the reference compositing
window manager for Wayland), and covered some other ground as well.  Martin
began their presentation by noting that they had done quite a bit of
research on the topic, and although they are Linux security engineers
rather than X developers, he expected that they would nevertheless have
useful things to tell the audience.


<h4>User security expectations and the X server</h4>

<a href="/Articles/517523/"><img
src="https://static.lwn.net/images/conf/2012/xdc/Martin_Peres_at_XDC2012-thumb.jpg" alt="[Martin Peres]"
width=150 height=193 border=0 align="left" hspace=2 vspace=2></a>

<p> Martin began with a review of security on the X server that focused on
the three classical areas: confidentiality, integrity, and availability.
In each case, he described security weaknesses in the X server.

<p> Starting with confidentiality issues, Martin used the example of a user
entering a credit card number while shopping online.  In this case, the
credit card number could be stolen if a key logger was running on the
machine, or another program was taking screen shots periodically.  This
violates the user's expectations of the GUI: applications should not be
able to spy on each other's input events or output buffers.  From the
user's point of view, the only time that arbitrary applications should
obtain information from one another is under explicit user control (for
example, cut-and-paste).  However, under X11, any application that can
provide the <a
href="http://en.wikipedia.org/wiki/X_Window_authorization#Cookie-based_access">magic
cookie</a> generated by the X server has full access to other applications'
input and output.  In other words, X11 provides isolation only between
users, not between applications run by the same user.  Thus, any
application that is launched by the user has the potential to break
confidentiality in the manner of the credit card example.

<p> Martin's second example concerned application integrity.  A user
visits a bank web site, and, being a sophisticated user, carefully checks
that the URL shown in the browser's address bar shows "https" plus the
correct domain.  However, the user is unaware that they are visiting a fake
domain, and that the browser's address bar has been redrawn by a malicious
application.  Consequently, the user's bank information is passed to a
third party.  This can happen under X11's Digital Rendering Infrastructure
(DRI) version 1.  (This problem is addressed in DRI2, which has been the
default for a few years now.)  In addition, virtual keyboards can inject
input to the X server; since the X server broadcasts input events, the
virtual-keyboard input can reach any application (just like a real
keyboard).

<p> Martin's third point was that applications should not be able to make
other applications or the entire system unavailable.  Under X11,
applications can, however, act as screen lockers, denying access to the
system.  In addition, in the past, a virtual keyboard was able to kill
other applications using the <tt>XF86ClearGrab</tt> feature that was
introduced in X server 1.11 (a feature that led to <a
href="/Articles/477062/">a high-profile security flaw</a> that made it
possible to break into a screen-locked system by typing a particular key
combination).


<h4>Mitigating X server security issues</h4>

<a href="/Articles/517526/"><img
src="https://static.lwn.net/images/conf/2012/xdc/Timothee_Ravier_at_XDC2012-thumb.jpg"
alt="[Timothée Ravier]"
width=150 height=170 border=0 align="left" hspace=2 vspace=2></a>

<p> At this point, Timothée took the lead to discuss techniques that have
been developed to mitigate these security problems.  The first of the
approaches that he described was <a
href="http://selinuxproject.org/page/NB_XWIN">XSELinux</a>.  XSELinux
provides finer-grained control within the X server, allowing control over
features such as drag-and-drop or access to the mouse.  However, the level
of control provided by XSELinux is still too coarse-grained to be useful:
it allows per-application control of access to X features, but cannot (for
example) restrict input to the currently selected application.
Consequently, it is either not provided, or disabled, in most
distributions.  A sometimes recommended alternative for confining
applications that use the X server is <a
href="http://www.freedesktop.org/wiki/Software/Xephyr">Xephyr</a>, which
implements sandboxing by launching an X server inside another X
server.  Although this provides a good degree of isolation between
applications in different sandboxes, a sandboxing solution has problems of
its own: it becomes complicated to share information between applications
in different sandboxes.

<p> Timothée went on to describe two projects that have tried, in different
ways, to bring greater security to the X server: QubesOS and PIGA-OS.
Both of these projects aim to confine applications, control which
applications can access input buffers of other applications, and so on.

<p> <a href="http://qubes-os.org/">QubesOS</a> groups applications into
"domains" that have similar levels of security.  Each domain runs its X
server in a separate Xen virtual machine.  For example, surfing the web in
a browser would be conducted in a low-security domain, while reading
corporate email is done in a separate, higher-security
domain. Functionality such as cut-and-paste and drag-and-drop between
domains is provided by means of a daemon that runs in the privileged dom0
virtual machine that implements mandatory access control.  QubesOS provides
a high degree of isolation between applications.

<p> However, Timothée described a number of drawbacks to QubesOS. It requires
many virtual machines, which results in slow performance on desktop and
laptop systems.  It is not feasible on mobile systems, because of heavy
resource-usage requirements and the almost-mandatory requirement for
hardware-assisted virtualization in order to achieve satisfactory
performance.  Furthermore, one can't be sure that Xen can isolate virtual
machines, so there might be ways to access buffers in other virtual
machines.

<p> PIGA-OS [<a
href="http://graal.ens-lyon.fr/~jrouzaud/files/shpcs_2009.pdf">PDF</a>], a
system that Martin and Timothée have worked on, takes a different approach
from QuebesOS. Each application is placed in a separate SELinux domain and
XSELinux is used to provide confinement in the X server.  SELinux plus
XSELinux provide many of the pieces needed for a secure X server, but some
pieces are still missing. Therefore, PIGA-OS adds a daemon, PIGA-SYSTRANS,
that grants rights to applications and prompts users when they switch
between different domains as a consequence of their activities.

<p> PIGA-OS has some notable advantages. It does not require virtual
machines. It dynamically adjusts (under user control) the permissions of
applications according to the user's activity.  However, a significant
downside of the PIGA-OS approach is that it requires quite some effort to
set up the global SELinux policy that governs applications and
activities. (This is a one-time effort, but the policy must be updated if
an application acquires new features that require new types of privileged
access.)


<h4>Wayland and Weston</h4>

<p> Timothée then turned to the subject of the <a
href="/Articles/481490/">Wayland</a>, the display server protocol posited
as a replacement for X11, and Weston, the reference implementation of the
compositing window manager for Wayland. His goal was to look at how Wayland
and Weston have fixed some of the problems of the X server described above
and outline the problems that remain.

<p> Timothée divided up the discussion of security somewhat differently in
this part of the presentation, beginning by talking about the security of
input in Wayland/Weston. On this front, the new system is in good
shape. Because Weston knows where applications are on the screen, it is
able to decide which application should receive input events (this differs
from the X server). This defeats key logging applications.  Regarding
integrity of input, the kernel limits access to the two main sources
(<tt>/dev/input</tt> and <tt>/dev/uinput</tt>) to the root user
only. Because Wayland/Weston does not (yet) support virtual keyboards it is
not (yet) possible to forge input. (The topic of virtual keyboards was
revisited later in the talk.)

<!-- (Keith Packard noted that
Weston currently avoids some security problems because it does not support
certain features that are supported on X11, such as virtual keyboards, and
that when these features are added to Weston, we need to make sure that
they are added in a secure way. Timothée agreed, noting that he would cover
the topic of virtual keyboards later.) -->

<p> On the output side, Timothée observed that Weston does have some
problems with confidentiality and integrity.  Weston uses the <a
href="/Articles/283798/">Graphics Execution Manager (GEM)</a> to share
application buffers between the compositor and applications.  The problem
is that GEM buffers are referenced using handles that are 32-bit
integers. These handles can be guessed (or brute-forced), which means that
one application can easily access GEM buffers belonging to other
applications. Martin noted that this problem would be resolved if and when
Weston moved to the use of <a href="/Articles/474819/">DMABUF (DMA buffer
sharing)</a>.

<!--
<p> Regarding availability, Weston currently denies one vector of attack,
by simply not supporting screen lockers, yet.  Timothée emphasized that
now is the right time to think about how to add support for this feature to
Weston in a secure way.
-->

<p> Timothée then considered how Weston should deal with applications that
need exceptional handling with respect to security. The first of these that
he covered was virtual keyboards, which are pseudo-devices that are
permitted to send input events to the compositor. He made the general point
that virtual keyboards should be "included" in the compositor, so that the
compositor knows that it can trust the input they provide. Peter Hutterer
raised a potential problem: each natural language (with a unique character
set) requires its own virtual keyboard, and it seems that every few months
someone starts a new virtual keyboard project for another language, with
the result that adding keyboards to the compositor would be a never-ending
task. In response, Timothée and Martin refined what they meant by
"include". The compositor must not trust just any application to be a
virtual keyboard. Rather, since the compositor knows which applications it
is launching, it can choose which applications it will trust as virtual
keyboards. Peter agreed with this approach but noted that there may be some
(solvable) complexities, since, when dealing with a multilingual user, a
switch from one language to another may involve not only a switch of
virtual keyboards, but also a switch of the background framework that
generates input events.

<p> Weston does not yet support screen-shot applications, but when that
support is added, some care will be needed to avoid confidentiality issues.
Timothée's proposal was similar to that for virtual keyboards: the
compositor would allow only trusted applications that it has launched to
make screen shots.  Again, there must be a method for specifying which
applications the compositor should trust for this task.

<p> Global keyboard shortcuts present a further problem.  For example,
media players commonly use keyboard shortcuts to provide functionality
such as pausing or skipping to the next track. Typically, media players are not
visible on the screen, and so do not receive input events
directly. Therefore the compositor needs a way of registering special
keystroke combinations and passing these to applications that have
registered them.  The problem is that this sort of functionality can allow
the implementation of a different kind of key logger: a malicious
application could register itself for many or all keystroke
combinations. Again, there needs to be a way of specify which applications
are allowed to register global keyboard shortcuts, and perhaps which
keystroke combinations they may register. Further complicating the problem
is the fact that the user may change the global keyboard shortcuts that an
application uses. Timothée said they had no solution to offer for this
problem.

<p> Peter Hutterer suggested what he called a "semantic approach" to the
problem, but noted that it would require a lot more code. Instead of
allowing applications to register keystroke combinations, the compositor
would maintain a global registry where applications would register to say
that they want to be notified for events such as "undo" or "cancel", and
the compositor would control the key that is assigned to the event. This
has the potential advantage that shortcuts could be consistent across
applications. On the other hand, there will likely be conflicts between
applications over deciding which events are which. Peter noted that the GTK
project is currently doing some work in this area, and it may be worth
contacting people working on that project.

<p> The situation with screen-locking applications is similar to
screen-shot applications. Currently, Weston does not support screen
locking, but when that support is added, there should be the notion of
having a restricted set of applications that the compositor permits to lock
the screen. Indeed, since the screen-locking code is typically small, and
the requirements are fairly narrow (so that there is no need for multiple
different implementations), it may be sensible to implement that
functionality directly inside the compositor.

<p> Timothée summarized the proposals for controlling application security
in Wayland and Weston. There should be a mandatory access control (MAC)
framework as in the <a
href="http://www.x.org/releases/X11R7.5/doc/security/XACE-Spec.html">X
Access Control Extension (XACE)</a>. Suitable hooks should be placed in the
code to allow control of which applications can interact with one another
and interact with Wayland to perform operations such as receiving
input. The MAC framework should be implemented as a library, so that access
control is unified across all Wayland compositors.


<h4>Rootless Weston</h4>

Traditionally, the X server has had to run with root privileges.  Because
the X window system is a large body of complex&mdash;and, in many cases,
ancient&mdash;code, the fact that that code must run as root creates a
window for attacks on a system. For this reason, it has long been a goal to
rework the system to the point where root privilege is no longer need to
run the X server. Although <a href="/Articles/341033/">some progress has
been made toward that goal</a>, there is as yet no general solution the
problem, and the X server still normally requires root privileges to run.
The question then is how to avoid repeating this situation going forward,
so that Weston does not require root privileges.

<p> Timothée ran through some of the factors blocking rootless Weston.  One
problem is that Weston needs access to <tt>/dev/input</tt>, which is
accessible only to root. Root privilege is also required to send output to
the screen and to support hot plugging of keyboards and screens. The
solution he proposed was to isolate the code that requires root privileges
into a separate small executable that is run with root privileges. In the
case where Weston needed access to a privileged file, the small executable
would then open the required file and pass a file descriptor via
a UNIX domain socket to Weston.  There was little comment on this proposal,
which may signify that it seemed reasonable to everyone present.


<h4>Hardware and driver security</h4>

<p> Martin returned to the microphone to talk about hardware and driver
security. He began with the simple observation that graphics drivers and
hardware should not allow privilege escalation (allowing a user to gain
root access) and should not allow one user to read or write graphics
buffers belonging to another user.  Various platforms and drivers don't
live up to these requirements. For example, on the Tegra 2 platform, the
GPU permits shader routines to have full read and write access to all of
the video RAM or all of the graphics-hosting RAM. Another example is the
NVIDIA driver, which provides unprivileged users with access to nearly all
of the GPU registers.

<p> Martin emphasized the need for a sane kernel API that isolates GPU users and
doesn't expose GPU registers to unprivileged users. GPU access to RAM also
needs to be restricted, in order to prevent the GPU from accessing kernel
data structures. (The lack of such a restriction was the source of <a
href="/Articles/509131/">the recent vulnerability in the NVIDIA driver that
allowed root privilege escalation</a>.)

<p> One approach to isolating GPU users would be to apply a virtual-memory
model to video memory, so that applications cannot touch each other's
memory. This approach provides the best security, but the problem is that
it is not supported by all graphics hardware. In addition, implementing
this approach increases context-switching times; this is a problem for
DRI2, which does a lot of context switching, and for Qt5, where all
applications that use QML (which is the recommended approach) have an
OpenGL context. The <a href="http://nouveau.freedesktop.org/">Nouveau</a>
driver currently takes this approach, and some other modern GPUs are also
capable of doing so.

<p> An alternative approach for isolating GPU users is for the kernel to
validate the user commands submitted to the GPU, in order to ensure that
they touch only memory that belongs to the user. This approach has the
advantage that it can be implemented for any graphics hardware and
context-switching costs are lower. However, it imposes a higher CPU
overhead. Currently the Radeon and Intel drivers take this approach.

<p>Moving to another topic, Martin observed that a GPU buffer is not zeroed
when it is allocated, meaning that the previous user's data is visible to
the new user. This could create a confidentiality issue. The problem is
that zeroing buffers has a heavy performance impact. He suggested two
strategies for dealing with this: zeroing deallocated buffers when the CPU
is idle and using the GPU to perform zeroing of buffers. Lucas Stach
pointed out that even if one of these strategies was employed, on embedded
devices the memory bandwidth required for zeroing buffers was simply too
great. Martin accepted the point, and noted that the goal was to allow the
user to choose the trade-off between security and performance.

<p> The final topic of the presentation concerned plug-ins. Since the
compositor has full access to input events and application output buffers,
this means that compositor plug-ins potentially have the same access, so
that a (possibly malicious) plug-in could cause a security
vulnerability. Martin said that they didn't have too many concrete
proposals on how to deal with this, beyond noting that, whenever possible,
plug-ins should not have access to user inputs and output buffers. He
suggested that <a
href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">address-space
layout randomization</a> inside the GPU virtual memory may help, along with
killing applications that access invalid virtual addresses.

<p> In some concluding discussion at the end of the session, Matthieu Herrb
remarked that most X11 applications are not ready to handle errors from
failed requests to the X server, and that if the graphics server is going to
implement finer-grained access control, then it's important that
applications have a good strategy for handling the various errors that may
occur. Martin agreed, adding "<q>We don't want to fix X; it's not
possible. We can't ask people to rewrite [applications]. But with Wayland
being new, we can do things better from day one.</q>"


<h4>Summary</h4>

<p> From the various comments made during the presentation, it's clear that
the X developers are well aware of the security problems in X11. It's equally
clear that they are keen to avoid making the same mistakes in Wayland and Weston.

<p> The X.Org wiki has <a
href="http://www.x.org/wiki/Events/XDC2012/XDC2012AbstractMartinPeres-Timoth%C3%A9eRavier">pointers
to the slides and video</a> for this presentation, as well as <a
href="http://www.x.org/wiki/Events/XDC2012/XDC2012AbstractHoegsberg%2BPeres%2BRavier%2BVetter">pointers
to the slides and video</a> for a follow-on security-related presentation
(entitled "DRM2").<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Wayland_and_Weston">Wayland and Weston</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Graphics">Graphics</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#X_server">X server</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#X.Org_Developers_Conference-2012">X.Org Developers Conference/2012</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/517375/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor517579"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2012 22:25 UTC (Tue)
                               by <b>JohnLenz</b> (guest, #42089)
                              [<a href="/Articles/517579/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the global keyboard shortcut problem, what about making it similar to the others like virtual keyboards and have weston only trust an application that it launches?  Then there could be several possible applications: one which has no security and lets any program access the keyboard similar to how X works.  As an alternative, desktop environments could provide a different program which listens for global keypresses but instead of handing out the raw keypresses, use dbus + policykit to pass events like volume up, volume down, etc to any application that policykit authorizes.<br>
<p>
This has the advantage of using already existing authentication infrastructure (policykit) and not force weston to define an explicit list of events.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517579/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 13:52 UTC (Wed)
                               by <b>mupuf</b> (subscriber, #86890)
                              [<a href="/Articles/517625/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This solution seems a bit over-complicated to me. The solution presented in the article can leverage policy kit too and doesn't necessitate another daemon neither dbus. <br>
<p>
However, a lot of work is left to be done on all this matter. We don't pretend to understand every valid use cases and the need of every applications so I may not be able to understand your point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor517617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 11:23 UTC (Wed)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/517617/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Martin observed that a GPU buffer is not zeroed when it is allocated, meaning that the previous user's data is visible to the new user. This could create a confidentiality issue. The problem is that zeroing buffers has a heavy performance impact. He suggested two strategies for dealing with this: zeroing deallocated buffers when the CPU is idle and using the GPU to perform zeroing of buffers.</font><br>
<p>
Is that 'zero-ing when not busy' actually a request for an in-kernel TRIM thread? Such a thread might also need to make promises about when its work eventually gets done, but that could be mitigated with a fallback plan for a on a busy system: explicitly wipe the memory before it's re-used. Do I hear "show me the code"?<br>
<p>
Ken.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517624"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 13:43 UTC (Wed)
                               by <b>mupuf</b> (subscriber, #86890)
                              [<a href="/Articles/517624/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here are basically my thoughts about this:<br>
- each VRAM page should be marked with the id of the GPU user that created it.<br>
- the wiping process requires another attribute (being_wiped) on each page. Before scheduling a bunch of page wiping, the correspondent pages should be marked "being_wiped". When the wiping process is done, the pages should be marked wiped (not linked to a single user) and the being_wiped should be cleared.<br>
- when allocating memory for a user, memory pages that were previously used by this user should be use for the allocation. When none is left, wiped memory pages should be used. If none are left but there are pages being wiped, then the allocator should wait for them to be wiped before using them. Otherwise, just return ENOMEM.<br>
<p>
The wiping process should be run on the whole VRAM at boot time and then can be scheduled when the pool of wiped pages is getting low. This should lower the number of wiping and thus, lower the VRAM bandwidth usage.<br>
I expect the performance-impact to be minimal in most cases. However, it makes the allocation more complicated and more memory-consuming.<br>
<p>
On the other hand, if we want all buffers to be wiped at allocation time, then we can  lower the allocation complexity at the expense of memory-bandwidth usage (more wiping are needed).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517624/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor517649"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 16:16 UTC (Wed)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/517649/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is VRAM treated differently from plain RAM? Can't a sanitizing step like <a href="https://lwn.net/Articles/334747/">https://lwn.net/Articles/334747/</a> be implemented for VRAM?<br>
<p>
A more general question: why are GPUs being treated differently from CPUs or coprocessors? We are there: GPUs need scheduling, process compartmentalisation, per-user limits, and so on, just like CPUs. It looks like people are reinventing everything on GPUs instead of just extending the existing concepts (if not code) to GPUs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517649/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 16:42 UTC (Wed)
                               by <b>mupuf</b> (subscriber, #86890)
                              [<a href="/Articles/517664/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Memory management on GPUs is very hardware-specific on GPUs. For instance, some buffers can be tiled or not depending on some conditions. It is also possible to "swap" VRAM buffers inside the RAM but certainly not on the hard disk drive. In its current forms, it is almost impossible to share code between the RAM allocator and GPU VRAM allocator (that is driver-dependent). <br>
<p>
In the end, we are "reinventing the wheel" but the concepts still holds (I didn't have the idea overnight for VRAM sanitization). However, the code is completely different because GPUs are more complex than CPUs.<br>
<p>
As for why GPUs aren't considered like CPUs, the reason is that they are built for throughput and aren't ready for being considered as a new processor (allmost no GPUs support preemption). We are slowly but surely going towards this direction but it is too early for us to design an API that would accommodate for both CPUs and GPUs.<br>
<p>
In the end, we can say that we indeed extend the already-existing CPU concepts to GPUs but it takes time and the GPU ecosystem is much fragmented than the CPU world. Moreover, most GPUs (if not all), aren't ready to be considered as an equivalent of the x86 (not even remotely).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 16:37 UTC (Thu)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/517835/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I remember reading hardware documentation of something similar to adress translation tables for onboard VRAM on a Cirrus Logic Laguna3D graphics chipset circa... 1996. Good wheels get reinvented so often... ;-)<br>
<p>
But even if common hardware protection features are not (uniformly at least) available on GPUs, from what we know about other hardware, it seems that memory protection and priviledged instructions are foundational features for practical security mechanisms.<br>
<p>
If these features are not in the hardware I wonder if it's even possible to adress the issue of graphics stack security for multiple applications without:<br>
1) either emulating them (something which apparently has started to appear but does not seem to be universally agreed upon);<br>
2) or evolving the security model to adress a different kind of security features (for example: forbidd applications with conflicting security requirement to use the same "screen").<br>
<p>
By the way, maybe option 2 is really workable in the context of graphical applications. Maybe there is a need for a risk/attacks analysis at a higher level and more thinking about the most important security features in order to provide a decent (if not completely satisfactory) implementation.<br>
<p>
For example, I would not mind trading a long context switch time (~1s) for access to full hardware control for a fullscreen application (game) while I may be reluctant to do that for a text editor and framebuffer security may even be a reason not to use a GUI for an encryption tool.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor517685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 17:00 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/517685/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One problem is that every weakness listed is something that has desirable users.<br>
<p>
you want to be able to do screenshots, or even create a video of what you are doing.<br>
<p>
you want to be able to have one application take over the screen and not let you do anything else, without that you couldn't have 'screensavers' that are also session locks. Kiosk mode for applications could not be done, etc.<br>
<p>
virtual keyboards are extremely useful in some cases.<br>
<p>
the problem isn't the capability for _some_ program to do these things, it's the capability for _any_ program to do these things.<br>
<p>
you shouldn't have to through out the capability to do these things, just change the control.<br>
<p>
X already requires the "magic cookie", so there is enough mechanism in place to allow this to work, we just need to change things so that you don't use the same cookie for every app, and don't give every cookie the same permissions.<br>
<p>
It would be best if this ability wasn't tied to SELinux (I'm not sure if XSELinux is, or is just a similar name)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 17:50 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/517693/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;you want to be able to have one application take over the screen and not let you do anything else, without that you couldn't have 'screensavers' that are also session locks. Kiosk mode for applications could not be done, etc.</font><br>
<p>
IMO this belongs in the compositor, not as a separate application.  Screensavers / screenlockers are fragile and buggy on X right now [1][2].<br>
<p>
If the (Wayland-style) compositor handled screen locking, then, if the compositor crashed, you're still secure -- the whole session goes away.<br>
<p>
[1] See, for example, the old bug where funny key combos caused the screen to unlock.<br>
[2] On the machine I'm typing on, sometimes the password prompt is completely invisible, and it's quite common for the unlocked screen to flash above the screen locker when DPMS comes back.<br>
<p>
<p>
That being said, I mostly agree with the rest of your comments.  File descriptors might be a nicer way to handle permissions than magic cookies, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 19:04 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/517701/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
so if you want a different screensaver, you need to have a different compositor?<br>
<p>
the 'funny key combos cause the screen to unlock' were not an accident, that was a deliberate feature for debugging that accidently got enabled by default.<br>
<p>
as one of those people who routinely uses X remotely, file descriptors have a significant problem ;-). There's nothing inherently wrong with cookies, just with the permissions being the same for all apps from a single user.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 20:03 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/517707/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; so if you want a different screensaver, you need to have a different compositor?</font><br>
<p>
Or the compositor could have specific support for pluggable screensavers.  In any case, I think that the Wayland compositor will end up being more line gnome-shell than compiz, so you may not have a choice anyway.<br>
<p>
<font class="QuotedText">&gt; the 'funny key combos cause the screen to unlock' were not an accident, that was a deliberate feature for debugging that accidently got enabled by default.</font><br>
<p>
Except that it was a feature to release screen grabs, which ought to be harmless for anything except screen lockers.<br>
<p>
<font class="QuotedText">&gt; as one of those people who routinely uses X remotely, file descriptors have a significant problem ;-). There's nothing inherently wrong with cookies, just with the permissions being the same for all apps from a single user.</font><br>
<p>
Presumably this will get solved the same way as the rest of Wayland remoting which, AIUI, doesn't really exist right now.  Maybe magic cookies would still be better for the remoting server, whatever it is, to tell what privileges its clients have.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor517946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2012 9:15 UTC (Fri)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/517946/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There's nothing inherently wrong with cookies, just with the permissions being the same for all apps from a single user.</font><br>
<p>
If you put the cookie in a file in the user's home directory, as is done for the current X server cookies then yes.  If you imagine different cookies for different privileges (reading from the screen, sending input events, whatever) there is no reason why there should not be different mechanisms for the clients which need them to obtain them.  For example you could put them in global files readable only to a particular user group, or you could use DBus and PolicyKit to pass them (just an example, as I know that DBus and remote X don't get along very well at present), or even both.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2012 19:13 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/518037/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I said that the problem was with the permissions being the same for all apps from a single user.<br>
<p>
putting the cookie in one file and having all apps read it from that file would seem to match my criteria for a problem.<br>
<p>
But there's nothing saying that you couldn't have a different cookie for each app, and then give different cookies different permissions.<br>
<p>
this wouldn't be a matter of 'user this cookie for screenshots' type of thing, but a matter of 'application X was given cookie Y, application X is a screenshot app, so allow cookie Y to do screenshots'<br>
<p>
Assuming apps do something sane and only read this cookie once at startup, you could replace the file they read it from with something that's an interface to an application that can use SCM_CREDENTIALS to find out what app is talking to it, and return different contents to different apps. You can then have that program either give a different cookie to every app, or make whatever policy decisions it wants about what cookies to give to different apps.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2012 19:28 UTC (Fri)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/518041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I said that the problem was with the permissions being the same for all apps from a single user.</font><br>
&gt;<br>
<font class="QuotedText">&gt; putting the cookie in one file and having all apps read it from that file would seem to match my criteria for a problem.</font><br>
<p>
Quite right; in fact my mind was on the track of SETGID or similar applications, but thinking again that is probably not such a great idea in this context.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor518205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 4:27 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/518205/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; so if you want a different screensaver, you need to have a different compositor?</font><br>
<p>
As I recall xscreensaver supports its different timewasters by each being an external program from the main screen lock, it would seem that a lock implemented in the compositor would likely operate the same way.  The screen lock itself has a very well defined function and UI and could easily be hardwired in, especially if that gets rid of a bunch of failure cases.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor517694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 17:51 UTC (Wed)
                               by <b>dpquigl</b> (guest, #52852)
                              [<a href="/Articles/517694/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
X has an access control framework similar to the LSM kernel framework called XACE. XSELinux is a security module for the XACE framework that uses SELinux to define policy and make access control decisions (called a Userspace Object Manager in SELinux speak). You're welcome to write other access control modules for XACE and propose them for inclusion if you have a good idea for an access control module.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 23:43 UTC (Wed)
                               by <b>mupuf</b> (subscriber, #86890)
                              [<a href="/Articles/517745/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
X cannot be made secure by nature. Even if we managed to do whatever we want with X, the applications aren't ready for that and would just crash because they don't always look at the error codes.<br>
<p>
The point of the presentation wasn't to fix X, it was to fix DRM, to talk about security in Wayland and discuss about a security policy for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 0:15 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/517748/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
causing an app to crash because it tries to do a screenshot and it wasn't allowed to seems like a very reasonable thing to have happen :-)<br>
<p>
While I expect that doing checks on these half dozen or so 'special' priviledges would break a few things, I don't think it would be that many, and if the capaibility was available, distros would experiment with them.<br>
<p>
After all, we know that SELinux breaks things, but it's being deployed. I would expect that SELinux has broken far more things than a handful of permission checks in X would.<br>
<p>
<font class="QuotedText">&gt; The point of the presentation wasn't to fix X, it was to fix DRM</font><br>
<p>
this writeup makes it sound like it was talking about problems in X not in the DRM layer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 9:56 UTC (Thu)
                               by <b>Siosm</b> (subscriber, #86882)
                              [<a href="/Articles/517776/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; While I expect that doing checks on these half dozen or so 'special' priviledges would break a few things, I don't think it would be that many, and if the capaibility was available, distros would experiment with them.</font><br>
<p>
I don't think we will be able to fix the input problems in X.<br>
<p>
<font class="QuotedText">&gt; After all, we know that SELinux breaks things, but it's being deployed. I would expect that SELinux has broken far more things than a handful of permission checks in X would.</font><br>
<p>
SELinux is mostly used in a "targeted" way in Red Hat/Fedora, and thus does not protect GUI apps. It is a lot of work to create and maintain an SELinux policy for every GUI applications.<br>
<p>
<font class="QuotedText">&gt; this writeup makes it sound like it was talking about problems in X not in the DRM layer.</font><br>
<p>
The second talk deals with DRM problems. This one was done to recap known problems and make sure we do not do the same "mistakes" with Wayland/Weston<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518206"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 4:33 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/518206/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; After all, we know that SELinux breaks things, but it's being deployed. I would expect that SELinux has broken far more things than a handful of permission checks in X would.</font><br>
<p>
Most SELinux permissions checks happen where applications should already expect them to be occurring such as on filesystem objects.  Putting in permissions where there weren't any before and where there is a lot of backwards compatibility requirements for very old software seems like a very bad idea and quite likely to break the world.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518206/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor517702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 19:06 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/517702/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In addition, as long as you allow more than one app to have windows open at a time, there is some potential for an app to pop up a window that looks like another app (or a system password prompt)<br>
<p>
Server-side window decorations have the potential to label each window as to what app it is part of (users may still ignore the data, but at least it can't be faked by the app)<br>
<p>
but if you either allow the client to tell the server what to label a window, or do client-side decorations where the client is in full control, it's impossible for the user to be able to trust any window completely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517746"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 23:59 UTC (Wed)
                               by <b>mupuf</b> (subscriber, #86890)
                              [<a href="/Articles/517746/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Completely fair point! There is no association between the binary file and its window(s) and it can be misleading to the user in some cases.<br>
<p>
As you said, this is fixable with server-side decoration rendering but it isn't when the client renders everything. I guess we could actually display the name of the binary in the compositor when hovering the mouse on top of the application bar but that's not obvious to most users.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517746/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 4:38 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/518207/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Server-side window decorations have the potential to label each window as to what app it is part of (users may still ignore the data, but at least it can't be faked by the app)</font><br>
<p>
IIUC applications can set their window title or argv[0] to anything they want and I don't think that's a feature that would likely be dropped making the point moot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 8:51 UTC (Mon)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/518213/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; IIUC applications can set their window title or argv[0] to anything they want and I don't think that's a feature that would likely be dropped making the point moot.</font><br>
<p>
And in a secure environement with server side decoration, this application's provided tittle can either be ignored or be added in addition to a color or text which provide the server's view of the application.<br>
<p>
That said, one could have virtual desktop/environment which would group application by security level even with client side decoration, of course for single applications this is annoying..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor517703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 19:11 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/517703/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even the example of catching your interaction with a bank is not necessarily an evil thing<br>
<p>
what if you are trying to create a video to demonstrate how to use the bank website?<br>
<p>
This is why the mantra "provide mechanism not policy" exists.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 19:35 UTC (Wed)
                               by <b>jg</b> (guest, #17537)
                              [<a href="/Articles/517704/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And many people seem to forget that "Mechanism, not policy" does *not* mean that the default policy should be insanity....  I've seen many who seem to think it does.<br>
                 - Jim<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 21:24 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/517722/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
agreed, having sane defaults for common use cases is a GOOD thing.<br>
<p>
Just don't make the mistake of thinking that those common use cases are the only use cases.<br>
<p>
I remember listening to you talk at some USENIX event a decade or so ago and talking about all the new things that were popping up on desktop systems (transparent terminal windows and similar IIRC) and you commented that when developing X you not only never considered such things, but if asked you would have said that it wasn't possible.<br>
<p>
Because the mechanism was flexible enough, new things that the initial developers never imagined were possible.<br>
<p>
It seems like a lot of people have forgotten that.<br>
<p>
<p>
<p>
Ubuntu is the force that it is today, not because they were doing any hard technical things that nobody else was doing, but in large part because they were offering sane defaults (with some technical effort in automating configs and device detection) that nobody else was doing at the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 10:03 UTC (Thu)
                               by <b>Siosm</b> (subscriber, #86882)
                              [<a href="/Articles/517778/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Just don't make the mistake of thinking that those common use cases are the only use cases.</font><br>
<p>
As said in the article, the goal in not to prevent people from adding things to Wayland/Weston, but to deny access to security-related features by default, and to provide a way for distribution/developers to make sure access to those features is allowed, by default, only the applications really requiring it, not just any application.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor517710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 20:18 UTC (Wed)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/517710/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You seem to be in violent agreement with the engineers who put this presentation together.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2012 23:40 UTC (Wed)
                               by <b>mupuf</b> (subscriber, #86890)
                              [<a href="/Articles/517744/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess you are talking about me.<br>
<p>
Well, I'm not in violent agreement with one them, I am one of them (Martin Peres). I'm here to clarify our views if needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 3:54 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/518198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was responding to someone else, sorry if it looked like I was responding to you.  Thanks for putting this together and for taking the time to think it through and explain your thoughts to the LWN community.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor517780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 10:44 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/517780/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding Wayland security, security has to be possible, but not mandated. By locking down applications we make them less useful. Think for instance what will happen if the Unix shell mandated integrity of input or confidentiality of output for all programs: pipes would be impossible.<br>
<p>
Having insecure input and output, _in_addition_ to secure ones, is clearly desirable and good.<br>
<p>
Let applications chose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517802"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 13:42 UTC (Thu)
                               by <b>mupuf</b> (subscriber, #86890)
                              [<a href="/Articles/517802/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree that the system should be made as flexible as possible. However, applications should NEVER be allowed to chose without control from distributions or the system administrator.<br>
<p>
It's like saying that applications should be able to decide if they want raw access to disks or not. Willing to do so is suicidal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517802/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor517807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 14:50 UTC (Thu)
                               by <b>Siosm</b> (subscriber, #86882)
                              [<a href="/Articles/517807/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Regarding Wayland security, security has to be possible, but not mandated.</font><br>
<p>
If it's not enabled by default, nobody will use it because it won't get testing and bugs won't be fixed.<br>
<p>
<font class="QuotedText">&gt; By locking down applications we make them less useful.</font><br>
<p>
Only a very limited set of applications has to be "locked down" in the Wayland/Weston case. Any "classic" application won't even notice the change.<br>
<p>
<font class="QuotedText">&gt; Think for instance what will happen if the Unix shell mandated integrity of input or confidentiality of output for all programs: pipes would be impossible.</font><br>
<p>
This is hardly comparable. On a classic *nix system, you use different users to separate tasks which should not interact with each others. Communications channels between users (pipes...) must be explicitly created, most of the time by the most privileged user. Without MAC (Mandatory Access Control) there is no confinement between applications from the same user.<br>
<p>
With GUI applications, everything runs under the same user, so we can not rely on user separation anymore. In the Wayland/Weston case, only explicit user controlled channels allow interactions between applications (drag&amp;drop, copy&amp;paste).<br>
<p>
<font class="QuotedText">&gt; Having insecure input and output, _in_addition_ to secure ones, is clearly desirable and good.</font><br>
<p>
Again, people will naturally choose the easy way over the hard way.<br>
<p>
In order to work, security has to be default built-in design feature which should make common operation easy, and control uncommon operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517959"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2012 10:34 UTC (Fri)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/517959/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If it's not enabled by default, nobody will use it because it won't get testing and bugs won't be fixed.</font><br>
<p>
Sorry for the harsh words, but this is the LAMEST possible argument you could make. If it was useful for someone people would use it. If it's not used it's because it's not useful, so we're all better without it. <br>
<p>
This strategy did not work all that well for GNOME, please do not repeat this mistake again.<br>
<p>
<font class="QuotedText">&gt; Only a very limited set of applications has to be "locked down" in the Wayland/Weston case. Any "classic" application won't even notice the change.</font><br>
<p>
Nope, you got it wrong. Take virtual keyboards, for instance. Currently they are not possible in Wayland because it has been decided that the compositor should not touch input in any way, applications receive it directly from the kernel. This decision effectively locks down _all_ applications, even those for which input integrity is of no use.<br>
<p>
<font class="QuotedText">&gt; With GUI applications, everything runs under the same user</font><br>
<p>
This does not need to be this way.<br>
<p>
<font class="QuotedText">&gt; Without MAC (Mandatory Access Control) there is no confinement between applications from the same user.</font><br>
<p>
And that is, the ability to pass information between applications, is what makes them useful. What we need is a mechanism to confine _selected_ applications.<br>
<p>
<font class="QuotedText">&gt; Again, people will naturally choose the easy way over the hard way.</font><br>
<p>
True. Also, people chose what works over what does not.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517959/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518055"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2012 21:54 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/518055/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Nope, you got it wrong. Take virtual keyboards, for instance. Currently they are not possible in Wayland because it has been decided that the compositor should not touch input in any way, applications receive it directly from the kernel. This decision effectively locks down _all_ applications, even those for which input integrity is of no use.</font><br>
<p>
And that's good. You can implement a virtual keyboard right way, by writing a CUSE driver. This way every app in the system will be able to access it. Or you can extend the compositor to do this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518055/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 4:08 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/518200/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; If it's not enabled by default, nobody will use it because it won't get testing and bugs won't be fixed.</font><br>
<font class="QuotedText">&gt;Sorry for the harsh words, but this is the LAMEST possible argument you could make. If it was useful for someone people would use it. If it's not used it's because it's not useful, so we're all better without it. </font><br>
<p>
It may be lame but it's true, non-default options don't get as much testing as default options, especially in volunteer-tested software, the less-used code paths are more likely to be buggy.  Sure, some people will use non-default config options but their experience may be sub-par because of it.<br>
<p>
In any event, reasonable security options should be enabled by default.  Imagine that something like password hashing were a non-default feature.  What would happen is that most people would never turn it on and have plenty of bad things happen as a result.  After the second or third time the security design problem bites them maybe they'd turn on the more secure feature but then would find themselves locked out of their system or some other horrible fate after which they'd find out that nobody turns the security feature on because it doesn't work.  So then they'd just accept the additional risk of doing things in a more risky way that is likely to have a bad outcome because that's just the way things work.<br>
<p>
It seems that this kind of scenario has played out many times over the years, like MS Windows putting people in the Administrators group to get around the entire permissions checking system.  The Windows issue with the Administrators group and all the trouble that has caused over the years seems to be exactly the kind of thing they are trying to avoid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 4:20 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/518204/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there are security options that can be turned on because they don't break anything (i.e. hashed passwords) and security options that should not be turned on by default because they do break things (the examples in this case that break all soft keyboards, screenshot programs, etc)<br>
<p>
many security people fall into the trap where they consider security the most important thing. In the real world it isn't. Security is a matter of risk, and you have to balance risk vs benefit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor518514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2012 7:39 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/518514/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>Nope, you got it wrong. Take virtual keyboards, for instance. Currently they are not possible in Wayland because it has been decided that the compositor should not touch input in any way, applications receive it directly from the kernel. This decision effectively locks down _all_ applications, even those for which input integrity is of no use.
</blockquote>
<p>Have you a cite for that? My recollection, backed by <a rel="nofollow" href="http://wayland.freedesktop.org/docs/html/sect-Protocol-Input.html">the protocol spec</a> is that the Wayland compositor is the only application that gets input directly from the kernel; everything else is notified of events by the compositor. This is essential if the compositor is to transform events in arbitrary fashion - how can a surface know where it is in kernel-global coordinates if the compositor is the only thing that knows about the arbitrary transform applied to it?
      
          <div class="CommentReplyButton">
            <form action="/Articles/518514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor517910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 22:18 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/517910/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe, but Martin is right that security has to be on by default, not off, at least for the most extreme stuff like keystroke monitoring or overpainting. I want selfspy to connect to the RECORD extension and record my keystrokes, but if anything else tries to do it I damn well want to refuse it. Right now, I can't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor517958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2012 10:08 UTC (Fri)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/517958/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Right now, I can't.</font><br>
<p>
And that's the point of my argument. Security has to be _possible_, but not _mandated_. With X11, right now, it's not possible. That is another way in which Wayland is an improvement over what we have right now.<br>
<p>
That doesn't mean, though, that many more steps in that direction are equally as good. We should be careful to not overshoot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2012 4:11 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/518201/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Security has to be _possible_, but not _mandated_.</font><br>
<p>
That is a very situational judgement on a technology by technology and setting by setting basis.  There are often ways to organize things more securely without being a burden for the user.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor517892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">XDC2012: Graphics stack security</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2012 20:03 UTC (Thu)
                               by <b>DavidS</b> (guest, #84675)
                              [<a href="/Articles/517892/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I really dig Peter Hutterer's notion of "semantic" global shortcuts. A privileged configuration panel can connect up keystrokes to "command slots" on each application and gone are the days of overlapping global shortcuts!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/517892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
