        <!DOCTYPE html>
        <html lang="en">
        <head><title>Semantics of MMIO mapping attributes across architectures [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/698014/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/697539/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/698014/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Semantics of MMIO mapping attributes across architectures</h1>
</div>
<div class="ArticleText">
<div class="GAByline">
           <p>August 24, 2016</p>
           <p>This article was contributed by Paul E. McKenney, Will Deacon, and Luis R. Rodriguez</p>
           </div>
<p>
Although both <a
href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory-mapped
I/O</a> 
(MMIO) and normal memory (RAM) are
	ultimately accessed using the same CPU instructions, they are used
	for very different purposes.  Normal memory is used to
	store and retrieve data, of course, while MMIO is instead primarily used
	to communicate with I/O devices, to initiate I/O
	transfers and to acknowledge interrupts, for example.  And while concurrent
	access to shared memory can be
<a
href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">complex</a>,
 programmers need
	not worry about what type of memory is in use, with only a few
	<a href="https://en.wikipedia.org/wiki/Row_hammer">exceptions</a>.
In contrast, even in the single-threaded case,
	understanding the effects of MMIO read and write operations requires a
	detailed understanding of the specific device being accessed by
	those reads and writes.
But the Linux kernel is not single-threaded, so we
	also need to understand MMIO ordering and concurrency issues.
</p>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
This article looks under the hood of the Linux kernel's MMIO
implementation, covering a number of topics:

<ol>
<li>	<a href="#MMIO Introduction">MMIO introduction</a>
<li>	<a href="#MMIO Access Primitives">MMIO access primitives</a>
<li>	<a href="#Memory Types">Memory types</a>
<li>	<a href="#x86 Implementation">x86 implementation</a>
<li>	<a href="#ARM64 Implementation">ARM64 implementation</a>
<li>	<a href="#PowerPC Implementation">PowerPC implementation</a>
<li>	<a href="#Summary and Conclusions">Summary and conclusions</a>
</ol>

<h4><a name="MMIO Introduction">MMIO introduction</a></h4>

<img src="https://static.lwn.net/images/2016/MMIOwrite.svg" alt="[MMIO write]" hspace=5
align="right" width=311 height=134>

<p>
MMIO offers both read and write operations.
MMIO writes are used for one-way communication, causing the device
to change its state, as shown in the diagram on the right.
The MMIO write operation transmits the data and a portion of the
address to the device, and the device uses both quantities
to determine how it should change its state.

<div class="tll"><a name="Quick quiz 1"><b>Quick quiz 1</b>:</a>
Why can't the device make use of the full address?
<br><a href="#qq1answer">Answer</a>
</div>

The size of the MMIO write is also significant, in fact, the device
might react completely differently to a single-byte MMIO write than
to (say) a four-byte MMIO write.
The size of the access could therefore be thought of as additional
bits feeding into the device's state-change logic.

<p>
MMIO reads are used for two-way communication, causing the device to
return a value based on its current state.

<img src="https://static.lwn.net/images/2016/MMIOread.svg" alt="[MMIO read]" hspace=5
align="right" width=325 height=134>

The MMIO read operation transmits a portion of the
address to the device, which the device can use to determine how to
query its state in order to compute the return value.
Interestingly enough, the device can also change its state based on
the read, and many devices do exactly that.
For example, the MMIO read operation that reads a character from a
serial input device would be expected to also remove that character
from the device's internal queue, so that the next MMIO read would
read the next input character.
As with writes, the size of the MMIO read is significant.

<p>
An MMIO read operation signals its completion by returning the value from
the device.
In contrast, the only way to determine when an MMIO write operation has
completed is to do an MMIO read to poll for completion.
Such polling is completely and utterly device-dependent,
sometimes even requiring time delays between the initial
MMIO write and the first subsequent MMIO read.

<p>
Given that both MMIO reads and writes can change device state,
ordering is extremely important and, as will be discussed below,
many of the Linux kernel's MMIO access functions provide strong ordering,
both with each other and with locking primitives and value-returning
atomic operations.
However, for devices such as frame buffers, it is not helpful
to provide strict ordering, as the order of writes to independent
pixels is irrelevant.
In fact,
<a href="https://en.wikipedia.org/wiki/Write_combining">write combining</a>
(WC) is an important frame-buffer performance
optimization, and this optimization explicitly ignores the
order of non-overlapping writes.
This means that the hardware and the Linux kernel need some way
of specifying which MMIO locations can and cannot tolerate
reordering.

<p>
The x86
family responded to this need with
<a href="https://en.wikipedia.org/wiki/Memory_type_range_register">
memory type range registers</a> (MTRRs),
which were used to set WC cache attributes for
<a href="https://en.wikipedia.org/wiki/Video_Graphics_Array">VGA</a>
memory.
MTRRs have been used to enable different caching policies for memory
regions on different
<a href="https://en.wikipedia.org/wiki/Conventional_PCI">PCI</a> devices.
When an x86 system boots, the default
cache attributes for physical memory are set by setting the model-specific
register that sets the default memory type (MSR_MTRRdefType), and then
MTRRs are used to modify memory in other ranges 
to other cache attributes, for example, uncached (UC) or WC for MMIO
regions.
Some BIOSes set MSR_MTRRdefType to
<a href="https://en.wikipedia.org/wiki/Cache_(computing)#WRITE-BACK">writeback</a>,
which is a common default for DRAM.
Other BIOSes might set MSR_MTRRdefType to UC, and then use MTRRs
to set DRAM to writeback.
One of the biggest issues with MTRRs is the limited number of them.
In addition, using MTRRs on x86 requires the use of the heavyweight
<tt>stop_machine()</tt> call whenever the MTRR configuration changes.

<div class="tlr"><a name="Quick quiz 2"><b>Quick quiz 2</b>:</a>
Can you set up UC access to normal (non-MMIO) RAM?
<br><a href="#qq2answer">Answer</a>
</div>

<p>
The <a href="https://en.wikipedia.org/wiki/Page_attribute_table">
page attribute table</a> (PAT) relies on paging to lift this
limitation.
Unfortunately, the BIOS runs in
<a href="https://en.wikipedia.org/wiki/Real_mode">real mode</A>,
in which paging is not available, which means that the BIOS must
continue to use MTRRs so x86 systems will continue to have them.
However, Linux kernels <i>can</i> use paging, and can therefore
use PAT when running on hardware providing it.

<p>
In short, MMIO reads and writes can be thought of as a message-passing
communication mechanism for interacting with devices; they can be
uncached for traditional device access or write combining for
access to things like frame buffers and
<a href="https://en.wikipedia.org/wiki/InfiniBand">InfiniBand</a>,
and they require special attention in order to
interact properly with synchronization primitives such as locks.
The Linux kernel therefore provides architecture-specific primitives
that implement MMIO accesses, as described in the next section.

<h4><a name="MMIO Access Primitives">MMIO access primitives</a></h4>

<p>
The <tt>readX()</tt> function
does MMIO reads, with the <tt>X</tt> specifying the size of the
read, so that <tt>readb()</tt> reads one byte, 
<tt>readw()</tt> reads two bytes,
<tt>readl()</tt> reads four bytes, and, on some 64-bit systems,
<tt>readq()</tt> reads eight bytes.
These functions are all little-endian, but in some cases, big-endian
behavior can be specified using an additional 
"<tt>_be</tt>"
component to the <tt>X</tt> suffix.

<p>
The <tt>writeX()</tt> function
does MMIO writes, with the <tt>X</tt> specifying write size as above,
and again in some cases with an additional "<tt>_be</tt>"
component to the <tt>X</tt> suffix.

<p>
There are also <tt>inX()</tt> and <tt>outX()</tt> functions that map back
to the x86 <tt>in</tt> and <tt>out</tt> instructions, respectively.
The <tt>X</tt> suffix contains the size in bits and a
"<tt>be</tt>" or
"<tt>le</tt>" component to specify endianness.
These are sometimes mapped to MMIO on non-x86 systems.  The
<tt>ioreadX()</tt> and <tt>iowriteX()</tt>, where <tt>X</tt> is the number
of bits to operate on, can also be used to read and write MMIO; they were
added to
<a href="/Articles/102232/">hide the differences</a> between
<tt>in</tt>/<tt>out</tt> operations and MMIO.

<p>
Linus Torvalds created the following example on a Kernel Summit whiteboard to illustrate
ordering requirements: 

<pre>
     1 unsigned long global = 0;
     2
     3 void locked_device_output(void)
     4 {
     5   spin_lock(&amp;a);
     6   i = global++;
     7   writel(i, dev_slave_address);
     8   spin_unlock(&amp;a);
     9 }
</pre>

<p>
Line&nbsp;5 acquires lock <tt>a</tt>, line&nbsp;6 increments a global
variable <tt>global</tt> under that lock, line&nbsp;7 writes the
previous value of <tt>global</tt> to an MMIO location at
<tt>dev_slave_address</tt>, and finally line&nbsp;8 releases the lock.
In an ideal world, both lines&nbsp;6 and&nbsp;7 would be protected by the
lock when <tt>locked_device_output()</tt> is invoked concurrently.

<p>
Of course, the normal variable <tt>global</tt> is protected by the lock,
that being what locks are for.
However, for the MMIO write to <tt>dev_slave_address</tt>,
such protection requires that the implementations of
<tt>spin_lock()</tt>, <tt>spin_unlock()</tt>,
and <tt>writel()</tt> <a href="http://yarchive.net/comp/linux/write_barriers.html">cooperate</a> so as to provide the ordering required to
force the <tt>writel()</tt> to <tt>dev_slave_address</tt>
of the value&nbsp;0 from the first <tt>locked_device_output()</tt> call to
happen before the second call writes the value&nbsp;1.
This is what x86 does and what most developers would expect to happen.
Weakly ordered systems must therefore insert whatever memory barriers are
required to enforce this ordering.

<div class="tll"><a name="Quick quiz 3"><b>Quick quiz 3</b>:</a>
What do weakly ordered systems do to enforce this ordering?
<br><a href="#qq3answer">Answer</a>
</div>

<p>
Providing the required ordering can be expensive on weakly ordered systems.
Because there are a number of situations where ordering is not required
(for example, frame buffers), the Linux kernel provides
relaxed variants
(<tt>readX_relaxed()</tt> corresponding to <tt>readX()</tt> and
<tt>writeX_relaxed()</tt> corresponding to <tt>writeX()</tt>)
that do not guarantee strong ordering, which can be used as follows:

<pre>
     1 unsigned long global = 0;
     2
     3 void locked_device_output(void)
     4 {
     5   spin_lock(&amp;a);
     6   i = global++;
     7   writel_relaxed(i, dev_slave_address);
     8   spin_unlock(&amp;a);
     9 }
</pre>

<p>
Because this example uses <tt>writel_relaxed()</tt> instead of
<tt>writel()</tt>, the <tt>writel_relaxed()</tt> can be reordered
with the <tt>spin_unlock()</tt>, so that the write of the value 1
might well precede the write of the value 0.
An MMIO write memory barrier, called <tt>mmiowb()</tt>, may be used to
prevent MMIO writes from being reordered with each other or or with
locking primitives and value-returning atomic operations.
This <tt>mmiowb()</tt> primitive can be used as shown below:

<pre>
     1 unsigned long global = 0;
     2
     3 void locked_device_output(void)
     4 {
     5   spin_lock(&amp;a);
     6   i = global++;
     7   writel_relaxed(i, dev_slave_address);
     8   mmiowb();
     9   spin_unlock(&amp;a);
    10 }
</pre>

<p>
Again, without the <tt>mmiowb()</tt>, the <tt>writel_relaxed()</tt> call
might be reordered with its counterpart from a later instance of this
critical section that was running on a different CPU.

<div class="tlr"><a name="Quick quiz 4"><b>Quick quiz 4</b>:</a>
Why can't <tt>mmiowb()</tt> be used with <tt>writel()</tt>?
<br><a href="#qq4answer">Answer</a>
</div>

<p>
A more useful version of this example might do several
<tt>writel_relaxed()</tt> invocations in the critical section followed
by a final <tt>mmiowb()</tt>.
It is worth noting that <tt>mmiowb()</tt> is a no-op on most architectures.

<p>
However, <tt>_relaxed()</tt> accesses from a given CPU to a specific device are
guaranteed to be ordered with respect to each other.
Tighter semantics can of course be used: per-bus or even global, for example.

<p>
Nevertheless, the <tt>_relaxed()</tt> functions are not primitives that most device driver
developers normally consider using and, even if they did, there are still
some kernel calls, such as locking calls, that might nullify such relaxed effects.
Its unclear if these implications have always been well thought-out throughout
the entire kernel. For instance, it is now understood that PowerPC's default kernel
<tt>writel()</tt> uses a memory barrier; although typically one would expect
write-combining to happen in user space for frame buffers, kernel writes
could <a href="http://marc.info/?l=linux-fbdev&m=143519363119441&w=2">nullify</a>
the write-combining effects.  

<p>
Asking more developers
to use the relaxed primitives when write combining might be the first
instinct to address this situation, there are other possible issues
which still need to be considered, however.  For instance, would using a
<tt>spin_lock()</tt> 
nullify any write-combining effects on some architectures even if relaxed
primitives were used?  If so, which architectures would be affected? Are we
nullifying write combining in some areas in the kernel even on x86 if locks
are used? To answer these questions, we must review each architecture's MMIO and
locking primitive helpers and the implications of them on ordering.

<h4><a name="Memory Types">Memory types</a></h4>

<p>
As noted earlier, this article covers the two most common flavors of MMIO,
uncached MMIO and write-combining MMIO.
In uncached MMIO, each read and write is independent and in some sense atomic,
with no combining, prefetching, or caching of any kind.
The <tt>ioremap_nocache()</tt> function is used to map uncached MMIO registers.
In write-combining MMIO, both reads and writes can be both coalesced
and reordered, even the non-<tt>_relaxed()</tt> reads and writes.
Memory that is write combining is also normally
"prefetchable", and these terms sometimes appear to be used
interchangeably.
The <tt>ioremap_wc()</tt> function is used to map write-combining MMIO
registers.

<p>
For any given architecture, there are some questions about write combining:

<ul class="spacylist">
<li>	What prevents reordering and combining?
	(Presumably <tt>mmiowb()</tt> and perhaps also <tt>mb()</tt>.)
<li>	What operations flush the write buffers?
	(Hardware dependent, but reads from a given device typically
	flush prior writes to that same device.)
</ul>

Five additional per-architecture questions will be addressed in tabular form:

<ol class="spacylist">
<li>	Must non-relaxed accesses to MMIO regions
	be confined to lock-based critical sections?
	(Presumably the answer is "yes".)
<li>	Must relaxed accesses to MMIO regions
	be confined to lock-based critical sections?
	(Prudence would suggest "yes" as the answer, at least in the UC case.)
<li>	Must reads from MMIO regions be
	ordered with each other?
	(Presumably the answer is "no" for <tt>_relaxed()</tt> primitives.)
<li>	Must reads from MMIO regions be
	ordered with writes to other locations within the region?
	(Presumably the answer is "no".)
<li>	Must accesses to specific locations in MMIO
	regions be ordered with other accesses to that same location?
	(Presumably the answer is "yes", even for accesses to WC MMIO regions, at least for
	completely overlapping updates.
	Otherwise you would get old pixels on your display, after all.)
</ol>

<p>
It is natural to wonder what happens if a given range of MMIO registers
is mapped as write combining at one virtual address and as
uncached (non-write-combining) at some other address.
The answer varies across both architectures and devices, so that
the current Linux-kernel stance is "don't do that" unless
absolutely necessary.

<p>
Regardless of what the answers are, they clearly need to be better
documented.

<h4><a name="Existing Practice">Existing practice</a></h4>

<p>
There are more than 2,000 uses of <tt>writel_relaxed()</tt> and
more than 1,000 uses of <tt>readl_relaxed()</tt>, so existing
practice must be taken into account:  changes might be made, but
not lightly.
Many uses of these primitives are in architecture-specific code, but
there are common-code uses in some drivers.
We took a look at a few of them:

<ul class="spacylist">
<li>	<tt>drivers/ata/ahci_brcmstb.c</tt>:
	This driver uses <tt>brcm_sata_readreg()</tt> and
	<tt>brcm_sata_writereg()</tt> to wrap
	<tt>readl_relaxed()</tt> and <tt>writel_relaxed()</tt>,
	respectively.
	The code appears to expect that relaxed reads and writes
	from/to the same device will be ordered.
<li>	<tt>drivers/crypto/atmel-aes.c</tt>:
	This driver uses <tt>atmel_aes_read()</tt> and
	<tt>atmel_aes_write()</tt> to wrap
	<tt>readl_relaxed()</tt> and <tt>writel_relaxed()</tt>,
	respectively.
	The code appears to expect that relaxed reads and writes
	from/to the same device will be ordered.
<li>	<tt>drivers/crypto/img-hash.c</tt>:
	This driver uses <tt>img_hash_read()</tt> and
	<tt>img_hash_write()</tt> to wrap
	<tt>readl_relaxed()</tt> and <tt>writel_relaxed()</tt>,
	respectively.
	The code appears to expect that relaxed reads and writes
	from/to the same device will be ordered.
<li>	<tt>drivers/crypto/ux500/cryp/cryp.c</tt> appears to expect
	that relaxed reads and writes
	from/to the same device will be ordered.
	At present, this driver does not seem to be used outside of
	ARM, but crypto IP blocks are not necessarily tied to ARM.
</ul>

<p>
Although the bulk of the uses of the relaxed I/O accessors are
confined to one architecture or another, it would not necessarily
be wise to define CPU-family-specific changes to their semantics.
Such changes are likely to cause serious problems should one of the
corresponding hardware IP blocks ever be used by an implementation of
the some other CPU family.

<h4><a name="x86 Implementation">x86 implementation</a></h4>

<p>
The <tt>x86</tt> mapping is as follows:

<table>
<tr><th>API</th>
	<th>Implementation</th>
		<th>Ordering</th></tr>
<tr class="Even"><td><tt>mmiowb()</tt></td>
	<td><tt>barrier()</tt></td>
		<td>Provided by x86 ordering</td></tr>
<tr class="Odd"><td><tt>spin_unlock</tt>()</td>
	<td><tt>arch_spin_unlock()</tt></td>
		<td>Provided by x86 ordering</td></tr>
<tr class="Even"><td><tt>inb()<br>
	    inw()<br>
	    inl()</tt></td>
	<td><tt>inb</tt> instruction<br>
	    <tt>inw</tt> instruction<br>
	    <tt>inl</tt> instruction</td>
		<td>See table below</td></tr>
<tr class="Odd"><td><tt>outb()<br>
	    outw()<br>
	    outl()</tt></td>
	<td><tt>outb</tt> instruction<br>
	    <tt>outw</tt> instruction<br>
	    <tt>outl</tt> instruction</td>
		<td>See table below</td></tr>
<tr class="Even"><td><tt>readb()</tt>, <tt>readb_relaxed()</tt>, <tt>ioread8()<br>
	    readw()</tt>, <tt>readw_relaxed()</tt>, <tt>ioread16()<br>
	    readl()</tt>, <tt>readl_relaxed()</tt>, <tt>ioread32()<br>
	    readq()</tt>, <tt>readq_relaxed()</tt></td>
	<td>MMIO read</td>
		<td>See table below</td></tr>
<tr class="Odd"><td><tt>writeb()</tt>, <tt>writeb_relaxed()</tt>, <tt>iowrite8()<br>
	    writew()</tt>, <tt>writew_relaxed()</tt>, <tt>iowrite16()<br>
	    writel()</tt>, <tt>writel_relaxed()</tt>, <tt>iowrite32()<br>
	    writeq()</tt>, <tt>writeq_relaxed()</tt></td>
	<td>MMIO write</td>
		<td>See table below</td></tr>
</table>

<p>
The <tt>readX()</tt> and <tt>writeX()</tt> definitions are built by
the <tt>build_mmio_read()</tt> and <tt>build_mmio_write()</tt>
macros, respectively.

<p>
The x86 answers to the other questions appear
to be as follows, based on a scan through
"<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel 64 and IA-32 Architectures Software Developer's Manual V3</a>":

<ul class="spacylist">
<li>	What prevents reordering and combining?
	For non-write-combining MMIO regions, everything.
	For write-combining MMIO regions, <tt>mmiowb()</tt>,
	<tt>smp_mb()</tt>, an access to a non-write-combining
	MMIO region, an interrupt, or a locked instruction,
	which is an instruction having the <tt>LOCK</tt> prefix
	that signals that the instruction is to be an atomic
	read-modify-write instruction.
<li>	What operations flush the write buffers?
	The same operations that prevent reordering and combining.
</ul>

<table><tbody>
<tr><th>x86</th>
	<th>Within <tt>ioremap_wc()</tt></th>
		<th>Within <tt>ioremap_nocache()</tt></th>
			<th>Against normal memory</th></tr>
<tr class="Even"><td><tt>_relaxed()</tt></td>
	<td>Unordered, ordered to same location.</td>
		<td>Ordered.</td>
			<td>Ordered.</td></tr>
<tr class="Odd"><td>non-<tt>relaxed()</tt></td>
	<td>Unordered, ordered to same location.</td>
		<td>Ordered.</td>
			<td>See [*] below.</td></tr>
</tbody></table>

<p>
<table><tbody>
<tr><td valign="top">[*]:</td>
	<td>Accesses to <tt>ioremap_wc()</tt>
		memory are not ordered with
		accesses to normal memory unless:
<ol class="spacylist">
		<li>Either there is an intervening <tt>smp_mb()</tt>,
		or
		<li>The normal-memory access uses the <tt>lock</tt>
			prefix, <b>and</b>
		<li>The I/O fabric is "sane" in that
			it avoids reordering and buffering invisible to
			the CPU.
		I/O fabrics that have multiple layers of I/O bus are
		all too often <i>not</i> sane.
</ol>
	</td></tr>
</tbody></table></p>

<div class="tlr"><a name="Quick quiz 5"><b>Quick quiz 5</b>:</a>
But if x86 always uses the same instructions for MMIO, how can the
ordering semantic differ for <tt>ioremap_wc()</tt> and
<tt>ioremap_nocache()</tt> regions?
<br><a href="#qq5answer">Answer</a>
</div>

<p>
To reiterate that last point, note that this all assumes sane hardware.
It is possible to construct x86 systems with I/O bus structures that do not
follow the above rules.
Drivers written for such systems typically need to "confirm"
prior MMIO writes by doing a later MMIO read that either forces ordering
or verifies the state changes caused by the write.
The exact confirmation method will depend on the details of the I/O
device in question.

<p>
On older MTRR-only x86 systems, some frame-buffer drivers must also use
<tt>arch_phys_wc_add()</tt>,
because on such systems <tt>ioremap_wc()</tt> would otherwise
produce an uncached non-write-combining mapping for the corresponding device.
This inability of <tt>ioremap_wc()</tt> to Do The Right Thing can be
due to limited numbers of MTRRs, limited MTRR size, I/O-mapping alignment
constraints, page aliasing (for example, to provide both kernel- and
user-mode access to MMIO registers),
and because some old hardware simply cannot be shoehorned into the nice
new PAT-based Linux-kernel APIs.

<p>
For more details, see commits
<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7d89a3cb159a">"drivers/video/fbdev/atyfb: Use
arch_phys_wc_add() and ioremap_wc()"</a>,
<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f55de6ec375d"</a>"drivers/video/fbdev/atyfb:
Clarify ioremap() base and length used"</a>, and
<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=eacd2d542610"</a>"drivers/video/fbdev/atyfb:
Carve out framebuffer length fudging into a helper"</a>.
Commit <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=3cc2dac5be3f">"drivers/video/fbdev/atyfb: Replace MTRR UC hole with strong UC"</a> is particularly instructive, as it describes how
old hacks were replaced by newer less-hacky hacks based on the new API.

<p>
Those interested in page aliasing should refer to
<a href="https://www.kernel.org/doc/Documentation/ia64/aliasing.txt">Documentation/ia64/aliasing.txt</a>,
particularly the "POTENTIAL ATTRIBUTE ALIASING CASES"
section.
Fortunately, most device manufacturers now dedicate one full
PCI base address register (<a href="http://wiki.osdev.org/PCI#Base_Address_Registers">BAR</a>)
to MMIO and another for frame-buffer use,
which means that developers writing drivers for modern devices can
for the most part simply use the <tt>ioremap_nocache()</tt> and
<tt>ioremap_wc()</tt> APIs.

<p>
One important last note: On x86 systems, spinlock-release primitives
usually use a plain store instruction.
This will not order accesses within <tt>ioremap_wc()</tt> regions.
Although this might seem strange at first glance, it has the advantage
that the effectiveness of write combining is not limited by
<tt>spin_unlock()</tt> invocations.

<h4><a name="ARM64 Implementation">ARM64 implementation</a></h4>

<p>
The <tt>arm64</tt> mapping is as follows:

<table><tbody>
<tr><th>API</th>
	<th>Implementation</th>
		<th>Ordering</th></tr>
<tr class="Even"><td><tt>mmiowb()</tt></td>
	<td>do { } while (0)</td>
		<td>Provided by ARM64 ordering</td></tr>
<tr class="Odd"><td><tt>spin_unlock</tt>()</td>
	<td><tt>arch_spin_unlock()</tt></td>
		<td><tt>llsc</tt> or <tt>lse</tt> instruction</td></tr>
<tr class="Even"><td><tt>readb()</tt>, <tt>ioread8()<br>
	    readw()</tt>, <tt>ioread16()<br>
	    readl()</tt>, <tt>ioread32()<br>
	    readq()</tt></td>
	<td>MMIO read</td>
		<td>Follow MMIO read by <tt>rmb()</tt></td></tr>
<tr class="Odd"><td><tt>writeb()<tt>, </tt>iowrite8()<br>
	    writew()<tt>, </tt>iowrite16()<br>
	    writel()<tt>, </tt>iowrite32()<br>
	    writeq()</tt></td>
	<td>MMIO write</td>
		<td>Precede MMIO write with <tt>wmb()</tt></td></tr>
<tr class="Even"><td><tt>readb_relaxed()<br>
	    readw_relaxed()<br>
	    readl_relaxed()<br>
	    readq_relaxed()</tt></td>
	<td>MMIO read</td>
		<td>See table below</td></tr>
<tr class="Odd"><td><tt>writeb_relaxed()<br>
	    writew_relaxed()<br>
	    writel_relaxed()<br>
	    writeq_relaxed()</tt></td>
	<td>MMIO write</td>
		<td>See table below</td></tr>
</tbody></table>

<p>
Note that although ARM does distinguish between WC and non-WC flavors of
MMIO regions in terms of ordering;
the type of accessor (<tt>_relaxed()</tt> vs. non-<tt>_relaxed()</tt>)
also has a big role to play.
Note that ARM64's non-<tt>_relaxed()</tt> accessors have ordering properties
similar to
<a href="https://en.wikipedia.org/wiki/Processor_consistency#Similarity_to_SPARC_V8_TSO.2C_IBM-370.2C_and_x86-TSO_Memory_Models">total store order</a>
(TSO), that is, they order prior reads
against later reads and writes, and also order prior writes
against later writes, but they do not order prior writes against later reads.

<p>
The ARM64 answers to the questions are
as follows:

<ul class="spacylist">
<li>	What prevents reordering and combining?
	A non-relaxed MMIO access (aside from not ordering prior
	writes against later reads)
	or either <tt>mb()</tt>, <tt>rmb()</tt>, or <tt>wmb()</tt>.
<li>	What operations flush the write buffers for write-combining regions?
	Either <tt>mb()</tt> or <tt>wmb()</tt>.
	But please note that this flushing has effect only within the CPU.
	These memory barrier do not necessarily affect any write buffers
	that might reside on external I/O buses.
</ul>

<table><tbody>
<tr><th>ARM64</th>
	<th>Within <tt>ioremap_wc()</tt></th>
		<th>Within <tt>ioremap_nocache()</tt></th>
			<th>Against normal memory</th></tr>
<tr class="Even"><td><tt>_relaxed()</tt></td>
	<td>Unordered, but fully ordered for accesses to the same address.</td>
		<td>Unordered, but fully ordered for accesses to same
		    device.</td>
			<td>Unordered.</td></tr>
<tr><td>non-<tt>relaxed()</tt></td>
	<td>"TSO", but fully ordered for accesses
	    to the same address.</td>
		<td>"TSO", but fully ordered for
		    accesses to same device.</td>
			<td>See below.</td></tr>
</tbody></table>

<p>
In the above table, "TSO" allows prior writes to be reordered
with later reads, but prevents any other reordering.

<p>
The lower right-hand cell's rules are as follows:

<table><tbody>
<tr><th>Prior Access</th>
	<th>Next Access</th>
		<th>Ordering</th></tr>
<tr class="Even"><td>Non-Relaxed Read</td>
	<td>Plain Read</td>
		<td>Ordered (useful for reading from a DMA buffer).</td></tr>
<tr><td>Non-Relaxed Read</td>
	<td>Plain Write</td>
		<td>Ordered.</td></tr>
<tr class="Even"><td>Non-Relaxed Write</td>
	<td>Plain Read</td>
		<td>Unordered.</td></tr>
<tr><td>Non-Relaxed Write</td>
	<td>Plain Write</td>
		<td>Unordered.</td></tr>
<tr class="Even"><td>Plain Read</td>
	<td>Non-Relaxed Read</td>
		<td>Unordered (departure from TSO).</td></tr>
<tr><td>Plain Read</td>
	<td>Non-Relaxed Write</td>
		<td>Unordered (departure from TSO).</td></tr>
<tr class="Even"><td>Plain Write</td>
	<td>Non-Relaxed Read</td>
		<td>Unordered.</td></tr>
<tr><td>Plain Write</td>
	<td>Non-Relaxed Write</td>
		<td>Ordered (useful for triggering DMA).</td></tr>
</tbody></table>

<p>
Just as with x86,
it is possible to construct ARM systems with I/O bus structures that do not
follow the above rules.
Drivers written for such systems typically need to "confirm"
prior MMIO writes by doing a later MMIO read that either forces ordering
or verifies the writes' state changes.
The exact confirmation method will depend on the details of the I/O
device in question.

<h4><a name="PowerPC Implementation">PowerPC implementation</a></h4>

<p>
Finally, the PowerPC mapping uses an <tt>-&gt;io_sync</tt>
field in the Linux kernel's PowerPC-specific per-CPU data.
This field is set by PowerPC MMIO writes, and tested at unlock time.
If this field is set, the unlock primitive executes a heavyweight
<tt>sync</tt> instruction, which forces the last MMIO write to be
contained within the critical section.

<p>
The mapping is as follows:

<table><tbody>
<tr><th>API</th>
	<th>Implementation</th>
		<th>Ordering</th></tr>
<tr class="Even"><td><tt>mmiowb()</tt></td>
	<td></td>
		<td><tt>sync</tt> and clear <tt>-&gt;io_sync</tt></td></tr>
<tr><td><tt>spin_unlock</tt>()</td>
	<td><tt>arch_spin_unlock()</tt></td>
		<td>If <tt>-&gt;io_sync</tt> set, <tt>sync</tt> and clear <tt>-&gt;io_sync</tt></td></tr>
<tr class="Even"><td><tt>in_8()<br>
	    in_be16()<br>
	    in_be32()<br>
	    in_le16()<br>
	    in_le32()</tt></td>
	<td>MMIO read</td>
		<td><tt>sync</tt> followed by read followed by <tt>twi;isync</tt></td></tr>
<tr><td><tt>out_8()<br>
	    out_be16()<br>
	    out_be32()<br>
	    out_le16()<br>
	    out_le32()</tt></td>
	<td>MMIO write</td>
		<td><tt>sync</tt> followed by write followed by set <tt>-&gt;io_sync</tt></td></tr>
<tr class="Even"><td><tt>readb()</tt>, <tt>inb()</tt>, <tt>ioread8()<br>
	    readw()</tt>, <tt>inw()</tt>, <tt>ioread16()<br>
	    readw_be()</tt>, <tt>ioread16be()<br>
	    readl()</tt>, <tt>inl()</tt>, <tt>ioread32()<br>
	    readl_be()</tt>, <tt>ioread32be()<br>
	    readq()<br>
	    readq_be()</tt></td>
	<td><tt>in_8()<br>
		in_le16()<br>
		in_be16()<br>
		in_le32()<br>
		in_be32()<br>
		in_le64()<br>
		in_be64()</tt></td>
		<td><tt>sync</tt> followed by read followed by <tt>twi;isync</tt></td></tr>
<tr><td><tt>writeb()</tt>, <tt>outb()</tt>, <tt>iowrite8()<br>
	    writew()</tt>, <tt>outw()</tt>, <tt>iowrite16()<br>
	    writew_be()</tt>, <tt>iowrite16be()<br>
	    writel()</tt>, <tt>outl()</tt>, <tt>iowrite32()<br>
	    writel_be()</tt>, <tt>writel_be()<br>
	    writeq()<br>
	    writeq_be()</tt></td>
	<td><tt>out_8()<br>
		out_le16()<br>
		out_be16()<br>
		out_le32()<br>
		out_be32()<br>
		out_le64()<br>
		out_be64()</tt></td>
		<td><tt>sync</tt> followed by write followed by set <tt>-&gt;io_sync</tt></td></tr>
</tbody></table>

<p>
The alert reader will note the duplication of some names in the
"API" and "Implementation" columns, for
example, <tt>in_8()</tt>.
The definitions are in <tt>arch/powerpc/include/asm/io.h</tt> and
<tt>arch/powerpc/include/asm/io-defs.h</tt>.

<p>
Other implementation strategies are possible, of course.
One approach would be for <tt>mmiowb()</tt> and <tt>arch_spin_unlock()</tt>
to both unconditionally execute the <tt>sync</tt> instruction and to
dispense with the <tt>-&gt;io_sync</tt> flag.
Another approach would be to make <tt>mmiowb()</tt> an no-op,
eliminate the test and <tt>sync</tt> instruction from
<tt>arch_spin_unlock()</tt>, and replace setting of <tt>-&gt;io_sync</tt>
by a <tt>sync</tt> instruction.
However, both of these approaches would greatly increase the number of
executions of the expensive <tt>sync</tt> instruction, so, for PowerPC,
the implementation in the above table is preferred.

<p>
Currently (v4.3) PowerPC's <tt>_relaxed()</tt> interfaces operate
exactly the same as do their non-relaxed counterparts.
Part of the motivation for the MMIO discussion during the technical day
at the
<a href="/Articles/KernelSummit2015/">2015 Linux Kernel Summit</a>
was to determine how and
to what extent PowerPC could actually relax the <tt>_relaxed()</tt>
implementations.
However, this article limits itself to documenting current reality.

<p>
The PowerPC answers to the questions appears
to be as follows:

<ul class="spacylist">
<li>	What prevents reordering and combining?
	Any MMIO access, <tt>mmiowb()</tt>, or <tt>smp_mb()</tt>.
	This is not a good thing, as it makes for slow frame buffers.
<li>	What operations flush the write buffers?
	The same operations that prevent reordering and combining.
</ul>

<table><tbody>
<tr><th>PowerPC</th>
	<th>Within <tt>ioremap_wc()</tt></th>
		<th>Within <tt>ioremap_nocache()</tt></th>
			<th>Against normal memory</th></tr>
<tr class="Even"><td><tt>_relaxed()</tt></td>
	<td>Fully Ordered.</td>
		<td>Fully Ordered.</td>
			<td>Fully Ordered.</td></tr>
<tr><td>non-<tt>relaxed()</tt></td>
	<td>Fully Ordered.</td>
		<td>Fully Ordered.</td>
			<td>Fully Ordered.</td></tr>
</tbody></table>

<h4><a name="Summary and Conclusions">Summary and conclusions</a></h4>

<p>
MMIO should be thought of as a message-passing mechanism that communicates
with hardware rather than a variant of normal memory.
As such, MMIO is not only device-specific, but also specific to the
hardware path between the CPU and the device.
In the general case, which includes ill-considered hardware designs,
even memory barriers cannot always order accesses:
in some cases, the device's state must be polled to determine when
a prior access has completed.

<p>
Nevertheless, the Linux kernel offers a rich set of primitives with
which to interact with MMIO devices, and this article has given a
brief overview of how they work and how they may be used.

<h4><a name="Acknowledgments">Acknowledgments</a></h4>

We are grateful to Michael Ellerman, Gautham Shenoy,
Peter Zijlstra, Andy Lutomirski, and Boqun Feng
for their review and comments.
We owe thanks to Toshimitsu Kani, Dave Airlie, Christoph Hellwig,
and Matt Fleming for a number of important discussions,
and to Jim Wasko for his support of this effort.

<h4><a name="Answers to Quick quizzes">
Answers to Quick quizzes</a></h4>

<a name="qq1answer"></a>
<p><b>Quick quiz 1</b>:
Why can't the device make use of the full address?


</p><p><b>Answer</b>:
Because part of the address is used to select the device.


</p><p><a href="#Quick%20quiz%201"><b>Back to Quick quiz 1</b>.</a>

<a name="qq2answer"></a>
<p><b>Quick quiz 2</b>:
Can you set up UC access to normal (non-MMIO) RAM?


</p><p><b>Answer</b>:
You can, and this is in fact actually used for GPU memory for GPUs
that cannot snoop the CPU caches.
One example may be found in <tt>ati_create_page_map()</tt>, which
uses <tt>__get_free_page()</tt> to allocate a page of DRAM and then
later uses <tt>set_memory_uc()</tt> to change the cache attribute.
There is also a <tt>set_memory_wc()</tt>.
Although <tt>set_memory_uc()</tt> and <tt>set_memory_wc()</tt> may
also be used to set up MMIO, such use is likely to be strongly
discouraged.
In addition, it is quite possible that the <tt>set_memory_uc()</tt> and
<tt>set_memory_wc()</tt> APIs will change.


</p><p><a href="#Quick%20quiz%202"><b>Back to Quick quiz 2</b>.</a>

<a name="qq3answer"></a>
<p><b>Quick quiz 3</b>:
What do weakly ordered systems do to enforce this ordering?


</p><p><b>Answer</b>:
They enforce this ordering by a combination of hardware and software
ordering constraints.
Please read on for more information, leading up to descriptions of the
ARM64
and the
PowerPC
implementations.


</p><p><a href="#Quick%20quiz%203"><b>Back to Quick quiz 3</b>.</a>

<a name="qq4answer"></a>
<p><b>Quick quiz 4</b>:
Why can't <tt>mmiowb()</tt> be used with <tt>writel()</tt>?


</p><p><b>Answer</b>:
Actually, they really can be used together.
But there is little point in doing so because <tt>writel()</tt>
already provides strong ordering.
Therefore, placing an <tt>mmiowb()</tt> after a <tt>writel()</tt>
has no effect other than to slow things down.

<p>
Of course, in this case it would be simpler to just use
<tt>writel()</tt> instead of both <tt>writel_relaxed()</tt> and
<tt>mmiowb()</tt>.
However, <tt>mmiowb()</tt> is quite useful when there are multiple
<tt>writel_relaxed()</tt>, all of which need to be contained within
the critical section.
A single <tt>mmiowb()</tt> placed between the last <tt>writel_relaxed()</tt>
and the unlock
will contain all of them, and with the added memory-barrier overhead
incurred only once at <tt>mmiowb()</tt> time instead of once for each
and every <tt>writel()</tt>.


</p><p><a href="#Quick%20quiz%204"><b>Back to Quick quiz 4</b>.</a>

<a name="qq5answer"></a>
<p><b>Quick quiz 5</b>:
But if x86 always uses the same instructions for MMIO, how can the
ordering semantic differ for <tt>ioremap_wc()</tt> and
<tt>ioremap_nocache()</tt> regions?


</p><p><b>Answer</b>:
Because the ordering is controlled not by the instructions, but rather
by the MTRR settings (in older systems) or by PAT (in newer systems).


</p><p><a href="#Quick%20quiz%205"><b>Back to Quick quiz 5</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Device_drivers-Support_APIs">Device drivers/Support APIs</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Deacon_Will">Deacon, Will</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Rodriguez_Luis_R.">Rodriguez, Luis R.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/698014/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor698198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Semantics of MMIO mapping attributes across architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2016 5:43 UTC (Thu)
                               by <b>ruscur</b> (guest, #104891)
                              [<a href="/Articles/698198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Terrific article, thanks.  Clarified a lot of things for me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/698198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor698595"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Semantics of MMIO mapping attributes across architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2016 7:23 UTC (Tue)
                               by <b>lpremoli</b> (guest, #94065)
                              [<a href="/Articles/698595/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great article, thank you!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/698595/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor699045"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Semantics of MMIO mapping attributes across architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2016 6:35 UTC (Fri)
                               by <b>yinghaoxie</b> (guest, #110979)
                              [<a href="/Articles/699045/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
article with quiz .. yeah it's "Paul E. McKenney" style .<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/699045/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor770591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Semantics of MMIO mapping attributes across architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2018 15:46 UTC (Sat)
                               by <b>matthijs</b> (guest, #128389)
                              [<a href="/Articles/770591/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Weakly ordered systems must therefore insert whatever memory barriers are required to enforce this ordering."<br>
<p>
Good luck with that, no such barrier exists on any ARM-based SoC I'm familiar with. You can easily force in-flight writes to land by doing a read to the same device, but there's no way to do this globally for writes to all devices.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2016, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
