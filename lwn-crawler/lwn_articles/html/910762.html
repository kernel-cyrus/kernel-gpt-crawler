        <!DOCTYPE html>
        <html lang="en">
        <head><title>A first look at Rust in the 6.1 kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/910762/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/911047/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/910762/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A first look at Rust in the 6.1 kernel</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 13, 2022</br>
           </div>
There have been a lot of significant changes merged into the mainline for
the 6.1 release, but one of the changes that has received the most
attention will also have the least short-term effect for users of the
kernel: the introduction of support for the Rust programming language.  No
system with a production 6.1 kernel will be running any Rust code, but this
change does give kernel developers a chance to play with the language in
the kernel context and get a sense for how Rust development feels.  Perhaps
the most likely conclusion for most developers, though, will be that there
isn't yet enough Rust in the kernel to do much of anything interesting.
<p>
Work on Rust for the Linux kernel has been going on for a few years, and it
has resulted in the creation of a lot of support code and <a
href="/Articles/907685/">some interesting drivers</a> to look at.  There
are other initiatives underway, including the writing of <a
href="/ml/rust-for-linux/70657af9-90bb-ee9e-4877-df4b14c134a5@asahilina.net/">an
Apple graphics driver</a> in the Rust language.  For the initial merge into
the mainline kernel, though, Linus Torvalds <a
href="/Articles/908347/">made it clear</a> that as little functionality as
possible should be included.  So those drivers and their support code were
trimmed out and must wait for a future kernel release.
What <i>is</i> there is the support needed to build a module that can be
loaded into the kernel, along with a small sample module.
<p>
<h4>Building Rust support</h4>
<p>
The first
challenge that interested developers will run into is actually building
that support.  The kernel configuration process looks for the prerequisites
on the build system and, if they are not present, silently disables the
Rust options so that they will not even show in, for example,
<tt>make&nbsp;menuconfig</tt>.  Your editor, despite having Rust installed
on the system in question, ran into this and was thus forced into the
ignominious process of actually reading <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/rust/quick-start.rst">the
documentation</a> to figure out what was missing.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
Building the Rust support requires specific versions of the Rust compiler
and bindgen utility — specifically, Rust 1.62.0 and bindgen 0.56.0.  If the
target system has newer versions, the configuration process will emit
warnings but will proceed anyway.  More awkwardly for anybody who is trying
to do the 
build with the Rust toolchain provided by their distributor, the build
process also needs the Rust standard library source so that it can build
its own version of the <tt>core</tt> and <tt>alloc</tt> crates.  Until
distributors start shipping "Rust for the kernel" packages, getting that code
into a place where the build process will find it will be a bit awkward.

<p>
The way to easily obtain that dependency is to throw in the towel, drop the
distributor's toolchain, and install everything from the Rust repositories
instead.  The <a href="https://www.rust-lang.org/learn/get-started">"getting
started" page</a> describes how to do this; inevitably, it involves one of
those confidence-building "<tt>curl|bash</tt>" operations.  The installer
is entirely uninterested in <i>where</i> one might like one's Rust stuff
installed (it goes into <tt>~/.cargo</tt>) and silently modifies the user's
Bash startup scripts to add the new directory into the <tt>PATH</tt>
variable.  The end result does work, though, and makes it easy to install
the needed dependencies.
<p>
<h4>The sample module</h4>
<p>
Once that is done, the kernel configuration system will consent to set the
<tt>CONFIG_RUST</tt> option; an additional option will build the sample
module.  That module (<a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/samples/rust/rust_minimal.rs"><tt>samples/rust/rust_minimal.rs</tt></a>)
is minimal indeed, but it is enough to get a sense for what kernel code in
Rust will look like.  It starts with the Rust equivalent of a
<tt>#include</tt> line:
<p>
<pre>
    use kernel::prelude::*;
</pre>
<p>
The pulls in the declarations found in <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/rust/kernel/prelude.rs"><tt>rust/kernel/prelude.rs</tt></a>,
making a few types, functions, and macros available.
<p>
A kernel module written in C includes a number of calls to macros like
<tt>MODULE_DESCRIPTION()</tt> and <tt>MODULE_LICENSE()</tt> that stash
metadata about the module in a separate ELF section.  The
<tt>module_init()</tt> and
<tt>module_exit()</tt> macros identify the module's constructor and
destructor functions, respectively.  The Rust equivalent puts much of that
boilerplate into a single macro call:
<p>
<pre>
    module! {
        type: RustMinimal,
        name: b"rust_minimal",
        author: b"Rust for Linux Contributors",
        description: b"Rust minimal sample",
        license: b"GPL",
    }
</pre>
<p>
This macro is fussy about the ordering of the various fields and will
complain if the developer gets that wrong.
Beyond putting all of this information into a single call, the
<tt>module!</tt> macro
includes a <tt>type:</tt> entry which will be the pointer to the actual
module code.  The developer will be expected to supply a type that does
something interesting.  In the sample module, that type looks like this:
<p>
<pre>
    struct RustMinimal {
        numbers: Vec&lt;i32&gt;,
    }
</pre>
<p>
It is a simple structure containing a <tt>Vec</tt> (an array, more or less)
of 32-bit integer values.  That's pretty boring on its own, but Rust then
allows the addition of interface ("trait") implementations to a structure
type.  So the sample module implements the <tt>kernel::Module</tt> trait
for the <tt>RustMinimal</tt> type:
<p>
<pre>
    impl kernel::Module for RustMinimal {
        fn init(_module: &amp;'static ThisModule) -&gt; Result&lt;Self&gt; {
            pr_info!("Rust minimal sample (init)\n");
            pr_info!("Am I built-in? {}\n", !cfg!(MODULE));
    
            let mut numbers = Vec::new();
            numbers.try_push(72)?;
            numbers.try_push(108)?;
            numbers.try_push(200)?;

            Ok(RustMinimal { numbers })
        }
    }
</pre>
<p>

The <tt>init()</tt> function is expected to do the usual module
initialization work.  In this case, it babbles a bit to the system log
(showing off in the process the <tt>cfg!()</tt> macro that can be used to
query kernel-configuration parameters at compile time).  It then allocates
a mutable <tt>Vec</tt> and attempts to put three numbers into it.  The use
of <tt>try_push()</tt> is important here: a <tt>Vec</tt> will resize
itself when necessary.  That involves allocating memory, which can fail in
the kernel environment.  Should that allocation fail, <tt>try_push()</tt>
will return a failure status and that, in turn, will cause <tt>init()</tt>
to return failure (that is what the "<tt>?</tt>" at the end of the line
does).
<p>
Finally, if all goes well, it returns a <tt>RustMinimal</tt> structure with
the allocated <tt>Vec</tt> and a success status.  Since this module has not
interacted with any other kernel subsystems, it won't actually do anything
other than wait patiently to be removed.  There isn't a function for module
removal 
in the <tt>Kernel::Module</tt> trait; instead, a simple destructor for the
<tt>RustMinimal</tt> type is used:
<p>
<pre>
    impl Drop for RustMinimal {
        fn drop(&amp;mut self) {
            pr_info!("My numbers are {:?}\n", self.numbers);
            pr_info!("Rust minimal sample (exit)\n");
        }
    }
</pre>
<p>
This function prints out the numbers that were stored in the <tt>Vec</tt> at
initialization time (thus confirming that the data survived in
meantime) and returns; after that, the module will be removed and its
memory freed.  There does not appear to be a way for module removal to
fail — which occasionally needs to happen in real-world modules.
<p>
<h4>Beyond "hello world"</h4>
<p>
That is, to a first approximation, the extent of what can be done with Rust
kernel modules in 6.1.  Torvalds asked for something that could do "hello
world" and that is what we got.  It is something that can be played with,
but it cannot be used for any sort of real kernel programming at this
point.
<p>
That situation will, hopefully, change in the near future.  The next step
for the Rust-for-Linux developers will be to start adding some of the
infrastructure they have created to interface with other kernel subsystems.
That will allow for the writing of some real kernel code and, just as
importantly, show what the abstractions needed to work with other kernel
subsystems will look like.  This needs to happen soon; Rust in the kernel
has some momentum now, but that could be lost if it remains limited to
printing kernel log messages for any period of time.  With luck, Rust in
the 6.2 kernel will be significantly more capable.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.1">Releases/6.1</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/910762/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor911064"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 14:57 UTC (Thu)
                               by <b>kees</b> (subscriber, #27264)
                              [<a href="/Articles/911064/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C kernel module removal cannot fail either:<br>
<p>
include/linux/init.h:typedef void (*exitcall_t)(void);<br>
<p>
Real-world module exiting is controlled via the mount usage count -- it's only callable if the count is zero.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911064/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor911085"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 19:04 UTC (Thu)
                               by <b>xi0n</b> (subscriber, #138144)
                              [<a href="/Articles/911085/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; it involves one of those confidence-building "curl|bash" operations</font><br>
<p>
If all that's needed is rustup, it should be possible to get it from your distro's package manager, through the usual `apt install rustup` or similar. Particular Rust toolchains, including 1.62 to build the Rust kernel modules, could then be installed from rust-lang.org using that distro-installed rustup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911085/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 21:35 UTC (Thu)
                               by <b>sigma914</b> (subscriber, #98227)
                              [<a href="/Articles/911094/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is exactly how most people I know install rustup, unless they're on Debian where the exact way they want it packaged is still under discussion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor911088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 20:21 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/911088/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The "getting started" page describes how to do this; inevitably, it involves one of those confidence-building "curl|bash" operations. The installer is entirely uninterested in where one might like one's Rust stuff installed (it goes into ~/.cargo) and silently modifies the user's Bash startup scripts to add the new directory into the PATH variable. The end result does work, though, and makes it easy to install the needed dependencies. </font><br>
<p>
Note that it is possible to get a `rustup` that doesn't muck about with one's setup. It does mean doing `curl -O` instead of `| bash` (or did when I set things up years ago; it gets rsync'd around on machine initialization now as it is self-contained at least) and some light editing to neuter global `PATH` editing and rerooting to `~/misc/root/rustup` (for myself). But it isn't a forced treadmill.<br>
<p>
<font class="QuotedText">&gt; The kernel configuration process looks for the prerequisites on the build system and, if they are not present, silently disables the Rust options so that they will not even show in, for example, make menuconfig.</font><br>
<p>
Ugh, I hate this pattern. I've found "let the user request what they want" and "error if not satisfiable" to be a far better behavior because having a configure line that says `--enable-frobnitz` which turns itself off if it doesn't find the obscure `quuxness` dependency is a wonderful way to frustrate build script authors as new dependencies get added because "it worked last week".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911119"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 8:32 UTC (Fri)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/911119/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's no `--enable-frobnitz` switch that gets silently turned off in kernel builds.<br>
IMHO It's just silly to ask the user about enabling a feature that doesn't make sense for his system, or can't be built anyway. And what about "allmodconfig" build tests and CI?<br>
We already have close to 20000 config symbols, no need to bother users with the useless ones.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911119/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 13:13 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/911125/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What happens if I have a config file that specifies "please enable Rust support" on a machine without the prereqs? Is there some notification that I'm not getting the kernel I asked for?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 13:22 UTC (Fri)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/911131/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In that case the Rust support will be disabled silently.<br>
This behaves the same as when using a config file that has compiler-dependent support enabled which is not supported by your compiler (e.g. UBSAN_TRAP, see `git grep "\$(" -- "*Kconf*"' for more).<br>
<p>
I guess that's fair enough for an experimental feature that is not yet supported on all architectures?<br>
<p>
Note that personally, I never run "make oldconfig", but always use my "linux-oldconfig" script, which prints a diff of all changes between the old and the new config file.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor911323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2022 15:47 UTC (Sun)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/911323/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust is a config-time check so I guess it'd be exactly the same as other toolchain probing: you can see the effect if you do `make LLVM=1 oldconfig`; it pops up a bunch of new clang-specific questions but the old gcc-plugin ones silently vanish without warning, and vice versa.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor911398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 17, 2022 7:44 UTC (Mon)
                               by <b>mkubecek</b> (guest, #130791)
                              [<a href="/Articles/911398/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; IMHO It's just silly to ask the user about enabling a feature that doesn't make sense for his system, or can't be built anyway.</font><br>
<p>
This logic makes sense for people who are configuring, building and running the kernel on the same system which is mostly kernel developers. For all others - i.e. vast majority - kernel is usually configured on one system, built on another and used on many different. For that use case, the old approach (resolving unusable config options at build time) made more sense than current one (resolving at configure time). To emulate the old approach, one can use the "dummy toolchain", set of scripts in scripts/dummy-tools/ which pretend to be gcc, linker etc. capable of everything needed. People configuring distribution kernels then run "make CROSS_COMPILE=scripts/dummy-tools/ oldconfig" to get reproducible config which works as a superset of what will be actually built. So the solution here would be providing a dummy rust compiler and everything else that is needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor911095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 21:38 UTC (Thu)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/911095/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A small clarification: the Drop implementation is totally optional. In this example you clearly see it does nothing of value except printing logs; you could just omit it, the compiler will generate the necessary code for you (here, it will free the memory allocated for the numbers as well as properly finalizing the module).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor911099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 22:17 UTC (Thu)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/911099/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm curious about the stability of rust's toolchain for kernel development. Does what has been merged still use unstable features? Or can you actually compile on stable rust 1.62.0? If no, are there any plans on how will the rust version support looks like? 1.62.0 forever? Or on other side of something like only latest and latest - 1?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 23:06 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/911103/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, Rust for Linux needs some unstable features. Rust for Linux tracks what is needed, since it is their long term goal that this will become unnecessary: <a href="https://github.com/Rust-for-Linux/linux/issues/2">https://github.com/Rust-for-Linux/linux/issues/2</a><br>
<p>
Note that - while this is not a supported configuration - the stable Rust compiler is technically quite capable of compiling code using the unstable features which existed when it shipped, as this is exactly how it builds itself and its standard library both of which of course use unstable features. So in principle Rust for Linux could advise builders to use the stable Rust compiler, but just tell it to pretend it isn't a stable Rust compiler (one environment variable change), so as to take advantage of any QA benefits as presumably your distribution's stable Rust 1.62 compiler was actually tested while some random nightly (which has unstable features since it wasn't supported anyway) is not tested.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2022 23:55 UTC (Thu)
                               by <b>Gaelan</b> (guest, #145108)
                              [<a href="/Articles/911106/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So in principle Rust for Linux could advise builders to use the stable Rust compiler, but just tell it to pretend it isn't a stable Rust compiler (one environment variable change), so as to take advantage of any QA benefits as presumably your distribution's stable Rust 1.62 compiler was actually tested while some random nightly (which has unstable features since it wasn't supported anyway) is not tested.</font><br>
<p>
This is exactly what's being done.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor911110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 1:14 UTC (Fri)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/911110/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There does not appear to be a way for module removal to fail — which occasionally needs to happen in real-world modules.</font><br>
<p>
Why should releasing resources ever fail? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 4:21 UTC (Fri)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/911112/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Eg if it is in use by some other module? (Not sure whether that is what the article means)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 16:58 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/911198/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In general (not specific to the kernel), that is never supposed to happen. By the time drop() gets called, your object should not be owned by anyone and nobody should have any outstanding references to it, or else the borrow checker has not done its job correctly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 18:49 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/911208/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; or else the borrow checker has not done its job correctly.</font><br>
<p>
(Or, more prosaically, someone has violated the safety rules in an unsafe block or in native C code or something along those lines. "Unsafe" doesn't mean "I can do whatever I want," it means "the compiler isn't checking everything here, so I have to be careful.")<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor911230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 23:41 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/911230/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In particular, although core::ops::Drop::drop(&amp;mut self) *looks* like a pretty ordinary safe trait function it is actually magic the compiler cares about - Rust calls such magic a "langitem" as in "language item". If you made your own my::Drop trait with a drop(&amp;mut self) function anybody can implement that on their types if they want, and anybody can call that drop() method on values of those types, yet it won't de-allocate anything, won't happen automatically, it just has a misleading name, like the artwork "An Oak Tree". But the langitem deliberately cannot be called by people explicitly (that's a compile error), and it will get called automatically by the language when items of that type are about to be destroyed.<br>
<p>
So logically this code happens because the kernel is destroying this value, if Linux actually keeps the value alive that's a kernel bug, it's logically OK if the kernel can't or won't clean up the RAM used for the module, but it definitely can't expect that the Vec still works for example since Rust will have recursively called Drop::drop on the Vec inside this type (and so on) and the Vec is presumably delegating to some kernel allocator to get suitable blocks of memory which it will then give back when destroyed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor911118"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 8:13 UTC (Fri)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/911118/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
rustup's behavior of modifying your startup scripts is not quite "silent".  When you run the curl | sh, you get a pretty clear explanation:<br>
<p>
<font class="QuotedText">&gt; This path will then be added to your PATH environment variable by</font><br>
<font class="QuotedText">&gt; modifying the profile files located at:</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt;   /home/comex/.profile</font><br>
<font class="QuotedText">&gt;   /home/comex/.bashrc</font><br>
<font class="QuotedText">&gt;   /home/comex/.zshenv</font><br>
<p>
It then gives you options to confirm or customize, and one of the options to customize is whether to modify the startup scripts.<br>
<p>
To be fair, this is only one part of a wall of text, so it's easy to skip past… but the rest of the text is pretty useful as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911118/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor911127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 12:00 UTC (Fri)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/911127/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a Rust lover I want to see the ability to build a kernel module with minimal amount of kernel stuff. If I need to put few bits into GPIO and create few entries for /sys, why should I dive deep into kernel build details?<br>
<p>
I really like to see a way to run 'cargo build' and to build a 'plain boring' module for the kernel.<br>
<p>
I know, the thing I ask is selfish, but those selfish moments are actually breakthroughs. 'You can build a kernel module within this reasonable kernel framework and do not think about whole complexity of the magic behind the curtain'. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 13:39 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/911134/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I know, the thing I ask is selfish, but those selfish moments are actually breakthroughs. 'You can build a kernel module within this reasonable kernel framework and do not think about whole complexity of the magic behind the curtain'.</font>

<p>Note that the whole reason Rust is merged into the kernel <b>now</b> is specifically because something like that is just not possible. <a href="https://github.com/torvalds/linux/blob/master/Documentation/process/stable-api-nonsense.rst">Kernel is very explicit and vocal about that</a>: all kernel APIs are unstable and there are no stability guarantees.</p>

<font class="QuotedText">&gt; If I need to put few bits into GPIO and create few entries for /sys, why should I dive deep into kernel build details?</font>

<p>If your needs are so modest then why do you even need kernel driver in the first place? Linux <a href="https://embeddedbits.org/new-linux-kernel-gpio-user-space-interface/">have GPIO API</a> and you can do everything without needing to write any drivers.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/911134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2022 8:15 UTC (Sat)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/911252/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Kernel is very explicit and vocal about that: all kernel APIs are unstable and there are no stability guarantees.</font><br>
<p>
I understand, that things like removal of the global kernel lock are huge and can not be supported by any 'shim' between driver and the kernel, but for most changes, may be, there is a way to have 'all-knowing' framework with zero-cost (i.e. compile time) transformations which allow to use the same (driver) code for different kernels.<br>
<p>
There is 'rkyv' zero-cost serialization/deserialization framework, which allow to work with external data without converting it. There is simple memory dump/load, and the serialization magic happens through careful memory layout of the data, orchestrated between all parties at compile time.<br>
<p>
I expect something like that from this imaginary framework. Driver code is the same for different kernels, framework knows all of kernels, actual binary representation changes wildly accordingly for kernel whims.<br>
<p>
The main motivation (the way I feel it) is to remove amount of nuances needed to know to write a driver. With C this is a pipe dream, but with Rust pedantism and expressiveness throuh indirect (like asking for &amp;Borrow&lt;Q&gt; instead of &amp;reference, with implementation details left to a type), may be there is a hope.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2022 19:17 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/911280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Have you you actually read the <a href="https://github.com/torvalds/linux/blob/master/Documentation/process/stable-api-nonsense.rst">stable-api-nonsense</a>?</p>

<p>It's summary is telling enough: <i> You think you want a stable kernel interface, but you really do not, and you don't even know it… what you want is a stable running driver, and you get that <b>only</b> if your driver is in the main kernel tree</i> (emphasis mine).</p>

<font class="QuotedText">&gt; With C this is a pipe dream, but with Rust pedantism and expressiveness throuh indirect (like asking for &amp;Borrow&lt;Q&gt; instead of &amp;reference, with implementation details left to a type), may be there is a hope.</font>

<p>C is not an issue. Both Solaris and Windows use C for their stable API for drivers but both face the same issue: once per few years some radical change in the hardware organization necessitates something radical which is not possible to provide without breaking APIs. Be it big kernel lock, addition of <a href="https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit">IOMMU</a> or bazillion other radical changes.</p>

<p>At that point old driver model becomes broken anyway and you need to rewrite your driver anyway.</p>

<p>Instead of trying to deal with it in Solaris/Window fashion (there are many “driver models”, kernel supports few recent ones and obsoletes very old ones slowly) Linux uses different approach, <a href="https://web.archive.org/web/20170615060422/https://www.apple.com/hotnews/thoughts-on-flash/">Apple-style</a>: <i>we want to provide the most advanced and innovative platform to our developers, and we want them to stand directly on the shoulders of this platform</i>.</p>

<p>I think this message <a href="https://lwn.net/1999/0211/a/lt-binary.html">from years where Linus was not sugar-coating his words</a> explains situation even more clearly:<br></br> <i>I <b>want</b> people to expect that interfaces change. I <b>want</b> people to know that binary-only modules cannot be used from release to release. I want people to be really really REALLY aware of the fact that when they use a binary-only module, they tie their hands.<br></br>
Note that this point is mainly psychological, but it's by far the most important one.<br></br>
Basically, I want people to know that when they use binary-only modules, it's THEIR problem.  I want people to know that in their bones, and I want it shouted out from the rooftops.  I want people to wake up in a cold sweat every once in a while if they use binary-only modules.</i></p>

<p>There are no compatibility layer which you hope to get from Rust not because of C deficiency but because kernel developers actively don't want to have it. And if they don't want want to have it then it wouldn't exist.</p>

<p>How can Rust language properties may affect that?</p>

<font class="QuotedText">&gt; I expect something like that from this imaginary framework. Driver code is the same for different kernels, framework knows all of kernels, actual binary representation changes wildly accordingly for kernel whims.</font>

<p>And what would happen when that magic would, finally, be stretched too far and fail? <b>That</b> is what Linus fights against:<br></br>
<i>Because I <b>know</b> that I will eventually make changes that break modules. And I want people to expect them, and I never EVER want to see an email in my mailbox that says "Damn you, Linus, I used this binary module for over two years, and it worked perfectly across 150 kernel releases, and Linux-5.6.71 broke it, and you had better fix your kernel".<br></br>
See?</i></p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/911280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor911170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 14:25 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/911170/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As a Rust lover I want to see the ability to build a kernel module with minimal amount of kernel stuff. If I need to put few bits into GPIO and create few entries for /sys, why should I dive deep into kernel build details?</font><br>
<p>
Because, unfortunately, the kernel build system is over 30 years old, a mess, and has accumulated masses of technical debt? From what I've heard, that's not much of an exaggeration, if any ... and fair a few people have tried to fix it with varying degrees of success, but not really that much.<br>
<p>
Sounds like you're not volunteering to make it easy for others to do what you want to do ...<br>
<p>
I wish we had a simple "what hardware do you have" style config that you could just say "this is my processor, this is my mobo, these are my add-in cards", and it configured everything for you. The feedback I've got basically is "you'll need to rewrite pretty much everything ...". I hope things have improved, but I doubt it ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2022 18:41 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/911205/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This really isn't true. Depending what you're complaining about, Kconfig is twenty years old, not thirty. Roman Zippel rewrote it in 2002. The Makefiles were moved to their current declarative syntax around 2000. There are regular updates to the build system, including an active maintainer.<br>
<p>
In summary, you have no idea what you're talking about.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor911236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2022 2:23 UTC (Sat)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/911236/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is what we were doing with the predecessor project, more or less: <a href="https://github.com/fishinabarrel/linux-kernel-module-rust">https://github.com/fishinabarrel/linux-kernel-module-rust</a><br>
<p>
It's not quite "cargo build" because there are some kernel-specific postprocessing steps to get a .ko that Cargo doesn't quite know how to do. (There's also some preprocessing that's theoretically doable in a build.rs but easier if you set up Cargo to be called from the kernel Makefiles.) But you could copy the scaffolding from the hello-world directory - Makefile, Kbuild, and Cargo.toml - and get something that worked.<br>
<p>
It's probably a good time to document how to do out-of-tree modules in Rust using the in-tree build support, because that's a lot easier for someone who wants to get started on their current running system.<br>
<p>
I don't see a way around the Kbuild file, though... but perhaps one could write a "cargo kbuild" subcommand that dynamically generates it and lets you keep your project using Cargo-style layout, to keep things familiar for people who know userspace Rust and not kernel Makefiles.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor911295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2022 7:43 UTC (Sun)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/911295/">Link</a>] 
      </p>
      
      </div>
      </summary>
      About that Apple graphics driver... here's the writer's (Asahi Lina's) <a href="https://twitter.com/LinaAsahi/status/1577667445719912450">tweet thread</a> on her experience with using Rust. Sample quotes
<blockquote>it's way more useful than I could've ever imagined! I went from 1st render to a stable desktop that can run run games, browsers, etc. in about two days of work on my driver (!!!)
</blockquote>
<blockquote>There is absolutely no way I wouldn't have run into race conditions, UAFs, memory leaks, and all kinds of badness if I'd been writing this in C.
<p>
In Rust? Just some logic bugs and some core memory management issues. Once those were fixed, the rest of the driver just worked!!
</blockquote>
<blockquote>I actually spent more time tracking down a single forgotten `*` in the DCP driver (written in C by Alyssa and Janne, already tested) that was causing heap overflows than I spent tracking down CPU-side safety issues (in unsafe code) in Rust on my brand new driver, in total.
</blockquote>
Also of note: she and Alyssa Rosenzweig <a href="https://twitter.com/LinaAsahi/status/1577388725931167744">used</a> this Rust driver (and Alyssa's kernel driver) on an M1 Mac Mini that they used to present their talk at XDC2022. 
<p>
So, while the mainline kernel part may be rudimentary, useful drivers seem already to be here, and more important, there are some who find the environment useful in developing drivers.




      
          <div class="CommentReplyButton">
            <form action="/Articles/911295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor911340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2022 18:50 UTC (Sun)
                               by <b>ceplm</b> (subscriber, #41334)
                              [<a href="/Articles/911340/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wasn’t the kernel quite GCC-centric? How does it work when GCC for Rust is still mostly non-existent?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor911405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 17, 2022 8:42 UTC (Mon)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/911405/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The kernel has been buildable with LLVM clang for quite some time. Android, among others, builds it with clang. From the rust docs linked above, LLVM is recommended for building kernels with rust support: "Using GCC also works for some configurations, but it is very experimental at the moment."<br>
<p>
But in any case, the question is of linking code compiled with gcc with objects compiled with clang or something else. In general, this is possible. The kernel may have special difficulties.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor911905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A first look at Rust in the 6.1 kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 20, 2022 15:52 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/911905/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The first challenge that interested developers will run into is actually building that support. The kernel configuration process looks for the prerequisites on the build system and, if they are not present, silently disables the Rust options so that they will not even show in, for example, make menuconfig.</font><br>
<p>
I've seen options (in older parts of the code, can't remember which) that display a line of informational text in the menu when the normal option is unselectable due to a non-adjacent thing. Perhaps that ought to be a generalised mechanism, because it could've saved me an hour or two of stumbling around trying to figure out how the LLVM LTO feature worked.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/911905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
