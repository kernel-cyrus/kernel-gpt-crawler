        <!DOCTYPE html>
        <html lang="en">
        <head><title>Ghosts of Unix past, part 3: Unfixable designs [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/414618/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/414815/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/414618/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Ghosts of Unix past, part 3: Unfixable designs</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="GAByline">
           <p>November 16, 2010</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>
In <a href="/Articles/412131/">the second installment</a> of this series, we documented two designs that
were found to be imperfect and have largely (though not completely)
been fixed through ongoing development.  Though there was some
evidence that the result was not as elegant as we might have achieved
had the original mistakes not been made, it appears that the current
design is at least adequate and on a path towards being good.
</p><p>
However, there are some designs mistakes that are not so easily
corrected.  Sometimes a design is of such a character that fixing it
is never going to produce something usable.  In such cases it can be
argued that the best way forward is to stop using the old design and
to create something completely different that meets the same need.

In this episode we will explore two designs in Unix which have seen
multiple attempts at fixes but for which it isn't clear that the result
is even heading towards "good".  In one case a significant change in
approach has produced a design which is both simpler and more functional
than the original.  In the other case, we are still waiting for a
suitable replacement to emerge.

After exploring these two "unfixable designs" we will try to address the
question of how to distinguish an unfixable design from a poor design
which can, as we saw last time, be fixed.
</p>
<h4>Unix signals</h4>
<p>
Our first unfixable design involves the delivery of
signals to processes. In particular it is the registration of a
function as a "signal handler" which gets called asynchronously when
the signal is delivered.

That this design was in some way broken is clear from the fact that
the developers at UCB (The University of California at Berkeley, home
of BSD Unix) found the need to introduce the <tt>sigvec()</tt> system
call, along with a few other calls, to allow individual signals to be
temporarily blocked.  They also changed the semantics of some system
calls so that they would restart rather than abort if a signal arrived
while the system call was active.
</p><p>
It seems there were two particular problems that these changes tried
to address.

Firstly there is the question of when to re-arm a signal handler.  In
the original Unix design a signal handler was one-shot -  it would only
respond the first time a signal arrived.  If you wanted to catch a
subsequent signal you would need to make the signal handler explicitly
re-enable itself.  This can lead to races, such as, if a signal is delivered
before the signal handler is re-enabled it can be lost forever.
Closing these races involved creating a facility for keeping the
signal handler always available, and blocking new deliveries while the
signal was being processed.
</p><p>
The other problem involves exactly what to do if a signal arrives
while a system call is active.  Options include waiting for the system
call to complete, aborting it completely, allowing it to return
partial results, or allowing it to restart after the signal has been
handled.  Each of these can be the right answer in different contexts;
<tt>sigvec()</tt> tried to provide more control so the programmer
could choose between them.
</p><p>
Even these changes, however, were not enough to make signals really
usable, so the developers of System&nbsp;V (at AT&amp;T) found the need for
a <tt>sigaction()</tt> call which adds some extra flags to control the fine
details of signal delivery.  This call also allows a signal handler to be
passed a "<tt>siginfo_t</tt>" data structure with information about the
cause of the signal, such as the UID of the process which sent the
signal. </p><p>
As these changes, particularly those from UCB, were focused on
providing "reliable" signal delivery, one might expect that at least
the reliability issues would be resolved.  Not so it seems.  The
<tt>select()</tt> system call (and related <tt>poll()</tt>) did not
play well with signals so <tt>pselect()</tt> and <tt>ppoll()</tt> had
to be invented and eventually implemented. The interested reader is
encouraged to explore their history.
Along with these semantic "enhancements" to signal delivery, both
teams of developers chose to define more signals generated by
different events.  Though signal delivery was already problematic
before these were added, it is likely that these new demands stretched
the design towards breaking point.
</p><p>
An interesting example is SIGCHLD and SIGCLD, which are sent when a child
exits or is otherwise ready for the parent to <tt>wait()</tt> for it.
The difference between these two (apart from the letter "H" and
different originating team) is that SIGCHLD is delivered once per event
(as is the case with other signals) while SIGCLD would be delivered
constantly (unless blocked) while any child is ready to be waited for.
In the language of hardware interrupts, SIGCHLD is edge triggered while
SIGCLD is level triggered.  The choice of a level-triggered signal
might have been an alternate attempt to try to improve reliability.

Adding SIGCLD was more than just defining a new number and sending
the signal at the right time.  Two of the new flags added for
<tt>sigaction()</tt> are specifically for tuning the details of
handling this signal.  This is extra complexity that signals didn't
need and which arguably did not belong there.
</p><p>
In more recent years the collection of signal types has been extended
to include "realtime" signals.  These signals are user-defined
signals (like SIGUSR1 and SIGUSR2) which are only delivered if
explicitly requested in some way.  They have two particular
properties.

Firstly, realtime signals are queued so the handler in the target
process is called exactly as many times as the signal was sent.  This
contrasts with regular signals which simply set a flag on delivery.
If a process has a given (regular) signal blocked and the signal is sent several
times, then, when the process unblocks the signal, it will still only
see a single delivery event.  With realtime signals it will see
several.  This is a nice idea, but introduced new reliability issues
as the depth of the queue was limited, so signals could still be lost.

Secondly (and this property requires the first), a realtime signal can carry
a small datum, typically a number or a pointer.  This can be sent
explicitly with <tt>sigqueue()</tt> or less directly with, e.g.,
<tt>timer_create()</tt>. </p><p>
It could be thought that this addition of more signals for more events is
a good example of the "full exploitation" pattern that was discussed
at the start of this series.  However, when adding new signal types
require significant changes to the original design, it could equally
seem that the original design wasn't really strong enough to be so
fully exploited.

As can be seen from this retrospective, though the original signal
design was quite simple and elegant, it was fatally flawed.  The need
to re-arm signals made them hard to use reliably, the exact semantics of
interrupting a system call was hard to get right, and developers
repeatedly needed to significantly extend the design to make it work
with new types of signals.
</p><p>
The most recent step in the saga of signals is the <tt>signalfd()</tt>
system call which was introduced to Linux in 2007 for 2.6.22.  This
system call extends "everything has a file descriptor" to work for
signals too. Using this new type of descriptor returned by
<tt>signalfd()</tt>, events that would normally be 
handled asynchronously via signal handlers can now be handled
synchronously just like all I/O events.  This approach makes many of the
traditional difficulties with signals disappear.  Queuing becomes
natural so re-arming becomes a non-issue.  Interaction with system
calls ceases to be interesting and an obvious way is provided for extra
data to be carried with a signal.  Rather than trying to fix a
problematic asynchronous delivery mechanism, <tt>signalfd()</tt>
replaces it with a synchronous mechanism that is much easier to work
with and which integrates well into other aspect of the Unix design -
particularly the universality of file descriptors.
</p><p>
It is a fun, though probably pointless, exercise to imagine what the
result might have been had this approach been taken to signals when
problems were first observed.  Instead of adding new signal types we
might have new file descriptor types, and the set of signals that were
actually used could have diminished rather than grown.  Realtime
signals might instead be a general and useful form of interprocess
communication based on file descriptors.
</p><p>
It should be noted that there are some signals which
<tt>signalfd()</tt> cannot be used for.  These include SIGSEGV, SIGILL,
and other signals that are generated because the process tried to do
something impossible.  Just queueing these signals to be processed
later cannot work, the only alternatives are switching control to a
signal handler, or aborting the process.  These cases are handled
perfectly by the original signal design.  They cannot occur while a
system call is active (system calls return EFAULT rather than raising a
signal) and issues with when to re-arm the signal handler are also less
relevant. </p><p>
So while signal handlers are perfectly workable for some of the early
use cases (e.g. SIGSEGV) it seems that they were pushed beyond their
competence very early, thus producing a broken design for which there
have been repeated attempts at repair.  While it may now be possible to
write code that handles signal delivery reliably, it is still very easy
to get it wrong.  The replacement that we find in <tt>signalfd()</tt>
promises to make event handling significantly easier and so more
reliable. </p>
<h4>The Unix permission model</h4>
<p>
Our second example of an unfixable design which is best replaced is
the owner/permission model for controlling access to files.

A well known quote attributed to H. L. Mencken is "there is always a
well-known solution to every human problem - neat, plausible, and
wrong."  This is equally true of computing problems, and the Unix
permissions model could be just such a solution.

The initial idea is deceptively simple: six bytes per file gives simple
and broad access control.  When designing an operating system to fit in 32 kilobytes
of RAM (or less), such simplicity is very appealing, and thinking about
how it might one day be extended is not a high priority, which is
understandable though unfortunate.
</p><p>
The main problems with this permission model is that it is both too
simple and too broad.

The breadth of the model is seen in the fact that every file stores its
own owner, group owner, and permission bits.  Thus every file can have
distinct ownership or access permissions.  This is much more flexibility
than is needed.  In most cases, all the files in a given directory, or
even directory tree have the same ownership and much the same
permissions.  This fact was leveraged by the Andrew filesystem which
only stores ownership and permissions on a per-directory basis, with
little real loss of functionality.
</p><p>
When this only costs six bytes per file it might seem a small price to pay
for the flexibility.  However once more than 65,536 different owners are
wanted, or more permission bits and more groups are needed, storing this information begins
to become a real cost.  However the bigger cost is in usability.
</p><p>
While a computer may be able to easily remember six bytes per file, a
human cannot easily remember why various different settings might have
been assigned and so are very likely to create sets of permission
settings which are inconsistent, inappropriate, and hence not
particularly secure.  Your author has memories from University days of
often seeing home directories given "0777" permissions (everyone has
any access) simply because a student wanted to share one file with a
friend, but didn't understand the security model.
</p><p>
The excessive simplicity of the Unix permission model is seen in the
fixed, small number of permission bits, and, particularly, that there is
only one "group" that can have privileged access.  Another maxim from
computer engineering, attributed to Alan Kay, is that "Simple things
should be simple, complex things should be possible."  The Unix
permission model makes most use cases quite simple but once the need
exceeds that common set of cases, further refinement becomes
impossible.  The simple is certainly simple, but the complex is truly
impossible.
</p><p>
It is here that we start to see real efforts to try to "fix" the model.
The original design gave each process a "user" and a "group"
corresponding to the "owner" and "group owner" in each file, and they
were used to determine access.  The "only one group" limit is limiting
on both sides; the Unix developers at UCB saw that, for the process
side at least, this limit was easy to extend.  They allowed a process to have a
list of groups for checking filesystem access against.  (Unfortunately
this list originally had a firm upper limit of 16, and that limit made
its way into the NFS protocol where it was hard to change and is still
biting us today.)
</p><p>
Changing the per-file side of this limit is harder as that requires
changing the way data is encoded in a filesystem to allow multiple
groups per file.  As each group would also need its own set of
permission bits a file would need a list of groups and permission bits
and these became known quite reasonably as "access control lists" or
ACLs.  The Posix standardization effort made a couple of attempts to
create a standard for ACLs, but never got past draft stage.  Some Unix
implementations have implemented these drafts, but they have not been
widely successful.
</p><p>
The NFSv4 working group (under the IETF umbrella) were tasked with
creating a network filesystem which, among other goals, would provide
interoperability between POSIX and WIN32 systems.  As part of this
effort they developed yet another standard for ACLs which aimed to
support the access model of WIN32 while still being usable on POSIX.
Whether this will be more successful remains to be seen, but it seems
to have a reasonable amount of momentum with an active project trying
to integrate it into Linux (under the banner of "<a
href="http://acl.bestbits.at/richacl/">richacls</a>") and 
various Linux filesystems.
</p><p>
One consequence of using ACLs is that the per-file storage space needed
to store the permission information is not only larger than six bytes, it
is not of a fixed length.  This is, in general, more challenging than any
fixed size.  Those filesystems which implement these ACLs do so using
"extended attributes" and most impose some limit on the size of these
- each filesystem choosing a different limit.  Hopefully most ACLs that
are actually used will fit within all these arbitrary limits.
</p><p>
Some filesystems - ext3 at least - attempt to notice when multiple
files have the same extended attributes and just store a single copy of those
attributes, rather than one copy for each file.  This goes some way to
reduce the space cost (and access-time cost) of larger ACLs that can
be (but often aren't) unique per file, but does nothing to address the
usability concerns mentioned earlier.

In that context, it is worth quoting Jeremy Allison, one of the main
developers of Samba, and so with quite a bit of experience with ACLs
from WIN32 systems and related interoperability issues.
<a
href=http://www.mail-archive.com/linux-cifs@vger.kernel.org/msg00605.html>He
writes</a>: "<q>But Windows ACLs are a nightmare beyond human
comprehension :-). In the 'too complex to be usable' camp.</q>"
It is worth reading the context and follow up to get a proper picture,
and remembering that richacls, like NFSv4 ACLs, are largely based on
WIN32 ACLs.
</p><p>
Unfortunately it is not possible to present any real example of
replacing rather than fixing the Unix permission model.  One contender
might be that part of "SELinux" that deals with file access.  This
doesn't really aim to replace regular permissions but rather tries to
enhance them with mandatory access controls.  SELinux follows much the
same model of Unix permissions, associating a security context with
every file of interest, and does nothing to improve the usability
issues.
</p><p>
There are however two partial approaches that might provide some
perspective.
One partial approach began to appear in Level 7 Unix with the
<tt>chroot()</tt> system call.  It
<a href=http://en.wikipedia.org/wiki/Version_7_Unix>appears</a>
that <tt>chroot()</tt> wasn't originally created for access control but rather to
have a separate namespace in which to create a clean filesystem for
distribution.  However it has since been used to provide some level of
access control, particularly for anonymous FTP servers. This is done by
simply hiding all the files that the FTP server shouldn't access.
Anything that cannot be named cannot be accessed.
</p><p>
This concept has been enhanced in Linux with the possibility for each
process not just to have its own filesystem root, but also to have a
private set of mount points with which to build a completely
customized namespace.  Further it is possible for a given filesystem
to be mounted read-write in one namespace and read-only in another
namespace, and, obviously, not at all in a third.

This functionality is suggestive of a very different approach to
controlling access permissions.  Rather than access control being
per-file, it allows it to be per-mount.  This leads to the location of
a file being a very significant part of determining how it can be
accessed.  Though this removes some flexibility, it seems to be a
concept that human experience better prepares us to understand.  If we
want to keep a paper document private we might put it in a locked
drawer.  If we want to make it publicly readable, we distribute copies.
If we want it to be writable by anyone in our team, we pin it to the
notice board in the tea room.
</p><p>
This approach is clearly less flexible than the Unix model as the
control of permissions is less fine grained, but it could well make up
for that in being easier to understand.  Certainly by itself it would
not form a complete replacement, but it does appear to be functionality
that is growing - though it is too early yet to tell if it will need to
grow beyond its strength.  One encouraging observation is that it is
based on one of those particular Unix strengths observed in our first
pattern, that of "a hierarchical namespace" which would be exploited
more fully.
</p><p>
A different partial approach can be seen in the access controls used
by the Apache web server.  These are encoded in a domain-specific
language and stored in centralized files or in "<tt>.htaccess</tt>s" files near the
files that are being 
controlled.  This method of access control has a number of real
strengths that would be a challenge to encode into anything based on
the Unix permission model:
<ul>
<li>
   The permission model is hierarchical, matching the filesystem
   model.  Thus controls can be set at whichever point makes most sense,
   and can be easily reviewed in their entirety.   When the controls
   set at higher levels are not allowed to be relaxed at lower levels it
   becomes easy to implement mandatory access controls.
<p>
<li>
    The identity of the actor requesting access can be arbitrary,
    rather than just from the set of identities that are known to the
    kernel.   Apache allows control based on source IP address or
    username plus password.  Using plug-in modules almost anything
    else that could be available.
<p>
<li>
    Access can be provided indirectly through a CGI program.  Thus,
    rather than trying to second-guess all possible access
    restrictions that might be desirable and define permission bits
    for them in a new ACL, the model can allow any arbitrary action to
    be controlled by writing a suitable script to mediate that access.
</ul>
</p><p>
It should be fairly obvious that this model would not be an easy fit
with kernel-based access checking and, in any case, would have a higher
performance cost than a simpler model.  As such it would not be suitable
to apply universally.  However it could be that such a model would be
suitable for that small percentage of needs that do not fit in a simple
namespace based approach.  There the cost might be a reasonable price
for the flexibility.
</p><p>
While an alternate approach such as these might be appealing, it would
face a much bigger barrier to introduction than <tt>signalfd()</tt> did.
<tt>signalfd()</tt> could be added as a simple alternate to signal
handlers. Programs could continue to use the old model with no loss,
while new programs can make use of the new functionality.  With
permission models, it is not so easy to have two schemes running in
parallel. People who make serious use of ACLs will probably already
have a bunch of ACLs carefully tuned to their needs and enabling an
alternate parallel access mechanism is very likely to break something.
So this is the sort of thing that would best be trialed in a new
installation rather than imposed on an existing user-base.
</p>
<h4>Discerning the pattern</h4>
<p>
If we are to have a convincing pattern of "unfixable designs" it must
be possible to distinguish them from fixable designs such as those
that we found last time.  In both cases, each individual fix appears
to be a good idea addressing a real problem without
obviously introducing more problems.  In some case this series
of small steps leads to a good result, in others these steps only help you
get past the small problems enough to be able to see the bigger
problem.
</p><p>
We could use mathematical terminology to note that a local maximum can
be very different from a global maximum.  Or, using mountain-climbing
terminology, it is hard to know the true summit from a false summit
which just gives you a better view of the mountain.
In each case the missing piece is a large scale perspective. If we can
see the big picture we can more easily decide if a particular path will
lead anywhere useful or if it is best to head back to base and start
again.
</p><p>
Trying to move this discussion back to the realm of software engineering, it is
clear that we can only head off unfixable designs if we can find a
position that can give us a clear and broad perspective.  We need to be
able to look beyond the immediate problem, to see the big picture and
be willing to tackle it.  The only known source of perspective we have
for engineering is experience, and few of us have enough experience to
see clearly into the multiple facets and the multiple levels of
abstraction that are needed to make right decisions.  Whether we look
for such experience by consulting elders, by researching multiple
related efforts, or finding documented patterns that encapsulate the
experience of others, it is vitally important to leverage any
experience that is available rather than run the risk of simply adding
bandaids to an unfixable design.
</p><p>
So there is no easy way to distinguish an unfixable design from a
fixable one.  It requires leveraging the broad perspective that is
only available through experience.
Having seen the difficulty of identifying unfixable designs early we can
look forward to the final part of this series, where we will explore a
pernicious pattern in problematic design.  While unfixable designs give a
hint of deeper problems by appearing to need fixing, these next designs do
not even provide that hint.  The hints that there is a deeper problem must
be found elsewhere.
</p>
<p>
<h4>Exercises</h4>
<ol>
<li>
Though we found that signal handlers had been pushed well beyond their
competence, we also found at least one area (i.e. SIGSEGV) when they
were still the right tool for the job.  Determine if there are other
use cases that avoid the observed problems, and so provide a balanced
assessment of where signal handlers are effective, and where they are
unfixable.
<P>
<li>
Research problems with "<tt>/tmp</tt>", attempts to fix them, any
unresolved issues, and any known attempts to replace rather than fix
this design. 
<p>
<li>
Describe an aspect of the IP protocol suite that fits the pattern
of an "Unfixable design".
<P>
<li>
It has been suggested that dnotify, inotify, fanotify are all broken.
Research and describe the problems and provide an alternate design that
avoids all of those issues.
<p>
<li> Explore the possibility of using fanotify to implement an "apache-like"
   access control scheme with decisions made in user-space.  Identify
   enhancements requires to fanotify for this to be practical.
</ol>
<p>
<h4>Next article</h4>
<p>
<a href="/Articles/416494/">Ghosts of Unix past, part 4: High-maintenance
designs</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-Patterns">Development model/Patterns</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/414618/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor415679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 16:10 UTC (Tue)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/415679/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>The NFSv4 working group (under the IETF umbrella) were tasked with creating a network filesystem which, among other goals, would provide interoperability between POSIX and WIN32 systems. As part of this effort they developed yet another standard for ACLs which aimed to support the access model of WIN32 while still being usable on POSIX.</blockquote>

<p>Actually, it's really just a copy of Windows ACLs as far as I can tell--different implementors have made different choices as to how to reconcile with POSIX.

<p>The Richacl implementors (mainly Andreas Gruenbacher) have added some extra "mask bits" as a way to ensure that a chmod can still restrict permissions without permanently losing information from any ACL set on the file.  Interestingly enough, the hardest part then becomes mapping the resulting masked ACL to a Windows/NFSv4-like ACL....

<p>Readers in search of a challenge can go look at their code and figure out if there's a better mapping.  I've drawn a blank so far.  It's likely what we'll end up doing.
      
          <div class="CommentReplyButton">
            <form action="/Articles/415679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 21:04 UTC (Tue)
                               by <b>wazoox</b> (subscriber, #69624)
                              [<a href="/Articles/415721/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Interestingly enough, the hardest part then becomes mapping the resulting masked ACL to a Windows/NFSv4-like ACL.... </font><br>
<p>
That reminds me of the ACL parts of the samba code. There is a long page of comments that reads something like "beware, here follows, long, hairy, complicated and untractable explanation of a longer, hairier and more incomprehensible code". Then more lines with comments like "Don't touch this code!" :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 23:21 UTC (Tue)
                               by <b>vonbrand</b> (subscriber, #4458)
                              [<a href="/Articles/415745/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>
Due to the "ACL model" of Windows being a unmangeable mess?
<p>
The user/group/others model is certainly lacking (it can't describe the full permissions matrix like the Bell-LaPadula model uses), but what are the real, <em>usable</em> alternatives?
      
          <div class="CommentReplyButton">
            <form action="/Articles/415745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 0:57 UTC (Wed)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/415775/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SELinux and an infinate level of fine grained control? I guess it really depends on how much control you need and how many man hours you want to put into maintaining it. <br>
<p>
I'd imagine the US DOD has permission levels and tables that would make your head spin, after all their paper permission levels are nearly incomprehensible, I can't even imagine their computer permissions. In fact I'd wager there is an entire staff of people that do nothing but manage permissions. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 17:51 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/416145/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I took the course, and they have the same four or five levels for everyone (unclassified, restricted ,confidential, secret and top secret), and a plethora of categories, possibly including "the commandant's cat's litter-box", assuming of course that you have secrets about it.<br>
<p>
--dave<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor415784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 3:18 UTC (Wed)
                               by <b>jra</b> (subscriber, #55261)
                              [<a href="/Articles/415784/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hey, there's ascii art in there explaining everything ! How can you not love code with ascii art in it ? :-).<br>
<p>
Jeremy.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor415684"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 16:43 UTC (Tue)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/415684/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; signalfd</font><br>
<p>
Unfortunately, signalfd has a very irritating practical issue.<br>
<p>
To use it, you need to block the signal you're interested in (using e.g. sigsetmask). However, the set of blocked signals is not reset by exec (blocked signals and signals set to SIG_IGN are preserved, but other signal actions are reset to default). So, if you use signalfd, whenever you spawn a process, it will not receive that signal. And processes tend to misbehave when not receiving signals they expect to.<br>
<p>
You can, of course, fix that. You simply need to unblock the signal after forking, but before exec'ing.  *IF* you control everything that ever calls fork/exec from your process. In many situations, that is impossible -- programs tend to use all sorts of libraries, some of which spawn processes.<br>
<p>
Okay, so, you might say: "Hey, that's what pthread_atfork is for! Just set an child-side after-fork handler to unblock the signal". Well, unfortunately, pthread_atfork doesn't always get called when spawning a child process, so you can't really use it for that.<br>
<p>
Three examples of that:<br>
1) For the system() call, POSIX says: "It is unspecified whether the handlers registered with pthread_atfork() are called as part of the creation of the child process." In glibc, they aren't.<br>
2) Regarding posix_spawn, POSIX says: "It is implementation-defined whether the fork handlers are run when posix_spawn() or posix_spawnp() is called." In glibc, they are.<br>
3) The linux-specific clone() system-call does not have atfork handlers called.<br>
<p>
So, basically, end result: signalfd is unusable in many circumstances where it'd be really nice to be able to use it -- you're better off just setting a standard signal handler which writes to an fd. Sigh.<br>
<p>
(POSIX spec URL: <a href="http://www.opengroup.org/onlinepubs/9699919799/">http://www.opengroup.org/onlinepubs/9699919799/</a>)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415684/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415698"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 17:17 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/415698/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't a named pipe in the filesystem do as well in many of the cases where signalfd is a feasible solution?  Presumably we are looking at the more specialised cases of signal handling here which are likely to be application-specific protocols, and not just handling SIGINT.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415698/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415699"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 17:29 UTC (Tue)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/415699/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you've got the wrong idea. Signalfd isn't intended for "specialized" applications of signals (and I'm not sure how named pipes come into play at all). It would be nice to use for completely normal uses of signal handling: for example, it would be ideal for replacing a SIGCHLD handler in an application with an event loop: you're already waiting on fds to become readable/writable, so waiting on a signalfd fd to notify you of a child that finished is exactly what you want.<br>
<p>
Most sensible such applications will already implement that by writing a signal handler for SIGCHLD which simply writes a byte into a pipe, and then has the event loop look for readability on that pipe. Signalfd would let you do that more easily -- if you could actually use it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415699/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 17:33 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/415700/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Signalfd isn't intended for "specialized" applications of signals (and I'm not sure how named pipes come into play at all). It would be nice to use for completely normal uses of signal handling: for example, it would be ideal for replacing a SIGCHLD handler in an application with an event loop [...]</font><br>
<p>
That makes sense - and obviously a named pipe would be no good there whatsoever.  I was more thinking of things like SIGUSR1 sorts of interactions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor415796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 8:11 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/415796/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems like what you want is... another arbitrary patch atop the mess! Specifically, a rule that unblocked signals which have open signalfds act exactly as if blocked (pending signals being sent down the signalfd 'instead' of being conventionally delivered) until the fd is closed. Now, assuming that the user has opened the signalfd O_CLOEXEC (hey, that should be the default! but we repeat ourselves), the signal will automatically 'unblock itself' at exec() time, which is exactly what we want.<br>
<p>
Bonus: no change to signal semantics when signalfd is not in use, and nobody sane would want the current semantics in any case.<br>
<p>
What am I missing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 14:43 UTC (Wed)
                               by <b>madcoder</b> (guest, #30027)
                              [<a href="/Articles/415841/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, you want a real atfork() interface that is not related to threads. pthread_atfork is here because when you fork() from threads, you fork one new process, not "all the threads" and that often means that you have to deregister stuff.<br>
<p>
Anyway, there is a solution for that (which is messy butÂ…) on linux which is to redefine fork(), system(), pthread_spawn{,p} and every similar problematic fork() wrapper using dlsym chaining to reset your signal masks properly. This isn't *that* complicated, and chains nicely. Or if you're sure that pthread_atfork() works for some then only divert the ones where it doesn't. I know it's not portable but signalfd() isn't in the first place either ;)<br>
<p>
WRT clone() I'd say that this is a very low level interface which has a really high chance to break the libc when used (e.g. TSD breaks in interesting ways in the glibc if you use clone without emulating what the glibc does IIRC), so I'd say people using it Know What They Are Doing in the first place and should have worried about resetting the signal mask to a sane default in the first place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor417083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2010 22:04 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/417083/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was wondering if you had brought this up with the developer of signalfd - Davide Libenzi?<br>
<p>
Fixing it would probably require adding a new 'flags' option, so adding a new syscall and deprecating the old.  This 'flags' could allow atomic setting of close-on-exec and an auto-block flag which causes all signals being tracked by signalfd to blocked just as long as the signalfd is open.<br>
<p>
If you haven't and don't want to, I might....<br>
<p>
Thanks,<br>
NeilBrown<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2010 18:28 UTC (Thu)
                               by <b>dcoutts</b> (subscriber, #5387)
                              [<a href="/Articles/417259/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please do bring this up with the kernel hackers. We were thinking of using signalfd in the GHC runtime / IO system until we discovered this problem with having to block all signals in all threads which makes it unusable (it's not just child processes, libraries can make their own threads). We have to stick with the approach of installing a signal hander that writes to a pipe (or we can use eventfd for the cases where there is no data associated with the signal).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor683793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 7:01 UTC (Thu)
                               by <b>linuxrocks123</b> (guest, #34648)
                              [<a href="/Articles/683793/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can't you #include &lt;dlfcn.h&gt; and intercept calls to glibc's fork()?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor415711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 20:05 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/415711/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
.htaccess is a convienient way to think about permissions, but in terms of performance it's a disaster.<br>
<p>
every time apache has to access a file it needs to look in .htaccess for that directory, AND EVERY PARENT DIRECTORY.<br>
<p>
As a result, just about every production apache server disables .htaccess files.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 20:47 UTC (Tue)
                               by <b>alvieboy</b> (guest, #51617)
                              [<a href="/Articles/415717/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That could be solved by simply caching access data in memory. dnotify() also allows you to do proper reloading of ACLs, without having to stat() every file on hierarchy.<br>
<p>
But Apache is not only meant for Linux. Other OSes do not provide these functionalities.<br>
<p>
What's really harder is to apply all constraints in a fast and efficient way. I never benchmarked Apache on this, but I'd bet its not that fast nor efficient.<br>
<p>
Alvaro<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 21:21 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/415726/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
under the covers, .htaccess files are not just access control files, they can contain any config options that can be in an apache config file, they just apply to that directory and it's subdirectories, discovered per-hit.<br>
<p>
so yes, they are horribly inefficient<br>
<p>
in terms of caching the combined contraints, that seems hard in the face of directories being moved around.<br>
<p>
there's also the issue of the interaction with links and finguring out the 'true' path to a file.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor415781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 1:55 UTC (Wed)
                               by <b>buck</b> (subscriber, #55985)
                              [<a href="/Articles/415781/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
maybe i'm a moron, but i find that trying to map the non-hierarchical<br>
layout of the apache httpd.conf to a mental overlay for the server's<br>
(virtual) filesystem/URI space to be way beyond my competence.  .htac-<br>
cess files at least have the virtue of controls being in proximity to<br>
the stuff they control, though that thinking runs entirely counter to<br>
the point being made in the article, the extended-attribute bloat,<br>
etc.  so maybe i just drank the inode/xattr Kool-Aid to my permanent<br>
detriment, but the ``composability'' of the permissions by masking<br>
them through the filesystem's links down to the object of concern is<br>
something i just totally grok.  (i think there must be some connec-<br>
tion i should make here about exploiting the grafted-on filesystem<br>
trees design to the full being part-and-parcel, but i am obviously not<br>
a big-picture type, and i think that case was made for chroot/name-<br>
space forking)<br>
<p>
i'll concede that maybe AFS directory-only permissions might simplify<br>
things a bit, at the fringes<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 2:50 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/415783/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
no disagreement that they are easier to understand, the problem is the performance implications of them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor415801"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 9:53 UTC (Wed)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/415801/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The beautiful thing is that one doesn't have to do this expensive lookup if the main filesystem/kernel used such a scheme. It would work pretty much like the dentry-cache and one could probably even JIT the possible complex patterns or at least byte-code compile them in memory.<br>
Apache doesn't do this for it is hard to get a good cross-platform file-change notification (which doesn't have possible side-effects).<br>
<p>
It even has a good chance to be cheaper than the current unix model, since in a practical setup there would only be a few (compiled) rulesets in effect (still hundreds, but a lot less than actual dentries). One could possibly cache a pointer to the list of effective rules to a dentry/inode (depending on how the rules are to be applied, this is semantics, but I suspect you'd want them on the inode level).<br>
<p>
But the decoupling of the details from every single inode can probably be done without any real performance impact (and possibly even performance gains). Whether you use hierarchical ACLs or matching rules shouldn't really make a difference and constant tree traversals shouldn't be necessary when done at the VFS level.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415801/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor415715"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 20:35 UTC (Tue)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/415715/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
s/using maintain climbing terminology/using mountain climbing terminology/<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415715/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 20:47 UTC (Tue)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/415719/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thou Shalt Not Post Typos As Comments.<br>
<p>
Presumably, that also holds for spelling mis-corrections.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 23:36 UTC (Tue)
                               by <b>tpo</b> (subscriber, #25713)
                              [<a href="/Articles/415757/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Thou Shalt Not Post Typos As Comments</font><br>
<p>
Why not? This series has very much the flavour of a classic text. Thus fixing it now for posteriority makes a lot of sense:<br>
<p>
s/Each of these can be the right answer is different contexts/Each of these can be the right answer in different contexts/<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 23:59 UTC (Tue)
                               by <b>ABCD</b> (subscriber, #53650)
                              [<a href="/Articles/415763/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To quote the text that appears every time you post a comment:<br>
<p>
<font class="QuotedText">&gt; Please do not post typos as comments, send them to lwn@lwn.net instead.</font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor415765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typos</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 0:05 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/415765/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      "Posteriority"?  You're going to sit on it? :)
<p>
As noted elsewhere; future readers of a classic text are likely to be supremely uninterested in the typos that made it through the editing process.  That's why we prefer that people email them to us.  
      
          <div class="CommentReplyButton">
            <form action="/Articles/415765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typos</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 18:15 UTC (Thu)
                               by <b>RobSeace</b> (subscriber, #4435)
                              [<a href="/Articles/416158/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You really should add a "report typo" button at the bottom of every story,<br>
with a web form to fill in...  When people are in their browser reading a web<br>
site, they hate to jump through the hoop of firing up their E-mail program (or<br>
navigating to their web-mail site) just to report a typo, especially when there's<br>
a handy-dandy easier-to-use forum thread right there that they can mention it<br>
in instead...<br>
<p>
And, yes, I know you've already got a "mailto:" link, but for many of us,<br>
"mailto:" is useless...  It doesn't bring up my prefered E-mail client (elm,<br>
running on a completely different machine than where my browser is currently<br>
running)...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typos</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2010 10:56 UTC (Sun)
                               by <b>Darkmere</b> (subscriber, #53695)
                              [<a href="/Articles/416473/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fix ye'r mailclient configuration ;)<br>
<p>
( ssh -t user@host 'something something something %U' )  should do it for you, add to a .desktop, associate as a Mailer and you should be good to go<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typos</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2010 18:46 UTC (Mon)
                               by <b>wookey</b> (guest, #5501)
                              [<a href="/Articles/416638/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a great suggestion, but where does one put it? It's the desktop or browser config that decides what to do with mailto: links. mozilla seems to have it's own internal config with useful options like 'yahoo mail' or 'googlemail' or 'thunderbird'. I can pick 'other' and specify '/usr/bin/ssh' there but not a useful command line SFAICT. THose internal options live in some kind of internal database thing SFAIK so there is no handy text file in .mozilla/firefox/435l2hlia.default to edit (is there?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416652"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">see gnome-default-applications-properties </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2010 19:41 UTC (Mon)
                               by <b>jku</b> (subscriber, #42379)
                              [<a href="/Articles/416652/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In GNOME gnome-default-applications-properties will let you choose the default mailto handler. You can set a custom entry like "/home/wookey/bin/mail-handler.sh %s". Mozilla products respect this, I think.<br>
<p>
The current setup seems to allow what you want but it's pretty limited in many ways. See Bastien Noceras blog for some recent mimetype-related developments: <a href="http://www.hadess.net/2010/10/new-control-center-and-you.html">http://www.hadess.net/2010/10/new-control-center-and-you....</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416652/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor415712"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signals vs. system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 20:43 UTC (Tue)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/415712/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Only lightly touched on here is the horrible-ness of signals interrupting system calls.  The ability to set SA_RESTART is better than nothing but it has significant problems, in particular that it's not implemented appropriately everywhere (Linux is pretty good but Solaris, for example, is pretty bad).<br>
<p>
This means that if, for example, you set a signal handler for SIGCHLD you have major problems since SA_RESTART can't be considered reliable (portably).  The trick of having an internal pipe to communicate between your signal handler and your main event loop is still subject to this problem.<br>
<p>
One assumes that signalfd() would not interrupt system calls on signals delivered through the FD so it solves that problem--but it's Linux-specific and Linux already handles SA_RESTART reliably.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415712/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signals vs. system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 22:57 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/416368/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I can't quite tell what problem you're pointing out.  Are you saying it's horrible that anything that makes a system call of an interruptible type has to check for EINTR or partial completion and repeat/resume the system call?
<p>
Of course, any solution in which system calls are uninterruptible defeats half the purpose of a signal.
<blockquote>
The trick of having an internal pipe to communicate between your signal handler and your main event loop is still subject to this problem.
</blockquote>
<p>
I'm familiar with the trick of having such an internal pipe -- it solves the problem of select() <em>not</em> getting interrupted when a signal arrives just as select() is starting.  But I don't see the connection between that and horribleness of signals interrupting system calls.
<p>
<blockquote>
One assumes that signalfd() would not interrupt system calls on signals delivered through the FD
</blockquote>
<p>
signalfd() just generates the file descriptor, so of course it doesn't interrupt anything.  If you mean that in a program that uses signalfd(), system calls don't get interrupted, I think you're right because a program that uses signalfd() normally blocks signals, and a blocked signal can't interrupt a system call.  But that just means that a program that uses signalfd() can't fully exploit signals -- control-C won't unhang some things.

      
          <div class="CommentReplyButton">
            <form action="/Articles/416368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signals vs. system calls</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2010 5:55 UTC (Thu)
                               by <b>rqosa</b> (subscriber, #24136)
                              [<a href="/Articles/417143/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p><font class="QuotedText">&gt; But that just means that a program that uses signalfd() can't fully exploit signals -- control-C won't unhang some things.</font></p>
<p>The solution to that is to use non-blocking system calls (or at least ones that you know will only block for a short time). That's something that you should already be doing if you're using signalfd(); the purpose of signalfd() is to handle signals with an event loop, and an event loop shouldn't have any blocking system calls in it (or anything else that takes a long time) except for the one select() (or epoll_wait() or similar) that drives the event loop.</p>
<p>(If there's some type of event whose handler must take a long time to run, then have the event loop hand it off to a worker thread/process.)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/417143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor415722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signals is the WORST part of Unix.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 21:08 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/415722/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Signals are way too complicated, introduce a lot of corner cases. And for no real gain - it's not possible to use signals reliably (in part because signal numbers are shared) beyond simple SIGHUP signaling.<br>
<p>
Windows DPC shows us that signals _can_ be done right.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signals is the WORST part of Unix.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 14:57 UTC (Fri)
                               by <b>Yorick</b> (guest, #19241)
                              [<a href="/Articles/416291/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <cite>Windows DPC shows us that signals _can_ be done right.</cite>

<p>I'm not very familiar with Windows, but isn't DPC a pure kernel-mode concept rather than something available in userspace? Windows does not appear to believe in pre-empting running userspace threads by user code - an approach that clearly solves some problems but mainly by taking options away from the programmer. This is not necessarily a bad thing, of course.

<p>Of course, since Unix signals are used for so many very different purposes, they cannot and should not be replaced by a single new mechanism.

      
          <div class="CommentReplyButton">
            <form action="/Articles/416291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signals is the WORST part of Unix.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 17:06 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/416309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's possible to drop from DPC to userlevel (in effect, replacing the currently executed code). In fact, signals are trivial to implement using DPC.<br>
<p>
<font class="QuotedText">&gt;Of course, since Unix signals are used for so many very different purposes, they cannot and should not be replaced by a single new mechanism.</font><br>
<p>
Unix signals are MISused for many purposes. They are broken and should be deprecated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor415725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 21:14 UTC (Tue)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/415725/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Neil, will you, at some point, release short answers to the exercises?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 4:28 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/415786/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most of the exercises are research questions for which short answers do not exist.<br>
Question 4 (on Xnotify) would result in an article that I would very much like to read.   Question 5 could result is a potentially useful slab of code (though it is less clear whether it would be used).<br>
<p>
I can tell you what I was thinking of in the "IP protocol suite" questions though, as no-one seems to have taken a stab that those in the comments.<br>
<p>
The 'full exploitation' in IP relates to UDP.  It is most nearly an application layer (layer 7) protocol (as applications can use it to communicate) yet it is used a multiple levels of the stack - particularly for routing (at least back when we used RIP.  BGP uses TCP) which is a layer 3 concern.  It is used for VPNs and other network management.  And even sometimes for application level protocols.<br>
<p>
The "conflated design" in IP is the fact that end-point addresses and rendezvous addresses are equivalent at the IP level.  They aren't at higher levels.  "lwn.net" is a rendezvous address, but the IP level you only see 72.51.34.34, which could (in a shared-hosting config) map from several rendezvous addresses.  So upper level protocols (like http/1.1) need to communicate the *real* rendezvous address, because IP doesn't.<br>
<p>
The "unfixable design" in IP is obviously the tiny address space, which we have attempted to fix by NAT and VPNs etc, but they aren't real fixes.  Had IP used a distinct rendezvous address it would have only been needed in the first packet of a TCP connection, so it would have been cheap to make it variable-length and then we might not have needed IPv6 (though that doesn't really address UDP).<br>
<p>
So those were my thoughts.  I haven't spent as much time fighting with network protocols as I have with the Unix API so I'm a lot less confident of these ideas than of the ones I wrote formally about.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 4:40 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/415790/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
just setting the address space to 64 bits instead of 32 bits would have been enough to eliminate the need for IPv6<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415803"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 10:00 UTC (Wed)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/415803/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No it would only eliminate the address shortage part of the problem. There are more significant changes that really are long due to be made which are also addressed by IPv6. The reasoning is: don't upgrade to half a solution when you know you really must do another upgrade soon after, the cost is in the breaking upgrade not in the amount of changes.<br>
That is not to say that IPv6 is the holy grail, it's design by committee and as such is probably too different on one front and not different enough on another. And of course it's trial by jury with a terribly large jury, so there is probably not one protocol (now or ever) that would meet all the demands.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415803/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 23:23 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/415957/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
what are the other problems that IPv6 solves?<br>
<p>
at the time it was designed, there were a lot of things that it did that were not possible in IPv4, but most (if not all) of the features that people really care about have been implemented in IPv4<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 8:11 UTC (Thu)
                               by <b>Cato</b> (guest, #7643)
                              [<a href="/Articles/416009/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are right about many things such as QoS, IPv6, etc.<br>
<p>
However, Mobile IP is much better implemented in IPv6 so you don't get inefficient 'triangular routing' - <a href="http://www.usipv6.com/ppt/MobileIPv6_tutorial_SanDiegok.pdf">http://www.usipv6.com/ppt/MobileIPv6_tutorial_SanDiegok.pdf</a><br>
<p>
The biggest benefit of course is not having to use NAT for IPv6 traffic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 13:19 UTC (Thu)
                               by <b>vonbrand</b> (subscriber, #4458)
                              [<a href="/Articles/416065/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
Yep, that's why people are clamoring for NATv6 ;-)
(Just as the idiotic firewalling going on has made everything run over HTTP.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/416065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor415980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 4:27 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/415980/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That the rendezvous address is (potentially) at a higher level than the end-point address is normal layering. For any given layer that provides some kind of addressing semantics, there can always be another layer above it that implements richer addressing and must map its richer addresses down to the lower layer. That's good and normal.<br>
<p>
So to look for conflation in networking addressing you probably need to stay within a layer. E.g. within IP, there is conflation in addressing because each address encodes both the identity of a node and its location in the network. Or perhaps more precisely: IP addressing lacks the notion of identity really, but an IP address is the closest you get and so many things use it for this. This may be fixed in the future with things like Shim6 or ILNP, which separate IP addressing into location and identity. This would allow upper-layer protocols like TCP to bind their state to a host identity, and so decouple them from network location.<br>
<p>
Variable length addresses would have been nice. The ISO packet protocol CLNP uses variable length NSAP addresses. However, hardware people tend to dislike having to deal with VL address fields. The tiny address space of IPv4 perhaps needn't have been unfixable - it could perhaps have been extended in a semi-compatible way. However it was decided (for better or worse) a long time ago to create IPv6.<br>
<p>
Possibly another problem with IP, though I don't know where it fits in your list, is multicast. This is an error of foresight, due to the fact that multicast still had to be researched and it depended on first understanding unicast - i.e. IP first had to be deployed. The basic problem is that multicast is bolted on to the side of IP. It generally doesn't work, except in very limited scopes. One case is where it can free-ride on existing underlying network multicast primitives, i.e. ones provided by local link technologies. Another is where a network provider has gone to relatively great additional trouble to configure multicast to work within some limited domain - needless to say this is both very rare and even when done is usually limited to certain applications (i.e. not available generally to network users). In any new network scheme one hopes that multicast services would be better integrated into the design and be a first-class service alongside unicast.<br>
<p>
Another retrospectively clear error is IP fragmentation. It was originally decided that fragmentation was best done on a host by host basis, on the assumption that path MTU discovery could be done through path network control signalling and that fragmentation/reassembly was a reasonably expensive process that middle-boxes ought not to be obliged to do. IMO this was a mistake: path MTU signalling turned out to be very fragile in modern deployment (IP designers didnt anticipate securo-idiocy); it turned out fragmentation/reassembly was relatively cheap - routers routinely use links both for internal buses and external connections which require fragmenting packets into small fixed size cells. As a consequence of the IP fragmentation choices, the IP internet is effectively limited to a (outer) path MTU of 1500 for ever more, regardless of changes in hardware capability. This causes problems for any IP packet protocol which wants to encap itself or another. One imagines that any new network scheme would learn from the IP MTU mess, make different trade-offs and come up with something better and more robust.<br>
<p>
We should of course be careful to not overly condemn errors of foresight. Anticipating the future can be hard, particularly where people are busy designing cutting-edge new technology that will define the future. ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 8:13 UTC (Thu)
                               by <b>Cato</b> (guest, #7643)
                              [<a href="/Articles/416010/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One performance improvement of IPv6 is that it has a much more regular IP header structure, which involves a lower cost for hardware-based forwarding.<br>
<p>
<a href="http://en.wikipedia.org/wiki/IPv6#Features_and_differences_from_IPv4">http://en.wikipedia.org/wiki/IPv6#Features_and_difference...</a> has a good summary of the benefits of IPv6 including this one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 1:15 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/416232/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
that sounds like something that was a really big deal when IPv6 was created, but with the increased processor speeds we have now, not nearly as important.<br>
<p>
this isn't just that clock speeds are higher, but that the ratio of clock speeds to the system bus speeds is no longer 1:1, this means that it's possible to execute far more steps without slowing the traffic down.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 11:15 UTC (Fri)
                               by <b>job</b> (guest, #670)
                              [<a href="/Articles/416264/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you're switching IP in hardware, it makes your design simpler and faster.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor416269"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 11:41 UTC (Fri)
                               by <b>Cato</b> (guest, #7643)
                              [<a href="/Articles/416269/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IP routers have not done CPU-based forwarding as the main path for a long time - the largest one is probably the Cisco CRS-3 which forwards 322 terabits per second when fully scaled (<a href="http://newsroom.cisco.com/dlls/2010/prod_030910.html">http://newsroom.cisco.com/dlls/2010/prod_030910.html</a>), but even quite low end routers now also use hardware forwarding (i.e. ASICs, network processors, etc, not CPU).<br>
<p>
You can probably manage to forward anything in hardware, but it helps somewhat that IPv6 has a regular header design.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416269/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IPV6 and hardware-parseable IP headers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 23:26 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/416369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I don't think CPU speed per se (how fast a single CPU is) is relevant.  It's all about cost, since most IP networks are free to balance the number of CPUs, system buses, network links, etc.
<p>
And from what I've seen, as the cost of routing in a general purpose CPU has come down, so has the cost of doing it in a specialized network link processor (what we're calling "hardware" here) -- assuming the IP header structure is simple enough.  So today, as ten years ago, people would rather do routing in an ASIC than allocate x86 capacity to it.
<p>
I think system designers balance system bus and CPU speed too, so it's not the case that there are lots of idle cycles in the CPU because the system bus can't keep up with it.

      
          <div class="CommentReplyButton">
            <form action="/Articles/416369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor418549"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 3, 2010 9:05 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/418549/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW, major router vendors still use software routing for many of their lower-end enterprise routers, even some mid-range.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/418549/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor416265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 11:18 UTC (Fri)
                               by <b>job</b> (guest, #670)
                              [<a href="/Articles/416265/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Path MTU discovery is indeed broken in practice.<br>
<p>
One thing I never really understood is why TCP MSS is a different setting from MTU. Given the belief that the MTU could be auto detected, MSS could be deduced from it.<br>
<p>
Perhaps someone can enlighten me?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor415724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: returning -1 for system call failure</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 21:21 UTC (Tue)
                               by <b>jhhaller</b> (guest, #56103)
                              [<a href="/Articles/415724/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the other problems resulting from early Unix implementation is the return code of -1 for failed system calls, with errno set as a side affect. If I remember correctly, this was a side effect of the PDP-11 instruction set, with the actual interface being a condition code and a single register return. If the condition code was set, the return register was errno, otherwise, it was the return value of the system call. Because of the limited data on the function return, it was impossible to give partial results when a system call failed. This has led to such things as failed writes not being able to report how many bytes were written before the failure, as well as the signal/select/poll problems described in the article. While the condition code was a good idea allowing fast failure checking, the translation into the C library interface and the single return code was a problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416370"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: returning -1 for system call failure</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 23:48 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/416370/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I don't know if it was an accident due to PDP-11 praticality or just good design philosophy, but I very much appreciate the convention in Unix of not returning information when a system call fails.  I.e. a failure is a failure.  If you get back useful information, or the system changes state, it's not a failure, but a different kind of success.
<p>
So I guess you're saying if a read of 10 sectors fails due to a media error on the 5th sector, you'd like to see the result, "failed due to media error, but read the first 4 sectors."  I like Unix'es version much better: Instead of requesting 10 sectors, you request "up to 10 sectors" and it succeeds with "4 sectors read" and the next read truly fails.
<p>
Things that fail but don't fail are much harder to program to.  They engender mistakes and convoluted code.  "Failure" has the special implication that you can probably just stop thinking about it and give up on whatever you were doing.  They are the inspiration for exception throwing in programming languages.

      
          <div class="CommentReplyButton">
            <form action="/Articles/416370/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor415743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Partial answer to #2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2010 23:03 UTC (Tue)
                               by <b>jamesmrh</b> (guest, #31622)
                              [<a href="/Articles/415743/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Per-user /tmp has been implemented with Linux namespaces for use with SELinux kiosk mode.  It's configurable via PAM (see pam_namespace(8), and not limited to any particular use.<br>
<p>
The fs namespace ideas came from Plan 9, but weren't really useful until integrated with PAM.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor415767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 0:13 UTC (Wed)
                               by <b>ldo</b> (guest, #40946)
                              [<a href="/Articles/415767/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ThatÂ’s my number-one example of an unfixable design crock in *nix systems and things that derive from them (like C).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 3:23 UTC (Wed)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/415785/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <p>Do you have a better suggestion?  Pascal-style strings?</p>

<p>While I agree that C-style strings are bothersome at times, there just doesn't seem to be any better alternative.  And never mind that Java's Strings are hideously inefficient (but again, is there a better way?).</p>

<p>I don't mean to argue; I'm just playing devil's advocate here. I honestly don't know myself whether there <i>could</i> have been a better way to do character strings way back in the day.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/415785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 4:37 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/415788/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I actually think nul terminated strings are simple and elegant and work.<br>
<p>
The problem is strcpy and strcat and sprintf should should never have existed.   strlcpy etc are much better interfaces when you have static or preallocated buffers.<br>
If you want dynamic strings, then talloc_strdup and talloc_strdup_append etc (in libtalloc) are probably your friends, though I confess I haven't used them extensively.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415794"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strlcpy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 6:26 UTC (Wed)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/415794/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, strlcpy is a failure.  It takes more and uglier code to use it correctly than to use strcpy with the same level of checking.  As a consequence, it is rarely used correctly, and unprofitably when it is.  This is not to say that one cannot improve on strcpy, just that strlcpy doesn't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415794/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor415797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 8:26 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/415797/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
nul terminated strings have a huge problem: you can accidentally overwrite the nul, and then you're dead. But if you're doing that, you can accidentally overwrite bits of the inside of the string as well, and then you have wrong results! Is that better? Probably not. Oh, and overwriting off the start or end can break your memory allocator or stack frame anyway, so you'd be dead in any case, even if not using nul-terminated strings.<br>
<p>
And then we have Pascal-layout strings (as opposed to actual Pascal 'strings', a nightmare for other reasons, see Kernighan). They don't fix this problem (you just have to overwrite the start of the string, not its end) and have two much bigger problems: finite string length, and an increase in size of every string. The finite string length means that writing general string-handling algorithms without special cases for the rare event of large strings is impossible, and the increase in size of every string bloats small strings, which are by far the common case. You can patch both of these: the first, by making the finite string length as large as a pointer; and the second, by noting that alignment constraints in existing systems bloat the effective size of strings anyway. But of course this soon turns into a special case of nul-terminated strings: point the pointer at the end of the string, bingo, one rather hard-to-consult nul by any other name.<br>
<p>
The biggest downside is probably a long-term ABI problem. The scheme is inflexible. If your Pascal string-length header is too short, however do you expand it? It's wired into every string-using program out there! At least nul-terminated strings need no expansion.<br>
<p>
The real solution to string-handling unfortunately requires a VM of some description which can prevent the program from accidentally overwriting fields in aggregates by writes to any other field or variable. Then you can do reliable Pascal strings, separating the length from the content, or reliable null-terminated strings, with the separate compartment containing a pointer into the string. Unfortunately this is incompatible with low-level all-the-world's-a-giant-arena languages like C without very specialized fine-grained MMU hardware.<br>
<p>
(I have, like everyone, written my own dynamic string-handliing library when younger. It starts out simple but it's amazing how soon you have to introduce extra code to track pointers and make freeing them in error cases less verbose, and extra code to track memory leaks... you need that in C anyway of course but the massive increase in dynamic memory use that dynamically allocating most strings brings tends to force them on you sooner than otherwise.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor415817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 12:38 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/415817/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"The biggest downside is probably a long-term ABI problem. The scheme is inflexible. If your Pascal string-length header is too short, however do you expand it? It's wired into every string-using program out there! At least nul-terminated strings need no expansion."<br>
<p>
Come on.<br>
<p>
You'd naturally use 32 bits on 32 bit systems for string length. And by a strange coincidence, that's the maximum amount of contiguous RAM that you can address on 32-bit systems. On 64-bit systems, you'd naturally use 64-bit counter.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 16:40 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/416126/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I talked about that as well. Nice to know that reading five paragraphs of text is too much for you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 17:04 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/416132/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I read it completely. However, you point about: "The biggest downside is probably a long-term ABI problem. The scheme is inflexible. If your Pascal string-length header is too short, however do you expand it? It's wired into every string-using program out there! At least nul-terminated strings need no expansion" is not correct.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2010 13:10 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/417197/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree with him that Pascal's strings are inflexible: think about two computer communicating together one with a 32-bit CPU, one with a 64-bit CPU, if you use a word as a length, you have an issue with Pascal's strings,<br>
but C-strings don't care..<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417227"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2010 16:22 UTC (Thu)
                               by <b>vonbrand</b> (subscriber, #4458)
                              [<a href="/Articles/417227/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
No, you haven't... (Original) Pascal "strings" were just (packed) arrays of characters of a fixed length.
<p>
/me ducks and runs for cover
      
          <div class="CommentReplyButton">
            <form action="/Articles/417227/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor416266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 11:24 UTC (Fri)
                               by <b>job</b> (guest, #670)
                              [<a href="/Articles/416266/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A modern string handling library would have to handle different character sets and different encondings as well, so there's already metadata to be stored with every string.<br>
<p>
If memory efficiency is a problem for you, multibyte encodings is a much worse problem than storing string length. But UTF-8/16 is here to stay, there is simply no competition. I think we have to accept it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor416021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 9:50 UTC (Thu)
                               by <b>stijn</b> (subscriber, #570)
                              [<a href="/Articles/416021/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does it not give an easy fuzzing attack? For anything that parses an input stream, the presence of nul bytes in that stream can lead to very unpredictable results unless one is really careful. Additionally, it is painful to have a string version (str) and a byte array version (mem) of everything, especially with a richer API (e.g. splice(), substr(), squash()). I've come to the conclusion that keeping length alongside the array is the only sane solution. Perhaps that already commits it too much down one path, so that it does not properly belong in the C library. By now I think the best is to have a byte-array API, and leave it up to the user of that API whether they want to keep it C-string compatible. If the keeping-length overhead is unacceptable, it is possible to do the string manipulations painlessly with the more generic API, and isolate a classic C-string as the very last step.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor416108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 15:38 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/416108/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I actually think nul terminated strings are simple and elegant and work.</font><br>
<p>
And you can also combine them to do things like:<br>
enum {lang_english, lang_french, lang_german} current_language = lang_french;<br>
const char mltstr_language[] = "english\0francais\0deutch\0"<br>
const char *curlang(const char *mltstr)<br>
{<br>
  /* select the right sub-string depending on current_language */<br>
}<br>
void fct(void)<br>
{<br>
  printf ("LANG=%s", curlang(mltstr_language))<br>
}<br>
It saves *a lot of space* ; having strings, (aligned) pointers arrays everywhere, and worse having (aligned) size for pascal strings takes easily more memory than the program code and data altogether.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 17:24 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/416134/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>I like your code example, but it might only work in C (not C++).</p>

<p>Two cases in point:</p>
<ul>
<li>Using the enum value as an array index might give unpredictable results since C++ treats enumerations as a distinct type (instead of int as in C)<sup>1</sup></li>
<li>The C++ standard library string can have '\0' characters anywhere inside the string (which may also lead to unpredictable behavior at runtime)<sup>2</sup>.  Of course, you're referring to a C-style string, so this may be a moot point.</li>
</ul>

<p><sup>1</sup> Stroustrup, B. <i>The C++ Programming Language, Special Edition</i>, p. 77<br/><sup>2</sup> <i>Ibid</i>, p. 583</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/416134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 10:58 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/416261/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The enum is only used like (to have empty substring default to english), so no problem with its C++ size:<br>
<p>
const char *curlang(const char *mltstr)<br>
{<br>
  const char *ptr = mltstr;<br>
  for (unsigned cptlang = 0; cptlang &lt; current_language; cptlang++)<br>
     while (*ptr++) {}<br>
  return (*ptr)? ptr : mltstr;<br>
}<br>
<p>
Oviously none of the substrings can have embedded zero char.<br>
<p>
A C++ line of code like:<br>
cout &lt;&lt; "The " &lt;&lt; big? "big " : "small " &lt;&lt; "dog is " &lt;&lt; age &lt;&lt; " year old.";<br>
needs an efficient storage for small strings, even more when doing a multi language software.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor416382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2010 1:03 UTC (Sat)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/416382/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I like your code example, but it might only work in C (not C++).</font><br>
<p>
Sorry, you are confused. It works in both C++ and C.<br>
<p>
<font class="QuotedText">&gt; Using the enum value as an array index might give unpredictable results </font><br>
<font class="QuotedText">&gt; since C++ treats enumerations as a distinct type (instead of int as in C)1</font><br>
<p>
Nope.<br>
<p>
Here the enum is promoted to an integer. C++, like C, promotes a lot of types to integers under the right situations.<br>
<p>
<font class="QuotedText">&gt; The C++ standard library string can have '\0' characters anywhere inside </font><br>
<font class="QuotedText">&gt; the string (which may also lead to unpredictable behavior at runtime)2. Of </font><br>
<font class="QuotedText">&gt; course, you're referring to a C-style string, so this may be a moot point.</font><br>
<p>
There is no std::string in this example. You are confused.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor416056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 12:44 UTC (Thu)
                               by <b>Kwi</b> (subscriber, #59584)
                              [<a href="/Articles/416056/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A better suggestion might be D-style strings, which are dynamic arrays of char. In D, a dynamic array is a (pointer, length) tuple. This gives you the ability to work on substrings without having to allocate new memory, since a substring is nothing more than a new reference to the same character data.<br>
<p>
(Incidentally, Java strings work the same way behind the scenes, but are immutable, which I guess is what you object to when you call them inefficient?)<br>
<p>
Of course, one problem with this suggestion is that it doubles the size of a string reference (8 bytes on 32-bit architechtures, 16 bytes on 64 bit architechtures).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416119"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 16:14 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/416119/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><font class="QuotedText">&gt; (Incidentally, Java strings work the same way behind the scenes, but are immutable, which I guess is what you object to when you call them inefficient?)</font></p>

<p>Exactly. And, my semi-rhetorical question immediately after that (&quot;is there a better way?&quot;) begs the question of whether the Sun engineers who developed the Java language imposed that immutability for thread safety (since thread safety was/is a primary goal of the Java language).  I don't know for sure; just going off intuition here.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/416119/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 10:07 UTC (Fri)
                               by <b>mfedyk</b> (guest, #55303)
                              [<a href="/Articles/416257/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
python has this immutable storage for values as well, but then the stopped and made the GIL...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor416149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null-Terminated Strings</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 18:03 UTC (Thu)
                               by <b>nevyn</b> (guest, #33129)
                              [<a href="/Articles/416149/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do: <a href="http://www.and.org/ustr/">http://www.and.org/ustr/</a><br>
<p>
I think it solves almost all the "normal" problems people have with non-nil terminated strings:<br>
<p>
1. You can easily allocate them on the stack.<br>
<p>
2. You can easily allocate them in constant memory.<br>
<p>
3. "" and "x" don't have overhead in the 1,000% range (depending on how you count).<br>
<p>
...but still has good solutions to the nil terminated strings problems, in that it allows you to have know the allocated size and length used (and put \0 in your string).<br>
<p>
Saying that, the solution was far from obvious ... so while I think it would have been usable in the 1970s, using NIL terminated strings was much more obvious.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor415806"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 10:27 UTC (Wed)
                               by <b>rusty</b> (guest, #26)
                              [<a href="/Articles/415806/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I've always found signal_fd a bit confusing.  After all, the standard method of handling signals in server programs has long been to write to a pipe in the signal hander.  Otherwise you need pselect and related nonsense.  But for normal signals signal_fd didn't add anything except performance.</p>

<p>
Cheers,<br>
Rusty.</p>

What Do We Want? <a href="http://rusty.ozlabs.org/?p=145">LWN Supporter Subscription!</a><br>
When Do We Want it? Before <a href="http://lca2011.linux.org.au/">LCA 2011!</a>
      
          <div class="CommentReplyButton">
            <form action="/Articles/415806/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor415955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2010 23:14 UTC (Wed)
                               by <b>Yorick</b> (guest, #19241)
                              [<a href="/Articles/415955/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The articles in this series progress very neatly from minor inelegancies to serious mistakes. We can only speculate what unspeakable horrors the next installment will feature for our entertainment. The TTY system, perhaps? STREAMS? Or maybe telldir/seekdir?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/415955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">telldir/seekdir</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 16:36 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/416123/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Just curious, why do you consider telldir()/seekdir() to be &quot;unspeakable horrors&quot;?  Their interfaces are simple and straightforward, and even their manual pages are easy to read/understand.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/416123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">telldir/seekdir</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 17:19 UTC (Thu)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/416133/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because of the requirements they impose on filesystem implementations: what happens when you add/delete files from the directory you have open. And with a saved position from "telldir"? How can you stuff enough information into a "long" to allow a stable iteration position in the face of concurrent modification of the directory contents? It's just a pain in the ass to implement.<br>
<p>
And it's so tricky and so unused, that the implementation was actually horribly broken from its inception in BSD until 2008, 25 years later!<br>
<p>
<a href="http://www.vnode.ch/fixing_seekdir">http://www.vnode.ch/fixing_seekdir</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">telldir/seekdir</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 17:31 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/416137/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Ahh yes, I almost forgot about those cases.  In fact, there was <a href="http://lwn.net/Articles/403012/">some discussion here on LWN</a> about the difficulties of these in the context of UnionFS.  Thanks for jogging my memory.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/416137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor416007"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 8:03 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/416007/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's always very amusing to read about problems with permissions and ACLs within Unix and Windows. I cannot understand why developers don't look at the model Novell developed for their Netware systems in the 1980's already.<br>
<p>
In Netware, you could quickly define an unlimited number of users/groups to a dir/file with any privileges that should be available, and you are finished. The filesystem did *not* have to go down to every file and write that ACL/permission there.<br>
<p>
I remember we had a big hierarchical tree, with every department having their working dir, and within that could define another department having access to some subsdirs if wanted. Like this, everything was secure, and every needed access was quickly possible.<br>
<p>
Really, if someone would use that approach for a Linux filesystem, the world would be easier and better. Maybe the btrfs devs read this, then they should look at Netware 3, which already had this neat ACL solution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416007/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416016"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 9:01 UTC (Thu)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/416016/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did I miss the explanation of why Windows ACLs are so horrendous?<br>
<p>
A list of users/groups and their permissions to this object (and optionally its' children) seems pretty straight forward to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416016/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 9:41 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/416020/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Did I miss the explanation of why Windows ACLs are so horrendous?</font><br>
<p>
Maybe you've never had a big file system. Take this example:<br>
<p>
Company with 900 employees, 40TB storage in about 40 departments, with a total of 100 million files.<br>
Now you have a hierachical structure, each dept. has it's own dir, and below that you have other dirs shareable with other depts.<br>
<p>
And then someone needs to set a new permission for a top-level dir. Both Unix and Windows ask to write those permissions to all files below that dir. If there are 10 million entries, the session will be blocked for a pretty long time.<br>
<p>
Novells Netware didn't have that: Set a new permission, done within the second. I don't know how they stored permissions, but it never depended on the amount of data below that dir.<br>
<p>
Also, in Unix and Windows there's a mix of permissions from a share and permissions to a file. In Netware you assigned a right, at that's it. Much easier to review.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 10:14 UTC (Thu)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/416030/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If there are 10 million entries, the session will be blocked for a pretty long time.</font><br>
<p>
Ah, I get you. It's the implementation that's the problem, not the concept.<br>
<p>
<font class="QuotedText">&gt; Both Unix and Windows ask to write those permissions to all files below that dir. </font><br>
<p>
I'm fairly certain Explorer (the Windows shell) uses the most naive method possible for applying permissions.<br>
<p>
<font class="QuotedText">&gt; Also, in Unix and Windows there's a mix of permissions from a share and permissions to a file. In Netware you assigned a right, at that's it. Much easier to review.</font><br>
<p>
For as long as I can remember giving full access to shares to "Everyone", and then using filesystem permisions has been the recommended practise. It is useful occasionally for enforcing "no remote access" policies, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 10:42 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/416037/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; For as long as I can remember giving full access to shares to "Everyone", and then using filesystem permisions has been the recommended practise.</font><br>
<p>
And it brings the feature "you see the share, but clicking on it tells you you can't access it". Again it's the implementation that's wrong: If I have no right on it anyway, don't display it. Seems to be a lazyness of programmers to have chosen this way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 13:55 UTC (Thu)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/416072/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>And it brings the feature "you see the share, but clicking on it tells you you can't access it". Again it's the implementation that's wrong: If I have no right on it anyway, don't display it. Seems to be a lazyness of programmers to have chosen this way.</blockquote>
<p>Counterpoint: <code>/bin/ls</code> lists the names of directories not owned by the user it's running as whose access control mode is 0700 (user rwx, all others forbidden).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/416072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 14:04 UTC (Thu)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/416087/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><i>Counterpoint: <tt>/bin/ls</tt> lists the names of directories not owned by the user it's running as whose access control mode is 0700 (user rwx, all others forbidden).</i>

<p>Which is perfectly correct behavior according to the way UNIX permissions are defined.  The ability to list names in a directory is controlled only by the <tt>r</tt> bit of the directory itself.

      
          <div class="CommentReplyButton">
            <form action="/Articles/416087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 14:16 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/416088/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ls is a technical unix command, not a user tool (which "clicki-clicki" mouse user knows ls?). ls must show everything, and it follows the kiss principle (keep it small and simple).<br>
<p>
Using a graphical dir browser like Dolphin could hide such unreadable contents, that would be nice, as normally users don't need to see that. Should be a config option.<br>
<p>
Browsing a server over the network is about 20 years younger "command", solving completely different needs, and it would help security a bit if shares not accessible are not seen by a user. But by the time Microsoft reinvented networking, they did not have the slightest clue about security (and I'd say that only started with Win7, where a user can work as user not admin). Maybe we'll see that improvement once someone at Microsoft gets the idea. Or maybe the Samba team can implement a setting to hide this, and later MS adopts it as it's clever.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor416443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2010 0:27 UTC (Sun)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/416443/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That issue seems completely unrelated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor416147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 17:57 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/416147/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also from Multics: it is relatively parsimonious, and has the concept of "initial acls", so it really only needs to store acls that are different from the iacl (or from the base acl of the tree).<br>
<p>
--dave<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor416185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 20:38 UTC (Thu)
                               by <b>jra</b> (subscriber, #55261)
                              [<a href="/Articles/416185/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Ah, I get you. It's the implementation that's the problem, not the concept.</font><br>
<p>
No, with Windows ACLs it's the concept.<br>
<p>
Look at this:<br>
<p>
<a href="http://www.pcguide.com/ref/hdd/file/ntfs/secRes-c.html">http://www.pcguide.com/ref/hdd/file/ntfs/secRes-c.html</a><br>
<p>
as an example. Explain that to a user. Don't forget to include why the sort order of DENY's ACE's depends on where in the file hierarchy they came from.<br>
<p>
Good luck ! :-)<br>
<p>
Jeremy.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2010 0:31 UTC (Sun)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/416444/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You recurse up the tree, until you find an applicable entry, with deny taking precedence over allows.<br>
<p>
How is that complicated?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor416018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 9:05 UTC (Thu)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/416018/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(Oops, wrong reply button.)<br>
<p>
---<br>
<p>
Could you explain the Netware model a bit more? It just sounds like ACLs to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 10:38 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/416023/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, but not stored within the filesystem, I believe. It never took more than a millisecond to assign a right, no matter how much data was below this dir.<br>
<p>
Also, the way you assigned rights was simple: take an object (user, group, department, etc.), assign it to a dir with rights, and specify if it's for subdirs as well or only this dir.<br>
<p>
And when you didn't have a right on a dir, you didn't even see it. I dislike the Windows approach of seeing a share, and upon click you get the info "no permission". That's just stupid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 11:09 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/416042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That would be a nice addition to file managers like Nautilus or Dolphin. Not even showing whatever you cannot open would remove much clutter. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor416167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 18:43 UTC (Thu)
                               by <b>jeremiah</b> (subscriber, #1221)
                              [<a href="/Articles/416167/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So permissions were only on the directory? and there were no file specific ACL?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 22:06 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/416208/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could make file ACLs also. But if you specified a dir ACL, it was taken for each file in that dir automatically. That makes sense, as most things are done on a per-dir base anyway, right? At least, if you have a system supporting it that way, you automatically use that approach to order things in directories, as it makes life - and administration! - much easier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor416169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 19:05 UTC (Thu)
                               by <b>jeremiah</b> (subscriber, #1221)
                              [<a href="/Articles/416169/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One ACL approach I tried to take once, but the product got dropped before I could see the problems was the following:<br>
<p>
you had a file/object, and a list of permissions/security attributes for each object. Object could be a group of objects, but group depth was not a concern. Mutiple applications (controlled by us) could access the permissions, and make decisions based on what they found. If there was a permission that they didn't understand, access was not allowed. This was a situation where we could trust the apps, and not the people. We also took the approach that permissions were subtractive. Everything started as readable/writable and access could only be removed. The nice thing about this was that it was extendable.<br>
<p>
This isn't relevant to Novell ACL's just trying to get people's thoughts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 22:09 UTC (Thu)
                               by <b>zmi</b> (guest, #4829)
                              [<a href="/Articles/416209/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From a security point of view, I don't like it. A system should deny everything, and only allow what I explicitly allow. The "default everybody everything yes" way you describe is so Windows, and it's for this reason most viruses are for this system today.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 23:41 UTC (Thu)
                               by <b>jeremiah</b> (subscriber, #1221)
                              [<a href="/Articles/416222/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
but it seems much harder to administer the other way around. Once something is marked as inaccessible, that's it. You get to stop looking. Where as it seems like when something is marked as visible you have to establish some sort of hierarchy in case a parent thinks it shouldn't be visible. Which would be indicated by nothing being set. Or you run into a situation like unix where you have permissions going either direction and you have to again determine which overrides which. I guess that would be a fail safe as opposed to a fail open though, which I prefer. But SELinux is a clear demonstration of how complicated things can get if you do it in a complete fashion. Starting with the idea that everything is hidden from everything first, and then transitions are made between them. Yet the bail when it comes to initrc, and almost mark everything as visible first.    <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2010 13:19 UTC (Fri)
                               by <b>jeremiah</b> (subscriber, #1221)
                              [<a href="/Articles/416275/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I feel the urge to clarify my initrc comment. Although it's been a while since I dealt with it, here's what I remember, and some context. I run a payment gateway, so we decided to use SELinux to enforce a true division of roles. We made root a second class citizen to the role a user belonged to. The most difficult part of doing this was that root could transition through rpm_t into initrc_t into any other role on the system. The idea, I think, being that root should be able to install packages, and packages, if they were related to a service, should be able to restart themselves. This had the unwanted effect of giving root the ability to transition to just about anything. Trying to remove the 20 bazillion independent transition paths took a hard 2 weeks. This was with the reference policy, and not a vendor supplied policy, which is much more strict than the strict policy. What it really boiled down to, is what it always boils down to in the end. That delicate balance between usability, and security. In the end it was doable, but it wasn't easy. <br>
<p>
I think SELinux is amazingly complete. It allowed us to implement a solution that always requires 2 users, from a group of 3. You throw LUKS, encrypted drives, and removable media into the mix, and you have as close to a bullet proof scenario as possible. On the other hand, I don't want to have to write code that the average admin can't administer without spending a month dealing with a sharp learning curve. <br>
<p>
Like a lot of us here I'm a developer, and a system administrator. When I have my development hat on I try to think of the user, and what they have to put up with, while balancing it with security requirements etc. As an administrator, I know I'm willing to tolerate more than most users. The difficult part for me, is defining my target audience, and understanding their abilities and tolerance, and shooting for that. And sometimes the perfect solution, has to be hobbled security wise, or the product won't sell. The only way I've found to begin addressing that is though intelligent defaults, and meaningful dialogs/user interaction.<br>
<p>
I am intrigued by the Netware ACL's though, since you seem to have found a happy place when dealing with them as opposed to other permission systems. Thanks for the input.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor416445"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Access Control: take them from Novell Netware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2010 0:35 UTC (Sun)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/416445/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The reason that most viruses are for Windows is the user, plain and simply the huge number of "users". &lt;/OT&gt;<br>
<p>
If you don't find a specific ACE allowing you access, you don't have access.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416445/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor416213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2010 23:11 UTC (Thu)
                               by <b>skissane</b> (subscriber, #38675)
                              [<a href="/Articles/416213/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding permissions, I think they ideally should not be stored with the files, but in some kind of separate security database. Then, one can easily review and manage them in aggregate. Much safer than littering the file system with them.<br>
<p>
I don't think evaluating access control should belong in the kernel. Policy questions like this should be handled by a trusted user space process. When a process tries to access a resource, the kernel should ask the security daemon if it is OK. The security daemon can do whatever you want to answer that, and then just tell the kernel permit or deny. There could be several different security daemons to choose from, depending on needs. A smartphone, or home users desktop, will have very different needs from a server operated by an intelligence agency - rather than one system to fit all needs, multiple systems for different needs may be better.<br>
<p>
In principle, what I am suggesting is similar to how I understand RACF (and TopSecret and ACF2) work on IBM mainframes. (OK, not all the associated mainframe-warts, but I think the basic idea is good.) The security software is an add-on to the base OS, the base OS just exposes standard hooks for the security software to integrate with.<br>
<p>
To avoid the performance hit of constantly context-switching to the security daemon, the kernel should have some kind of cache. That way, first time process tries to access a resource, kernel asks security daemon for OK. If daemon says yes, then kernel remembers and doesn't need to ask again. If everything is a file descriptor, a good time to do this would be at OPEN time - the kernel asks once when FD is open what access will be permitted for that FD, then remembers that for duration of FD.<br>
<p>
I suppose this is the classical capability architecture - if everything is an FD (or in Windows-ese, a "handle"), then we can merge the concepts of FDs with capabilities. And a security daemon is then used at FD/handle creation time to determine for the lifetime of the FD/handle what it can do. It might need to be consulted occasionally once FD is created - e.g. is it OK to pass this FD to another process? Also, if the security permissions are revoked while FD is open, the daemon should be able to ask kernel to forcibly close, or downgrade the rights, of an FD it earlier approved to be opened.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/416213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor416378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2010 0:32 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/416378/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You've hit the nail on the head better than any of the other comments or the article itself, by talking not about what the right permission scheme for all future applications is, but a fixable design that lets us recover if we pick the wrong permission scheme today.
<p>
Incidentally, I think the separateness of RACF happened out of necessity more than architecture.  The filesystem formats were already cast in stone with no concept of permissions whatsoever in them.  There was no concept of a user identity either.  I don't know if designers of RACF considered building all that into the supervisor code and felt it would be less fixable that way or just that it would be harder, but I do like the result.
<p>
RACF and its alternatives also encompass resources other than files.
<p>
I think there are plentiful examples of this on Linux too, but I don't follow those things.  Selinux?  AppArmor?

      
          <div class="CommentReplyButton">
            <form action="/Articles/416378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor417271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ghosts of Unix past, part 3: Unfixable designs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2010 20:18 UTC (Thu)
                               by <b>slashdot</b> (guest, #22014)
                              [<a href="/Articles/417271/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux does this, although security is handled by kernel modules ("LSM"s) instead of daemons.<br>
<p>
AppArmor has separately-stored policy, while SELinux has separately-stored policy which is however automatically baked into the filesystem.<br>
<p>
The real problem Linux has is that nobody seems to have the interest, authority and/or ability to figure out the optimal security model to use, so there are several ones in wide use, but none is actually polished and widespread.<br>
<p>
Also, security UI and user-friendliness work seems quite lacking, with the result that advanced security often gets just turned off and even if enabled, only distribution-provided policies tend to be used.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor417348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Six bytes?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2010 13:16 UTC (Fri)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/417348/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you mean the basic rwxrwxrwx permission bits.  That's two bits less than a byte, not six bytes :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Six bytes?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2010 15:02 UTC (Fri)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/417361/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd really like to know on what architecture bytes have eleven bits.  ;-)<br>
<p>
The user and group bits wouldn't make much sense without the corresponding IDs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417643"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Six bytes?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2010 19:57 UTC (Mon)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/417643/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True I fail to multiply 3 by 3 :)  So it's nine bits.  The suid, sticky, and sgid make it twelve if you count them -- one and a half bytes.<br>
<p>
However if you are going to count uid and gid those then it started with 2+2+1.5 = 5.5 bytes (sounds like the count in the article I agree), but it moved to 4+4+1.5 = 9.5 bytes.  Since the point was that this was something which can't be changed (and hasn't except for POSIX ACLs which are mostly ignored) I don't think that's what the author meant.<br>
<p>
But maybe it's true. He seems to be responding to comment so he can clear it up very easily.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417643/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Six bytes?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2010 21:20 UTC (Mon)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/417655/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, that is what I meant.<br>
<p>
As you say, permission information only uses 5bytes and 1 bit (setuid etc are not permission bits, they are really the 'type' of the object and so are is some ways more closely related to IF_REG etc).  Being that precise in the article would have been excessive I think.  It is still true that the permissions were stored in 6 bytes.  It is just that some room was left over for file type as well.<br>
<p>
POSIX ACLs may well be mostly ignored, but ACLs are still the only direction being explored for making the permission model more complete.  My point was simply that they have a storage cost which gets worse quickly, but worse than that it has a serious usability cost.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor417349"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The &quot;impossible&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2010 14:04 UTC (Fri)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/417349/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article says in reference to applying complex group-based permissions: "The simple is certainly simple, but the complex is truly impossible."<br>
<p>
Clearly you haven't had to find a way to do it. :)   There are a few different ways.<br>
<p>
The easiest way to be able to apply permissions for more than one group is to create many additional groups which are unions of the others by putting the users in them.  Yes, now you get to maintain these.  It's best to write a tool to generate them.<br>
<p>
If you want intersections you can do that with groups too, or by nesting subdirectories and applying the traversal permissions for each group to those.<br>
<p>
But what if you want to mix read permission for one set of groups with write permission for another?<br>
<p>
Well, you have to use the file's real write bit and group owner for the write permission since that's the only way to control it traditionally.  Then use the parent directory's permissions to prevent read access from anyone not in the second set of groups and set the file's world-readability bit.<br>
<p>
If you want to grant execute permission to a third set of groups -- that's a problem.  That one really is impossible but execute doesn't mean much if you can read something (and it's not suid or sgid).<br>
<p>
Please don't think I'm saying any of that is nice or preferable to POSIX or Windows ACLs, because it clearly sucks horribly for so many use cases, but it does should that it is possible to apply read/write permissions to arbitrary sets of groups if you're willing to deal with this kind of setup.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417349/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor417417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The &quot;impossible&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2010 22:23 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/417417/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you actually had to implement something like this - which the second line seems to suggest, you have my sympathies!<br>
<p>
Yes: it does seem that it was a slight over-statement to say "impossible".  If you have unlimited groups per user, allow users to create their own groups, and don't worry too much about giving new access to already-running processes, then many complex things are indeed possible.<br>
<p>
Maybe we need a different maxim:  "simple things should be simple, complex things shouldn't drive you insane" !<br>
<p>
Thanks for your thoughts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/417417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
