        <!DOCTYPE html>
        <html lang="en">
        <head><title>Short topics in memory management [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/224829/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/224247/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/224829/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Short topics in memory management</h1>
<div class="Byline">[Posted March 6, 2007 by corbet]
               <p>
               </div>
</div>
<div class="ArticleText">
Memory management has been a relatively quiet topic over much of the life
of the 2.6.x kernels.  Many of the worst problems have been solved and the
MM hackers have gone on to other things.  That does not mean that there is
no more work to do, however; indeed, things might be about to heat up.  A
few recent discussions illustrate the sort of pressures which may lead to a
renewed interest in memory management work in the near future.
<p>

Mel Gorman's fragmentation avoidance patches have been discussed here a few
times in the past.  The core idea behind Mel's work is to identify pages
which can be easily moved or reclaimed and group them together.  Movable
pages include those allocated to user space; moving them is just a matter
of changing the relevant page table entries.  Reclaimable pages include
kernel caches which can be released should the need arise.  Grouping
these pages together makes it easy for the kernel to free large blocks of
memory, which is useful for enabling high-order allocations or for vacating
regions of memory entirely.
<p>

In the past, reviewers of Mel's patches have disagreed over how they should
work.  Some argue in favor of maintaining separate free lists for the
different types of allocations, while others feel that this sort of memory
partitioning is just what the kernel's zone system was created to do.  So,
this time around, Mel has posted two sets of patches: a <a
href="http://lwn.net/Articles/224254/">list-based grouping mechanism</a>
and <a href="http://lwn.net/Articles/224255/">a new <tt>ZONE_MOVABLE</tt>
zone</a> which is restricted to movable allocations.
<p>

<a
href="http://www.skynet.ie/~mel/anti-frag/2007-02-28/page_type_distribution.jpg"><img
src="https://static.lwn.net/images/ns/kernel/gorman-page-distribution.jpg" width=150 height=189
alt="[page distribution graphic]" hspace=2 border=0 align="right"></a>

The difference this time around is that the two patches are designed to
work together.  By default, there is no movable zone, so the list-based
mechanism handles the full job of keeping alike allocations together.  The
administrator can configure in <tt>ZONE_MOVABLE</tt> at boot time with the
<tt>kernelcore=</tt> option, which specifies the amount of memory which is
<i>not</i> to be put into that zone.  In addition, Mel has posted <a
href="/Articles/224835/">some comprehensive information</a> on how
performance is affected by these patches.  In an unusual move, Mel has
included a set of videos showing just how memory allocations respond to
system stress with different allocation mechanisms in place; the image at
the right shows one frame from one of those videos.  The demonstration is
convincing, but one is left with the uneasy hope that the creation of
multimedia demonstrations will not become necessary to get patches into the
kernel in the future.
<p>

These patches have found their way into the -mm tree, though Andrew Morton
is still unclear on whether he thinks they are worthwhile or not.  Among
other things, he is concerned about how they fit with other, related work,
especially memory hot-unplugging and per-container memory limits.  While
patches addressing both areas have been posted, nothing is really at a
point where it is ready to be merged. <a href="/Articles/224839/">This
discussion between Mel and Andrew</a> is worth reading for those who are
interested in this topic.
<p>

The hot removal of memory can clearly be helped by Mel's work - memory
which is subject to removal can be restricted to movable and reclaimable
allocations, allowing it to be vacated if need be.  Not everybody is
convinced that hot-unplugging is a useful feature, though.  In particular,
Linus <a href="/Articles/224842/">is opposed to the idea</a>.  The biggest
potential use for hot-unplugging is for virtualization; it allows a
hypervisor to move memory resources between guests as their needs change.
Linus points out that most virtualization mechanisms already have
mechanisms which allow the addition and removal of individual pages from
guests; there is, he says, no need for any other support for memory
changes.  
<p>

Another use for this technique is allowing systems to conserve power by
turning off banks of memory when they are not needed.  Clearly, one must be
able to move all useful data out of a memory bank before powering it down.
Linus is <a href="/Articles/224844/">even more dismissive</a> of this idea:
<p>
<div class="BigQuote">
	The whole DRAM power story is a bedtime story for gullible
	children. Don't fall for it. It's not realistic. The hardware
	support for it DOES NOT EXIST today, and probably won't for several
	years. And the real fix is elsewhere anyway...
</div>
<p>
More information on his objections is available <a
href="/Articles/224846/">here</a> for those who are interested.  In short,
Linus thinks it would make much more sense to look at turning off entire
NUMA nodes rather than individual memory banks.  That notwithstanding, Mark
Gross has posted <a href="http://lwn.net/Articles/224746/">a patch enabling
memory power-down</a> which includes some basic anti-fragmentation
techniques.  Says Mark:
<p>
<div class="BigQuote">
	To be clear PM-memory will not be useful unless you have workloads
	that can take advantage of it.  The identified workloads are not
	desktop workloads.  However; there is a non-zero number of
	interested users with applicable workloads that make pushing the
	enabling patches out to the community worth while.  These workloads
	tend to be within network elements and servers where memory
	utilization tracks traffic load.
</div>
<p>
It has also been suggested that resident set size limits (generally
associated with containers) can solve many of the same problems that the
anti-fragmentation work is aimed at.  Rik van Riel was <a
href="/Articles/224848/">heard to complain</a> in response that RSS limits
could aggravate the scalability problems currently being experienced by
the Linux memory management system.  That drew questions from people like
Andrew, who were not really aware of those problems.  Rik <a
href="/Articles/224850/">responded</a> with a few relatively vague
examples; his ability to be specific is evidently restricted by agreements
with the customers experiencing the problems.
<p>

That led to a whole discussion on whether it makes any sense to try to
address memory management problems without test cases which demonstrate
those problems.  Rik <a href="/Articles/224851/">argues</a> that fixing
test cases tends to break things in the real world.  Andrew <a
href="/Articles/224853/">responds</a>:
<p>
<div class="BigQuote">
	Somehow I don't believe that a person or organisation which is
	incapable of preparing even a simple testcase will be capable of
	fixing problems such as this without breaking things.
</div>
<p>
Rik has put together <a href="http://linux-mm.org/ProblemWorkloads">a page
describing some problem workloads</a> in an attempt to push the discussion
forward.
<p>

One of Andrew's points is that trying to fix memory management problems
caused by specific workloads in the kernel will always be hard; the kernel
simply does not always have the information to know which pages will be
needed soon and which can be discarded.  Perhaps, he says, the right answer
is to make it easier for user space to communicate its expected future
needs.  To that end, he put together <a
href="http://lwn.net/Articles/224653/">a pagecache management tool</a> for
testing.  It works as an <tt>LD_PRELOAD</tt> library which intercepts
file-related system calls, tracks application usage, and tells the kernel
to drop pages out of the cache after they have been used.  The result is
that common operations (copying a kernel tree, for example) can be carried
out without forcing other useful data out of the page cache.
<p>

There were some skeptical responses to this posting.  There  was also
some interest and some discussion of how smarter, application-specific
policies could be incorporated into the tool.  A <a
href="/Articles/224855/">possible backup tool policy</a>, for example,
would force the output file out of memory immediately, track pages read
from other files and force them back out - but only if they were not
already in the page cache, and so on.  It remains to be seen whether
anybody will run with this tool and try to use it to solve real workload
problems, but there is some potential there.  The kernel does not always
know best.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Hotplug-Memory">Hotplug/Memory</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management">Memory management</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/224829/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor224950"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 6:18 UTC (Wed)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/224950/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      I'd like to see a real memory reservation system in Linux, using kernel events to notify userland of memory pressure and having applications dynamically adjust their own caches/etc. as needed.<br>
<p>
I brought this up on lkml a while ago, and suggested a combination of netlink events passed over D-BUS to listening applications as one way to achieve this - for example, telling Firefox that memory pressure means it needs to stop using ludicrously large in-memory caches of the last 10 pages visited so the rest of the user session isn't killed by the thrashing to disk that follows.<br>
<p>
Having briefly played with this, I lost interest due to lack of time (and perhaps also a lack of intimate knowledge of the VM system) but I'd like to revive this if anyone is interested in helping out.<br>
<p>
Jon.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224950/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor224959"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 9:02 UTC (Wed)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/224959/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      I'm ignorantly curious about the problems you're trying to address.  Isn't the solution to "the firefox problem" to cache almost all data on disk?  Linux seems really great about keep disk data in memory when there isn't pressure and reclaiming it when necessary.  Am I misunderstanding that problem, and is what you are trying to address really a different problem?<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224959/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor224970"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 11:28 UTC (Wed)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/224970/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The cache's he's referring to in the firefox case are explicitly the in-memory ones -- while in principle an app could write such caches out to disk and trust the OS to make accessing that data as efficient as reasonable, in practice this may require major restructuring of your app.  Firefox *does* cache pages on disk, of course, but it also has a smaller in-memory cache of fully parsed and rendered pages; the point of this is to avoid the re-rendering (and re-executing javascript, etc.) overhead of going to the normal disk cache (which just stores html files), and there's no reasonable way to take giant in-memory object graphs and write them do disk directly.<br>
<p>
Now OTOH one would hope Linux would be clever about reclaiming memory by writing such memory out to swap... though various things could thwart this, e.g., if Firefox has a garbage collector tromping over those pages and keeping them resident, or if its memory is sufficiently fragmented that objects that are just being kept around as a cache, and objects that are in active use, happen to share pages.<br>
<p>
These are just potential problems, though; I have no idea if they come up in practice.  The firefox I'm typing this in seems to be about 300 megabytes total, but about 100 of those have been pushed out to swap, even during active use on a lightly loaded system without much memory pressure.    Now, of course, it might be that those 100 megabytes are unused because they were actually leaked or something, but it is at least suggest that the "firefox problem" is not as bad as the original poster thinks.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224970/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor224979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 13:35 UTC (Wed)
                               by <b>dion</b> (guest, #2764)
                              [<a href="/Articles/224979/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      I think you might be right.<br>
<p>
Firefox probably thinks we are living in 1970 when there wasn't anything called virtual memory, so it allocates gobs of RAM for caches and does explicit file io.<br>
<p>
A much better way would be to have just one cache in one huge memory mapped file, that way there is never any explicit io and the kernel is free to write stuff out to disk whenever it needs to.<br>
<p>
It would make a persistent cache a bit tricky, you could never do anything with the cached files using normal tools and crashing would be interesting, though.<br>
<p>
Someone working on firefox should take a peek at Varnish, which is incredibly fast because it lets the kernel do all the hard memory/io work.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor224987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Stuck with 1970s VM?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 15:57 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/224987/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Don't forget, Firefox has to run on Windows, too.  ;-)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor224994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Stuck with 1970s VM?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 16:38 UTC (Wed)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/224994/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      As far as I remember Windows got memory-mapped files starting at least with Windows-95. Surely the API is different, but it is straightforward to isolate the difference behind a tiny wrapper. The best thing about it is that since the memory mapping removes explicit reads/writes from the application, the end result is more portable code.  <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor224996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Stuck with 1970s VM?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 16:44 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/224996/">Link</a>] 
      </p>
      
      </div>
      </summary>
      *whoooosh*<br>
<p>
That's the sound of a tongue-in-cheek jab at Windows going over your head.  :-)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor224995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 16:50 UTC (Wed)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/224995/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It would make a persistent cache a bit tricky,</font><br>
<p>
The trick is to use relative offsets instead of pointers in the data that goes into the mapped file. It has an extra benefit of a more secure code since it is easier to add bound-check for the offsets then checking the pointers.    <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/224995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 17:47 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/225018/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Checking offset bounds may look easier than a pointer, but it isn't really.  A pointer is nothing but an offset from memory location 0, after all.<br>
<p>
if( pointer &gt; mmap_base &amp;&amp; pointer &lt; mmap_end ) ...<br>
<p>
Using an unsigned int offset instead saves you from checking the lower bound, but you lose that savings again the instant you segment your memory into different uses, like using some for text and some for graphics.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 23:57 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/225367/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>"A pointer is nothing but an offset from memory location 0, after all."
</P><P>
Well, <I>these days</I> it is on most architectures...
</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor225019"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 17:49 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/225019/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      One problem with large mmaps is fragmented virtual memory.  It is very possible with 32-bit addressing to end up in a situation where you *cannot* allocate a single block of virtual.  Especially if you are doing things where you grow your maps, reposition them, etc.  Then you need crazy stuff like a mmap defragmenter where you flush it all to disk, unmap it and remap everything again.<br>
<p>
All the problems could be solved of course, but who is going to rewrite all that code?  Again.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225019/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 18:14 UTC (Wed)
                               by <b>dion</b> (guest, #2764)
                              [<a href="/Articles/225038/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Well, the solution is to "not do that, then".<br>
<p>
If I were to implement a browser cache in a memory mapped file then the mapping would be the first thing to get allocated and it would never change.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor225054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2007 20:11 UTC (Wed)
                               by <b>aanno</b> (guest, #6082)
                              [<a href="/Articles/225054/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      There are indeed indications for the opinion that collaboration of kernel MM and 
user space tools could improve performance. <a 
href="http://www-cs.canisius.edu/~hertzm/">Matthew Hertz</a> did some 
academic research on the topic. His <a 
href="http://www-cs.canisius.edu/~hertzm/bc.html">bookmarking collector</a>, a 
garbage collection algorithm for the Java VM <em>is</em> impressing. 
<p/>
I might be that garbage collection languages will predominant computer 
programming soon. I could soon be annoying that MM of many OS (including 
Linux) does not handle garbage collection as good as could be imagined. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/225054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225114"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 8:26 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/225114/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      It would be most unfortunate if GC-ridden languages came to predominate.  It is practically impossible for an OS memory manager to "handle" GC well, just as it is practically impossible for the program itself to do so.  It is in the nature of GC to interact badly with caches, and we are ever more dependent on an increasing variety of caches.
<p>
Every time the above is pointed out, somebody pops up and says that some new or old wrinkle has potential to mitigate the problems.  Invariably there's a paper with lots of artificial benchmarks, running on a machine dedicated to nothing but running those benchmarks.  Invariably such programs interact badly with real programs on real machines.
<p>
Besides its fundamental problems, GC never advances much because it can't be encapsulated.  For every place that needs it, it must be re-done from scratch.  The cunning tricks of the last implementation don't work in the next.
<p>
Academia can't see limitations of GC because the ideal academic program only ever manages memory.  Real-world programs must manage other much more limited resources -- network sockets, database connections, disks -- and any method sufficient to manage them suffices for memory as well.  No current language threatens C++ for serious programming, however useful such a language would be.  In large part this is because any such rival would first need to impress academics who, for the most part, have no clue about what makes a language actually useful.
      
          <div class="CommentReplyButton">
            <form action="/Articles/225114/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 10:55 UTC (Thu)
                               by <b>aanno</b> (guest, #6082)
                              [<a href="/Articles/225134/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      I completly agree with you, mcn. Cache locality will probably never be fixed with 
GC based languages. But as far as I understand, in many GC algorithms, there is 
also a 'walker' that marks memory that is not reachable any more. It is a bad idea 
to walk onto a swapped-out page, though.
<p/>
And I <em>could</em> imagine that this problem could be diminished. The paper 
I 
linked to takes this direction.
<p/>
Even if GC based language will not predominate, they have to be taken into 
account more than let's say 20 years ago. The fact that many Linux users don't 
like Java or .NET will not make this langauges to disappear. And even if they 
would, what's about Python, Ruby, Perl and the like?
<p/>
GC is even mentioned in this discussion to be used within firefox (see above). 
And I heart that the GCC suite also uses GC (beginning with version 3.0).
<p/>
GC will always be problematic. But it is a thing that could be improved by 
collaboration of kernel and user land knowledge. My point of view is that the 
research of Hertz points to the right direction. I was interesting to read that this 
sort of collaboration could also solve other MM related problems.
      
          <div class="CommentReplyButton">
            <form action="/Articles/225134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225154"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 12:22 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/225154/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, GCC 3.0 did start using GC (because the lifetime rules of objects in the compiler were unfathomably complex). It fixed an unknown but large number of bugs... and slowed down the compiler a *lot* due to cache locality issues.<br>
<p>
Years ago now, someone (Mike Stump?) ran some benchmarks that showed GCC incurring cache stalls every *twenty instructions* or thereabouts. Small wonder that it slowed down!<br>
<p>
Careful moves are now underway (and have been for a while) to migrate objects with simple lifetime rules back into obstacks. The obstacks are still garbage-collected, but the obstack is a *single* GCed object with good cache locality, where the myriads of objects it replaces were not.<br>
<p>
I doubt GCC will ever leave GCC, either: for objects with complex lifetime rules, there's really no maintainable alternative. But for the simple ones, using suballocators with better cache locality (like obstacks) is a good idea.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225154/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor225199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 15:25 UTC (Thu)
                               by <b>pflugstad</b> (subscriber, #224)
                              [<a href="/Articles/225199/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <i>But as far as I understand, in many GC algorithms, there is also a 'walker' that marks memory that is not reachable any more. It is a bad idea to walk onto a swapped-out page, though.</i><p>
This has not been the case for several years now.  Most GCs (certainly in Java) systems use a 
<A href="http://www-128.ibm.com/developerworks/java/library/j-jtp11253/">
generational/compacting collector.</a>  As such, dead objects aren't touched at all.  And this was 3+ years ago - it's gotten even better since then.  When you do Java, you really do need to re-think how you program.
<p>
As someone else said, GC is everywhere these days, even embedded.  The ease and clarity of developing in a GC language (Python, Perl, Java, etc), far outweigh the performance penalty  you may see with GC.  This is especially true for the vast majority of programs where performance is not seriously a concern, such as those with human interactions.  I've done a lot C.  I've done a lot of C++.  I've done Python.  I've done Java.  I'll take Python/Java 6 days a week (but not twice on Sundays - sometimes you do need performance :-). 
      
          <div class="CommentReplyButton">
            <form action="/Articles/225199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 16:32 UTC (Thu)
                               by <b>aanno</b> (guest, #6082)
                              [<a href="/Articles/225231/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Right. I oversimplified this. Generational/compacting collectors have no walker but 
(a) have a second indirection (that slows down things) and (b) are not memory 
efficient (as they roughly use twice the space that is theoretically needed). 
Certainly Hertz compares his GC against this type. Refer to the paper to get all 
the details.
      
          <div class="CommentReplyButton">
            <form action="/Articles/225231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor225322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 20:35 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/225322/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Python is not, at present, a GC language.  Neither is Perl.  <br>
<p>
However, people are working on GC implementations.  Expect complaints about cache abuse by scripts, too, soon.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2007 0:04 UTC (Fri)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/225364/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Python is certainly a GC language (since version 2.0).  It happens to optimize that GC by using reference counting to catch the easy cases, and only doing mark/sweep type stuff occasionally to catch reference cycles, but it definitely has a full GC.<br>
<p>
I'm told that some of the hottest Java GC techniques actually involve reference counting these days, because you can massively optimize your actual walking -- the only time a cycle can be created is when a reference count is decremented, and thus achieves a number greater than 0.  This is pretty rare, and it also tells you that any cycle that was just created must involve that object in particular, so you don't have to tromp through all memory either.<br>
<p>
None of this affects your original point, though, because reference counting already trashes caches by itself -- especially in the multiprocessor case, where supposedly read-only access to variables is suddenly triggering cache flushes...<br>
<p>
Depending on your cache hierarchy and the characteristics of your GC, you can minimize its impact, though.  E.g., in gcc, I thought I remember some trick where you only run the collector between passes, since you know already that that's when everything becomes garbage, and also where it doesn't matter if you trash the cache?  Similarly, Graydon was saying something about in initial implementations of firefox's GC, they would just run it after page load, because no-one notices if the browser pauses for 400 milliseconds then, they're just looking at the page.<br>
<p>
Long run: build garbage collection into the RAM hardware!  That'll work around those pesky cache issues ;-)<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor225169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GC languages and domination</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 14:46 UTC (Thu)
                               by <b>kevinbsmith</b> (guest, #4778)
                              [<a href="/Articles/225169/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      For web servers, GC languages already dominate. Java, obviously, plus PHP, perl, python, and ruby. Who writes CGI in C or C++ any more? Sure, a few folks, but not many.<br>
<p>
On the desktop, I can't think of a single GUI app that I would rather write (or see written) in C or C++ instead of one of the languages mentioned above. Heck, even command-line utilities are often (usually?) written in perl or some other scripting language (not to mention bash). I guess it depends on your definition of "serious" programming.<br>
<p>
Like it or not, GC is pervasive, and still increasing in popularity. It just makes sense to have the inexpensive computers do the extra work instead of the expensive programmers.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GC languages and domination</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 19:41 UTC (Thu)
                               by <b>nevyn</b> (guest, #33129)
                              [<a href="/Articles/225309/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
For web servers, GC languages already dominate.
</blockquote>

<p> Err, no. Yaws is about the only major Web server that <b>isn't</b> written in C. And that's entirely because C is the only thing that performs well enough.
</p>
<p> For the CGI like "backend", yes GC languages dominate mainly because performance isn't as big a problem and the real web server can take actions to limit the performance problem of the GC'd language code. Also the person running the application is often closely tied to the person writting it, and so they can throw money at their users performance problems.
</p>

<blockquote>
On the desktop, I can't think of a single GUI app that I would rather write (or see written) in C or C++ instead of one of the languages mentioned above.
</blockquote>

<p> There are still very few GUI applications that aren't written in C, and again it's mainly because of performance and memory usage. For instance the "revelation GNOME applet" is currently ~125MB big, with an RSS of 32MB; this is a python application that provides a single text entry and an icon on my panel ... it is far from unique. About the only major GC'd application I use is xemacs, and it's all too often that I reboot it due to memory usage spiraling out of control (and I wouldn't call it fast).
</p>

<blockquote>
It just makes sense to have the inexpensive computers do the extra work instead of the expensive programmers.
</blockquote>

<p> That is wrong in two ways: 1) The computers are now not doing real work for their users, instead they are doing busy work for the programers (on the users time). 2) Doing it properly is often not that expensive for a good programer, who already has to manage other reasources. But, yes, users are often still letting programers charge them millions of units of work in exchange for not having to do a single unit themself. I doubt any economy can make this sustainable, long term, and you only have to look at people using dillo and/or lighttpd to see the choices being made.
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/225309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor225415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GC languages and domination</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2007 11:45 UTC (Fri)
                               by <b>aanno</b> (guest, #6082)
                              [<a href="/Articles/225415/">Link</a>] 
      </p>
      
      </div>
      </summary>
      This is a very biased opion. Dynamic web content is often delivered by J(2)EE applications - especial in (big) enterprise environments. The infrastructure for this is also Java based, like like <a href="http://labs.jboss.com/portal/jbossas">JBoss</a> or <a href="http://tomcat.apache.org/">Tomcat</a>. There are also desktop application that uses GC based languages: <a href="http://www.eclipse.org/">Eclipse</a>, <a href="http://www.netbeans.org/">NetBeans</a>, <a href="http://beagle-project.org/Main_Page">beagle</a>. 
<p/>
In enterprise environments Eclipse RCP has become <em>the</em> plattform for fat client programming.
<p/>
On the other hand there are applications written in C/C++ that waste tons of memory, like <a href="http://www.mozilla.com/en-US/firefox/">Firefox</a> or <a href="http://gaim.sourceforge.net/">Gaim</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/225415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor225542"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GC languages and domination</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2007 11:04 UTC (Mon)
                               by <b>ekj</b> (guest, #1524)
                              [<a href="/Articles/225542/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>1) The computers are now not doing real work for their users, instead they are doing busy work for the programers (on the users time).</i><p>

Users are free to choose. If programs written in non-GCed languages where enough faster that this mattered to the users, they'd be perfectly free to use those programs then. For some kinds of programs this *is* the case. The inner loop of a FPS-game is probably better written with explicit memory-handling.<p>

For other uses, this doesn't seem to be the case. Most web-apps are infact written in GCed languages. There is absolutely *nothing* stopping you from developing competing programs in say C, and if you're rigth, that the users really would prefer this, you'd make billions. I somehow think that'll fail to be the case though.<p>

The thing you're missing is that computing-power really is cheap, and often cheap enough to be almost completely ignorable. The company I work for, for example, spend on the order of $1million/year on developing web-applications. The hardware for running all of this costs something like literally 5% of this, and that is *including* backups, sysadmin-stuff and the like.<p>

Even if we could run the same stuff on a 486 if it was written in C, it wouldn't be worth it if that meant more than 3-4% extra development-time.

<i>2) Doing it properly is often not that expensive for a good programer, who already has to manage other reasources.</i><p>

Doing software-development "properly" is very expensive. So expensive that if you do custom-development it is going to completely -dwarf- the hardware-requirements in 95% of the cases.<p>

Spending a year of work and $5000 of hardware for doing the same thing that could be done with 6 months of work and $10.000 of hardware is the completely unsustainable choice -- You save $5000 in hw and spend ten times that in extra development-costs.<p>

If you can do in 12 months in C the same job that require 11 months in Python/Ruby/Php/whatever, then more power to you. Most people can't though, not even smart people.



      
          <div class="CommentReplyButton">
            <form action="/Articles/225542/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor225455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2007 21:39 UTC (Fri)
                               by <b>cpeterso</b> (guest, #305)
                              [<a href="/Articles/225455/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Perhaps this is an argument for putting GC in the kernel itself? Instead of userspace programs solving the same complicated memory management problems again and again, consolidate the solution in the kernel, close it the OS's MM code.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor225541"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2007 10:50 UTC (Mon)
                               by <b>ekj</b> (guest, #1524)
                              [<a href="/Articles/225541/">Link</a>] 
      </p>
      
      </div>
      </summary>
      But the thing is, it appears, in practice, really really hard for human brains to handle memory-allocation well too.<p>

Sure, sure, "just do it correctly" would work, in principle. Except that in *practice* we've been using C for like forever in computer-terms, and *still* the classical memory-managment problems keep coming up, even in well-audited clueful code. So, obviosuly, "just do it correctly" isn't going to solve the problem.<p>

So, who is most likely to improve their ability of handling memory-allocation? Computers (who grow in various ways by leaps and bounds) or human beings (who's been struggling with manual memory-managment in C for decades, and this far seems to be making very very little, if any, progress.)<p>

Also, the overwhelming part of code written does not care about performance. They don't care *enough* to be willing to take the extra hit on development-time needed to do manual memory-managment anyway.<p>

It's not about laziness. I don't particularily care if my employer wishes to hire me for a week to do something in Python, or if he prefers paying me for 2 weeks to solve the same problem in C. (or for that matter a month and solve it in assembler)<p>

My employer cares though. He wants a problem solved. He'll probably opt for the python-version, even if it runs 3 times slower. Especially since he knows that it's a simple thing to re-write any routines that *do* need performance in C if that should turn out to be nessecary.
      
          <div class="CommentReplyButton">
            <form action="/Articles/225541/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor225843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2007 19:24 UTC (Tue)
                               by <b>pimlott</b> (guest, #1535)
                              [<a href="/Articles/225843/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You make a good case, but ...

<blockquote type=cite>
Real-world programs must manage other much more limited resources -- network sockets, database connections, disks -- and any method sufficient to manage them suffices for memory as well.
</blockquote>

comparing the problem of managing memory with managing other resources is off-base.  Other resources almost always have simple, obvious lifetime rules that make explicit management straight-forward.  Furthermore, there are many fewer of them (so fewer places to make mistakes, easier to audit), and errors are usually detected quickly because the resource has an externally-visible behavior.  And if still explicit management is too difficult, reference counting solves the problem neatly because there are not enough objects to cause a performance impact, and there is no possibility of reference loops.
<p>
Memory management is fundamentally much harder.
      
          <div class="CommentReplyButton">
            <form action="/Articles/225843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor226179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Garbage collection and MM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 15, 2007 11:21 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/226179/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Another paper on VM aware GCs: first link when looking for 'vm aware garbage collector' on Google.<br>
<p>
They got significant improvement on their benchmark by making the VM and the GC communicate. <br>
Of course whether this show real like improvement is anyone guess..<br>
<p>
One annoying thing with these papers is that they use copying GCs which doesn't interact well with C-based libraries: they're useful only for Java not the other scripting language which tend to reuse C-based libraries..<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/226179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor225157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short topics in memory management</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2007 12:56 UTC (Thu)
                               by <b>ranmachan</b> (guest, #21283)
                              [<a href="/Articles/225157/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Andrews pagecache-management tool works great for burning DVDs.<br>
The script I use for that first md5sums all the files, burns them with growisofs and checks the result with md5sum again.<br>
However, the stock script doesn't work with md5sum+growisofs because the use fread/fwrite.<br>
I also had to include linux/fadvise.h to get it to compile on my Debian system.<br>
<p>
diff -Naru pagecache-management/fadv.c pagecache-management/fadv.c<br>
--- pagecache-management/fadv.c	2007-03-03 20:02:20.000000000 +0100<br>
+++ pagecache-management/fadv.c	2007-03-04 11:35:56.000000000 +0100<br>
@@ -9,6 +9,7 @@<br>
 #include &lt;fcntl.h&gt;<br>
 #include &lt;limits.h&gt;<br>
 #include &lt;errno.h&gt;<br>
+#include &lt;linux/fadvise.h&gt;<br>
 <br>
 int main(int argc, char *argv[])<br>
 {<br>
diff -Naru pagecache-management/pagecache-management.c pagecache-management/pagecache-management.c<br>
--- pagecache-management/pagecache-management.c	2007-03-03 21:14:00.000000000 +0100<br>
+++ pagecache-management/pagecache-management.c	2007-03-04 14:55:27.000000000 +0100<br>
@@ -15,6 +15,7 @@<br>
 #include &lt;unistd.h&gt;<br>
 #include &lt;dlfcn.h&gt;<br>
 #include &lt;limits.h&gt;<br>
+#include &lt;linux/fadvise.h&gt;<br>
 <br>
 #include "sync_file_range.h"<br>
 <br>
@@ -152,9 +157,12 @@<br>
 <br>
 static ssize_t (*_write)(int fd, const void *buf, size_t count);<br>
 static ssize_t (*_pwrite)(int fd, const void *buf, size_t count, off_t offset);<br>
+static size_t (*_fwrite)(const void *ptr, size_t size, size_t nmemb, FILE *stream);<br>
 static ssize_t (*_read)(int fd, void *buf, size_t count);<br>
 static ssize_t (*_pread)(int fd, void *buf, size_t count, off_t offset);<br>
+static size_t (*_fread)(void *ptr, size_t size, size_t nmemb, FILE *stream);<br>
 static int (*_close)(int fd);<br>
+static int (*_fclose)(FILE *fp);<br>
 static int (*_dup2)(int oldfd, int newfd);<br>
 <br>
 static int symbols_loaded;<br>
@@ -176,6 +184,10 @@<br>
 	if (dlerror())<br>
 		abort();<br>
 <br>
+	_fwrite = dlsym(handle, "fwrite");<br>
+	if (dlerror())<br>
+		abort();<br>
+<br>
 	dlerror();<br>
 	_read = dlsym(handle, "read");<br>
 	if (dlerror())<br>
@@ -185,10 +197,18 @@<br>
 	if (dlerror())<br>
 		abort();<br>
 <br>
+	_fread = dlsym(handle, "fread");<br>
+	if (dlerror())<br>
+		abort();<br>
+<br>
 	_close = dlsym(handle, "close");<br>
 	if (dlerror())<br>
 		abort();<br>
 <br>
+	_fclose = dlsym(handle, "fclose");<br>
+	if (dlerror())<br>
+		abort();<br>
+<br>
 	_dup2 = dlsym(handle, "dup2");<br>
 	if (dlerror())<br>
 		abort();<br>
@@ -222,6 +242,22 @@<br>
 	return (*_pwrite)(fd, buf, count, offset);<br>
 }<br>
 <br>
+size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)<br>
+{<br>
+	load_symbols();<br>
+	write_was_called(fileno(stream), size*nmemb);<br>
+	return (*_fwrite)(ptr, size, nmemb, stream);<br>
+}<br>
+<br>
+#undef fwrite_unlocked<br>
+<br>
+size_t fwrite_unlocked(const void *ptr, size_t size, size_t nmemb, FILE *stream)<br>
+{<br>
+	load_symbols();<br>
+	write_was_called(fileno(stream), size*nmemb);<br>
+	return (*_fwrite)(ptr, size, nmemb, stream);<br>
+}<br>
+<br>
 ssize_t read(int fd, void *buf, size_t count)<br>
 {<br>
 	load_symbols();<br>
@@ -236,6 +272,29 @@<br>
 	return (*_pread)(fd, buf, count, offset);<br>
 }<br>
 <br>
+size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)<br>
+{<br>
+	load_symbols();<br>
+	read_was_called(fileno(stream), size*nmemb);<br>
+	return (*_fread)(ptr, size, nmemb, stream);<br>
+}<br>
+<br>
+#undef fread_unlocked<br>
+<br>
+size_t fread_unlocked(void *ptr, size_t size, size_t nmemb, FILE *stream)<br>
+{<br>
+	load_symbols();<br>
+	read_was_called(fileno(stream), size*nmemb);<br>
+	return (*_fread)(ptr, size, nmemb, stream);<br>
+}<br>
+<br>
+int fclose(FILE *fp)<br>
+{<br>
+	load_symbols();<br>
+	close_was_called(fileno(fp));<br>
+	return (*_fclose)(fp);<br>
+}<br>
+<br>
 int close(int fd)<br>
 {<br>
 	load_symbols();<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/225157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2007, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
