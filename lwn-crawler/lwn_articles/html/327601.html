        <!DOCTYPE html>
        <html lang="en">
        <head><title>Linux Storage and Filesystem workshop, day 1 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/327601/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/326818/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/327601/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Linux Storage and Filesystem workshop, day 1</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we donâ€™t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 7, 2009</br>
           </div>
The annual Linux kernel summit may gain the most attention, but the size of
the kernel community makes it hard to get deeply into subsystem-specific
topics at that event.  So, increasingly, kernel developers gather for more
focused events where some real work can be done.  One of those gatherings
is the Linux Storage and Filesystem workshop; the <a
href="http://events.linuxfoundation.org/events/lsf-workshop">2009
workshop</a>  began on
April&nbsp;6.  Here is your editor's summary of the discussions which took
place on the first day.
<p>

Things began with a quick recap of the action items from the previous
year.  Some of these had been fairly well resolved over that time; these
include power management, support for object storage  devices, fibre channel
over Ethernet, barriers on by default in ext4, the <tt>fallocate()</tt>
system call, and
enabling relatime by default.  The record for some other objectives is not
quite so good; low-level error handling is still not what it could be, "too
much work" has been done with I/O bandwidth controllers while nothing has
made it upstream, the union filesystem problem has not been solved, etc.
As a whole, a lot has been done, but a lot remains to do.
<p>
<h3>Device discovery</h3>
<p>
Joel Becker and Kay Sievers led a session on device discovery.  On a
contemporary system, device numbers are not stable across reboots, and
neither are device names.  So anything in the system which must work with
block devices and filesystems must somehow find the relevant device first.
Currently, that is being done by scanning through all of the devices on the
system.  That works reasonably well on a laptop, but it is a real problem
on systems with huge numbers of block devices.  There are stories of large
systems taking hours to boot, with the bulk of that time being spent
scanning (repeatedly - once for every mount request) through known devices.
<p>
What comes out of the discussion, of course, is that user space needs a
better way to locate devices.  A given program may be searching for a
specific filesystem label, UUID, or something else; a good search API would
support all of these modes and more.  What would be best would be to build
some sort of database where each new device is added at discovery time.  As
additional information becomes available (when a filesystem label is found,
for example), it is added to the database.
Then, when a specific search is done, the information has already been
gathered and a scan of the system's devices is no longer necessary.
<p>
In the simplest form, this database can be the various directories full of
symbolic links that udev creates now.  These directories solve much of the
problem, but they can never be a complete solution for one reason: some
types of devices - iSCSI targets, for example - do not really exist for the
system until user space has connected to them.  Multipath devices also
throw a spanner into that works.  For this reason, Ted Ts'o asserted that
some sort of programmatic API will always be needed.
<p>
Not a lot of progress was made toward specifying a solution; the main
concern, seemingly, was coming to a common understanding of the problem.
What's likely to happen is that the libblkid library will be extended to
provide the needed functionality.  Next year, we'll see if that has been
done.
<p>
<h3>Asynchronous and direct I/O</h3>
<p>

Zach Brown's stated purpose in this session was to "just rant for 45
minutes" about the poor state of asynchronous I/O (AIO) support in Linux.
After ten years, he says, we still have an inadequate system which has
never been fixed.  The problems with Linux AIO are well documented: only a
few operations are truly asynchronous, the internal API is terrible, it
does not properly support the POSIX AIO API, etc.  There, Zach says, are
people wanting to do a lot more with AIO than is currently supported by
Linux.
<p>
That said, various alternatives have been proposed over time but nobody
ever tests them.
<p>
The conversation then shifted for a bit; 
Jeff Moyer took a turn to complain about the related topic of direct I/O.  It works poorly for
applications, he says, its semantics are different for different
filesystems, the internal I/O paths for direct I/O are completely
different from those used for buffered I/O, and it is full of races and
corner cases.  Not a pretty picture. 
<p>
One of the biggest complications with direct I/O is the need for the system
to support simultaneous direct and buffered I/O on the same file.
Prohibiting that combination would simplify the problem considerably, but
that is a hard thing to do.  In particular, it would tend to break backups,
which often want to read (in buffered mode) a file which is open for direct
I/O.  There was some talk of adding a new O_REALLYDIRECT mode which would
lock out buffered operations, but it's not clear that the advantages would
make this change worthwhile.
<p>
Another thing that would help with direct I/O would be to remove the
alignment restrictions on I/O buffers.  That's a hard change to make,
though; many disk controllers can only perform DMA to properly-aligned
buffers.  So allowing unaligned buffers would force the kernel to copy data
internally, which rather defeats the purpose of direct I/O.  There
is one use case, though, where direct I/O might still make sense: some
direct I/O users really only 
want to avoid filling the system page cache with their data.  Using the
<tt>fadvise()</tt> system call is arguably a better way of achieving that
goal, but application developers are said to distrust it.  
<p>
All told, it seems from the discussion that there is not a whole lot to be
done to improve direct I/O on Linux.
<p>
Returning to the AIO problem, the developers discussed Zach's proposed <a
href="http://lwn.net/Articles/316806/"><tt>acall()</tt> API</a>, which
shifts blocking operations into special-purpose kernel threads.  The use
of threads in this manner promises a better AIO implementation than Linux
has ever had in the past.  But there is a cost: some core scheduler changes
need to be made to support <tt>acall()</tt>.  Among other things, there are
some complexities related to transferring credentials between threads,
propagating signals from AIO threads back to the original process, etc.
The end result is that scheduler performance may well suffer slightly.  The
scheduler developers tend to be sensitive to even very small performance
penalties, so there may well be pushback when <tt>acall()</tt> is proposed
for mainline inclusion.
<p>
The addition of <tt>acall()</tt> would also add a certain maintenance
burden.  Whenever a kernel developer makes a change to the task structure,
that developer would have to think about whether the change is relevant to
<tt>acall()</tt> and whether it would need to be transferred to or from
worker threads.
<p>
The conclusion was that <tt>acall()</tt> looks promising, and that the
developers in the room thought that it could work.  They also agreed,
though, that a number of the relevant people were not in the room, so the
question of whether <tt>acall()</tt> is appropriate for the kernel as a
whole could not be answered.
<p>
<h3>RAID unification</h3>
<p>

The kernel currently contains two software RAID implementations, found in
the MD and device mapper (DM) subsystems.  Additionally, the Btrfs
filesystem is gaining RAID capabilities of its own, a process which is
expected to continue in the future.  It is generally agreed that having
three (or more) versions of RAID in the kernel is not an optimal situation.
What a proper solution will look like, though, is not all
that clear.
<p>
The session on RAID unification started with this question: who thinks that
block subsystem development should be happening in the device mapper
layer?  A single hand was raised.  In general, it seems, the developers in
the room had a relatively low opinion of the device mapper RAID code.  It
should be said, of course, that there were no DM developers present.
<p>
What it comes down to is that the next generation of filesystems wants to
include multiple device support.  Plans for Btrfs include eventual
RAID&nbsp;6 support, but Btrfs developer Chris Mason has no interest in
writing that code.  It would be much nicer to use a generic RAID layer
provided by the kernel.  There are challenges, though.  For example, a
RAID-aware filesystem really wants to use different stripe sizes for data
and metadata.  Standard RAID, which knows little about the filesystems
built on it, does not provide any such feature.
<p>
So what would a filesystem RAID API look like?  Christoph Hellwig is
working on this problem, but he's not ready to deal with the filesystem
problem yet.  Instead, he's going to start by figuring out how to unify the
MD and DM RAID code.  Some of this work may involve creating a set of
tables in the block layer for mapping specific regions of a virtual device
onto real regions in a lower-level device.  The block layer already does
that - it's how partitions work - but incorporating RAID would complicate
things considerably.  But, once that's done, we'll be a lot closer to
having a general-purpose RAID layer which can be used by multiple callers. 
<p>
The talk wandered into the area of error handling for a while.  In
particular, the tools Linux provides to administrators to deal with bad
blocks are still not what they could be.  There was talk about providing a
consistent interface for reporting bad blocks - including tools for mapping
those blocks back to the files that contain them - as well as performing
passive scanning for bad blocks.
<p>
The action items that came out of this discussion include the rework of
in-kernel RAID by Christoph.  After that, the process of trying to define
filesystem-specific interfaces will begin.

<p>
<h3>Rename, fsync, and ponies</h3>
<p>

Prior to Ted Ts'o's session on <tt>fsync()</tt> and <tt>rename()</tt>, some
joker filled the room with coloring-book pages depicting ponies.  These
pages reflected the sentiment that Ted has often expressed: application
developers are asking too much of the filesystem, so they might as well
request a pony while they're at it.
<p>
Ted apologized to the room for his part in the implementation of the
<tt>data=ordered</tt> mode for ext3.  This mode was added as a way to
improve the security of the filesystem, but it had the side effect of
flushing many changes to the filesystem within a five-second window.  That
allowed application developers to "get lazy" and stop worrying about
whether their data had actually hit the disk at the right times.  Now those
developers are resisting the idea that they should begin to worry again.
<p>
This problem has a longer history than many people realize.  The XFS
filesystem first hit it back around 2001.  But, Ted says, most application
developers didn't understand why they were getting corrupted files after a
crash.  Rather than fix their applications, they just switched filesystems
- to ext3.  Things worked for some time until Ubuntu users started testing
the alpha "Jaunty" release, which <strike>uses ext4 by default</strike>
makes ext4 available as an installation option.  At that point,
they started finding zero-length files after crashes, and they blamed
ext4.
<p>
But, Ted says, the real problem is the missing <tt>fsync()</tt> calls.
There are a number of reasons why they are not there, including developer
laziness, the problem that <tt>fsync()</tt> on ext3 has become very
expensive, the difficulty involved in preserving access control lists and
other extended attributes when creating new files, and concerns about the
battery-life costs of forcing the disk to spin up.  Ted had more sympathy
for some of these reasons than others, but, he says, "the application
developers outnumber us," so something will have to be done to meet their
concerns.
<p>
Valerie Aurora broke in to point out that application developers have been
put into a position where they cannot do the right thing.  A call to
<tt>fsync()</tt> can stall the system for quite a while on ext3.  Users
don't like that either; witness the fuss caused by excessive use of
<tt>fsync()</tt> by the Firefox browser.  So it's not just that application
developers are lazy; there are real disincentives to the use of
<tt>fsync()</tt>.  Ted agreed, but he also claimed that a lot of application
developers are refusing to help fix the problem.
<p>
In the short term, the ext4 filesystem has gained a number of workarounds to
help prevent the worst surprises.  If a newly-written file is renamed on
top of another, existing file, its data will be flushed to disk with the
next commit.  Similar things happen with files which have been truncated
and rewritten.  There is a performance cost to these changes, but they do
make a significant part of the problem go away.
<p>
For the longer term, Ted asked: should the above-described fixes become a
part of the filesystem policy for Linux?  In other words, should
application developers be assured that they'll be able to write a file,
rename it on top of another file, omit <tt>fsync()</tt>, and not encounter
zero-length files after a crash?  The answer turns out to be "yes," but
first Ted presented his other long-term ideas.
<p>
One of those is to improve the performance of the
<tt>fsync()</tt> system call.  The ext4 workarounds have also been added to
ext3 when it runs in the <tt>data=writeback</tt> mode.  Additionally, some
block-layer fixes have been incorporated into 2.6.30.  With those fixes in
place, it is possible to run in <tt>data=writeback</tt> mode, avoid the
zero-length file problem, and also avoid the <tt>fsync()</tt> performance
problem.  So, Ted asked, should <tt>data=writeback</tt> be made the default
for ext3?  
<p>
This idea was received with a fair amount of discomfort.  The
<tt>data=writeback</tt> mode brings back problems that were fixed by
<tt>data=ordered</tt>; after a crash, a file which was being written could
turn up with completely unrelated data in it.  It could be somebody else's
sensitive data.  Even if it's boring data, the problem looks an awful lot
like file corruption to many users.  It seems like a step backward and a
change which is hard to justify for a filesystem which is headed toward
maintenance mode.  So it would be surprising to see this change made.
<p>
[After writing the above, your editor noticed that Linus had just merged a
change to make <tt>data=writeback</tt> the default for ext3 in 2.6.30.
Your editor, it seems, is easily surprised.]
<p>
Finally, the idea of the <tt>fbarrier()</tt> system call was raised.
Essentially, <tt>fbarrier()</tt> would ensure that any data written to a
file prior to the call would be flushed to disk before any metadata changes
made after the call.  It could be implemented with <tt>fsync()</tt>; for
ext3 <tt>data=ordered</tt> mode, it would do nothing at all.  Ted did not
try hard to sell this system call, saying that it was mainly there to
address the laptop power consumption concern.  Ric Wheeler claimed that it
would be a waste of time; by the time people are actually using it, we'll
all have solid-state drives in our laptops and the power concern will be
gone.  In general, enthusiasm for <tt>fbarrier()</tt> was low.
<p>
So the discussion turned back to the idea of generalizing and guaranteeing
the ext4 workarounds.  Chris Mason asked when there might be a time that
somebody would <i>not</i> want to rename files safely; he did not get an
answer.  There was concern that these workarounds could not be allowed to
hurt the performance of well-written applications.  But the general
sentiment was that these workarounds should become policy that all
filesystems should implement.
<p>
<h3>pNFS</h3>
<p>
There was a session on supporting <a
href="http://lwn.net/Articles/313437/">parallel NFS</a> (pNFS).  It was
mostly a detailed, technical discussion on what sort of API is needed to
allow clustered filesystems to tell pNFS about how files are distributed
across servers.  Your editor will confess that his eyes glazed over after a
while, and his notes are relatively incoherent.  Suffice to say that,
eventually, OCFS2 and GFS will be able to communicate with pNFS servers and
that all the people who really care about how that works will understand
it.
<p>
<h3>Miscellaneous topics</h3>
<p>
The final session of the day related to "miscellaneous VFS topics"; the
first had to do with eCryptfs.  This filesystem provides encryption for
individual files; it is currently implemented as a stacking filesystem
using an ordinary filesystem to provide the real storage.  The stacking
nature of eCryptfs has long been a problem; now some Ubuntu developers are
working to change it.
<p>
In particular, what they would like to do is to move the encryption
handling directly into the VFS layer.  Somehow users will supply a key to
the kernel, which will then transparently handle the encryption and
decryption of data.  To that end, some sort of transformation layer will be
provided to process the data between the page cache and the underlying
block device.
<p>
One question that came up was: what happens when the user does not have a
valid key?  Should the VFS just provide encrypted data in that case?  Al
Viro raised the question of what happens when one process opens the file
with a key while another one opens it without a key.  At that point there
will be a mixture of encrypted and clear-text pages in the cache, a
situation which seems sure to lead to confusion.  So it seems that the VFS
will simply refuse to provide access to files if the necessary key is not
provided.
<p>
There are various problems to be solved in the creation of the
transformation layer - things like not letting processes modify a page
while it is being encrypted or decrypted.  Chris Mason noted that he faces
a similar problem when generating checksums for pages in Btrfs.  These are
problems which can be addressed, though.  But it was clear that this kind
of transformation is likely to be built into the VFS in the future.
Stacking filesystems just do not work well with the Linux VFS as it exists
now.
<p>
Next up was David Brown, who works in the scientific high-performance
computing field.  David has an interesting problem.  He runs massive
systems with large storage arrays spread out across many systems.  Whenever
some process calls <tt>stat()</tt> on a file stored in that array, the
entire cluster essentially has to come to a stop.  Locks have to be
acquired, cached pages have to be flushed out, etc., just to ensure that
specific metadata (the file size in particular) is available and
correct.  So, if a scientist logs in and types "ls" in a large directory,
the result can be 30&nbsp;minutes in coming and little work gets done in
the mean time.  Not ideal.
<p>
What David would like is a "stat() light" call which wouldn't cause all of
this trouble.  It should return the metadata to the best of its knowledge,
but it would not flush caches or take cluster-wide locks to obtain this
information.  If that means that the size is not entirely 
accurate, so be it.  In the subsequent discussion, the idea was modified a
little bit.  "Slightly inaccurate" results would not be returned; instead,
the size would simply be zeroed out.  It was felt that returning no
information at all was better than returning something which may have no
real basis in reality.
<p>
Beyond that, there would likely be a mask
associated with the system call.  Initially it was suggested that the mask
would be returned; it would have bits set to indicate which fields in the
return <tt>stat</tt> structure are valid.  But it was also suggested that
the mask should be an input parameter instead; the call would then do
whatever was needed to provide the fields requested by the caller.  Using
the mask as an input parameter would avoid the need for duplicate calls in
the case where the necessary information is not provided the first time
around. 
<p>
The actual form of the system call is likely to be determined when somebody
follows Christoph Hellwig's advice to "send a bloody patch."
<p>
The final topic of the day was union mounts.  Valerie Aurora, who led this
session, recently wrote <a href="http://lwn.net/Articles/324291/">an
article about union filesystems and the associated problems</a> for LWN.
The focus of this session was the <tt>readdir()</tt> system call in
particular.  POSIX requires that <tt>readdir()</tt> provide a position
within a directory which can be used by the application at any future time
to return to the same spot and resume reading directory entries.  This
requirement is hard for any contemporary filesystem to meet. It becomes
almost impossible for union filesystems, which, by definition, are
presenting a combination of at least two other filesystems.
<p>
The solution that Valerie was proposing was to simply recreate directories
in the top (writable) layer of the union.  The new directories would point
to files in the appropriate places within the union and would have
whiteouts applied.  That would eliminate the need to mix together directory
entries from multiple layers later on, and the <tt>readdir()</tt>
problem would collapse back to
the single-filesystem implementation.  At least, that holds true for as
long as none of the lower-level filesystems in the union change.  Valerie
proposes that these filesystems be forced to be read-only, with an unmount
required before they could be changed.
<p>
The good news is that this is how BSD union mounts have worked for a long
time. 
<p>
The bad news is that there's one associated problem: inode number
stability.  NFS servers are expected to provide stable inode numbers to
clients even
across reboots.  But copying a file entry up to the top level of a union
will change its inode number, confusing NFS clients.  One possible solution
to this problem is to simply decree that union mounts cannot be exported
via NFS.  It's not clear that there is a plausible use case for this kind
of export in any case.  The other solution is to just let the inode number
change.  That could lead to different NFS clients having open file
descriptors to different versions of the file, but so be it.  The consensus
seemed to lean toward the latter solution.
<p>
And that is where the workshop concluded.  Your editor will be attending
most of the second and final day (minus a brief absence for a cameo
appearance at the Embedded Linux Conference); a report from that day will
be posted shortly thereafter.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer">Block layer</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Workshops">Filesystems/Workshops</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_and_Filesystem_Workshop-2009">Storage and Filesystem Workshop/2009</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/327601/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor327702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 17:37 UTC (Tue)
                               by <b>thornhill</b> (guest, #57198)
                              [<a href="/Articles/327702/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are the presentations (pdf) available somewhere?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Presentations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 17:41 UTC (Tue)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/327703/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I wouldn't look for a lot of PDF files.  It's all very discussion-oriented, so there's not much in the way of presentations.  
      
          <div class="CommentReplyButton">
            <form action="/Articles/327703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Presentations</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 8:56 UTC (Thu)
                               by <b>nikanth</b> (guest, #50093)
                              [<a href="/Articles/327976/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are recordings/transcript available somewhere? ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor327708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 18:19 UTC (Tue)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/327708/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could someone please enlighten me why aio should happen in kernel space at all, especially since acall() just seems to distribute work on different threads anyway? That could be done in userspace as well, and in fact is done in GLib's GVFS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327723"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 20:18 UTC (Tue)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/327723/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In Zach's original patch set, the thread was spawned iff satisfying the IO request required blocking (so if the data was in cache, thread spawning/joining overhead was avoided), which you can't determine from userspace. Not sure how much that matters (a kernel thread is what, two pages?) or whether it's part of this version of the patch, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327723/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327779"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 1:33 UTC (Wed)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/327779/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, not sure of programs really want to make use of that functionality. Also, wouldn't it be easier to simply allow O_NDELAY style access to files? Then blocking IO requests could simply return EAGAIN and userspace could start a thread for it, and everything could be done easily in userspace.<br>
<p>
In addition, the POSIX aio doesn't allow such 'early' returns. (POSIX aio is an awful API anyway, with all those signals)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327779/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Using threads for AIO? Best do it in userspace.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 6:38 UTC (Wed)
                               by <b>xoddam</b> (guest, #2322)
                              [<a href="/Articles/327808/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree entirely, posted words to the same effect below.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor327710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 18:22 UTC (Tue)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/327710/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What's the point in doing asynchronous I/O in the kernel? Nowadays, if an application doesn't want to block on I/O, the programming environment makes it easy to start a thread/process and let it handle the I/O. Even with kernel support the separate thread/process might be necessary to update e.g. a progress bar.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 19:34 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/327713/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At least traditionally, I think that AIO has been much more scalable than threaded I/O, not least because you don't need to keep a stack around for each thread.  And some people prefer to keep everything on a single thread, because they don't want to deal with multi-threading issues, although I don't know if they are the ones people are interested in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">They are</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 20:35 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/327724/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Think <a href="http://nginx.net/">NGINX</a>. If you have 50'000 
clients connected in the same time and your box have 100 separate disks 
with content (not unrealistic example - NGINX does have support for such 
extreme conditions) then AIO is suddenly much faster then threaded I/O and 
MUCH less resource-hungry.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/327724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why does AIO need to be supported at the kernel level?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 1:16 UTC (Wed)
                               by <b>xoddam</b> (guest, #2322)
                              [<a href="/Articles/327773/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even if only operations that *need* to be asynchronous require kernel threads, and even if they are recycled instead of being created and destroyed on demand, that will still be quite expensive at the kernel level.<br>
<p>
If one thread per outstanding operation or per client is too many, there are good userspace thread pool implementations that dedicate a few threads to waiting for IO completions whilst others get on with whatever work can proceed immediately.<br>
<p>
I'm not convinced that pushing the thread pool down into the kernel is a performance win.<br>
<p>
The Linux thread implementation chose for very good reasons to stick to a 1:1 relationship between userspace and kernel threads: it's because the job of multiplexing application tasks to a smaller number of system threads is hard to do in a generic way.  All the choices are best made by the application developer, therefore thread pool implementations belong in userspace.<br>
<p>
I don't really see the point of supporting POSIX signal-driven AIO at the kernel level if the implementation uses threads and sits on top of the existing synchronous IO.  A userspace library could do it just as reliably using select() and kill(), for those few applications that insist on the POSIX AIO interface for whatever reason.<br>
<p>
That said, the kernel handles asynchronous events all the time.  Why exactly is it so hard to let userspace handle them asynchronously too at a low level, without going through the synchronous layer?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I think the idea is to support AIO for all objects with a single API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 12:46 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/327834/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>While it's very important to have "light AIO" for some things (like TCP 
sockets) it's not so important to have them for other things (like
in-memory pipes). If you have everything in kernel you can implement some 
things with threads and other without threads and userspace does not care. 
With userspace library any change require ABI schange - and that's 
PAIN...</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/327834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor327722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 20:15 UTC (Tue)
                               by <b>lmb</b> (subscriber, #39048)
                              [<a href="/Articles/327722/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, IO in the kernel is async anyway. This is about defining a usable user-space interface for it.<br>
<p>
An event-driven FSA would benefit greatly from this; not everyone buys into multi-threaded paradigms. For some scenarios, this would make it possible to simplify the user-space implementation significantly.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor329099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2009 9:59 UTC (Mon)
                               by <b>forthy</b> (guest, #1525)
                              [<a href="/Articles/329099/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I don't understand why there was so much objection against the syslets
- send the kernel a bunch of "IO instructions", and let it execute those
asynchronously. Passing active messages (that's what it is) is a good
idea, anyway; especially for networks like NFS4, where each "kernel call"
is quite heavy. Syslets would scale a lot better (lower load, less context
switches) than synchronous IO. Active message systems often had problems
with programmers who did not understand them (like Display Postscript), so
I guess this problem comes up again. It is not just a quality of
implementation issue, it is a fundamental quality of understanding
issue.</p>

<p>This overall doesn't sound good. With Ted T'so, it's even worse: He
doesn't get it. It is not an option to a "save" filesystem which already
takes a performance penalty by maintaining a journal, to corrupt data. It
is an option to delay writing, and in effect, the 5 seconds update in ext3
is not what solved the problem, it is writing <b>ordered</b>. From an
application writer point of view, this is a quality of implementation
issue, but when I read the arguments, it's again an understanding problem.
I'm concerned; maybe it is that those hard-core Linux hackers have been
there for 20 years and are still sticking to 90s state-of-the-art?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/329099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor327728"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 22:00 UTC (Tue)
                               by <b>dankamongmen</b> (subscriber, #35141)
                              [<a href="/Articles/327728/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Resource utilization is maximized when each processing element (think core) executes useful work, until no more useful work remains. Starting a thread/process has overhead. Context switching between threads on a processor has overhead. Spawning and switching between threads is not useful work.<br>
<p>
High-performance servers want to spawn a thread per allocated core, and have each thread fully exercising that CPU. That's why AIO can/must beat synchronous I/O (blocking or non; that's immaterial here) -- your thread can go on managing events (of course, if the CPU is necessary for the AIO to be performed, your thread won't run anyway, but the CPU can sometimes be avoided).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327728/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 0:29 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327769/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One could also solve the problem that fbarrier() is meant to solve by using aio_fsync(). If aio_fsync() was designed to wait for the regular kernel commit interval in laptop mode (which it could, because there are no guarantees when it's going to complete), application writers could just use that to provide safe rename. The actual rename would be called from signal handler or the thread created when aio_fsync() completes.<br>
<p>
In other words, no new calls would need to be introduced into the kernel, the apps would be portable and safe, interactivity would be preserved (this is an async interface), one would not need to use extra threads (signal can be delivered instead) and disk would not need to spin up to commit the file right away.<br>
<p>
At the same time, regular fsync() would still mean "really commit now", so databases and similar software could use it safely even in laptop mode.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 4:19 UTC (Wed)
                               by <b>jamesh</b> (guest, #1159)
                              [<a href="/Articles/327788/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <p>Your aio_fsync() suggestion would give a significantly different result to fbarrier().</p>

<p>Consider a function that wrote a file and renamed it using the hypothetical fbarrier():</p>

<blockquote><pre>
fp = open("filename.tmp")
write(fp, "data", length)
fbarrier(fp)
close(fp)
rename("filename.tmp", "filename")
</pre></blockquote>

<p>When this function completes, any process reading the file will get the new contents.  The changes to the underlying block device could be delayed, but if there is a crash "filename" should either give the old contents or the new.</p>

<p>Using aio_fsync() as you suggest would keep the same crash resilience behaviour, but would provide entirely different runtime behaviour.  As the signal would likely be delivered after the function returns, the rename won't have happened at that point.  So a read of "filename" will return the old file contents for some unknown period of time after the function returns.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/327788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 4:51 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/327793/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am sorry, but that appears to be completely wrong.  The base POSIX <br>
specification allows a null implementation of fsync. If one is not <br>
concerned about a system crash or unclean shutdown, there is no need to <br>
call fsync, aio_fsync, fbarrier or any other comparable function.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 4:56 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327795/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is also true, of course. If the docs say you need to restore after a crash, then open(), write(), close(), rename() is just fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor327791"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 4:54 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327791/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True.<br>
<p>
That's why you'd have to hang on to your config in buffers until last unique temp file has overwritten the actual file, which is something that programs like gconfd can do easily. At that point, the buffers would get dumped and read of the real config file would be required next time.<br>
<p>
Normally, we are talking of about a few seconds to maybe half a minute of such behaviour here (i.e. either the amount of time it takes to finish immediate fsync or the next regular kernel commit). Programs that overwrite the same config file many, many times within half a minute period are really broken, so this should generally not be an issue.<br>
<p>
PS. The point of this whole thing with aio_fsync() is to show that there can be many different approaches to address this issue. Sure, it would require a more sophisticated code, but it can be done. If we had inotify with IN_SYNC event, we could use that too in userland to play with backup files and achieve the desired result (and it that case, read of the renamed file would always give the latest config - instead programs would have to rename foo~ into foo if they found one at startup, which would signal a crash).<br>
<p>
PPS. As you probably noticed from my previous posts regarding ext4/POSIX, I'd be very interested to have fbarrier(), because I think we need to have a clean, new way of saying this through an API.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327791/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327794"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 4:55 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/327794/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Of course using aio_fsync has lots of other problems...complexity and <br>
overhead mostly.  Either way, the rename is atomic and immediately visible <br>
to all user process.  What it isn't is necessarily durable, or safe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327794/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 5:02 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/327796/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I need to read more carefully. Jamesh is exactly right with regard to the <br>
problems of the solution suggested by the parent poster, namely delaying <br>
the rename until after the aio_fsync has completed.  Aside from the <br>
complexity and overhead issues, it has completely different user visible <br>
semantics.  That is fine if no other process needs to read the new version <br>
of the file in the meantime, otherwise it is problematic.  fbarrier would <br>
be a much cleaner solution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 6:02 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327800/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; fbarrier would be a much cleaner solution.</font><br>
<p>
Absolutely. No question about it. It's just that Linus is not keen on having it, so that got me thinking as to how the same can be done without a new call. Of course, many of the thought are, shall will say, ill conceived... :-)<br>
<p>
<font class="QuotedText">&gt; it has completely different user visible semantics</font><br>
<p>
One could also do this:<br>
<p>
1. See if "foo~" exists.<br>
2. If it doesn't, do link("foo","foo~") (i.e. create "backup").<br>
3. Open "foo".<br>
4. Read "foo".<br>
5. Open/create/truncate "foo.new".<br>
6. Write into "foo.new".<br>
7. Call aio_fsync() on "foo.new".  &lt;-- doesn't block<br>
8. Close "foo.new".<br>
9. Rename "foo.new" into "foo".<br>
<p>
In signal handler/thread created on sigevent do:<br>
<p>
1. Unlink "foo~".<br>
<p>
Then you get full rename semantics with always up to date file (i.e. what I was getting at with inotify example). However, your app then needs to check at startup if "foo~" exists (which means you crashed before the signal handler/thread unlinked you backup) and if it does, rename it to "foo". Then, continue.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 6:17 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327807/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 1. Unlink "foo~".</font><br>
<p>
That is when signal/thread counter reached zero.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 7:40 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327812/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>Quick and dirty - probably has more bugs then lines, but you'll get the picture.</p>

<p>Compile and link with: gcc -Wall -O2 -g -o a a.c -lrt</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;
#include &lt;aio.h&gt;

#define BUF_SIZE 50

static int count=0;

void whack(int signum,siginfo_t *info,void *context){
  if(!--count)
    unlink("foo~");
}

int main(int argc,char **argv){
  int fd;
  ssize_t rl;
  char *buf=malloc(BUF_SIZE);
  struct aiocb *cb=calloc(1,sizeof(*cb));
  struct sigevent *se=calloc(1,sizeof(*se));
  struct sigaction *act=calloc(1,sizeof(*act));

  /* XXX this is just a demo, no error checking */

  /* AIO control block defaults */
  cb->aio_sigevent.sigev_notify=SIGEV_SIGNAL;
  cb->aio_sigevent.sigev_signo=SIGRTMIN;

  /* signal handler */
  act->sa_flags=SA_SIGINFO;
  act->sa_sigaction=whack;
  sigaction(SIGRTMIN,act,NULL);

  /* see if foo~ exists and restore */
  if(!access("foo~",F_OK|R_OK|W_OK))
    rename("foo~","foo"); 

  /* back it up if required */
  if(access("foo~",F_OK|R_OK|W_OK))
    link("foo","foo~");

  /* read existing file */
  fd=open("foo",O_RDONLY);
  rl=read(fd,buf,BUF_SIZE);
  close(fd);

  /* write to new file and initiate sync */
  fd=open("foo.new",O_WRONLY|O_CREAT|O_TRUNC,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
  write(fd,buf,rl);
  cb->aio_fildes=fd;
  count++;
  aio_fsync(O_SYNC,cb);
  close(fd);

  /* rename new file into the existing one */
  rename("foo.new","foo");

  free(act);
  free(se);
  free(cb);
  free(buf);

  return 0;
}
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/327812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 8:03 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Of course, this won't work for two programs reading/modifying the same config file.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why all the runtime allocations? (off-topic)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 4:17 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/327954/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>This is going way off-topic, but why all the runtime allocations in your sample program?  Malloc(3), calloc(3), and free(3) are horribly expensive, relatively speaking.  Automatic/static storage for those structs and that char buffer would be substantially faster.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/327954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327965"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why all the runtime allocations? (off-topic)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 6:14 UTC (Thu)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327965/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just being lazy to call memset(), I guess...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327965/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor327809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 8:30 UTC (Wed)
                               by <b>jamesh</b> (guest, #1159)
                              [<a href="/Articles/327809/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With this proposal, you're now in a situation where every reader of the file needs to participate in the crash recovery, rather than having the writer ensure that the file is written correctly.<br>
<p>
Also, readers would need to differentiate between the case of "foo~" existing because the system crashed and "foo~" existing because some other process is in the process of replacing "foo" and waiting on the fsync.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 11:02 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327825/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I said, this will work for one process only. With Gnome, at least, this is the case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor328095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 4:53 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/328095/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
fbarrier(fd) is primarily useful to ask a filesystem to do what it ought to <br>
be doing already.  There is a relatively simple solution to this that I <br>
have mentioned a few times that is applicable to virtually any journalled <br>
filesystem that has none of the performance cost of falling back to <br>
data=ordered mode every time someone wants to do a rename replacement.  <br>
<p>
That is what ext4 (and apparently XFS) do in data=writeback mode when <br>
rename safety is enabled - force all the data for the file to be renamed to <br>
disk before the next metadata transaction can complete.  That means that <br>
*every* outstanding fsync operation is delayed while your multi-gigabyte <br>
ISO file finishes being committed to disk.<br>
<p>
This solution, as it turns out, is very similar to the practice of keeping <br>
tilde files.  It is just that the filesystem does it automatically and <br>
invisibly, restoring the old version on recovery whenever the new version <br>
didn't finish getting committed to disk.  No threads, signal handlers, etc. <br>
required.  No problems with multiple process access.  No application level <br>
code to figure out whether a version is corrupt.  No browser freeze ups. <br>
Rename undo is the way to avoid all that, with little or no performance <br>
cost.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Async I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 5:26 UTC (Fri)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/328100/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; No problems with multiple process access.</font><br>
<p>
No entirely true, actually. Imagine two processes reading the same file "foo". After they read it, they make the changes in memory, write them out to "foo.new" and then rename into "foo". Which changes will persist? From the fist or the second process?<br>
<p>
You have to have some kind of synchronisation to do this (flock(), semaphore etc.). Which can also be applied to the example with "foo~" files to sync access. That's why Gnome has a daemon (i.e. single process) to manage all these changes.<br>
<p>
PS. Of course, fbarrier() is still a much better solution, cleaner etc., but you cannot just say that multiple processes can do this as the please.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel based rename undo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 5:49 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/328101/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am talking about a kernel based solution, where in the case of a rename <br>
replacement an undo entry is placed in the journal and the old inode is <br>
kept around until the new inodes data is committed to disk.  Then in the <br>
case of an unclean shutdown the filesystem recovery process rolls forward <br>
using journal and uses the undo entries in the journal to build a rename <br>
undo candidate list.  When the journal redo is complete, the filesystem <br>
then uses the rename undo list to undo the rename replacements whenever the <br>
replacement inode's data was not committed before the system crashed.<br>
<p>
Ext4 does a certain amount of comparable undo already - if the replacement <br>
file was not committed to disk, the allocated blocks are freed and the <br>
filesystem truncates the file.  What I suggest is not much more complicated <br>
than that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328105"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel based rename undo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 7:35 UTC (Fri)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/328105/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>I know. What I'm talking about is synchronisation between processes in terms of contents of data (i.e. one process may write a change, which gets lost when another process does the same - your stock race). So, you cannot just open(), write(), close(), rename() with multiple processes. You have to lock, otherwise your processes will stomp all over each other's data.</p>

<p>An example of doing the same with multiple processes when kernel doesn't guarantee data before metadata on rename is below. Bugs included, of course ;-).</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;aio.h&gt;

#define BUF_SIZE 50

static int *count=NULL;

/* XXX this is just a demo, no error checking */

static void whack(int signum,siginfo_t *info,void *context){
  int sd=*(int*)info-&gt;si_value.sival_ptr;

  /* critical section */
  lockf(sd,F_LOCK,0);

  if(!--(*count))
    unlink("foo~");

  /* end critical section */
  lockf(sd,F_ULOCK,0);
}

int main(int argc,char **argv){
  int sd,fd;
  ssize_t len;
  char buf[BUF_SIZE];
  struct aiocb cb;
  const struct aiocb *cbl[]={&amp;cb};
  struct sigaction act;

  /* AIO control block setup */
  memset(&amp;cb,0,sizeof(cb));
  cb.aio_sigevent.sigev_notify=SIGEV_SIGNAL;
  cb.aio_sigevent.sigev_signo=SIGRTMIN;
  cb.aio_sigevent.sigev_value.sival_ptr=&amp;sd;

  /* signal handler setup */
  memset(&amp;act,0,sizeof(act));
  act.sa_flags=SA_SIGINFO;
  act.sa_sigaction=whack;
  sigaction(SIGRTMIN,&amp;act,NULL);

  /* setup shared counter, restore */
  if((sd=shm_open("foo",O_RDWR|O_CREAT|O_EXCL,S_IRUSR|S_IWUSR))==-1){
    int tries=20;
    struct stat s;

    /* not the first to arrive, open and wait for counter to be written */
    sd=shm_open("foo",O_RDWR,S_IRUSR|S_IWUSR);
    fstat(sd,&amp;s);
    while(tries-- &amp;&amp; s.st_size&lt;sizeof(*count)){
      sleep(1);
      fstat(sd,&amp;s);
    }

    /* something's really screwed */
    if(!tries)
      return 1;
  } else{ /* first to arrive, restore */
    int count=0; /* filler */

    /* don't care if we fail */
    if(!rename("foo~","foo"))
      fprintf(stderr,"Restored.\n");

    write(sd,&amp;count,sizeof(count));
  }

  /* shared counter */
  count=mmap(NULL,sizeof(int),PROT_READ|PROT_WRITE,MAP_SHARED,sd,0);

  /* critical section */
  lockf(sd,F_LOCK,0);

  /* don't care if it fails - already there */
  link("foo","foo~");

  /* read existing file */
  fd=open("foo",O_RDONLY);
  len=read(fd,buf,BUF_SIZE);
  close(fd);

  /* write to new file and initiate sync */
  fd=open("foo.new",O_WRONLY|O_CREAT|O_TRUNC,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
  write(fd,buf,len);
  cb.aio_fildes=fd;
  (*count)++;
  aio_fsync(O_SYNC,&amp;cb);
  close(fd);

  /* put the new file in place */
  rename("foo.new","foo");

  /* end critical section */
  lockf(sd,F_ULOCK,0);

  /* do something really useful here */

  /* wait for AIO completion */
  aio_suspend(cbl,1,NULL);

  /* clean up shared memory */
  munmap(count,sizeof(int));
  close(sd);

  return 0;
}
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/328105/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel based rename undo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 15:34 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/328136/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you want multiple writers, you definitely need locking.  I was referring <br>
to single writer / multiple readers, which is a far more common situation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel based rename undo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2009 10:22 UTC (Sat)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/328228/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BTW, aio_suspend() has no effect on aio_fsync(). That, for sure, is a bug.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328229"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel based rename undo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2009 12:06 UTC (Sat)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/328229/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The lockf() would also land in trouble with the mmap().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328229/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel based rename undo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2009 4:52 UTC (Sun)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/328250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>A more robust version below:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;aio.h&gt;
#include &lt;errno.h&gt;

/* XXX this is just a demo, no error checking */

static int sd=-1;
static int count=0;
static char filler[2]={0,0};

/* locks */
static struct flock 
  fwl={.l_type=F_WRLCK,.l_whence=SEEK_SET,.l_start=0,.l_len=1},
  ful={.l_type=F_UNLCK,.l_whence=SEEK_SET,.l_start=0,.l_len=1},
  bwl={.l_type=F_WRLCK,.l_whence=SEEK_SET,.l_start=1,.l_len=1},
  brl={.l_type=F_RDLCK,.l_whence=SEEK_SET,.l_start=1,.l_len=1},
  bul={.l_type=F_UNLCK,.l_whence=SEEK_SET,.l_start=1,.l_len=1};

static void aiodone(int signum,siginfo_t *info,void *context){
  /* signal counter down */
  count--;
}

#define BUF_SIZE 50

static void config(struct aiocb *cb){
  int fd;
  ssize_t len;
  char buf[BUF_SIZE];

  /* critical section */
  while(fcntl(sd,F_SETLKW,&amp;fwl));

  /* don't care if it fails, any version is OK */
  link("foo","foo~");

  /* read existing file */
  fd=open("foo",O_RDONLY);
  len=read(fd,buf,BUF_SIZE);
  close(fd);

  /* write to new file */
  fd=open("foo.new",O_WRONLY|O_CREAT|O_TRUNC,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
  write(fd,buf,len);

  /* AIO control block setup */
  memset(cb,0,sizeof(*cb));
  cb-&gt;aio_sigevent.sigev_notify=SIGEV_SIGNAL;
  cb-&gt;aio_sigevent.sigev_signo=SIGRTMIN;
  cb-&gt;aio_fildes=fd;

  /* signal counter up */
  count++;

  /* initiate sync and close */
  aio_fsync(O_SYNC,cb);
  close(fd);

  /* put the new file in place */
  rename("foo.new","foo");

  /* end critical section */
  while(fcntl(sd,F_SETLKW,&amp;ful));
}

#define LOOPS 10
#define TRIES 20

int main(int argc,char **argv){
  int i;
  struct aiocb cb[LOOPS];
  struct sigaction act;

  /* setup shared file, restore */
  if((sd=shm_open("foo",O_RDWR|O_CREAT|O_EXCL,S_IRUSR|S_IWUSR))==-1){
    int tries=TRIES;
    struct stat f;

    /* not the first to arrive, open and wait for restore */
    sd=shm_open("foo",O_RDWR,S_IRUSR|S_IWUSR);

    fstat(sd,&amp;f);
    while(tries-- &amp;&amp; f.st_size&lt;sizeof(filler)){
      sleep(1);
      fstat(sd,&amp;f);
    }

    /* something's really screwed */
    if(!tries)
      return 1;
  } else{ /* first to arrive, restore */
    /* don't care if we fail */
    if(!rename("foo~","foo"))
      fprintf(stderr,"Restored.\n");

    /* setup lock file */
    write(sd,&amp;filler,sizeof(filler));
  }

  /* signal handler setup */
  memset(&amp;act,0,sizeof(act));
  act.sa_flags=SA_SIGINFO;
  act.sa_sigaction=aiodone;
  sigaction(SIGRTMIN,&amp;act,NULL);

  /* we need the backup file to be there */
  while(fcntl(sd,F_SETLKW,&amp;brl));

  /* program may run config many times */
  for(i=0;i&lt;LOOPS;i++){
    config(&amp;cb[i]);

    /* do something really useful here */
  }

  /* wait for AIO completion */
  while(count)
    sleep(1);

  /* unlock the backup file */
  while(fcntl(sd,F_SETLKW,&amp;bul));

  /* try to remove backup file */
  if(!fcntl(sd,F_SETLK,&amp;fwl)){
    if(!fcntl(sd,F_SETLK,&amp;bwl)){
      unlink("foo~");
      while(fcntl(sd,F_SETLKW,&amp;bul));
    }
    while(fcntl(sd,F_SETLKW,&amp;ful));
  }

  /* clean up shared memory */
  close(sd);

  return 0;
}
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/328250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor327726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 20:46 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/327726/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems customary for file system people to excoriate application coders who fail to call fsync() at appropriate moments.  When, though, has calling fsync() at the right moment ever been possible in a shell script?  Is it the opinion that one cannot write a well-behaved reliable, shell script anyway, so effort to accommodate the needs of scripts would be wasted?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 21:57 UTC (Tue)
                               by <b>lmb</b> (subscriber, #39048)
                              [<a href="/Articles/327731/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
# rpm -qf /bin/fsync<br>
sysvinit-2.86-148.1<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 22:10 UTC (Tue)
                               by <b>Chousuke</b> (subscriber, #54562)
                              [<a href="/Articles/327734/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can't you just use 'sync' in a shell script?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 1:49 UTC (Wed)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/327783/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, since sync isn't provided by POSIX. Even if it was, POSIX doesn't require sync() to be synchronous.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 13:33 UTC (Wed)
                               by <b>vaurora</b> (guest, #38407)
                              [<a href="/Articles/327841/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Actually, sync() is POSIX, but you are correct that the definition does not specify that the data on disk by the time it returns, just that it's been scheduled to be written out  However, if you restrict your scripts to Linux and other sane operating systems, you will get the expected behavior modulo disk caching.  From the sync(2) man page:

<pre>
       According to the standard specification (e.g., POSIX.1-2001), sync() schedules the writes,
       but may return before the actual writing is done.  However,  since  version  1.3.20  Linux
       does  actually  wait.   (This  still  does not guarantee data integrity: modern disks have
       large caches.)
</pre>

UFS on Solaris is the only case I know of that actually takes advantage of this hole and returns before the data hits disk.  The last I heard, ZFS did the sane thing and waited.
      
          <div class="CommentReplyButton">
            <form action="/Articles/327841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 13:44 UTC (Wed)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/327843/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The sync() system call is POSIX, but as far as I can tell the sync command isn't. Whether this is actually a real world issue, I have no idea, but since half of these conversations are about being POSIXly correct...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2009 7:10 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/328397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I remember reading at one point that on some older systems sync could exit as soon as the fsync started, but if you did sync;sync the second one could not start until the first finished.<br>
<p>
so sync was not enough sync;sync would do the job, but sync;sync;sync is what people ended up using.<br>
<p>
this could be yet another myth, but it seems to match the facts that I have run across on the topic<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor327743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fsync and scripts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 23:34 UTC (Tue)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327743/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FreeBSD has fsync command. GNU dd has options to do the same. See conv=fsync and conv=fdatasync options.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor327730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Generic RAID layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 21:40 UTC (Tue)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/327730/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The bit about need for generic RAID remapping layer and how partition are of the same kind reminded  me something. Isn't FreeBSD's GEOM layer something like that? <a href="http://unix.derkeiler.com/pdf/Mailing-Lists/FreeBSD/current/2005-04/0329.pdf">http://unix.derkeiler.com/pdf/Mailing-Lists/FreeBSD/curre...</a> and <a href="http://en.wikipedia.org/wiki/GEOM">http://en.wikipedia.org/wiki/GEOM</a> have more information.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 22:05 UTC (Tue)
                               by <b>dberkholz</b> (guest, #23346)
                              [<a href="/Articles/327733/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>One possible solution to this problem is to simply decree that union mounts cannot be exported via NFS. It's not clear that there is a plausible use case for this kind of export in any case.</blockquote>

Imagine an LTSP server or another cluster fileserver that wants to ship out a shared base filesystem with host- or class-specific "overlays" for different roles.
      
          <div class="CommentReplyButton">
            <form action="/Articles/327733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 1:11 UTC (Wed)
                               by <b>ewan</b> (guest, #5533)
                              [<a href="/Articles/327777/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd have thought the usual approach to that would be to export the <br>
read-only base and the host specific overlay and unify them on the <br>
client, not union mount the two on the server and export the result.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 4:50 UTC (Wed)
                               by <b>jamesh</b> (guest, #1159)
                              [<a href="/Articles/327790/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the union is done on the client, then modifying to a file stored in the base layer would involve reading the file contents over the network, then writing it back to the server over the network again.<br>
<p>
A union performed on the server would only result in local IO when copying the file between layers.<br>
<p>
I'm not sure how much of a difference this would make though, since it'd only really hit renames of files in the base layer or partial modification of files.  Neither the "truncate and overwrite" or "write to a temporary file and rename over old" methods of writing files would show much difference between server and client side unions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor327736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2009 22:18 UTC (Tue)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/327736/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If acall touches the scheduler code it looks like just one more thing to plonk from my config.  I like speed and reliability thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 0:05 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327760/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; [After writing the above, your editor noticed that Linus had just merged a change to make data=writeback the default for ext3 in 2.6.30. Your editor, it seems, is easily surprised.] </font><br>
<p>
We got a whole bunch of latency improvements on the back of this as well. fsync(), at least in writeback mode of ext3, should not kill the system for a number of seconds any more, even with an evil dd running in the background:<br>
<p>
<a href="http://marc.info/?l=linux-kernel&amp;m=123902214529919&amp;w=2">http://marc.info/?l=linux-kernel&amp;m=123902214529919&amp;...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 1:22 UTC (Wed)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/327778/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p style="border-style: none none none solid;
   border-color: rgb(51, 51, 255);
   border-width: 2px;
   padding: 0.2em 1em;
   color: darkred;
   max-width: 60em;
   margin-top: 1em;
   margin-left: 0.5em;">
[After writing the above, your editor noticed that Linus had just merged a change to make data=writeback the default for ext3 in 2.6.30. Your editor, it seems, is easily surprised.]</p>

<p>I'm surprised, also.  And a little disappointed.  After all, <font face="monospace">data=ordered</font> has worked fine for, what, <a title="Ext3 on Wikipedia" href="http://en.wikipedia.org/wiki/Ext3">7 1/2 years</a> now?</p>

<p>If it ain't broke, don't fix it.  I'll be modifying my fstab files accordingly.  &lt;/grumble&gt;</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/327778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 1:38 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327781/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can also turn it on at the FS level:<br>
<p>
tune2fs -o journal_data_ordered<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">journal_data_ordered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 3:44 UTC (Wed)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/327785/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Thanks!  But, I'm curious: If I specify <font face="monospace">journal_data_ordered</font> in tune2fs(8), and I put <font face="monospace">data=writeback</font> in <font face="monospace">/etc/fstab</font>, which mode actually gets used?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/327785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">journal_data_ordered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 3:57 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327786/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the one from /etc/fstab. The manual of tune2fs says:<br>
<p>
-o [^]mount-option[,...]<br>
  Set or clear the indicated default mount options in the filesystem.<br>
<p>
I take this to mean that if you have "defaults" in /etc/fstab, then the FS option can specify what is the default for that particular file system. I would think the default would get overridden by an explicit mount option from /etc/fstab though.<br>
<p>
But, that's easy to check. Just set the options on the FS level and/or fstab, mount and check dmesg to see what really happened.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">journal_data_ordered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 5:11 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/327797/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The default spoken of is a kernel level default that applies prior to and <br>
in the absence of any user specified mount options.  In other words, if you <br>
specify data=writeback on any supporting filesystem, that is what you will <br>
get.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">journal_data_ordered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 5:18 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/327798/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My tune2fs(8) man page states:<br>
<p>
"-o [mount_option,...] <br>
<p>
Set or clear the indicated default mount options in the filesys-<br>
tem.  Default mount options can be overridden by  mount  options<br>
specified  either  in /etc/fstab(5) or on the command line argu-<br>
ments to mount(8).  Older kernels may not support this  feature;"<br>
<p>
There are really three "defaults" of course.  The filesystem implementation <br>
level, the filesystem image level, and the /etc/fstab level, in that order.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327811"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">journal_data_ordered</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 7:13 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/327811/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Gee - thanks! I really am blind. My manual page says exactly the same thing (of course)...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327811/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor328099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 5:24 UTC (Fri)
                               by <b>vaurora</b> (guest, #38407)
                              [<a href="/Articles/328099/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A quick note that my comment, "The good news is that BSD union mounts have worked this way for a long time," applies just to the practice of copying up a directory inode on open (but not copying up the directory entries themselves).  For the painfully detailed description of the differences between Linux and BSD mounts, see the LWN article:<br>
<p>
<a href="http://lwn.net/Articles/325369/">http://lwn.net/Articles/325369/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2009 14:42 UTC (Sun)
                               by <b>mdz@debian.org</b> (guest, #14112)
                              [<a href="/Articles/328256/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Things worked for some time until Ubuntu users started testing the alpha "Jaunty" release, which uses ext4 by default.
</blockquote>

Correction (not sure if this is for Jon or Ted):
<p>
Ubuntu does not yet use ext4 by default in any version, including the "Jaunty" development series soon to become Ubuntu 9.04.
<p>
Jaunty does offer ext4 as a non-default option to users who partition their disks manually, as a convenient way for more adventurous users to start testing it.
<p>
Fedora 11, I believe, will install using <a href="https://fedoraproject.org/wiki/Features/Ext4DefaultFs#Current_status">ext4 by default</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2009 22:49 UTC (Mon)
                               by <b>tytso</b> (subscriber, #9993)
                              [<a href="/Articles/328378/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, it was Josef 'Jeff' Sipek who deserves the first mention of application programmers asking for pones, when he posted an April Fools patch submission for the new open flag, O_PONIES --- unreasonable file system assumptions desired.<br>
<p>
Another file system developer who had worked on two major filesystems (ext4 and XFS) had a t-shirt on that had O_PONIES written on the front.   And the joker who distributed the colouring book pages with pictures of ponies was another file system developer working yet another next generation file system.<br>
<p>
Application programmers, while they were questioning my competence, judgement, and even my paternity, didn't quite believe me when I told them that I was the moderate on these issues, but it's safe to say that most of the file system developers in the room were utterly unsympathetic to the idea that it was a good idea to encourage application programmers to avoid the use of fsync().   About the only one who was also a moderate in the room was Val Aurora (formerly Henson).  Both of us recognize that ext3's data=ordered mode was responsible for people deciding that fsync() was harmful, and I've said already that if we had known how badly it would encourage application writers to Do The Wrong Thing, I would have pushed hard not to make data=ordered the default.  Unfortunately, memory wasn't as plentiful in those days, and so the associated page writeback latencies wasn't nearly as bad ten years ago.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2009 0:06 UTC (Tue)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/328385/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Perhaps I'm a little confused,</p>

<p style="border-style: none none none solid;
   border-color: rgb(51, 51, 255);
   border-width: 2px;
   padding: 0.2em 1em;
   color: darkred;
   max-width: 60em;
   margin-top: 1em;
   margin-left: 0.5em;">Both of us recognize that ext3's data=ordered mode was responsible for people deciding that fsync() was harmful</p>

<p>Is your use of the word &quot;harmful&quot; implying a performance hit only?  I'm convinced that fsync() is (relatively) safe and reliable, all other discussions here, there, anywhere, and in POSIX, aside.</p>

<p>The O_PONIES bit (and related T-shirt) was an interesting bit of humor&mdash;I like it!</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/328385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor328948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2009 3:53 UTC (Sat)
                               by <b>roelofs</b> (guest, #2599)
                              [<a href="/Articles/328948/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <FONT COLOR="#884400"><I>The kernel currently contains two software RAID implementations, found in the MD and device mapper (DM) subsystems.</I></FONT>

<P>
"But at least there is symmetry."<SUP>*</SUP>

<P>
<FONT SIZE="-2"><SUP>*</SUP>Ponies -&gt; beast of burden -&gt; ObZathrasQuote...  Sorry, too obscure? :-)</FONT>
      
          <div class="CommentReplyButton">
            <form action="/Articles/328948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor329023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem workshop, day 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 19, 2009 12:58 UTC (Sun)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/329023/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What are the use-cases for stat() needing to return information that is <br>
completely correct at the moment when it's requested?<br>
<p>
For example mainline already has file systems where some of the stat() <br>
information is never correct:<br>
* Number of used blocks is correct only on block based file systems (i.e. <br>
not in JFFS2, UBIFS etc)<br>
* File size doesn't correspond to how much space the file takes from the <br>
file system if file system uses compression<br>
* Time information depends on mount options<br>
* Is st_dev correct for union mounts of union file systems?<br>
<p>
I think nowadays applications should consider stat() mostly as a "best <br>
guess"...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/329023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
