        <!DOCTYPE html>
        <html lang="en">
        <head><title>Safer flexible arrays for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/908817/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/909008/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/908817/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Safer flexible arrays for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>September 22, 2022</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2022-Linux_Security_Summit_Europe">LSS EU</a>
</div>
<p>
At the 2022 <a
href="https://events.linuxfoundation.org/linux-security-summit-europe/">Linux
Security Summit Europe</a> (LSS EU), Gustavo A. R. Silva reported in on
work he has been doing on "flexible" arrays in the kernel.  While these
arrays provide some ... flexibility ... they are also a source of bugs,
which 
can often result in security vulnerabilities.  He has been working on ways
to make the use of flexible arrays safer in the kernel.
</p>

<p>
Silva has a background in embedded systems, working with both realtime
operating systems (RTOS) and embedded Linux. For the last six years, he has 
has been working as an
upstream kernel engineer.   He collaborates with the <a
href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project">Kernel
Self Protection
Project</a> (KSPP) and the Linux kernel division of the Google open-source 
security team.
</p>

<h4>Trailing and flexible arrays</h4>

<p>
He began with an introduction to C arrays, starting with the simplest,
<tt>int&nbsp;happy_array[10];</tt>, which declares an array holding ten
elements of type <tt>int</tt> that can be indexed using the values zero to
nine. <tt>happy_array</tt> is "going to remain happy as long as we access
it within its boundaries".  But C does not enforce those limits, so
developers must do so; if they do not, they end up in what he likes to call
"The Land of Possibilities", also known as undefined behavior.
</p>

<p>
A "trailing" array is one that is declared as the last field in a
structure.  They can have a concrete size, as with <tt>happy_array</tt>, or
they can represent a "blob" of data that is tacked onto the structure at
run time.  For example:
<pre>
    struct blob_holder {
        ...
        size_t count;
        unsigned char blob[];
    }
</pre>
</p>

</p>
Typically, some element in the structure holds the length of the blob, such
as <tt>count</tt> here. In this way, trailing arrays are used to build
variable-length objects (VLOs) in C. 
So a flexible array is simply a trailing array used as a VLO; its size is
determined at run time.  A flexible structure is a <tt>struct</tt> that
contains a flexible array as its last element.
There are three ways to declare flexible arrays, Silva said.  Two of those
are designated as "fake" flexible arrays because they do not use the C99
empty-bracket declaration (i.e. "true" flexible arrays) as above.  Many of
those fake uses predate C99 
entirely and they declare either zero- or one-element arrays to use as
flexible arrays. This usage leads to bugs.
</p>

<p>
Declaring a one-element flexible array is a "buggy hack".  The problem is
that the single element is counted toward the size of the array (and
enclosing structure), which can
easily lead to off-by-one errors.  The count field in the structure is one
larger than what should be allocated, so <tt>count&nbsp;-&nbsp;1</tt> needs
to be used consistently.  When analyzing existing code that uses flexible
structures of that sort, one must always consider the uses of
<tt>sizeof()</tt> for the array and structure.  Often that analysis will find
existing off-by-one and other bugs in the code.
</p>

<p>
A zero-element fake flexible array is a GNU extension that was added to work
around the lack of true flexible arrays in the language at that time.  They
are somewhat less buggy than the one-element arrays, since they do not
contribute to the size of the enclosing structure.  True flexible arrays
must appear last in the structure, which is enforced by the compiler.
Either of the fake flexible array variants can appear anywhere in a
structure, though, which can lead to other kinds of problems, of course.
</p>

<h4>Problems</h4>

<p>
The <tt>sizeof()</tt> operator returns different values for the three
variants.  For the one-element variant, the array's size is that of one
element of the
type of the array; it is zero for the zero-element variant.  But for true
flexible arrays, <tt>sizeof()</tt> gives a compile-time error because the
size is not known.
</p>

<a href="/Articles/909132/">
<img src="https://static.lwn.net/images/2022/lsseu-silva-sm.png" border=0 hspace=5 align="left"
alt="[Gustavo A. R. Silva]" title="Gustavo A. R. Silva" width=195
height=280> 
</a>

<p>
The first flexible-array-transformation <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=76497732932f">fix</a>
that he did as part of his KSPP work shows the kind of problem  that can
stem from fake flexible 
arrays.  A 
zero-length array was declared at the end of a structure, but later someone
<a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e48f129c2f20">added
a field for read-copy-update</a> (RCU) <i>after</i> the flexible array. 
The compiler did not complain, so the bug persisted from 2011 until he
fixed it in 2019.  He used a true flexible array declaration (and moved it
to the end); now if someone adds a new structure member at the end, the
compiler will 
report an error.
</p>

<p>
There has been an effort to enable array-bounds checking in the compiler
with the <tt>-Warray-bounds</tt> option, but the fake flexible
arrays were causing too many false-positives (along with finding some real
bugs). 
It is not uncommon for a flexible array to be indexed directly with a value
that is
beyond the "end" of the array.  Those needed to be fixed before bounds
checking could be turned on.
</p>

<p>
He <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c1e4726f465440">fixed</a>
a simple example in mid-2021.  A one-element array was being accessed with
<tt>[1]</tt>, which is obviously one element too far; changing it to a true
flexible array got rid of the warning. Others are a bit <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=39107e8577ad">more
elaborate</a>, but boil down to a switch to a true flexible array; removing
the one-element array also got rid of a few <tt>count&nbsp;-&nbsp;1</tt>
calculations for allocation sizes.
</p>

<p>
Flexible arrays can be the source or target of <tt>memcpy()</tt> operations
and it would be nice to have them participate in the <a
href="/Articles/864521/">hardened <tt>memcpy()</tt> effort</a>.  When
<tt>CONFIG_FORTIFY_SOURCE</tt> is enabled for the kernel, <tt>memcpy()</tt>
uses the <a
href="https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html"><tt>__builtin_object_size()</tt>
function</a> (with a <tt>type</tt> argument of&nbsp;1) to calculate the sizes
of the source and destination at run time.  
</p>

<p>
For true flexible arrays, though, that function
returns&nbsp;-1 because it cannot determine the size.  Fake
flexible arrays <i>do</i> have a size, but it turns out that
<tt>__builtin_object_size()</tt> still returns&nbsp;-1 for those.  Combining
that with the behavior of <tt>sizeof()</tt> makes things all a bit
confusing as he showed in his <a
href="https://static.sched.com/hosted_files/lsseu2022/5e/lsseu2022_flex_array_transformations.pdf">slides</a>:
<pre>
    __builtin_object_size(flex_struct-&gt;one_element_array, 1) == -1
    __builtin_object_size(flex_struct-&gt;zero_length_array, 1) == -1
    __builtin_object_size(flex_struct-&gt;flex_array_member, 1) == -1

    sizeof(flex_struct-&gt;one_element_array) == size-of-element-type
    sizeof(flex_struct-&gt;zero_length_array) == 0
    sizeof(flex_struct-&gt;flex_array_member) == ? /* Error */
</pre>
</p>

<p>
Because <tt>__builtin_object_size()</tt> cannot
determine a size for trailing arrays, no bounds checking is done in
<tt>memcpy()</tt> (with <tt>CONFIG_FORTIFY_SOURCE</tt>) for those arrays
today.
What's even stranger, perhaps, is that <tt>__builtin_object_size()</tt>
returns&nbsp;-1 for <i>any</i> trailing array, even if it has a specified
size greater than one.  Because <tt>__builtin_object_size()</tt> does not
return a size for trailing arrays, even those that it ostensibly could
determine, no bounds checking is done in
<tt>memcpy()</tt> (with <tt>CONFIG_FORTIFY_SOURCE</tt>) for those arrays
today.  The reason for this <tt>__builtin_object_size()</tt>  behavior is
legacy code that declares trailing arrays 
with a fixed length—but treats them as flexible arrays. He showed a BSD
version of <tt>struct&nbsp;sockaddr</tt> with a trailing array,
<tt>char&nbsp;sa_data[14]</tt>, that can actually hold up to 255 bytes at
run time.
</p>

<p>
In order to allow <tt>memcpy()</tt> to do sanity checking on trailing
arrays, this ambiguity in declarations for flexible arrays needs to be
eliminated. All arrays that are meant to be used as flexible arrays should
be declared as true flexible arrays using <tt>[]</tt>; then, compilers can
be instructed to treat fixed-length 
trailing arrays as regular fixed-length arrays. He pointed to a <a
href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101836">GCC bug
report</a> for a compiler change to address the problem.
</p>

<h4>Compiler flag</h4>

<p>
There is a new compiler flag in the upcoming GCC&nbsp;13 and Clang&nbsp;16
releases 
that will 
allow developers to set the level of strictness for flexible arrays:
<tt>&#8209;fstrict&#8209;flex&#8209;arrays[=n]</tt> (often abbreviated as
<tt>-fsfa</tt>). 
The default setting for <tt>n</tt> is&nbsp;0, which means no change from
today and all trailing arrays are treated as flexible by
<tt>__builtin_object_size()</tt>.  Values of 
<tt>n</tt> from&nbsp;1 to&nbsp;3 increase the strictness of enforcement by
changing the behavior of  <tt>__builtin_object_size()</tt>:
<ul class="spacylist">

<li><b><tt>-fsfa=1</tt></b>: only trailing arrays that are declared with
<tt>[1]</tt>, <tt>[0]</tt>, and <tt>[]</tt> are 
treated as flexible arrays; <tt>__builtin_object_size()</tt> returns the
proper length for others.

<li><b><tt>-fsfa=2</tt></b>: only trailing arrays that are declared with
<tt>[0]</tt> and <tt>[]</tt> are  
treated as flexible arrays; <tt>__builtin_object_size()</tt> returns the
proper length for others.

<li><b><tt>-fsfa=3</tt></b>: only trailing arrays that are declared with
<tt>[]</tt> are 
treated as flexible arrays; <tt>__builtin_object_size()</tt> returns the
proper length for any with a concrete size.

</ul>
</p>

<p>
Unfortunately, the Clang developers have not (yet?) been convinced to add
<tt>-fsfa=3</tt>; there is an ongoing discussion about it, Silva
said.  The work to transform the flexible arrays in the kernel to true
flexible arrays had been going on for several years and there is still more
to do.  Transforming uses of zero-element arrays is fairly straightforward,
but one-element arrays are more difficult to transform because they require
more code inspection to look for off-by-one problems.  Once that is done,
and the compilers are available, <tt>memcpy()</tt> will be able to bounds-check
all trailing (non-flexible) arrays, so all arrays of fixed size will
finally be bounds-checked in the kernel.
</p>

<p>
So there is a path toward getting all of those arrays bounds-checked, what
about checking for actual flexible arrays?  It is a more challenging case,
Silva said,
but there are proposals for ways to handle it. The key is to identify the
structure member that holds the length of the array.  That could be done
with an attribute on the array like the following:
<pre>
    struct bounded_flex_struct {
	...
	size_t elements;
	struct foo flex_array[]
	  __attribute__((__element_count__(elements)));
    };
</pre>
</p>

<p>
There are some user-space API issues to work out, however, when switching
from one-element flexible arrays to true flexible arrays.  The first
attempt at supporting both the existing API and the new way of doing
things duplicated the fields in user-facing 
structures and placed them inside a <tt>union</tt> so
that user space could use the array one way and the kernel could use it the
other: 
<pre>
    struct farray {
        union {
            struct {
                ... /* renamed versions of the members */
                size_t renamed_count;
                int orig_array_name[1];
            };
            struct {
                ... /* members with existing names */
                size_t count;
                int orig_array_name_flex[];
            };
        };
    };
</pre>
</p>

<p>
Doing that caused a lot of code churn, so the
<tt>__DECLARE_FLEX_ARRAY()</tt> helper macro was added that would go in a
union that just contained the arrays:
<pre>
    struct farray {
        ...
        size_t count;
        union {
            int orig_array_name[1];
            __DECLARE_FLEX_ARRAY(int, orig_array_name_flex);
        };
    };
</pre>
In both cases, user space will continue to use <tt>orig_array_name</tt>,
while the kernel will use <tt>orig_array_name_flex</tt>.  One thing to note
is that the size of the structure does not change; the one-element array
will still contribute to the size of the structure.
</p>

<h4>Status, conclusions, and questions</h4>

<p>
At this point, most of the zero-length arrays in the kernel have been
transformed, including handling any user-space API issues.  But there is
nothing stopping 
new ones from being added, so he asked kernel developers not to introduce
new uses.  Transformations for one-element arrays are still a work in
progress; that work is more challenging and there is a need to ensure that
the maintainers of the code being changed feel comfortable that the changes
have not broken anything. To that end, he is using a variety of
<tt>diff</tt>-like tools to try to verify that no significant changes have
been made by the transformation process. 
</p>

<p>
It is important to turn all of the kernel uses of flexible arrays into true
flexible arrays—and then to ensure that no new uses of zero- or one-length
flexible arrays are added, he reiterated.  The security of the kernel can
be significantly 
improved with <tt>&#8209;fstrict&#8209;flex&#8209;arrays=3</tt>, which
means it is important 
to convince the Clang developers to support that setting.  
This work has already found vulnerabilities in the kernel and will surely
find more as it progresses.  It is going to take some time but there is a
clear vision of how we get to the point where all trailing arrays,
fixed-size or flexible, will be bounds-checked in <tt>memcpy()</tt>. 
</p>

<p>
Silva took a few comments and questions at the end of the talk. LSS EU
organizer Elena Reshetova noted that when the conversion from
<tt>atomic_t</tt> to <tt>recount_t</tt> was done, those developers faced a
similar problem with stopping developers from adding new uses of the types
they were trying to convert.  They ended up integrating a test into the
<a href="https://01.org/lkp/documentation/0-day-brief-introduction">0-day
test robot</a> to catch those introductions and send email.  That worked
well and she encouraged Silva to try something like that.
</p>

<p>
I asked what reasons the Clang developers had for opposing the strictest
setting on the new compiler flag. Silva said that their position is "just
don't use zero-length arrays" but he deferred to Kees Cook, who said he
could speak to the "minutiae of that".  The Clang folks point out that
zero-length arrays are not legal C, according to the standard, so if the
GNU extension allowing them is removed, zero-length arrays do not exist so
the <tt>=2</tt> level is sufficient.  Adding another option to support
having zero-length arrays that are not flexible arrays seems pointless within
that community, Cook said.
</p>

<p>
"Unfortunately, that's not the reality of our world."  When the GNU
extension was added, some code used zero-length arrays as flexible arrays,
while other code used them as actual arrays with no elements in order to place
markers inside structures, for example.  In addition, there are arrays in
the kernel that typically have some fixed size but that size may fall to
zero in certain configurations.  
</p>

<p>
There are probably ways to work around the
lack of that option for Clang, Cook said, but it would be much easier for
the Clang developers to
accept the reality that zero-length arrays exist and that the kernel (at
least) wants to be able to stop treating them as flexible arrays.  There is
a flag available to warn on the use of zero-length arrays, but it produces
60,000 warnings on the kernel code, so that is not a sensible path either,
Silva said. It is clear that the hope is for the Clang folks to relent on
this particular point.
</p>

<p>
[I would like to thank LWN subscribers for supporting my travel to Dublin
for the Linux Security Summit Europe.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Variable-length_arrays">Variable-length arrays</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#C_language">C language</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Hardening">Linux kernel/Hardening</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Security_Summit_Europe-2022">Linux Security Summit Europe/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/908817/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor909137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 0:06 UTC (Fri)
                               by <b>ndesaulniers</b> (subscriber, #110768)
                              [<a href="/Articles/909137/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://reviews.llvm.org/D126864">https://reviews.llvm.org/D126864</a> for the review comments in the initial implementation of -fstrict-flex-arrays in clang.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 0:09 UTC (Fri)
                               by <b>ndesaulniers</b> (subscriber, #110768)
                              [<a href="/Articles/909138/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And additional color: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101836#c32.">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101836#c32.</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor921871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">clang will implement -fstrict-flex-arrays=3</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 16:28 UTC (Wed)
                               by <b>david.a.wheeler</b> (subscriber, #72896)
                              [<a href="/Articles/921871/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FYI: After this article was published the clang folks decided to add -fstrict-flex-arrays=3. Here's the commit:<br>
<a href="https://github.com/llvm/llvm-project/commit/7f93ae808634e33e4dc9bce753c909aa5f9a6eb4">https://github.com/llvm/llvm-project/commit/7f93ae808634e...</a><br>
<p>
This is expected to be in LLVM 16, at the time of this writing that should be out in a few months.<br>
So there *is* movement on this front!<br>
<p>
(My thanks to Nathan Chancellor for letting me know about this upcoming change to clang.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor909139"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 0:53 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/909139/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Clearly the way forward is for all the actual zero size arrays in Linux to be written in Rust since in Rust types with zero size are a completely unremarkable idea we use all the time :D<br>
<p>
But yes, I think Clang relenting makes the most sense. Zero Size Types are good. Standard C and C++ can&#x27;t have them without ripping the mask off when it comes to pointers, but that&#x27;s a price the kernel is certainly willing to pay. &quot;Flexible&quot; arrays are less obviously good, but they&#x27;re a pragmatic extension to C, and they aren&#x27;t somehow the same thing as ZSTs, so it makes little sense to implement both but then insist people can only have one or the other.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909139/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 3:07 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/909141/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>I think there's still an active proposal for adding better array semantics to C. Two actually, but they're related. I believe both have missed the C2x cut-off, but judging by straw poll reporting still under consideration for post-C2x changes. They effectively add dependent typing, extending and improving variably-length array (VLA) semantics. See, e.g., https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2660.pdf and follow-ups N2779, N2905, N2906.</p>

<p>VLAs--more precisely, variably-modified types (VMTs)--are what permit C99 and later code to declare arrays like,</p>

<pre>
  size_t n = 10;
  int a[n];
</pre>

<p>with sizeof working as expected,</p>

<pre>
  printf("%zu\n", sizeof a / sizeof a[0]); // prints 10
</pre>

<p>C99 also added VLA syntax for function arguments, but it's useless on account of retained array-to-pointer decay semantics, despite this being infinitely higher on the wish list for most C programmers (IMO), who also mostly (and rightly) shun VMTs. So this is valid code,</p>

<pre>
  foo(size_t n, int a[n]) {
      ...
  }
</pre>

<p>but sizeof doesn't work as expected as `a` has still decayed to a pointer. To make things nominally consistent--but just as useless--the standard says that `int a[n]` in prototypes is treated as-if written `int a[*]`, where `*` means unspecified length. So the most obvious fix here is making VLAs in function arguments work sanely. While conceptually simple, the required changes would be backward incompatible. One proposed workaround is adding a new operator, lengthof, to complement sizeof. sizeof could still work as before, but compilers would be permitted (or required) to complain and suggest lengthof. There are still some other potential incompatibilities regarding function declaration semantics, though, that either need to be worked around or swallowed as necessary medicine.</p>

<p>The second prong to better array types marry VLAs and flexible array members (FAMs). At least, that's how I conceptualize of it in my head. Similar to how automatic storage VLAs (aka VMTs) *do* work, and to how function declaration VLAs *should* work, improved FMAs would look like:</p>

<pre>
  struct foo {
    size_t n;
    int a[n];
  }
</pre>

<p>This informs the compiler that the size of FAM `a` is a function of the value of member `n`. Correct me if I'm wrong, but this is literally dependent typing, albeit simple and strictly limited to this kind of declaration. In principal this feature shouldn't be too onerous to implement as it's effectively identical to how automatic variable VLAs behave today--sizeof must be computed at runtime rather than being a compile-time constant. And there aren't any backwards compatibility worries, except for sizeof (arguable as sizeof wouldn't work before, but lengthof workaround would suffice nonetheless), or regarding some proprietary extensions (IIRC, GCC might support this syntax, but not the semantics--`n` is ignored as a side-effect of some other GCC feature). One ugly issue to resolve is how to *initialize* `n`. AFAIU this is not unrelated to a similar issue in Rust regarding array initializations, though the C community would likely more be accepting of a solution that still leaves a potential foot-gun lying around (e.g. sizeof/lengthof on `a` undefined if  `n' not explicitly and correctly assigned beforehand), whereas the Rust community (or at least the current Rust developers) are adamant that no gaps in soundness guarantees be introduced.</p>

<p>These two language changes don't per se get us to strict array bounds checking in C, but they're necessary prerequisites for being able to apply Fortify-like bounds checking ubiquitously and comprehensively. Personally I've never found __builtin_object_size very useful precisely because I have no way to comprehensively and reliably declare my array types appropriately; it's currently all just best effort and very hand wavy. I would gladly contribute hard cash (maybe even 4-figure cash, though the work is worthy of at least 6-figure renumeration) if it helped redirect GCC and clang efforts to first implementing the above extensions to VLAs. And having a proper implementation of these proposals in GCC or clang would go a long way toward their ultimate acceptance by the C committee. Contrast that with Fortify and __builtin_object_size, where they're so obviously deficient--at least, absent the above changes--that few would even seriously question why they wouldn't be under consideration by the C committee.</p>






      
          <div class="CommentReplyButton">
            <form action="/Articles/909141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 5:20 UTC (Fri)
                               by <b>kees</b> (subscriber, #27264)
                              [<a href="/Articles/909153/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup, this is the purpose of the proposed &quot;element_count&quot; attribute, which can entirely bypass needing a C language spec change, letting us just get it working. With __builtin_dynamic_object_size this will significantly improve bounds checking coverage. (And also adding the &quot;access&quot; function attribute.)<br>
<p>
See <a href="https://lore.kernel.org/linux-hardening/e2a0debe-e99f-2259-1cb9-35193c387c82@gotplt.org/">https://lore.kernel.org/linux-hardening/e2a0debe-e99f-225...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 6:15 UTC (Fri)
                               by <b>jrtc27</b> (subscriber, #107748)
                              [<a href="/Articles/909159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Such standard attributes would also be useful for CHERI; by default, bounds are based on the allocation, but have an opt-in mode (in fact, more than just one, but they get increasingly aggressive and standard breaking) to add subobject bounds which we enable for the pure-capability CheriBSD kernel configuration, and then have to go annotate things that don&#x27;t play nicely with it to opt-out on a per-member/type basis. We have various variants in <a href="https://github.com/CTSRD-CHERI/cheribsd/blob/6a9e74b4bd73bef8cffdb0f134fc657fed60e029/sys/sys/cdefs.h#L235-L312">https://github.com/CTSRD-CHERI/cheribsd/blob/6a9e74b4bd73...</a>, but for the dependent type case we just have to make it be treated like a flexible array member, so a standardised annotation for that would give us additional expressivity (and maybe some of what we had might be usefully fed back into standardised GNU attributes, since there&#x27;s a lot of overlap with the goals?).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor921820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 13:18 UTC (Wed)
                               by <b>syrjala</b> (subscriber, #47399)
                              [<a href="/Articles/921820/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wouldn't call using the array notation for function arguments entirely useless. It at last conveys to the reader the fact that the argument is supposed to be an array rather than just a pointer. I've wasted far too much time sifting through code trying to figure out exactly what one is supposed to pass in to random functions that apparently take just pointers.<br>
<p>
OTOH it is a bit of a footgun for C newbies. Maybe the compiler could warn about sizeof(foo) when foo was declared as one of these "array that's actually a pointer" things?<br>
<p>
I've also made an unfortunate observation about forward declarations vs. array function arguments:<br>
struct foo;<br>
void whatever(struct foo *stuff);<br>
-&gt; fine<br>
<p>
struct foo;<br>
void whatever(struct foo stuff[]);<br>
-&gt; fails to build :(<br>
<p>
Personally I would call that a bug, but maybe it's because of some specific stupid clause in the standard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 13:30 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/921825/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Maybe the compiler could warn about sizeof(foo) when foo was declared as one of these "array that's actually a pointer" things?</span><br>
<p>
GCC and Clang already do this by default:<br>
<p>
<span class="QuotedText">&gt; warning: ‘sizeof’ on array function parameter ‘stuff’ will return size of ‘struct foo *’ [-Wsizeof-array-argument]</span><br>
<p>
<span class="QuotedText">&gt; warning: sizeof on array function parameter will return size of 'struct foo *' instead of 'struct foo [n]' [-Wsizeof-array-argument]</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor909250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 17:04 UTC (Fri)
                               by <b>bluss</b> (subscriber, #47454)
                              [<a href="/Articles/909250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ZST work fine in Rust but I would say from experience that unsafe code has to handle it carefully and a lot of corner cases in Rust and Rust libraries have to fixed through history due to this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor909492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">tangentially-related rant about flexible arrays</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2022 19:11 UTC (Mon)
                               by <b>floppus</b> (guest, #137245)
                              [<a href="/Articles/909492/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      It's kind of crazy that it's legal to take the "sizeof" a structure with a flexible array in it.

If I have
<pre>
    struct foo {
        int i;
        char c[];
    } *x;
</pre>
then "sizeof(x-&gt;c)" is an error (as the article says), but "sizeof(*x)" is perfectly acceptable and not even a warning.
<p>
(I've been thinking about this recently because of a bug in my own code that would have been caught by such a warning.)
<p>
I can't think of any scenario where "sizeof(*x)" or "sizeof(struct foo)" is the correct thing to write - what you probably mean to write is "offsetof(struct foo, c)".  Even if "sizeof" and "offsetof" happen to give the same answer (which is hard to guarantee), "offsetof" has the advantages of being compatible with the pre-C99 hacks, AND making it apparent to the reader that you're doing something funky with memory.





      
          <div class="CommentReplyButton">
            <form action="/Articles/909492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921811"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">tangentially-related rant about flexible arrays</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 7:38 UTC (Wed)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/921811/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>...that's because <tt>sizeof(*x)</tt> is asking for the size of what's pointed to by x, which in the case of structures is the first element of the structure. So it's actually asking for <tt>sizeof(x-&gt;i)</tt> in your example.</p>

<p><tt>struct foo {<br>&emsp;short int i;<br>&emsp;char c[];<br>} *x;</tt></p>

<p>The above would cause <tt>sizeof(x[0])</tt> or <tt>sizeof(*x)</tt> to return 2 on most platforms.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/921811/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921813"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">tangentially-related rant about flexible arrays</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 8:14 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/921813/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; ...that's because sizeof(*x) is asking for the size of what's pointed to by x, which in the case of structures is the first element of the structure. So it's actually asking for sizeof(x-&gt;i) in your example.</span><br>
<p>
No, x points to the structure, the expression *x has a structure type (not short int), and sizeof(*x) is the size of that structure. A pointer to a structure is distinct from a pointer to its first field; they have different types, even though the addresses are equal. If the array member were a normal non-flexible array (char c[20]) it would be included in sizeof(*x). Likewise, if there were fields besides i and c in the structure they would be counted in sizeof(*x) with or without the flexible array. The size of the flexible array member is not known statically, but for the purpose of the sizeof operator it's treated as it if were zero-length. (But not as if it were missing; it still affects alignment.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921813/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor909891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2022 2:25 UTC (Fri)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/909891/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You *never* use sizeof on a struct with a flexible array member. You use offsetof of that member plus the size of the extra area to allocate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor921887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Safer flexible arrays for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 19:46 UTC (Wed)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/921887/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there ongoing towards the the __element_count__ attribute? I didn't find anything in my initial search. <br>
<p>
I would be quite interested in using it in postgres... <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
