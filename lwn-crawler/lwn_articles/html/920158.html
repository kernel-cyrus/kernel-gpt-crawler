        <!DOCTYPE html>
        <html lang="en">
        <head><title>Nolibc: a minimal C-library replacement shipped with the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/920158/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/920485/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/920158/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Nolibc: a minimal C-library replacement shipped with the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>January 20, 2023</p>
           <p>This article was contributed by Willy Tarreau</p>
           </div>
<p>The kernel project does not host much user-space code in its repository,
but there are exceptions.  One of those, currently found in the <a
href="https://elixir.bootlin.com/linux/v6.2-rc4/source/tools/include/nolibc"><tt>tools/include/nolibc</tt></a>
directory, has only been present since the 5.1 release.  The nolibc project
aims to provide minimal C-library emulation for small, low-level workloads.
Read on for an overview of nolibc, its history, and future direction
written by its principal contributor.

<p>The nolibc component actually made a discreet entry into the 5.0 kernel
as part of the RCU torture-test suite ("rcutorture"), via <a
href="https://git.kernel.org/linus/66b6f755ad45">commit 66b6f755ad45</a>
("rcutorture: 
Import a copy of nolibc"). This happened after Paul McKenney <a
href="/ml/linux-kernel/20180823174359.GA13033@linux.vnet.ibm.com/">asked</a>:
"<q>Does anyone do kernel-only deployments, for example, setting up an
embedded device having a Linux kernel and absolutely no userspace
whatsoever?</q>"

<p>He went on:
<p>
<blockquote class="bq">
	The mkinitramfs approach results in about 40MB of initrd, and
	dracut about 10MB.  Most of this is completely useless for
	rcutorture, which isn't interested in mounting filesystems, opening
	devices, and almost all of the other interesting things that
	mkinitramfs and dracut enable.
<p>
	Those who know me will not be at all surprised to learn that I went
	overboard making the resulting initrd as small as possible.  I
	started by throwing out everything not absolutely needed by the
	dash and sleep binaries, which got me down to about 2.5MB, 1.8MB of
	which was libc.
</blockquote>

<p>This description felt familiar to me, since I have been solving
similar problems for a long time.  The end result (so far) is nolibc — a
minimal C library for times when a system is booted only to run a single
tiny program.

<h4>A bit of history: when size matters</h4>

<p>For 25 years, I have been building single-floppy-based emergency
routers, firewalls, and traffic generators containing both a kernel and a
root filesystem. I later moved on to credit-card-sized live CDs and,
nowadays, embedding tiny 
interactive shells in all of my kernels to help better recover from boot
issues. 

<p>All of these had in common a small program called <a
href="https://github.com/formilux/flxutils/tree/master/init">preinit</a>
that is in charge of creating <tt>/dev</tt> entries, mounting
<tt>/proc</tt>, optionally mounting a RAM-based filesystem, and loading
some extra modules before executing <tt>init</tt>. The
characteristic that all my kernels have in common is that all of their
modules are 
packaged within the kernel's builtin initial ramfs, reserving the initial
RAMdisk (initrd) for the root filesystem.  When the kernel boots, it pivots
the root and boot mount points to make the pre-packaged modules appear at
their final location, making the root filesystem independent of the kernel
version used. This is extremely convenient when working from flash or
network boot, since you can easily swap kernels without ever touching the
filesystem.

<p>Because it had to fit into 800KB (or smaller) kernels, the preinit code
initially had to be minimal; one of the approaches consisted of strictly
avoiding stdio or high-level C-library functions and reusing code and data
as much as possible (such as merging string tails). This resulted in code
that could be statically built and remain small
(less than 1KB for the original floppy version)  thanks to its small
dependencies.

<p>As it evolved, though, the resulting binary size was often dominated by
the C-library initialization code. Switching to <a
href="https://www.fefe.de/dietlibc/">diet libc</a> helped but, in 2010, it
was not evolving anymore and still had some limitations.  I replaced it
with the slightly larger — but more active — <a
href="https://uclibc.org/">uClibc</a>, with a bunch of functions
replaced by local alternatives to keep the size low (e.g. 640&nbsp;bytes
were saved on <tt>memmove()</tt> and <tt>strpcy()</tt>), and used this
until 2016.

<p>uClibc, in turn, started to show some more annoying limitations which
became a concern when trying to port code to architectures that it did not
support by then (such as aarch64), and its maintenance was falling off.  I
started to consider using <a
href="https://git.kernel.org/pub/scm/libs/klibc/klibc.git">klibc</a>, which
also had the advantage of being developed and maintained by kernel
developers but, while klibc was much more modern, portable, and closer to
my needs, it still had the same inconvenience of requiring to be built
separately before being linked into the final executable.

<p>It then started to appear obvious that, if the preinit code had so
little dependency on the C library, it could make sense to just define the
system calls directly and be done with it. Thus, in January 2017, some
system-call definitions were moved to macros. With this new ability to
build without relying on any C library at all, a natural-sounding name
quickly emerged for this project: "nolibc".

<p>The first focus was on being able to build existing code as seamlessly
as possible, with either nolibc or a regular C library, because ifdefs in
the code are painful to deal with. This includes the ability to bypass the
"include" block when nolibc was already included on the command line, and
not to depend on any external files that would require build-process
updates. Because of this, it was decided that only macros and static
definitions would be used, which imposes some limitations that we'll
cover below.

<p>One nice advantage for quick tests is that it became possible to include
<tt>nolibc.h</tt> directly from the compiler's command line, and to rely on
the <tt>NOLIBC</tt> definition coming from this file to avoid including the
normal C-library headers with a construct like:

<p>
<pre>
    #ifndef NOLIBC
    #include &lt;stdint.h&gt;
    #include &lt;stdio.h&gt;
    /* ... */
    #endif
</pre>

<p>This allows a program to be built with a regular C library on architectures
lacking nolibc support while making it easy to switch to nolibc when it is
available. This is how rcutorture currently uses it.

<p>Another point to note is that, while the resulting binary is always
statically linked with nolibc (hence it is self-contained and doesn't
require any 
shared library to be installed), it is still usually smaller than with
glibc, with either static or dynamic linking:

<p>
<pre>
    $ size init-glibc-static init-glibc init-nolibc
    text    data     bss     dec     hex  filename
    707520  22432   26848  756800   b8c40 init-glibc-static
     16579    848   19200   36627    8f13 init-glibc
     13398      0   23016   36414    8e3e init-nolibc
</pre>

<p>Given that this binary is present in all my kernels, my immediate next
focus was supporting the various architectures that I was routinely using:
i386, x86_64, armv7, aarch64, and mips. This was addressed by providing
architecture-specific setup code for the platforms that I could test. It
appeared that a few system calls differ between architectures
(e.g. <tt>select()</tt> or <tt>poll()</tt> variants exist on some
architectures), and even some structures can differ, like the
<tt>struct&nbsp;stat</tt> passed to the <tt>stat()</tt> system call. It was
thus decided that the required ifdefs would all be inside the nolibc code,
with the occasional wrapper used to emulate generic calls, in order to
preserve the ease of use.

<h4>The painful <tt>errno</tt></h4>

<p>A last challenging point was the handling of <tt>errno</tt>. In the
first attempt, the preinit loader used a negative system-call return value
to carry an error-return code. This was convenient, but doing so ruins
portability because POSIX-compliant programs have to retrieve the error
code from the global <tt>errno</tt> variable, and only expect system
calls to return -1 on error.  (I personally think that this original design
is a mistake that complicates everything but it's not going to change and
we have to adapt to it).

<p>The problem with <tt>errno</tt> is that it's expected to be a global
variable, which implies that some code has to be linked between nolibc and
the rest of the program.  That would remove a significant part of the ease
of use, so a trade-off was found: since the vast majority of programs using
nolibc will consist of a single file, let's just declare <tt>errno</tt>
static. It will be visible only from the files that include nolibc, and
will even be eliminated by the compiler if it's never used.

<p>The downside of this approach is that, if a program is made of multiple
files, each of them will see a different <tt>errno</tt>. The need to
support multi-file programs is rare with nolibc, and programs relying on a
value of <tt>errno</tt> collected from another file are even less common,
so this was considered as an acceptable trade-off. For programs that
don't care and really need to be the smallest possible, it is possible to
remove all assignments to <tt>errno</tt> by defining
<tt>NOLIBC_IGNORE_ERRNO</tt>.

<h4>A proposal</h4>

<p>Base on the elements above, it looked like nolibc was the perfect fit
for rcutorture. I sent <a
href="/ml/linux-kernel/20180823190657.GA12057@1wt.eu/">the proposal</a>,
showing what it could achieve: a version of the <tt>sleep</tt> program in a
664-byte binary.  (Note that, since then, some versions of binutils have
started 
to add a section called "<tt>.note.gnu.property</tt>", which stores
information about 
the program's use of hardening extensions like <a
href="/Articles/885220/">shadow stacks</a>,
that pushes the code 4KB apart).

<p>McKenney expressed interest in this approach, so we tried together to port
his existing program to nolibc, which resulted in faster builds and much
smaller images for his tests (which is particularly interesting in certain
situations, like when they're booting from the network via TFTP for
example).  With this change, rcutorture automatically detects if nolibc
supports the architecture, and uses it in such cases, otherwise falls back
to the regular static build.

<p>The last problem I was seeing is that, these days, I'm more than
full-time on <a href="http://www.haproxy.org/">HAProxy</a> and, while I
continue to quickly glance over all 
linux-kernel messages that land in my inbox, it has become extremely
difficult for me to reserve time on certain schedules, such as being ready
for merge windows.  I didn't want to become a bottleneck for the project,
should it be merged into the kernel.  McKenney offered to host it as part of
his -rcu tree and to take care of merge windows; that sounded like a
great deal for both of us and that initial work was quickly <a
href="/ml/linux-kernel/20181111200127.GA9511@linux.ibm.com/">submitted</a>
for inclusion.

<h4>Contributions and improvements</h4>

<p>Since the project was merged, there have been several discussions about how
to improve it for other use cases, and how to better organize it. Ingo
Molnar <a
href="/ml/linux-kernel/20181204080837.GA67285@gmail.com/">suggested</a>
pulling it out of the RCU subdirectory to make it easier to use for other
projects. The code was duly moved under <tt>tools/</tt>.

<p>Support for RISC V came in 5.2 by Pranith Kumar; S390 support was
posted by Sven Schnelle during 6.2-rc and was merged for a future version.
Ammar Faizi <a href="/ml/linux-kernel/20211011040344.437264-1-ammar.faizi@students.amikom.ac.id/">found
some interesting ABI issues</a> and inconsistencies that were <a
href="https://git.kernel.org/linus/937ed91c7122">addressed in 5.17</a>;
that made Borislav Petkov <a
href="/ml/linux-kernel/YWXwQ2P0M0uzHo0o@zn.tnic/">dig into glibc</a>
and the <a 
href="https://gitlab.com/x86-psABIs">x86 psABI</a> (processor specific
ABI — basically the calling convention that makes sure that all programs
built for a given platform are interoperable regardless of compiler and
libraries used).  After this work, the psABI spec <a
href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/merge_requests/25">was
updated</a> to reflect 
what glibc actually does.

<p>At this point, it can be said that the project has taken off, as it even
received <a
href="/ml/linux-kernel/20220322102115.186179-1-ammarfaizi2@gnuweeb.org/">a
tiny dynamic-memory allocator</a> that is sufficient to run
<tt>strdup()</tt> to keep a copy of a command-line argument, for example.
Signal handling is also <a
href="/ml/linux-kernel/20221222035134.3467659-1-ammar.faizi@intel.com/">currently
being discussed</a>.

<h4>Splitting into multiple files</h4>

<p>It appeared obvious that the single-file approach wasn't the most
convenient for contributors, and that having to ifdef-out regular include
files to help with portability was a bit cumbersome. One challenge was to
preserve the convenient way of building by including <tt>nolibc.h</tt>
directly from the source directory when the compiler provides its own
kernel headers, and to provide an installable, architecture-specific
layout. This problem was addressed in 5.19 by having this <tt>nolibc.h</tt> file
continue to include all other ones; it also defines <tt>NOLIBC</tt>, which
is used by older programs to avoid loading the standard system headers.

<p>Now the file layout looks like this:
<p>
<pre>
    -+- nolibc.h      (includes all other ones)
     +- arch-$ARCH.h  (only in the source tree)
     +- arch.h        (wrapper or one of the above)
     +- ctype.h
     +- errno.h
     +- signal.h
     +- std.h
     +- stdio.h
     +- stdlib.h
     +- string.h
     +- sys.h
     +- time.h
     +- types.h
     +- unistd.h
</pre>

<p>The <tt>arch.h</tt> file in the source tree checks the target
architecture and includes the corresponding file. In the installation tree,
it is simply replaced by one of these files. In the source tree, it's only
referenced by <tt>nolibc.h</tt>.  This new approach was already confirmed
to be easier to deal with, as <a
href="/ml/linux-kernel/20221209141939.3634586-1-svens@linux.ibm.com/">the
s390 patches</a> touched few files. This clean patch set may serve as an
example of how to bring support for a new architecture to nolibc. Basically
all that 
is needed is to add a new arch-specific header file containing the assembly
code, referencing it in the <tt>arch.h</tt> file, and possibly adjusting
some of the existing system calls to take care of peculiarities of the new
architecture. Then the kernel self tests and rcutorture should be updated
(see below).

<h4>Two modes of operation</h4>

<p>The kernel defines and uses various constants and structures that user
space needs to know; these include system-call numbers, <tt>ioctl()</tt>
numbers, structures like <tt>struct&nbsp;stat</tt>, and so on. This is
known as the UAPI, for "user-space API", and it is exposed via kernel
headers.  These headers are needed for nolibc to be able to communicate
properly with the kernel.

<p>There are now two main ways to connect nolibc and the UAPI headers:
<ul>

<li> <p>The quick way, which works with a libc-enabled toolchain without
     requiring any installation. In this case, the UAPI headers found under
     <tt>asm/</tt> and <tt>linux/</tt> are provided by the toolchain
     (possibly the native one).  This mode remains compatible with programs
     that are built directly from the source tree using "<tt>-include
     $TOPDIR/tools/include/nolibc/nolibc.h</tt>".

</li>

<li> <p>The clean way that is compatible with bare-metal toolchains such as
     <a href="https://mirrors.edge.kernel.org/pub/tools/crosstool/">the
     ones found on kernel.org</a>, but which requires an installation to
     gain access to the UAPI headers. This is done with
     "<tt>make&nbsp;headers_install</tt>". By combining this with the nolibc
     headers, we get a small, portable system root that is compatible with
     a bare-metal compiler for one architecture and enables building a
     simple source file into a working executable. This is the preferred
     mode of operation for the kernel self tests, as the target
     architecture is known and fixed.

</li>
</ul>
<h4>Tests</h4>

<p>The addition of new architectures showed the urgency of developing some
self tests that could validate that the various system calls are properly
implemented.  One feature of system calls is that, for a single case of
success, there are often multiple possible causes of failure, leading to
different <tt>errno</tt> values. While it is not always easy to test them
all, a reasonable framework was designed, making the addition of new tests,
as much as possible, burden-free.

<p>Tests are classified by categories — "syscall" (system calls) and
"stdlib" (standard C library
functions) only for
now — and are simply numbered in each category. All the effort consists of
providing sufficient macros to validate the most common cases. The code is
not pretty for certain tests, but the goal is achieved, and the vast
majority of them are easy to add.

<p>When the test program is executed, it loops over the tests of the
selected category and simply prints the test number, a symbolic name, and
"OK" or "FAIL" for each of them depending on the outcome of the test. For
example, here are two tests for <tt>chdir()</tt>, one expecting a success
and the other a failure:

<pre>
    CASE_TEST(chdir_dot);    EXPECT_SYSZR(1, chdir(".")); break;
    CASE_TEST(chdir_blah);   EXPECT_SYSER(1, chdir("/blah"), -1, ENOENT); break;
</pre>

<p>Some tests may fail if certain configuration options are not enabled, or
if the program is not run with sufficient permissions. This can be overcome
by enumerating the tests to run or avoid via the <tt>NOLIBC_TEST</tt>
environment variable.  The goal here is to make it simple to adjust
the tests to be run with a boot-loader command line.
The output consists of OK/FAIL results for each test and a count of
total errors.

<p>The Makefile in <tt>tools/testing/selftests/nolibc</tt> takes care of
runing the tests,
including installing nolibc for the current architecture, putting it
into an initramfs, building a kernel equipped with it, and possibly
starting the kernel under QEMU. All architecture-specific settings are set
with variables; these include the defconfig name, kernel image
name, QEMU command line, etc.

<p>The various steps remain separated so that the makefile can be used from
a script that would, for example, copy the kernel to a remote machine or to
a TFTP server.

<p>
<pre>
    $ make -C tools/testing/selftests/nolibc
    Supported targets under selftests/nolibc:
    all          call the "run" target below
    help         this help
    sysroot      create the nolibc sysroot here (uses $ARCH)
    nolibc-test  build the executable (uses $CC and $CROSS_COMPILE)
    initramfs    prepare the initramfs with nolibc-test
    defconfig    create a fresh new default config (uses $ARCH)
    kernel       (re)build the kernel with the initramfs (uses $ARCH)
    run          runs the kernel in QEMU after building it (uses $ARCH, $TEST)
    rerun        runs a previously prebuilt kernel in QEMU (uses $ARCH, $TEST)
    clean        clean the sysroot, initramfs, build and output files
    (...)
</pre>

<p>It is also possible to just create a binary for the local system or a
specific architecture without building a kernel (useful when creating new
tests).

<p>One delicate aspect of the self tests is that, if they need to build a
kernel, they have to be careful about passing all required options to that
kernel. It looked desirable here to avoid confusion by using the same
variable names as the kernel (<tt>ARCH</tt>, <tt>CROSS_COMPILE</tt>, etc.) in
order to limit the risk of discrepancies between the kernel that is being
built and the executable that is put inside.

<p>As there is no easy way to call the tests from the main makefile, it is
not possible to inherit common settings like kernel image name, defconfig,
or build options. This was addressed by enumerating all required variables
by architecture, and this appears to be the most maintainable.

<p>While the tests were initially created in the hope of finding bugs in
nolibc's system-call implementations (and a few were indeed found), they
also proved useful to find bugs in its standard library functions (e.g. the
<tt>memcmp()</tt> and <tt>fd_set</tt> implementations were wrong).  It is
possible that they might, one day, become useful to detect kernel
regressions affecting system calls. It's obviously too early for this, as
the tests are quite naive and more complete tests already exists in other
projects like the <a href="https://github.com/linux-test-project/ltp">Linux
Test Project</a>. A  more likely situation would be for a new system call
being developed with its test in parallel, and the test being used to debug
the system call.

<h4>Current state, limitations, and future plans</h4>

<p>The current state is that small programs can be written, built on the
fly, and used. Threads are not implemented, which will limit some of the
tests, unless the code uses the <tt>clone()</tt> system call and does not
rely on thread-local storage or thread cancellation. Mark Brown managed to
implement <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/arm64/abi/tpidr2.c">some
tests for TPIDR2 on arm64</a> that use threads managed directly inside the
test.

<p>Many system calls, including the network-oriented calls and trivial ones
like <tt>getuid()</tt> that nobody has needed, are still not implemented,
and the <tt>string.h</tt> and <tt>stdlib.h</tt> functions are still 
limited, but it is expected that most kernel developers will be able to
implement what they are missing when needed, so this is not really a
problem.

<p>The lack of data storage remains a growing concern, first for
<tt>errno</tt>, then for the <tt>environ</tt> variable, and finally also
for <a href="/Articles/519085/">the auxiliary vector</a> (AUXV, which
contains some settings like the page size). While all of them could easily
be recovered by the program from <tt>main()</tt>, such limitations were
making it more difficult to implement new extensions, and a patch set
addressing this was <a
href="/ml/linux-kernel/20230109084208.27355-1-w@1wt.eu/">recently
submitted</a>.

<p>McKenney and I had discussions about having a more interactive tool,
that would allow running a wider variety of tests that could all be
packaged together. This tool might include a tiny shell and possibly be able
to follow a certain test sequence. But it's unclear yet if that should be
part of a low-level self-testing project or if, instead, the focus should
remain on making it easier to create new tests that could be orchestrated
by other test suites.

<h4>A tandem team on the project</h4>

<p>I don't know if similar "tandem" teams are common in other subsystems,
but I must admit that the way the maintenance effort was split between
McKenney and myself is efficient. My time on the nolibc project is
dedicated to contribution reviews, bug fixes, and improvements — not much
more than what it was before its inclusion into the kernel, thanks to
McKenney taking care of everything related to inclusion in his -rcu tree,
meeting deadlines, and sending pull requests. For contributors, there may be
a perceived small increase in time between the moment a contribution is
published and when it appears in a future kernel, if I have to adjust it
before approving it, but it would be worse if I had to deal with
it by myself.

<p>It took some time and effort to adapt and write the testing
infrastructure, but now it's mostly regular maintenance. It seems to me
like we're significantly limiting the amount of processing overhead caused
by the project on our respective sides, which allows it to be usable in the
kernel at a  low cost. For McKenney, the benefit is a reduced burden
for his testing tools like rcutorture. For me, getting feedback, bug
reports, fixes, and improvements for a project that is now more exposed than
it used to be, is appreciated.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Nolibc">Nolibc</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Tarreau_Willy">Tarreau, Willy</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/920158/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor920664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2023 17:47 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/920664/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If somebody needs a very small libc, you should also consider this one: <a href="https://keithp.com/picolibc/">https://keithp.com/picolibc/</a><br>
<p>
Its advantage is focus on math functions and floating point emulation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2023 3:24 UTC (Sat)
                               by <b>keithp</b> (subscriber, #5140)
                              [<a href="/Articles/920690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Thanks for the plug, but these appear to target very different needs — nolibc looks like it's for building user-space Linux tests with as little overhead as possible, and doesn't pretend to support much of the standard C library. Picolibc is a complete C library for embedded systems but doesn't have any Linux support. 
<p>
However, the notion of a set of C library functions which can be simply built as part of your application and not compiled into a separate library (with a separate build system) is pretty cool, and someone is already thinking about <a href="https://github.com/picolibc/picolibc/issues/409">trying that with bits of picolibc</a>





      
          <div class="CommentReplyButton">
            <form action="/Articles/920690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor920684"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2023 0:11 UTC (Sat)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/920684/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Shameless plug: <a href="https://github.com/XeCycle/mini-tools">https://github.com/XeCycle/mini-tools</a><br>
But I have to admit I’m targeting a different case, such that I chose not to support errno and did not bother to include an allocator.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920684/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor920687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2023 1:37 UTC (Sat)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/920687/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, reminds me of the Unikernel idea where there is no kernel &lt;&gt; userspace divide. Turns out there are folks working on that for Linux:<br>
<p>
<a href="https://github.com/unikernellinux">https://github.com/unikernellinux</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 22:11 UTC (Sun)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/920760/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note that UKL uses a slightly modified glibc and doesn't aim to produce small binaries.  In fact the binaries - really whole kernels - that we produce are absolutely massive right now, although we're working on that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor920692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2023 6:02 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/920692/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's excellent, I hoped that others would voice in suggesting related projects, and in 4 comments we discover 3 alternative projects. It definitely shows that there's an expressed need for a low-level stdlib, especially when it comes to embedded systems (like picolibc seems to address) or just early kernel. In all such environments the problem is the same, we have to reimplement everything before starting to have a usable main().<br>
<p>
Based on previous discussions for splitting nolibc into multiple files, the point was raised a few times that what is desired is to have the OS-independent stuff being either self-sustaining (e.g. memcpy()) or relying on a portable syscall API and _start code, and that's why we split the code like this (probably far from being perfect yet). In a modern world we could imagine the stdlib being provided with the language (and toolchain) and the syscall with the OS and arch, both in source form so that they're built on the fly with the resulting program. Maybe building the high-level stuff would be slow once the lib becomes rich though.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2023 8:21 UTC (Sat)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/920695/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not even a need for a low-level stdlib always so much as a "Why do we require literally megabytes just to get Hello World to run?" situation. Even on a modern system with SSD's I was surprised how much of the boot time was waiting for ~50MB of initrd to be read off of the disk and decompressed.<br>
<p>
In theory all the tools are there, libc.so could be a set of much smaller components that could be dlopen'ed transparently the first time any given families of functions are called and instrumented to let other software only copy over actually required components, but that's less "efficient" (performance hits, re-using mappings across processes, etc) for the normal system case where hundreds of tools will all be loading libc in parallel.<br>
<p>
So instead they're even removing separate libraries and merging them into libc.so lately like pthreads and bulking up the single monolithic library even more.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 2:19 UTC (Sun)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/920725/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Keeping pthreads separate from glibc core is one of the major reasons glibc is so bloated and convoluted, as they basically had to duplicate 1/2 of it to support dynamic loading of libpthread, plus even more complexity so those internal pieces worked cleanly with the related pthreads primitives. In fact, dlopen and related interfaces are crazy complex because of this. Pthreads integration has made musl smaller and simpler, including dlopen and the dynamic linker. Fortunately, glibc recently merged libpthread into the core, though negative consequences of the separation may never be fully eliminated. Similarly, another source of bloat and headaches in glibc is NSS support, which was originally justified for much the same reasons as you propose: putting lesser used facilities behind dlopen'd modules. But abstraction invites complexity, especially when it prevents you from implementing a simple, 80% solution inline. Notably, musl rejected NSS support.<br>
<p>
A major reason for musl's lighter footprint is eschewing locale support--the original idea was that simply being UTF-8 clean would suffice for a POSIX-compliant environment, though they eventually had to backtrack somewhat even after some concessions from [future] POSIX. glibc's locale support adds alot of weight, and significantly impacts performance. OTOH, this is probably one of the more justifiable features of glibc; at least, justifiable at a time when Unix environments, and libc specifically, were more often relied upon for higher-level application interfaces--timekeeping, I18N, string processing, etc. OTOOH, simply avoiding locale interfaces entirely, POSIX be damned, is one of the easiest choices to justify for a lightweight, embedded libc.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 2:49 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/920726/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; this is probably one of the more justifiable features of glibc</span><br>
<p>
No, it's not. It would have been justifiable if the interface were a little bit more thought out. But it's thread-unsafe and clunky.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor928799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2023 22:38 UTC (Tue)
                               by <b>Phoenix591</b> (guest, #157780)
                              [<a href="/Articles/928799/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if you manually adjust your kernel config, depending on your disk layout, you can get down to no/ a nice small initrd. If not using lvm or raid or luks for / you can just build everything into the kernel and be fine without one. I use lvm for my / and have a 2.5 M initrd with static lvm, fsck, busybox, and microcode. to get root mounted.<br>
<p>
boots faster than the autogenerated giant initrds too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/928799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor929620"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2023 11:32 UTC (Thu)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/929620/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><em>In theory all the tools are there, libc.so could be a set of much smaller components that could be dlopen'ed transparently the first time any given families of functions are called and instrumented to let other software only copy over actually required components, but that's less "efficient" (performance hits, re-using mappings across processes, etc) for the normal system case where hundreds of tools will all be loading libc in parallel.</em></blockquote>
<p>
Systems like Linux already use “demand paging”, i.e., only those pages of libc.so (or any executable) that contain code which is actually being executed are fetched into memory (and evicted again if their code hasn't been executed in some time). Chances are that, with loads of different processes using libc.so simultaneously, almost all of it will be used by <em>something</em>, but in principle the system is pretty good at ignoring unneeded stuff, so the added complication of subdividing libc.so seems unnecessary.
</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/929620/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor929774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2023 10:20 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/929774/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Rather than splitting libc.so, then, would a better option be to work out what pages of libc are commonly used together, and group things such that you don't page in the bits you're not going to use? That way, you need only build system changes to libc (possibly quite big ones), but then all applications benefit immediately (e.g. if you don't ever use the X/Open Message Catalog interface for message translation, you don't page in any of the functions involved in that interface).


      
          <div class="CommentReplyButton">
            <form action="/Articles/929774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor920713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2023 15:57 UTC (Sat)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/920713/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great stuff. Hope to see more LWN articles from this "guest writer". <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor920731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 10:24 UTC (Sun)
                               by <b>MrWim</b> (subscriber, #47432)
                              [<a href="/Articles/920731/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another very impressive libc is cosmopolitan libc: <a href="https://justine.lol/cosmopolitan/index.html">https://justine.lol/cosmopolitan/index.html</a><br>
<p>
Statically linked, smaller than dynamically linked glibc. Binaries run on multiple platforms.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 21:43 UTC (Sun)
                               by <b>pgarciaq</b> (subscriber, #153687)
                              [<a href="/Articles/920759/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cosmopolitan is so impressive and unbelievable advanced when you first read about it, that it seems an April Fools. But it's for real.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor920763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 22:26 UTC (Sun)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/920763/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for sharing this nice piece of art. This one is absolutely awesome.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor920786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2023 14:34 UTC (Mon)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/920786/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sadly apple have moved to arm64 so it is less universal now!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor920739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 15:40 UTC (Sun)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/920739/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If Nolibc consists only of headers containing macros and static functions, doesn't this mean that if an application consists of more than one C file, it may contain multiple copies of a library function called by both files?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2023 22:23 UTC (Sun)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/920762/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; doesn't this mean that if an application consists of more than one C file, it may contain multiple copies of a library function called by both files?</span><br>
<p>
In case of multiple files, yes definitely, but most of them are quite small, and multi-file projects relying on something like nolibc are rare.<br>
<p>
A few functions had to be exported and we found how to do it by declaring them with the weak attribute (e.g. raise(), memcpy() and a few other ones that libgcc may depend on). In this case it's during the linking stage that the linker decides to keep a single copy of each. That's also how we dealt with errno/environ/etc lately. Eventually we could imagine replacing all static functions with weak ones if it proves to provide any benefit (not convinced at the moment).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 5:45 UTC (Wed)
                               by <b>remexre</b> (guest, #138784)
                              [<a href="/Articles/921809/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought that was what the inline keyword "actually means" -- or is that only for C++?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2023 13:11 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/921821/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
`inline` (at least for C++ and AFAIK) is mostly a linking behavior change these days. The optimizer will inline or not as it sees fit anyways. `inline` means that if you do stamp out the full function, don't export a symbol for it. I don't know that the linker can optimize these because it might be different instances of the same function (though looking and seeing that they're the same object code could work I suppose). A weak symbol "exists" and can be exported.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor920765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2023 0:28 UTC (Mon)
                               by <b>xxiao</b> (guest, #9631)
                              [<a href="/Articles/920765/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
why not musl, or a locale-removed musl to further downsize its already small size?<br>
<p>
dietlibc, ulibc are pretty outdated,  even picolib or newlibs are not as popular/tested-in-the-field as musl these days. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2023 4:14 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/920768/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  why not musl, or a locale-removed musl to further downsize its already small size?</span><br>
<p>
As indicated in the article, in the context of the kernel, having a "library" that doesn't require to already be pre-built is a significant advantage when you're doing testing with various architectures. Musl could very well be included prebuilt in the toolchain, just like glibc or uclibc and then the problem is solved. But with bare-metal toolchains (or multi-arch ones like clang) using just a .h is cool.<br>
<p>
Musl however definitely is the best glibc alternative to me, allowing to build virtually any mainstream application.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2023 10:28 UTC (Mon)
                               by <b>zoobab</b> (guest, #9945)
                              [<a href="/Articles/920775/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Glibc breaks static compilation for political purposes, without documenting it, see <a rel="nofollow" href="http://stalinux.wikidot.com/">http://stalinux.wikidot.com/</a><br>
<p>
At least with musl static compilation is possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2023 11:00 UTC (Mon)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/920776/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Political purposes like nss not working when statically linked because it's obviously impossible for nss to work when statically linked?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2023 19:43 UTC (Mon)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/920881/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Musl not supporting NSS in the first place fixes the problem of NSS not being available in a statically linked binary. ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor920935"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2023 11:53 UTC (Tue)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/920935/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Supporting NSS via other way besides dlopen() from arbitrary process is almost fully implemented already - nscd. I don't get why that approach isn't used more widely. It would solve other problems also, for example having to have both 32-bit and 64-bit .so:s of every NSS module.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920935/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2023 14:34 UTC (Tue)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/920949/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
nscd is mostly dead these days, e.g. <a href="https://fedoraproject.org/wiki/Changes/DeprecateNSCD">https://fedoraproject.org/wiki/Changes/DeprecateNSCD</a> and <a href="https://www.fedoraproject.org/wiki/Changes/RemoveNSCD">https://www.fedoraproject.org/wiki/Changes/RemoveNSCD</a> .<br>
<p>
Using NSS makes it relatively easy to replace nscd with something modern like sssd and systemd-resolved like the above deprecation issue mentions, without having to have a big flag day and recompile $WORLD. ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2023 18:55 UTC (Tue)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/921082/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't understand where "big flag day and recompile $WORLD" would be needed. nscd is a client-server system over UNIX sockets, so "to replace it with something modern" you'd just replace the server part with something that speaks the same protocol.<br>
<p>
In fact, someone already has done such a server reimplementation of the nscd: <a href="https://github.com/pikhq/musl-nscd">https://github.com/pikhq/musl-nscd</a> - and apparently musl does support talking the nscd protocol (TIL, I thought it really does only basic /etc/passwd et al reading).<br>
<p>
So if that musl-nscd project actually is mature and well-maintained, then sounds like musl has a superior NSS implementation to the glibc one - one that works from statically linked binaries (unlike glibc), doesn't need installing 32-bit versions of all NSS modules separately, and no risk of mess of NSS modules potentially loading incompatible shared objects with the user program.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2023 21:07 UTC (Tue)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/921092/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not very familiar with the nscd socket protocol, but I'm not sure it does everything needed considering nscd does only caching and not lookups, which is why we get these backwards setups where things like ldap and tls libraries are mapped into the client process address space, and each client is responsible for looking up stuff independently if the entry is not found in nscd. Luckily e.g. sssd fixes that architectural misstep, but, well, that's sssd and not nscd.<br>
<p>
Also, IIRC nscd relies on the client process mmap'ing the cache DB, the socket protocol is only used as a control protocol and actual data is accessed via mmap?<br>
<p>
In an ideal world NSS could instead, back in the day, have been designed as a set of well-designed unix socket interfaces, and then individual daemons would be responsible for lookups, caching etc. (with perhaps an exception for a built-in local /etc/{passwd,group} implementation). Oh well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2023 16:43 UTC (Wed)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/921213/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At least to the extent musl uses nscd, that part of the protocol seems just sensible request-response one: <a href="https://github.com/bminor/musl/search?q=nscd">https://github.com/bminor/musl/search?q=nscd</a> (1st one having __nscd_query).<br>
<p>
It does appear to be the case that the protocol allows some craziness like the client can query the file descriptors of the cache files (via SCM_RIGHTS fd passing over Unix sockets): <a href="https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/nscd/connections.c#L1274">https://github.com/lattera/glibc/blob/895ef79e04a953cac14...</a> . Musl doesn't seem to use so maybe not everything is supported, or maybe that is some weird attempt at optimization to reduce IPC overhead.<br>
<p>
I do know that for sure (at least in the past) glibc does support doing the lookups from the nscd daemon because I have setup such a system in the past. That is, libnss_foo.so were located outside the usual library search path, so any application wouldn't find and dlopen() it. Then, the directory containing libnss_foo.so was added to LD_LIBRARY_PATH of nscd.service. I don't remember anything being broken (for a basic LDAP logins use case).<br>
<p>
(That was on the NixOS distribution, where there is no global /lib and multiple versions of every package, including glibc, can coexist on the system. So in-process NSS module loading quickly leads to disaster).<br>
<p>
<span class="QuotedText">&gt; In an ideal world NSS could instead, back in the day, have been designed as a set of well-designed unix socket interfaces, and then individual daemons would be responsible for lookups, caching etc. (with perhaps an exception for a built-in local /etc/{passwd,group} implementation).</span><br>
<p>
That's the thing - from what I can tell nscd-the-protocol is basically 80% of the way there! But sadly there seems to be no interest in glibc side. Maybe there is hope for musl folks to improve it (maybe by taking and documenting the good parts of the current protocol and then speccinc and implementing any needed extensions and hoping that glibc would eventually implement those). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor920887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nolibc: a minimal C-library replacement shipped with the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2023 20:58 UTC (Mon)
                               by <b>anguslees</b> (subscriber, #7131)
                              [<a href="/Articles/920887/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nolibc's design reminded me of newlib in particular - iirc newlib also uses inline macros/headers to avoid a separate library compilation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
