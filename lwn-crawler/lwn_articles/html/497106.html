        <!DOCTYPE html>
        <html lang="en">
        <head><title>User and group mount options for ext filesystems [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/497106/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/496626/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/497106/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>User and group mount options for ext filesystems</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>May 16, 2012</br>
           </div>
<p>
When transporting files between systems using USB sticks or other removable
media, one can run into an annoying problem: the UIDs or GIDs of the files
on the media don't match those on the system.  In most situations, those
kinds of devices have a VFAT filesystem that avoids the problem entirely by not
storing UID/GID information.  But if a user wants to use a "real"
filesystem on the device, one of the ext* family for example, it might be
useful to specify the local owner of the files.  Ludwig Nussel's <a
href="/Articles/496891/">patch set</a> would do just that for ext2, ext3,
and ext4 
filesystems.  
</p>

<p>
The patch comes from some work Nussel did "<q>years ago</q>", he
said, when <a href="/Articles/497141/">re-introducing it</a>. It simply
adds two new mount options for ext filesystems.  Following in the footsteps
of the VFAT filesystem, the patch would add <tt>uid=</tt> and <tt>gid=</tt>
options that would treat all files in the filesystem as being owned by that
UID/GID combination.

When a filesystem is mounted using these options, files retain their
ownership on disk, but they 
appear to be owned by the specified user and group.  Existing files cannot
have their ownership changed, but new files will be created with the user
and group given at mount time.  If a different UID/GID combination is
desired for new files&mdash;to match the UID/GID on the device for
example&mdash;they can be added to the mount option:
<pre>
    uid=m:n
    gid=x:y
</pre>
which would make the files appear to be owned by m.x and would create new
files as n.y.
</p>

<p>
One of the first questions to greet Nussel's patch was about putting the
code into specific filesystems, rather than the VFS layer.  While the VFS
seems like the right place, Ted Ts'o <a href="/Articles/497209/">points
out</a> that there is no easy way to do it all there:
<div class="BigQuote">
The problem is that there will need to be at least some
support in the individual file system, since there isn't a good place
for the VFS to intercept the internal file system iget() function to
patch in the override uid/gid values.
<p>
So the question at this point is whether it's cleaner to have the
functionality split between the VFS and the file system layers (i.e.,
with the options parsing and storing the override uid/gid values in
the super_block structure) or keeping it all in the file system layer,
and accepting the duplication of code across multiple file systems.
</div>
</p>

<p>
Ts'o leaned toward the first approach in that message, but later <a
href="/Articles/497222/">reluctantly accepted</a> the code duplication.
From what he could see, there wasn't enough of a win to put it into the VFS.

<p>
There was a little more discussion when Nussel <a
href="/Articles/497214/">resent the patch</a> on May 10.  First off, Jan
Kara and Ts'o both wanted to see the patch split into three parts (one for
each of ext2, 3, and 4), which Nussel did and posted the next day.  But,
Roland Eggner and Boaz Harrosh were both concerned about the underlying
idea of the patch.  Circumventing the access restrictions on the files via
a mount option is not a sensible way to address what is, really, an
administrative problem, they said.
</p>

<p>
Eggner <a href="/Articles/497215/">described</a> how he "solves" the problem
for systems he administers by essentially creating and using a static list
of UIDs and GIDs. His position is: "<q>If UIDs differ on machines
FORESEEN for file exchange, this is an 
administrator error, not a kernel deficit.</q>"  Furthermore,
exchanging files with unexpected systems requires root privileges, he said,
so there 
is no need for the mount option override.
</p>

<p>
Like Eggner, Harrosh is <a href="/Articles/497216/">concerned</a> about
security issues with the proposed change.  He also doesn't see anything
particularly special about the ext filesystems in terms of removable media,
noting that VFAT is the dominant choice.  Beyond that, he questions the
definition of "removable media", and notes that the problem is common in
the NFS world: "<q>we constantly encounter multiple domain
uid/gid views, and it does not mean we blow a hole in POSIX security
rules.</q>" 
</p>

<p>
But Neil Brown <a href="/Articles/497217/">sees</a> things a little
differently. He notes that VFAT suffers from limitations including a 4G
file size limit and an inability to handle some special characters in file
names. 
That aside, when someone has physical access to a device, it is essentially
"removable" in some sense, so that someone may want to easily access the
data: 
<div class="BigQuote">
[...] if I "own" a filesystem - whether because I hold the
physical non-encrypted devices or because I know the encryption key - then I
want to be able to  leverage that "ownership" to full access rights to
the contents of the filesystem.  By typing in a key or plugging in a device I
want to get full "root" access to the filesystem on the device.  Not giving
that to me is just getting in my way.
</div>
</p>

<p>
When users insert a VFAT-formatted USB stick or disk, suitably configured
systems will give full access to the user by using the VFAT uid/gid
options.  Nussel's patches essentially 
just give that same power for ext-formatted devices.  While it could
certainly lead to problems, those problems are already latent, as Brown
pointed out:
<div class="BigQuote">
 You cannot prevent data
destruction on such devices if you lose physical control, and the only
workable data privacy option is encryption.  Trying to pretend that file
permission bits mean anything is extremely naive.
</div>
</p>

<p>
While Harrosh is concerned that automounters will start using the options,
Brown believes that makes sense for removable devices.  In the patch,
Nussel mentions 
that it could be done statically in <tt>/etc/fstab</tt> or be handled
dynamically through udev rules.  The alternative
suggested by Harrosh is that root can mount the device and then
<tt>chmod</tt> (or <tt>chown</tt>, presumably) the files appropriately.
That seems like a pointless exercise that will just have to be repeated,
potentially every time the device is plugged into a new system.  Eggner's
method is certainly workable, at some level, but makes things more difficult
and less "user friendly", Brown said.
</p>

<p>
In the end, it is a convenience feature.  Anyone with physical access to a
unencrypted removable device already has the tools available to read the
data on it or 
to put malware onto it.  It's a little hard to see how making it easier for
legitimate owners of removable USB storage to access their data somehow
opens the floodgates for attackers of various sorts.  Those of a malicious
bent can find any number of ways (live CD, their own Linux system, ...) to
access the device as root if they wish.
</p>

<p>
It is unclear how prevalent ext-formatted removable devices are, so there
may be an argument against adding the feature on those grounds.  On the
other hand, making the ext family work better may encourage people to use those
filesystems more often for removable media.  The patches do
duplicate code in the three separate filesystems, but the total number of
lines is changed is only around 100 lines for each.  Moving some of that
into the VFS (like parsing the mount options and storing the flags in the
superblock) might reduce that a bit, but
it's not much code overall.  Administrators who are worried about the
feature will be able to avoid it entirely, though they may need to keep an
eye on their distribution's udev rules.  Given that it brings the same
convenience as VFAT to ext-formatted devices, it seems like a feature worth
having. 
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Mounting">Filesystems/Mounting</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/497106/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor497459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This patch is even more useful for data servers than for removable media!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 2:19 UTC (Thu)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/497459/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that an important use case for such a patch is being completely overlooked.  I basically just wrote the same patch and we are considering deploying this patch internally on some of our servers.  Such a patch can be very useful from a sysadmin standpoint to prevent many permission related mistakes.<br>
<p>
Picture a data serving daemon which runs as a non root user and which needs read/write access to an entire volume of data.  It is not uncommon to place this data on a single partition for ease of management.  All the files and directories on this partition need the same simple access policy and would be greatly served by the simple uid and gid options suggested in this article.  Any other ownership of any data on this partition is inherently an admin mistake and serves no other purpose than to be POSIX compliant.  Without such a mount option, it is only a matter of time until a mistake bites the service (an admin mistakingly copies a file as root, the service can not write to this new file...). <br>
<p>
How many admins have cron jobs which scan an entire directory tree to verify that every object is porperly owned to combat (poorly) exactly this?  Such cron hacks should be easily eliminated entirely with this patch, please apply it right away!  :)  Backport it even to every kernel in every distro still used in production!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 5:53 UTC (Thu)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/497476/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I strongly agree with this. I have volumes on my file servers where I very strongly wish I could disable POSIX permissions entirely, replacing them with an inherited ACL from a file system root or subdirectory root.<br>
<p>
I want to be able to say "Absolutely all files within this tree must always have the permissions &lt;x&gt;, don't make me waste my time with badly behaved programs that set stupid umasks, idiotic network access clients, etc. Just MAKE IT SO."<br>
<p>
The only issue I see with this patch is that it's done at the file system level, and IMO this is something that'd be useful for subtrees within a file system too.<br>
<p>
I hate to say it, but what I want is to turn off UNIX-style permissions for some directory trees and have Windows-style inherited ACLs instead. Right now I can have the ACLs, but the permissions triplets always take priority, so some stupid @#$#@W app that sets mode 0700 every directory it creates (I'm looking at you, Thunderbird) still breaks access for everyone else. What I want is for the FS to completely ignore permissions within those trees or force them to a specified value on file/directory creation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2012 15:00 UTC (Fri)
                               by <b>jackb</b> (guest, #41909)
                              [<a href="/Articles/497736/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>I strongly agree with this. I have volumes on my file servers where I very strongly wish I could disable POSIX permissions entirely, replacing them with an inherited ACL from a file system root or subdirectory root.
I want to be able to say "Absolutely all files within this tree must always have the permissions &lt;x>, don't make me waste my time with badly behaved programs that set stupid umasks, idiotic network access clients, etc. Just MAKE IT SO."</blockquote>I believe the only way to get what you want is to use Samba and CIFS. It can't be done with local filesystems or NFS.
      
          <div class="CommentReplyButton">
            <form action="/Articles/497736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor499986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2012 6:03 UTC (Sun)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/499986/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Windows ACLs are a mess too --- they're attached to files (think "inodes"), not directory entries. If you have a file foo/bar.txt and bar.txt has dutifully inherited its ACL from foo on creation, then if you move foo/bar.txt to qux/bar.txt, bar.txt *retains its old ACL*. Some tools, like Explorer, will reset file ACL on move, but this work is done at the UI-tool level, not the OS level.<br>
<p>
Also, Windows supports hard links. Imagine that instead of moving foo/bar.txt to qux/bar.txt, we added qux/bar.txt as a hard link. Which inherited ACL does bar.txt have? It turns out that whichever parent directory modifies its ACL last, wins. (This flaw applies to all ACL inheritance schemes.)<br>
<p>
Honestly, I prefer old-fashioned Unix permissions to ACL inheritance. Permissions bits are a lot less confusing and combined with path traversal checking (i.e., in order to read foo/bar.txt, you need execute permission on foo and read permission on bar.txt), it's actually rather flexible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/499986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2012 4:40 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/500054/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think the behavior you described is unreasonable, I'm not sure what "better" behavior would be in that situation.  In any event there are far far far more people who prefer ACLs and find them better for practical use than Unix permissions bits for shared file management.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2012 5:09 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/500059/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
please show me any system that allows both unix permissions and ACLs where more people use the ACLs than the unix permissions.<br>
<p>
the fact that more people use windows ACLs is because more people use windows due to the apps that it supports, not because they prefer the ACL model.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor500110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2012 13:16 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/500110/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with the system quotemstr describes is that it is path-dependent: if you look at the inherited set of ACLs attached to some directory, you cannot use it to determine what the properties of files underneath are likely to be unless you know the history of those files (which is not recorded anywhere). Worse yet, files *outside* that directory may have been affected by its ACL, as long as they were at one point within that directory -- or, rather, they would have been affected by whatever ACL it had at that point (it may have been changed, but the moved-out file's ACL would not have changed).<br>
<p>
Thus, you cannot look at the limited set of ACLs attached directly to files and their inherited permission set to figure out what their actual ACLs are: you have to look at the whole, huge, set for every single file, because the inheritance is a thin layer atop that implementation, and the underlying layer shows through (though that it shows through on non-GUI file moves is particularly shoddy).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2012 13:33 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/500111/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You just need to know parent directory's ACL and file's ACL. No need for anything more significant.<br>
<p>
Windows ACLs are a PITA - they're so complicated that one needs a PhD in aclology too understand them completely. But they actually allow several very useful use-cases that depend on ACL inheritance.<br>
<p>
In general, I like Unix permission bits for static structures (like /usr or /var filesystems) but I absolutely hate them for shared dynamic directories.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500206"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2012 18:12 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/500206/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
You just need to know parent directory's ACL and file's ACL. No need for anything more significant.
</blockquote>
As I pointed out, for Windows ACLs, that is not true: you need to know the mv history of the file and (since files might have been moved out of and then back into directories with inherited ACLs) the ACL history of all directories it has moved into over its lifetime as well. None of this information is recorded anywhere.
      
          <div class="CommentReplyButton">
            <form action="/Articles/500206/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2012 18:42 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/500214/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why? Moving a file simply changes its ACLs. No need to track them for the whole lifetime of the file.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500549"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2012 17:33 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/500549/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As was pointed out a few posts up, moving a file does *not* change its ACLs unless you do the move *from the GUI*. A command-line move leaves the ACLs unchanged, and does not respect inherited ACLs (i.e. inherited ACLs are not really part of the permission system but are a hack implemented at the GUI level). Thus the problems I mentioned.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500549/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor500258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2012 23:43 UTC (Mon)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/500258/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The right thing to do would have been to attach ACLs to *directory entries*, not to files themselves. When you do that, everything automatically just works.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 0:29 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/500260/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The right thing to do would have been to attach ACLs to *directory entries*, not to files themselves.</font><br>
<p>
That would certainly simplify the ACL inheritance situation, but it's the files themselves you want to control access to, not the directory entries. Having different permissions depending on how you access the file seems like a big step backward to me.<br>
<p>
"Live" inherited ACLs have obvious issues; the hard-link case is particularly bad. However, "static" inheritance, as with the default POSIX ACL associated with a directory, offers a reasonable compromise. A file receives the default ACL of the directory in which it is created, and retains that ACL (unless separately modified) even if the file is moved or hard-linked into another directory. If inheritance is preferred after a move or directory permission change, the default ACL of the new containing directory can be re-applied as a separate step.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 1:47 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/500264/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;That would certainly simplify the ACL inheritance situation, but it's the files themselves you want to control access to, not the directory entries. Having different permissions depending on how you access the file seems like a big step backward to me.</font><br>
Why? It's totally natural and logical. <br>
<p>
And it's not quite unlike the current situation - you must have +r access to file's directory to be able to read it (if you obtain the file handle to it by doing path traversal).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 15:30 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/500317/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And it's not quite unlike the current situation - you must have +r access to file's directory to be able to read it (if you obtain the file handle to it by doing path traversal).</font><br>
<p>
The current situation is that you need read permission to a directory to read its directory entries (e.g. with ls), and search (+x) permission to access files and directories under it. The two are orthogonal; you don't need read access just to traverse a directory, and you don't need search permission just to list the contents.<br>
<p>
You also need read access to the individual file to access the file's contents, and typically _that_ is what you want to protect. The read and search bits on the directory govern access to the directory (listing and traversing), while the permission bits on the file govern access to the file's contents.<br>
<p>
In the common case of one directory entry per file, there is no difference between your proposal and the way the system already works. Each file would still have one set of permissions, just stored in the directory entry rather than the inode. However, in the case of a file hard-linked into multiple directories, a single item (the contents of the file) would have multiple, possibly conflicting, permissions, depending on the directory entry used to access it. I consider that a step backward from the current model of one clear-cut set of permissions per filesystem object.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 17:11 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/500340/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;In the common case of one directory entry per file, there is no difference between your proposal and the way the system already works. Each file would still have one set of permissions, just stored in the directory entry rather than the inode. However, in the case of a file hard-linked into multiple directories, a single item (the contents of the file) would have multiple, possibly conflicting, permissions, depending on the directory entry used to access it. I consider that a step backward from the current model of one clear-cut set of permissions per filesystem object.</font><br>
Why is it bad? <br>
<p>
Personally, I'd simply ban hardlinks completely if it was up to me. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 18:40 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/500352/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you can't see why it's a bad idea for both security and usability to have two different, conflicting sets of permissions for the same data, then I can only say that I'm glad you probably don't have any influence on this issue. Consider the case of restricting write access to a file: you would need to know about, and have write access to, _all_ the directory entries referring to that file, as opposed to just a single inode in the current model.<br>
<p>
That goes double for the idea of banning hard links, which are actually quite useful and logical given the separation between human-readable names and inodes. In any case, without hard links there is no motive for moving the permission bits to the directory entry, as you suggest, since the mapping between directory entries and inodes would be one-to-one. Only the case with hard-links is interesting in this context.<br>
<p>
The filesystem permissions apply to inodes and not directory entries for a reason, and once you replace the limited owner/group/other model with POSIX ACLs, the system works rather well as-is. It's only the Windows-style permission model which has issues relating to inherited ACL.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 20:41 UTC (Tue)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/500379/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sometimes it's a GOOD idea to have different sets of permissions. The final permission set is just the union of both, something that can be difficult to express otherwise. It would be possible to create *complimentary* permissions, but not conflicting (they are only conflicting if you think of the bits as restriction flags, not permission flags).<br>
<p>
In the case of write access, you only need back-pointers (from inode to directory) like btrfs has to trivially get "_all_ the directory entries referring to that file".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 21:24 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/500383/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In the case of write access, you only need back-pointers (from inode to directory) like btrfs has to trivially get "_all_ the directory entries referring to that file".</font><br>
<p>
You'd still need write access to all those directories to change the permissions stored in the directory entries. That can be a problem if you own the file, but someone else owns some or all of those directories. Alternatively, the system could grant write access to directory entries based on the ownership of the target inode rather than the ownership of the directory. Both methods are counter-intuitive.<br>
<p>
Regular POSIX ACLs can already express the union of two sets of permissions. There is no need to vary the permissions based on the path used to access the file.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2012 21:52 UTC (Tue)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/500384/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You don't need write permissions, because what you're describing is not very reasonable. Imagine we are talking about copies of the data. Would you expect to have a magic command to wipe out all copies of "your" data? Well, if you're the RIAA you would, but it would be unreasonable.<br>
<p>
If you have write permissions, you can wipe the file contents clean and destroy your links. Others will still be able to open the file, but the data would not be there anymore. If you have read permissions, then all you can do is remove your link.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2012 0:48 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/500418/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You don't need write permissions, because what you're describing is not very reasonable. Imagine we are talking about copies of the data. Would you expect to have a magic command to wipe out all copies of "your" data?</font><br>
<p>
Obviously not. I'm not concerned with copies, just the original, mutable file. If the file is static then the only function of hard links is to save space. As you say, each user might as well have their own copy of the file, and I wouldn't expect to be able to control that copy after granting access.<br>
<p>
<font class="QuotedText">&gt; If you have write permissions, you can wipe the file contents clean and destroy your links. Others will still be able to open the file, but the data would not be there anymore.</font><br>
<p>
If the contents of the file are dynamic rather than static, then destroying the links removes not just write access, but also read-only access to any future updates. Let's say that there is a file which I own, and which I'm sharing with several other users. Some of these users should be able to write to the file, while others only get read access. For whatever reason (perhaps they're using chroots for sandboxing), some or all of the users have their own hard links to this file rather than using a single path.<br>
<p>
With per-inode permissions, to revoke another user's write access while leaving them read access to the shared file, including any future updates, all I have to do is update the ACL on the file. If I were to destroy my link and start over, on the other hand, I would also have to recreate everyone else's links using the new permissions so that we are once again sharing the same file.<br>
<p>
Frankly, I don't see any benefits to this change. One ACL per filesystem object has served us well for a long time. The original problem in this thread was with inherited ACLs and multiple parent directories, a problem with doesn't apply to POSIX ACLs, which have defaults but not inheritance. What issue are you trying to solve by moving permissions to the directory entry?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2012 9:32 UTC (Wed)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/500459/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What issue are you trying to solve by moving permissions to the directory entry?</font><br>
<p>
Basically the same ACLs solve, but using just permission bits. I personally find them much more sensible, and think this is something that could have been better, had Unix been designed this way instead.<br>
<p>
Now it's too late, of course. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2012 15:16 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/500491/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Basically the same ACLs solve, but using just permission bits.</font><br>
<p>
But POSIX ACLs are basically permission bits, just without the "one user plus one group" limitation. They still govern read, write, and execute/search permissions for specific users and groups and "others". I don't see how requiring multiple directory entries for the same effect is a "more sensible" solution.<br>
<p>
That the UNIX permissions model could have been better--I have no argument with you there. We could have used POSIX-style ACLs from the beginning, and skipped the restrictive user/group/other model entirely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor500529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Doesn't go far enough for file servers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2012 17:29 UTC (Wed)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/500529/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I don't see how requiring multiple directory entries for the same effect is a "more sensible" solution.</font><br>
<p>
One word explanation: ls<br>
<p>
Multiple word explanation: It's a question of simplicity, I suppose. This way you avoid introducing more concepts and tools. Notice just how simple it is to say "every link can have different permissions". Compare that to the simplest explanation of POSIX ACLs. <br>
<p>
Additionally, you don't need to modify existing tools, and hardly add any new ones. The only one you may want to add is something that gives back the list of aliases (links) to a file.<br>
<p>
In return for that simplicity you have to give up on the expectation of absolute ownership. You no longer can revoke permissions on other's links, but you can always recreate a file.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/500529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor497463"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 2:20 UTC (Thu)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/497463/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Finally! I've been waiting for this for years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497463/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497500"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 9:17 UTC (Thu)
                               by <b>zuki</b> (subscriber, #41808)
                              [<a href="/Articles/497500/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. I don't really see why we would want FAT to be more feature-full than EXT[234].<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497500/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 4:46 UTC (Thu)
                               by <b>imunsie</b> (guest, #68550)
                              [<a href="/Articles/497471/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't this be better suited as a filesystem attribute set with something like 'mkfs.ext3 -O noperms' or 'tune2fs -O +noperms'? Then it's up the admin who created the filesystem to decide whether it uses traditional posix permissions or vfat style files are owned by whoever mounted it.<br>
<p>
For instance, I may backup a filesystem to a removable drive, in which case I definitely don't want any automounter deciding to remap UIDs &amp; GIDs at any point just because the drive happens to be removable, whether when performing the backup, or later when reading it because an important part of the backup (the ownership &amp; permissions) could be corrupted.<br>
<p>
On the other hand, I am tired of always telling people they need to 'sudo chown -R user.group some_dir' whenever they are copying something to/from my external hard drive and the permissions aren't liberal enough. A related use case is a machine used without root access that is still able to mount removable media (I'm specifically thinking of the machines in the IT labs at uni), where 'sudo chown/chmod' is not possible.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497478"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 6:00 UTC (Thu)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/497478/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree, FS attributes would be the right way to go - but I'd go further.<br>
<p>
I want it to be a directory xattr, so I can set it for arbitrary sub-trees of a file system. Not just a uid= and gid=, but most importantly a dirmode= and filemode= . <br>
<p>
I waste SO MUCH TIME fighting the stupidity of the UNIX permissions model, which presumes every user (a) knows and (b) cares about the permissions of each file and can be trusted to set them. It also assumes that a particular umask is appropriate globally across a session, where in reality different masks are appropriate when working in different data storage spaces. It also causes endless problems with idiotic apps like Thunderbird that like to override the admin-set umask when creating files or directories, leaving files/dirs in shared working areas that only the creator can access.<br>
<p>
I want to be able to turn all this crap off. Seriously. Let me say "Everything under /srv/users/editorial is mode 770 (dir) or 660 (file) with group 'editorial'". POSIX ACLs would work if only I could turn off or override UNIX permissions.<br>
<p>
As it is, I have the usual horrid cron job. I'm always patching apps when some idiotic application developer gets it into their head to "improve security" by adding an explicit umask() call they don't understand. Again.<br>
<p>
This is particularly painful when there's a combination of clients using network file servers (Samba, NetATalk, etc) and clients using local or NFS access.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497478/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems vs xattr for entire subtree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 14:21 UTC (Thu)
                               by <b>scripter</b> (subscriber, #2654)
                              [<a href="/Articles/497552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree. And the xattr for the entire subtree shouldn't just override uid, gid, dirmode and filemode -- it should override the SELinux attributes as well.<br>
<p>
Why? I've got a directory tree full of 10+ years of images that I serve up through apache. It's a nightmare to make sure everything has the correct dirmode, filemode, and SELinux attributes.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor497592"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 17:47 UTC (Thu)
                               by <b>RobSeace</b> (subscriber, #4435)
                              [<a href="/Articles/497592/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Let me say "Everything under /srv/users/editorial is mode 770 (dir) or 660 (file) with group 'editorial'".</font><br>
<p>
Well, you can get the group inheritence already by just setting the setgid bit on the directory...  Maybe we need to allow for similar user inheritence via the setuid bit?  Not sure about how to do the modes, though...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497592/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2012 16:33 UTC (Fri)
                               by <b>jschrod</b> (subscriber, #1646)
                              [<a href="/Articles/497749/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; Let me say "Everything under /srv/users/editorial is mode 770 (dir) or</font><br>
<font class="QuotedText">&gt; &gt; 660 (file) with group 'editorial'".</font><br>
<p>
<font class="QuotedText">&gt; Well, you can get the group inheritence already by just setting the</font><br>
<font class="QuotedText">&gt; setgid bit on the directory...</font><br>
<p>
How do you enforce a gid change when a file is mv'ed into that directory? setgid only works for newly created files.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2012 16:59 UTC (Fri)
                               by <b>RobSeace</b> (subscriber, #4435)
                              [<a href="/Articles/497753/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmmm, true enough...  I guess I always figured it'd work for mv'd files too, but never tried...  Bummer...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 21, 2012 1:13 UTC (Mon)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/497994/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
`chmod g+s` is all well and good as far as it goes, but it doesn't go far.<br>
<p>
As others have noted, it has no effect on moved files or directories, so you land up with subtrees with different permissions that're incorrect for that working group.<br>
<p>
More importantly, it doesn't affect the permissions bits. What I really need is to be able to force the group permissions bits to a fixed mode whenever a file is created in or moved into a directory *or* *any* *sub* *directory*. That mode may be g=rwX if I want to use inherited POSIX ACLs instead.<br>
<p>
The fact that these issues cause such hassle that I was considering mounting local directories via samba and CIFS (so I could use Samba to remap all permissions) should tell you something!<br>
<p>
In truth, I hate to say what I've done in the end is replace our Samba server with a Win2k8 box, and have the Linux boxes mount its storage over CIFS. All these pain points just go away, to the point where I think Windows is currently a much better file server for Linux boxes than Linux its self is at least for some workloads. For one thing, I have volume shadow copy snapshots now, which are so massively better than LVM snapshots that it's hard to believe.<br>
<p>
I did this partly because Samba isn't usable as a primary domain controller for Windows 7 machines; our Samba PDC had to go anyway. I was reluctant to do it initially, but after my experience with win2k8 I'm going to be very reluctant to go back to Linux and Samba file servers again. Not unless LVM snapshot expiry stops sucking and preventing the machine from booting, LVM learns to co-operate with the file system(s) on top of it for snapshot management, permissions management for shared access modes stops being so horrible, and of course Samba 4 eventually hits release.<br>
<p>
Note that I'm not demanding that any of these things magically happen or whining that they aren't happening. I'm not doing the work to make it so, so I have no right to. Doesn't mean I won't use whatever's best for the job right now.<br>
<p>
(Of course, now I'm trying to resist being saddled with Microsoft Exchange. I don't want to give up Cyrus IMAPd and Postfix, but pressure for a working shared calendar and address book is growing within the organisation, and there isn't much out there...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor499467"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 31, 2012 16:38 UTC (Thu)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/499467/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;In truth, I hate to say what I've done in the end is replace our Samba server with a Win2k8 box, and have the Linux boxes mount its storage over CIFS. All these pain points just go away, to the point where I think Windows is currently a much better file server for Linux boxes than Linux its self is at least for some workloads. For one thing, I have volume shadow copy snapshots now, which are so massively better than LVM snapshots that it's hard to believe.</font><br>
<p>
Unless you have a powerful technical or ideological objection, I would seriously recommend taking a good, hard look at Solaris.<br>
<p>
I've only been trialling Openindiana for a couple of weeks, so it's certainly possible that there are major headaches to come, but so far it has been an incomparably better experience than using Linux + Samba - so much so that I deeply regret wasting my life on the latter for so long.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/499467/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor498465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2012 22:35 UTC (Wed)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/498465/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, the directory approach seems like a much better solution. Then depending on where I mount the removable media, permissions can be respected or not. I can mount a backup hard drive to /mnt/backup normally or my USB stick on /mnt/usb to access just everything.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/498465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497516"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 11:17 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/497516/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's up to the person who has the disk in their hand.  If I have the disk, it's mine, and I can do what I want with it.  Some permission bit set by whoever created the filesystem has nothing to do with it, unless you believe in creating some trivially breakable DRM.  If Linux doesn't let you have unrestricted access to a disk you pick up and insert (or a USB stick you plug in), then users will just put the disk into another system which is less choosy.<br>
<p>
By the same argument, it makes no sense to restrict the 'shutdown' operation for locally logged in users.  You may prompt the user 'are you sure?' but in the end you have to grant shutdown permission to somebody who is sitting at the local console, since they have the power switch at their fingertips anyway.<br>
<p>
A lot of security measures which are reasonable for a computer locked in an air-conditioned server room make no sense for desktop and portable devices, if you can establish that the user is physically present.  If they're logged in remotely then of course you re-enable all those restrictions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497516/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497610"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bad example</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 18:49 UTC (Thu)
                               by <b>NRArnot</b> (subscriber, #3033)
                              [<a href="/Articles/497610/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Retricting shutdown is a bad example. There are environments where a local user has no access to the power switch and reset button. For example, a public "kiosk". Vandal-proof keyboard and trackball and display, metal enclosure locked shut and permanently wired into the electricity supply (ie no plug). Inside sits a plain ordinary PC.<br>
<p>
Or the systems I was using this afternoon in a library. Just a hinged cover glued over those buttons, cable-tied shut. A Mollyguard. (Molly, age 5, thinks to herself "what does that button do if I press it"? )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497610/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor497663"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2012 1:57 UTC (Fri)
                               by <b>imunsie</b> (guest, #68550)
                              [<a href="/Articles/497663/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's up to the person who has the disk in their hand. If I have the disk, it's mine, and I can do what I want with it.</font><br>
<p>
You clearly missed the tune2fs mention in my post. I'm not suggesting that you don't have control of your disk, I'm suggesting that I don't want an automounter deciding to ignore permissions if I actually want or need them.<br>
<p>
<font class="QuotedText">&gt; Some permission bit set by whoever created the filesystem has nothing to do with it, unless you believe in creating some trivially breakable DRM.</font><br>
<p>
Absolutely not, it's about preventing an automounter deciding not to respect file permissions on a volume where they are in fact required (e.g. a backup medium) and inadvertently corrupting the data stored there (permissions are data, and critical to the integrity of backups encompassing multiple users, such as a full backup of ANY Linux system, including "single human user" systems, which still have root, user, www-data, shadow, lp, daemon, etc. users/groups). Same goes for a disk you have pulled out of another system and placed in a USB caddy.<br>
<p>
Besides which, if it's a filesystem attribute than it can just as easily be applied to a non-removable media if permissions are not desired there. I can't think of a good solid example of why you would want this (other than Linux failing to detect the media as removable, which has happened to me on a number of occasions), but I'm sure someone else can.<br>
<p>
We could even make mke2fs default to disabling permissions on newly created filesystems on removable media, though you wouldn't want that if the removable disk was in a caddy and you were about to debootstrap it. The point is that if you decide the filesystem should support permissions you don't want an automounter ignoring that decision without asking just because the drive happens to be in a caddy. If you later want to disable permissions, that's fine, but it's YOUR choice, not the choice of an automounter.<br>
<p>
<font class="QuotedText">&gt; If Linux doesn't let you have unrestricted access to a disk you pick up and insert (or a USB stick you plug in), then users will just put the disk into another system which is less choosy.</font><br>
<p>
I presume you mean a system they have root on or are a member of the disk group so they can run tune2fs to set the noperms attribute. Nothing wrong with that, that's THEIR decision.<br>
<p>
<font class="QuotedText">&gt; By the same argument, it makes no sense to restrict the 'shutdown' operation for locally logged in users. You may prompt the user 'are you sure?' but in the end you have to grant shutdown permission to somebody who is sitting at the local console, since they have the power switch at their fingertips anyway.</font><br>
<p>
As NRArnot stated, that is a bad example because that is an administrative decision to allow local users to shut down. It makes sense in the general case, which is why most sane distributions default to that, but there are special cases where that does not make sense.<br>
<p>
<font class="QuotedText">&gt; A lot of security measures which are reasonable for a computer locked in an air-conditioned server room make no sense for desktop and portable devices, if you can establish that the user is physically present. If they're logged in remotely then of course you re-enable all those restrictions.</font><br>
<p>
Sure, but that is ALWAYS an administrative decision. We CAN and DO set sane defaults to support that, which is why your Ubuntu system has something installed called "PolicyKit" (IIRC).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497663/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497618"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Magic UID</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 19:33 UTC (Thu)
                               by <b>kh</b> (guest, #19413)
                              [<a href="/Articles/497618/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am afraid this is probably terribly naive, but I wonder if it would not be better to have a magic UID - GID that when present, caused the VFS to ignore all permissions. Then the other part would be to create a way to format a disk so that when such a system was mounted, all new files would be created with the magic UID - GID. That way it would take a format action to create such a disk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497618/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 4:48 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/497473/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>I'm confused&mdash;why the colon notation in <tt>m:x</tt> and <tt>n:y</tt> (dot notation in the article text)?  Are there two separate values, one each for <tt>m</tt> and <tt>x</tt> (and <tt>n</tt> and <tt>y</tt>)? Assuming one value is a UID (or GID), what's the second value for?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/497473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497479"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 6:00 UTC (Thu)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/497479/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From the next line in the article:<br>
<p>
"which would make the files appear to be owned by m.x and would create new files as n.y."<br>
<p>
The usefulness of this makes is more obvious when you realize that m and x are user-visible uids/gids, and n and y are on-disk uids/gids -- different namespaces entirely. That is, if user geofft on my current system is uid 1001, and I'm mounting my laptop's root partition where user geofft is 1000, then I should mount with uid=1001:1000 so that everything appears owned by me now, but also so that anything new remains owned by me when I put the disk back into my laptop. 1001 is from the host's /etc/passwd, 1000 from the target's.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497479/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 9:20 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/497502/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Thanks for the reply.</p>

<p>Of course, knowing myself, if I were to use such an implementation, I'd certainly get the <tt>m</tt> and the <tt>x</tt> backwards and <i>really</i> mess things up! :-)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/497502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 18:22 UTC (Thu)
                               by <b>knobunc</b> (subscriber, #4678)
                              [<a href="/Articles/497603/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was a little surprised that there was no way to do more than one user mapping.<br>
<p>
For the stated use case, it makes sense, but it would be nice to be able to pull a disk from another machine (in a different uid scheme) and be able to mount it to back-up onto another machine, and provide a mapping for all user ids present on the disk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497480"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Relationship with CLONE_NEWUSER?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 6:16 UTC (Thu)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/497480/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It seems like this might fit in well with CLONE_NEWUSER / <a href="https://wiki.ubuntu.com/UserNamespace">user namespaces</a>, which allows an unprivileged user to set up a process (and its descendants) to have uids/gids completely separate from the uid/gids of the host, such that e.g. uid 0 in the namespace has none of the permissions that root has on the host machine. There's current work to set up a mapping between inner uids/gids and outer ones, so that a user can be assigned (by the sysadmin) a handful of unprivileged users, and map one of them to uid 0 inside the namespace and freely setuid() to other ones that they're allowed.<br>
<p>
As might be implied by the CLONE_NEWFOO name, the primary use case of this is containers -- uid x in one container should have no relationship with uid x in another. (Within a user namespace, an unprivileged user can chroot since setuid binaries cause you to switch to that uid inside the namespace, not outside, etc. so the usual reasons not to let an unprivileged user chroot don't apply. The goal of user namespaces is essentially to let unprivileged users start their own containers.)<br>
<p>
But there are a ton of applications for this, when it becomes useful, and one good one seems to be to associate a mount with a namespace. If I plug in an ext2-formatted external drive, I should be able to bind its uids/gids to a namespace I control, instead of to the root-level uid/gid namespace, and thereby be able to su to any user account inside it (and still have POSIX permissions be respected within that namespace). This certainly seems to help with the common case of USB sticks, since I can say that e.g. user 1000 in the root namespace maps to user 0 or 501 or whatever in the namespace associated with the mount, and then be able to directly read and write files and have things work as expected. It also has some benefits for other use cases, like being able to mount a device a container-owner controls a container and have permissions work properly there without impacting the host system.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/497480/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor497529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">JFS already has this</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 12:45 UTC (Thu)
                               by <b>mcisely</b> (subscriber, #2860)
                              [<a href="/Articles/497529/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>JFS has had this user/group settable mount feature for years already.  It is in fact why I currently favor using JFS for removable media - vfat is simply not up to the task due to file size limits, screwy case insensitivity, limited character set for file names, etc.</p>

<p>The need &amp; rationale for this for use with removable media as described in the article and multiple comments is spot-on.  It is long past due for the ext* family of file systems to gain this ability.</p>

-Mike<br>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor497575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 16:02 UTC (Thu)
                               by <b>wookey</b> (guest, #5501)
                              [<a href="/Articles/497575/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I certainly use ext2/3 formatted removeable media whenever I can - you can run systems off them and preserve UID/mode info - a VFAT rootfs simply doesn't work. I've long resented the way we've been stuck with VFAT (and it's bloody patents to add insult to mediocrity) for so long, not least because of the way USB-storage is implmented (logical block level). <br>
<p>
I've suffered from the wrong UID/GID thing for many years, mostly over NFS (And I liked the way that the non-kernel NFS server let you supply UID map). Just last week I found that all my backup files for a server that just died have the wrong UIDs (that'll be the new admin doing it wrong, but the point is that it's common) Anything that helps work round this is good IMHO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor497733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2012 14:43 UTC (Fri)
                               by <b>vivo</b> (subscriber, #48315)
                              [<a href="/Articles/497733/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
change group on the fly for a directory is possible like this:<br>
<p>
as root:<br>
<p>
# mkdir /g/distfiles<br>
# chown portage:portage /g/distfiles<br>
# chmod 6775 /g/distfiles<br>
# touch /g/distfiles/pippo<br>
# ls -l /g/distfiles/pippo<br>
-rw-r--r-- 1 root portage 0 May 18 16:40 /g/distfiles/pippo<br>
<p>
however I would really love to see the feature of userid swapping applyable to bind mounts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor498152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2012 10:36 UTC (Tue)
                               by <b>Jonno</b> (subscriber, #49613)
                              [<a href="/Articles/498152/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I use ext3 on removable media simply because vfat is not an option (4 GiB limit), and ext2fsd on Windows works better than ntfs3g on Linux.<br>
<p>
On those drives, permission bits are just a bother. For now I simply do chown and chmod recursively every time I mount on Linux, but this feature would make things much simpler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/498152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor499474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 31, 2012 16:45 UTC (Thu)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/499474/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;ext2fsd on Windows works better than ntfs3g on Linux</font><br>
<p>
I haven't used ext2fsd in *years*, and back then it had a tendency to cause a BSoD not infrequently, but what problems have you had with ntfs3g? I've always found it to be utterly dependable, and pretty fast besides.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/499474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor498591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2012 15:15 UTC (Thu)
                               by <b>kraftcheck</b> (guest, #35072)
                              [<a href="/Articles/498591/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given that UID/GID data is largely useless and a nuissance for most removable media, why not let the user specify that they do not want UID/GID data for a given file system when the file system is created.  Save a value in the superblock indicating a UID/GID-less file system.  The permissions can be handled the same as is done for VFAT in that case (controlled by mount options and defaulting to root.)  This way a) developers don't need to worry about deciding which device is "removable", the user specifies the behavior they want for the evice and b) any determination of how the device is to be handled is made once when the file system is created rather than every time it is mounted.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/498591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor499300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User and group mount options for ext filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2012 20:26 UTC (Wed)
                               by <b>switzel</b> (guest, #84885)
                              [<a href="/Articles/499300/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am very happy that people are working on this. To those who say, this problem should be circumvented by configuring "the" machine differently I would like to describe my situation: I have usb hard disk on which I store my data to carry them around with me. I use this hard disk on various computers of whose existence I am often not previously aware and on which I certainly have nothing near to root access.<br>
With vfat this was not a problem but of course it has the described shortcomings (most importantly the 4GB bound). So ideally I would like a filesystem "like vfat" with these shortcomings removed (I somehow think that a "light" filesystem is appropriate for removable drives).<br>
In that spirit I also support the idea of an option to ext2 to "turn off" permissions. But really I am happy about any solution at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/499300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
