        <!DOCTYPE html>
        <html lang="en">
        <head><title>The cpuidle subsystem [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/384146/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/384420/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/384146/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The cpuidle subsystem</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 26, 2010</br>
           </div>
Your editor recently had cause to dig around in the cpuidle subsystem.
It never makes sense to let such work go to only a single purpose when it
could be applied toward the creation of a kernel-page article.  So, what
follows is a multi-level discussion of cpuidle, what it's for, and how it works.
Doing nothing, it turns out, is more complicated than one might think.
<p>

On most systems, the processor is idle much of the time.  We can't always
be running CPU-intensive work like kernel builds, video transcoding,
weather modeling, or 
yum.  When there is nothing left to do, the processor will go into the idle
state to wait until it is needed again.  Once upon a time, on many systems,
the "idle state" was literally a thread running at the lowest possible
priority which would execute
an infinite loop until the system found something better to do.  Killing
the idle process was a good way to panic a VAX/VMS machine, which had no
clue of how to do nothing without a task dedicated to that purpose.
<p>
Running a busy-wait loop requires power; contemporary concerns have led us
to the conclusion that expending large amounts of power toward the
accomplishment of nothing is rarely a good idea.  So CPU designers have
developed ways for the processor to go into a lower-power state when
there is nothing for it to do.  Typically, when put into this state, the
CPU will stop clocks and power down part or all of its circuitry until the
next interrupt 
arrives.  That results in the production of far more nothing per watt than
busy-waiting.
<p>
In fact, most CPUs have multiple ways of doing nothing more efficiently.
These idle modes, which go by names like "C&nbsp;states," vary in the
amount of power saved, but also in the amount of ancillary information
which may be lost and the amount of time required to get back into a
fully-functional mode.  On your editor's laptop, there are three idle
states with the following characteristics:
<p>
<blockquote>
<table cellspacing=3>
<tr><th></th><th>C1</th><th>C2</th><th>C3</th></tr>
<tr><th align="right">Exit latency (&micro;s)</th><td align="right">1</td>
	<td align="right">1</td>
	<td align="right">57</td></tr>
<tr><th align="right">Power consumption (mW)</th><td align="right">1000</td>
	<td align="right">500</td><td align="right">100</td></tr>
</table>
</blockquote>
<p>
On a typical processor, C1 will just turn off the processor clock, while C2
turns off other clocks in the system and C3 will actively power down parts
of the CPU.
On such a system, it would make sense to spend as much time as possible in
the C3 state; indeed, while this sentence is being typed, the system is in
C3 about 97% of the time.  One might have thought that emacs could do a
better job of hogging the CPU, but even emacs is no challenge for
modern processors.  The C1 state is not used at all, while a small amount
of time is spent in C2.
<p>
One might wonder why the system bothers with anything but C3 at all; why
not insist on the most nothing for the buck?  The answer, of course, is
that C3 has a cost.  The 57&micro;s exit latency means that the system must
commit to doing nothing for a fair while.  Bringing the processor back up
also consumes power in its own right, and the ancillary costs - the C3
state might cause the flushing of the L2 cache - also hurt.  So it's only worth
going into C3 if the power savings will be real and if the system knows
that it will not have to respond to anything with less than 57&micro;s
latency.  If those conditions do not hold, it makes more sense to use a
different idle state.  Making that decision is the cpuidle subsystem's job.
<p>

Every processor has different idle-state characteristics and different
actions are required to enter and leave those states.  The cpuidle
code abstracts that complexity into a separate driver layer; the drivers
themselves are often found in architecture-specific or ACPI code.  On the other
hand, the decision as to which idle state makes sense in a given situation
is very much a policy issue.  The cpuidle "governors" interface allows the
implementation of different policies for different needs.  We'll take a
look at both layers.

<p>
<h4>cpuidle drivers</h4>
<p>
At the highest level, the cpuidle driver interface is quite simple.  It
starts by registering the driver with the subsystem:
<p>
<pre>
    #include &lt;linux/cpuidle.h&gt;

    struct cpuidle_driver {
	char			name[CPUIDLE_NAME_LEN];
	struct module 		*owner;
    };

    int cpuidle_register_driver(struct cpuidle_driver *drv);
</pre>
<p>
About all this accomplishes is making the driver name available in sysfs.
The cpuidle core also will enforce the requirement that only one cpuidle
driver exist in the system at any given time.
<p>

Once the driver exists, though, it can register a cpuidle "device" for each
CPU in the system - it is possible for different processors to have
completely different setups, though your editor suspects that tends not to
happen in real-world systems.  The first step is to describe the processor
idle states which are available for use:
<p>
<pre>
    struct cpuidle_state {
	char		name[CPUIDLE_NAME_LEN];
	char		desc[CPUIDLE_DESC_LEN];
	void		*driver_data;

	unsigned int	flags;
	unsigned int	exit_latency; /* in US */
	unsigned int	power_usage; /* in mW */
	unsigned int	target_residency; /* in US */

	unsigned long long	usage;
	unsigned long long	time; /* in US */

	int (*enter)	(struct cpuidle_device *dev,
			 struct cpuidle_state *state);
    };
</pre>
<p>

The <tt>name</tt> and <tt>desc</tt> fields describe the state; they will
show up in sysfs eventually.  <tt>driver_data</tt> is there for the
driver's private use.  The next four fields, starting with <tt>flags</tt>,
describe the characteristics of this sleep state.
Possible <tt>flags</tt> values are:
<p>
<ul>
<li> <tt>CPUIDLE_FLAG_TIME_VALID</tt> should be set if it is possible 
     to accurately measure the amount of time spent in this particular idle
     state.
<p>
<li> <tt>CPUIDLE_FLAG_CHECK_BM</tt> indicates that this state is not
     compatible with bus-mastering DMA activity.  Deep sleeps will, among
     other things, disable the bus cycle snooping hardware, meaning that
     processor-local caches may fail to be updated in response to DMA.
     That can lead to data corruption problems.

<p>
<li> <tt>CPUIDLE_FLAG_POLL</tt> says that this state causes no latency, but
     also fails to save any power.
<p>
<li> <tt>CPUIDLE_FLAG_SHALLOW</tt> indicates a "shallow" sleep state with
     low latency and minimal power savings.
<p>
<li> <tt>CPUIDLE_FLAG_BALANCED</tt> is for intermediate states with some
     latency and moderate power savings.
<p>
<li> <tt>CPUIDLE_FLAG_DEEP</tt> marks deep sleep states with high latency
     and high power savings.
</ul>
<p>
The depth of the sleep state is also described by the remaining fields:
<tt>exit_latency</tt> says how long it takes to get back to a fully
functional state, <tt>power_usage</tt> is the amount of power consumed by
the CPU when it is in this state, and <tt>target_residency</tt> is the
minimum amount of time the processor should spend in this state to make the
transition worth the effort.
<p>
The <tt>enter()</tt> function will be called when the current governor
decides to put the CPU into the given <tt>state</tt>; it will be described
more fully below.  The number of times the state has been entered will be
kept in <tt>usage</tt>, while <tt>time</tt> records the amount of time
spent in this state.
<p>
The cpuidle driver should fill in an appropriate set of states in a
<tt>cpuidle_device</tt> structure for each CPU:
<p>
<pre>
    struct cpuidle_device {
	unsigned int		cpu;

	int			last_residency;
	int			state_count;
	struct cpuidle_state	states[CPUIDLE_STATE_MAX];
	struct cpuidle_state	*last_state;

	void			*governor_data;
	struct cpuidle_state	*safe_state;
	/* Others omitted */
    };
</pre>
<p>

The driver should set <tt>state_count</tt> to the number of valid states
and <tt>cpu</tt> to the number of the CPU described by this device.  The
<tt>safe_state</tt> field points to the deepest sleep which is safe to
enter while DMA is active elsewhere in the system.  The device
should be registered with:
<p>
<pre>
    int cpuidle_register_device(struct cpuidle_device *dev);
</pre>
<p>
The return value is, as usual, zero on success or a negative error code.
<p>
The only other thing that the driver needs to do is to actually implement
the state transitions.  As we saw above, that is done through the
<tt>enter()</tt> function associated with each state:
<p>
<pre>
    int (*enter)(struct cpuidle_device *dev, struct cpuidle_state *state);
</pre>
<p>
A call to <tt>enter()</tt> is a request from the current governor to put
the CPU associated with <tt>dev</tt> into the given <tt>state</tt>.  Note
that <tt>enter()</tt> is free to choose a different state if there is a
good reason to do so, but it should store the actual state used in the
device's <tt>last_state</tt> field.  If the requested state has the
<tt>CPUIDLE_FLAG_CHECK_BM</tt> flag set, and there is bus-mastering DMA
active in the system, a transition to the indicated <tt>safe_state</tt>
should be made instead.  The return value from <tt>enter()</tt>
should be the amount of time actually spent in the sleep state, expressed
in microseconds.
<p>
If the driver needs to temporary put a hold on cpuidle activity, it can
call:
<p>
<pre>
    void cpuidle_pause_and_lock(void);
    void cpuidle_resume_and_unlock(void);
</pre>
<p>
Note that <tt>cpuidle_pause_and_lock()</tt> blocks cpuidle activity for all
CPUs in the system.  It also acquires a mutex which is held until
<tt>cpuidle_resume_and_unlock()</tt> is called, so it should not be used
for long periods of time.
<p>
Power management for a specific CPU can be controlled with:
<p>
<pre>
    int cpuidle_enable_device(struct cpuidle_device *dev);
    void cpuidle_disable_device(struct cpuidle_device *dev);
</pre>
<p>
These functions can only be called with cpuidle as a whole paused, so one
must call <tt>cpuidle_pause_and_lock()</tt> first.

<P>
<h4>cpuidle governors</h4>
<p>
Governors implement the policy side of cpuidle.  The kernel allows the
existence of multiple governors at any given time, though only one will be
in control of a given CPU at any time.  Governor code begins by filling in
a <tt>cpuidle_governor</tt> structure:
<p>
<pre>
    struct cpuidle_governor {
	char			name[CPUIDLE_NAME_LEN];
	unsigned int		rating;

	int  (*enable)		(struct cpuidle_device *dev);
	void (*disable)		(struct cpuidle_device *dev);
	int  (*select)		(struct cpuidle_device *dev);
	void (*reflect)		(struct cpuidle_device *dev);

	struct module 		*owner;
	/* ... */
    };
</pre>
<p>

The <tt>name</tt> identifies the governor to user space, while
<tt>rating</tt> is the governor's idea of how useful it is.  By default,
the kernel will use the governor with the highest rating value, but the
system administrator can override that choice.
<p>
There are four callbacks provided by governors.  The first two,
<tt>enable()</tt> and <tt>disable()</tt>, are called when the governor is
enabled for use or removed from use.  Both functions are optional; if the
governor does not need to know about these events, it need not supply these
functions.  
<p>
The <tt>select()</tt> function, instead, is mandatory; it is called
whenever the CPU has nothing to do and wishes the governor to pick the
optimal way of getting that nothing done.  This function is where the
governor can apply its heuristics, look at upcoming timer events, and
generally try to decide how long the sleep can be expected to last and
which idle state makes the most sense.  The return value should be the
integer index of the target state (in the <tt>dev-&gt;states</tt> array). 
<p>
When making its decision, the governor should pay attention to the current
latency requirements expressed by other code in the system.  The mechanism
for the registration of these requirements is the "pm_qos" subsystem.  A
number of quality-of-service requirements can be registered with this
system, but the one most relevant for cpuidle governors is the CPU latency
requirement.  That information can be obtained with:
<p>
<pre>
    #include &lt;linux/pm_qos_params.h&gt;

    int max_latency = pm_qos_requirement(PM_QOS_CPU_DMA_LATENCY);
</pre>
<p>
On some systems, an overly-deep sleep state can wreak havoc with DMA
operations (trust your editor's experience on this), so it's important to
respect the latency requirements given by drivers.  
<p>
Finally, the <tt>reflect()</tt> function will be called when the CPU exits
the sleep state; the governor can use the resulting timing information to
reach conclusions on how good its decision was.
<p>
<h4>An aside: blocking deep sleep</h4>
<p>
For what it's worth,
driver developers can use these pm_qos functions to specify latency
requirements: 
<p>
<pre>
    #include &lt;linux/pm_qos_params.h&gt;

    int pm_qos_add_requirement(int qos, char *name, s32 value);
    int pm_qos_update_requirement(int qos, char *name, s32 new_value);
    void pm_qos_remove_requirement(int qos, char *name);
</pre>
<p>
This API is not heavily used in current kernels; most of the real uses
would appear to be drivers telling the system that transitions into deep
sleep states would be unwelcome.  Needless to say, a driver should only
block deep sleep when it is strictly necessary; the latency requirement
should be removed when I/O is not in progress.

<p>
And that describes the 2.6.34 version of the cpuidle subsystem and API.
For the curious, the core and governor code can be found in
<tt>drivers/cpuidle</tt>, while cpuidle drivers live in
<tt>drivers/acpi/processor_idle.c</tt> and a handful of ARM subarchitecture
implementations.
All told, it's a testament to the complexity of doing nothing properly on
contemporary systems.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#ACPI">ACPI</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Power_management-cpuidle">Power management/cpuidle</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/384146/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor384716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How do you measure C states?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 17:51 UTC (Mon)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/384716/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Just curious, how did you measure the C1/C2/C3 stats?  Is there a command-line tool for this?  Thanks!</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/384716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How do you measure C states?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 17:56 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/384718/">Link</a>] 
      </p>
      
      </div>
      </summary>
      powertop is your friend.
      
          <div class="CommentReplyButton">
            <form action="/Articles/384718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor384720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Power consumption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 18:37 UTC (Mon)
                               by <b>koch</b> (subscriber, #55163)
                              [<a href="/Articles/384720/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How did you get the numbers for the power consumption of the different power-states?<br>
<p>
Thank you for an excellent article.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Power consumption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 18:42 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/384721/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Sorry, I should have mentioned that in the article.  Wander into
<p>
<pre>
    /sys/devices/system/cpu/cpu0/cpuidle
</pre>
<p>
and you'll find a bunch of files with that information.  The <tt>time</tt> and <tt>usage</tt> numbers are there too.
      
          <div class="CommentReplyButton">
            <form action="/Articles/384721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Power consumption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 20:58 UTC (Mon)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/384741/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>Funny that cpuidle doesn't exist in that directory on my home PC (Slackware 12.2 running vanilla kernel 2.6.31.13).  Am I missing something (other than the aforementioned powertop)?</p>

<p>By the way, this is a desktop PC, so all this discussion on my end may be moot (unless I want to save a few pennies on my electric bill). :-)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/384741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Power consumption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 21:47 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/384749/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps C-states are disabled in your BIOS. (Personally, I've disabled them on my suspended-when-not-in-use desktop simply because when C states are disabled, if the TSC is otherwise stable it can be used as a time source rather than the expensive HPET. On always-on servers and power-important laptops and netbooks, a bit of timekeepoing expense is worth the power saving, so it's best to turn C states on.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Power consumption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 0:45 UTC (Tue)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/384770/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I've got S3 enabled in BIOS (I actually rebooted just to look), but I'm curious whether I've got all the proper kernel options set and modules compiled/installed.  Sounds like a research project... :-)</p>

<p>Thanks for the replies.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/384770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor385456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">S3 is different</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2010 22:29 UTC (Thu)
                               by <b>pflugstad</b> (subscriber, #224)
                              [<a href="/Articles/385456/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IIRC, S3 is suspend-system-to-RAM, as opposed to the C states, which are just CPU states. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/385456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor384772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Power consumption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 0:55 UTC (Tue)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/384772/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
some desktop pc's support C states... but many, especially slightly older ones (1 - 2 years old), do not.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor384771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Power consumption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 0:55 UTC (Tue)
                               by <b>xtifr</b> (guest, #143)
                              [<a href="/Articles/384771/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On my system, I have /sys/devices/system/cpu/cpuidle (not in the cpu0 subdir).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor384743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 20:59 UTC (Mon)
                               by <b>MTecknology</b> (subscriber, #57596)
                              [<a href="/Articles/384743/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
heh... This is an awesome article. Also show you how efficient your system really is (or isn't).<br>
<p>
I just thought I'd show what I found:<br>
michael@panther:/sys/devices/system/cpu/cpu0/cpuidle$ cat */power<br>
4294967295<br>
1000<br>
500<br>
250<br>
michael@panther:/sys/devices/system/cpu/cpu0/cpuidle$ cat */usage<br>
273<br>
306<br>
12054<br>
546476<br>
<p>
I'd say for what I do that's very impressive. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2010 21:42 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/384748/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed. One of my larger servers, which spends most of its time idle, is disturbingly stating (via powertop) that it spends 77% of its time in C1, only 20% in C3, and is woken up fifty times a second by a mysterious 'load balancing tick'. I wonder what this is? Maybe compiling with NO_HZ would fix it...<br>
<p>
(Still, at least it's running in a low P-state.)<br>
<p>
(A completely idle PostgreSQL 8.4.3 also causes a wakeup every 1/10s, which seems a bit off.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 6:14 UTC (Tue)
                               by <b>koch</b> (subscriber, #55163)
                              [<a href="/Articles/384787/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The kernel on my dual-core laptop is compiled with NO_HZ, but still keeps itself warm and awake with these "load balancing ticks". There seems to be a <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/526354">bug</a>  (with fixes) filed for Ubuntu, describing these symptoms.
      
          <div class="CommentReplyButton">
            <form action="/Articles/384787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 9:37 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/384799/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Er, the linked bug is an ACPI bug causing temperature sensing to fail on resume from suspend on some laptops. I doubt it's related to a load-balancing tick on a big beefy quad-core Nehalem server :)<br>
<p>
(did you paste in the wrong link?)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor385309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2010 12:13 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/385309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It was disappointingly difficult to get many server authors to remove such polling behaviour. The response tended to be that (a) they didn't believe it made any difference and (b) this was the only way to measure some arbitrary thing they'd decided their software needed to constantly know about (e.g. free RAM, system load average).<br>
<p>
It appears that after a while everyone just stopped pushing :/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/385309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor384776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 2:23 UTC (Tue)
                               by <b>mcgrof</b> (subscriber, #25917)
                              [<a href="/Articles/384776/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great article, if you had a *Like* button I would have just hit it :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor384778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 4:01 UTC (Tue)
                               by <b>svaidy</b> (subscriber, #39260)
                              [<a href="/Articles/384778/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good article that describes the subsystem that silently saves power and extends battery life on laptops.  This subsystem is also useful on servers that support multiple low power idle states.<br>
<p>
The cpuidle subsystem is being ported to other architectures as well, however as mentioned by our editor the complexity of the subsystem poses some challenges for a clean multi architecture implementation. <br>
<p>
Reference: <br>
[1] cpuidle for POWER (patch v12)<br>
<a href="http://lkml.org/lkml/2010/4/15/190">http://lkml.org/lkml/2010/4/15/190</a><br>
<p>
[2] Discussions and previous patches<br>
<a href="http://lkml.org/lkml/2009/12/2/98">http://lkml.org/lkml/2009/12/2/98</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor384902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 18:23 UTC (Tue)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/384902/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've always wondering why PowerTop reports: "Detailed C-state information is only available on Mobile CPUs (laptops)"<br>
<p>
Why aren't these statistics available on normal CPUs?<br>
And why can't C-state counters be accounted in software?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 20:15 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/384926/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This was changed (and the message reworded) two years ago in commit 70551c5171abf366b3caa6d22e12892f0da5a95e, after which powertop became capable of reading C-state information exported from sysfs by cpuidle in kernel 2.6.25+ (the data that Jon talks about in this article).<br>
<p>
Prior to that, powertop had to read the data itself by making ACPI calls. I suppose this is less likely to work on non-laptops, even when C-states are available, because it's depending on the BIOS vendor doing the right thing (and we know how often *that* happens).<br>
<p>
So, upgrade powertop and/or upgrade the kernel?<br>
<p>
(You can't count C-state counters in software because when the CPU is in a C state it is not executing instructions. That's the whole point.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 20:53 UTC (Tue)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/384931/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This was changed (and the message reworded) two years ago</font><br>
Indeed, I pasted that from an older installation. Up-to-date computers give me this ever-confusing message:<br>
"&lt; Detailed C-state information is not P-states (frequencies)"<br>
I guess since this is Intel's software, they don't pay much attention to how it looks like on AMD processors. :)<br>
<p>
<font class="QuotedText">&gt; You can't count C-state counters in software because when the CPU is in</font><br>
<font class="QuotedText">&gt; a C state it is not executing instructions.</font><br>
But you can record timestamps before entering and after leaving the sleep state. Is that too expensive?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor384944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2010 21:23 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/384944/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's got nothing to do with Intel versus AMD. One of my Nehalem machines reports that message: it's just because C states are turned off in the BIOS.<br>
<p>
I suspect it needs some word-wrapping: the 'available' has been overwritten by the P-state heading :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/384944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor385040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2010 11:53 UTC (Wed)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/385040/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;I suspect it needs some word-wrapping: the 'available' has been overwritten by the P-state heading :)</font><br>
<p>
Since it always says that, no matter how wide the terminal in which it's run, you'd think somebody who knows that the message has been truncated would have noticed at some point and fixed it. I just assumed it was a message in some arcane code known to those deeply involved in power usage monitoring :P.<br>
<p>
Anyway it's unfortunate that desktop CPUs don't support this - even the Atom (D510) I bought a month ago only supports C0 and C1, and I don't know if it's possible to tell how long it's spending in what state. It seems you need CPUs designed specifically for battery-powered devices if you want anything more.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/385040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor385043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2010 12:16 UTC (Wed)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/385043/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many desktop CPUs do support it.  Your BIOS might not.  Your particular CPU might not (or might be buggy and the BIOS went ahead and disabled it for safety).   But it is not a rare feature in desktop CPUs anymore.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/385043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor385062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2010 14:11 UTC (Wed)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/385062/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there anywhere a list of supporting processors? I was hoping that a site like lesswatts.org might have that sort of thing, but I couldn't find that information anywhere short of downloading the datasheets for every individual CPU, and of course there are a near-infinite selection of CPUs on offer nowadays.<br>
<p>
However, if even brand new all-in-one Atom systems don't support this - given that they're targetted specifically at low-power uses - it doesn't seem to be a stretch to conclude that this is something that manufacturers basically don't care about.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/385062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor385087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2010 15:43 UTC (Wed)
                               by <b>gartim</b> (guest, #10123)
                              [<a href="/Articles/385087/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Jonathan -- curious what brand/specs are your laptop? -- Gary<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/385087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor385194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2010 23:33 UTC (Wed)
                               by <b>jonabbey</b> (guest, #2736)
                              [<a href="/Articles/385194/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yah, my nehalem (core i7) Fedora 11 system doesn't report any C-states in powertop, just P-states (reductions in the clockspeed of individual cores).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/385194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor395819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2010 6:38 UTC (Tue)
                               by <b>MS_ASU</b> (guest, #68817)
                              [<a href="/Articles/395819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
very nice article. I have two questions. <br>
<p>
What does the number in power field for each C state signify? for C0 its very high on my system. Its 4294967295 (mW). Is it the total power consumed in C0 till now? But seems like this value is not changing.<br>
<p>
The second question is about the C-state transitions. Can a transition occur within the same state? I mean CPU goes into C3 from C3 only. Because the value for C3 usage is very high for my system. (AFAIK the usage number denotes the number of transitions to that state) So seems like the "enter" function is being called from C3 and again the output state is C3.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor407561"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2010 13:17 UTC (Wed)
                               by <b>rsv</b> (guest, #70379)
                              [<a href="/Articles/407561/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sir,<br>
  I have some questions on cpu idle<br>
 <br>
  a) How does the kernel know the cpu is idle.<br>
  b) How does it know (predict) that the next activity will most likely happen after some time (say after 50 seconds or so) so that it can switch to the appropriate cpu sleep state.<br>
<p>
Thank you,<br>
rsv<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/407561/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The cpuidle subsystem</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2012 10:42 UTC (Mon)
                               by <b>bandarusivakrishna</b> (guest, #87084)
                              [<a href="/Articles/518886/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hai All,<br>
<p>
I Need some questions on CPUIDLE SUBSYSTEM<br>
<p>
1) As per Linux Power States Concepts we have C0 to C7 states are their, but in linux kernel we are using only c0 to c3....can any one please clarify what is the reason?<br>
<p>
2) How the processor will move from one state to another state...and once we from one state to another state what about the devices states in kernel...how it control<br>
<p>
We are Doing Power management on ARM Cortex-A9. I am new to power management. can any one help me on CPUIDLE SUBSYSTEM. How it works in Linux kernel governors to Hardware level how the flow is going on...<br>
<p>
Thanks &amp; Regards,<br>
Siva Krishna.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
