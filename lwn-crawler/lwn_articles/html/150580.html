        <!DOCTYPE html>
        <html lang="en">
        <head><title>4K stacks for everyone? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/150580/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/149977/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/150580/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>4K stacks for everyone?</h1>
<div class="Byline">[Posted September 7, 2005 by corbet]
               <p>
               </div>
</div>
<div class="ArticleText">
The 2.6.6 kernel contained, among many other things, a patch implementing
single-page (4K) kernel stacks on the x86 architecture.  Cutting the kernel
stack size in half reduces the kernel's per-process overhead and eliminates
a major consumer of multi-page allocations.  So running with the smaller
stack size is good for kernel performance and robustness.  The only problem
has been certain code paths in the kernel which require more stack space
than that.  Overrunning the kernel stack will corrupt kernel memory and
lead to unfortunate behavior in a hurry.
<p>

Over time, however, most of these problems have been taken care of, to the
point that Adrian Bunk recently <a href="/Articles/150582/">asked</a>: is
it time to eliminate the 8K stack option entirely for x86?  Some
distributors (e.g. Fedora) have been shipping kernels with 4K stacks for
some time without ill effect.  What problems might result, Adrian asked, if
4K stacks became the only option for everyone?
<p>

It turns out that there are a few problems still.  For example, the reiser4
filesystem 
still cannot work with 4K stacks.  There is, however, a patch
in the works which should take care of that particular problem.
<p>

A more complicated issue comes up in certain complex storage
configurations.  If a system administrator builds a fancy set of RAID
volumes involving the device mapper, network filesystems, etc., the path
between the decision to write a block and the actual issuance of I/O can
get quite long.  This situation can lead to stack overflows in strange and
unpredictable times.
<p>

What happens here is that a filesystem will decide to write a block, which
ends up creating a call to the relevant block driver's
<tt>make_request()</tt> function (or the block subsystem's generic version
of it).  For stacked block devices, such as a RAID volume, that I/O request
will be transformed into a new request for a different device, resulting in
a new, recursive <tt>make_request()</tt> call.  Once a few layers have been
accumulated, the call path gets deep, and the stack eventually runs out.
Neil Brown has posted <a href="/Articles/150583/">a patch</a> to resolve
this problem by serializing recursive <tt>make_request()</tt> calls.  With
this patch, the kernel keeps an explicit stack of <tt>bio</tt> structures
needing submission, and only processes one at a time in any given task.
This patch will truncate the deep call paths, and should resolve the
problem.

<p>
That leaves one other problem outstanding: <a
href="http://ndiswrapper.sourceforge.net/">NDISwrapper</a>.  This code is a
glue layer which allows Windows network drivers to be loaded into a Linux
kernel; it is used by people who have network cards which are not otherwise
supported by Linux.  NDIS drivers, it seems, require larger stacks.  Since
they are closed-source drivers written for an operating system which makes
larger stacks available, there is little chance of fixing them.  So a few
options have been discussed:
<p>
<ul>

<li> Ignoring the problem.  Since NDISwrapper is a means for loading
     proprietary drivers into the kernel - and Windows drivers at that -
     many kernel developers will happily refuse to support it at all.  The
     fact is, however, that disallowing 8K stacks would break (formerly)
     working systems for many users, and there are kernel developers who do
     not want to do that.
<p>
<li> Hack NDISwrapper to maintain its own special stack, and to switch to
     that stack before calling into the Windows driver.  This solution
     seems possible, but it is a nontrivial bit of hacking to make it work
     right.
<p>
<li> Move NDISwrapper into user space with some sort of mechanism for
     interrupt delivery and such.  These mechanisms exist, so this solution
     should be entirely possible.
</ul>
<p>

No consensus solution seems to have emerged as of this writing.  There is
time, anyway; removing the 8K stack option is not a particularly urgent
task, and certainly will not be considered for 2.6.14.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Kernel_stack">Kernel stack</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#NDISwrapper">NDISwrapper</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/150580/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor150751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">4K stacks for everyone?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 5:43 UTC (Thu)
                               by <b>wtogami</b> (subscriber, #32325)
                              [<a href="/Articles/150751/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      NDISWrapper actually requires 16K stacks for reliable operation.  8K isn't always enough.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor151051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NDISWrapper and 4K stacks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2005 18:57 UTC (Fri)
                               by <b>Duncan</b> (guest, #6647)
                              [<a href="/Articles/151051/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      NDISWrapper moving to user-space seems the clear-case best choice, here.  <br>
Not only does it solve its problem with 4k kernel stacks, it also moves <br>
not only proprietary, but proprietary MSWormOS even, drivers out of kernel <br>
space into more sanely protected userspace.  This sounds like exactly the <br>
sort of solution the kernel devs would prefer, because it gets those <br>
"black-box binary-only things" out of the kernel greatly simplifying and <br>
securing things. <br>
 <br>
The cost is of course speed...  Mode transfers between user space and <br>
kernel space take time, so proprietary-only MSWormOS based drivers will be <br>
slower.  Somehow, I don't see that as being a big issue either, since the <br>
view will be that it encourages transfering to more Linux-friendly <br>
hardware, always seen as a good thing. <br>
 <br>
Duncan <br>
 <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/151051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor151897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NDISWrapper and 4K stacks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2005 15:36 UTC (Thu)
                               by <b>Luyseyal</b> (guest, #15693)
                              [<a href="/Articles/151897/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Agreed. Most ndiswrapper users seem to be wireless card users who won't be expecting stellar performance in any case.<br>
<p>
-l<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/151897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor150755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">4K stacks for everyone?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 7:02 UTC (Thu)
                               by <b>jwb</b> (guest, #15467)
                              [<a href="/Articles/150755/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      A friend relayed this excellent suggestion.  Instead of causing great pain among users of ndiswrapper, raid, cryptoloop, xfs, nfs, lustre, and a great many other kernel features, why not accelerate the move to 16KiB soft pages on x86?  Then the stack could be kept in a single softpage, with the last 4KiB hardware backing page unallocated.  That leaves 12KiB in the stack, and a reliable means of determining when the stack overflows.  In addition you get all the other efficiency benefits of larger pages.<br>
<p>
The current proposal is sheer madness.  The developers have NO IDEA what the maximum kernel stack usage is, and no way of determining it.  They who are proposing mandatory 4KiB stacks are just crossing their fingers and saying "fuckit, it seems to run on my laptop."  That's not a very modern method of software development, especially when the only beneficiaries are a couple of large [elided] customers with over-threaded Java apps.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conservative Automatic Stack Size Check</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 8:27 UTC (Thu)
                               by <b>pkolloch</b> (subscriber, #21709)
                              [<a href="/Articles/150767/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The current proposal is sheer madness. The developers have NO IDEA what the maximum kernel stack usage is, and no way of determining it.</font><br>
<p>
Then the current state is desperate as well: They don't have a clue if the current stack size limit is sufficient. Your dynamic stack size check would be a step into the right direction, but:<br>
<p>
Most stack allocation should be easily statically determinable (with only small conservative overapproximations). Things like alloca (if there is a kernel equivalent) or any other means which change the stack size by a dynamically computed amount are more tricky. However, these should be avoided anyways if stack conservation has such a priority.<br>
<p>
At least conceptionally, computing a call graph with conservative stack usage annotations should be fairly easy (using existing code in GCC). In the absense of recursion, one could easily determine the largest stack size in use. And again, if you value the stack size so much, you should not use recursion. (well, there might be valid use cases with a known maximal recursion depth of 3 or so which might be hard to check statically for machines and even if that is the case, you will need something slightly smarter than plain call graphs.)<br>
<p>
Without such an automatic check, I pretty much agree with you.<br>
<p>
[Disclaimer: I have basically no clue about the kernel source except of what I read occasionally on this page.]<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150779"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conservative Automatic Stack Size Check</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 9:12 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/150779/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Most stack allocation should be easily statically determinable
</blockquote>
Some static determination is possible but not easy and not reliable (nor can it ever be reliable in the general case), and the error bars are large. See Olivier Hainque's paper in the GCC 2005 Summit proceedings for a pile of info on this.
<p>
TBH I'd expect that kernel developers' own hunches would be as reliable.
      
          <div class="CommentReplyButton">
            <form action="/Articles/150779/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conservative Automatic Stack Size Check</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 9:53 UTC (Thu)
                               by <b>pkolloch</b> (subscriber, #21709)
                              [<a href="/Articles/150784/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      After a moderate amount of web searching, I could find the abstract of the      <br>
presentation, but not the paper itself. Any pointers?    <br>
      <br>
BTW I did not say that it "easy" for the general case, but for the kernel     <br>
without dynamic stack allocations and recursion. And OK, I was probably   <br>
naive and will agree that it is probably also difficult for this special   <br>
case ;) But both feasible and desirable. I hope Olivier Hainque will be   <br>
successful in his quest and his work will be applied to the kernel.     <br>
      <br>
<font class="QuotedText">&gt; TBH I'd expect that kernel developers' own hunches would be as reliable.      </font><br>
      <br>
And predict which variables are being stored in registers and which on the      <br>
stack and considering all call paths? No, I think humans would miss a lot      <br>
of special cases on that one. Additionally, not anyone would actually     <br>
endeavor to do this for anything but some core functions. Am I wrong?     <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conservative Automatic Stack Size Check</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 11:42 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/150798/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <a href="http://www.gccsummit.org/2005/2005-GCC-Summit-Proceedings.pdf#page=99">The paper starts on page 99 of the proceedings PDF</a>. I've not found it split separately, and the PDF file is quite large (around 1.7MB).
      
          <div class="CommentReplyButton">
            <form action="/Articles/150798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor150920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conservative Automatic Stack Size Check</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2005 1:58 UTC (Fri)
                               by <b>sethml</b> (guest, #8471)
                              [<a href="/Articles/150920/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Clever idea, but you missed a case that's hard to deal with: calling through function pointers.  The kernel uses function pointers extensively, especially for device drivers.  I suspect the case mentioned involving RAID involves calling through quite a few levels of function pointers.  Figuring out the maximum possible call stack depth, even very conservatively, is probably pretty difficult, and the conservative answer is probably "infinite" because there are pathways you could construct that would recurse, even if that never happens in practice.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conservative Automatic Stack Size Check</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2005 9:29 UTC (Fri)
                               by <b>pkolloch</b> (subscriber, #21709)
                              [<a href="/Articles/150944/">Link</a>] 
      </p>
      
      </div>
      </summary>
      hmmm, you are right, I knew I had been naive, but I couldn't see what I missed.<br>
<p>
Since from what I saw about the VFS, it's a shame that it is not expressed in an object oriented fashion. That could at least limit the amount of candidates. Maybe one could provide some annotations?<br>
<p>
But I can well imagine that especially concepts as unionfs which wrap other file systems could in principle be wrapped around each other infinitely. You would have too make up some clever notation to tell the stack analyzer that this really isn't possible. (If there is even such a check ;) ) Or is it done in some clever fashion that the wrapped and the wrapper are not called in a nested fashion, but in some kind of chaining way for exactly the purpose of saving stack space?<br>
<p>
[Disclaimer: Again, I have no real clue about the kernel source, so I hope my assumptions are not totally off the beat.]<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor151168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conservative Automatic Stack Size Check</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2005 21:03 UTC (Sat)
                               by <b>joern</b> (guest, #22392)
                              [<a href="/Articles/151168/">Link</a>] 
      </p>
      
      </div>
      </summary>
      FYI: Function pointers are not that hard to follow.  See<br>
<a href="http://wh.fh-wedel.de/~joern/quality.pdf">http://wh.fh-wedel.de/~joern/quality.pdf</a><br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/151168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor160225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">4K stacks for everyone?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2005 10:08 UTC (Wed)
                               by <b>dcg</b> (subscriber, #9198)
                              [<a href="/Articles/160225/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I strongly disagree - this patch has been in fedora core for 2 years. Developers are not pushig this out of their ass. The total stack space is actually bigger due to interrupt stacks. Also, it improves scalability<br>
<p>
Apparently the main issues (Xfs, etc) have been fixed so I'd say that 4KB stacks has actually improved code quality....<br>
<p>
<p>
Larger pages are interesting but they also bring more fragmentation, also lots of no-so-old x86 cpus can't handle pages &gt; 4kb very well AFAIK<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/160225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor150786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Binary graphics drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 10:57 UTC (Thu)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/150786/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      I seem to remember that there was a warning in the kernel configuration option about breaking binary-only modules such as NVidia and ATI drivers if the stack is only 4k. Was this problem fixed?
<P>
<CENTER>Bye,NAR</CENTER>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Binary graphics drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 13:00 UTC (Thu)
                               by <b>sbergman27</b> (guest, #10767)
                              [<a href="/Articles/150809/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Although I am currently running x86_64, which uses 8k stacks, I have run the same machine on i386 Fedora (4k stacks) with the NVidia drivers with no problem.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor150820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Binary graphics drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 14:27 UTC (Thu)
                               by <b>alspnost</b> (guest, #2763)
                              [<a href="/Articles/150820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes - NVidia, at least, fixed their driver to work with 4k stacks back at the time.  I used it for many months on my old x86 system, before switching to AMD64.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor150861"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Binary graphics drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 18:25 UTC (Thu)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/150861/">Link</a>] 
      </p>
      
      </div>
      </summary>
      As I recall, the nVidia graphics drivers were fixed to work with 4k stacks at around the time 2.6.7 came out.  Either .7 or .8.  It's been awhile, though.  I have been running with 4k stacks and the nVidia driver for several kernel versions with no incident.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150861/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor150858"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conexant drivers from Linuxant also requires &gt;4K</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 17:56 UTC (Thu)
                               by <b>astrand</b> (guest, #4908)
                              [<a href="/Articles/150858/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      On my laptop with the ICH6 chipset, which is running FC4, I'm using the HSF softmodem driver from Linuxant. After many kernel panics, I found out that this driver doesn't work with 4K stacks. I replaced the kernel with a version from Linuxant and now things works, but some drawbacks remains:<br>
<p>
* I won't recieve any kernel updates via "yum"<br>
<p>
* I cannot use the NTFS drivers from Livna. <br>
<p>
To sum up, this problem has been boring and frustrating. I don't care if the kernel is a few percents slower, as long as things works...<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150858/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conexant drivers from Linuxant also requires &gt;4K</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2005 18:58 UTC (Thu)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/150866/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
Well its not really a question of speed. Many kernel updates fix security issues. Custom ones will have to rebuild everytime. For filesystems, FUSE has recently been merged in the upstream kernel and will be included in 2.6.14 version. So it might be possible to use a pure user space solution which wouldnt potentially break with every new kernel update<br>
<p>
Rahul<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor151822"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Conexant drivers from Linuxant also requires &gt;4K</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2005 5:25 UTC (Thu)
                               by <b>thleemhuis</b> (guest, #32469)
                              [<a href="/Articles/151822/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; * I cannot use the NTFS drivers from Livna. </font><br>
<p>
You can easily rebuild the kernel-module-ntfs.srpm from livna. See:<br>
<a rel="nofollow" href="http://rpm.livna.org/kernel-modules.html">http://rpm.livna.org/kernel-modules.html</a><br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/151822/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor150924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">4K stacks for everyone?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2005 1:06 UTC (Fri)
                               by <b>mcelrath</b> (guest, #8094)
                              [<a href="/Articles/150924/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      I noticed the other day while configuring my 2.6.13 kernel that there is now an experimental option to use register arguments for function calls.  I imagine this should seriously reduce stack usage.  Perhaps a default 4k stack should require register arguments.<br>
<p>
But this just begs the question...does the kernel really have no means of detecting or handling stack overflows?  That just seems like bad design.  Can't the stack be set up so that if it is over-written it will trigger a page fault, and the kernel could handle it?  gcc/libc can allocate more stack pages for userspace programs if needed, but why not the kernel?<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor150931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM for device drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2005 4:36 UTC (Fri)
                               by <b>xoddam</b> (guest, #2322)
                              [<a href="/Articles/150931/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; gcc/libc can allocate more stack pages for userspace programs  </font><br>
<font class="QuotedText">&gt; if needed, but why not the kernel?  </font><br>
  <br>
A defining characteristic of kernel-space programming is that  <br>
you don't get the benefits of implicit memory protection.  <br>
Everything has to be done explicitly by the kernel itself.  <br>
 <br>
It's possible in principle to give kernel-space tasks virtual  <br>
memory support, but it would open a big can of worms.   If <br>
you want deep recursion, do it in userspace. <br>
 <br>
As things stand the kernel-space page map is never changed  <br>
implicitly, and rarely explicitly.  The prospect of giving  <br>
kernel tasks their own vm maps with holes to fit new pages  <br>
which are to be faulted in (from where?) when the stack  <br>
overflows is nightmarish!  Performance and maintainability  <br>
are much, much more important than a growable stack.  <br>
  <br>
If stack usage in kernel space isn't demonstrably finite  <br>
then the code is broken.  The best solution is explicit  <br>
management of the resources (eg. using a queue) so that  <br>
the stack size ceases to be an issue.  <br>
  <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/150931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor151182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM for device drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2005 1:14 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/151182/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      The kernel uses virtual memory address translation today, and that's all that's required to do this kind of stack overflow protection.  Make the stack one page and the page immediately after it invalid.  A process tries to overflow the stack, and it gets oopsed.
<p>
However, I believe the point of 4K stacks is that there is a dirth of kernel virtual memory address space, so have 4K of usable addresses plus 4K of unusable obviates the 4K stack change.
<p>
To be robust like other OSes in this area, we'd have to go to some complex system with multiple kernel address spaces, and that probably would bring with it a pageable kernel.

      
          <div class="CommentReplyButton">
            <form action="/Articles/151182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor151371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM for device drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2005 1:17 UTC (Tue)
                               by <b>mcelrath</b> (guest, #8094)
                              [<a href="/Articles/151371/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Dirth isn't a word.  The word you wanted is dearth.  (back at cha)<br>
<p>
Anyway, one really needs an oops or panic if the kernel stack is overflowed.  A previous poster said page faults in kernel space aren't detectable.  You are proposing a 4k page at the end of the stack to check if the stack has overflowed.  If there are no page faults in kernel space, then one has to check the stack-overflow page on every process switch?  That seems expensive.<br>
<p>
Then on the other hand this overflow page can probably be only one physical page, shared among all processes (and an oops or panic if ANY process writes it), and if a page fault isn't possible then the task switch could just do an<br>
<p>
 if(stack_overflow[0] != STACK_OVERFLOW_PATTERN) { oops }<br>
<p>
e.g. just check the first byte.  So overall it costs 1 cmp per task switch and 4k.  Seems much better than silent stack overflows, and the possible security flaws that might come from them too...<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/151371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor151431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM for device drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2005 16:07 UTC (Tue)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/151431/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The kernel can and does detect page faults in kernel space.  When the kernel tries to dereference a null pointer, the oops you see is due to the page fault.  The same thing would work with the invalid page after the end of the stack (that's called a "guard page").
<p>
The earlier comment really meant that the kernel is not set up to handle a page fault in a virtual memory fashion -- i.e. do a pagein and continue as if nothing had happened.
<p>
But, unfortunately, the guard page has the same problem as 8K stacks -- requires an extra 4K per thread of kernel virtual memory address space and requires 2 contiguous virtual pages.  There was a time when virtual address space was in abundant supply and we just worried about real memory, but today the reverse is often true.

      
          <div class="CommentReplyButton">
            <form action="/Articles/151431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor152467"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM for device drivers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2005 20:19 UTC (Tue)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/152467/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;There was a time when virtual address space was in abundant supply and we just worried about real memory, but today the reverse is often true.</font><br>
<p>
Well, only on 32 bit CPUs. The suggestion of adding guard page seems very valid to me, even if only for 64 bit CPUs: less crash or at least 'controlled crash' are always better.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/152467/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor151033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">4K stacks for everyone?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2005 17:09 UTC (Fri)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/151033/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Actually the kernel is what expands the userspace stack, not the C library.  If you think about it, it is exanded even in a program which doesn't call any functions in the C library.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/151033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor151129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How exactly would you handle a stack overflow in kernel space?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2005 10:15 UTC (Sat)
                               by <b>pkolloch</b> (subscriber, #21709)
                              [<a href="/Articles/151129/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I think it is not that easy to gracefully deal with stack overflows, even if they get detected. What do you do, if the process scheduler triggers a stack overflow? Disable it?<br>
<p>
Even for device drivers the general case gets tricky... [besides the fact that at least the device in question would have to stop working]<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/151129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor151181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How exactly would you handle a stack overflow in kernel space?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2005 1:04 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/151181/">Link</a>] 
      </p>
      
      </div>
      </summary>
      In most cases, an oops is easy, and significantly more graceful than what we have now.  In some cases (e.g. process scheduler), oops isn't possible, but panic is still more graceful than we we have.

      
          <div class="CommentReplyButton">
            <form action="/Articles/151181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor151183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">4K stacks for everyone?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2005 1:15 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/151183/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
But this just begs the question...does the kernel really have no means of detecting or handling stack overflows?
</blockquote>
<p>
It doesn't beg any question.  It just raises one.  "Beg" means "evade."

      
          <div class="CommentReplyButton">
            <form action="/Articles/151183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2005, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
