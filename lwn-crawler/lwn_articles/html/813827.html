        <!DOCTYPE html>
        <html lang="en">
        <head><title>Two new ways to read a file quickly [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/813827/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/813895/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/813827/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Two new ways to read a file quickly</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 6, 2020</br>
           </div>
System calls on Linux are relatively cheap, though the mitigations for
speculative-execution vulnerabilities have made them more expensive than
they once were.  But even cheap system calls add up if one has to make a
large number of them.  Thus, developers have been working on ways to avoid
system calls for a long time.  Currently under discussion is a pair of ways
to reduce the number of system calls required to read a file's contents,
one of which is rather simpler than the other.
<br clear="all">
<p>
<h4>readfile()</h4>
<p>
LWN recently <a href="/Articles/813172/">looked at</a> the proposed
<tt>fsinfo()</tt> system call, which is intended to return information
about mounted filesystems to an application.  One branch of the discussion delved into
whether that information could be exported via sysfs instead; one concern
that was expressed about that approach is that
the cost of reading a lot of little files would be too high.  Miklos
Szeredi <a
href="/ml/linux-kernel/CAJfpegtOwyaWpNfjomRVOt8NKqT94O5n4-LOHTR7YZT9fadVHA@mail.gmail.com/">argued</a>
that it would not be, but suggested that, if people were concerned, they
could reduce this cost by introducing a new system call to read the contents of a
file:
<p>
<pre>
    ssize_t readfile(int dfd, const char *path, char *buf, size_t bufsize, 
		     int flags);
</pre>
<p>
The <tt>dfd</tt> and <tt>path</tt> arguments would identify a file in the
usual way.  A successful <tt>readfile()</tt> would read the contents of the
indicated file into <tt>buf</tt>, up to a maximum of <tt>bufsize</tt>
bytes, returning the number of bytes actually read.  On its face,
<tt>readfile()</tt> adds nothing new; an application 
can obtain the same result with calls to <tt>openat()</tt>,
<tt>read()</tt>, and <tt>close()</tt>.  But it reduces the number of system
calls required from three to one, and that turns out to be interesting to
some users.
<p>
In particular, Karel Zak, the maintainer of the util-linux project, <a
href="/ml/linux-kernel/20200303113814.rsqhljkch6tgorpu@ws.net.home/">offered</a>
"<q>many many beers</q>" for the implementation of
<tt>readfile()</tt>.  Many of the utilities in util-linux (tools like
<tt>ps</tt> and <tt>top</tt>, for example) spend a lot of time reading
information from small <tt>/proc</tt> and sysfs files; having a
<tt>readfile()</tt> call would make them quite a bit more efficient.
<p>
People who complain that it's hard to get kernel developers to pay
attention to their problems clearly have missed an important technique;
Greg Kroah-Hartman quickly <a
href="/ml/linux-kernel/20200303130347.GA2302029@kroah.com/">responded</a>
with enthusiasm: "<q>Unlimited beers for a 21-line kernel patch?  Sign
me up!</q>".  He provided a first implementation, and went on to say
that this system call might actually 
make sense to have.  Naturally, the patch has grown past 21&nbsp;lines once
all of the details that need to be taken into account were dealt with, and
there is still a manual page to write.  But it seems likely that there will
be a submission of <tt>readfile()</tt> in the near future.
<p>
Of course, some people are already talking about the need for a
<tt>writefile()</tt> as well.
<p>
<h4>readfile() on the ring</h4>
<p>
As the conversation progressed, Jann Horn <a
href="/ml/linux-kernel/CAG48ez3Z2V8J7dpO6t8nw7O2cMJ6z8vwLZXLAoKGH3OnCb-7JQ@mail.gmail.com/">pointed
out</a> that the developers working on <a
href="/Articles/776703/">io_uring</a> have also expressed interest in
adding a <tt>readfile()</tt>-like capability.  The whole point of io_uring
is to be able to perform system-call actions asynchronously and without
having to actually call into the kernel, so it might seem like a good fit
for this use case.  He did note that truly
supporting that feature in io_uring is "<q>a bit complicated</q>",
since there is no way to propagate a file descriptor returned by
<tt>openat()</tt> to a subsequent <tt>read()</tt> operation queued in the
ring.  Without that, the <tt>read()</tt> cannot be queued until after the
file has been opened, defeating the purpose of the exercise.
<p>
The fact of the matter, though, is that "a bit complicated" is a good description of
io_uring in general.  It seems unlikely that the author of a tool like
<tt>ps</tt> is going to want to go through all of the effort needed to set
up an io_uring instance, map it into the address space, queue some
operations, and start things running  just to avoid some system calls when
reading <tt>/proc</tt>.  But the
developers of other, more complex applications would, it seems, like to have
this sort of capability.
<p>
In short order, perhaps in the hope of tapping into that "unlimited beer"
stream, io_uring maintainer Jens Axboe <a
href="/ml/io-uring/20200303235053.16309-1-axboe@kernel.dk/">posted</a> a
patch that fills in the missing piece.  It works by remembering the file
descriptor returned by the last <tt>openat()</tt> call in a given chain of
operations.  To implement a <tt>readfile()</tt>, an application could set
up an io_uring chain with three operations, corresponding to the
<tt>openat()</tt>, <tt>read()</tt>, and <tt>close()</tt> calls.  For the
latter two, though, the usual file-descriptor argument would be provided as
the special constant <tt>IOSQE_FD_LAST_OPEN</tt>, which would be replaced
by the descriptor for the last opened file when the operation executes.
<p>
This approach works, at the cost of complicating the interface and
implementation with the magic file-descriptor substitution.  Josh Triplett had
a different idea, which he first <a href="/Articles/810495/">posted in an
LWN comment</a> in January: let applications specify which file descriptor
they would like to use when opening a file.  He filled out that idea in
March with
<a href="/ml/io-uring/20200304143548.GA407676@localhost/">a patch
series</a> adding a new <tt>O_SPECIFIC_FD</tt> flag to the <a
href="/Articles/796868/"><tt>openat2()</tt></a> system call.  This feature
is available independently of io_uring; if an application really wants to
open a file on descriptor 42 and no other, the new flag makes that
possible. 
<p>
The patch set also adds a new <tt>prctl()</tt> operation to set the minimum
file descriptor to use when the application has not requested a specific
one.  This minimum defaults to zero, preserving the "lowest available
descriptor" semantics that Unix has guaranteed forever.  A developer
wanting to control the file descriptors used could raise this
minimum and know that the kernel would not use any of the descriptors below
that minimum without an explicit request.
<p>
It only took Axboe about three hours to come up with <a
href="/ml/io-uring/20200304180016.28212-1-axboe@kernel.dk/">a new patch
series</a> integrating this work.  It mostly consists of delaying the
checks of file-descriptor validity so that they don't happen ahead of the
call that actually makes a given descriptor valid.  There seems to be a
general agreement that this approach makes more sense than magic
file-descriptor substitution, so this is the version that seems likely to
go ahead.
<p>
At this point, though, this work has only circulated on the io_uring list,
which has a relatively limited readership.  Axboe has <a
href="/ml/io-uring/ed5c490f-4faf-afc7-bfab-d58aed061fc6@kernel.dk/">said</a>
that he plans to post it more generally in the near future, and that
merging for 5.7 is within the realm of possibility.  So it may well be that
there will soon be two different ways for an application to read the
contents of a file with a minimum of system calls — and Karel Zak may end
up buying a lot of beer.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls-readfile">System calls/readfile()</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/813827/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor814072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 16:16 UTC (Fri)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/814072/">Link</a>] (50 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, how is one actually supposed to use O_SPECIFICFD in real life though? I mean, picking some specific FD nr can work in trvial, single threaded programs maybe, but how is that supposed to work on typical generic userspace code that has many threads and many libraries/subsystems all running in the same address space (and fd space) that want to take possession of some fd? I mean are apps supposed to block fd ranges ahead of time, by dup()ing /dev/null a couple of times, or how is that supposed to work? not getting this...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 17:32 UTC (Fri)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/814081/">Link</a>] (39 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The simple use case can be done by raising the min fd as described in the article. For slightly more complicated, app could manage that space (between 0/2 and min_fd). Outside of that, one idea bounced around was fd reservation, which essentially ends up being the same thing, except the kernel now manages the reservations for you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 20:18 UTC (Fri)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/814108/">Link</a>] (37 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite frankly this doesn't sound thought to the end to me. Having to have a userspace pre-allocator/fd arena manager requires complex code that glibc would have to carry to be useful (since every lib, every subsystem loaded into the local process has to buy into this to work). Otherwise everyone is going to step on each others toes here. I am pretty sure picking a numeric fd is something the kernel should do, its kinda its primary job: allocating objects...<br>
<p>
This concept makes things easy in kernel space maybe, but is not managable in non-trivial real-life apps in userspace I am sure.<br>
<p>
I mean, its a bit like rtsigs: almost noone uses them, because there are no allocation semantics defined and thus library code could never safely, generically, reliably make use of them. rtsigs are a failure as an I/O concept in hindsight and this plays a major role in that I think, and I don't think it would be a good idea to repeat this with fds now. Its kinda like picking the semantics of one of the crappiest kernel concepts (rtsigs) we have and applying them to one of the saner kernel concepts we have (fds), just because its a bit easier to implement in the kernel (at the cost of much heavier userspace work).<br>
<p>
Or to say this differently: few people would think that a userspace malloc() implementation that takes the memory pointer value as input (rather than as output) would be a good idea, I am sure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814114"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 20:46 UTC (Fri)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/814114/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't generally disagree with you. 1) The concept isn't finalized at all, and 2) As mentioned at the end, having the kernel manage the allocations were indeed one of the suggestions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814114/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 21:25 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/814117/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd like to discuss this on linux-fsdevel, but in lieu of that ...<br>
<p>
I think the right way to do this is to have userspace open /dev/null as often as it needs to in order to create the fds it will need. Then use those fd #s in the io_uring calls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 23:58 UTC (Fri)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/814129/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've been back and forth on it, but I think leaving fd allocation to the kernel is ultimately the right thing to do. Very few applications actually care _what_ fd they end up getting, and trying to do anything else is going to make it hard to eliminate competing users. This functionality will almost certainly end up in certain libraries after all so you would need a standard allocator of some sort.<br>
<p>
Mainly, io_uring needs to be able to specify that a subsequent read (or write, or whatever) use the fd from an open done earlier in the same chain. I think just being able to express "use the fd from last open" would be super useful for about 90% of use cases, and you could always layer on another way to deal with multiple fds later.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 6:33 UTC (Sat)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/814151/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In multi-threaded programs (which do exist), the concept of a "last-opened file descriptor" is entirely meaningless. How can anyone think this would be a good idea?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 10:39 UTC (Sat)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/814176/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But in the context of a single io_uring command queue, "last-opened file descriptor" seems perfectly well defined.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 17:33 UTC (Sat)
                               by <b>justincormack</b> (subscriber, #70439)
                              [<a href="/Articles/814205/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not if you open lots of files asynchronously. You need to identify which open you meant.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814206"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 18:01 UTC (Sat)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/814206/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A linked sequence of io_uring operations provides that. If you need to operate on lots of files, you have lots of linked sequences, each of which opens one file and operates on it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814206/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2024 13:40 UTC (Tue)
                               by <b>sammythesnake</b> (guest, #17693)
                              [<a href="/Articles/962837/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry for the thread necromancy, but...<br>
<p>
Isn't operating on thousands of files in one io_uring linked sequence exactly the kind of thing some applications would like to do,  reducing thousands of syscalls to a couple...?<br>
<p>
Would some kind of per-io_uring-linked-sequence "pseudo-FD" make sense? In/alongside open operations, you could provide a number (1, 2, 3...) for each file opened in the sequence that the kernel transparently maps to "real" FDs internally. Later operations could then identify which of the files opened within the sequence should be acted on (e.g. "read the file *this sequence* calls "1". Maybe with negative FD numbers...?)<br>
<p>
The pFD *could* be sequentially allocated so subsequent calls would simply say "the third one opened" but keeping those straight while editing the sequence would be error-prone, so that's probably not a win over finding a way to nominate a pFD.<br>
<p>
Obviously, they're are details to sort out like managing the pFD-&gt;FD mappings, and getting the API right, but none of that sounds nastier than the other things suggested in this thread (to me, at least - I'm merely a curious bystander!)<br>
<p>
This is presumably a very naive question, but can't an io_uring open() operation save the FD returned it a look-up table to be referenced by later operations - that would seem the "obvious" way to me, but I assume this isn't possible, or this whole thread would be moot...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962906"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2024 16:32 UTC (Tue)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/962906/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you have described the descriptorless FDs: <a href="https://lwn.net/Articles/863071/">https://lwn.net/Articles/863071/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962906/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor814189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 13:34 UTC (Sat)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/814189/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think that opening /dev/null is the right approach here, for multiple reasons:<br>
<p>
1) The block of reserved fds shouldn't actually consist of open file descriptors that take up resources, especially if we may want to have a block of reserved fds per thread.<br>
2) If the only thing keeping an fd reserved is that it has an open file on it, then once that fd is opened and subsequently closed, it stops being reserved. The fd should stay reserved after being closed.<br>
3) O_SPECIFIC_FD specifically doesn't allow opening "over" an existing open file descriptor the way dup2 does; it'll return -EBUSY. I felt that would be less error-prone, and would help catch races.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 15:08 UTC (Sun)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/814248/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding 3 I think that's a mistake, O_SPECIFICFD to open and dup2 to close seems like a very easy way to manage pre-reserved file descriptors, even without the prctl.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 15:14 UTC (Sun)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/814250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps we could have a specialized "reserved" fd type, and use that instead of opening /dev/null, and only allow "overwriting" that.It would help to have a guaranteed continuous chunk of fds to allocate out of, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor814139"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 2:53 UTC (Sat)
                               by <b>ploxiln</b> (subscriber, #58395)
                              [<a href="/Articles/814139/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      Programs like ps, top, grep, and even nginx or mariadb, could benefit from this kind of thing, while not linking many "miscellaneous" libraries. Not all programs should be huge agglomerations like systemd or libreoffice or gnome-shell, in fact most programs shouldn't.

And "miscellaneous" libraries should not be using these advanced APIs automatically anyway, they should always be under explicit control of the main program. You would never want libdbus or libsystemd or glib2 to use these advanced interfaces automatically.

(Of course, systemd does seem to want to do every new whiz-bang thing automatically, default enabled, and then when it causes problems it's always someone else's fault...)
      
          <div class="CommentReplyButton">
            <form action="/Articles/814139/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 19:03 UTC (Sat)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/814208/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Programs like ps, top, grep, and even nginx or mariadb, could benefit from this kind of thing</font><br>
<p>
Well what if you want to implement (or use) the ps command but as a C library?<br>
<p>
<font class="QuotedText">&gt; And "miscellaneous" libraries should not be using these advanced APIs automatically anyway, they should always be under explicit control of the main program.</font><br>
<p>
Why not? As a potential user of an ps-as-a-C-library, why would I care what it does internally? And what classifies as an "advanced API" in contrast to a "non-advanced API" anyway?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 19:44 UTC (Sat)
                               by <b>ploxiln</b> (subscriber, #58395)
                              [<a href="/Articles/814211/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As a potential user of an ps-as-a-C-library, why would I care what it does internally?</font><br>
<p>
You should care about what every library you use does internally. Every single library you use brings security, compatibility, efficiency, and general tech-debt burden.<br>
<p>
ps-as-a-library would need the old open/read/close method for compatibility with older kernels, and that method should be the default for newer kernels too. A user which knows what they are doing could enable the super-efficient mode explicitly, by passing a range of file descriptors they want ps-as-a-library to use for it.<br>
<p>
<font class="QuotedText">&gt; And what classifies as an "advanced API" in contrast to a "non-advanced API" anyway?</font><br>
<p>
Anything which needs to be managed in a process-global manner. Signals are another example. Libraries may suggest the user register some signal handlers for them, or offer to register signal handlers if the user explicitly requests it.<br>
<p>
zlib has no interest in this, nor libjpeg ... openssl takes sockets you create and open yourself, and they can even be non-blocking. The opening and closing of file descriptors is up to you, not the library. Or, some libraries offer helpers to open and close files or connections, which you have to call explicitly.<br>
<p>
You could use a library which makes a mess - but don't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 20:19 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/814213/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; ps-as-a-library would need the old open/read/close method for compatibility with older kernels, and that method should be the default for newer kernels too. </font><br>
Why? Compat code (to be eventually removed) is fine. But why wouldn't library use new functionality?<br>
<p>
<font class="QuotedText">&gt; A user which knows what they are doing could enable the super-efficient mode explicitly, by passing a range of file descriptors they want ps-as-a-library to use for it.</font><br>
If a library can do it transparently then why not do it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 19:59 UTC (Sun)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/814266/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; to be eventually removed</font><br>
<p>
My past experience tells that most likely it is the new and shiny interface that will be removed or deprecated (to be replaced by even a newer and shinier interface) than something that is survived for ages and still does the job.<br>
<p>
Case in point is epoll. If I have an old code that uses poll, I would not bother to replace that with epoll. I would rather go straight to io ring.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 21:37 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/814272/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; My past experience tells that most likely it is the new and shiny interface that will be removed or deprecated (to be replaced by even a newer and shinier interface) than something that is survived for ages and still does the job.</font><br>
Why not select() then, to be maximally traditional?<br>
<p>
Traditional UNIX interfaces are badly designed, on all fronts (process management, file management, AIO, you name it). And traditional design affected the replacement interfaces as well: poll (and epoll), AIO, etc. These days thankfully the attitude is "screw UNIX and design something that makes sense".<br>
<p>
This is definitely refreshing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814294"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 9:39 UTC (Mon)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/814294/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It does not  matter that the interface may look as badly designed from the present moment. The only thing that matters is that it is still used after 30 years meaning it is good enough across very huge range of hardware.<br>
<p>
And if an application uses select and it shows its limitations, I will skip poll when patching it and depending on the target I will opt for epoll or the io ring. Which shows the same rule. A new thing most likely will be replaced by even newer thing than the old thing that still works acceptably stops being suitable.<br>
<p>
Essentially the new thing is optimized for the present moment. We do not know how relevant that optimization will be in future. The old thing by surviving and still working shows that when it was created it was not over optimized. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814294/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814296"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 16:34 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/814296/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Essentially the new thing is optimized for the present moment. We do not know how relevant that optimization will be in future.</font><br>
The thing is, readfile() is inherently more optimizable than the open()/read()/close() sequence. And it simply can't be slower than them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814296/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814427"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 21:11 UTC (Mon)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/814427/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; readfile() is inherently more optimizable </font><br>
<p>
It is more optimizable in context of the present hardware and current kernel code. RISC architecture is based on an assumption that a small number of fast operations is better than a big set of complex ones. So it could be that on future hardware one could have a small set set of super-fast syscalls. Then readfile implemented as a syscall would be a liability. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814427/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814429"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 21:13 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/814429/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It is more optimizable in context of the present hardware and current kernel code. </font><br>
Incorrect. It'll ALWAYS be more optimizable. In the worst case it'll be no worse than open/read/close sequence.<br>
<p>
The main potential for optimization is for networked filesystems where one readfile() request can easily save a couple of roundtrips.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814429/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815216"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 16:18 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/815216/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ibukanov just gave you a plausible example of a situation in which they are not incorrect: in which common syscalls like read/write/open etc are ultrafast, while uncommon ones like readfile remain slow. Oops, now it's less optimizable.<br>
<p>
Do you even read what you're responding to?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815216/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 16:40 UTC (Tue)
                               by <b>mebrown</b> (subscriber, #7960)
                              [<a href="/Articles/815221/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did you notice he used the word "optimizable"? Paying careful attention to that suffix: -able, can you explain a future world that exists where it's not possible to optimize one system call to be faster than three system calls?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 22:50 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/815261/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I just did: a potential world in which there is a small set of fast syscalls (perhaps architectural limitations prevent the set becoming larger), and a larger set of slow ones. open() and read() would almost certainly be in the fast set; readfile(), being rarely used to date, would surely be in the slow set. If syscall entry/exit in the fast set is at least three times faster than from the slow set, there's nothing you can do to make that one slow syscall faster than the three fast ones, as long as they're doing remotely the same work.<br>
<p>
(Similar things have existed before, and will again: the vDSO is one such, as is the fast syscall optimization in Solaris on SPARC.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815278"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 18, 2020 10:10 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/815278/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Except that for such a potential world to be worth considering, you need to explain how it's plausible.
<p>The "fast syscall optimization" in Solaris on SPARC used the fact that SPARC has 128 syscall entry points in the hardware to optimize up to 128 syscalls - that's over a third of Linux syscalls, more if you ignore all the legacy syscalls (as Solaris could, since it could do the translation from legacy to current in libc). It only had such a drastic effect in Solaris since the "fast" syscalls didn't make use of the generic ABI translation at syscall entry that Solaris chose to do to simplify syscall implementation - in other words, it worked around a known software deficiency in Solaris, stemming from their desire to use the same SunStudio compiler and ABI for all code, rather than teaching SunStudio to have a syscall ABI for kernel code to use.
<p>The vDSO isn't about syscalls per-se; the vDSO page is a userspace page that happens to be shared with the kernel, and contain userspace code and data from the kernel, allowing you to completely avoid making a syscall.
<p>Remember that, at heart, syscalls are four machine micro-operations sequenced sensibly; everything else is built on top of this:
<ol>
<li>Save the current privilege level, so that you can restore it on return.
<li>Save the next PC so that you can return back here.
<li>Set the current privilege level.
<li>Set PC to a syscall entry point.
</ol>
<p>Any optimization in hardware that leads to a subset of syscalls being faster has to be in the last micro-operation; all the others are common to all syscalls. The only such optimization that's possible is to have alternate syscall entry points for different syscalls; this is what the SPARC trap system does, using a 128 entry trap table to decide which syscall entry point to use.
<p>Note, too, that the tendency over time is to optimize the hardware with a single syscall entry point, since that's just a single pointer-sized piece of data to track; Intel 8008 through to 80286 only had INT for syscalls, 80386 added call gates, while Pentium II added SYSENTER which only has a single possible entry point. Similarly, ARM, MIPS, POWER, PowerPC, RISC-V, and AArch64 all only have a single instruction to do syscalls that goes to a single syscall entry point (albeit that on POWER, PowerPC, ARM, and AArch64, that instruction also includes a limited amount of data that's supplied to the kernel, intended for use as a syscall number).
<p>SPARC is the one exception to the rule that more modern architectures only have a single syscall entry point, with its trap table of 128 entries, and even then, it was only a performance win because Solaris was able to use the trap table to get around its own earlier bad decisions around syscall handling.
      
          <div class="CommentReplyButton">
            <form action="/Articles/815278/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor815219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 16:53 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/815219/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Except that that's an implausible situation, based on the hardware of the last 50 (yes, 50!) years.
<p>The trend has been towards fewer system call instructions, not more, over time. In the 1970s, you had things like the 8008's RST instructions, which gave you a small number of fast system calls. RISC CPUs have tended to have just a single syscall type instruction (sc/svc in PowerPC/POWER, SVC in AArch64, SWI in AArch32, syscall in MIPS), with the exception of SPARC, whose trap instructions allowed you to specify different trap handlers directly.
<p>In modern x86, the SYSENTER/SYSCALL instructions are also a single option - there's no "fast path" included here at all.
<p>Now, AArch32, AArch64, POWER/PowerPC, and VAX all have an argument supplied as part of the syscall instruction itself, but it's literally just an argument. It doesn't point you to a new trap handler, it's just an argument to the handler.
      
          <div class="CommentReplyButton">
            <form action="/Articles/815219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor814232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 7:55 UTC (Sun)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/814232/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Programs like ps, top, grep ...</font><br>
<p>
But is anyone actually complaining or concerned about poor performance of these programs?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 11:29 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/814239/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
top's job is to inspect system performance, so it should itself be performant to minimize its impact on system performance.<br>
<p>
And I'm sure plenty of people care about grep running slower than it needs to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 17:00 UTC (Sun)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/814254/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
And I'm sure plenty of people care about grep running slower than it needs to.
</Blockquote>
<P>grep on large files should be IO bound, and grep on a small file is surely overshadowed by process startup time rather than an extra system call to get file contents into a buffer.</p>
<p>
I've also never noticed top negatively impacting system performance; even the busybox version on little embedded systems has never caused me a problem or disappointed.</p>
<P>Generically allowing system-call batching is a good idea, but personally I'm less convinced by esoteric system-calls for specific and limited use cases.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/814254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 18:06 UTC (Sun)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/814261/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have seen top use a noticeable fraction of CPU time. You're not gonna hit that on a 2 core system with 30 idling processes. But a busy 64 core system with a few thousand processes is a different story.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 23:42 UTC (Sun)
                               by <b>himi</b> (subscriber, #340)
                              [<a href="/Articles/814282/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very much so, and even in less intrusive cases it introduced a spike in instantaneous load that can affect interactive and time sensitive processes (games, audio, that kind of thing).<br>
<p>
And the general principle of having measurement of the system cause as little impact on the properties being measured definitely holds.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor814299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 11:05 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/814299/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
grep on a small file, sure, but what about grep on many small files (e.g. grep -r foo /usr/include)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor814433"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 22:00 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/814433/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I grep through large source trees all the time --- several gigabytes of data spread over thousands or millions of files, all cached in RAM so not I/O bound.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814433/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor814268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 20:02 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/814268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many people do care about grep being slow, and care enough to rewrite it from scratch. Even ack is advertised as being faster than grep (mostly by filtering the list of files to search, e.g. skipping .git directories by default), and ag is advertised as "an order of magnitude faster than ack" (because of multithreading, mmap() instead of read(), faster regex engine, etc), and ripgrep is advertised as being much faster than ag (better multithreading, both mmap() and read() in different situations, better regex engine, etc).<br>
<p>
There's no point optimising the kernel for grep itself, because grep could be improved by maybe two orders of magnitude with purely application changes; but it might be worth considering whether kernel changes could improve the performance of ripgrep which has already taken most of the low-hanging fruit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor814283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 23:51 UTC (Sun)
                               by <b>himi</b> (subscriber, #340)
                              [<a href="/Articles/814283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point of readfile() in the context of ps and the like is that it's opening, reading the contents of, and closing lots of small files - that's a lot of small operations performed on the filesystem, which in cases like a clustered filesystem could be translated into things like a lot of distributed lock operations and metadata operations, which can have major impacts on filesystem performance. Using a single syscall won't get rid of all that, but depending on the implementation it could represent a significant improvement.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor815220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 16:38 UTC (Tue)
                               by <b>mebrown</b> (subscriber, #7960)
                              [<a href="/Articles/815220/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am. I  have an embedded system that I need to monitor for performance issues and I'd rather not my performance monitoring tools cause performance issues!<br>
<p>
In practice I observe that current implementations of top use a noticeable percentage of CPU, which can throw off my observations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor814247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 15:06 UTC (Sun)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/814247/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there a dup2 io_uring operation that can be used instead of close?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor814082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 17:39 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/814082/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would guess that highly-parallel code would use some kind of allocator that would divide the descriptor space into thread-local arenas.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 18:28 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/814088/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So... it's simpler to implement tcfdalloc() in userspace, than to just let io_uring do the "magic fd substitution" in kernelspace? Maybe I just don't understand what we mean by "simplicity."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 18:42 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/814093/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The dense structure of file descriptors is actually becoming a problem in its own right. Having a way to opt out of it is a nice feature in itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor814080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 17:46 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/814080/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bash, and I'd guess other POSIX shells, currently requires an extra dup2+close to force file handles to have a number other than the kernel-assigned one. That happens for every &lt; or &gt; redirect except when the command line is lucky enough to ask for the same number the kernel gives it (which never happens). An average autoconf script contains about 1500 of these, so it adds up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814119"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 21:45 UTC (Fri)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/814119/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does it really? I thought the configure script opens the file handles it wants upfront, eg attaching 5 to config.log, and thereafter the commands that want to log just do &gt;&amp;5, which should just be a dup2 call?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814119/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 23:06 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/814122/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're right, it looks like they already thought of this. There's still a few hundred lines that don't: &gt;$CONFIG_STATUS (containing a string filename) and &gt;/dev/null and the like. But that's something autotools upstream could fix on their own if they wanted.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor814136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 1:16 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/814136/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  I mean are apps supposed to block fd ranges ahead of time, by dup()ing /dev/null a couple of times</font><br>
<p>
What's wrong with that? It seems like a perfectly reasonable approach to me.<br>
<p>
More generally, the io_uring "use the last FD" proposal is just a special case of the "promise pipelining" approach that systems like Cap'n Proto implement [1]. In a way, the series of IO requests in io_uring amounts to a little program. We can add features like "local variables" (the last FD opened), flow control, or even branches to this little programming language, but I think it's better to just use eBPF to specify batches of system-call-like operations that a program might want to do in the kernel.<br>
<p>
[1] <a href="https://capnproto.org/rpc.html">https://capnproto.org/rpc.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 3:10 UTC (Sat)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/814142/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think it's better to just use eBPF to specify batches of system-call-like operations that a program might want to do in the kernel.</font><br>
<p>
The X Window System solved this problem in the 1980s, and not by embedding a programming language in the X protocol. Letting the user specify the ID allows sending a batch of requests that include object creation.<br>
<p>
X gave clients an initial range of IDs they could use, and then provided a protocol to ask for a new "block" of IDs. We could, similarly, provide a call to reserve a block of IDs, and a library can ask for and use such a block without any fear of stepping on other libraries.<br>
<p>
The "minimum fd" mechanism was intended as a trivial reservation mechanism for programs to use, as well as something useful for other purposes (such as ensuring that you can't "accidentally" open a random file as file descriptor 1 if file descriptor 1 got closed). It's not the only such reservation mechanism possible, just the simplest.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor814150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 6:02 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/814150/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In a way, the series of IO requests in io_uring amounts to a little program. We can add features like "local variables" (the last FD opened), flow control, or even branches to this little programming language</font><br>
<p>
Long ago there was a proposal and proof of concept, syslets, that did exactly that: <a href="https://lwn.net/Articles/221887/">https://lwn.net/Articles/221887/</a> It eventually morphed into something simpler (<a href="https://lwn.net/Articles/261473/">https://lwn.net/Articles/261473/</a>) and then just died.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor814144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 3:15 UTC (Sat)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/814144/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The requested file descriptor must *not* already be open; if it is, the attempt to allocate it will return -EBUSY. This is intentionally not a dup2-syle operation that closes the target fd, because that would be more error-prone (stepping on a file descriptor used elsewhere in the program).<br>
<p>
The file descriptor should be reserved, instead. The min_fd approach provides one way to do that; we could also add a more general mechanism to ask the kernel for a range of unused file descriptors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor814069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 16:33 UTC (Fri)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/814069/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; spend a lot of time reading information from small /proc and sysfs files; having a readfile() call would make them quite a bit more efficient. </font><br>
<p>
Isn't the cost of that mostly locking and rendering them in the kernel, not the system calls?   (OK I didn't try to measure, but I hope the people asking for this have tried and will refute me by posting numbers)<br>
<p>
<font class="QuotedText">&gt; To implement a readfile(), an application could set up an io_uring chain with three operations, corresponding to the openat(), read(), and close() calls.</font><br>
<p>
One tricky thing with this is that the simple "read a file into memory" falls over badly if somehow one is passed a large file.  In libostree we have a helper which switches to mmap() for large files: <a href="https://github.com/ostreedev/ostree/blob/26a2be0578ec10898a29f32d6ec01a355a03122d/src/libotutil/ot-fs-utils.c#L163">https://github.com/ostreedev/ostree/blob/26a2be0578ec1089...</a><br>
and I know a lot of other userspace does that, like ripgrep, etc.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 10:37 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/814175/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Isn't the cost of that mostly locking and rendering them in the kernel, not the system calls?</font><br>
<p>
Yes. Naming /proc and /sys as an example is quite funny.<br>
<p>
On my system the numbers are:<br>
a) calling non-existent system call -- 600 cycles (as measured by rdtsc)<br>
b) calling umask(0) -- 670 cycles (system call which does something)<br>
c) open, read, close /proc/version -- ~6500 cycles (static /proc file which goes through seq_file interface)<br>
d) open, read, close /proc/loadavg -- ~7580 cycles (dynamic /proc file)<br>
<p>
Sysfs generally generate deeper hierarchies and (correct me, if I'm wrong) revalidates dentries on each lookup.<br>
But sysfs have simple file contents.<br>
<p>
I feel that readfile is not important. Stracing all those stat collecting top-like utilities shows that they are living in stone age.<br>
<p>
5516  openat(AT_FDCWD, "/proc/uptime", O_RDONLY) = 5<br>
5516  lseek(5, 0, SEEK_SET)             = 0<br>
5516  read(5, "4082.55 63567.25\n", 8191) = 17<br>
<p>
and the it reseeks to offset 0 again.<br>
<p>
5516  openat(AT_FDCWD, "/proc", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 6<br>
5516  fstat(6, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0<br>
5516  getdents64(6, /* 273 entries */, 32768) = 6856<br>
5516  openat(AT_FDCWD___WHAT___, "/proc/1/stat", O_RDONLY) = 7<br>
<p>
Reading file to Vec[u8] by default In Rust does multiple system calls because it doubles the buffer for vector contents and starts with small value like 16(?).<br>
<p>
Why even help userspace developers?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 11:34 UTC (Sat)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/814178/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why even help userspace developers?</font><br>
<p>
"Some userspace developers are gormless" is not an argument against providing better tools for userspace developers who are not gormless.<br>
<p>
(Whether any particular tool is actually a better tool is a separate conversation.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 12:05 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/814182/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is not, but it can be very demoralizing.<br>
<p>
If top(1) would start preading /proc/uptime, it will do 1 system call just like with readfile().<br>
<p>
The best way to speed up reading lots of /proc and /sys files by factor of 5x is to upload statistics without VFS involvement.<br>
but this battle is probably lost.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor814195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 14:38 UTC (Sat)
                               by <b>burntsushi</b> (guest, #110124)
                              [<a href="/Articles/814195/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Reading file to Vec[u8] by default In Rust does multiple system calls because it doubles the buffer for vector contents and starts with small value like 16(?).</font><br>
<p>
No it doesn't: <a rel="nofollow" href="https://doc.rust-lang.org/src/std/fs.rs.html#266-274">https://doc.rust-lang.org/src/std/fs.rs.html#266-274</a><br>
<p>
$ cat src/main.rs<br>
fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {<br>
    let data = std::fs::read("/tmp/some-big-file")?;<br>
    println!("{}", data.len());<br>
    Ok(())<br>
}<br>
<p>
$ cargo build --release<br>
<p>
$ strace ./target/release/rustfile<br>
openat(AT_FDCWD, "/tmp/some-big-file", O_RDONLY|O_CLOEXEC) = 3<br>
fcntl(3, F_GETFD)                       = 0x1 (flags FD_CLOEXEC)<br>
statx(0, NULL, AT_STATX_SYNC_AS_STAT, STATX_ALL, NULL) = -1 EFAULT (Bad address)<br>
statx(3, "", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=941088098, ...}) = 0<br>
mmap(NULL, 941088768, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9f65d43000<br>
read(3, "Presented by IM Pictures\nProduce"..., 941088099) = 941088098<br>
read(3, "", 1)                          = 0<br>
close(3)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 16:44 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/814204/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;No it doesn't:</font><br>
<p>
Most files in /proc report st_size=0.<br>
<p>
openat(AT_FDCWD, "/proc/stat", O_RDONLY|O_CLOEXEC) = 3<br>
fcntl(3, F_GETFD)                       = 0x1 (flags FD_CLOEXEC)<br>
statx(0, NULL, AT_STATX_SYNC_AS_STAT, STATX_ALL, NULL) = -1 EFAULT (Bad address)<br>
statx(3, "", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS, stx_attributes=0, stx_mode=S_IFREG|0444, stx_size=0, ...}) = 0<br>
read(3, "cpu  2591925 76 66642 2680980 29", 32) = 32<br>
read(3, "58 0 925 0 0 0\ncpu0 161817 6 407", 32) = 32<br>
read(3, "8 167469 97 0 429 0 0 0\ncpu1 158"..., 64) = 64<br>
read(3, "cpu2 158993 7 4186 170648 115 0 "..., 128) = 128<br>
read(3, "60993 10 3957 168784 202 0 7 0 0"..., 256) = 256<br>
read(3, "9 163063 143 0 60 0 0 0\ncpu12 16"..., 512) = 512<br>
read(3, " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"..., 1024) = 1024<br>
read(3, " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"..., 2048) = 821<br>
read(3, "", 1227)                       = 0<br>
close(3)                                = 0<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 23:02 UTC (Sat)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/814223/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It doesn't seem reasonable to put all the blame on userspace when the kernel gives it misleading information.<br>
<p>
I wonder if we could enhance statx to have a STATX_SIZE_HINT flag? With that flag, statx could return a new attribute indicating that the file has an unspecified size and should be read in a single read call, along with a hint for a buffer size that's *probably* big enough. That would substantially reduce the number of read calls.<br>
<p>
(Also, for future reference, the first statx call is Rust probing to see if the kernel supports statx, and it only happens for the first statx in the program. Likewise, the fcntl checks if the kernel respects O_CLOEXEC, and that only happens on the first open.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814320"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 14:10 UTC (Mon)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/814320/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe a simpler change would be for the kernel to cache the *last* size of a file in /proc and report it?  Though it might trigger bugs in userspace apps that wouldn't be prepared for the file growing between stat() and read().<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814320/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 15:29 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/814397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think any app or library expecting stat to have trustworthy information at read time without some safety net is already a disaster waiting to happen (especially if they're in the /proc hierarchy; the file could fail to *open* after stat returns because the process exited in the meantime).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor814554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2020 11:51 UTC (Wed)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/814554/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Best way to read /proc is to read PAGE_SIZE minimum at once, and interpret short read as EOF for small files like /proc/uptime or /proc/*/statm which are bounded in size. Bigger reads should be (PAGE_SIZE &lt;&lt; n) for unbounded files (/proc/*/maps):<br>
<p>
m-&gt;buf = seq_buf_alloc(m-&gt;size &lt;&lt;= 1);<br>
<p>
Most of sysfs is 4KB tops but arbitrary sized for binary attributes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor814083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 17:40 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/814083/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The dfd and path arguments would identify a file in the usual way. A successful readfile() would read the contents of the indicated file into buf, up to a maximum of bufsize bytes, returning the number of bytes actually read.</font><br>
How does it indicate that there is still unread data left?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 18:54 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/814092/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The initial patch does not appear to try. Either you get a short read, a complete read, or an error. I think the idea is that you pass a large-but-reasonable buffer size, and if you get a complete read, then you simply assume the file is too big, and you try again with open()/read()/close(). Alternatively, you stat() it first and then dynamically allocate a sufficiently large buffer (plus one byte to detect whether the file has grown, if you care).<br>
<p>
(Obviously, this isn't going to work very well with special files like /dev/zero. But IMHO that's the application's fault for trying to read an infinite stream of data in the first place.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 19:28 UTC (Fri)
                               by <b>nkiesel</b> (subscriber, #11748)
                              [<a href="/Articles/814103/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One could imagine an API which returns a negative number in error case, a number in [0;bufSize] for complete reads, and bufSize + 1 for incomplete reads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 22:58 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/814123/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can emulate that in userspace: just allocate a buffer one byte longer and pass bufSize+1 in the first place. You even get to read the first "extra" byte for free!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 10:58 UTC (Sat)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/814177/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Although I understand how people might consider non-power-of-two sized buffers ugly. The extra 1 byte in an allocation of 8193 bytes would have an alignment overhead of 15 bytes.<br>
<p>
In some cases malloc() will also call mmap() to get whole-page allocations, and that would cause a whole 4k page to be wasted for 1 byte.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 18:06 UTC (Sat)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/814207/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Power of two sized buffers turn out to be a memory wasting trap though.<br>
<p>
There was a blog article I read a while ago, linked off Hacker News I think, talking about some research into memory usage this programmer had done. It turned out that many allocations for buffers of sizes such as 4,096 bytes ended up having 16 bytes or so added to it. This was for memory allocation tracking, or if passed into some API the library would put it into a structure with other variables.<br>
<p>
If I remember correctly the author determined that allocating 4,000 bytes was a nice round number that tended to round up to a 4,096 page size much more reliably.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor815407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2020 12:43 UTC (Thu)
                               by <b>mgedmin</b> (subscriber, #34497)
                              [<a href="/Articles/815407/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Was it <a href="https://blog.mozilla.org/nnethercote/2011/08/05/clownshoes-available-in-sizes-2101-and-up/?">https://blog.mozilla.org/nnethercote/2011/08/05/clownshoe...</a>  That was a great article from a Firefox developer working on memory optimization.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor814252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2020 16:29 UTC (Sun)
                               by <b>nkiesel</b> (subscriber, #11748)
                              [<a href="/Articles/814252/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nope, because if the result is bufSize+1 the caller again does not know if the file fit perfectly into the buffer or if there are more bytes to read.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor814509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2020 16:27 UTC (Tue)
                               by <b>ThomasBellman</b> (guest, #67902)
                              [<a href="/Articles/814509/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Even better, take a cue from snprintf() and return the number of bytes that <i>would</i> have been read if the buffer was infinitely large (i.e, return the file size).  And in case the kernel can't quickly determine the size of the file, return either MAXINT or bufSize+1.
      
          <div class="CommentReplyButton">
            <form action="/Articles/814509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor814087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 18:11 UTC (Fri)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/814087/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do we need a writefile() too?  What about preadfile() or readfile()?<br>
<p>
I think looking at a way to generically batch any system call in an easy to use way might be a better approach, though not easy to get.<br>
<p>
Perhaps a getlastfd() 'system call' could also be used to help bridge the problem of open() (or socket() etc...) then read() without needing to use fixed FD numbers or loop beck through userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814096"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2020 19:11 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/814096/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think looking at a way to generically batch any system call in an easy to use way might be a better approach, though not easy to get.</font><br>
<p>
We have that. It's called "userspace."<br>
<p>
Snark aside, I think any solution in this space needs to be very clear on exactly what set of problems it is solving, and what set of problems are out of scope. Otherwise, I imagine you would inevitably end up with a harder-to-use-but-less-flexible syscall interface.<br>
<p>
<font class="QuotedText">&gt; Perhaps a getlastfd() 'system call' could also be used to help bridge the problem of open() (or socket() etc...) then read() without needing to use fixed FD numbers or loop beck through userspace.</font><br>
<p>
Would getlastfd() be thread-local, or would it be thread-unsafe? Does the kernel track fds in a thread-local way right now?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814096/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 3:12 UTC (Sat)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/814143/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"userspace" has this increasingly problematic performance bottleneck called "system calls", which io_uring replaces with a much faster mechanism called "shared memory".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor814135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 1:04 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/814135/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
These new system calls are nice, but we can't add a fixed-function system call for every single thing somebody might want to do in the kernel. My ideal is a mechanism to send a little BPF program to the kernel and let it specify a bunch of different things to do there --- for example, open a file, read this byte, mmap this range, whatever, all as a single unit of work, entering the kernel once. You'd register such a program with the kernel from userspace, get a file descriptor back, and invoke your custom program via a single system call.<br>
<p>
This way, any userspace program would be able to build its own system call.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 6:54 UTC (Sat)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/814152/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How is this (or any of the other notions) better than the series of system calls? In each case you have a series of things you want the kernel to do, and more or less elaborate ways to specify them. But actually doing the system calls achieves exactly the desired thing without bloating the kernel any.<br>
<p>
Io_uring makes some sense, eliminating a million or a billion system calls in exchange for a little setup. Eliminating two out of three calls just looks foolish. Even if you have to read a thousand files, or a million: one million calls, three million calls, who cares? The time spent is in pottering around in the file system, not transitioning between user and system. An ordinary library function much shorter than 21 lines does it.<br>
<p>
The whole discussion makes no sense. It makes me wonder if Linux is shuffling toward irrelevance. It has happened to better kernels.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor814155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 7:12 UTC (Sat)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/814155/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I imagine that on some network file systems having a single system call means a single round trip to the server.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor814163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2020 7:47 UTC (Sat)
                               by <b>beagnach</b> (guest, #32987)
                              [<a href="/Articles/814163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The time spent is in pottering around in the file system, not transitioning between user and system.</font><br>
<p>
I think much of the discussion is based on the assumption that there are situations where this is not true. <br>
So far we've seen a lot generalizations - hopefully some benchmarks will be provided in the near future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor814295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2020 9:28 UTC (Mon)
                               by <b>pwfxq</b> (subscriber, #84695)
                              [<a href="/Articles/814295/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I could see small utilities being cross-compiled into BPF and run directly in kernel space, rather than user space. After that, I could see some wag expanding the BPF instruction limit and getting Emacs to run in kernel space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/814295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor815209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two new ways to read a file quickly</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2020 15:45 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/815209/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This will break a lot of software through name clashes  once it hits glibc ((or, if namespaces exclude it by default, through misbinding of the symbol to the one in glibc).<br>
<p>
readfile is a commonly used C identifier: Debian codesearch reveals 143 pages of broken packages, nearly all of which appear to be legitimate uses of this identifier in actual C code (though some is in C++ which is presumably safer).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/815209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
