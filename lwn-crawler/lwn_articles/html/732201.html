        <!DOCTYPE html>
        <html lang="en">
        <head><title>A return-oriented programming defense from OpenBSD [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/732201/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/731897/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/732201/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A return-oriented programming defense from OpenBSD</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 30, 2017</br>
           </div>
Stack-smashing attacks have a long history; they featured, for example, as
a core part of the <a
href="https://en.wikipedia.org/wiki/Morris_worm">Morris worm</a> back in
1988.  Restrictions on executing code on the stack have, to a great extent,
put an end to such simple attacks, but that does not mean that
stack-smashing attacks are no longer a threat.  <a
href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-oriented
programming 
(ROP)</a> has become a common technique for compromising systems via a
stack-smashing vulnerability.  There are various schemes out there for
defeating ROP attacks, but a mechanism called "RETGUARD" that is being implemented
in OpenBSD is notable for its relative simplicity.
<p>
In a classic stack-smashing attack, the attack code would be written
directly to the stack and executed there.  Most modern systems do not allow
execution of on-stack code, though, so this kind of attack will be
ineffective.  The stack <i>does</i> affect code execution, though, in that
the call chain is stored there; when a function executes a "return"
instruction, the address to return to is taken from the stack.  An attacker
who can overwrite the stack can, thus, force a function to "return" to an
arbitrary location.
<p>
That alone can be enough to carry out some types of attacks, but ROP adds
another level of sophistication.  A search through a body of binary
code will turn up a great many short sequences of instructions ending in
a return instruction.  These sequences are termed "gadgets"; a large
program contains enough gadgets to carry out almost any desired task â€” if
they can be strung together into a chain.  ROP works by locating these
gadgets, then building a series of stack frames so that each gadget
"returns" to the next.
<p>
This technique allows the construction of arbitrary programs on the stack
without the need for execute permission on the stack itself.  It is worth
noting that, on a complex-instruction-set architecture like x86, unexpected
gadgets can be created by jumping into the middle of a multi-byte
instruction, a phenomenon termed "polymorphism".  Needless to say, there
are tools out there that can be used 
by an attacker to locate gadgets and string them together into programs.
<p>
The <a href="/Articles/732202/">RETGUARD mechanism</a>, posted by Theo de
Raadt on August&nbsp;19, makes use of a simple return-address
transformation to disrupt ROP chains and prevent them from executing as
intended.  It takes the form of a patch to the LLVM compiler adding a new
<tt>-fret-protector</tt> flag.  When code is compiled with that flag, two
things happen:
<p>
<ul>
<li> The prologue to each function (the code that runs before the
     body of the function itself) exclusive-ORs the return address on the
     stack with the value of the stack pointer itself.
<p>
<li> The epilogue, run just before the function returns, repeats the
     operation to restore the return address to its initial value.
</ul>
<p>
The exclusive-OR operation changes the return address into something that
is effectively random, especially when address-space layout randomization
is used to place the stack at an unpredictable location.  With this change,
the first gadget used by a ROP sequence will, when it attempts the second
step above, transform the return address into something unpredictable and,
most likely, useless to an attacker.  That will stop the chain and thwart
the attack.
<p>
There is, of course, a significant limitation here: a ROP chain made up of
exclusively polymorphic gadgets will still work, since those gadgets were
not (intentionally) created by the compiler and do not contain the
return-address-mangling code.  De Raadt acknowledged this limitation, but
said: "<q>we believe once standard-RET is solved those concerns become
easier to address separately in the future.  In any case a substantial
reduction of gadgets is powerful</q>".
<p>
Using the compiler to insert the hardening code greatly eases the task of
applying RETGUARD to both the OpenBSD kernel and its user-space code.  At
least, that is true for code written in a high-level language.  Any code
written in assembly must be changed by hand, though, which is a fair amount
of work.  De Raadt and company have done that work; he reports that:
"<q>We are at the point where userland and base are fully working
without regressions, and the remaining impacts are in a few larger ports
which directly access the return address (for a variety of
reasons)</q>".  It can be expected that, once these final issues are
dealt with, OpenBSD will ship with this hardening enabled.
<p>
It makes sense to ask whether this relatively straightforward hardening
technique could be applied to the Linux kernel as well.  Using LLVM to
build the kernel is not yet a viable option, but it should be possible to
reimplement the RETGUARD transformations as a GCC plugin module.  The
tiresome task of fixing up the assembly code would also need to be done;
the <a href="/Articles/658333/"><tt>objtool</tt> utility</a> could
probably be pressed into service to help with this task.  But the patch
that emerged would not be small.
<p>
If any benchmarks have been run to determine the cost of using RETGUARD,
they have not been publicly posted.  The extra code will make the kernel a
little bigger, and the extra overhead on every function is likely to add up
in the end.  But if this technique can make the kernel that much harder to
exploit, it may well justify the extra execution overhead that it brings
with it.  All that's needed is somebody to actually do the work and try it
out.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Kernel_hardening">Security/Kernel hardening</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Hardening">Hardening</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#OpenBSD">OpenBSD</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/732201/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor732336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 2:25 UTC (Wed)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/732336/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds similar to but not the same as the equivalent protection in RAP from grsecurity, I wonder if the OpenBSD implementation was influenced by grsecurity's patent on RAP.<br>
<p>
<a href="https://www.grsecurity.net/rap_announce.php">https://www.grsecurity.net/rap_announce.php</a><br>
<a href="https://www.grsecurity.net/rap_faq.php">https://www.grsecurity.net/rap_faq.php</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732339"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 3:26 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/732339/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Probably not; RAP is considerably more involved (and causes a lot more slowdown).<br>
Using the stack pointer itself to encode the return address is an interesting idea that should help thwart such attacks with significantly lower overhead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732339/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor732353"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 6:54 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/732353/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it has nothing to do with RAP and it's not quite that novel (and secure) either: <a rel="nofollow" href="https://twitter.com/grsecurity/status/899294869105106944">https://twitter.com/grsecurity/status/899294869105106944</a> and <a rel="nofollow" href="https://pax.grsecurity.net/docs/pax-future.txt">https://pax.grsecurity.net/docs/pax-future.txt</a> . <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732353/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor732357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 9:04 UTC (Wed)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/732357/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Note that the scheme used in RAP has a different trade-off - RAP needs two extra registers (which probably hurts performance) but it also doesn't alter the return address iterator. Modifying the return address are runtime, the way this technique does, will invalidate the processor's branch prediction and hurt performance.
      
          <div class="CommentReplyButton">
            <form action="/Articles/732357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 11:21 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/732361/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think this would interfere with the return stack buffer. Probably the RSB just predicts the return address using an internal stack and verifies that the return address, when popped, matches its prediction. It doesn't matter whether the memory containing the return address was mangled temporarily.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor732348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 4:18 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/732348/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder how easy this is to defeat if the stack address is already known.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732351"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 5:06 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/732351/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or if the stack address is reasonably predictable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732351/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor732371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 13:58 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/732371/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In most cases a function is called from only a finite number of places.  If the number of such places is less than 256, then instead of storing a return address on the stack you could store a byte.  At the end of the function the compiler generates code to jump to one of several possible addresses depending on the value of that byte.  Then no matter what the attacker overwrites he can't jump to a gadget of his choosing, only to a small number of points that call the function in normal use anyway.  And if there are only 5 possible return points but the byte is overwritten with 99, that's a clean crash ('stack corruption detected') rather than a jump to some random address.  The stack becomes smaller too.  (Performance would suffer if there are loads of possible return points and the compiler generates an endless if-then-goto-else chain, but you could set an upper limit or disable the mechanism for performance-critical code, which can then be audited more carefully than usual.)<br>
<p>
Here I am thinking of the program as a single lump of object code which is compiled and linked in its entirety before running.  Obviously if you have loadable modules or you are writing a dynamically linked library you have to allow more flexibility in return addresses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 0:12 UTC (Thu)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/732472/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice idea!  Presumably you'd want this to use a simple lookup table (with a bounds check), in which case the performance wouldn't be particularly affected by a large number of callers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 8:34 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/732492/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, a lookup table might perform better for large numbers of callers, while if there are just two possible values a couple of inline test-and-jumps would likely be faster.  (And if there are a hundred possible callers but one of them is way more frequent than the others, it might still be faster to test for that one first.)  It depends on benchmarks and would likely vary by platform and even by different CPUs in the same platform.<br>
<p>
If the program is not multithreaded, and static analysis shows that a function is not re-entrant, then its return address (or a number to look up the return address) does not need to be on the stack at all.  It can be at a fixed location, making it harder for an attacker to overwrite, and saving some stack space too.<br>
<p>
Indeed, there's a case for saying that all re-entrant functions should need to be explicitly tagged as such by the programmer, since they need more care in writing.  If the function isn't tagged as re-entrant, and the compiler cannot statically prove that it can never be called by some chain starting from itself, then that's a compile-time warning or error.  On the other hand, if a function is never re-entrant, all its local variables can be allocated statically away from the stack.  Who knows, perhaps some optimizing compilers do this already.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 9:31 UTC (Thu)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/732496/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a cool idea, but I'm confused about two points.<br>
<p>
1. You say<br>
<font class="QuotedText">&gt; and the compiler cannot statically prove that it can never be called by some chain starting from itself</font><br>
<p>
AFAIK there will be plenty of situations where a function cannot be called through a chain starting from itself, but a static analysis cannot prove this, so the compiler will emit false positives (i.e. tell you that you need to tag the function when you should not). This is due to function pointers; static analyses typically over-approximate what concrete values function pointers might have at runtime. Analyses that have a more precise idea about function pointer addresses are typically very slow.<br>
<p>
Note also that the analysis would need to have the entire program at its disposal to determine the values of function pointers, while here we're talking about the compiler (which only has access to a single translation unit). There are tools like CBMC [1] that don't have much trouble with analyzing entire programs and serve as a drop-in replacement to GCC, and there has been some work [2] to the Clang Static Analyzer that would enable it to analyze the entire program at once (still in discussion), but these are both way beyond the capabilities of a regular compiler anyway. Alternatively, it could be done as a link-time optimization (well, it would be a link-time analysis, but the line between analysis and optimization is quite fine), as at link-time you have the whole program, though I don't know what the exact capabilities of LLVM and GCC's LTO are and whether this would be possible.<br>
<p>
2. I'm not sure what reentrancy has to do with this, would you mind elaborating?<br>
<p>
[1] <a href="http://www.cprover.org/cbmc/">http://www.cprover.org/cbmc/</a><br>
[2] <a href="https://reviews.llvm.org/D30691">https://reviews.llvm.org/D30691</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732534"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 13:41 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/732534/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's right, static analysis won't be able to show all cases where a function isn't re-entrant.  The programmer would have to annotate some functions with a tag to quieten the warning and would presumably add a comment with a human-readable explanation (or proof) of why it's OK.  Yes, analysis of the whole program as a unit is necessary -- don't compilers have whole-program optimization modes nowadays?<br>
<p>
After my first paragraph I went off on a separate idea which was that the stack could be avoided altogether if a function can only be executing 'once' -- it cannot call itself so it cannot appear twice in a call stack.  In that case you can set aside a static area of memory, which is read-write of course, but is physically separate from the stack and so perhaps less likely to be trampled in a typical stack smashing attack.  This might not really be a win, if it just means that memory trampling attacks against this static area become easier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732534/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor732501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 10:16 UTC (Thu)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/732501/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This suggests to go back to early Fortran model with no stack but static locations for return addresses unless the function is recursive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor732541"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 15:26 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/732541/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't this break the ABI and `dlsym` looking up and using that function? Or would this approach only be viable for static functions or functions going into executables?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732541/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732559"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 19:15 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/732559/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would only be viable for static functions whose addresses are not leaked (whether dlsym() counts as such a leak is questionable). Simply taking the function's address is probably enough to invalidate it, particularly given the existence of things like register_printf_function(), or, heck, atexit().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732559/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor732440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2017 20:15 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/732440/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wondered recently about how useful copying the return address to a local variable at the bottom (address-wise) of the frame and comparing them before returning would be as a defence technique.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 12:00 UTC (Thu)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/732509/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This still allows overwriting of the return address of the caller of the current function.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 12:07 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/732510/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This still allows overwriting of the return address of the caller of the current function.</font><br>
<p>
Yes, I realise that.  It is at least harder though as you have to avoid overwriting your own in the process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor732508"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 12:04 UTC (Thu)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/732508/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Lots of different solutions were proposed in comments.<br>
<p>
1. Xoring the return address stored in stack. (article)<br>
2. Allowing a function to return only to a finite number of places using an array of possible return addresses. (epa)<br>
3. Keeping return address in a global variable in the case the function is non-recursive. (epa)<br>
4. Duplicate a return address at bottom of stack frame. (michaeljt)<br>
<p>
Just for completeness I would like to say that another possible solution would be having two separate stacks. One for return addresses and for variables whose address is not taken. Another for variables whose address is taken.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732508/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 15:24 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/732537/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's also the way the Mill CPU is doing it where the CPU manages the call stack pointers for you and there's no access to them (except presumably through the debugger APIs, but I assume even that is read-only). Kind of like the split stack, but instead, it is just the way the CPU works.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732560"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 19:17 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/732560/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Intel has a similar thing they're calling 'shadow stacks'.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732560/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor732557"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 18:07 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/732557/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The dual-stack approach was merged into Clang.<br>
<p>
  <a href="http://dslab.epfl.ch/proj/cpi/">http://dslab.epfl.ch/proj/cpi/</a><br>
  <a href="http://clang.llvm.org/docs/SafeStack.html">http://clang.llvm.org/docs/SafeStack.html</a><br>
<p>
Though IIUC there are still some unresolved integration and interoperability issues involving threading, dynamic memory, etc, that make SafeStack undesirable to use long-term until those issues are resolved.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732557/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor732583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 22:18 UTC (Thu)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/732583/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Clang implementation works well when paired with proper integration in libc, but glibc doesn't have that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor733344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2017 13:29 UTC (Mon)
                               by <b>itvirta</b> (guest, #49997)
                              [<a href="/Articles/733344/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The dual-stack approach was merged into Clang.</font><br>
<p>
So, if I got that right, they make another software controlled stack for variables/arrays that get their pointers taken,<br>
and keep the rest in the usual hardware stack?<br>
<p>
<p>
I've sometimes wondered why CPUs don't implement a separate, protected, stack for the CALL/RETURN instructions.<br>
That should deal with all sorts of overwriting and adding return pointers, if the stack was made read-only or completely<br>
inaccessible to other instructions. But I don't know if there would be some prohibitive cost to that.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/733344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor733401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2017 18:40 UTC (Mon)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/733401/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
From Table 1 of the <a href="http://dslab.epfl.ch/pubs/cpi.pdf">Code-Pointer Integrity (2014) paper</a>:
</p>

<p><pre>
                   Safe Stack  CPS    CPI
-------------------------------------------
Average (C/C++)  |       0.0%   1.9%   8.4%
Median (C/C++)   |       0.0%   0.4%   0.4%
Maximum (C/C++)  |       4.1%  17.2%  44.2%
-------------------------------------------
Average (C only) |      -0.4%   1.2%   2.9%
Median (C only)  |      -0.3%   0.5%   0.7%
Maximum (C only) |       4.1%  13.3%  16.3%
-------------------------------------------
Table 1: Summary of SPEC CPU2006
performance overheads.
</pre></p>

<p>
Safe Stack is the dual-stack mechanism. CPS(weak) and CPI (strong) are for dealing with function pointers in heap data. 
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/733401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor733459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2017 16:20 UTC (Tue)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/733459/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe that *every* recent CPU instruction set does a separate return stack. Well, as far as I can tell RISC-V puts it in a register, then it is up to a function caller to save the "ra" register wherever it wants before making the call. It can save it to the stack, a different stack or a linked list, the processor doesn't care. Itanium was similar, return addresses were saved in registers, and the registers would overflow into a separate stack.<br>
<p>
If only people would stop relying on the x86 / amd64 ISA.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/733459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor733477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2017 18:32 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/733477/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
RISC-V sounds similar to ARMv8 AArch64, where (if I understand correctly) the "BLR" instruction branches and stores the return address in the X30 (LR) register, and the "RET Xn" instruction returns to the address stored in some register, and that's the only proper way to call a function. A non-leaf function can preserve X30 however it wants; usually it will push/pop X30 on the stack associated with the slightly magic SP register, but the push/pop instructions (store-and-decrement/load-and-increment) can use any register as the index, so I think you could create a separate control stack for approximately zero cost (just one more reserved register) to keep the frame pointers and return addresses away from all the "char surely_this_is_big_enough[256];" buffers and other local variables.<br>
<p>
(ARMv7/AArch32 is similar but more confusing, because there are lots of mostly-deprecated ways of returning by using PC as a destination register, and you usually push/pop LR/PC in the same instruction as all the other registers you want to preserve (whereas AArch64 can only push/pop a pair of registers at once), and the Thumb instruction encoding has lots of limitations, and there are only half as many registers as AArch64, so a separate control stack might be significantly more expensive there.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/733477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor733889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2017 22:16 UTC (Sat)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/733889/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The dual-stack method is also the basis of the Web Assembly ABI, which (via emscripten) is probably why it's in clang already.  Coming (or already in) a web browser near you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/733889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor732585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return-oriented programming defense from OpenBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2017 23:04 UTC (Thu)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/732585/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Windows also has a similar (and somewhat richer) set of ROP defenses:<br>
  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt637065">https://msdn.microsoft.com/en-us/library/windows/desktop/...</a>(v=vs.85).aspx<br>
Though there are IP issues in using some of this in Linux.<br>
<p>
Also, there is some evidence that these are reducing the use of ROP in exploits:<br>
  <a href="https://www.endgame.com/blog/technical-blog/rop-dying-and-your-exploit-mitigations-are-life-support">https://www.endgame.com/blog/technical-blog/rop-dying-and...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/732585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
