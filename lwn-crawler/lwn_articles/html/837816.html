        <!DOCTYPE html>
        <html lang="en">
        <head><title>epoll_pwait2(), close_range(), and encoded I/O [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/837816/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/837813/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/837816/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>epoll_pwait2(), close_range(), and encoded I/O</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 20, 2020</br>
           </div>
The various system calls and other APIs that the kernel provides for access
to files and filesystems has grown increasingly comprehensive over the
years.  That does not mean, though, that there is no need or room for
improvement.  Several relatively small additions to the kernel's
filesystem-related API are under consideration in the development
community; read on for a survey of some of this work.
<p>
<h4>Higher-resolution <tt>epoll_wait()</tt> timeouts</h4>
<p>
The kernel's "epoll" subsystem provides a high-performance mechanism for a
process to wait on events from a large number of open file descriptors.
Using it involves creating an epoll file descriptor with <a
href="https://man7.org/linux/man-pages/man2/epoll_create.2.html"><tt>epoll_create()</tt></a>,
adding file descriptors of interest with <a
href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><tt>epoll_ctl()</tt></a>,
then finally waiting on events with <a
href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html"><tt>epoll_wait()</tt>
or <tt>epoll_pwait()</tt></a>.  When waiting, the caller can specify a
timeout as an integer number of milliseconds.
<p>
The epoll mechanism was added during the 2.5 development series, and became
available in the 2.6 release at the end of 2003.  Nearly 20&nbsp;years ago,
when this work was being done, a millisecond timeout seemed like enough
resolution; the kernel couldn't reliably do shorter timeouts in any case.
In 2020, though, one millisecond can be an eternity; there are users who
would benefit from much shorter timeouts than that.  Thus, it seems it is
time for another update to the epoll API.
<p>
Willem de Bruijn duly showed up with <a
href="/ml/linux-kernel/20201116161001.1606608-1-willemdebruijn.kernel@gmail.com/">a
patch set</a> adding nanosecond timeout support to <tt>epoll_wait()</tt>,
but it took a bit of a roundabout path.  Since there is no "flags" argument
to <tt>epoll_wait()</tt>, there is no way to ask for high-resolution timeouts
directly. So the patch set instead added a new flag (<tt>EPOLL_NSTIMEO</tt>)
to <tt>epoll_create()</tt> (actually, to <tt>epoll_create1()</tt>, which
was added in 2.6.27 since <tt>epoll_create()</tt> also lacks a "flags"
argument).  If an epoll file descriptor was created with that flag set,
then the timeout value for <tt>epoll_wait()</tt> would be interpreted as
being in nanoseconds rather than milliseconds.
<p>
Andrew Morton, however, <a
href="/ml/linux-kernel/20201116120445.7359b0053778c1a4492d1057@linux-foundation.org/">complained</a>
about this API.  Having one system call set a flag to change how arguments
to a different system call would be interpreted was "<q>not very
nice</q>" in his view; he suggested adding a new system call instead.
After a bit of back and forth, that is what happened; the <a
href="/ml/linux-kernel/20201118144617.986860-1-willemdebruijn.kernel@gmail.com/">current
version of the patch set</a> adds <tt>epoll_pwait2()</tt>:
<p>
<pre>
    int epoll_pwait2(int fd, struct epoll_event *events, int maxevents,
                     const struct timespec *timeout, const sigset_t *sigset);
</pre>
<p>
In this version, the <tt>timeout</tt> is passed as a <a
href="https://elixir.bootlin.com/linux/v5.9.9/source/include/uapi/linux/time.h#L11"><tt>timespec</tt> 
structure</a>, which includes a field for nanoseconds.
<p>
There has been some discussion of the implementation of this system call,
but not a lot of comments on the API, so perhaps this work will go forward
in this form.  Your editor cannot help but note, however, that this system
call, too, lacks a "flags" argument, so the eventual need for an
<tt>epoll_pwait3()</tt> can be readily foreseen.
<p>
<h4><tt>close_range()</tt> — eventually</h4>
<p>
The <a href="/Articles/789023/"><tt>close_range()</tt></a> system call was
added in the 5.9 release as a way to efficiently close a whole list of file
descriptors:
<p>
<pre>
    int close_range(int first, int last, unsigned int flags);
</pre>
<p>
This call will close all file descriptors between <tt>first</tt> and
<tt>last</tt>, inclusive.  There is currently one
<tt>flags</tt> value defined: <tt>CLOSE_RANGE_UNSHARE</tt>, which causes the indicated
range of file descriptors to be unshared from any other processes (and does
<i>not</i> close them).
<p>
In <a
href="/ml/linux-kernel/20201118104746.873084-1-gscrivan@redhat.com/">this
patch set</a>, Giuseppe Scrivano adds another flag,
<tt>CLOSE_RANGE_CLOEXEC</tt>.  This flag will set the "close on
<tt>exec()</tt>" flag on each of the indicated file descriptors.  Once
again, <tt>close_range()</tt> does not actually close the files in this
case; it simply marks them to be closed if and when the calling process
does an <tt>exec()</tt> in the future.  This is, presumably, faster than
executing a loop and setting the flag with <a
href="https://man7.org/linux/man-pages/man2/fcntl.2.html"><tt>fcntl()</tt></a>
on each file descriptor individually.
<p>
The functionality seems useful, and there have not really been any
complaints about the API (there were some issues with the implementation in
previous versions of the patch set).  Given that <tt>close_range()</tt> is
taking on more functionality that does not involve actually closing files,
though, it seems increasingly clear that this system call is misnamed.
It has only been available since the 5.9 release on October&nbsp;11, so
there are not yet C-library wrappers for it in circulation.  So there
<i>is</i> time to come up with a better name for this system call, should
the desire to do so arise.
<p>
<h4>Encoded I/O</h4>
<p>
Some filesystems have the ability to compress and/or encrypt data written
to files.  Normally, this data will be restored to its original form when
read from those files, so users may be entirely unaware that this
transformation is taking place at all.  What if, however, somebody wanted
the ability to work with this "encoded" data directly, bypassing the
processing steps within the filesystem code?  Omar Sandoval has <a
href="/ml/linux-fsdevel/cover.1605723568.git.osandov@fb.com/">a patch
set</a> making that possible.
<p>
The main motivation for this work appears to be backups and, in particular,
the transmission of partial or full filesystem images with <a
href="/Articles/581558/">the Btrfs <tt>send</tt> and <tt>receive</tt>
operations</a>.  The whole point of using this mechanism is to create an
identical copy of a Btrfs subvolume on another device.  If the subvolume
is using compression, a <tt>send</tt> will currently decompress the data,
which must then be recompressed on the <tt>receive</tt> side, ending up in
its original form.  If there is a lot of data involved, this is a somewhat
wasteful operation; it would be more efficient to just transmit the
compressed data.
<p>
With this patch set applied, it becomes possible to read the compressed
and/or encrypted data directly and write it directly, with no intervening
processing.  The first step is to open the subvolume with the new
<tt>O_ALLOW_ENCODED</tt> flag.  The <tt>CAP_SYS_ADMIN</tt> capability is
needed to open a subvolume in this mode; imagine what could happen if an
attacker were to write corrupt compressed data to a file, for example.
Dave Chinner <a
href="/ml/linux-fsdevel/20190925225243.GF804@dread.disaster.area/">argued</a>
early on that corrupt data should just be treated as bad data and this
operation could be unprivileged, but that view did not win out.
<p>
Then, encoded data can be read or written using the <a
href="https://man7.org/linux/man-pages/man2/preadv.2.html"><tt>preadv()</tt>
and <tt>pwritev()</tt></a> system calls.  The new <tt>RWF_ENCODED</tt> flag
must be used to indicate that encoded data is being transferred.  A normal
invocation of these system calls takes an array of pointers to <tt>iovec</tt>
structures describing the buffers to be transferred; when encoded I/O is
being done, though, the first pointer instead refers to an instance of
the new <tt>encoded_iov</tt> structure type:
<p>
<pre>
    struct encoded_iov {
	__aligned_u64 len;
	__aligned_u64 unencoded_len;
	__aligned_u64 unencoded_offset;
	__u32 compression;
	__u32 encryption;
    };
</pre>
<p>
The <tt>len</tt> field must contain the length of this structure; it is
there in case new fields are added in the future.  The
<tt>unencoded_len</tt> and <tt>unencoded_offset</tt> fields describe the
portion of the file affected by this operation; the <tt>compression</tt>
and <tt>encryption</tt> fields contain filesystem-dependent values
describing the type of compression and encryption applied.  All other
pointers in the <tt>iovec</tt> array point to actual <tt>iovec</tt>
structures describing the data to transfer.
<p>
The patch set includes support for reading and writing compressed data from
a Btrfs filesystem.  There is also <a
href="/ml/linux-fsdevel/cover.1605723600.git.osandov@fb.com/">a follow-on
patch set</a> working this support into the <tt>send</tt> and
<tt>receive</tt> operations.  Benchmarks included there show a significant
reduction in bandwidth required to transmit the data, reduced CPU time
usage and, in some cases, reduced elapsed time as well.
<p>
This patch series has been through six revisions as of this writing; <a
href="/ml/linux-fsdevel/cover.1568875700.git.osandov@fb.com/">the first
version</a> was posted in September 2019.  Various implementation issues
have been addressed, and the work appears to be converging on something
that should be ready to merge soon.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Btrfs">Btrfs</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Epoll">Epoll</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Btrfs">Filesystems/Btrfs</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls-close_range">System calls/close_range()</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/837816/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor837969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2020 20:12 UTC (Fri)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/837969/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seriously, close_range() really deserves a rename if it is still possible to do so.<br>
<p>
And I can see the demand in the horizon not just for a single range, but for a set of ranges (or of bitmaps) if any operations it performs becomes attractive to do, e.g., on epoll sets :-)<br>
<p>
But yes, that way lies a cliff...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/837969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor837981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2020 21:56 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/837981/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Clearly we need to be able to provide an eBPF predicate function that returns true/false whether the given file descriptor needs to be closed or not!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/837981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2020 21:14 UTC (Sat)
                               by <b>gps</b> (subscriber, #45638)
                              [<a href="/Articles/838029/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s not actually a bad idea.<br>
<p>
Going further: rather than at syscall time, how about registering that eBPF to determine the fate of fds as an at-fork and/or at-exec time fd filter?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor841606"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2021 19:20 UTC (Sun)
                               by <b>Shabbyx</b> (guest, #104730)
                              [<a href="/Articles/841606/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wasn&#x27;t io_uring made for all this? What&#x27;s the advantage of close_range over io_uring?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/841606/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor841725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2021 10:19 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/841725/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They&#x27;re orthogonal APIs. You certainly could emulate close_range with io_uring, but that&#x27;s a lot more syscalls and a whole lot less error-checking.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/841725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor846413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2021 22:46 UTC (Tue)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/846413/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How about fcntl_range(int first, int last, int cmd, ...)<br>
<p>
It executes any fcntl command across the range of file descriptors, and also accepts a new F_CLOSE command (for the original purpose of the API)<br>
<p>
(not a kernel dev, but wanted to add some cents)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/846413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor837997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2020 1:54 UTC (Sat)
                               by <b>glenn</b> (subscriber, #102223)
                              [<a href="/Articles/837997/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      Perhaps epoll_pwait3() be used to implement something like Window's <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects(...,/*bWaitAll*/=1,...)</a> to wait until all file descriptors are ready (rather than just one)?
      
          <div class="CommentReplyButton">
            <form action="/Articles/837997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2020 9:35 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/838006/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m a bit confused about the point of that API, actually. My understanding is that epoll is generally used when waiting for the network, which is multiple orders of magnitude slower than making a syscall. So why can&#x27;t you just wait for them one at a time? You even have EPOLLONESHOT to make it properly atomic.<br>
<p>
(Nevertheless, I am surprised that epoll_pwait2() lacks a flags argument. I had thought that was a standard feature at this point.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2020 16:08 UTC (Sat)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/838018/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; why can&#x27;t you just wait for them one at a time?</font><br>
<p>
It&#x27;s a general-purpose API, the modernized equivalent of select() or poll(), used to wait for whatever interesting event happens next on any of several waitable objects in an event loop - which might indeed come from a network socket, but might equally come from an IPC channel (Wayland, X11, D-Bus, any other AF_UNIX socket, or a pipe), or from a communication channel between threads (eventfd or pipe-to-self). Some of these are slow anyway, but some are time-sensitive.<br>
<p>
If you are watching pollable fds A, B, C, you poll one at a time with a nonzero timeout, and pollable fd C is ready, then you won&#x27;t process the event from C until 2 timeouts later than you could have done, resulting in an unnecessary delay. This results in an incentive to set the poll timeout to be shorter than the intended application-level timeout, leading to the opposite problem: the process is woken up once per poll timeout period, even if nothing interesting has actually happened yet.<br>
<p>
The common state for a CPU- and power-efficient event loop should be that if the process is waiting for something interesting to happen (like the next X11 or Wayland event), then it&#x27;s mostly sleeping in epoll_wait() or similar, trusting the kernel to wake it up at an appropriate time; and if it&#x27;s waiting for one or more application-level timeouts (which might be short, like the time an animation needs to wake up to start drawing the next frame so that it will be finished in time, or long, like the time at which the app gives up hope of receiving a reply to a pending network operation or D-Bus call), then the timeout value that it gives to epoll_wait() or equivalent should be whichever of those application-level timeouts will happen soonest. This is how the GLib and Qt event loops work, for instance.<br>
<p>
If you&#x27;re trying to write an event loop that is capable of running a smooth animation at the refresh rate of a 60Hz screen, then the time between frames is less than 17ms, so I can imagine that the difference between one millisecond and the next does make a difference; if you&#x27;re trying to keep up with a 144Hz screen, then you get less than 7ms between frames.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2020 14:12 UTC (Sun)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/838042/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, sorry, perhaps you meant &quot;I don&#x27;t see the point of bWaitAll=1&quot; rather than &quot;I don&#x27;t see the point of high-resolution epoll_wait&quot;?<br>
<p>
If that, then I&#x27;m not sure I see it either.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2020 15:48 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/838044/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WFMO lets you wait for many different kinds of non-fd structures, in particular mutexes and semaphores. It&#x27;s a useful primitive for that (“wait until this file is ready and I have these two mutexes”), and one WINE has had great problems emulating in the past. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2020 21:16 UTC (Sun)
                               by <b>sbaugh</b> (guest, #103291)
                              [<a href="/Articles/838058/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The ability to wait for mutexes and semaphores is useful for sure, and epoll lacks it. But the WaitAll flag isn&#x27;t related to that, and shouldn&#x27;t be necessary for epoll, since one can just use edge-triggered mode and repeatedly epoll_wait until you&#x27;ve seen all the events you want to wait for.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2020 21:17 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/838062/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Will edge-triggered mode work correctly is one of the descriptors becomes ready between epoll() invocations?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838064"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2020 21:22 UTC (Sun)
                               by <b>sbaugh</b> (guest, #103291)
                              [<a href="/Articles/838064/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Will edge-triggered mode work correctly is one of the descriptors becomes ready between epoll() invocations?</font><br>
<p>
Yes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838064/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor838065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2020 21:24 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/838065/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But WaitAll allows you to take multiple mutexes efficiently and deadlock-free.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 23, 2020 6:45 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/838071/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We&#x27;re talking in circles. There are two different APIs here:<br>
<p>
- Windows WaitForMultipleObjects: Has a WaitAll option, can wait for both mutexes and file handles (and various other things) in the same call.<br>
- Linux epoll: No WaitAll option. Mutexes are acquired one by one with futex(2) or more commonly pthread_mutex_lock(3) (which uses futex internally). epoll has nothing to do with futex and can&#x27;t acquire anything that resembles a mutex. It waits on file descriptors, and that&#x27;s it.<br>
<p>
Adding a WaitAll option to epoll would not help with mutexes, because you can&#x27;t use epoll to acquire mutexes in the first place. You would need to also add the ability to acquire mutexes. But most of the complexity of mutexes lives in userspace (in NTPL) and epoll is a kernel interface. So that&#x27;s probably infeasible without some kind of userspace abstraction layer. In practice, it would probably make more sense to add this functionality to NTPL than to add it to epoll.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 23, 2020 6:48 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/838072/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(And of course I misspelled NPTL. Oh well.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor838278"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2020 4:56 UTC (Wed)
                               by <b>glenn</b> (subscriber, #102223)
                              [<a href="/Articles/838278/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I can point to two patterns that would benefit from epoll_wait() with bWaitAll.
<p>
(1) You want to have a thread that services a UDP socket, processing one datagram per unit time.  A clean way to do this would be to pair the UDP socket file descriptor with a timerfd file descriptor.  Using epoll_wait() and bWaitAll, this thread would only wake when a datagram is available and enough time has elapsed.  Is there an equally clean way that avoids trivial wakeups?
<p>
(2) Consider a real-time application with a message-passing task graph software architecture that may or may not span multiple compute nodes (e.g., <a href="https://www.ros.org/">ROS</a>).  Each node in the task graph is backed by a thread.  These threads should only execute when data is available on all input file descriptors.  epoll_wait() with something like bWaitAll would allow these threads from waking before all inputs are satisfied.  Furthermore, my understanding is that this capability is necessary if threads are scheduled by SCHED_DEADLINE.  Irregular wake-up patterns can cause thread budget reclamation to kick in before the thread has done any real work (see “2.2 Bandwidth reclaiming” in Documentation/scheduler/sched-deadline.txt).
      
          <div class="CommentReplyButton">
            <form action="/Articles/838278/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 25, 2020 9:11 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/838283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (1) You want to have a thread that services a UDP socket, processing one datagram per unit time. A clean way to do this would be to pair the UDP socket file descriptor with a timerfd file descriptor. Using epoll_wait() and bWaitAll, this thread would only wake when a datagram is available and enough time has elapsed. Is there an equally clean way that avoids trivial wakeups?</font><br>
<p>
The network RTT is multiple orders of magnitude slower than a context switch, unless you have crazy bad swapping *and* the other node is just across the room. So my position is that trivial wakeups don&#x27;t matter in this case. They&#x27;re effectively noise.<br>
<p>
<font class="QuotedText">&gt; (2) Consider a real-time application [...]</font><br>
<p>
Does epoll respect real-time scheduling in the first place? If a thread goes to sleep, it necessarily relinquishes the CPU. And, once it has done so, what exactly is the kernel expected to do about it, if anything? I tend to think of real-time scheduling as protecting CPU-bound threads from CPU-stealing by other threads, but epoll certainly isn&#x27;t a CPU-bound interface.<br>
<p>
<font class="QuotedText">&gt; may or may not span multiple compute nodes [...] Furthermore, my understanding is that this capability is necessary if threads are scheduled by SCHED_DEADLINE. Irregular wake-up patterns can cause thread budget reclamation to kick in before the thread has done any real work (see “2.2 Bandwidth reclaiming” in Documentation/scheduler/sched-deadline.txt).</font><br>
<p>
If you want this to actually work across multiple nodes, you need to be tolerant of variances in network latency (unless you&#x27;re building an entirely real-time network... which seems like it would be really hard to do), and (again) those are way bigger than some minor CPU context switching. If you don&#x27;t want this to work across multiple nodes, then perhaps you should be using more elaborate userspace synchronization primitives rather than fooling around with loopback addressing and epoll.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor838005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">And still no flags</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2020 7:30 UTC (Sat)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/838005/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given how often they&#x27;ve been bitten by this, I&#x27;m surprised to see epoll_pwait2 also has no flags.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor838008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">And still no flags</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2020 10:01 UTC (Sat)
                               by <b>awww</b> (guest, #122021)
                              [<a href="/Articles/838008/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, but this time it&#x27;s finally the one true interface that will suit all possible purposes, so there really is no need. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor844617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">And still no flags</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2021 23:53 UTC (Sat)
                               by <b>andyc</b> (subscriber, #1130)
                              [<a href="/Articles/844617/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A few years ago epoll_pwait1() was proposed[0] that had both flags _and_ nanosecond resolution...<br>
<p>
[0]: <a href="https://lwn.net/Articles/633422/">https://lwn.net/Articles/633422/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/844617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor838277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2020 23:47 UTC (Tue)
                               by <b>ppisa</b> (subscriber, #67307)
                              [<a href="/Articles/838277/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
epoll_pwait2() is useless for real-time and control if clockid_t clock_id cannot be specified tosynchronize activity with walltime (realtime) and monotonic. Monotonic is a must for all dynamic systems control applications. It worth to add flag for selection between time interval and absolute timeout value as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839600"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2020 10:29 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/839600/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
epoll_* currently use CLOCK_MONOTONIC for everything. It would be handy if they supported absolute monotonic times. And I can see an argument for supporting CLOCK_MONOTONIC_RAW and CLOCK_BOOTTIME. But I don&#x27;t think CLOCK_REALTIME makes sense: it can jump around, so relative times aren&#x27;t necessarily well-defined (!), and they can&#x27;t even represent all absolute times (e.g. leap seconds).<br>
<p>
Also note that timerfd already does support all these variations, so in a pinch you can stick one of those in your epoll set.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839600/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor839602"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2020 10:37 UTC (Thu)
                               by <b>ppisa</b> (subscriber, #67307)
                              [<a href="/Articles/839602/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks, you are right that I forgot timerfd, which is solution for non-critical variants. Real time has reason as the time base, if you mix RT control with some &quot;people time&quot;/wall time alarms, shifts changes, railroad timetables etc....<br>
<p>
Absolute would be nice, but it only one more system call and often virtual one, so no significant problem. And if you have two time queues for one e-poll, one MONOTONIC and one REALTIME, then it is better at least one move to timerfd to resolve mutual time shifts correctly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839602/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor838939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">epoll_pwait2(), close_range(), and encoded I/O</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2020 11:30 UTC (Fri)
                               by <b>brauner</b> (subscriber, #109349)
                              [<a href="/Articles/838939/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The functionality seems useful, and there have not really been any complaints about the API (there were some issues with the implementation in previous versions of the</font><br>
<font class="QuotedText">&gt; patch set). Given that close_range() is taking on more functionality that does not involve actually closing files, though, it seems increasingly clear that this system call is</font><br>
<font class="QuotedText">&gt; misnamed. It has only been available since the 5.9 release on October 11, so there are not yet C-library wrappers for it in circulation. So there is time to come up with a </font><br>
<font class="QuotedText">&gt; better name for this system call, should the desire to do so arise.</font><br>
<p>
Unfortunately I don&#x27;t think we can change the name anymore. There are already users including Python, systemd, LXC, LXD, and other large codebases and also the name is identical between FreeBSD and Linux since Kyle and I coordinated on this syscall after FreeBSD picked it up from us. But CLOSE_RANGE_CLOEXEC is essentially like a deferred close so I&#x27;d consider this closing file descriptors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/838939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
