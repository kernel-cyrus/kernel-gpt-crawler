        <!DOCTYPE html>
        <html lang="en">
        <head><title>Zero-copy networking [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/726917/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/726818/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/726917/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Zero-copy networking</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 3, 2017</br>
           </div>
In many performance-oriented settings, the number of times that data is
copied puts an upper limit on how fast things can go.  As a result,
zero-copy algorithms have long been of interest, even though the benefits
achieved in practice tend to be disappointing.  
Networking is often performance-sensitive and is definitely dominated by
the copying of data, so an interest in zero-copy algorithms in networking
comes naturally.  A set of patches under review makes that capability
available, in some settings at least.
<p>
When a process transmits a buffer of data, the kernel must format that data
into a packet with all of the necessary headers and checksums.  Once upon a
time, this formatting required copying the data into a single kernel-space
buffer.  Network hardware has long 
since gained the ability to do scatter/gather I/O and, with techniques like
<a href="/Articles/9123/">TCP segmentation offloading</a>, the ability to
generate packets from a buffer of data.  So support for zero-copy
operations has been available at the hardware level for some time.
<p>
On the software side, the contents of a file can be transmitted without
copying them through user space using the <a
href="http://man7.org/linux/man-pages/man2/sendfile.2.html"><tt>sendfile()</tt></a>
system call.  That works well when transmitting static data that is in the
page cache, but it cannot be used to transmit data that does not come
directly from a file.  If, as is often the case, the data to be transmitted
is the result of some sort of computation — the application of a template
in a content-management system, for example — <tt>sendfile()</tt> cannot be
used, and zero-copy operation is not available.
<p>
The <a href="/Articles/726353/"><tt>MSG_ZEROCOPY</tt> patch set</a> from
Willem de Bruijn is an attempt to make zero-copy transmission available in
such settings.  Making use of it will, naturally, require some changes in
user space, though.
<p>
Requesting zero-copy operation is a two-step process.  Once a socket has
been established, the process must call <tt>setsockopt()</tt> to set the
new <tt>SOCK_ZEROCOPY</tt> option.  Then a zero-copy transmission can be
made with a call like:
<P>
<pre>
    status = send(socket, buffer, length, MSG_ZEROCOPY);
</pre>
<P>
One might wonder why the <tt>SOCK_ZEROCOPY</tt> step is required.  It comes
down to a classic API mistake: the <tt><a
href="http://man7.org/linux/man-pages/man2/send.2.html">send()</a></tt>
system call doesn't check for unknown flag values.  The two-step ritual is
thus needed to avoid breaking any programs that might have been
accidentally setting <tt>MSG_ZEROCOPY</tt> for years and getting away with it.
<p>
If all goes well, a transmission with <tt>MSG_ZEROCOPY</tt> will lock the
given buffer into memory and start the transmission process.  Transmission
will almost certainly not be complete by the time that <tt>send()</tt>
returns, so the process must take care to not touch the data in the buffer
while the operation is in progress.  That immediately raises a question:
how does the process know when the data has been sent and the buffer can be
used again?  The answer is that the zero-copy mechanism will place a
notification message in the error queue associated with the socket.  That
notification can be read with something like:
<p>
<pre>
    status = recvmsg(socket, &amp;message, MSG_ERRORQUEUE);
</pre>
<p>
The socket can be polled for an error status, of course.  When an "error"
packet originating from <tt>SO_EE_ORIGIN_ZEROCOPY</tt> shows up, it can be
examined to determine the status of the operation, including whether the
transmission succeeded and whether it was able to run in the zero-copy
mode.  These status packets contain a sequence number that can be used to
associate them with the operation they refer to; the fifth zero-copy
<tt>send()</tt> call will generate a status packet with a sequence number
of five.  These status packets can be coalesced in the kernel, so a single
packet can report on the status of multiple operations.
<p>
The mechanism is designed to allow traditional and zero-copy operations to
be freely intermixed.  The overhead associated with setting up a zero-copy
transmission (locking pages into memory and such) is significant, so it
makes little sense to do it for small transmissions where there is little
data to copy in the first place.  Indeed, the kernel might decide to use
copying for a small operation even if <tt>MSG_ZEROCOPY</tt> is requested
but, in that case, it must still go to the extra effort of generating the
status packet.  So the developers of truly performance-oriented programs
will want to take care to only request zero-copy behavior for large
buffers; just where the cutoff should be is not entirely clear, though.
<p>
Sometimes, zero-copy operation is not possible regardless of the buffer
size.  For example, if the network interface cannot generate checksums, the
kernel will have to perform a pass over the data to do that calculation
itself; at that point, copying the data as well is nearly free.  Anytime
that the kernel must transform the data — when IPSec is being used to
encrypt the data, for example — it cannot do zero-copy transmission.  But,
for most straightforward transmission cases, zero-copy operation should be
possible.
<p>
Readers might be wondering why the patch does not support zero-copy
reception; while the patch set itself does not address this question, it is
possible to make an educated guess.  Reading is inherently harder because
it is not generally known
where a packet is headed when the network interface receives it.  In
particular, the interface itself, which must place the packet somewhere, is
probably not in a position to know that a specific buffer should be used.
So incoming packets end up in a pile and the kernel sorts them out
afterward.  Fancier interfaces have a fair amount of programmability, to
the point that zero-copy reception is not entirely infeasible, but it
remains a more complex problem.  For many common use cases (web servers,
for example), transmission is the more important problem anyway.
<p>
As was noted in the introduction, the benefits from zero-copy operation are
often less than one might hope.  Copying is expensive, but the setup
required to avoid a copy operation also has its costs.  In this case, the author
claims that a simple benchmark (<a
href="https://github.com/HewlettPackard/netperf"><tt>netperf</tt></a>
blasting out data) runs 
39% faster, while a more realistic production workload sees a 5-8%
improvement.  So the benefit for real-world systems is not huge, but it may
well be enough to be worth going for on highly-loaded systems that transmit
a lot of data.
<p>
The patch set is in its fourth revision as of this writing, and the rate of
change has slowed considerably.  There do not appear to be any fundamental
objections to its inclusion at this point.  For those wanting more details,
<a href="https://netdevconf.org/2.1/papers/netdev.pdf">this paper [PDF]</a> by De
Bruijn is worth a read.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-Performance">Networking/Performance</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/726917/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor727054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 0:35 UTC (Tue)
                               by <b>mikemol</b> (guest, #83507)
                              [<a href="/Articles/727054/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That works well when transmitting static data that is in the page cache, but it cannot be used to transmit data that does not come directly from a file. If, as is often the case, the data to be transmitted is the result of some sort of computation — the application of a template in a content-management system, for example — sendfile() cannot be used, and zero-copy operation is not available.</font><br>
<p>
Is there no mechanism which can be used to wrap a chunk of memory in a file descriptor? I would think that an incredibly useful and powerful abstraction. If I can wrap a file with a block of memory via mmap, why couldn't I do the reverse?<br>
<p>
That's not to say this work doesn't have value, but still...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 3:47 UTC (Tue)
                               by <b>lkundrak</b> (subscriber, #43452)
                              [<a href="/Articles/727060/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is memfd_create(2).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor727062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 7:15 UTC (Tue)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/727062/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Mmmmmm....memfd?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor727335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">fd &lt;-&gt; memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 22:16 UTC (Thu)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/727335/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could open /dev/zero and mmap it MAP_PRIVATE. This wouldn't give you a fd corresponding to an arbitrary memory region but you could setup this memory in advance to create the content into it.  Zero-copy with sendfile should be possible with this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor727055"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 0:38 UTC (Tue)
                               by <b>mikemol</b> (guest, #83507)
                              [<a href="/Articles/727055/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, wouldn't zero-copy reception effectively be RDMA?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727055/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 8:00 UTC (Tue)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/727063/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With remote DMA, the sender of the packet puts the memory address of the receiver's buffer into the packet, and the receiving interface just writes it there. This requires that the receiver has told the sender in advance what a valid buffer address would be (so this cannot work with most existing protocols), and this is, of course, completely unsafe if you cannot trust the sender.<br>
<p>
In theory, it would be possible to configure the interface to put packets from a specific source address and port and to a specific destination address and port into a specific buffer. The article mentions that such fancy interfaces might exist.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 8:36 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/727065/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's pretty much how userspace network stacks work these days. To replicate it, a client will have to set up some kind of a lockless ring buffer and a way for the kernel to wake up the the client. But the API won't look like sockets anymore.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 1:10 UTC (Thu)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/727240/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's still possible to put a sockets API on such a ring buffer based interface but any approach I know of will then require for receive...a copy out of the ring buffer. I think that, ultimately, we need recognize that we need a new set of APIs for zero-copy operations. You use those if you want maximum performance, otherwise you use the familiar sockets interface, which is layered on the zero copy APIs.<br>
<p>
By "new", I just mean new for Linux. There are candidate APIs out there that should be considered. The HPC guys are kind of nuts about shipping data, so they have at least one possibility, though I haven't used them. I've heard comments implying that their environment doesn't mandate the level of security a more general Linux deployment might need but this is, again, hearsay.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor752754"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2018 14:48 UTC (Wed)
                               by <b>mikemol</b> (guest, #83507)
                              [<a href="/Articles/752754/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think zero-copy should be possible with a sockets API.<br>
<p>
You still use the ring buffer, but you only drain the buffer when there are read() calls on the socket. Send ACKs only for the packets whose data have been consumed by read() calls.<br>
<p>
This further allows you to combat bufferbloat at the application layer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/752754/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor727056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 2:04 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/727056/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The last time I discussed zero-copy networking with a kernel person (this was in the context of NetBSD's UVM, which worked automatically, given certain preconditions), it was explained to me that the benefit available plummets when you go from one to two-or-more CPUs.  The unintuitive reason was that flipping the page tables, as UVM did, invalidates caches on other CPUs, which more than eats up any savings from not copying.  Anyway, chip designers put enormous efforts into making sequential copying fast. It's the single most heavily optimized operation in any system, so it is stiff competition.<br>
<p>
So, this scheme, that requires just a little more cooperation from user space to avoid re-mappings, seems like the minimum needed to make the process useful at all. (That approximates the definition of good engineering.) A practical saving of 5% isn't much for most of us, but it would pay salaries of dozens of engineers at a Facebook or Netflix.  Indeed, it would be negligent of each of them not to have implemented something like this, so I count it likely that many have cobbled-up versions of this in-house that work just well enough for their purposes.  This work was done at Google; probably they, too, had a cobbled-up version that worked just well enough, which then took several times more engineering effort to clean up for publication and upstreaming.  The negligent among the other big shops get the benefit for free, but only years later, and the rest (Google included) can delete their hard-to-maintain cobbled-up versions.<br>
<p>
Probably the biggest benefits of this work go to (often big) customers of small vendors who haven't the engineering staff to devote to faking it, and who in any case don't control what kernel their code runs on.  The small shops can reasonably be asked to have their code use the feature when running on a kernel that supports it.  Google, meanwhile, will have reasonable hope that, eventually, companies they buy already use the feature, and the code that comes with them doesn't need to be jimmied to use a cobbled-up, proprietary version.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 17:55 UTC (Tue)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/727112/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have heard that the CPU utilization on the megasize infrastructures averages around 5%.  I don't have a citation for that, and have no idea how close that number is to reality.  However, if that is in the ballpark, a 5% syscall savings probably won't have a major TCO impact for most applications. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 21:46 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/727130/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is legitimate to bring up numbers, but I doubt that the monetary value of performance is measured by TCO alone, or by average CPU utilization.  There are service level agreements, and peak-traffic latency, and potential income.  How many ads can be delivered, and displayed for the required amount of time before the user clicks past, at 5:30 PM?  How frequently does the streaming video skip, at 6:30 PM, and how does that affect subscription renewal rates?  How many product pages can be presented per potential customer per minute, and how does the conversion rate (from looking to spending money) vary with how long they have to wait to see the next page?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor727137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2017 3:47 UTC (Wed)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/727137/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>5% gains are worthwhile. CPUs get faster by about 5% a year from process improvements alone. So a 5% gain obtained from software can delay a hardware upgrade by a year. For which you can calculate a TCO value.</p>

<p>The more worrying thought is that semiconductor process miniaturisation seems to be coming to an end: each node shrink is successively later. At some point in the late-2020s future the major source for throughput improvement will move to software. Ie: assume a 5nm process is economic around 2024, allow two generations of CPU design tuning, after that the "CPU" barrel is empty of economic performance improvements. We can still look to other hardware components for performance enhancement -- particularly in the way hardware hangs together -- but such system-level design change usually requires enabling software in the operating system and in key applications. In short, this patch is a look into the future of computer performance.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/727137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2017 14:05 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/727788/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Transistor miniaturisation has pretty much peaked ... The width of a conducting line, and the insulator between it, can now be measured in atoms, and it's not many of them ...<br>
<p>
The biggest problem with shrinking dies further is now quantum leakage, which will only grow. In order to make chips faster, they are now having seriously to contend with the speed of light, which is why chips are spreading more and more into the realms of 3d.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor727529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2017 10:47 UTC (Tue)
                               by <b>abo</b> (subscriber, #77288)
                              [<a href="/Articles/727529/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Netflix does have a zero-copy sendfile() in their FreeBSD based CDN. They also (partially) implemented TLS in the kernel.<br>
<p>
<a href="https://medium.com/netflix-techblog/protecting-netflix-viewing-privacy-at-scale-39c675d88f45">https://medium.com/netflix-techblog/protecting-netflix-vi...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor727067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 12:18 UTC (Tue)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/727067/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux people should keep an eye on what Microsoft do. Microsoft had zero copy networking for ages. I believe they had had I/O completion ports (queues where notifications that I/O operation is completed are pushed) even before Linux got epoll support.<br>
<p>
In Microsoft they realized that locking pages in memory is expensive. And in Windows 8 they come up with an API called Registered I/O. It requires an application to register buffers in advance. Then I/O operations just use these registered buffers and therefore don't need to lock any pages.<br>
<p>
I believe in Linux kernel people should just skip designing zero-copy operations altogether and just implement Registered I/O.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727121"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2017 18:49 UTC (Tue)
                               by <b>einstein</b> (guest, #2052)
                              [<a href="/Articles/727121/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good point - In this case, Linux devs ought to look at borrowing worthwhile features even from crappy OSes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727121/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor741880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2017 22:23 UTC (Tue)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/741880/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Windows I/O stack has always felt lightyears ahead of Linux to me.<br>
<p>
Just because several components are tied together in one product with annoying marketing, doesn't mean they all suck. I'm sure the kernel I/O developers had nothing to do with the start screen.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/741880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor727149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2017 13:17 UTC (Wed)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/727149/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know Windows, but this is exactly what I was thinking.  Register the buffers ahead of time to save the overhead of pinning and unpinning the pages over and over again.  See also: SCSI generic (drivers/scsi/sg.c) mmap()ed I/O.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor727157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2017 14:35 UTC (Wed)
                               by <b>clameter</b> (subscriber, #17005)
                              [<a href="/Articles/727157/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux has had zero copy networking for more than 10 years. Use the RDMA subsystem to send messages. The RDMA subsystem can even receive messages(!!!).  The RDMA subsystem can not only perform remote DMA operations but also send and receive datagrams.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727333"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 21:52 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/727333/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It has even worked for userland for a while. HAProxy successfully makes use of splice() to perform zero-copy transfers between sockets (receive AND send).<br>
<p>
Also it seems to me that this send(MSG_ZEROCOPY) is not much different from doing a vmsplice().<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727333/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727513"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2017 0:00 UTC (Tue)
                               by <b>klempner</b> (subscriber, #69940)
                              [<a href="/Articles/727513/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The entire point of MSG_ZEROCOPY is the notification that the kernel is done so the memory can be unpinned and potentially freed/reused. This isn't a problem for HAProxy's socket to splice pipe to socket doesn't have that problem because in that case the memory never has a userspace address.<br>
<p>
The fundamental problem with application to vmsplice pipe to TCP socket is that you don't know when the pages in question are done and can be freed/modified, and if you modify them you're liable to start, say, leaking crypto keys out to the network if that memory gets reused before the TCP stack is done with it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727513/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor727225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2017 21:27 UTC (Wed)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/727225/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Async I/O a la completion ports shouldn't be news to anyone, given that this was the standard means of doing I/O on VMS in the 1980s.  The downsides are that's it's tricker to get right (there's a lot more opportunity for creating bugs in the application code), and that reaping the benefits means receiving data in an interface that looks essentially nothing like sockets.<br>
<p>
Those are prices that must be paid for completely maximizing throughput in high transaction count scenarios, but they're an awkward price for most users.<br>
<p>
The registered I/O tweak is relatively recent and somewhat informative however, driven as it is by modern hardware requirements instead of ancient design concerns.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor727143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2017 6:37 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/727143/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Reading is inherently harder because it is not generally known where a packet is headed when the network interface receives it.</font><br>
<p>
Interruptions is another reason why receiving is "harder"/more expensive than sending. As usual, predicting the future is very difficult.<br>
<p>
<font class="QuotedText">&gt; With remote DMA, the sender of the packet puts the memory address of the receiver's buffer into the packet, and the receiving interface just writes it there. This requires that the receiver has told the sender in advance...</font><br>
<p>
For high performance, not just RDMA but message passing interfaces also involve a certain amount of "telling in advance", at least for large messages.<br>
<p>
The socket API sucks, really not designed for high performance: "I'm receiving, send me whatever whenever and I'll manage somehow!" Very slowly.<br>
<p>
Last I checked I wasn't even possible for user space to tell the kernel: "I'm expecting to recv() 2kbytes, don't wake me up and waste our time until you got at least that". BTW I suspect many applications would break if IP fragmentation was real.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 3:56 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/727256/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have seen IP fragmentation in the wild.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 10:42 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/727267/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IP fragments are how some applications send larger-than-MTU sized application-layer messages.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor727317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 17:32 UTC (Thu)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/727317/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Last I checked I wasn't even possible for user space to tell the kernel: "I'm expecting to recv() 2kbytes, don't wake me up and waste our time until you got at least that".</font><br>
<p>
Although I agree that having this type of function in kernel would be good, I believe the benefits of it are small compared to what we have now. Let me explain. There is 2 options: either the chunk of data you expect is small in size or it is big.<br>
<p>
In case it is small. It is likely fit one packet or a few packets with a small interval between them. In this case by the time the program is woken up tailing packets have already arrived.<br>
<p>
In case it is big. The program is unlikely to buffer all the data in memory. Instead it is likely to write this data to disk/handle it somehow as it is coming. And in this case waking up the program is what you want.<br>
<p>
So the only use case for this function would be a program that receives large amount of data buffering it in memory until the last byte arrives.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 17:43 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/727321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In this case by the time the program is woken up tailing packets have already arrived.</font><br>
<p>
This fully qualifies the definition of a race condition.<br>
<p>
On one hand there's the performance question which you addressed. On the other hand there's the fact that some applications don't bother coding a retry loop around the recv() call. Combine this with the race condition above and let the fun begin.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor734411"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zero-copy networking</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2017 7:38 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/734411/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Last I checked I wasn't even possible for user space to tell the kernel: "I'm expecting to recv() 2kbytes, don't wake me up and waste our time until you got at least that".</font><br>
<p>
recv(2) says it was added in Linux 2.2 :-) (see MSG_WAITALL)<br>
<p>
Unfortunately this doesn't help if you're using non-blocking sockets.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/734411/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
