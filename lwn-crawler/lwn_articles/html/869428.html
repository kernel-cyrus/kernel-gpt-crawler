        <!DOCTYPE html>
        <html lang="en">
        <head><title>More Rust concepts for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/869428/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/869382/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/869428/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>More Rust concepts for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 20, 2021</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2021-Kangrejos">Kangrejos</a>
</div>
The <a href="/Articles/869145/">first day</a> of the <a
href="https://kangrejos.com/">Kangrejos</a> (Rust for Linux) conference
introduced the project and what it was trying to accomplish; <a
href="/Articles/869317/">day&nbsp;2</a> covered a number of core Rust
concepts and their relevance to the kernel.  On the third and final day of
the conference, Wedson Almeida Filho delved deeper into how Rust can be
made to work in the Linux kernel, covered some of the lessons that have been
learned so far, and discussed next steps with a number of kernel
developers. 
<p>
Almeida started by noting that he is not a Rust developer and does not feel
that the language is perfect; he does believe, though, that it can solve
some problems in the kernel.  He works as an Android platform
security-team engineer and has been looking for ways to improve that
platform — specifically, to reduce its attack surface.  Rust can do that,
he said; it also helps with correctness and provides an expressive type
system with features that C cannot match.
<p>
<h4>Ownership</h4>
<p>

<a href="/Articles/869625/"><img
src="https://static.lwn.net/images/conf/2021/rust/WedsonAlmeidaFilho-sm.png" alt="[Wedson Almeida
Filho]" title="Wedson Almeida Filho" class="rthumb"></a>

An important Rust concept, he continued, is data ownership; every value in
a Rust program has exactly one owner.  That ownership will move around as
the program executes, but will never be shared.  When the owner of an
object goes out of scope, that object will be freed.  Ownership is
exclusive, but there are still ways to move data around, of course; in Rust
that is done with references.  A mutable reference allows the holder to
modify the data; mutable references are exclusive, in that no other
references to the object in question may exist.  Shared references,
instead, are non-exclusive, and are read-only.
<p>
There are, it seems, a couple of exceptions to the above rules.  Almeida
mentioned briefly the idea of <a
href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior
mutability</a> but did not get into the details of it.  Rust also supports
raw pointers, but only in unsafe code.
<p>
One result of Rust's ownership rules is that there are no data races in
code written in safe Rust.  To have a data race, you must have at least two
CPUs accessing shared data in an unsynchronized manner, with at least one
writer.  Since mutable references are exclusive, this situation simply
cannot come about.
<p>
These rules also give the compiler the ability to optimize around code that
it cannot directly see.  For example, in code that looks like:
<p>
<pre>
    *x = 32
    some_function()
    return *x
</pre>
<p>
The compiler can safely just return 32.  There cannot be aliases for the
variable <tt>x</tt>, so there is no way that <tt>some_function()</tt> can
have modified its value.
<p>
So how do the ownership rules apply to kernel code?  Almeida brought up the
example of the <tt>private_data</tt> field found in many kernel structures;
it allows subsystems to attach their own data to a structure managed by
higher levels of the system.  That field is typically a
<tt>void&nbsp;*</tt> pointer that is cast to the appropriate type when it
is used; this is not safe usage by Rust standards.  As an example, consider
<a
href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L920"><tt>struct
file</tt></a>, which is used in the kernel to represent an open file.
<p>
In Rust code, a developer would write an <tt>open()</tt> method that
creates some sort of internal state — the sort of data that would normally
be attached via <tt>private_data</tt>.  That state will be returned to the
caller, and ownership of that state object is returned as well.  If, for
example, user space calls <tt>ioctl()</tt> on that open file, the handler
will get a shared reference to the state object; this must be shared, since
these calls can be made concurrently.  When, instead, the file is closed,
the <tt>release()</tt> method will get ownership of the state, which it
will then drop.  All of this can be done using Rust's type discipline to
provide type and concurrency safety.
<p>
<h4>Device IDs, locks, and more</h4>
<p>
Another example is the device-ID tables found throughout the driver
subsystem.  These tables contain an array of IDs and an untyped, optional
argument; they must be null-terminated.  Almeida has written a <a
href="/Articles/863459/">PL061 (GPIO)
driver</a> in Rust to mirror <a 
href="https://elixir.bootlin.com/linux/latest/source/drivers/gpio/gpio-pl061.c">the
C driver</a> found in the kernel and created a new device-ID-table
abstraction to go with it.  Developers must decide what the type of the
optional data will be, and all data specified must match that type.  There is
no need to null-terminate the list, eliminating a common error made by
driver authors.  As a result, the whole mechanism is type-safe and easier
to use.
<p>
Locking is the cause of a lot of complexity and confusion in the kernel.
In C code, locks are typically declared as structure fields, and it is
often not clear exactly what data any given lock is protecting.  In Rust,
instead, data is associated directly with the lock that protects it, with
the result that there is no way to write code that accesses that data
without first acquiring the lock — at least, not if the developer wants the
compiler to accept it.  All of the checking can be done at compile time. 
<p>
Almeida briefly mentioned the vulnerability known as <a
href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26708">CVE-2021-26708</a>,
which was an exploitable race condition in the mainline kernel caused by
accessing data prior to 
acquiring the lock that protects it.  Rust, he said, would have prevented
this vulnerability from happening.  The definition of the lock would have
ensured that the relevant data could not be touched without first acquiring
that lock.  But what happens if a developer doesn't realize that a lock is
needed in the first place?  In this case Rust's ownership rules would save
the situation, since attempts to modify the unprotected data would fail
with the wrong type of reference.
<p>
Laurent Pinchart jumped in to say that he likes the idea of bundling data
with the lock that protects it.  But he wondered about the cases where the
developer knows that the lock is not needed; initialization code is one
such case.  Seemingly, if the compiler knows that there can only be one
reference to the object in question, the lock is not necessary; this can
happen when the object has just been created, for example.  If all else
fails, Almeida said, developers can always use the "unsafe escape hatch".
<p>
Another abstraction to look at is file descriptors; these are created by
first acquiring a reference to the underlying <tt>file</tt> structure, then
allocating the descriptor number itself.  If that allocation fails, code
must remember to drop the file reference.  Rust's lifecycle management
makes that error-handling happen automatically, with a lot less boilerplate
code.  The sort of "<tt>goto&nbsp;out;</tt>" pattern often seen in kernel
code is just not necessary in Rust.
<p>
<a
href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15791">CVE-2019-15971</a>,
Almeida said, came about as the result of a failure to increment a file's
reference count; that led to a use-after-free vulnerability.  In Rust it is
not possible to make this kind of mistake without getting a friendly
diagnostic from the compiler.
<p>
Returning to error paths, Almeida repeated that most of the complex and
error-prone error handling seen in kernel code just vanishes when using
Rust.  For the most part, objects are simply cleaned up when they go out of
scope, with no explicit handling needed at all.  For cases where the
developer needs more control, a <a
href="https://docs.rs/scopeguard/1.1.0/scopeguard/"><tt>scopeguard</tt></a>
object can be used. 
This object is initialized with the appropriate error-handling information;
if all goes well and the error-handling code is not needed, its
<tt>dismiss()</tt> method can be called.  Otherwise,
if that object goes out of scope, it will perform the needed error
handling.
<p>
A few other kernel abstractions were covered, including task structures,
red-black trees, and access to memory-mapped I/O areas.  The point that
Almeida was trying to make should be clear by now, though.  The Rust
language is capable of handling kernel-level programming in a way that is
inherently safer than doing the same tasks in&nbsp;C.  Were there, he
concluded, any questions or objections?
<p>
<h4>Discussion</h4>
<p>
Julia Lawall started by asking about things that
<i>don't</i> work well in Rust — where are the sticking points?  Almeida
answered that, in Rust, all objects are 
movable in memory, which can be problematic for self-referential data
structures. The solution is <a
href="https://doc.rust-lang.org/std/pin/index.html">pinning</a>, but that
requires writing unsafe code.  A lot of unsafe code in existing Rust
drivers has its origin in this problem, he said.  Another issue is the way
that Rust requires all data to be initialized, which can be a problem with
mutexes in particular.  Fixing that is mostly a matter of finding the right
abstractions.
<p>
Pinchart questioned the incremental approach being taken by the Rust
developers — an issue that came up a number of times in the discussion.  He
said that the right approach is to lock the kernel subsystem maintainers in
a room, require them to learn Rust, and to provide a great deal of help

<a href="/Articles/869626/"><img
src="https://static.lwn.net/images/conf/2021/rust/day3-disc-sm.png" alt="[Discussion]"
title="Discussion" width=250 height=197 border=0 hspace=3 vspace=3
align="right"></a>

to those maintainers during the transition.  If a maintainer is blocked by
a Rust-related problem, they should be able to count on immediate help to
fix it.  Otherwise, he said, the Rust developers are going to encounter a
huge amount of pushback.
<p>
Ojeda questioned whether pushback was really going to be a problem; nobody
is taking away the ability to write a driver in C, he said.  Pinchart
replied that, at some point, maintainers may not accept those drivers.
Ojeda said that could maybe happen in five or ten years, not before.  It is
necessary to say that kernel developers will be expected to learn some
Rust, he said; the safe subset is not that hard.  He did allow that unsafe
Rust is rather harder; worries about undefined behavior return, and the
documentation is not as good.
<p>
In another frequently heard concern, Pinchart pointed out that kernel
developers have to be able to work all over the source tree; it's a rare
developer who never looks outside of one subsystem.  That will make it
hard to minimize the impact of Rust in the kernel early on; a surprising
number of developers are likely to encounter it.  Ojeda said that the
plan is only to introduce Rust in subsystems where the maintainer knows the
language, but Pinchart answered that expecting that other developers will
not have to care about that Rust code is wrong.  Developers are almost
certainly going to have to work with unsafe Rust as well.  Mark Brown added
that there will probably have to be some sort of flag day tied to the
introduction of Rust, after which maintainers will simply have to know the
language to some degree.
<p>
Almeida asked how many Rust-knowing kernel developers would need to exist
before this transition might begin; Jonathan Cameron answered: "a lot".
I jumped in with some experience from the introduction of
the ReStructured Text language for documentation; that process took longer
than might have been expected, ran into some fierce (and ongoing)
resistance, and is still not complete.  It would not have succeeded to the
degree it has without acceptance by a significant part of the development
community.  The introduction of Rust, which is a vastly more complex task,
will not have an easier time of it; working to build wide acceptance is not
optional.  Pinchart said that most developers
seem to appreciate the value of Rust now, but many of them worry about the
cost of bringing it into the kernel.
<p>
Ojeda said that the Rust for Linux developers need to either convince
enough developers of the value of Rust so that
Linus Torvalds will bless the change, or else simply
end the discussion.  He looked forward to the upcoming discussions at the
Linux Plumbers Conference and Kernel Summit as a way to bring more
developers into the process.  I expressed some worries about relying too
heavily on a blessing from Torvalds; that is a necessary condition but far
from sufficient.
<p>
Greg Kroah-Hartman said that he likes the idea of introducing Rust into
kernel development, but said that this work has a long way to go yet.
Device drivers (which is what the Rust developers are initially targeting)
have to interact with many parts of the kernel, including the driver model,
sysfs, and various other subsystems; the Rust to enable that interaction
has not yet 
been written.  There are going to be social, political, and technical
issues around the introduction of Rust, and not even the technical issues
have been taken care of yet.  That said, he commended the Rust developers
for the progress they have made so far.
<p>
As the session ran out of time, Kroah-Hartman said that it would not be
possible to require developers to write in Rust for at least five years.
Pinchart asked whether anybody has thought about how many developers the
community is willing to lose in this transition; the actual number will
almost certainly not be zero.  Ojeda concluded things by saying that the
process for getting Rust into the kernel is the most important aspect, and
that the next step for that will be the discussions at the Linux Plumbers
Conference.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Kangrejos-2021">Kangrejos/2021</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/869428/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor869874"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 17:53 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/869874/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Seemingly, if the compiler knows that there can only be one reference to the object in question, the lock is not necessary; this can happen when the object has just been created, for example. If all else fails, Almeida said, developers can always use the &quot;unsafe escape hatch&quot;. </font><br>
<p>
Sure, but since Rust prefers to just return initialized data instead of the `obj* p = malloc(…); obj_init(p);` pattern, you get `obj::new()` (passing in allocator info is certainly possible here). This method can just initialize whatever it needs to before putting it under the mutex. What kind of deferred init would still be necessary with better resource management patterns available?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869874/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor869871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 17:57 UTC (Mon)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/869871/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Seemingly, if the compiler knows that there can only be one reference to the object in question, the lock is not necessary</font><br>
<p>
To clarify, this is not some special rust compiler magic. It&#x27;s just a normal consequence of two parts of the Mutex implementation:<br>
<p>
 - If you have an exclusive (&amp;mut) reference to a lock, you can use the get_mut() function to get the inner contents of the lock without any locking.<br>
<p>
 - You only create the lock with new() once have a value for it to wrap. You can do any initializations you want before that at no extra cost due to the familiar return value optimizations<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 23:15 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/869887/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, if you find yourself with exclusive ownership of a Mutex, you can call into_inner() to take ownership of the contents without taking the lock.<br>
<p>
There probably are some weird locking patterns that Rust Mutex can&#x27;t express but it&#x27;s not easy to come up plausible ones out of thin air. Probably some conditional stuff where a lock is only needed under certain dynamic conditions. Of course you could probably still write a custom Mutex implementation that encapsulates those conditions in a nice way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 23:35 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/869888/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Notably, the API could be something like (purely a sketch):

<pre>
/// A token which indicates that it is safe to access data 
pub struct SafeToken(());

impl SafeToken {
    pub fn new(proof: SafeTokenProof) -&gt; Self {
        assert!(proof.verify()); // Or run unconditionally.
        Self(())
    }
}

impl&lt;T&gt; KMutex&lt;T&gt; {
    pub fn mut_proven(&amp;self, _: SafeToken) -&gt; &amp;mut T {
        todo!()
    }
}
</pre>

In reality, something along the lines of <a href="https://docs.rs/ghost-cell/0.2.2/ghost_cell/index.html">GhostCell/GhostToken</a> is probably wanted to tie the given token to a given mutex instance, but it really depends on the situation.



      
          <div class="CommentReplyButton">
            <form action="/Articles/869888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor869901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2021 9:31 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/869901/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The main locking pattern that Mutexes don&#x27;t model is where a single mutex protects many objects, which sometimes has better performance than extremely fine-grained locking. RCU also requires some custom smart pointers (such as <a href="https://github.com/bonzini/rust-rcu-qemu/blob/master/src/cell.rs">https://github.com/bonzini/rust-rcu-qemu/blob/master/src/...</a>).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2021 0:22 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/869949/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Normally you&#x27;d reorganize your data in that case so that the data protected by the mutex are all under one object. I guess for the kernel you can&#x27;t always do that.<br>
<p>
You may be able to use something similar to qcell to handle it --- <a href="https://docs.rs/qcell/0.4.3/qcell/index.html">https://docs.rs/qcell/0.4.3/qcell/index.html</a>. Basically have a mutex that hands out an exclusively-owned access token, and the access token can be used to &quot;lock&quot; multiple protected data items without actually taking a lock.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869950"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2021 0:23 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/869950/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see mathstuf already suggested that, oops.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869950/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor869966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fixing developers instead of the tools?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2021 9:18 UTC (Wed)
                               by <b>cagrazia</b> (guest, #124754)
                              [<a href="/Articles/869966/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If all else fails, Almeida said, developers can always use the &quot;unsafe escape hatch&quot;.</font><br>
...turns out that we need to fix the developers after fixing the tools they use.. :) <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fixing developers instead of the tools?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2021 11:35 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/869967/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Nah. <code>unsafe</code> is perfectly valid tool in Rust. After all hardware itself is “unsafe” thus <b>someone</b> have to deal with it.</p>

<p>Only Rust have a culture of providing safe abstractions on top of <code>unsafe</code> code. That is: if you tried <b>really</b> hard yet all existing safe abstractions don't work for you then it's time to invent a new one, not to time go and use <code>unsafe</code> everywhere.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/869967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor870127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fixing developers instead of the tools?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2021 13:33 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/870127/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Also, as a code reviewer, <tt>unsafe</tt> is a big red flag that I need to pay attention to the details here, whereas in C, you can sneak UB past me. That helps continue the culture of "encapsulate <tt>unsafe</tt> in safe interfaces", because your reviewers don't like reviewing unsafe Rust.


      
          <div class="CommentReplyButton">
            <form action="/Articles/870127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor870538"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Fixing developers instead of the tools?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2021 13:53 UTC (Sun)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/870538/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, and that is why unsafe is so hard, because you have not only to write code that has no undefined behavior, but also to write an interface that prevents any user with any mistakes from possibly causing undefined behavior, even if they do things that you document shouldn&#x27;t be done.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870538/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor870128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2021 13:34 UTC (Thu)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/870128/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; how many developers the community is willing to lose in this transition; the actual number will almost certainly not be zero</font><br>
<p>
How many developers the community may gain in this transition? The actual number will almost certainly not be zero<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor870244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2021 19:48 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/870244/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Certainly it&#x27;s easy to imagine that if writing safe Rust can produce a working kernel driver for relatively simple hardware that&#x27;s a member of an existing class (e.g yet another serial driver, or a DVB decoder device), there are going to be some people who are pretty mediocre programmers and whose C programming in particular isn&#x27;t up to this job, but can write an acceptable Rust driver.<br>
<p>
In my opinion the best targets are cases where multiple distinct hardware implementations exist without any good reason. Think entry-level PCI network cards in the late 1990s. There&#x27;s no reason for so many different vendors to make a 100Mbps PCI Ethernet card that has essentially the same features as the competitors but requires its own driver, but that&#x27;s what happened, and you can imagine that there&#x27;s nothing interesting (potentially requiring unsafe and deep kernel knowledge or new subsystem code) in the NE2k driver compared to the 3Com one so that the work to make the 19th and 20th of these drivers is not actually the application of arcane wisdom kernel programmers might pride themselves in, but mostly rote work copying from manufacturer data sheets and a little bit of &quot;suck it and see&quot; when the data sheet is needlessly ambiguous. Rust is going to make that practical for patient non-experts whose sole advantage over the existing Linux maintainers is that they own the hardware they&#x27;re writing a driver for so they can iterate over the &quot;suck it and see&quot; aspects very rapidly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor870259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2021 20:34 UTC (Thu)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/870259/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; mostly rote work copying from manufacturer data sheets and a little bit of &quot;suck it and see&quot; when the data sheet is needlessly ambiguous.</font><br>
<p>
Though I&#x27;m not sure the data sheet for the NatSemi DP83820 mentions the thing where the transmitter interrupt is unreliable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor871255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2021 18:13 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/871255/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote> How many developers the community may gain in this transition? The actual number will almost certainly not be zero</blockquote>

I would not bet on that.   From a different field: There are those who lobby for bike paths, because car drivers claim they will switch to bicycles if only the bike paths were there.  A few decades later, there are lots of bike paths, but there are still many car drivers and few bike riders (e.g. in Stevenage with bike paths that are the wet dream of bike path fans, the modal split of bikes dropped  IIRC from 16% in 1964 to 3% in 2015, with a 68% car modal split (high for a European city)).  And if you ask the bike riders, they have not switched from cars; even the fans of bike paths could not name a single person who switched from car to bike because of bike paths when I asked them; by contrast, a collegue of mine stopped bike riding because of bike paths (bike path fans started with insults when I mentioned that).

<p>Back to topic: What happened to OS projects in Rust?  If Rust makes an OS project attractive to many highly competent developers, one of these projects should be on the way to overtake Linux, no?  Admittedly there is also the draw of contributing to the most widely-used kernel, but still, the BSDs survive despite not having the most widely-used kernel and not being written in Rust.



      
          <div class="CommentReplyButton">
            <form action="/Articles/871255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2021 21:24 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/871290/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What happened to OS projects in Rust?</font><br>
<p>
New OS projects usually burble along in obscurity no matter how brilliant the people working on them are, and getting a new OS to the point where people whose primary goal isn&#x27;t &quot;develop the OS&quot; can usefully use it is a remarkably labour-intensive task, especially if you need all-new device drivers because your design goals preclude the use of existing C or C++ driver code.<br>
<p>
<font class="QuotedText">&gt; the BSDs survive despite not having the most widely-used kernel and not being written in Rust.</font><br>
<p>
Within their respective niches, the BSDs have well-established user bases. The inertia of users is a powerful thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor871348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2021 9:32 UTC (Thu)
                               by <b>peter-b</b> (subscriber, #66996)
                              [<a href="/Articles/871348/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  in Stevenage with bike paths that are the wet dream of bike path fans</font><br>
<p>
This is some extremely subtle trolling, right?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2021 13:08 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/871368/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      It was not intended as trolling.  My statement is based on Carlton Reid's articles (<a href="http://roadswerenotbuiltforcars.com/stevenage/">longer from 2013</a>, <a href="https://www.theguardian.com/cities/2017/sep/19/britains-1960s-cycling-revolution-flopped-stevenage">shorter from 2017</a>, the pictures shown there and what bike path fans usually argue for: Stevenage has a network of bike paths that is separate but equal from the car infrastructure, on a separate level to avoid the problems that many other bike path networks have with crossings between bit path traffic and other traffic.  This network was planned by a bike path fan who had the advantage of a relatively clean slate.  If the result does not produce the predicted switch from car to bike, but instead a switch from bike to car, this looks like a good falsification of the theory that people will switch from car to bike if you build them bike paths.  BTW, I have now found the modal split numbers: 13% bike in 1964, 2.7% bike in 2013, 68.8% car in 2011.

<p>If you have a different perspective, I would be interested in reading about that.


      
          <div class="CommentReplyButton">
            <form action="/Articles/871368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2021 10:24 UTC (Mon)
                               by <b>Klavs</b> (guest, #10563)
                              [<a href="/Articles/872476/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a rel="nofollow" href="https://supercykelstier.dk/about/">https://supercykelstier.dk/about/</a> &lt;- in Denmark - they invest heavily in &quot;cycle superpaths&quot; - and they are great - it makes it faster to reach anywhere in town by bike, than by car (almost - at a few off-peak hours - it can be faster by car - but parking costs are NOT low - and parking my bike is free so :)<br>
<p>
quote from article &quot;A socio-economic analysis of the cycle superhighways in the Capital Region of Denmark from 2018 shows that the investment in cycle infrastructure and cycle superhighways has many economic benefits. By investing in the total network of 45 routes (in 2018), the cycle superhighways are estimated to give a socio-economic surplus of 765 million euro – due in part to improved health, fewer days of sick leave and less time wasted in traffic jams.&quot;<br>
<p>
I don&#x27;t know how they calculated that and I haven&#x27;t gone looking for a 2021 cycle traffic count.. I know they do count bikes.. and there&#x27;s a LOT in Copenhagen that bike.. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2021 10:31 UTC (Mon)
                               by <b>Klavs</b> (guest, #10563)
                              [<a href="/Articles/872477/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So it does indeed seem that the article you link to is correct.. IF its just as quick to drive and free to park - people take the car.<br>
Which is WHY it its NOT free to park in copenhagen (as the air polution from cars is a huge problem - it really shouldn&#x27;t be either IMHO) and the traffic jams are extensive in peak hours too.. so it actually typicly IS faster to bike anything &lt;15km than doing it by car.<br>
<p>
Those 2 factors are clearly driving biking in copenhagen - and the fact that the cycle bike paths are soo good as they are - increases the cycle trafic even more.. But it starts with bikers getting a benefit from biking (typicly cost per trip or time) for most.<br>
<p>
Enough of bikepaths here though - the article does not seem to really relate as much, except for the fact that you need a similar incentive, to get developers to want to learn Rust :)<br>
<p>
I do think, that if it ends up being &quot;fairly easy&quot; to write safe drivers - in Rust - so the benefits starts showing clearly in CVE statistics - that will probably start helping.. So the more stats the better :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">More Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2021 17:31 UTC (Mon)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/872569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Concerning the transition to Rust in the kernel, it may win some developers and it may lose some developers; the Stevenage experience shows that the outcome can be negative (this time not because of a more attractive alternative, but because working in two languages may reduce the attractiveness of kernel development). 

<p>Concerning Copenhagen, according to <a href="http://tems.epomm.eu/search_city.php">TEMS</a> Copenhagen had 33% car modal split in 2014 (most recent for Copenhagen), so cars are still quite attractive (by comparison, my home town Vienna had 28% in 2014, and Vienna has very car-centric politics).  Concerning the study, I would not be surprised if a lot of the computations are based on wishful thinking (which is very frequent in anything involving bike paths).

<p>Concerning traffic jams, bike path fans recommended <a href="https://www.youtube.com/watch?v=996Hg2GeUvo">this video</a> to show how great Copenhagen is for cyclists.  Looking at the traffic coming from the bridge, I see that Copenhagen is great for cars: A wide, bike-free roadway that allows car drivers who want to drive straight ahead to go at full speed when they arrive at the crossing at green and wait at most one red phase otherwise.  By contrast, bicyclists have to bunch up on a narrow bike path and often have to wait a full cycle or more (it's not clear how far onto the bridge the bike traffic jam extends at times).  Of course, there must be a reason why there are so few cars that cross that bridge, but it's obviously not the bike paths.



      
          <div class="CommentReplyButton">
            <form action="/Articles/872569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
