        <!DOCTYPE html>
        <html lang="en">
        <head><title>Losing the magic [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/915163/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/916498/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/915163/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Losing the magic</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 5, 2022</br>
           </div>
The kernel project is now more than three decades old; over that time, a
number of development practices have come and gone.  Once upon a time, the
use of "magic numbers" to identify kernel data structures was seen as a
good way to help detect and debug problems.  Over the years, though, the
use of magic numbers has gone into decline; <a
href="/ml/linux-kernel/cover.1668128257.git.nabijaczleweli@nabijaczleweli.xyz/">this
patch set</a> from Ahelenia Ziemia≈Ñska may be an indication that the reign
of magic numbers may be reaching its end.
<p>
A magic number is simply a specific constant value that is placed within a
structure, typically as the first member, to identify the type of that
structure.  When structures are labeled in this way, in-kernel
debugging code can check the magic number and raise the alarm if the
expected value is not found, thus detecting problems related to type
confusion or data
corruption.  These numbers can also be located in hexadecimal data dumps
(stack contents, for example) to identify known data structures.
<p>
The use of magic numbers in the kernel appears to have had its origin in
the filesystem code, where it was initially used to identify (and verify)
the superblock in the disk image.  Even the 0.10 kernel release included <a
href="https://elixir.bootlin.com/linux/0.10/source/fs/super.c#L131">a test
against <tt>SUPER_MAGIC</tt></a> (<tt>0x137f</tt>) to verify that the boot
disk was, indeed, a Minix filesystem.  Other filesystems came later,
starting with the "first extended" (ext), which used <tt>0x137d</tt> for
its <tt>EXT_SUPER_MAGIC</tt> value in the 0.96c release in July 1992.
<p>
In the 0.99 release (December 1992), the <a
href="https://elixir.bootlin.com/linux/0.99/source/net/tcp/sock.h#L155"><tt>sk_buff</tt>
structure</a> that is still used in the networking
subsystem to hold packets was rather 
smaller than <a
href="https://elixir.bootlin.com/linux/v6.1-rc5/source/include/linux/skbuff.h#L728">it
is now</a>, but it did gain a <tt>magic</tt> field to identify 
the queue a packet was expected to be in.  Toward the middle of 1993, the
0.99.11 release acquired an updated <a
href="https://elixir.bootlin.com/linux/0.99.11/source/lib/malloc.c"><tt>kmalloc()</tt>
implementation</a> that sprinkled magic numbers around as a debugging aid.
That release, incidentally, is also the one where an attempt was made to
use C++ to build the kernel; that only lasted until 0.99.13, a couple of
months later.
<p>
The use of magic numbers in the kernel grew slowly after that.  The 1.1.13
release, in May 1994, added <a
href="https://elixir.bootlin.com/linux/1.1.13/source/MAGIC">a file called
<tt>MAGIC</tt></a> in the top-level directory to keep track of the various
numbers in use; it listed eight such numbers.  This file was, incidentally,
nearly the first documentation file in the kernel beyond the basic
installation information; the kernel would not gain a directory for
documentation until 1.3.22 in 1995.  In this new file, Ted Ts'o wrote:
<p>
<blockquote class="bq">
	It is a *very* good idea to protect kernel data structures with
	magic numbers.  This allows you to check at run time whether (a) a
	structure has been clobbered, or (b) you've passed the wrong
	structure to a routine.  This last is especially useful ---
	particlarly when you are passing pointers to structures via a
	void&nbsp;* pointer.  The tty code, for example, does this
	frequently to pass
	driver-specific and line discipline-specific structures back and
	forth.
</blockquote>
<p>
The file went on to ask developers to follow this practice for future
additions to the kernel.  (For the curious: the typo of "particularly"
lasted until 1.1.42 in August 1994; otherwise that text persists to this
day). 
<p>
The 1.3.99 release saw the movement of <tt>MAGIC</tt> to <a
href="https://elixir.bootlin.com/linux/1.3.99/source/Documentation/magic-number.txt"><tt>Documentation/magic-number.txt</tt></a>,
perhaps as part of a general cleaning-up prior to the imminent 2.0 release.
Some developers, at least, had clearly taken Ts'o's advice; there were, at
this point, 21&nbsp;entries in that file.  The <a
href="https://elixir.bootlin.com/linux/2.2.0/source/Documentation/magic-number.txt">2.2.0
version</a> (January 1999) held 51&nbsp;entries.  Magic numbers appeared to
be an established kernel-development practice.
<p>
The 2.4.0 release came almost exactly two years later.  <a
href="https://elixir.bootlin.com/linux/2.4.0/source/Documentation/magic-number.txt">The
2.4 version of <tt>magic-number.txt</tt></a> was, except for one small
change, identical to the 2.2 version; no new magic numbers had been added.
That doesn't necessarily reflect a change in development practices so much
as the eternal habit of letting documentation go out of date.  Some effort
went into updating the file during the 2.5 development series, and the <a
href="https://elixir.bootlin.com/linux/v2.6.0/source/Documentation/magic-number.txt">2.6.0
version</a> contained an even 100 magic numbers.  For the rest of the 2.6.x
series, though, the only changes were small tweaks and the removal of a
couple of obsolete entries; <tt>Documentation/magic-number.txt</tt> began
to shrink.
<p>
In fact, no additions to that file have been made in the entire Git
history.  In 2016 the file was converted to the RST format and moved into
the nascent development-process manual.  It mostly sat idle and unnoticed
until earlier this year, when the file began to shrink; the <a
href="https://elixir.bootlin.com/linux/v6.1-rc5/source/Documentation/process/magic-number.rst">6.1 version of
<tt>Documentation/process/magic-number.rst</tt></a> is down to
14&nbsp;entries.  Where has the magic gone?
<p>
This change is the result of Ziemia≈Ñska's work, which is aimed at removing
this file entirely; the current patch set describes it as "<q>a low-value
historical relic at best and misleading cruft at worst</q>".  In that
series, Ziemia≈Ñska systematically deletes the final entries, often removing
the associated structure fields and magic-number checks in the code, until
the file is empty; the <a
href="/ml/linux-kernel/93e66d80680c52e8d04763fb2d86f841c69e32c9.1668128257.git.nabijaczleweli@nabijaczleweli.xyz/">final
patch</a> in the series simply deletes it.  Chances are that it will not be
missed.
<p>
There is no clear point where the development community made a collective
decision to move away from the magic-number practice; it just sort of faded
away.  The are probably a few reasons behind this change.  The kernel
community has, for many years now, tried to use type-safe interfaces rather
than passing <tt>void</tt> pointers around, making it less likely that the
wrong structure type will be passed into a function.  Developers spend less
time staring at hex dumps of data, preferring more structured output,
tracepoints, and interactive debuggers as ways of tracking down problems.
Debugging features in the kernel's memory allocators mean that many sorts
of memory-corruption issues will be caught directly.  Magic numbers 
are just not as helpful as they once were.
<p>
Magic numbers will still have their place; they still, for example, can
help filesystem code be confident that it is dealing with the correct type
of filesystem image.  Even there, though, the use of checksums for on-disk
data structures should provide better protection against many types of
problems. But, for the most part, kernel development has lost some of the
magic it once had; as often happens, it slipped away when nobody was paying
attention.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-Patterns">Development model/Patterns</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/915163/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor916995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 16:39 UTC (Mon)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/916995/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I initially thought this was something to do with the magic file used by the "file" utility.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 19:03 UTC (Mon)
                               by <b>stop50</b> (subscriber, #154894)
                              [<a href="/Articles/917010/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Me too, probably because users have more touch with the magic file than kernel imternals.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor916996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 17:01 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/916996/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  The kernel community has, for many years now, tried to use type-safe interfaces rather than passing void pointers around, making it less likely that the wrong structure type will be passed into a function.</span><br>
<p>
Some "void *" statistics would be great. They can be really hard to avoid in generic code and so-called "private data"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 14:15 UTC (Tue)
                               by <b>sima</b> (subscriber, #160698)
                              [<a href="/Articles/917107/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Tons of places have moved to container_of and struct embedded, and away from void*. It's not really more typesafe when you try to get things intentionally wrong, but it does help a lot with silly mistakes and "oops wrong offset" screwups.<br>
<p>
But yeah relative amount of void* might be an interesting metric to see whether the conjecture that the kernel moved towards more type safety actually holds.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 17:41 UTC (Wed)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/917266/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As an example of the kernel moving in the unsafe direction, the kernel has lots of special printk format specifiers for specific pointer types that are not typechecked by the compiler.<br>
<p>
<a href="https://docs.kernel.org/core-api/printk-formats.html">https://docs.kernel.org/core-api/printk-formats.html</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2022 10:53 UTC (Thu)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/917355/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like a good task for sparse?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor918894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2023 18:31 UTC (Mon)
                               by <b>tabberson</b> (guest, #162965)
                              [<a href="/Articles/918894/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can you please explain what you mean by "struct embedded"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/918894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor918942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2023 9:56 UTC (Tue)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/918942/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <pre>
struct foo {
        ...
        struct bar embedded;
        ...
};
</pre>

If you have a pointer to the "embedded" member of type "struct bar", you can convert it to a pointer to the containing "struct foo" using the
<a href="https://elixir.bootlin.com/linux/v6.1-rc7/source/include/linux/container_of.h">container_of()</a> macro.



      
          <div class="CommentReplyButton">
            <form action="/Articles/918942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor917000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 20:58 UTC (Mon)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/917000/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the innovation is really the macros that enforce type safety before discarding the type information. There are still plenty of structures that store a function with an argument and a pointer that has to match, where the structure can't validate them (and different instances of the structures don't match each other), but the macros for creating the structures ensure that, still having the type information, you could call the function with the argument without getting a type error. I don't think it was common knowledge until that time frame that it was possible to tell a C compiler "generate any warnings or errors for this expression, but don't generate code to evaluate it". (Or maybe it's still not common knowledge, but the kernel has all the macros needed to do it, and they're commonly used.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 21:40 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/917023/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Out of curiosity, what is the trick? Using sizeof?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 22:06 UTC (Mon)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/917024/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the original was (0 ? (*fn)(arg) : store_callback(fn, arg)), and using enough optimization that the direct call won't be generated. Once people demonstrated the benefit and possibility of doing this sort of testing, a later innovation was the sizeof trick to make the code really explicitly execute as "discard a small integer", which will be nothing following even unoptimized code generation (since even minimal register allocation will just discard the code).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor917022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 21:42 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917022/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Or maybe it's still not common knowledge, but the kernel has all the macros needed to do it, and they're commonly used.</font>

<p>It would be interesting to ask about that random C developers. While the answer is kinda ‚Äúobvious‚Äù (every C programmer I ever knew used <code>sizeof</code> at one point or another and it's pretty obvious that if you ask for <code>sizeof</code> of some object there are no need to actually evaluate an expression that produces that object, you only need to know type of that expression), yet I wouldn't be surprised to see lots of developers who just don't realize they have all the tools they need in a basic course of C.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/917022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 5:01 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/917039/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bear in mind, many of the people using C are not coming from a compsci or software engineering background, but from an embedded systems background. For them, C is like old-school javascript: You write ~10 lines of code to make the monkey dance (except it's, like, an animatronic monkey or some such thing, wired up to an Arduino). There is no operating system and you probably don't have a full libc, or possibly any libc. While I'm sure these are very smart people, it is not necessarily reasonable to expect them to know about the intricacies of compile-time vs. runtime evaluation, because that's simply not relevant to the work they're trying to do. They may never even use sizeof, because malloc is not typical in these environments (everything is statically allocated).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 13:59 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917101/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <p>These guys are extra hopeless. Not because they couldn't learn proper discipline, but because they don't want to learn it.</p>

<p>Thankfully these days even tiny microcontrollers are powerful enough to run high-level languages, even <a href="https://en.wikipedia.org/wiki/CircuitPython">python</a>.</p>

<p>There are absolutely no need to [try to] teach them C.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/917101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 14:07 UTC (Tue)
                               by <b>andi8086</b> (guest, #153876)
                              [<a href="/Articles/917104/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is only your personal point of view. I appreciate the simplicity and readability of C very much. Although I DO USE sizeof :D and I certainly do no monkey dances, except maybe in hardware projects... According to your definition I am SEMI-Extra-Hopeless. In environments like bare metal, you need a lot of discipline, otherwise you don't understand your own code a few years later... or everything will just crash. It seems to me you lack a lot of experience!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 14:38 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/917109/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bare-metal embedded (not to mention the actual hardware) requires a _lot_ more discipline than most other software categories.<br>
<p>
On average, you'll find embedded and hw folks a lot more vigorous when it comes to testing/validation, as fixing bugs after things have shipped can be prohibitively expensive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917115"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 15:24 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917115/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Bare-metal embedded (not to mention the actual hardware) requires a _lot_ more discipline than most other software categories.</font>

<p>It requires <b>entirely different</b> discipline, that's the issue.</p>

<font class="QuotedText">&gt; On average, you'll find embedded and hw folks a lot more vigorous when it comes to testing/validation, as fixing bugs after things have shipped can be prohibitively expensive.</font>

<p>Yes, but more often than not they do bazillion tests and conclude that it's enough to be confident that thing actually works as it should.</p>

<p>Often they are even right: hardware is hardware, it often limits input to your program severely (which makes things like buffer overflow impossible simply because laws of physics protect you). And hardware is rarely behaves 100% like specs say it would behave thus without testing math models wouldn't save you.</p>

<p>Software is thoroughly different: adversary may control inputs so well and do things which are so far beyond anything you may even imagine that all these defenses built by folks with hardware experience and their tests are sidesteped without much trouble.</p>

<p>You need math, logic and rigorous rules to make things work. It's really interesting how attitude of linux kernel developers have slowly shifted from hardware mindset to software mindset when fuzzing guys found more and more crazy ways to break what they have thought was well-designed and tested piece of code.</p>

<p>Now they are even trying to use Rust as a mitigation tool. It would be interesting to see whether it would actually work or not: linux kernel sits between hardware and software worlds which means that pure math, logic and rigorous rules are not enough to make it robust.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/917115/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917124"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 17:18 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/917124/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In other words, you're saying we need more rigorous/detailed specifications for software.<br>
<p>
...And you're the one going on about folks asking for O_PONIES?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917124/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 17:58 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/917126/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And if I've understood the "higher maths" correctly - I'm more a chemist/medical guy by education - the O_PONY I'm asking for is that signed multiplication be a group. Any group, I don't care, so long as when it doesn't overflow the result is what naive arithmetic would expect.<br>
<p>
Because, on the principle of least surprise, it's a very unpleasant surprise to discover that multiplying two numbers could legally result in the computer squirting coffee up your nose ... :-)<br>
<p>
Is there really anything wrong in asking for the result of computer operations to MAKE SENSE? (No, double-free and things like that - bugs through and through - clearly can't make sense. That's just common sense :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 18:20 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917128/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; And if I've understood the "higher maths" correctly - I'm more a chemist/medical guy by education - the O_PONY I'm asking for is that signed multiplication be a group. Any group, I don't care, so long as when it doesn't overflow the result is what naive arithmetic would expect.</font>

<p>Doesn't look that way to me. Compiler developers <b>already</b> acquiesced to these demands and provided flag which makes <code>clang</code> and <code>gcc</code> to make signed integers behave that way.</p>

<p>Now you arguing about different thing: ‚Äúright to be ignorant‚Äù. You don't want to use flag, you don't want to use provided functions, you don't want to accept anything but complete surrender from guys who have never promised you that your approach would work in the first place (because it's not guaranteed to work even in C90 and gcc 2.95 from last century already assumes you write correct code and don't overflow signed integers).</p>

<font class="QuotedText">&gt; That's just common sense :-)</font>

<p>And that's precisely the problem. You ask for <b>common sense</b> but neither computers nor compilers have it.</p>

<p>They couldn't employ common sense during the optimisation because it's not possible to formally describe what ‚Äúcommon sense‚Äù means!</p>

<p>Thus they use the best next substitute: list of logical rules collected in the C standard.</p>

<font class="QuotedText">&gt; Is there really anything wrong in asking for the result of computer operations to MAKE SENSE? (No, double-free and things like that - bugs through and through - clearly can't make sense.</font>

<p>That's how specification is changed and how new switches are added. People employ their common sense and discuss things and arrive at some set of rules.</p>

<p>Similarly to how law is produced: people start with common sense, but common sense is different for different people thus we end up with certain set of rules which some people like, some people don't like, but all have to follow.</p>

<p>Only with C standard situation is both simpler and more complicated: subject matter is much more limited, but agent which does the interpretation doesn't have even vestigial amounts of common sense (law assumes that where there are contradictions or ambiguities judge would use common sense, C language specification writers have no such luxury) thus you have to make specification as rigid and strict as possible.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/917128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor917112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 15:16 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917112/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It seems to me you lack a lot of experience!</font>

<p>I worked with embedded guys and even know a guy who spent insane amount of time to squeeze AES into 256 bytes on some 4-bit Samsung CPU.</p>

<p>I've seen how these folks behave.</p>

<font class="QuotedText">&gt; In environments like bare metal, you need a lot of discipline, otherwise you don't understand your own code a few years later... or everything will just crash.</font>

<p>The big trouble (and also what makes them truly hopeless) is that hardware is often buggy, it very much contains lots of UBs (especially if you use raw prototypes) but because it's physical thing, <b>UBs are limited</b>. Something doesn't become set when it should, or you need a delay, of if you do something too quickly (or too slowly!) there's a crash‚Ä¶ but it rarely happens that issue in one part of you device affects another, completely unrelated part (except if you are developing something like modern 100-billion transistors CPU/GPU‚Ä¶ but that's not embedded and I'm not even sure you may classify what these people are doing as ‚Äúhardware‚Äù novadays).</p>

<p>They cope with hardware UBs with tests and, na√Øvely, try to apply the same approach to software. Which rarely ends well and just leads to <code>P_PONIES</code> ultimatums (which remain mostly ignored because software is not hardware and effects of UB maybe thoroughly non-local).</p>

<p>They they adopt <i>these idiot compiler makers couldn't be trusted and we are right, thus we would just froze the version of compiler we are using</i>. Which, of course leads to inability to reuse code written is supposedly portable language later (which greatly surprises their bosses).</p>

<p>It's a mess. The worst of all is the attitude <i>we don't have time to sharpen the axe, we need to chop trees!</i></p>

<font class="QuotedText">&gt; I appreciate the simplicity and readability of C very much.</font>

<p>Unfortunately it's simplicity is one skin-deep: it's syntax is readable enough (if you forget blunder with pointers to functions), but it semantic is, often, extremely non-trivial and very few understand it.</p>

<p>This goes back to the fact that C was never, actually, designed, it was cobbled together by similarly-minded folks thus when people who knew how languages are supposed to be designed have tried to clarify how C works they only could do so much if they don't want to create an entirely different language which doesn't support programs written before that point at all (which would defeat the purpose of clarification work).</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/917112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 18:03 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/917129/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The big trouble (and also what makes them truly hopeless) is that hardware is often buggy, it very much contains lots of UBs (especially if you use raw prototypes) but because it's physical thing, UBs are limited. Something doesn't become set when it should, or you need a delay, of if you do something too quickly (or too slowly!) there's a crash‚Ä¶ but it rarely happens that issue in one part of you device affects another, completely unrelated part (except if you are developing something like modern 100-billion transistors CPU/GPU‚Ä¶ but that's not embedded and I'm not even sure you may classify what these people are doing as ‚Äúhardware‚Äù novadays).</span><br>
<p>
In other words, with C's assumption that UB is impossible, we now have a conundrum if we want to write Operating Systems in C!<br>
<p>
Which has been my problem ALL ALONG. I want to be able to reason, SANELY, in the face of UB without the compiler screwing me over. If that's an O_PONY then we really are fscked.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 18:47 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917131/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; In other words, with C's assumption that UB is impossible, we now have a conundrum if we want to write Operating Systems in C!</font>

<p>Why would it be so? There are lots of art built around how can you avoid UBs in practice. Starting from switches which turn certain UBs into IBs (and thus make them safe to use) to sanitizers which [try to] catch UBs like race conditions or double-free or out-of-bounds array access.</p>

<p>If you accept the goal (ensure that your OS doesn't ever trigger UB) there are plenty of ways to achieve it. Here is <a href="http://web1.cs.columbia.edu/~junfeng/09fa-e6998/papers/sel4.pdf">an interesting article on subject</a>.</p>

<p>I, personally, did something similar on smaller scale (not OS kernel, but another security-critical component of the system). Ended up with one bug in 10 years system was in use (and that was related to problem with specification of hardware).</p>

<p>But if you insist on your ability to predict what code with UBs would do‚Ä¶ you can't write Operation System in C that way (or, rather, you can, it's just there are no guarantees that it will work).</p>

<font class="QuotedText">&gt; Which has been my problem ALL ALONG. I want to be able to reason, SANELY, in the face of UB without the compiler screwing me over.</font>

<p>Not in the cards, sorry. In you code can trigger UB then the only guaranteed fix is to change code and make it stop doing that.</p>

<font class="QuotedText">&gt; If that's an O_PONY then we really are fscked.</font>

<p>Why? Rust pushes UBs into tiny corner of your code and there are already enough research into how we can avoid UBs completely (by replacing these with markup which includes proof that your code doesn't trigger any UBs). <a href="https://github.com/google/wuffs">Here</a> is related (and very practical) project.</p>

<p>Of course even after all that we would have issue of bugs in hardware, but that's entirely different can of worms.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/917131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 20:19 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/917138/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; &gt; In other words, with C's assumption that UB is impossible, we now have a conundrum if we want to write Operating Systems in C!</span><br>
<p>
<span class="QuotedText">&gt; Why would it be so? There are lots of art built around how can you avoid UBs in practice. Starting from switches which turn certain UBs into IBs (and thus make them safe to use) to sanitizers which [try to] catch UBs like race conditions or double-free or out-of-bounds array access.</span><br>
<p>
I notice you didn't bother to quote what I was replying to. IF THE HARDWARE HAS UBs (those were your own words!), and the compiler assumes that there is no UB, then we're screwed ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 22:45 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917152/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; IF THE HARDWARE HAS UBs (those were your own words!)</font>

<p>Not <i>if</i>. Hardware most definitely have an UB. x86 have less UBs than most other architectures, but it, too <a href="https://preshing.com/20120515/memory-reordering-caught-in-the-act/">can provide <b>mathematically impossible results</b></a>!</p>

<p><b>On the hardware level, without help from the compiler!</b> If used incorrectly, of course.</p>

<p>These UBs are results of hardware optimizations, instead. <b>You can not turn these off!</b></p>

<p>But you can find series of articles which are explaining how one is supposed to work with all that <a href="https://lwn.net/Articles/718628/">right here</a>, <a href="https://lwn.net/Articles/720550/">on LWN</a>!</p>

<p>You have probably seen then already, but probably haven't realized what they are <b>actually</b> covering.</p>

<font class="QuotedText">&gt; if the compiler assumes that there is no UB, then we're screwed ...</font>

<p>Why? How? What suddenly happened? Compiler deals with these UBs precisely and exactly like with any other UBs: it assumes they never happen.</p>

<p>And then programmer is supposed to deal with all that in the exact same fashion as with any other UBs: by ensuring that compiler assertion is correct.</p>






      
          <div class="CommentReplyButton">
            <form action="/Articles/917152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 11:05 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/917220/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <p>It's worth noting that you're making the situation sound a little worse than it actually is.
<p>The compiler's job is translate your program from one language (say C) to another language (say x86-64 machine code), with the constraint that the output program's behaviour must be the same as the input program's behaviour. Effectively, therefore, the compiler's job is to translate defined behaviour in the source program into identically defined behaviour in the output program.
<p>For source languages without undefined behaviour, this means that the compiler must know about the destination language's undefined behaviour and ensure that it never outputs a construct with undefined behaviour - this can hurt performance, because the compiler may be forced to insert run-time checks (e.g. "is the shift value greater than the number of bits in the input type, if so jump to special case").
<p>For source languages with undefined behaviour, the compiler gets a bit more freedom; it can translate a source construct with UB to any destination construct it likes, including one with UB. This is fine, because the compiler hasn't added new UB to the program - it's "merely" chosen a behaviour for something with UB.


      
          <div class="CommentReplyButton">
            <form action="/Articles/917220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 12:44 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917232/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It's worth noting that you're making the situation sound a little worse than it actually is.</font>

<p>You are mixing issues. Of course it's possible to make language without UB! There are <b>tons</b> of such languages: C#, Java, Haskell, Python‚Ä¶</p>

<p>But that's <b>not</b> what <code>O_PONIES</code> lovers want! They want the ability to ‚Äúprogram to hardware‚Äù. Lie to compiler (because ‚Äúthey know better‚Äù), do certain manipulations to hardware <b>which compiler have no idea about</b> and then expect that code would still work.</p>

<p><b>That</b> is impossible (and I, probably, underestimate the complexity of task). It's as if Java program opened <code>/proc/self/men</code>, poked the runtime internals and then, when upgrade broken it, its author demanded satisfaction and claimed that since his code worked in one version of JRE then it must work in all of them.</p>

<p>That is what happens when you ‚Äúuse UB to combat UB‚Äù. Onus is on you to support new versions of compiler. Just like onus is on you to support new versions of Windows if you use undocumented functions, onus is on you if you poke into linux kernel internals via <code>debugfs</code> and so on.</p>

<p>And Linux kernel developers are <b>not</b> shy when they say that when programs rely on such intricate internal details all bets are off. Even <code>O_PONIES</code> term was coined by them, not by compiler developers!</p>

<font class="QuotedText">&gt; For source languages with undefined behaviour, the compiler gets a bit more freedom; it can translate a source construct with UB to any destination construct it likes, including one with UB. This is fine, because the compiler hasn't added new UB to the program - it's "merely" chosen a behaviour for something with UB.</font>

<p>Yes, but that's precisely what <code>O_PONIES</code> lovers object against. Just <a href="http://www.complang.tuwien.ac.at/papers/ertl17kps.pdf">read the damn paper already</a>. It doesn't even entertain the notion that programs can be written without use of UBs for one minute. They just assert they would continue to write code with UBs (‚Äúwrite code for the hardware‚Äù since ‚ÄúC is a portable assembler‚Äù) and compilers have to adapt, somehow. Then they discuss how compiler would have to deal with mess <b>they</b> are creating.</p>

<p>You may consider that as a concession of sorts (no doubt caused by the fact that you can not avoid UBs in today's world because even bare hardware have UBs), but it's still not a discussable position because instead of listing constructs which are <b>allowed</b> in the source program they want to just only blacklist certain ‚Äúbad things‚Äù.</p>

<p>Because it doesn't work! Ask any security guy what he thinks about black lists and you would hear that they are always only a papering over the problem and just lead to the ‚Äúwhack the mole‚Äù busywork. To arrive at some promises you have to <b>whitelist</b> good programs, not <b>blacklist</b> the bad ones!</p>





      
          <div class="CommentReplyButton">
            <form action="/Articles/917232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 14:18 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/917243/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>You're arguing a different point, around people who demand a definition of UB in their language of choice L, by analogy to another language M.
<p>I'm saying that the situation is not as awful as it might sound; if I write in language L, and compile it to language M, it's a compiler bug if the compiler converts defined behaviour in L into undefined behaviour in M. As a result, when working in language L (whether that's C, Haskell, Python, Rust, JavaScript, ALGOL, Lisp, PL/I, Prolog, BASIC, Idris, whatever), I do not need to worry about whether or not there's UB in language M - I only need care about language L, because it's a compiler bug if the compiler translates defined behaviour language L into undefined behaviour in language M.
<p>So, for example, if language L says that a left shift by more than the number of bits in my integer type always results in a zero value, it's up to the compiler to make that happen. If language M says that a left shift by more than the number of bits in my integer type results in UB, then the compiler has to handle putting in the checks (or proving that they're not needed) so that if I do have a left shift by more than the number of bits in my integer type, I get 0, not some undefined behaviour.
<p>And this applies all the way up the stack if I have multiple languages involved; if machine code on my platform has UB (and it probably does in a high-performance CPU design), it makes no difference if I compile BASIC to Idris, Idris to Chicken Scheme, Chicken Scheme to C, C to LLVM IR and finally LLVM IR to machine code, or if I compile BASIC directly to machine code. Each compiler in the chain must ensure that all defined behaviour of the source language translates to identically defined behaviour in the destination language.
<p>In other words, as you compile from language L to language M, the compiler can leave you with as much UB as you had before, or it can decrease the amount of UB present in language M, but it can never add UB. The only "problem" this leaves you with if you're the O_PONIES sort is that it means that defining what it actually means for UB to flow from language M to language L is tricky, because in the current world, UB doesn't flow that way, it only flows from language L to language M.



      
          <div class="CommentReplyButton">
            <form action="/Articles/917243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 15:09 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917247/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; In other words, as you compile from language L to language M, the compiler can leave you with as much UB as you had before, or it can decrease the amount of UB present in language M, but it can never add UB.</font>

<p>Of course it can add UB! Every language with manual memory management, without GC, adds UB related to these. On hardware level there are no such UBs, memory is managed by user when he adds new DIMMs or removes then, there may never be any confusion about whether memory is accessible or not.</p>

<p>But Ada, C, Pascal and many other such languages add memory management functions and then say ‚Äúhey, if you freed memory then onus is on you to make sure you wouldn't try to use object which no longer exists‚Äù.</p>

<p>The desire to do what you are talking about is what gave rise to GC infestation and abuse of managed code.</p>

<font class="QuotedText">&gt; The only "problem" this leaves you with if you're the O_PONIES sort is that it means that defining what it actually means for UB to flow from language M to language L is tricky, because in the current world, UB doesn't flow that way, it only flows from language L to language M.</font>

<p>UBs can flow in any direction and don't, actually, cause any problems as long as you understand what UB is: something that you are not supposed to do. If you understand what UB is and can list them ‚Äî you can deal with them.</p>

<p>If you don't understand that UB is (<code>O_PONIES</code> people) or don't understand where they are (Cl√©ment B≈ìsch case or, of we are talking about hardware, Meltdown and Spectre case) then there's trouble.</p>

<p>Ignorance can be fixed easily. But attitude adjustments are hard. If someone believes it's his right to ignore traffic light because that's how he drove for last half-century in his small village then it becomes a huge problem when someone like that moves to big city.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/917247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 16:21 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/917259/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>You're misunderstanding me still. If there is no UB in my source code, then there is also no UB in the resulting binary, absent bugs/faults in the compiler, the OS or the hardware.
<p>Your examples are cases where I have UB in language L, I translate to language M, and I still have UB - in other words, no new UB has been introduced, but the existing UB has resulted in the output program having UB, too. The only gotcha is that the UB in the output program may surprise the programmer, since UB in the source language simply leaves the target language behaviour completely unconstrained.
<p>There is never a case where I write a program in language L that is free of UB, but a legitimate compilation of that program to language M results in the program having UB. If this does happen, it's a bug - the compiler has produced invalid output, just as it's a bug for a C compiler to turn <tt>int a = 1 + 2;</tt> into <tt>int a = 4;</tt>.
<p>In turn, this means that UB in language M does not create new UB in language L - the flow of UB is entirely one-way in this respect (there was UB in language L, when I compiled it, I ended up with a program that has UB in language M).
<p>The only thing that people find tricky here is that they have a mental model of what consequences of UB are "reasonable", and what consequences of UB are "unreasonable", and get upset when a result of compiling a program from L to M results in the compiler producing a program in language M with "unreasonable" UB, when as far as they were concerned, the program in language L only had "reasonable" UB. But this is not a defensible position - the point of UB is that the behaviour of a program that executes a construct that contains UB is undefined, while "reasonable" UB is a definition of what behaviour is acceptable.
<p>And here we come to the underlying fun with O_PONIES: Coming up with definitions for existing UB and pushing that through the standards process is hard work, and involves thinking about a lot of use cases for the language, not just your own, and getting agreement either on a set of allowable behaviours for a construct that's currently UB, or getting the standards process to agree that something should be implementation-defined (i.e. documented set of allowable behaviours from the compiler implementation). This is a lot of work, and involves getting a full understanding of why people want certain behaviours to be UB, rather than defined in a non-deterministic fashion.



      
          <div class="CommentReplyButton">
            <form action="/Articles/917259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917263"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 17:28 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/917263/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And here we come to the underlying fun with O_PONIES: Coming up with definitions for existing UB and pushing that through the standards process is hard work, and involves thinking about a lot of use cases for the language, not just your own, and getting agreement either on a set of allowable behaviours for a construct that's currently UB, or getting the standards process to agree that something should be implementation-defined (i.e. documented set of allowable behaviours from the compiler implementation). This is a lot of work, and involves getting a full understanding of why people want certain behaviours to be UB, rather than defined in a non-deterministic fashion.</span><br>
<p>
I don't know whether khim's English skills are letting him down, or whether he's trolling, but I think you've just encapsulated my view completely.<br>
<p>
Multiplication exists in C. Multiplication exists in Machine Code. All I want is for the C spec to declare them equivalent. If the result is sane in C, then machine code has to return a sane result. If the result is insane in C, then machine code is going to return an insane result. Whatever, it's down to the PROGRAMMER to deal with.<br>
<p>
khim is determined to drag in features that are on their face insane, like double frees and the like. I'm quite happy for the compiler to optimise on the basis of "this code is insane, I'm going to assume it can't happen (because it's a bug EVERYWHERE). What I'm unhappy with is SchrodinUB where the EXACT SAME CODE may, or may not, exhibit UB depending on situations outside the control of the programmer (and then the compiler deletes the programmer's checks!).<br>
<p>
And it's all very well khim saying "the compiler writers have given you an opt-out". But SchrodinUB should always be opt IN. Principle of "least surprise" and all that. (And actually, I get the impression Rust is like that - bounds checks and all that sort of thing are suppressed in runtime code I think I heard some people say. That's fine - actively turn off checks in production in exchange for speed IF YOU WANT TO, but it's a conscious opt-in.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917263/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 18:48 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917267/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; All I want is for the C spec to declare them equivalent.</font>

<p>If that's really your desire then you sure found a funny way to achieve it.</p>

<p>But I'm not putting you with <code>O_PONIES</code> crowd.  It seems you are acting out of ignorance not malice.</p>

<p> John Regehr <a href="https://blog.regehr.org/archives/1287">tried to do what you are proposing to do</a> ‚Äî and failed spectacularly, of course.</p>

<p>But <a href="https://lwn.net/Articles/916771/">look here</a>: <i>My paper does not propose a tightening of the C standard. Instead, it tells C compiler maintainers how they can change their compilers without breaking existing, working, tested programs. Such programs may be compiler-specific and architecture-specific (so beyond anything that a standard tries to address), but that's no reason to break them on the next version of the same compiler on the same architecture.</i></p>

<p>Basically <code>O_PONIES</code> lovers position is the following: if language M (machine code) have UBs then it's Ok for L to have UB in that place, but if M doesn't have UB <b>then it should be permitted to violate rules of L and still produce working program</b>.</p>

<p>But yeah, that's probably problem with me understanding English or you having trouble explaining things.</p>

<font class="QuotedText">&gt; What I'm unhappy with is SchrodinUB where the EXACT SAME CODE may, or may not, exhibit UB depending on situations outside the control of the programmer</font>

<p>How is that compatible with this:</p>

<font class="QuotedText">&gt; khim is determined to drag in features that are on their face insane, like double frees and the like. I'm quite happy for the compiler to optimise on the basis of "this code is insane, I'm going to assume it can't happen (because it's a bug EVERYWHERE).</font>

<p>I don't see why do you say that this feature is insane. Let's consider <a href="https://www.joelonsoftware.com/2000/05/24/strategy-letter-ii-chicken-and-egg-problems/">concrete example</a>:</p>

<blockquote>On beta versions of Windows 95, SimCity wasn‚Äôt working in testing. Microsoft tracked down the bug and <i>added specific code to Windows 95 that looks for SimCity</i>. If it finds SimCity running, it runs the memory allocator in a special mode that doesn‚Äôt free memory right away.</blockquote>

<p>It looks as if your approach <i>the EXACT SAME CODE may, or may not, exhibit UB depending on situations outside the control of the programmer</i> very much <b>does</b> cover double free, dangling pointers and other such things. It's even possible to make it work if you have enough billions in bank and obsession with backward compatibility.</p>

<p>The question: are these a well-spent billion? Should we have a dedicated team which cooks up such patches for the <code>clang</code> and/or <code>gcc</code>? Who would pay for it?</p>

<p>Without changing spec (which people like Anton Ertl or Victor Yodaiken very explicitly say not what they want) this would be the only alternative, I'm afraid.</p>

<font class="QuotedText">&gt; But SchrodinUB should always be opt IN.</font>

<p>Why? It's not part of the C standard, why should it affect good programs which are not abusing C?</p>

<font class="QuotedText">&gt; And actually, I get the impression Rust is like that - bounds checks and all that sort of thing are suppressed in runtime code I think I heard some people say. </font>

<p>Only integer overflow checks <a href="https://doc.rust-lang.org/reference/behavior-not-considered-unsafe.html#integer-overflow">are disabled</a>. If you would try to divide by zero you would still get check and panic if divisor is zero.</p>

<p>But if you violate <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">some other thing</a> (e.g. <a href="https://www.ralfj.de/blog/2019/07/14/uninit.html">if you program would try to access undefined variable</a>) all bets are still off.</p>

<p>Let's consider the following example:</p>

<pre>
bool to_be_or_not_to_be() {
    int be;
    return be == 0 || be != 0;
}
</pre>

With Rust you need to jump through the hoops to use uninitialized variable but with <code>unsafe</code> it's possible:

<pre>
pub fn to_be_or_not_to_be() -&gt; bool {
    let be: i32 = unsafe { MaybeUninit::uninit().assume_init() };
    return be == 0 || be != 0;
}
</pre>

<p>You may argue that <a href="https://godbolt.org/z/PTM8Kn6E4">what Rust is doing</a> (removing the code which follows  <code>to_be_or_not_to_be</code> call and replacing it with unconditional crash) is, somehow, better then what C is doing (claiming that value of the <code>be == 0 || be != 0</code> is <code>false</code>).</p>

<p>But that would hard sell to <code>O_PONIES</code> lover who was counting on getting <code>true</code> from it (like Rust <a href="https://godbolt.org/z/dY8PW69fK">did only few weeks ago</a>).</p>

<p>Yes, Rust is better-defined language, no doubt about it. It has smaller number of UBs and they are more sane. <b>But C and Rust are cast in the same mold</b>!</p>

<p>You either avoid UBs and have a predictable result or not's avoid them and end up with something strange‚Ä¶ and there are <b>absolutely</b> no guarantee that program which works today would continue to work tomorrow‚Ä¶ you have to ensure you program doesn't trigger UB <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">to cash on that promise</a>.




      
          <div class="CommentReplyButton">
            <form action="/Articles/917267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor917276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 19:48 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/917276/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And it's all very well khim saying "the compiler writers have given you an opt-out". But SchrodinUB should always be opt IN. </span><br>
<p>
The thing is... they are!  Run GCC without any arguments and you'll get -O0, ie "no optimization".<br>
<p>
These UB-affected optimizations are only ever attempted if the compiler is explicitly told to try.<br>
<p>
Now what I find hilarious are folks who complain about the pitfalls of modern optimization techniques failing on their code while simultaneously complaining  "but without '-O5 -fmoar_ponies'  my program is too big/slow/whatever".  Those folks also tend to ignore or disable warnings, so.. yeah.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor917271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 19:06 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917271/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; If there is no UB in my source code, then there is also no UB in the resulting binary, absent bugs/faults in the compiler, the OS or the hardware.</font>

<p>We don't disagree there, but that's <b>not</b> what <code>O_PONIES</code> lovers are ready to accept.</p>

<font class="QuotedText">&gt; Your examples are cases where I have UB in language L, I translate to language M, and I still have UB - in other words, no new UB has been introduced, but the existing UB has resulted in the output program having UB, too. </font>

<p>Yes. Because that's what <code>O_PONIES</code> lovers demand to handle! They, basically, say that it doesn't matter whether L have UB or not. It only matters whether <b>M</b> have UB. If M doesn't have ‚Äúsuitably similar‚Äù UB then program in L <b>must</b> be handled correctly <b>even if it violates rules of language L</b>.</p>

<p>Unfortunately on practice it works only in two cases:</p>
<ol>
<li>If L and M are extremely similar (like machine code and assembeler)<br>or</li>
<li>If translator from L to M is so primitive that you can, basically, predict how precisely each construct from L maps to M (old C compilers)</li>
</ol>

<font class="QuotedText">&gt; In turn, this means that UB in language M does not create new UB in language L - the flow of UB is entirely one-way in this respect (there was UB in language L, when I compiled it, I ended up with a program that has UB in language M).</font>

<p>Ah, got it. Yeah, <b>in that sense</b> it's one-way street in the absence of bugs. Of course bugs may move things from M to L (see Meltdown and Spectre), but in the absence of bugs it's one way street, I agree.</p>

<font class="QuotedText">&gt; This is a lot of work, and involves getting a full understanding of why people want certain behaviours to be UB, rather than defined in a non-deterministic fashion.</font>

<p>And it's also explicitly not what <code>O_PONIES</code> lovers want. They explicitly don't want all that hassle, they just want the ability to write code in L with UB and get a working program. <b>That</b> is really pure <code>O_PONIES</code> ‚Äî <a href="https://sandeen.net/wordpress/uncategorized/coming-clean-on-o_ponies/">exactly like in that story with Linux kernel</a>.</p>

<p>List of UBs in C and C++ is still patently insane, but that's <b>different</b> issue. It would have been possible to tackle <b>that issue</b> if <code>O_PONIES</code> lovers actually wanted to alter the spec. That's not what they want. They want ponies.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/917271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2022 11:11 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/917350/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Yep - and the <tt>O_PONIES</tt> problem, when you reduce it to its core is simple. The standard permits non-deterministic behaviour (some behaviours are defined as "each execution of the program must exhibit one behaviour from the allowed list of behaviours", not as a single definite behaviour). The standard also permits implementation-defined behaviour - where the standard doesn't define how a construct behaves, but instead says "your implementation will document how it interprets this construct".
<p>What the <tt>O_PONIES</tt> crowd want is to convert "annoying" UB in C and C++ to implementation-defined behaviour. There's a process for doing that - it involves going through the standards committees writing papers and convincing people that this is the right thing to do. The trouble is that this is hard work - as John Regehr has already demonstrated by making the attempt - since UB has been used by the standards committee as a way of avoiding difficult discussions about what is, and is not, acceptable in a standards-compliant compiler, and thus re-opening the discussion is going to force people to confront those arguments all over again.


      
          <div class="CommentReplyButton">
            <form action="/Articles/917350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor917214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 10:04 UTC (Wed)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/917214/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><em>This goes back to the fact that C was never, actually, designed, it was cobbled together by similarly-minded folks thus when people who knew how languages are supposed to be designed have tried to clarify how C works they only could do so much if they don't want to create an entirely different language which doesn't support programs written before that point at all (which would defeat the purpose of clarification work).</em></blockquote>
<p>
That, of course, applies to all programming languages which are in common use ‚Äì especially to programming languages that have more than one implementation. (Life is a lot easier when a programming language has only one implementation and you can decree that the official behaviour of the language is whatever that implementation does in every case.)
</p>
<p>
C had been around for almost 20 years, with a considerable number of implementations on a wide variety of hardware architectures, when the first official C standard was published. Considering that, ANSI/ISO 9899-1990, within its limits, was a very important and remarkably useful document. It's easy to argue, with the benefit of 30-plus years' worth of hindsight, that C is a terrible language and the various C standards not worth the paper they're printed on, but OTOH as far as the Internet is concerned, C is still what makes the world go round ‚Äì between the Linux kernel, Apache and friends, and for that matter many implementations of nicer languages than C, most of the code we're running on a daily basis remains written in C, and it will be a while yet before new languages like Rust get enough traction (and architecture support) to be serious competitors.
</p>
<p>
Of course C has its problems, but it is virtually guaranteed that any other language, once it has achieved the popularity and widespread use of C, will too (even if invented by ‚Äúpeople who know how languages are supposed to be designed‚Äù). Certainly in the last 80 years of programming language design, and claims to the contrary notwithstanding, nobody has so far been able to come up with a systems programming language that has no problems at all, that runs everywhere, and that people are actually prepared to adopt.
</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/917214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 12:04 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/917222/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; That, of course, applies to all programming languages which are in common use</font>

<p>Depends on how would you define ‚Äúcommon use‚Äù, though. The first language which was actually designed is, arguably, <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> (and it wasn't even designed to write real-world programs). It's still in use.</p>

<p>Also different version of Algol were designed, Pascal, Ada, Haskell‚Ä¶ Even Java, C#, Go were designed to some degree! The goal of all these projects were to create something people can use to discuss how programs are crated, features of the language were extensively discussed and rejected (or accepted) on that basis.</p>

<p>C or PHP, on the other hand, were never actually designed, C was create just by pressing need to have something to rewrite <a href="https://en.wikipedia.org/wiki/PDP-7">PDP-7</a> only OS to support <a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11</a>, too. Later more machines were added and C was stretched and stretched till it started to break.</p>

<p>Only then committee started it's work and it stitched it together to the best of their abilities, but because some cracks were so deep some results were‚Ä¶ unexpected.</p>

<font class="QuotedText">&gt; Life is a lot easier when a programming language has only one implementation and you can decree that the official behaviour of the language is whatever that implementation does in every case.</font>

<p>You never can do that. Look on languages with one implementation: PHP, Python (theoretically many implementation, but CPython is the definition one), or even Rust (although there are new implementations in development). Different versions may behave differently and you have to decide which one is ‚Äúright‚Äù even if are no other implementation.</p>

<p>Life is ‚Äúsimple‚Äù only when language and it's implementation never change (Lua comes close).</p>

<font class="QuotedText">&gt; most of the code we're running on a daily basis remains written in C</font>

<p>I wouldn't say so. Maybe in embedded, but in most other places C is replaced with C++. Even if you say that C and C++ is the same language (which is true to some degree), then you would have to admit that most code today is not written in C, it's written in Python, Java, JavaScript or Visual Basic.</p>

<p>It was never true that C was <b>the language</b> which was used to the exclusion of everything else. And it wasn't even initially popular with OS writers: <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">MacOS</a> was written in Pascal, e.g. and early versions of Microsoft's development tools (Assembler, Linker, etc) were written in Microsoft Pascal, too.</p>

<p>Success of UNIX made C popular and this success wasn't even based in technical merits! Rather AT&amp;T was forced to refrain from selling software thus it couldn't compete with sellers of UNIX.</p>

<p>It was <b>always</b> known that C is awful language, since day one. It was just not obvious <b>how</b> awful it was till sensible alternative arrived.</p>

<p>Approach was: ‚ÄúC is that horrible, awful thing, let's hide it from mere mortals‚Äù. Mostly because IT industry bought the cool-aid of GC-based solution to memory safety which, of course, can only work if there are something <b>under</b> your language to provide GC and other important runtime.</p>

<p>Most managed languages remained with runtime written in C/C++ because ‚Äúhey, it's used by professionals, they can deal with sharp corners‚Äù. Only Go avoided that and it still need some other language for OS kernel, even in theory.</p>

<font class="QuotedText">&gt; Of course C has its problems, but it is virtually guaranteed that any other language, once it has achieved the popularity and widespread use of C, will too (even if invented by ‚Äúpeople who know how languages are supposed to be designed‚Äù).</font>

<p>Oh, absolutely. Pascal was stretched, too and it, too, got many strange warts when <s>Borland</s>, <s>CodeGear</s>, <s>Borland</s>, <s>Embarcadero</s>, Idera was adding hot new features without thinking how to integrate them.</p>

<p>Rust is definitely not immune: while it's core is very good <code>async</code> approach is questionable and chances are high that we would know, 10 or 20 years later, how to do it much better than how Rust does it today.</p>

<p>But today it's unclear how to it better thus we have what we have.</p>

<font class="QuotedText">&gt; Certainly in the last 80 years of programming language design, and claims to the contrary notwithstanding, nobody has so far been able to come up with a systems programming language that has no problems at all, that runs everywhere, and that people are actually prepared to adopt.</font>

<p>That's just not possible. Languages come and go. C lifespan was artificially extended by invention and slow adoption of C++, though (when C++ was created it became possible to froze C and say that if you want a modern language you can go use C++ and since C++ wasn't ‚Äúready‚Äù for so many years it was always easy to say ‚Äúhey, don't worry, <b>next</b> version would fix everything‚Äù). It's a bit funny and sad when you read <a href="https://www.stroustrup.com/good_concepts.pdf">concepts complete C++ templates as originally envisioned</a> 30+ years after language was made, but oh, well‚Ä¶ that's life.</p>

<p>Rust wasn't built in a vacuum, after all. It took many concepts developed in C++! RAII was invented there, ownership rules were invented there (only initially <a href="https://web.archive.org/web/20080701113040/http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">enforced by style guide, not compiler</a> and so on.</p>

<p>Only, at some point, it becomes obvious that the only way forward is to <b>remove</b> some things from the language ‚Äî which, basically, makes it a different language (it's really hard to remove something from popular language, recall the Python3 saga). <a href="https://graydon2.dreamwidth.org/218040.html">Here</a> Graydon Hoare lists things which were either removed from Rust or (in some cases) never added.</p>

<p>Thus yes, it would be interesting to see what would happen in 10-20 years when we would need to remove something from Rust. Would we get Rust 2.0 (like happened with Python) or entirely different language (like happening with C)? Who knows.</p>

<p>But no, I don't expect Rust to live forever. Far from it. It's full of problems, we just have to idea how to solve these problems <b>properly</b> yet, thus we solve these problems the same way we solve them in C (ask developer ‚Äúto hold it right‚Äù).</p>










      
          <div class="CommentReplyButton">
            <form action="/Articles/917222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor917027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 21:57 UTC (Mon)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/917027/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would be interesting to do an in-depth comparison with rust's type system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor917028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2022 22:28 UTC (Mon)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/917028/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, another day, I stumbled on binfmt_misc and the register file has a "magic" number field too :) <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 0:04 UTC (Tue)
                               by <b>magfr</b> (subscriber, #16052)
                              [<a href="/Articles/917032/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is an entirely different school closer related to file(1) than the magic that is fading from the kernel sources.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor917046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2022 6:44 UTC (Tue)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/917046/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At this rate kernel will never run out of magic!<br>
<p>
$ find . -type f -name '*.[chS]' | xargs grep -e magic -i | wc -l<br>
12342<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor917161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 7, 2022 1:14 UTC (Wed)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/917161/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't this the situation from which Rusgocamkell will save us?<br>
<p>
Sorry. Couldn't resist the snark. Run-time-ish methods to ensure compatibility likely are good at the correct abstraction points. I've used eight-character strings to detect (integer) endianness as a trivial example. Not zero terminated.<br>
<p>
And losing magic for openness isn't bad necessarily. Just a tad sad for ex-wizards.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor917721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2022 6:02 UTC (Tue)
                               by <b>tytso</b> (subscriber, #9993)
                              [<a href="/Articles/917721/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <p>The use of magic numbers is something that I learned from Multics.   One advantage of structure magic numbers is that it also provides protection against use-after-free bugs, since you can zero the magic number before you free the structure, and even if you don't, when it gets reused, if everyone uses the magic number scheme where the first four bytes contain a magic number, then it becomes a super-cheap defense a certain class of bugs without needing to rely on things like KMSAN, which (a) is super-heavyweight and so won't be used on production kernels, and (b) didn't exist in the early days of Linux. </p> 

<p>Like everything, it's a trade-off.   Yes, there is overhead associated with magic numbers.  But it's not a lot of overhead  (and it's certainly cheaper than KMSAN!) and the ethos of "trying to eliminate an entire set of bugs" which is something is well accepted for making the kernel more secure, is someting that could be applied for magic numbers as well.</p>

<p>I still use magic numbers in e2fprogs, where the magic number is generated using the com_err library (another Multicism; where the top 24-bits identify the subsystem, and the low 8-bits is the error code for that subsystem).   This means it's super easy to do things like this:
</p>

<p>In lib/ext2fs/ext2fs.h:

<pre>
#define EXT2_CHECK_MAGIC(struct, code) \
	  if ((struct)-&gt;magic != (code)) return (code)
</pre>

<p>In lib/ext2fs/ext2_err.et.in:

<pre>
	error_table ext2

ec	EXT2_ET_BASE,
	"EXT2FS Library version @E2FSPROGS_VERSION@"

ec	EXT2_ET_MAGIC_EXT2FS_FILSYS,
	"Wrong magic number for ext2_filsys structure"

ec	EXT2_ET_MAGIC_BADBLOCKS_LIST,
	"Wrong magic number for badblocks_list structure"
</pre>

<p>The compile_et program generates ext2_err.h and ext2_err.c, for which ext2_err.h will have definitions like this:

<pre>
#define EXT2_ET_BASE                             (2133571328L)
#define EXT2_ET_MAGIC_EXT2FS_FILSYS              (2133571329L)
#define EXT2_ET_MAGIC_BADBLOCKS_LIST             (2133571330L)
...
</pre>

<p>Then in various library functions:

<pre>
errcode_t ext2fs_dir_iterate2(ext2_filsys fs,
			      ext2_ino_t dir,
...
{
	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
        ...
</pre>

<p>And of course:

<pre>
void ext2fs_free(ext2_filsys fs)
{
	if (!fs || (fs-&gt;magic != EXT2_ET_MAGIC_EXT2FS_FILSYS))
		return;
       ...
	fs-&gt;magic = 0;
	ext2fs_free_mem(&amp;fs);
}
</pre>

<p>Callers of ext2fs library functions then will do things like this:

<pre>
 	errcode_t    retval;

	retval = ext2fs_read_inode(fs, ino, &amp;file-&gt;inode);
	if (retval)
		return retval;
</pre>

or in application code:

<pre>
		retval = ext2fs_read_bitmaps (fs);
		if (retval) {
			printf(_("\n%s: %s: error reading bitmaps: %s\n"),
			       program_name, device_name,
			       error_message(retval));
			exit(1);
		}
</pre>

<p>This scheme has absolutely found bugs, and given that there is a full set of regression tests that get run via "make check", I've definitely found that having this kind of software engineering practice increases developer velocity, and reduces my stress when I code since when I do make a mistake, it generally gets caught really quickly as a result.</p>

<p>Personally, I find this coding discipline easier to understand and write than Rust, and more performant than using things like valgrind and MSan.   Of course, I use those tools too, but if I can catch bugs early, my experience is that it allows me to generate code much more quickly and reliably.</p>

<p>Shrug.   Various programming styles go in and out of fashion.   And structure magic numbers goes all the way back to the 1960's (Multics was developed as a joint project between MIT, GE, and Bell Labs starting in 1964).</p>










      
          <div class="CommentReplyButton">
            <form action="/Articles/917721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917723"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2022 6:19 UTC (Tue)
                               by <b>Fowl</b> (subscriber, #65667)
                              [<a href="/Articles/917723/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it still 'magic' if it's a vtable pointer? ;p<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917723/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor917722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2022 6:27 UTC (Tue)
                               by <b>tytso</b> (subscriber, #9993)
                              [<a href="/Articles/917722/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And by the way.... the com_err library is not just used by e2fsprogs.   It's also used by Kerberos, as well as a  number of other projects that were developed at MIT's Project Athena[1] (including Zephyr[2], Moira[3], Hesiod[4], Discuss[5], etc.)  <br>
<p>
[1] <a href="http://web.mit.edu/saltzer/www/publications/atp.html">http://web.mit.edu/saltzer/www/publications/atp.html</a><br>
[2] <a href="http://web.mit.edu/saltzer/www/publications/athenaplan/e.4.1.pdf">http://web.mit.edu/saltzer/www/publications/athenaplan/e....</a><br>
[3] <a href="http://web.mit.edu/saltzer/www/publications/athenaplan/e.1.pdf">http://web.mit.edu/saltzer/www/publications/athenaplan/e....</a><br>
[4] <a href="http://web.mit.edu/saltzer/www/publications/athenaplan/e.2.3.pdf">http://web.mit.edu/saltzer/www/publications/athenaplan/e....</a><br>
[5] <a href="http://www.mit.edu/afs/sipb/project/www/discuss/discuss.html">http://www.mit.edu/afs/sipb/project/www/discuss/discuss.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor917753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2022 12:11 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/917753/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I run my userspace under `MALLOC_CHECK_=3` and `MALLOC_PERTURB_=‚Ä¶` (updated occasionally by a user timer unit) to catch things like this. Is some kind of "memset-on-kfree" mechanism not suitable for debugging the entire kernel for use-after-free while also being far less heavy than KMSAN?<br>
<p>
I ask because some day, a very smart compiler might see that dead write of `fs-&gt;magic = 0;` given the immediate free afterwards and optimize it out as UB to observe. Additionally, while it's also against UAF in ext2 code, non-ext2 code that gets its hands on the pointer that somehow that doesn't have the magic-checking logic is just as dead too (I have no gauge on how "likely" this is in the design's use of pointers).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2022 13:08 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/917755/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I ask because some day, a very smart compiler might see that dead write of `fs-&gt;magic = 0;` given the immediate free afterwards and optimize it out as UB to observe.</span><br>
<p>
That day was at least 8 years ago. GCC 4.9 with -O1 will optimise away the writes, defeating this attempt at memory protection, because ext2fs_free_mem is an inline function so the compiler knows the object is passed to free() and can no longer be observed. See e.g. <a href="https://godbolt.org/z/nWYEa34a6">https://godbolt.org/z/nWYEa34a6</a><br>
<p>
I guess the cheapest way to prevent that is to insert a compiler barrier (`asm volatile ("" ::: "memory")`) just after writing to fs-&gt;magic, to prevent the compiler making assumptions about observability of memory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2022 14:47 UTC (Tue)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/917759/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is the usecase for "volatile": *(volatile int *)&amp;fs-&gt;magic = 0;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 14, 2022 2:46 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/917775/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even then, couldn't the compiler just set it back after the volatile write, but before the memory is freed? Seeing as how it's unobservable and all. Perhaps it decides to use that "dead" memory as scratch space for some other operation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 14, 2022 16:47 UTC (Wed)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/917857/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think so. "volatile" means "load/store instruction must be somewhere in the instruction stream" which is what needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917858"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 14, 2022 17:10 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/917858/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It means that the value being represented is not trackable in the C abstract machine and therefore no assumptions can be made about it. Because no assumptions can be made, optimizers are hard-pressed to do much of anything about it because the "as-if" rule is likely impossible to track accurately.<br>
<p>
However, given that this is trivially detectable as about-to-be-freed memory, I don't know what kind of rules exist around "volatile values living in C-maintained memory" might allow even this to still be seen as a dead store and unobservable via UAF == UB.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917858/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 14, 2022 19:31 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/917863/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>If I'm reading the standard correctly, the compiler has to output the stores, because it is possible that the program has shared that memory with an external entity using mechanisms outside the scope of the standard. What the implementation does <em>after</em> the memory is freed is not specified (although the implementation is allowed to assume that the memory is no longer shared with an external entity at this point), and in theory a sufficiently malicious implementation could undo those final stores after you called free, but before the memory is reused.
<p>In practice, I don't think this is a significant concern for tricks intended to help with debugging. It is for security-oriented code, but that's not the case here.


      
          <div class="CommentReplyButton">
            <form action="/Articles/917863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 14, 2022 23:25 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/917871/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can the C abstract machine really say that memory it obtains through `malloc` has some other magical property? Wouldn't that require you to get "lucky" with what `malloc` gives you in the first place to have that address space "mean something" to some other part of the system?<br>
<p>
Maybe the kernel gets away with it by "hiding" behind non-standard allocation APIs‚Ä¶<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor917921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2022 10:47 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/917921/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's more that you can have an external observer outside the abstract machine, but able to understand abstract machine pointers; I can, in theory, store a pointer from malloc in a way that allows the external observer to reach into the abstract machine and read the malloc'd block. I can also have the external observer be looking not at the addresses, but at the pattern of data written into the block (just as in hardware, it's not unknown to have chips only connected to the address bus, and to rely on the pattern of address accesses to determine what to do).
<p>The compiler is not allowed to make assumptions about what the external environment can, or cannot, see, and thus has to assume that any write to a volatile is visible in an interesting fashion.


      
          <div class="CommentReplyButton">
            <form action="/Articles/917921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor917860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Losing the magic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 14, 2022 18:33 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/917860/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Even then, couldn't the compiler just set it back after the volatile write, but before the memory is freed? Seeing as how it's unobservable and all. Perhaps it decides to use that "dead" memory as scratch space for some other operation.</span><br>
<p>
It probably could, but I don't think it's particularly fruitful to consider what the compiler 'could' do, because the goal of the magic numbers here is to detect use-after-free bugs, i.e. we're interested in the practical behaviour of a situation that the standard says is undefined behaviour. We're outside the scope of the standard, so all we can do is look at what GCC/Clang actually will do.<br>
<p>
If there is no barrier or volatile, and some optimisations are turned on, they demonstrably will delete the write-before-free. With barrier or volatile, it appears (in my basic testing) they don't delete it, so the code will behave as intended - that doesn't prove they'll never delete it, but I can't immediately find any examples where that trick fails, and intuitively I think it'd be very surprising if it didn't work, so I'd be happy to make that assumption until shown a counterexample.<br>
<p>
(The same issue comes up when trying to zero a sensitive buffer before releasing it, to reduce the risk of leaking its data when some other code has a memory-safety bug - you need to be very careful that the compiler doesn't remove all the zeroing code, and you can't look to the C standard for an answer.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/917860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
