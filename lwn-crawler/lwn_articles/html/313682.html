        <!DOCTYPE html>
        <html lang="en">
        <head><title>Btrfs aims for the mainline [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/313682/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/313048/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/313682/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Btrfs aims for the mainline</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 7, 2009</br>
           </div>
The Btrfs filesystem has been under development for the last year or so;
for much of that time, it has been widely regarded as the most likely "next
generation filesystem" for Linux.  But, before it can claim that title,
Btrfs must stabilize and find its way into the mainline kernel.  Btrfs
developer Chris Mason has been saying for a while that he thinks the code
will come together more quickly if it is merged relatively soon, even if it
is not yet truly ready for production use.  General experience with kernel
development tends to support this position: in-tree code gets more review,
testing, and fixes than out-of-tree code.  So the development community as
a whole has been reasonably supportive of a relatively early Btrfs merge.
<p>
In <a href="http://lwn.net/Articles/302251/">our last Btrfs episode</a>,
Andrew Morton suggested that a 2.6.29 merge be targeted.
Chris would like that  happen; to that end, he has <a
href="http://lwn.net/Articles/313343/">posted a version of Btrfs</a> for
consideration.  Unsurprisingly, that posting has already increased the
amount of attention being paid to this code, with the result that Chris
quickly got a list of things to fix.  Most of those have now been
addressed, but there are a few remaining issues which could still impede
the merging of Btrfs in this development cycle.  This article will look at
the potential roadblocks.
<p>
One of those is the user-space API.  Btrfs brings with it a whole set of
new <tt>ioctl()</tt> calls, none of which have been seriously reviewed or
even documented.  These calls perform functions like creating snapshots,
initiating defragmentation, creating or resizing subvolumes, adding devices
to the volume set, etc.  Interestingly, there has been no real complaint
about the volume-management features of Btrfs in general.  But the
interface to features like that needs close scrutiny; normally, user-space
APIs cannot be broken once they are merged into the mainline.  There has
been some talk of making an exception for Btrfs, since there is little
chance of systems becoming dependent on a specific interface before Btrfs
is production-ready.  
<p>

Still, once distributions start shipping Btrfs tools - to help testers if
nothing else - an API change would cause pain.  Any potential for this kind
of pain would make API changes very hard to do.  So Linux may well end up
being stuck with the early Btrfs API.  Given that at least one developer <a
href="/Articles/313691/">thinks that this API needs a serious rework</a>,
this issue could turn out to be a serious roadblock indeed.

<p>
Then, there is the issue of the special-purpose locking primitives used in
Btrfs.  To understand this discussion, it's worth looking at the locking
function used within Btrfs:
<p>
<pre>
    int btrfs_tree_lock(struct extent_buffer *eb)
    {
	int i;

	if (mutex_trylock(&amp;eb-&gt;mutex))
	    return 0;
	for (i = 0; i &lt; 512; i++) {
	    cpu_relax();
	    if (mutex_trylock(&amp;eb-&gt;mutex))
		return 0;
	}
	cpu_relax();
	mutex_lock_nested(&amp;eb-&gt;mutex, BTRFS_MAX_LEVEL - btrfs_header_level(eb));
	return 0;
    }
</pre>
<p>

The lock in question is a mutex, but it is being acquired in an interesting
way.  If the lock is held by another process, this function will poll it up
to 512 times, without
sleeping, in the hope that it will become available quickly.  Should that
happen, the lock can be acquired without sleeping at all.  After 512
unsuccessful attempts, the function will finally give up and go to sleep.
<p>
Chris <a href="/Articles/313686/">justifies this behavior</a> this way:
<p>
<div class="BigQuote">
	Btrfs is using mutexes to protect the btree blocks, and btree
	searching often hits hot nodes that are always in cache.  For these
	nodes, the spinning is much faster, but btrfs also needs to be able
	to sleep with the locks held so it can read from the disk and do
	other complex operations.
<p>
	For btrfs, dbench 50 performance doubles with the unconditional spin,
	mostly because that workload is almost all in ram.
	For 50 procs creating 4k files in parallel, the spin is 30-50% faster.
	This workload is a mixture of disk bound and CPU bound.
</div>
<p>
That kind of performance increase seems worth going for.  In fact, it
reflects a phenomenon which has been observed in other situations as well:
even when sleeping locks are used, performance often improves if a
processor spins for a while in the hope that a contended lock will become
available.  If the lock can be acquired without sleeping, then the overhead
associated with putting the process to sleep and waking it up can be
avoided.  Beyond that, though, there is the fact that the process seeking
to acquire the lock is probably well represented in the CPU's cache.
Allowing that process to continue to run will, if the lock can be acquired
quickly, almost certainly lead to better system performance.
<p>
For this reason, the <a href="http://lwn.net/Articles/271817/">adaptive
realtime locks patch</a> was developed last year, though it never found its
way into the mainline.  In response to the Btrfs discussion, Peter Zijlstra
proposed <a href="http://lwn.net/Articles/313604/">a spinning mutex
patch</a> which is intended to provide the same benefits as the special
Btrfs locking function, but for more general use and without the addition
of magic constants.  In Peter's patch, an attempt to acquire a contended
lock will spin for as long as the process holding that lock is actually
running on a CPU.  If the lock holder goes to sleep, any process trying to
acquire the lock also goes to sleep.  The heuristic seems to make sense,
though detailed benchmarks have not been posted.
The patch was received reasonably
well, though Linus has <a href="/Articles/313687/">insisted</a> that some
changes be made.
<p>
So a more general spinning mutex may well find its way into the mainline.
Whether it will go in for 2.6.29 is not clear, though.  Developers tend to
like their core locking primitives to be reasonably well tested; merging
something which was developed toward the end of the merge window could be a
hard sell.  Until something like that happens, Chris is <a
href="/Articles/313688/">uninterested in removing his special locking
function</a>:
<p>
<div class="BigQuote">
	But, if anyone working on adaptive mutexes is looking for a coder,
	tester, use case, or benchmark for their locking scheme, my hand is
	up.  Until then, this is my for loop, there are many like it, but
	this one is mine.
</div>
<p>
Finally, there is the question of the name.  Some reviewers have suggested
that the filesystem should be merged with a name which makes it clear that
it's not meant for production use - "btrfsdev," for example.  Chris is
resistant to that idea, noting that, unlike existing filesystems, Btrfs is
known to be new and has no reputation for stability.  He has stated his
willingness to make the change, though, if it is truly considered to be
necessary.  Bruce Fields <a href="/Articles/313689/">pointed out</a> that
calling it "Btrfs" from the beginning could possibly burn future developers
who boot an old kernel (with a non-production Btrfs) after switching to
a newer, production-ready version of the filesystem.
<p>
All of this adds up to an uncertain fate for Btrfs in 2.6.29; there are a fair
number of open issues and it's late in the merge window.  Of course, Btrfs could
be merged after 2.6.29-rc1; since it is a completely new subsystem, it
won't cause regressions.
But if Linus concludes that there are enough loose ends in the current
Btrfs code, he may just decide to give it one more development cycle before
bringing it into the mainline.  So, while nobody seems to doubt that Btrfs
will go in, the question of when remains open.
<p>
(With any luck, we hope to have an authoritative article on Btrfs for this
page in the near future, once the author - you know who you are! - gets it
written.  Stay tuned.)<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Btrfs">Btrfs</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Btrfs">Filesystems/Btrfs</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Locking_mechanisms-Mutexes">Locking mechanisms/Mutexes</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/313682/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor313774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hand-waving about a phased sleep</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 17:27 UTC (Wed)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/313774/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Pardon me for engaging in some hand-waving, and not really knowing what the kernel developers have tried to do about this issue over time.<p>
Isn't the problem here that sleep and the following process wakeup are expensive? In the case that sleep might be necessary only for a short time, a phased sleep makes more sense in the context of multiprocessing or hyperthreads. Halt the processor, but leave the process context in place in the processor. Don't move the process context out of the processor until some time has passed. Handle wakeups during this period by restarting the processor.<p>First, you stop banging on the lock in a tight loop, and that's important because atomic operations make expensive use of inter-processor cache coordination, potentially keeping other processors from doing useful work for some time. Also, you get to put the CPU core to useful work if the stopped processor is actually a hyperthread.<p><i>Bruce</i>
      
          <div class="CommentReplyButton">
            <form action="/Articles/313774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hand-waving about a phased sleep</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 17:55 UTC (Wed)
                               by <b>johntb86</b> (subscriber, #53897)
                              [<a href="/Articles/313789/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's an interesting idea, but as far as I know to wake up the processor you'd need an IPI, so it's not exactly cheap. You'd also need to create a timer interrupt to wake up the processor if it's not woken up by some other method, so this could become a pretty expensive way to have the processor do no work for a while.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hand-waving about a phased sleep</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 18:26 UTC (Wed)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/313820/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Perhaps we need hardware support to make this work properly. A timed halt instruction, or a low-level atomic primitive that can wake a processor waiting for an address.
      
          <div class="CommentReplyButton">
            <form action="/Articles/313820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hand-waving about a phased sleep</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 21:29 UTC (Wed)
                               by <b>jlokier</b> (guest, #52227)
                              [<a href="/Articles/313872/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
x86 does have a primitive to wait on an address: monitor/mwait.<br>
It waits until the monitored location is modified by another processor.<br>
<p>
I read that it's a bit slow for this sort of thing.<br>
<p>
In principle, if it were fast (and it could be with MESI caches),<br>
it would be very well suited to replace all spinning waits.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor313937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hand-waving about a phased sleep</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 3:03 UTC (Thu)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/313937/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, what Peter Zijlstra has done (and we do in the -rt patch) is not to spin on any atomic operations. We simply spin and check a variable. For instance, when we fail to get the lock, we go into a loop, checking the lock owner, and if that owner is still running. No atomic operations involved. There are a few races in different implementations, but none of those races are detrimental. A missed race just means we may sleep when we could have gotten the lock (current behavior). When the lock owner changes, or the current owner goes to sleep, we try to retake the lock. If the owner is asleep, we then schedule.<br>
<p>
In the -rt patch, we are a bit more conservative and avoid these races, but we still do not spin on any atomics. Thus, we do not slow down the bus traffic of other CPUS.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor313854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">If API is in flux, how about not exposing it for now?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 20:06 UTC (Wed)
                               by <b>proski</b> (subscriber, #104)
                              [<a href="/Articles/313854/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      If the btrfs API is in flux, how about not exposing it for now?  It's not like the filesystem cannot be used without that API.  There are also more flexible ways of communicating with the kernel, such as configfs.
      
          <div class="CommentReplyButton">
            <form action="/Articles/313854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313868"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">If API is in flux, how about not exposing it for now?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 20:48 UTC (Wed)
                               by <b>masoncl</b> (subscriber, #47138)
                              [<a href="/Articles/313868/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unfortunately, the ioctls are required to use the filesystem.  The part that is most in flux is the system used to mount multi-device filesystems.<br>
<p>
This is just one ioctl, and keeping it around shouldn't be a problem for compatibility.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313868/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor314059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">If API is in flux, how about not exposing it for now?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 17:11 UTC (Thu)
                               by <b>nas</b> (subscriber, #17)
                              [<a href="/Articles/314059/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Why can't those ioctls be marked as experimental?  It's very difficult to design the perfect API up front.  Also, I don't see any need to rename the filesystem.  Just merge the darn thing already and mark it experimental.  I've got over 1 TB in my desktop machine (not really a whole lot of space nowdays) and I'm willing to devote some space to testing.  People who compile their own kernels should be able to deal with filesystem format changes.
      
          <div class="CommentReplyButton">
            <form action="/Articles/314059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor313864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 20:36 UTC (Wed)
                               by <b>jwb</b> (guest, #15467)
                              [<a href="/Articles/313864/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd like to hear how this lock-spinning loop behaves on a system with 1024 CPUs.  I'm sure it's swell on a dual-core, shared-cache, UMA machine but it sounds like it could practically grind to a halt on a many-way NUMA machine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 21:41 UTC (Wed)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/313877/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't it make spinning more worthwhile the more CPUs you have running?  The more other CPUs running, the more likely the lock will be released sooner than later, making the spinning instead of sleeping more likely to pay off, right?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 23:32 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/313897/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know that it'd cause things to grind to a halt on a NUMA under normal circumstances.  The cost of migrating lines goes up, sure, but you only get extra traffic when the busywaiter arrives just ahead of a lock-release.<br>
<p>
I'm sure it could cause some interesting thundering-herd behavior, though, if there are a lot of people waiting on the lock to release though.  If a large number of CPUs are in the busywaiting loop when the lock releases, things get really fun I suppose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor313873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 21:32 UTC (Wed)
                               by <b>MisterIO</b> (guest, #36192)
                              [<a href="/Articles/313873/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't it actually trying to acquire the lock for 513 times?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 23:21 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/313894/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I assume (but haven't checked) that the kernel's mutex functions do not have the 0 on success behaviour seen in pthread_mutex_trylock(3p)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 23:28 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/313896/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, or did you mean 513 as distinct from the 512 claimed by the author? No, this is the usual C idiom for doing something N times...<br>
<p>
for (int k = 0; k &lt; N; ++k) { /* do something */ }<br>
<p>
It won't do them N+1 times because after the Nth iteration k is N and will fail the condition (k &lt; N)<br>
<p>
(Actually mine is a slightly more modern idiom, requiring C9X semantics, and it has the K&amp;R increment style, but it amounts to the same thing)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor313895"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2009 23:25 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/313895/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <P>Are you commenting on the fact that the loop iterates 512 times in addition to the one try outside the loop?  The way I read the following, it tries once, and if it fails, it tries another 512 times:</P>
<BLOCKQUOTE>The lock in question is a mutex, but it is being acquired in an interesting way. If the lock is held by another process, this function will poll it up to 512 times, without sleeping, in the hope that it will become available quickly. Should that happen, the lock can be acquired without sleeping at all. After 512 unsuccessful attempts, the function will finally give up and go to sleep. </bLOCKQUOTE>
<P>So, yeah, it tries 513 times.  I guess it's hair-splitting as to exactly how many times it tries.  I think the point was "try several times just in case."</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/313895/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 4:16 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/313945/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Why not just get rid of the outer (top) if-statement altogether, and move the cpu_relax() statement to <i>after</i> the inner if-statement?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/313945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor314275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2009 17:57 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/314275/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Why not just get rid of the outer (top) if-statement altogether, and move the cpu_relax() statement to after the inner if-statement?
</blockquote>
<p>
In at least some systems, it is probably an extra instruction or two for the most common case -- that the lock is available immediately.  Lock algorithms are usually written this way.
<p>
Incidentally, as long as we're counting, it's 514.  mutex_lock_nested() will necessarily try to acquire the lock before going to sleep.

      
          <div class="CommentReplyButton">
            <form action="/Articles/314275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor313949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 4:25 UTC (Thu)
                               by <b>MisterIO</b> (guest, #36192)
                              [<a href="/Articles/313949/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I didn't mean to say I catched who knows what kind of big error, but if you sum the first attempt with the 512 into the loop, that's 513!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor313905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 0:00 UTC (Thu)
                               by <b>lmb</b> (subscriber, #39048)
                              [<a href="/Articles/313905/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have to admit that the idea of merging yet another RAID/volume management implementation, this time within a filesystem, does not make me very happy.<br>
<p>
However, the design of btrfs - its ability to have subvolumes etc - clearly shows the path forward. In a way, the block versus filesystem boundary blurs, and stops making sense. It would be interesting to consider if filesystems could be stacked like this too, so that "raid1" would simply become a filesystem consuming two containers/objects and providing a new object, on which a new filesystem can then be mounted ...<br>
<p>
Even if that is crazy talk, we really need more convergence here, not proliferation.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313918"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Actually RAID/volume management is superlimited when not in filesystem...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 1:57 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/313918/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>I have to admit that the idea of merging yet another 
RAID/volume management implementation, this time within a filesystem, does 
not make me very happy.</blockquote><p>Actually I can not imagine sane 
volume management outside of filesystem. For example here I have 4 HDD 
drivers in my system. What I <b>really</b> want?<br />
1. Keep most of the data on just one drive (for movies from my own 
DVDs).<br />
2. Keep the rest in RAID-5 form (for movies in games and such: PITA to 
reinstall but can be done if needed).<br />
3. Keep my own personal files (1% of total size or so) duplicated 4 times 
(on 4 HDDs).<br />
Pretty easy and simple requirements, right? Yet totally unachievable with 
usual LVM/filesystem separation. Currently btrfs can not support this mode 
of operation too, but potentially - it's doable...</p>

<p>P.S. Actually I got the idea after reading in <a 
href="http://labs.google.com/papers/gfs.html">GFS paper</a>: <i>Users can 
specify different replication levels for different parts of the file 
namespace</i>. I was dumbfound when read this: this is <b>exactly</b> what 
I need from normal filesystem - why it was never actually done? There are 
two answers:<br />
1. It's harder to do for normal filesystem (GFS works with huge chunks and 
so fragmentation is not an issue).<br />
2. RAID/volume management is separated from filesystem - there are just not 
enough info in filesystem to make in happen!</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/313918/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Actually RAID/volume management is superlimited when not in filesystem...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 2:54 UTC (Thu)
                               by <b>Da_Blitz</b> (guest, #50583)
                              [<a href="/Articles/313936/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
you can do some of the thinks you mentioned with LVM<br>
<p>
to keep most of the data on one partion you create a new pv with the vgcreate -p 1 &lt;name&gt; &lt;dev&gt; &lt;dev&gt;, -p  limits the maximum amount of physical volumes for pv<br>
<p>
while you cant do raid 5 in LVM (something i am assuming can be patched in) you can do RAID 1 using LVM with support for migrating the data from one drive to another should you remove or fail a drive, use lvcreate --mirrors 3 &lt;volume name&gt; &lt;pvname&gt;/-m<br>
<p>
this will create one partition that is mirrored to 3 other drives<br>
<p>
at the end you would end up with 2 volume groups, one for your DVDs that contains one lv partition and another volume group that includes all 4 drives that is replicated 4 times by lvm<br>
<p>
i would pay for raid5 support in lvm as i could then specify different levels of replication for different partitions like you suggested, <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/313936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I don't need volume groups!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 3:48 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/313943/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Yes, that's more or less how I do it today. But it's insane: I have a 
perfectly capable system developed to automate tasks, it can do billions of 
operations per second and yet it can not automagically reallocate space for 
me? Pathetic. Plus I want ALL metainformation keept on ALL drives: it's 
small amount of data, after all, and even if I can restore all files from 
DVDs it's certainly easier to do if I'll know what exactly was stored on 
that broken drive!</p>

<p>Sure I can develop a lot of palliatives (I do ls -lR regularly and 
store it on RAIDed partition), but it's all ugly and stupid.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/313943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor313956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I don't need volume groups!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 5:43 UTC (Thu)
                               by <b>Ze</b> (guest, #54182)
                              [<a href="/Articles/313956/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p><i>In reply to: Actually RAID/volume management is superlimited when not in filesystem... by Da_Blitz
Parent article: Btrfs aims for the mainline

Yes, that's more or less how I do it today. But it's insane: I have a perfectly capable system developed to automate tasks, it can do billions of operations per second and yet it can not automagically reallocate space for me? Pathetic. Plus I want ALL metainformation keept on ALL drives: it's small amount of data, after all, and even if I can restore all files from DVDs it's certainly easier toes, that's more or less how I do it today. But it's insane: I have a perfectly capable system developed to automate tasks, it can do billions of operations per second and yet it can not automagically reallocate space for me? Pathetic. Plus I want ALL metainformation keept on ALL drives: it's small amount of data, after all, and even if I can restore all files from DVDs it's certainly easier to do if I'll know what exactly was stored on that broken drive!

Sure I can develop a lot of palliatives (I do ls -lR regularly and store it on RAIDed partition), but it's all ugly and stupid.

 do if I'll know what exactly was stored on that broken drive!</p></i>

<p>So what you really want is one logical volume with arbitrary tags on block allocation and replication on a per file basis.</p>

<p>Tux3 approach of keeping metadata information in normal files strikes me as being the nicest way to map meta-data onto multiple physical volumes.</p>

<p>Perhaps in the future we'll handle proper separation of concerns when it comes to different layers properly instead of munging em all in one.</p>

<p>The real bitch though with that is backward compatibility.</p>

<p>Since we'd effectively be splitting existing file systems up into two separate concerns , a block format and a file system format composed of blocks.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/313956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor314007"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Actually RAID/volume management is superlimited when not in filesystem...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 11:51 UTC (Thu)
                               by <b>lmb</b> (subscriber, #39048)
                              [<a href="/Articles/314007/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure; you want redundancy, encryption etc being managed at the file/directory object level. That makes perfect sense, and is exactly what I was hinting at by being able to stack "filesystems".<br>
<p>
But we need a general solution for that. Not yet a 3rd one inside one component. Or, rather, maybe we need to start with that now, and then phase out or at least depreciate the past.<br>
<p>
But what we definitely don't need is three or more permanent solutions to this problem.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314007/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor314056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Actually RAID/volume management is superlimited when not in filesystem...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 16:58 UTC (Thu)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/314056/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 1. Keep most of the data on just one drive (for movies from my own DVDs).</font><br>
<font class="QuotedText">&gt; 2. Keep the rest in RAID-5 form (for movies in games and such: PITA to </font><br>
<font class="QuotedText">&gt; reinstall but can be done if needed).</font><br>
<font class="QuotedText">&gt; 3. Keep my own personal files (1% of total size or so) duplicated 4 times &gt; (on 4 HDDs).</font><br>
<font class="QuotedText">&gt; Pretty easy and simple requirements, right? Yet totally unachievable with </font><br>
<font class="QuotedText">&gt; usual LVM/filesystem separation. Currently btrfs can not support this mode &gt; of operation too, but potentially - it's doable...</font><br>
<p>
What's wrong with using partitions and bind mounts?<br>
<p>
3) A partition that's mirrored on all disks<br>
2) A RAID 5 (yuck!) using partition on 3 disks<br>
1) A partition for your data disk<br>
<p>
You can bind mount stuff to be at convenient points in the filesystem hierarchy.  That is "specifiying different methods of replication for different parts of the namespace".<br>
<p>
( Frankly if you have 4 disks, then I'd rather stripe, lower level mirrors with RAID 10 and accept the lower capacity for the performance and reliability benefits of avoiding RAID5 in a 3 disk configuration. )<br>
<p>
Using a RAID layer to do RAID<br>
An LVM layer to provide logical volumes (caveat on FS barriers)<br>
File System layer to hand filesystem structure, and journalling<br>
<p>
Would appear like a logical structure, though it does require initial planning.<br>
<p>
Perhaps you want to be able to expand the alloted space, given over to RAID1, RAID5, RAID10 etc?<br>
<p>
Couldn't that be done, by using LVM type block devices, used by the RAID layer which is then exposed to filesystems, so they can grow/shrink their capacity, as chunks of disk are (de)allocated to partitions?<br>
<p>
<p>
Call me a cynic if you like but pushing every feature you could want into 1 layer, the filesystem, which should then become a generic dynamic disk management system, would appear to become a very complicated monolithic block of code.  If sane implementations would then use generic layers, then you're really back to where you started.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor314085"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That's the setup I have - and HATE it</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 18:03 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/314085/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Perhaps you want to be able to expand the alloted space, given 
over to RAID1, RAID5, RAID10 etc?</blockquote><p>I want to forget words 
"RAID", "LVM" and related. <b>Forever.</b> I want <b>sane</b> options. 
Like:<br/>
A. Store data cheaply (say... $0.10/GB) but unreliably: single disk failure 
- and be ready to redownload/reinstall)<br/>
B. Store data reliably but expensively ($.40/GB): up to three disks 
can fail without any problems<br/>
C. Some intermediate versions: cheap and reliable ($0.12/GB to $0.15/GB), 
Ok with single disk failure (if it'll happen OS will of course 
restore status quo if possible), but sloooooow (still much faster then 
DVD).<br/>
Just like filesystems were invented to make unnecessary manual manageent of 
data on a single disk I want <b>something</b> to hide all this RAID/LVM/etc 
stuff from me. Will it be btrfs or stack of other technologies - I don't 
care as long as I have nice simple option list in "Save As..." dialog.</p>

<blockquote>Couldn't that be done, by using LVM type block devices, used by 
the RAID layer which is then exposed to filesystems, so they can 
grow/shrink their capacity, as chunks of disk are (de)allocated to 
partitions?</blockquote><p>May be. But then - it'll need huge, very complex 
schemes to make it work well as whole. This is "microkernel vs monolitic 
kernel" discussion all over again.</p>

<blockquote>Call me a cynic if you like but pushing every feature you could 
want into 1 layer, the filesystem, which should then become a generic 
dynamic disk management system, would appear to become a very complicated 
monolithic block of code. If sane implementations would then use generic 
layers, then you're really back to where you started.</blockquote><p>Huh? 
Why "monolithic block of code"??? I'm perfectly happy with separating of 
functions - different filesystems are free to use the same implementation 
of RAID, LVM, etc - if their authors decide it's the best way to do things. 
Just as long as it's not exposed to userspace (or at least to user).</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314085/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor314094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That's the setup I have - and HATE it</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 18:56 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/314094/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
what you want isn't anything resembling a traditional filesystem. what you want is something like the 'object based storage' things that are being discussed (but you want something far more complex than what has been proposed, let alone implemented or accepted).<br>
<p>
defining the redundancy for each file as it is saved will also require changes to every single program out there, which is very unlikely to happen.<br>
<p>
if you are willing to deal with different directories having different redundancy options, then what you want is doable today, with no kernel changes. it just needs userspace tools written to make it easier to deal with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor314105"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That's the setup I have - and HATE it</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 20:11 UTC (Thu)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/314105/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; defining the redundancy for each file as it is saved will also require </font><br>
<font class="QuotedText">&gt; changes to every single program out there, which is very unlikely to happen.</font><br>
<p>
Probably a lot of ppl still expect filesystems to be fast, and having every node in the hierarchy and all files, having some different form of backing storage depending on redundancy requirements...   *sucks through teeth* sounds expensive to me.<br>
<p>
The "I want to know nothing" and just have it managed by some kind of Storage management system that takes care of details, does sound a better requirement to me.<br>
<p>
<p>
Actually I don't think "every program" would need modifying, as when files are created, they can inherit the characteristics of the parent directory, as would new sub-directories.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314105/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor314110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That's the setup I have - and HATE it</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 20:26 UTC (Thu)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/314110/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Huh? Why "monolithic block of code"??? I'm perfectly happy with </font><br>
<font class="QuotedText">&gt; separating of functions - different filesystems are free to use the same </font><br>
<font class="QuotedText">&gt; implementation of RAID, LVM, etc - if their authors decide it's the best </font><br>
<font class="QuotedText">&gt; way to do things. Just as long as it's not exposed to userspace (or at </font><br>
<font class="QuotedText">&gt; least to user).</font><br>
<p>
Well you seemed to imply it by saying you couldn't imagine it being down outside of the filesystem.<br>
<p>
Permitting layers, I could imagine some specialised "meta" filesystem being feasible, that would give you a name space, that lets you tag directories and files with storage characteristics using more traditional type file systems as backing stores for bulk data storage.  The real files might end up in a file hierarchy, spread over a number of volumes a bit like http proxy caches, to provide manageable chunks of RAID1, RAID0, RAID5, RAID10 storage, which can be increased (and freed) on demand by the Disk Management System.<br>
<p>
The only thing is, how many ppl would actually need that?  And if it were provided, how many would ever use funky "Save As" options, in applications, compared to the number who would whinge about excessive options, being confusing and unclean in their precious GUI? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor314282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">That's the setup I have - and HATE it</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2009 18:43 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/314282/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Permitting layers, I could imagine some specialised "meta" filesystem being feasible, that would give you a name space, that lets you tag directories and files with storage characteristics using more traditional type file systems as backing stores for bulk data storage.
</blockquote>
<p>
I believe you're describing object storage.  The lower of those layers is the object layer.  But it differs from a traditional filesystem in that the only names the objects (files) have are made up by the system (essentially, inode numbers).
<p>
In most of the work on object storage, that layer actually lives in a hardware unit separate from the one with the POSIX filesystem image, but it could be in the kernel between the filesystem drivers and the block device drivers as well (if it hasn't been done already).
<p>
But we do need to ask whether there is a need to have more than one future filesystem type with this kind of storage function before we put a lot of effort into making a reusable layer.

      
          <div class="CommentReplyButton">
            <form action="/Articles/314282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor315330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Actually RAID/volume management is superlimited when not in filesystem...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2009 0:02 UTC (Fri)
                               by <b>topher</b> (guest, #2223)
                              [<a href="/Articles/315330/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>What you're asking for is quite doable right now, using RAID+LVM 
(actually, only RAID is needed).</p>

<p><em>1. Keep most of the data on just one drive (for movies from my own 
DVDs).<br />
2. Keep the rest in RAID-5 form (for movies in games and such: PITA to 
reinstall but can be done if needed).<br />
3. Keep my own personal files (1% of total size or so) duplicated 4 times 
(on 4 HDDs).</em></p>

<p>Assuming 4 500GB Disks:<br />
Drive 1: 10GB partition, RAID1; 490GB partition, stand alone<br />
Drive 2: 10GB partition, RAID1; 490GB partition, RAID5<br />
Drive 3: 10GB partition, RAID1; 490GB partition, RAID5<br />
Drive 4: 10GB partition, RAID1; 490GB partition, RAID5</p>

<p>The 10GB partitions are all part of a 4x replicated RAID1 for your 
personal files.  For additional redundancy across the system, put /boot and 
/ on that RAID1 also, install GRUB on the bootloader for each disk, and you 
can lose any disk and boot the system.  The stand alone 490GB partition is 
for your movies.  The 3 490GB partitions in the RAID5 are for the rest of 
your stuff.</p>

<p>It's not required, but you could make use of LVM on top of those to more 
easily split things out as desired.</p>

<p>What you're asking for in a couple of your other posts, however, is not 
a simple thing.  It doesn't fit well with how computers work in general.  
You seem to be saying you want to just save something and have the computer 
magically understand that it's "important" or "not important" or "kind of 
important" and know what that means.  But computers don't do that.  Someone 
has to tell them what each of those categories means, and how they're 
defined.  And since it's your data, it's going to be hard for someone else 
to do that.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/315330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor315496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Actually RAID/volume management is superlimited when not in filesystem...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2009 21:34 UTC (Sat)
                               by <b>speedster1</b> (guest, #8143)
                              [<a href="/Articles/315496/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>What you're asking for in a couple of your other posts, however, is not a simple thing. It doesn't fit well with how computers work in general. You seem to be saying you want to just save something and have the computer magically understand that it's "important" or "not important" or "kind of important" and know what that means. But computers don't do that. Someone has to tell them what each of those categories means, and how they're defined. And since it's your data, it's going to be hard for someone else to do that.</i>
<p>
I don't think this automatic classification of "importance" is really the killer feature khim is pining for! There are a couple of key things that are painful or impossible with current LVM+RAID (which khim does know about and is currently using, for lack of a better alternative):
<ol>
<li>allocation of space among the areas of differing redundancy</li>
<li>ability to store metadata in a higher-redundancy area than the corresponding normal data</li>
</ol>

If the normal filesystem in your example 10GB partition of high-redundancy storage fills up, your app will get an out-of-space error and you will have to hack around with LVM tools to try to reclaim some space from that big RAID 5 partition. Are you at all confident that a typical user could shrink it safely? I think a typical user would end up having to buy more disks, even though there was lots of unused space in the existing disks!
<p>
In a smart filesystem that handled levels of redundancy internally, you would not have this problem at all. The filesystem would have one big pool of storage, and would create additional regions of high redundancy as needed.
<p>
I know it is possible to put filesystem journals on separate partitions, but I don't think point #2 is even possible with current filesystems.
      
          <div class="CommentReplyButton">
            <form action="/Articles/315496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor315513"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Actually RAID/volume management is superlimited when not in filesystem...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2009 0:33 UTC (Sun)
                               by <b>Kamilion</b> (subscriber, #42576)
                              [<a href="/Articles/315513/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
... Yknow, you've basically just described ZFS on OpenSolaris. Check it out.<br>
<p>
There's already a FUSE module for linux. If someone bothered reimplimenting the ZFS filesystem with FUSE, shouldn't it be much easier to use it as the basis of a cleanroom GPL2 kernel implementation of ZFS?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/315513/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor314126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2009 20:52 UTC (Thu)
                               by <b>masoncl</b> (subscriber, #47138)
                              [<a href="/Articles/314126/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Andrew Morton recently asked about why the device management in the FS makes sense.  The thread covered a bunch of ground:<br>
<p>
<a href="http://article.gmane.org/gmane.comp.file-systems.btrfs/1764">http://article.gmane.org/gmane.comp.file-systems.btrfs/1764</a><br>
<p>
The most important reason in my mind is connecting the transaction domains of the storage management with the rest of the filesystem.  It makes it much more efficient to move storage around without having to wonder if the FS is currently using it.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor314165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2009 0:29 UTC (Fri)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/314165/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting.<br>
<p>
Presumbably there's similar issues with the "array of blocks/bytes" idea, when it comes to disks themselves.  It shows with Flash, where it'd be nice to let the device know blocks are unused.  Perhaps with bad block reallocation to on disks, which might have unpleasant consequences for journal files (without barriers).<br>
<p>
It used to be, that disks were always damn near full, so you didn't really gain anything by not doing a raw partition copy when transfering data from one disk to another.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/314165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor315088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Btrfs aims for the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2009 6:25 UTC (Thu)
                               by <b>angelortega</b> (guest, #1306)
                              [<a href="/Articles/315088/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've translated this article to spanish here: <br>
<a href="http://triptico.com/docs/lwn_313682.html">http://triptico.com/docs/lwn_313682.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/315088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
