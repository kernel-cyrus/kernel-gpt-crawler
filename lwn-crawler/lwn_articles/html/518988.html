        <!DOCTYPE html>
        <html lang="en">
        <head><title>An f2fs teardown [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/518988/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/518561/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/518988/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>An f2fs teardown</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>October 10, 2012</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>
When a techno-geek gets a new toy there must always be an urge to take
it apart and see how it works.  Practicalities (and warranties)
sometimes suppress that urge, but in the case of <tt>f2fs</tt> and this geek,
the urge was too strong.  What follows is the result of taking apart
this new filesystem to see how it works.
</p><p>
<tt>f2fs</tt> (interestingly not "<tt>f3s</tt>") is the "flash-friendly file
system", a
new filesystem for Linux recently
<a href="/Articles/518717/">announced</a>
by engineers from Samsung.  Unlike <tt>jffs2</tt>
and <tt>logfs</tt>, <tt>f2fs</tt> is not
targeted at raw flash
devices, but rather at the specific hardware that is commonly
available to consumers &mdash; SSDs, eMMC, SD cards, and other flash
storage with an 
<a href="http://en.wikipedia.org/wiki/Flash_file_system#Translation_layers">FTL</a>
(flash translation layer) already built in.
It seems that as hardware
gets smarter, we need to make even more clever software to manage that
"smartness".  Does this sound like parenting to anyone else?
</p><p>
<tt>f2fs</tt> is based on the log-structured filesystem (LFS) design &mdash; which
is hardly surprising given the
<a href="/Articles/353411/">close match</a> between the log-structuring
approach and the needs of flash. 
For those not familiar with log-structured design, the key elements
are:
<ol>
<li>That it requires copy-on-write, so data is always written to
   previously unused space.</li>
<p>
<li>That free space is managed in large regions which are written to
   sequentially.  When the number of free regions gets low, data that
   is still live is coalesced from several regions into one free
   region, thus creating more free regions.  This process is known as
   "cleaning" and the overhead it causes is one of the significant costs
   of log structuring.</li>
</ol>
</p><p>
As the FTL typically uses a log-structured
design to provide the wear-leveling and write-gathering that flash
requires, this means that there are two log structures active on the
device &mdash; one in the firmware and one in the operating system.
<tt>f2fs</tt> is explicitly designed to make use of this fact and leaves a
number of tasks to the FTL while focusing primarily on those tasks
that it is well positioned to perform.  So, for example, <tt>f2fs</tt> makes no
effort to distribute writes evenly across the address space to provide
wear-leveling.
</p><p>
The particular value that <tt>f2fs</tt> brings, which can justify it being
"flash friendly", is that it provides large-scale write gathering so
that when lots of blocks need to be written at the same time they are
collected into large sequential writes which are much easier for the
FTL to handle.  Rather than creating a single large write, <tt>f2fs</tt>
actually creates up to six in parallel.  As we shall see,
these are assigned different sorts of blocks with different life
expectancies.  Grouping blocks with similar life expectancies together
tends to make the garbage collection process required by the LFS less expensive.
</p><p>
The "large-scale" is a significant qualifier &mdash; <tt>f2fs</tt> doesn't always
gather writes into contiguous streams, only almost always.  Some
metadata, and occasionally even some regular data, is written via
random single-block writes.  This would be anathema for a regular
log-structured filesystem, but <tt>f2fs</tt> chooses to avoid a lot of
complexity 
by just doing small updates when necessary and leaving the FTL to make
those corner cases work.
</p><p>
Before getting into the details of how <tt>f2fs</tt> does what it does, a brief
list of some of the things it doesn't do is in order.
</p><p>
A feature that we might expect from a copy-on-write filesystem is
cheap snapshots as they can be achieved by simply not freeing up the
old copy.  <tt>f2fs</tt> does not provide these and cannot in its current form
due to its two-locations approach to some metadata which will be detailed
later.
</p><p>
Other features that are missing are usage quotas, NFS export, and the
"security" flavor of extended attributes (xattrs).  Each of these
could probably be added with minimal effort if they are needed, though
integrating quotas correctly with the crash recovery would be the most
challenging.  We shouldn't be surprised to see some of these in a future
release.
</p>
<h4>Blocks, segments, sections, and zones</h4>
<p>
Like most filesystems, <tt>f2fs</tt> is comprised of blocks.  All blocks
are 4K in size, though the code implicitly links the block size with
the system page size, so it is unlikely to work on systems with larger
page sizes as is possible with IA64 and PowerPC.  The block addresses
are 32 bits so the total number of addressable bytes in the filesystem is at most 2<sup>(32+12)</sup> bytes or 16 terabytes.  This is probably not a
limitation &mdash; for current flash hardware at least.
</p><p>
Blocks are collected into "segments".  A segment is 512 blocks or 2MB
in size.  The documentation describes this as a default, but this size
is fairly deeply embedded in the code.  Each segment has a segment
summary block which lists the owner (file plus offset) of each block
in the segment.  The summary is primarily used when cleaning to
determine which blocks need to be relocated and how to update the
index information after the relocation.  One block can comfortably
store summary information for 512 blocks (with a bit of extra space
which has other uses), so 2MB is the natural size for a segment.
Larger would be impractical and smaller would be wasteful.
</p><p>
Segments are collected into sections.  There is genuine flexibility in
the size of a section, though it must be a power of two.  A section
corresponds to a "region" in the outline of log structuring given above.  A
section is normally filled from start to end before looking around for
another section, and the cleaner processes one section at a time.
The default size when using the <tt>mkfs</tt> utility is 2<sup>0</sup>, or
one segment per section. 
</p><p>
<tt>f2fs</tt> has six sections "open" for writing at any time with
different sorts of data being written to each one.   The different sections
allows for file content (data) to be kept separate from indexing
information (nodes), and for those to be divided into "hot", "warm",
and "cold" according to various heuristics.  For example, directory
data is treated as hot and kept separate from file data because they have
different life expectancies.   Data that is cold is 
expected to remain unchanged for quite a long time, so a section full of cold
blocks is likely to not require any cleaning.  Nodes that are hot are expected
to be updated soon, so if we wait a little while, a section that was full of hot
nodes will have very few blocks that are still live and thus will be cheap to
clean.
</p><p>
Sections are collected into zones.  There may be any (integer) number
of sections in a zone though the default is again one.  The sole
purpose of zones is to try to keep these six open sections in different
parts of the device.  The theory seems to be that flash devices are
often made from a number of fairly separate sub-devices each of which
can process IO requests independently and hence in parallel.  If zones
are sized to line up with the sub-devices, then the six open sections
can all handle writes in parallel and make best use of the
device.
</p><p>
These zones, full of sections of segments of blocks, make up the
"main" area of the filesystem.  There is also a "meta" area which
contains a variety of different metadata such as the segment summary
blocks already mentioned.   This area is not managed following normal
log-structured lines and so leaves more work for the FTL to do.
Hopefully it is small enough that this isn't a problem.
</p><p>
There are three approaches to management of writes in this area.
First, there is a small amount of read-only data (the superblock)
which is never written once the filesystem has been created.  Second,
there are the segment summary blocks which have already been
mentioned.  These are simply updated in-place.  This can lead to
uncertainty as to the "correct" contents for the block after a crash,
however for segment summaries this is not an actual problem.  The
information in it is checked for validity before it is used, and if
there is any chance that information is missing, it will be recovered
from other sources during the recovery process.
</p><p>
The third approach involves allocating twice as much space as is
required so that each block has two different locations it can exist
in, a primary and a secondary.  Only one of these is "live" at any time
and the copy-on-write requirement of an LFS is met by simply writing to
the non-live location and updating the record of which is live.
This approach to metadata is the main impediment to providing snapshots.
<tt>f2fs</tt> does a small amount of journaling of updates to this last group
while creating a checkpoint, which might ease the task for the FTL
somewhat.
</p>
<h4>Files, inodes, and indexing</h4>
<p>
Most modern filesystems seem to use B-trees or similar structures for
managing indexes to locate the blocks in a file.  In fact they are
so fundamental to <tt>btrfs</tt> that it takes its name from that data
structure.  <tt>f2fs</tt> doesn't.  Many filesystems reduce the size of the
index by the use of "extents" which provide a start and length of a
contiguous list of blocks rather than listing all the addresses
explicitly.  Again, <tt>f2fs</tt> doesn't (though it does maintain one extent
per inode as a hint).
</p><p>
Rather, <tt>f2fs</tt> uses an indexing tree that is very reminiscent of the
original Unix filesystem and descendants such as ext3.  The inode
contains a list of addresses for the early blocks in the file, then
some addresses for indirect blocks (which themselves contain more
addresses) as well as some double and triple-indirect blocks.  While
ext3 has 12 direct addresses and one each of the indirection addresses,
<tt>f2fs</tt> has 929 direct address, two each of indirect and double-indirect
addresses, and a single triple-indirect address.  This allows the
addressing of nearly 4TB for a file, or one-quarter of the maximum filesystem
size.
</p><p>
While this scheme has some costs &mdash; which is why other filesystems have
discarded it &mdash; it has a real benefit for an LFS.  As <tt>f2fs</tt> does not use
extents, the index tree for a given file has a fixed and known size.
This means that when blocks are relocated through cleaning, it is
impossible for changes in available extents to cause the indexing tree
to get bigger &mdash; which could be embarrassing when the point of
cleaning is to free space.  <tt>logfs</tt>, another reasonably modern
log structured filesystem for flash, uses much the same arrangement
for much the same
<a href="http://lca2007.linux.org.au/talk/91.html">reason</a>.
</p><p>
Obviously, all this requires a slightly larger inode than <tt>ext3</tt> uses.
Copy-on-write is rather awkward for objects that are smaller than the
block size so <tt>f2fs</tt> reserves a full 4K block for each inode which
provides plenty of space for indexing.  It even provides space to
store the (base) name of the file, or one of its names, together with
the inode number of the parent.  This simplifies the recovery of
recently-created files during crash recovery and reduces the number of
blocks that need to be written for such a file to be safe.
</p><p>
Given that the inode is so large, one would expect that small files and
certainly small symlinks would be stored directly in the inode, rather
than just storing a single block address and storing the data
elsewhere.  However <tt>f2fs</tt> doesn't do that.  Most likely the reality is
that it doesn't do it <i>yet</i>.  It is an easy enough optimization
to add, so it's unlikely to remain absent for long.
</p><p>
As already mentioned, the inode contains a single extent that is a
summary of some part of the index tree. It says that some range of blocks
in the file are contiguous in storage and gives the address of this
range.  The filesystem attempts to keep the largest extent recorded
here and uses it to speed up address lookups.  For the common case of a
file being written sequentially without any significant pause, this should
result in the entire file being in that one extent, and make lookups in the
index tree unnecessary.
</p><p>
Surprisingly, it doesn't seem there was enough space to store 64-bit
timestamps, so instead of nanosecond resolution for several centuries
in the future, it only provides single-second resolution until some
time in 2038.  This oversight was
<a href="/Articles/519032/">raised on linux-kernel</a>
and may well be 
addressed in a future release.
</p><p>
One of the awkward details of any copy-on-write filesystem is that
whenever a block is written, its address is changed, so its parent
in the indexing tree must change and be relocated, and so on up to the
root of the tree.  The logging nature of an LFS means that
roll-forward during recovery can rebuild recent changes to the indexing tree so all
the changes do not have to be written immediately, but they do have to
be written eventually, and this just makes more work for the cleaner.
</p><p>
This is another area when <tt>f2fs</tt> makes use of its underlying FTL and
takes a short-cut.  Among the contents of the "meta" area is a NAT &mdash;
a Node Address Table.  Here "node" refers to inodes and to indirect
indexing blocks, as well as blocks used for xattr storage.  When the address of
an inode is stored in a directory, or an index block is stored in
an inode or another index block, it isn't the block address that is
stored, but rather an offset into the NAT.  The actual block address
is stored in the NAT at that offset.  This means that when a data
block is written, we still need to update and write the node that points to it.  But writing that node only requires updating the NAT
entry.  The NAT is part of the metadata that uses two-location journaling
(thus depending on the FTL for write-gathering) and so does not require further
indexing.
</p>
<h4>Directories</h4>
<p>
An LFS doesn't really impose any particular requirements on the layout
of a directory, except to change the fewest number of blocks
possible, which is generally good for performance anyway.  So we can
assess <tt>f2fs</tt>'s directory structure on an equal footing with other
filesystems.  The primary goal is to provide fast lookup by file name,
and to provide a stable address of each name that can be reported
using <tt>telldir()</tt>.
</p><p>
The original Unix filesystem (once it had been adjusted for 256-byte
file names) used the same directory scheme as <tt>ext2</tt> &mdash; sequential search
though a file full of directory entries.  This is simple and
effective, but doesn't scale well to large directories.
</p><p>
More modern filesystems such as <tt>ext3</tt>, <tt>xfs</tt>,
and <tt>btrfs</tt> use various
schemes involving B-trees, sometimes indexed by a hash of the file
name.  One of the problems with B-trees is that nodes sometimes need
to be split and this causes some directory entries to be moved around
in the file.  This results in extra challenges to provide stable
addresses for <tt>telldir()</tt> and is probably the reason that <tt>telldir()</tt> is often
called out for being a poor interface.
</p><p>
<tt>f2fs</tt> uses some sequential searching and some hashing to provide a
scheme that is simple, reasonably efficient, and
trivially provides stable <tt>telldir()</tt> addresses.  A lot of the hashing
code is borrowed from ext3, however f2fs omits the use of a per-directory seed.
This seed is a secret random number which ensures that the hash values used are
different in each directory, so they are not predictable.  Using such a seed
provides protection against hash-collision attacks.  While these might be
unlikely in practice, they are so easy to prevent that this omission is a
little surprising.
</p><p>
It is easiest to think of the directory structure as a series of hash
tables stored consecutively in a file.  Each hash table has a number of fairly large buckets.  A
lookup proceeds from the first hash table to the next, at each stage
performing a linear search through the appropriate bucket, until
either the name is found or the last hash table has been searched.
During the search, any free space in a suitable bucket is recorded
in case we need to create the name.
</p><p>
The first hash table has exactly one bucket which is two blocks in
size, so for the first few hundred entries, a simple linear search is
used.  The second hash table has two buckets, then four, then eight
and so on until the 31st table with about a billion buckets, each two
blocks in size.  Subsequent hash tables &mdash; should you need that many &mdash;
all have the same number of buckets as the 31st, but now they are four
blocks in size.
</p><p>
The result is that a linear search of several hundred entries can be required,
possibly progressing through quite a few blocks if the directory is very large.
The length of this search increases only as the logarithm of the number of
entries in the directory, so it scales fairly well.  This is certainly
better than a purely sequential search, but seems like it could be a
lot more work than is really necessary.  It does however guarantee
that only one block needs to be updated for each addition or deletion
of a file name, and since entries are never moved, the offset in the
file is a stable address for <tt>telldir()</tt>, which are valuable features.
</p>
<h4>Superblocks, checkpoints, and other metadata</h4>
<p>
All filesystems have a superblock and <tt>f2fs</tt> is no different.  However
it does make a clear distinction between those parts of the superblock
which are read-only and those which can change.  These are kept in two
separate data structures.
</p><p>
The <tt>f2fs_super_block</tt>, which is stored in the second block of
the device, contains only read-only data. Once the filesystem is
created, this is never changed.  It describes how big the filesystem
is, how big the segments, sections, and zones are, how much space has
been allocated for the various parts of the "meta" area, and
other little details.
</p><p>
The rest of the information that you might expect to find in a
superblock, such as the amount of free space, the address of the
segments that should be written to next, and various other volatile
details, are stored in an <tt>f2fs_checkpoint</tt>.  This "checkpoint"
is one of the metadata types that follows the two-location approach to
copy-on-write &mdash; there are two adjacent segments both of which store a
checkpoint, only one of which is current. The
checkpoint contains a version number so that when the filesystem is
mounted, both can be read and the one with the higher version number
is taken as the live version.
</p><p>
We have already mentioned the Node Address Table (NAT) and Segment
Summary Area (SSA) that also occupy the meta area with the superblock
(SB) and Checkpoints (CP).  The one other item of metadata is the
Segment Info Table or SIT.
</p><p>
The SIT stores 74 bytes per segment and is kept separate from the
segment summaries because it is much more volatile.  It primarily keeps
track of which blocks are still in active use so that the segment can
be reused when it has no active blocks, or can be cleaned when the
active block count gets low.
</p><p>
When updates are required to the NAT or the SIT, <tt>f2fs</tt> doesn't make them
immediately, but stores them in memory until the next checkpoint is
written.  If there are relatively few updates then they are not written
out to their final home but are instead journaled in some spare space
in Segment Summary blocks that are normally written at the same time.  If the
total amount of updates that are required to Segment Summary blocks
is sufficiently small, even they are not written and the SIT, NAT,
and SSA updates are all journaled with the Checkpoint block &mdash; which is
always written during checkpoint.  Thus, while <tt>f2fs</tt> feels free to leave
some work to the FTL, it tries to be friendly and only performs random
block updates when it really has to.  When <tt>f2fs</tt> does need to perform
random block updates it will perform several of them at once, which
might ease the burden on the FTL a little.
</p>
<h4>Knowing when to give up</h4>
<p>
Handling filesystem-full conditions in traditional filesystems is
relatively easy.  If no space is left, you just return an error.
With a log-structured filesystem, it isn't that easy.  There might be a
lot of free space, but it might all be in different sections and so it
cannot be used until those sections are "cleaned", with the live data
packed more densely into fewer sections.  It usually makes sense to
over-provision a log-structured filesystem so there are always free
sections to copy data to for cleaning.
</p><p>
The FTL takes exactly this approach and will over-provision to both allow
for cleaning and to allow for parts of the 
device failing due to excessive wear.  As the FTL handles
over-provisioning internally there is little point in <tt>f2fs</tt> doing it as
well.  So when <tt>f2fs</tt> starts running out of space, it essentially gives
up on the whole log-structured idea and just writes randomly
wherever it can.  Inodes and index blocks are still handled
carefully and there is a small amount of over-provisioning for them,
but data is just updated in place, or written to any free block that
can be found.  Thus you can expect performance of <tt>f2fs</tt> to degrade when
the filesystem gets close to full, but that is common to a lot of
filesystems so it isn't a big surprise.
</p>
<h4>Would I buy one?</h4>
<p>
<tt>f2fs</tt> certainly seems to contain a number of interesting ideas, and a
number of areas for possible improvement &mdash; both attractive attributes.
Whether reality will match the promise remains to be seen.  One area
of difficulty is that the shape of an <tt>f2fs</tt> (such as section and zone
size) needs to be tuned to the particular flash device and its FTL; vendors are notoriously secretive about exactly how their FTL
works.  f2fs also requires that the flash device is comfortable
having six or more concurrently "open" write areas.  This may not be a
problem for Samsung, but does present some problems for your average
techno-geek &mdash; though Arnd Bergmann has <a
href="/Articles/428584/">done some 
research</a> that may prove useful.  If this leads to people reporting performance results
based on experiments where the <tt>f2fs</tt> isn't tuned properly to the
storage device, it could be harmful for the project as a whole.
</p><p>
<tt>f2fs</tt> contains a number of optimizations which aim to ease the burden
on the FTL.  It would be very helpful to know how often these actually
result in a reduction in the number of writes.  That would help
confirm that they are a good idea, or suggest that further refinement
is needed.  So, some gathering of statistics about how often the
various optimizations fire would  help increase confidence in the
filesystem.
</p><p>
<tt>f2fs</tt> seems the have been written without much expectation of highly
parallel workloads.  In particular, all submission of write requests
are performed under a single semaphore.  So <tt>f2fs</tt> probably isn't the
filesystem to use for big-data processing on 256-core work-horses.  It
should be fine on mobile computing devices for a few more years though.
</p><p>
And finally, lots of testing is required.  Some preliminary performance
measurements have been
<a href="/Articles/519033/">posted</a>, but to get a
fair comparison you really need an "aged" filesystem and a large mix
of workloads.  Hopefully someone will make the time to do the testing.
</p><p>
Meanwhile, would I use it?  Given that my phone is as much a toy to
play with as a tool to use, I suspect that I would.  However, I would
make sure I had reliable backups first.  But then ... I probably should
do that anyway.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Flash">Filesystems/Flash</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/518988/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor519292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 1:55 UTC (Thu)
                               by <b>mbcook</b> (guest, #5517)
                              [<a href="/Articles/519292/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd just like to thank you guys for this article. When the announcement hit Slashdot and a few other places a couple of days ago, I was really disappointed that coverage basically fit into the "Samsung did something, here's a Git repository" mold.<br>
<p>
Thanks for the informative discussion of how f2fs works, and why it may have been designed that way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2012 9:58 UTC (Sat)
                               by <b>liljencrantz</b> (guest, #28458)
                              [<a href="/Articles/519694/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Real journalism takes time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor519334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 9:03 UTC (Thu)
                               by <b>hthoma</b> (subscriber, #4743)
                              [<a href="/Articles/519334/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The block addresses are 32 bits so the total number of addressable bytes in the filesystem is at most 2^(32+12) bytes or 16 terabytes. This is probably not a limitation — for current flash hardware at least. </font><br>
<p>
16 TB is not a limitation? OK, you can not buy a 16 TB SSD now, but you can buy one with 512 GB. That is only a factor of 32. And it will probably not take too long to close that gap.<br>
<p>
So this sounds really a lot like: "640 kB of RAM is enough."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 12:06 UTC (Thu)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/519358/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As far as I can see, f2fs is primarily intended for less intelligent flash devices, like those in smartphones, where 16 TB indeed is enough for the forseeable future.<br>
<p>
If there ever is a smartphone with 32 TB of flash storage, I'd guess that it will also have a flash controller as least as good as those in today's top-end SSDs, which aren't as bad with 'normal' file systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor519337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">f2fs versus jffs2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 9:37 UTC (Thu)
                               by <b>flok</b> (subscriber, #17768)
                              [<a href="/Articles/519337/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What would be the advantage of f2fs over jffs2?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519342"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">f2fs versus jffs2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 10:04 UTC (Thu)
                               by <b>drago01</b> (subscriber, #50715)
                              [<a href="/Articles/519342/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is designed for flash devices that expose themselves as block devices (like SSDs) and not for raw flash devices as jffs2 .. so they aren't really comparable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519342/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor525453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">f2fs versus jffs2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2012 15:31 UTC (Fri)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/525453/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And JFFS2 works really badly on file systems which sizes are in GBs as it AFAIK keeps the whole fs structure in RAM.  From scalability point of view, UBIFS would be more reasonable comparison.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/525453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor519426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 19:16 UTC (Thu)
                               by <b>skitching</b> (guest, #36856)
                              [<a href="/Articles/519426/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the great analysis Neil.<br>
<p>
Unfortunately, it is sad to see that f2fs is *so* coupled to an underlying FTL. I presume that where you say "leaves it to the FTL", this means that f2fs is simply rewriting data at a fixed address, and relying on the FTL to relocate that address to perform wear-leveling. And given that flash is supposed to be efficient at random writes (in units of an erase block) it is a shame that f2fs spendsg so much effort grouping writes into larger operations to help the FTL layer perform.<br>
<p>
So we have a choice of filesystems that only work well on "raw" flash (jffs2, ubifs, logfs) or a filesystem that only works well on managed flash (f2fs).<br>
<p>
AIUI, FTL is a solution invented to make it possible to put filesystems like FAT32 onto a flash device without quickly killing it. Are we really still going to be stuck with FTL decades from now?<br>
<p>
If the industry is going to provide a "raw" interface to removable flash media in the near future, then f2fs will only be a short-term solution, yes? And interestingly, Samsung are exactly the people who could get a "raw flash interface" happening...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 21:11 UTC (Thu)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/519484/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A few replies to each of your comments:<br>
<p>
* Wear leveling usually works by having a pool of available erase blocks in the drive. When you write to a new location, the drive takes on block out of that pool and writes the data there. When the drive thinks you are done writing to one block, it cleans up any partially written data and puts a different block back into the pool.<br>
<p>
* f2fs tries to group writes into larger operations of at least page size (16KB or more) to be efficient, current FTLs are horribly bad at 4KB page size writes. It also tries to fill erase blocks (multiples of 2MB) in the order that the devices can handle.<br>
<p>
* logfs actually works on block devices but hasn't been actively worked on over the last few years. f2fs also promises better performance by using only 6 erase blocks concurrently rather than 12 in the case of logfs. A lot of the underlying principles are the same though.<br>
<p>
* The "industry" is moving away from raw flash interfaces towards eMMC and related technologies (UFS, SD, ...). We are not going back to raw flash any time soon, which is unfortunate for a number of reasons but also has a few significant advantages. Having the FTL take care of bad block management and wear leveling is one such advantage, at least if they get it right.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2012 21:01 UTC (Tue)
                               by <b>travelsn</b> (guest, #48694)
                              [<a href="/Articles/520090/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      But are there processor out there that can boot from FTL enabled flash don't we still need raw NAND for boot device?
      
          <div class="CommentReplyButton">
            <form action="/Articles/520090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520119"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2012 23:53 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/520119/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But are there processor out there that can boot from FTL enabled flash</font><br>
<p>
The OMAP3 in my phone boots from the micro-SD card.  It reads from the blocks that a file would be stored in if it were the first file copied onto a newly formated VFAT partition (it doesn't parse the FAT, it just *knows* what to read).<br>
<p>
So yes:  processors can boot from all sorts of things.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520119/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520154"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 17, 2012 12:14 UTC (Wed)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/520154/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So yes: processors can boot from all sorts of things.</font><br>
<p>
In fact OMAP3 boots from an internal ROM and can chain-load other boot device.<br>
It would be so nice if that ROM would also contain a description of all the devices on this particular system-on-chip...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520154/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor530464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 22, 2012 22:38 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/530464/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It reads from the blocks that a file would be stored in if it were the first file copied onto a newly formated VFAT partition (it doesn't parse the FAT, it just *knows* what to read).</font><br>
<p>
To avoid this kludge, starting from version 4.3 e-MMC chips feature two 128K boot partitions with a simplified access procedure: simplified for ROMs.<br>
<p>
JEDEC specifications are free (registration required)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/530464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor519485"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 21:15 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/519485/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One point that I didn't emphasise in the article, and maybe should have, is that those locations where f2fs writes to fixed addresses are all at the start of the device, the same region that a FAT filesystems uses for the "FAT" (File Allocation Table).<br>
As the FAT is also updated by writes to fixed addresses, that part of the device is often optimised for that sort of access pattern.<br>
<p>
So if you manage to align the "meta" area to the "fat"-dedicated area, and align the sections and zones as already described, f2fs should be fully optimised for the device.<br>
<p>
As for whether we'll be stuck with FTL for decades: that is really a question of economics.  For a better product to appear, there needs to be a big enough market.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519485/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor519477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 20:01 UTC (Thu)
                               by <b>rfrancoise</b> (subscriber, #15508)
                              [<a href="/Articles/519477/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fantastic article, thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor519545"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2012 8:21 UTC (Fri)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/519545/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great article!<br>
<p>
I'm a little disturbed by the many arbitrary low limits in the filesystem.  16 TB max?  Less than 4 TB max for a file?  Timestamps only up to 2038?<br>
<p>
I mean, sure, good design requires tradeoffs.  But I thought the point of this filesystem was that it would become some kind of long-lived standard for how we accessed embedded flash devices, sort of like how FAT32 is now.  We would probably not even be talking about replacing FAT32 on flash devices, despite its many inefficiencies and limitations, if it didn't have the 2TB limit.<br>
<p>
Or am I misreading this, and it's simply about avoiding the FAT tax and getting some additional performance in the bargain?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519545/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519597"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2012 16:06 UTC (Fri)
                               by <b>Aissen</b> (subscriber, #59976)
                              [<a href="/Articles/519597/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure the primary usage is to prevent the "FAT" tax. Sure, it could be useful on SD cards to replace exFAT. But I think the primary goal is to replace ext4 for eMMCs embedded in smartphones (and tablets, or any other smart device). This limitation could then make (a little bit) sense. With current technology we have 64GB eMMCs, with 128GB in the pipes. With capacity doubling every 2 years, it would take ~15 years to reach the filesystem limit. Let's hope that by then non volatile memory use will be pervasive.<br>
<p>
The thing I don't understand, is why work isn't done to make btrfs fit this use case. It already has less write amplification than ext4 or xfs due to it's COW nature (I think Arnd Bergmann did some research on that). It would use the years of experience and higher performance of btrfs (vs a newly developed filesystem). It would also fit the Linux philosophy of running on anything from the tiniest devices to TOP500 computers.<br>
<p>
Is it because btrfs as a high CPU overhead ? Consumes lots of disk space ? Or just because every btrfs developer is working on "big data" server-side use cases ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519597/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2012 18:38 UTC (Sun)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/519749/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The thing I don't understand, is why work isn't</font><br>
<font class="QuotedText">&gt; done to make btrfs fit this use case. It already</font><br>
<font class="QuotedText">&gt; has less write amplification than ext4 or xfs</font><br>
<font class="QuotedText">&gt; due to it's COW nature (I think Arnd Bergmann</font><br>
<font class="QuotedText">&gt; did some research on that).</font><br>
<p>
It's not obvious that btrfs is the best choice for SSDs.  Ted T'so posted some information on this earlier: <a href="http://lwn.net/Articles/470553/">http://lwn.net/Articles/470553/</a><br>
<p>
There is currently some work going into btrfs to make it a better match for SSDs.  That would probably make an interesting LWN article of its own.  Also keep in mind that the type of SSD you see on a desktop is much different than what you see in a mobile phone.  The firmware is much fancier and so an optimization for one may be a pessimization for the other.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2012 8:18 UTC (Mon)
                               by <b>Aissen</b> (subscriber, #59976)
                              [<a href="/Articles/519771/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the link you point to (very interesting BTW), Ted says that btrfs will be at a disadvantage in "fsync()-happy workload"s. So it varies between workloads.<br>
<p>
I didn't use the work "SSD", and that's because (as you said) it might refer to different things. I talked about eMMCs and SD cards, which are the target use case of f2fs, and used in mobile phones.<br>
In some use cases, btrfs might be the best choice, according to Arnd's year old research: <br>
<a href="http://www.youtube.com/watch?feature=player_detailpage&amp;v=6DilhvJy6Fc#t=1752s">http://www.youtube.com/watch?feature=player_detailpage&amp;...</a> (wasn't able to find the updated slides).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor520165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 17, 2012 14:26 UTC (Wed)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/520165/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe btrfs has improved significantly in this area, but its design means that it won't be as good as f2fs on the media that f2fs optimizes for. The issue with b-tree updates that Ted mentions in the link is something that f2fs avoids by having another level of indirection that is not copy-on-write, and btrfs suffers more from fragmentation because it intentionally does not garbage-collect.<br>
<p>
On a lot of flash devices, btrfs starts out significantly faster than ext4 after a fresh mkfs, but it's possible that btrfs performance degrades more as the file system fragments with aging. I don't have any data to back that up though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor525454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2012 15:33 UTC (Fri)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/525454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nobody mentioned compression, but I think BTRFS can use e.g. LZO compression.  What's the situation with that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/525454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor520063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2012 18:22 UTC (Tue)
                               by <b>tomstdenis</b> (guest, #86984)
                              [<a href="/Articles/520063/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
4TB max for a file is not a problem.<br>
<p>
Let's look at your typical use case [e.g. cell phone].  Max download speeds are in the 5-50Mbit/sec range realistically.  It'd take 2 days of straight downloading at 50Mbit/sec constantly to fill that up.<br>
<p>
If that were an 720p quality video it'd play for 4+ days straight...<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 17, 2012 18:13 UTC (Wed)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/520213/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 4TB max for a file is not a problem. [...] Max download speeds are in the 5-50Mbit/sec range realistically.</font><br>
<p>
Famous last words.<br>
<p>
2GB max for a file wasn't a problem in 1996 when they designed FAT 32, either. It would take over 5 days to fill that over a 33.6 kbaud modem in those days.<br>
<p>
Now I can plug an HDMI-capable cellphone into a 1080p TV and stream multi-gigabyte Bluray rips over Wi-Fi. Yet I can't store them on the SD card because someone thought "it would never be a problem".<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2012 17:20 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/521764/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>This is interesting comment. Note that FAT32 was explicitly designed as stop-gap solution for Windows96 (and then retrofitted into Windows95OSR2 when Windows96 become first Windows97, then Windows98). Long-term solution was supposed to be Windows 2000 (and later Windows XP) and it worked like a charm.</p>

<p>But then FAT32 was used for totally unrelated task (USB-sticks) and <b>this</b> is where it's limitation become problematic... and since Microsoft wants to monopolize this market, too instead of FAT32X we've gotten exFAT... which is, of course, not supported by many-many things because it's implementation is not free because exFAT is heavily patented.</p>

<p>Moral? F2FS limitations are fine for what's it's designed for, but if we'll try to use it for some unrelated tasks... we may be in trouble.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/521764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor520294"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2012 4:12 UTC (Thu)
                               by <b>cyanit</b> (guest, #86671)
                              [<a href="/Articles/520294/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is, how about a 5TB disk image/virtual disk on a virtualized server that has a RAID array of 10 512GB SSDs? (the SSDs would only cost around $6000)<br>
<p>
Not to mention the fact that files can be sparse.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520294/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2012 14:23 UTC (Thu)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/520335/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
f2fs isn't really optimized for SSDs at all. The largest media today that it actually targets are USB sticks of maybe 128GB that are both slow and expensive. Rather than using a RAID of 40 USB sticks and f2fs, I would always recomment getting a bunch of SSDs and using btrfs on them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor519601"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2012 16:16 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/519601/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice article btw, more of it please!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519601/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor520200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 17, 2012 17:12 UTC (Wed)
                               by <b>jond</b> (subscriber, #37669)
                              [<a href="/Articles/520200/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great article. I have a spare microsd I want to use to expand my archive storage. This seems to be just what I need.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2012 12:40 UTC (Thu)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/520319/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure if you were joking here, but since you put no smiley in your message, let me warn you about two reasons why you really should not consider this:<br>
<p>
* The file system is not stable or merged yet, and will very likely see incompatible changes to the on-disk layout. Even if you don't run into bugs that cause your data to get destroyed, you won't be able to read the data anymore with the version of the file system that eventually gets merged.<br>
<p>
* A lot of SD cards are not sufficient in their hardware characteristics to support f2fs. Have a look at <a href="https://wiki.linaro.org/WorkingGroups/Kernel/Projects/FlashCardSurvey">https://wiki.linaro.org/WorkingGroups/Kernel/Projects/Fla...</a>, all SD cards with a number of less than 7 in the "# open AUs linear" column or cards that don't have a power-of-two erase block size.will not work correctly with f2fs. It's not worse than using ext4 or btrfs on the same devices though, but you should not do that either, at least not if you are storing important data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor613605"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An f2fs teardown</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2014 10:29 UTC (Sat)
                               by <b>Praveen_Pandey</b> (guest, #99082)
                              [<a href="/Articles/613605/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great article !!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/613605/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
