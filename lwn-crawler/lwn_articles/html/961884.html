        <!DOCTYPE html>
        <html lang="en">
        <head><title>Windows NT synchronization primitives for Linux [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/961884/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/962303/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/961884/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Windows NT synchronization primitives for Linux</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 16, 2024</br>
           </div>
The <a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex</a>
mechanism provided by the kernel allows for the creation of efficient and
flexible locking primitives in user space.  Futexes work well for many
applications, but not all.  One of the exceptions, it seems, is that
perennially difficult-to-support use case: Windows games.  With 
<a href="/ml/linux-kernel/20240214233645.9273-1-zfigura@codeweavers.com/">this
patch series</a>, Elizabeth Figura seeks to provide the sort of locking
that those games need, by way of a special-purpose virtual device.
<p>
The performance of a futex can be hard to beat when it is used as intended;
in the uncontended case, there is no need for a system call at all to
acquire one.  Surprisingly, though, the Windows&nbsp;NT locking primitives
were not designed with the objective of being easy to implement efficiently
with futexes; as a result, there are certain operations supported by
Windows that are not straightforward to implement on Linux.  At the top of
the list is operations requiring the simultaneous acquisition of multiple
locks.
<p>
Applications written for Unix-like systems normally do not suffer from the
lack of Windows-style locking primitives, but Windows applications that
have been made to run on Linux often will.  Until now, these applications
have been supported in <a href="https://www.winehq.org/">Wine</a> by
creating a special process to arbitrate access to locks.  That solution can
work, but it adds an interprocess-communication overhead to every locking
operation, which hurts performance.  The new device takes the place of that
process, handling locking in the kernel without the communication overhead.
<p>
To use this feature, a process opens the new special file
<tt>/dev/ntsync</tt>.  Every open of that file creates a new instance that
is distinct from all of the others, so the intended use case is a single
process that shares an instance across multiple threads.  Each instance
provides a whole set of <a
href="https://man7.org/linux/man-pages/man2/ioctl.2.html"><tt>ioctl()</tt></a>
operations (all described on <a
href="/ml/linux-kernel/20240131021356.10322-30-zfigura@codeweavers.com/">this
patch</a>).  The first step to use those operations will be to create the
locks to be managed by the device; they come in three flavors:
<p>
<ul class="spacylist">
<li> A <b>mutex</b> is similar to the kernel equivalent; it is a lock that
     can be held by a single owner at a time.  Locking calls can nest,
     though: once a thread has acquired a mutex it can do so again any
     number of times.  Once all of the acquisition calls have been matched
     with release calls, the mutex is freed.
<li> A <b>semaphore</b> is a counter, as one would expect.  Every
     acquisition decrements the counter by one; as long as the counter is
     nonzero, the semaphore remains available.
<li> An <b>event</b> is a condition variable; it has a boolean value, and
     threads can wait until it becomes true.  If the event is marked for
     auto-reset, it will be reset to false as soon as a wait is satisfied,
     meaning that only one thread will see the event become true.
     Otherwise, an event, once set to true, stays that way until explicitly
     reset.
</ul>
<p>
The <tt>NTSYNC_IOC_CREATE_MUTEX</tt>, <tt>NTSYNC_IOC_CREATE_SEM</tt>, and
<tt>NTSYNC_IOC_CREATE_EVENT</tt> <tt>ioctl()</tt> calls can be used to
create a mutex, semaphore, or event, respectively.  On success, each of
these operations returns a file descriptor that can be used to operate on
the created object.  The API is a bit different than one might expect, in
that the file descriptor is not the return value from <tt>ioctl()</tt>;
instead, it is stored in a structure passed by user space.
<p>
For example, to create a mutex, a thread starts with this structure:
<p>
<pre>
   struct ntsync_mutex_args {
   	__u32 mutex;
   	__u32 owner;
   	__u32 count;
   };
</pre>
<p>
On entry to the <tt>NTSYNC_IOC_CREATE_MUTEX</tt> call, the value of
<tt>mutex</tt> is ignored.  The <tt>owner</tt> field is set to the
(application-defined) ID of the initial owner of the mutex, while
<tt>count</tt> is set to the number of times the mutex has been acquired by
that owner.  To create a mutex that is not yet owned by anybody, both of
those fields will simply be set to zero.  On a successful return, the file
descriptor corresponding to this mutex will be stored in the <tt>mutex</tt>
field.
<p>
A number of operations are provided for manipulating these objects.  For
mutexes, <tt>NTSYNC_IOC_READ_MUTEX</tt> will return the current state of a
mutex, while <tt>NTSYNC_IOC_MUTEX_UNLOCK</tt> will unlock a (currently
locked) mutex.  A slightly strange one is <tt>NTSYNC_IOC_KILL_OWNER</tt>,
which doesn't actually kill anything; it takes a thread ID as an argument
and, if that ID is the owner of the mutex, that mutex will be freed and
marked as "abandoned".  The next attempt to acquire the mutex will return
an error status of <tt>EOWNERDEAD</tt>, but the acquisition will have
succeeded anyway.
<p>
For semaphores, <tt>NTSYNC_IOC_READ_SEM</tt> will read the current state,
and <tt>NTSYNC_IOC_SEM_POST</tt> will add a given amount to the semaphore's
count (perhaps releasing the semaphore).  Events can be queried with
<tt>NTSYNC_IOC_READ_EVENT</tt> and modified with
<tt>NTSYNC_IOC_SET_EVENT</tt>, <tt>NTSYNC_IOC_RESET_EVENT</tt>, and
<tt>NTSYNC_IOC_PULSE_EVENT</tt>.  That last operation acts like an
instantaneous set and reset of the event, allowing one or more waiting
threads to proceed but never causing the event to appear to be set.  The
"pulse" operation is one of those that is hard to implement with futexes.
<p>
To actually acquire a mutex or semaphore involves calling either
<tt>NTSYNC_IOC_WAIT_ANY</tt> (which will return as soon as it is able to
acquire any one of a list of mutexes and semaphores or one of the indicated
events is set) or <tt>NTSYNC_IOC_WAIT_ALL</tt>, which will only return when
it is able to atomically acquire <i>all</i> of the indicated resources.  The
latter operation will make an attempt whenever one of the resources is
freed, but will only succeed if all of them happen to be available.  It
will not hold a partial set of resources while waiting for the rest, so it
could be subject to starvation if the resources are heavily contended.
Both wait operations include an optional timeout.
<p>
The motivation behind this work becomes clear after a look at the benchmark
results provided in the patch cover letter:
<p>
<blockquote class="bq">
	The gain in performance varies wildly depending on the application
	in question and the user's hardware. For some games NT
	synchronization is not a bottleneck and no change can be observed,
	but for others frame rate improvements of 50 to 150 percent are not
	atypical.
</blockquote>
<p>
The question that has not been directly answered in the cover letter is
whether the futex API could have been enhanced to provide the needed
functionality without introducing an entirely new API.  It would seem
(though your editor, needless to say, has not tried to implement it) that
the "pulse event" functionality would be relatively straightforward to add.
Some aspects of the multi-resource wait operations were provided by the
addition of <a href="/Articles/866112/"><tt>futex_waitv()</tt></a> to the
5.16 kernel, but more work would clearly have to be done.
It may well be that adding a standalone virtual device for this niche
functionality is easier and less intrusive than trying to coerce futexes
into doing the job.
<p>
The comments on <a
href="/ml/linux-kernel/20240124004028.16826-1-zfigura@codeweavers.com/">the
first version</a> of the patch set were focused on the details of the API
rather than whether a separate device was needed; they resulted in a number
of changes leading to the API described here.  Subsequent versions, the
last of which was posted on February&nbsp;14, have received relatively few
comments so far.  So, perhaps, the community is happy with this proposal in
its current form, and Linux gamers can look forward to a 131% faster Lara
Croft in the near future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Locking_mechanisms">Locking mechanisms</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.10">Releases/6.10</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/961884/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor962543"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Run time loading</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2024 17:23 UTC (Fri)
                               by <b>nickodell</b> (subscriber, #125165)
                              [<a href="/Articles/962543/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it possible to load this driver at run-time so that users who haven't used Wine since their last boot won't pay the cost of having this loaded? Or must it be compiled into the kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962543/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Run time loading</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2024 17:57 UTC (Fri)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/962552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>The patch to <a href="https://lore.kernel.org/all/20240214233645.9273-2-zfigura@codeweavers.com/">Kconfig</a> would indicate it can be compiled as a module.



      
          <div class="CommentReplyButton">
            <form action="/Articles/962552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor962581"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Run time loading</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2024 22:06 UTC (Fri)
                               by <b>shironeko</b> (subscriber, #159952)
                              [<a href="/Articles/962581/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it can be built as a module, as shown in the first patch<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962581/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor962608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Run time loading</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2024 9:07 UTC (Sat)
                               by <b>grawity</b> (subscriber, #80596)
                              [<a href="/Articles/962608/">Link</a>] 
      </p>
      
      </div>
      </summary>
      What is the cost of having this loaded? (Besides having the word "NT" on your system.)


      
          <div class="CommentReplyButton">
            <form action="/Articles/962608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor962564"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2024 19:23 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/962564/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      &gt; Futexes work well for many applications, but not all.

<p>The timing of this made me laugh.  A week ago I ran into this years-old bug for the first time:

<p><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=25847">pthread_cond_signal failed to wake up pthread_cond_wait due to a bug in undoing stealing</a>

<p>To be fair though it is a glibc bug not a futex bug.


      
          <div class="CommentReplyButton">
            <form action="/Articles/962564/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2024 7:16 UTC (Sat)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/962603/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      But this <em>does</em> illustrate that synchronization primitives are <strong>hard</strong>.


      
          <div class="CommentReplyButton">
            <form action="/Articles/962603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962607"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2024 8:50 UTC (Sat)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/962607/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The only thing that's harder is not using them! Lock-free programming is… subtle.<br>
<p>
(I guess you could argue that implementing mutexes is a form of lock-free programming…)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962607/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962610"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2024 9:20 UTC (Sat)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/962610/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, if you can implement your new synchronization primitives on top of something else (which is what this ntsync work or even the futex system call do, using e.g. waitqueues) it's not that hard. But the futex code in glibc is much harder to write, much more so than the futex implementation in the kernel itself!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962610/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962611"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2024 9:43 UTC (Sat)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/962611/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
glibc code, for example for mutexes, is somewhat complex mostly because of the many options that it supports. Futex'es without the userspace part are "just" a mechanism to wait atomically, not a complete synchronization primitive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962611/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962642"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2024 15:57 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/962642/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, compare Rust's Mutex† which, on Linux, ultimately boils down to: <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/unix/locks/futex_mutex.rs">https://github.com/rust-lang/rust/blob/master/library/std...</a><br>
<p>
... with what they have to do if you only have POSIX threads: <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/unix/locks/pthread_mutex.rs">https://github.com/rust-lang/rust/blob/master/library/std...</a><br>
<p>
Between "It's very stupid but POSIX technically allows this, so we need to cope" on one hand, and people just straight up not complying with POSIX anyway on the other I'd have thrown all of my toys out of the pram before writing the latter monster.<br>
<p>
† Technically unlike the C mutex, a Rust Mutex&lt;T&gt; is a wrapper for a type T, the code I've linked isn't about that part, just the part with the actual mechanics of a mutex which are platform specific.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962642/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2024 19:57 UTC (Sun)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/962664/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; with what they have to do if you only have POSIX threads: <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/unix/locks/pthread_mutex.rs">https://github.com/rust-lang/rust/blob/master/library/std...</a></span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; [...] I'd have thrown all of my toys out of the pram before writing the latter monster [...]</span><br>
<p>
I'm not seeing anything criminal there. Certainly not a monster. WDYM?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962684"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2024 10:31 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/962684/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For example when we want to lock the mutex, that can't fail in POSIX, it will just deadlock if we're recursively locking our own mutex, which in Rust's model is fine... too bad Sun didn't agree and so it fails instead.<br>
<p>
  _ = libc::pthread_mutex_lock(raw(self)); // Should be fine, but instead there's a whole mess<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962684/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor962641"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2024 15:32 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/962641/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think so, lock freedom guarantees global progress. If our threads are executing and we're a lock free algorithm, we will get work done. It may be the least preferred work, it may get done more slowly than preferred, but some of the work we had gets done. I think mutexes can't promise that, you might spend all of your execution resources on the mechanics and get no work done.<br>
<p>
And one step harder is wait freedom, a guarantee of local progress - if our threads are executing specific work will get done, if thread A is squawking a goose, that goose gets squawked, it may not get squawked quickly but it definitely gets squawked, whereas a lock free algorithm is allowed to leave thread A starving forever until some day squawking that goose is globally the only work left to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962641/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 1:26 UTC (Wed)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/962953/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe that was just meant to say that implementing a mutex requires similar programming techniques (atomic operations, avoiding issues like race conditions) as lock-free programming.<br>
<p>
Of course, there can be (and there are already some) higher level abstractions for lock-free programming as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor962583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2024 22:28 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/962583/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The comments on the first version of the patch set were focused on the details of the API rather than whether a separate device was needed; they resulted in a number of changes leading to the API described here. Subsequent versions, the last of which was posted on February 14, have received relatively few comments so far.</span><br>
<p>
Specifically, there seems to be no comment reflecting an extensive (and independent) expertise in synchronization primitives. In this regard, it sounds like a "whatever" response.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor962628"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2024 2:19 UTC (Sun)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/962628/">Link</a>] (45 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was wondering how this compares to futex2 / futex_waitv, which was also targeting the use case of Windows synchronization primitives that are heavily used by games. The LPC presentation linked in the patchset covers basically this, especially starting around here re futex: <a href="https://youtu.be/NjU4nyWyhU8?t=626">https://youtu.be/NjU4nyWyhU8?t=626</a> Essentially, futex_waitv covers the "wait for one" operation, but not the "wait for all" or "pulse" operations.<br>
<p>
I still don't follow why there can't just be more futex API for this, e.g. a flag to futex_waitv to wait for all instead of any. But it sounds like some of the motivation is to isolate the weird NT-compatibility APIs into their own place (this is being proposed as a driver, not a syscall, and there are tons of niche drivers in the kernel already) and lower the risk of messing up syscalls that other applications use.<br>
<p>
(Also - why isn't the "pulse" operation just FUTEX_WAKE without actually writing to the futex location? I'm certainly missing something....)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962628/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2024 16:16 UTC (Sun)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/962658/">Link</a>] (42 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the main reason is that there exists no use case for the wait for all except for the single case of replicating WIN32 behaviour. Quite telling is also that (per the presentation) they have not found a single game or application in Windows that actually use the wait for all flag, so this is just to get 100% compliance with the API and I don't think that changing something as fundamental as the futex would fly with the kernel devs with this in mind.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962659"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2024 16:36 UTC (Sun)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/962659/">Link</a>] (41 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;they have not found a single game or application in Windows that actually use the wait for all flag</span><br>
<p>
Ok, well. The correct thing to do would then be to panic/abort wine if an application uses the flag.<br>
Implementation of the flag on Linux should then be based on whether these aborts do actually occur.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962659/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962925"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2024 19:20 UTC (Tue)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/962925/">Link</a>] (40 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Upstream WINE does not allow that, this is Collabora trying to find a solution that is both performant that will be accepted upstream.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962925/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2024 20:11 UTC (Tue)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/962932/">Link</a>] (39 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wine doesn't allow ignoring non-existent problems and demands fixing non-existent problems instead?<br>
Great! They must have solved all real problems then.<br>
<p>
<span class="QuotedText">&gt;trying to find a solution that is both performant</span><br>
<p>
If this option is never executed by any Windows application, I have an easy and very performant implementation:<br>
<p>
abort();<br>
<p>
Why not first prove that a problem exists and _then_ fix it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2024 23:08 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/962943/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If this option is never executed by any Windows application, I have an easy and very performant implementation:</span><br>
<p>
Didn't Figura include benchmarks [1] showing significant (double-to-triple-digit percentages [2]) improvements in popular games when these patches were used?<br>
<p>
All shorts of shenaigans have been added to Linux for far lower gains than this; why should this be treated any differently?<br>
<p>
[1] See the first message in the "patch series" link in the article<br>
[2] between 21% to 678%<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 1:03 UTC (Wed)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/962952/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Didn't Figura include benchmarks ...</span><br>
<p>
The wait-for-all function is not relevant to any benchmarks shown.<br>
<p>
Similar benchmarks show that other solutions (which do not require kernel patches, at least not additional ones) have similar performance or even marginally better, for the benchmarked games.<br>
<p>
And, those don't exhaust the possibilities of userspace solutions in general, and their shortcomings are not inherent to non-kernel solutions in general.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 1:17 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/962954/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Similar benchmarks show that other solutions (which do not require kernel patches, at least not additional ones) have similar performance or even marginally better, for the benchmarked games.</span><br>
<p>
Citation, please?<br>
<p>
Because I remember this bit of drama going back many, many, many years, and the only reason a kernel-based proposal has been worked on at all was that the userspace-based options weren't anywhere near performant enough.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 2:00 UTC (Wed)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/962955/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://www.youtube.com/watch?v=NjU4nyWyhU8">https://www.youtube.com/watch?v=NjU4nyWyhU8</a><br>
At about 14:06.<br>
<p>
In my view the best slide of that presentation is the one mentioning "fast user-space RPC" as a "half-baked idea", called an "interesting idea".<br>
<p>
(Such concepts exist for a long time in all kind of variations. Some people associate the concept with "actors" in a multi-threaded context, or "asynchronous message queues". I'm using something that could go by that label (though so far within a single process, between threads) for many years, and it works very well, using lock-free queues. As a low-level implementation, execution time in a loop is a small single-digit number of nanoseconds.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 3:04 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/962958/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In my view the best slide of that presentation is the one mentioning "fast user-space RPC" as a "half-baked idea", called an "interesting idea".</span><br>
<p>
Ah, so this mythical other approach is just that; no implementation much less any benchmarks showing it to be just as good or better than the kernel-based approach that exists _today_.<br>
<p>
<span class="QuotedText">&gt; I'm using something that could go by that label (though so far within a single process, between threads) for many years, and it works very well, using lock-free queues</span><br>
<p>
...Um, you do realize that Wine needs to synchronize between multiple independent heayweight *processes* ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962959"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 3:23 UTC (Wed)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/962959/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Ah, so this mythical other approach is just that; no implementation much less any benchmarks showing it to be just as good or better than the kernel-based approach that exists _today_.</span><br>
<p>
There are several existing approaches that have the same performance, just the existing ones also have shortcomings which that approach would not have. <br>
<p>
<span class="QuotedText">&gt; ...Um, you do realize that Wine needs to synchronize between multiple independent heayweight *processes* ?</span><br>
<p>
Yes, as indicated I do, however I wonder what you mean with a "heavyweight" process?<br>
<p>
Shared memory is as fast between processes (I measured it), and can be read-protected or write-protected for specific processes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962959/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor962940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 9:52 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/962940/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <p>Wine already has a solution to this problem; it's just excessively slow because it depends on relatively complex user-space emulation of a kernel primitive, where the <tt>wineserver</tt> process does a lot of the work to emulate the Windows kernel behaviours atop the host OS. The goal of this work is to allow you to completely bypass <tt>wineserver</tt> and rely on the kernel doing all of the synchronization work for the Windows WaitForMultipleObjects family of API calls.
<p>However, if you bypass <tt>wineserver</tt>, it can't then correctly emulate the wait for all behaviour, since it no longer has all the information it needs (it needs to know about all waiters on a given object to correctly emulate Windows behaviour, since Windows has some fairness between waiters that you need to emulate to get it right). Telling <tt>wineserver</tt> before and after each wait destroys the performance gain from not doing <tt>wineserver</tt> IPC, so that's off the table. And Wine doesn't want to regress on API support; while commercial applications don't use wait for all, Wine also wants to be able to run all in-house applications perfectly, and I know that such applications have existed (since my employer 20 years ago had one, written for NT 4.0).
<p>So, you're asking Wine to make a choice:
<ul>
<li>Regress on API support, knowing that there are probably applications that the Wine developers don't have access to that depend on the old behaviour, and thus that they're quite likely to be faced with bug reports about the regression.
<li>Refuse to accept a speed-up change (not a correctness change) until it correctly handles the same API surface that the existing Wine implementation handles.
</ul>
<p>Wine is choosing to not knowingly regress purely for the sake of performance, and asking the people who are trying to push a performance-only change to avoid regression. How they do that is up to them; they may find a way for wait for all operations to be handled by <tt>wineserver</tt> collaborating with the <tt>/dev/ntsync</tt> mechanism, or add it to <tt>/dev/ntsync</tt> fully.



      
          <div class="CommentReplyButton">
            <form action="/Articles/962940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 11:35 UTC (Wed)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/962971/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Improving the performance of some old and crusty proprietary application that might exist somewhere in private is not really a good justification for getting a new locking mechanism merged into the kernel.<br>
Just live with the old performance then or change it to use faster locking.<br>
Or use your own special purpose wine dkms driver.<br>
<p>
I don't see why the mainline Linux kernel should care.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962973"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 11:50 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/962973/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <p>And therein lies the problem: if you merge this driver without resolving the "wait for all" problem, it won't get used by Wine, and you're at risk of needing two mechanisms that do the same thing with different UAPI (this one for older Wine forks, and one with the tweaks needed to resolve the "wait for all" problem for newer Wine versions).
<p>So, a solution has to be found to the "wait for all" problem; can you make it possible for Wine to transparently fall back to the old methods if an application uses "wait for all", for example? Is there a trivial way for userspace to "reclaim" all waits that are in-kernel using this mechanism, and fall back to <tt>wineserver</tt> IPC? Can you come up with a simple way to implement "wait for all" that's low performance (after all, the existing method is low performance anyway)? Is there an easy way to detect that an application uses "wait for all" waits before it uses a "wait for some" wait, and thus disable this optimization?
<p>And these are questions that need answering before <tt>/dev/ntsync</tt> merges, not after.


      
          <div class="CommentReplyButton">
            <form action="/Articles/962973/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 12:09 UTC (Wed)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/962976/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My proposal was to not merge ntsync at all.<br>
I have not yet seen a good justification for having it in mainline.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 12:24 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/962979/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <p>The justification for merging is that it's a significant performance improvement for applications running under Wine. And the justification for not putting the full functionality into <tt>futex</tt> is that the wait-for-all operation is only needed under Wine, and even then, only when you have applications using edges of the Windows API. Most of the time, pulse and wait-for-any are all that you need.


      
          <div class="CommentReplyButton">
            <form action="/Articles/962979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 12:37 UTC (Wed)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/962981/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So what's wrong with dkms? Why does this single-purpose driver have to be in mainline?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 13:01 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/962982/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>The kernel maintainers want everything in mainline, not in DKMS. DKMS is meant for backports from a later mainline kernel, or for cases where legal issues prevent something being merged into mainline (e.g. licensing conditions).
<p>You'd have to ask Greg K-H and others why they don't want a stable API or ABI for modules so that things can stay outside mainline forever.


      
          <div class="CommentReplyButton">
            <form action="/Articles/962982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962983"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 13:13 UTC (Wed)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/962983/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps hyperbolic, but taken to the extreme that argument could also mean no drivers, filesystems, etc. really need to be in the kernel since you could always compile extra modules out of tree, put them into the initramfs, and be done with it.<br>
<p>
But yeah, that's not how Linux works? There might be whole architectures with fewer users than this feature would have ...<br>
<p>
It's also tremendously impractical with modules signing, having to have compilers everywhere, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962983/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor963049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 14:55 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/963049/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  So what's wrong with dkms? Why does this single-purpose driver have to be in mainline?</span><br>
<p>
Because there's a non-trivial amount of users that would see a substantial improvement?  As I mentioned earlier in this thread, all sorts of insanity is merged into Linux every cycle that only yields a low-single-percentage improvement on narrow (and more often than not, proprietary/internal) use cases; this would seem to be a no-brainer by those same general principles.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor963069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 17:54 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/963069/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; So what's wrong with dkms? Why does this single-purpose driver have to be in mainline?</span><br>
<p>
Why not move out drivers for all of the one-off devices out of the kernel, then? DKMS significantly complicates the OS updates and secure boot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 9:59 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963144/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <p>And just looking at the kernel, there's a huge number of single-purpose drivers that most users are never going to need - 100G Ethernet, Infiniband, FireWire, UIO, parallel SCSI, PCMCIA, amateur radio, SLIP, FPGA drivers, SGI system drivers, analogue TV tuners, multipath block I/O, old PC-style gameports, Industrial I/O (iio), obscure HID devices, CXL, ATM, PATA and probably more. The kernel's full of stuff that most people don't need - either because it's legacy (analogue TV tuners, ATM, PATA), or special case (IIO, UIO, amateur radio), or because it's too expensive for most of us (100G Ethernet, Infiniband, FPGA drivers).




      
          <div class="CommentReplyButton">
            <form action="/Articles/963144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 19:04 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/963268/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's what-about-ism. ntsync has nothing to do with analogue TV tuners and all the other stuff you mentioned.<br>
<p>
But thanks to all for explaining the technical details and the background behind ntsync.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 21:35 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963284/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <p>But all of those other stuff are "single use drivers" for things that I'm never likely to use; I have more chance of benefiting from ntsync than I do from all of those other things.


      
          <div class="CommentReplyButton">
            <form action="/Articles/963284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 22:09 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/963285/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly. What about all those other unrelated things over here?<br>
<p>
As I said: Thanks for explaining some technical details. But now you keep on saying things that are off topic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 22:25 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963287/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <p>Because you said "So what's wrong with dkms? Why does this single-purpose driver have to be in mainline?" - but that applies to every last one of those things that are also single-purpose drivers in mainline.
<p>I'd like you to explain what criteria makes a single-purpose driver sensible to include in mainline (rather than being things that should be in dkms), such that all the single-purpose drivers in mainline that I'm never likely to use meet that criteria, but this doesn't.


      
          <div class="CommentReplyButton">
            <form action="/Articles/963287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963307"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2024 6:26 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/963307/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, but this is not what I meant.<br>
<p>
With "single-purpose" I did _not_ mean that a driver would only drive a single type of hardware. That is _obvious_. That's the case for most drivers.<br>
And I also was not referring to the number of users of this driver.<br>
There are even drivers in the mainline where probably only a single instance of the hardware exists. Does it make sense? No, it does't. But that's a completely different thing. Doesn't have anything to do with how we discuss ntsync.<br>
<p>
I was referring to the number of _applications_ that would use the driver. I'm sorry that I didn't make that clearer to begin with. That was my fault.<br>
ntsync only serves a single _application_.<br>
<p>
It is like the DCO driver for OpenVPN. Which is a DKMS. And I don't see anything wrong with that. Except for maybe that it breaks module signing.<br>
<p>
And yes, I do know that we have more features in the kernel that only serve a single application. You don't need to bring that up. ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963307/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2024 10:57 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963317/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>The OpenVPN DCO driver is out of tree not because it has a single use, but because the kernel has a guideline of "don't break userspace applications", and the OpenVPN DCO driver currently wants the freedom to make changes that will deliberately break userspace applications. This is a very good reason to not enter mainline - you don't want to be under the strictures that Linus applies.


      
          <div class="CommentReplyButton">
            <form action="/Articles/963317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor964573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2024 19:18 UTC (Wed)
                               by <b>florianfainelli</b> (subscriber, #61952)
                              [<a href="/Articles/964573/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And yet this driver is now attempting to enter mainline: <a href="https://lore.kernel.org/netdev/20240106215740.14770-1-antonio@openvpn.net/">https://lore.kernel.org/netdev/20240106215740.14770-1-ant...</a><br>
<p>
The technical reasons for attempting to upstream should be simple and clear: it facilitates the distribution of your module and it gives you some amount of maintenance "for free".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/964573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor964675"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2024 11:36 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/964675/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Yep. Now that they're confident that they don't want to deliberately break user-space, they're going for mainline, just like everything else, because there's good reasons to be in mainline. It's just that when you know you want to break mainline's rules (unstable userspace interfaces like OpenVPN DCO, wrong licence like NVidia's proprietary driver), you need to stay out until you're ready to keep to mainline's rules.


      
          <div class="CommentReplyButton">
            <form action="/Articles/964675/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor963318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2024 11:24 UTC (Fri)
                               by <b>timon</b> (subscriber, #152974)
                              [<a href="/Articles/963318/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But why then do you think that the ntsync driver only serves a single application? Do you count anything running under Wine as the same application?<br>
<p>
From what I understand from the article and its comments, there might be numerous (legacy?) applications that use those NT features and that one may want to run on a Linux kernel with Wine, or there might be not a single application ever using this NT feature with Wine.<br>
<p>
That Wine wants to be able to offer the Windows APIs as complete, conformant and performant as possible seems like a laudable goal and a win for FOSS -- and I don't see why one would want to hinder their efforts by relegating their work to out-of-tree modules via DKMS, as long as there are no legal or severe technical hurdles.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2024 17:47 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/963405/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please see the root of this thread.<br>
This is going way off topic to what I originally commented on.<br>
<p>
The original assumption was that there were *zero* use cases. (which was *not* claimed by me)<br>
Which has been clarified as being wrong.<br>
<p>
The corrected assumption is that there are proprietary apps hidden somewhere that wine does not want to break.<br>
Whether that warrants a kernel driver or not is a completely different question. IMO it doesn't, but feel free to have a different opinion. I'm Ok with that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2024 18:35 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963407/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Note that the thing that warrants a kernel driver is the wait-for-any functionality of the call; the challenge is that if the kernel driver <em>only</em> implements wait-for-any, and neither implements a way to "return" those waits to userspace early nor a wait-for-all option, then Wine has a regression and won't use this driver for wait-for-any, even though it works for that purpose.
<p>The exact implementation of this is up to the people doing the work; do you put a wait-for-all mode in the kernel, even though it's rarely needed, or do you come up with a way for Wine to reclaim all the wait-for-anys sitting in the kernel and push all wait-for-anys (including the reclaimed ones) through the slow path, not using the kernel driver?
<p>Both work, since we only have evidence that there are applications that do not use wait-for-all, but would benefit from a faster wait-for-any than can be implemented in userspace alone.



      
          <div class="CommentReplyButton">
            <form action="/Articles/963407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor964095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 29, 2024 18:55 UTC (Thu)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/964095/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  the challenge is that if the kernel driver only implements wait-for-any, and neither implements a way to "return" those waits to userspace early nor a wait-for-all option, then Wine has a regression and won't use this driver for wait-for-any, even though it works for that purpose</span><br>
<p>
I'm catching up but isn't the way that MS solves these kinds of compat issues in the Windows world is tedius baked-in lists of specific applications which need the differential behavior?   A WINE config/cli flag that indicates when  emulated wait-for-all is needed which uses the existing slow implementation with a default which uses the fast kernel implementation, that aborts with a sensible error if the app uses features which aren't implemented, so the user/admin can restart the app with the right compat option saved.  Maybe an option to upload those compat lists somewhere so the config could be distributed, if the existence of the app isn't sensitive data.<br>
<p>
I know having things work correctly automatically is more awesome but sometimes just doing the dumb brute force thing is more effective and efficient than working through all the details, coordination and judgement to automate something.  Technical debt isn't always bad as long as you are picky when you create it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/964095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor964100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 29, 2024 19:20 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/964100/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That would work, too, but then needs the people proposing a Linux-only accelerator for wait-for-any behaviour to create the compat options + list, so that people can use it.
<p>This is not an unsoveable problem; it's "just" that Wine isn't happy with a gain in performance for some applications at the expense of others now failing to work at all, and people will have to do the work so that this becomes a gain in performance for some applications (those that only use wait-for-any) but not others.



      
          <div class="CommentReplyButton">
            <form action="/Articles/964100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor962972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 11:36 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/962972/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can they add an option (default off) to enable this performance gain, in the knowledge that it may trigger a regression for in-house apps?<br>
<p>
After all, if they are in-house, there's always the option (provided they haven't lost the source) to work around the regression ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor962974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2024 11:46 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/962974/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>That's not Wine's way of working (although a Wine fork like Proton may do just that). Wine would like to remove configuration options that depend on you knowing details of what APIs your application uses, not add more, since you don't have to set options on Windows to say "this is a perfectly well-behaved Win32 app that should function on Windows NT 3.1 to Windows 11 without modification, but that gets a performance boost if you set this modification"; instead, Windows itself detects applications that can't have the performance boost, and disables it appropriately.


      
          <div class="CommentReplyButton">
            <form action="/Articles/962974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 6:54 UTC (Thu)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/963132/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can we do what windows itself does, then?<br>
Grep through the binary of whatever wine is executing for wait_for_all calls, then disable the optimization if any are spotted?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 7:41 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/963133/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even better, if wait_for_all_calls is part of wine (I get the impression it might be), on the first call it could itself disable optimisation.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 9:52 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963141/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>You can't do it on the first call, because to implement it properly, you need to prevent previous wait-for-any calls from using the kernel mechanism; time-travelling backwards like that is a technical challenge. And Windows handles it by having its kernel equivalent of <tt>/dev/ntsync</tt> handle wait-for-all as well as wait-for-any; it may have fast paths in there for wait-for-any, but it's all in-kernel.


      
          <div class="CommentReplyButton">
            <form action="/Articles/963141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 15:05 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/963211/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And a wait-for-any call will go direct from the app bypassing wine? <br>
<p>
Otherwise you could presumably ref-count wait-for-any, and if the count was non-zero you'd have to divert new calls and wait for existing calls to go to zero. Messy, assuming it's even possible ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 15:21 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963226/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>You also need some mechanism to tell all the existing calls in the kernel that <tt>wineserver</tt> is taking over wait calls now, so they need to return to userspace and be retried (inside Wine) by the IPC mechanism instead of the kernel mechanism, otherwise you can't correctly implement the corner-cases of Win32 when you have both wait-for-any and wait-for-all referencing the same objects.


      
          <div class="CommentReplyButton">
            <form action="/Articles/963226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 17:04 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/963257/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That was the point of my ref-counting - wine takes over, but cannot proceed until the ref count drops to zero. Almost certainly not nice ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2024 21:36 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/963283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Wine needs to take over <em>before</em> the ref count drops to zero, else you've regressed. To match Windows kernel behaviour, you either need the Linux kernel to support wait-for-all somehow, or you need the Linux kernel to hand over the existing wait-for-any waits to Wine, so that Wine can correctly emulate the corner cases of wait-for-all.


      
          <div class="CommentReplyButton">
            <form action="/Articles/963283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor963322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2024 12:41 UTC (Fri)
                               by <b>nicklecompte</b> (guest, #151334)
                              [<a href="/Articles/963322/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; (Also - why isn't the "pulse" operation just FUTEX_WAKE without actually writing to the futex location? I'm certainly missing something....)</span><br>
<p>
I am actually more familiar with Windows events than futexes so excuse my heresy :) One problem I see is auto-reset events, where pulse specifically only wakes one *and only one* of the waiting threads. But I don't think futexes don't have an easy way of guaranteeing the wakes happen atomically in that fashion: it seems like this would wake *at least* one waiting thread, absent a very clever workaround or modifying the kernel directly. Of course I could be missing something. But I suspect Windows kernel being written to atomically wake up a single waiting thread is probably expensive to emulate on Linux.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor963542"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2024 23:37 UTC (Sat)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/963542/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  I am actually more familiar with Windows events than futexes so excuse my heresy :) One problem I see is auto-reset events, where pulse specifically only wakes one *and only one* of the waiting threads. But I don't think futexes don't have an easy way of guaranteeing the wakes happen atomically in that fashion: it seems like this would wake *at least* one waiting thread, absent a very clever workaround or modifying the kernel directly. Of course I could be missing something. But I suspect Windows kernel being written to atomically wake up a single waiting thread is probably expensive to emulate on Linux.</span><br>
<p>
Futexes do have an easy way to wake exactly one thread (of course, otherwise how would you efficiently implement a lock using them).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/963542/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor962910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2024 17:37 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/962910/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not just add system calls to implement these synchronization primitives directly? They're probably useful for programs in general, not just Windows ones<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor975593"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Windows NT synchronization primitives for Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 28, 2024 16:54 UTC (Tue)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/975593/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Wait for all with timeout and alert" feels like the core operation here that is currently impossible to perform on Linux without an arbitrator, and when you don't know if a program is going to use that operation you need to send all operations on all of these objects over the costly arbitrator connection.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/975593/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
