        <!DOCTYPE html>
        <html lang="en">
        <head><title>HWPOISON [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/348886/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/347815/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/348886/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>HWPOISON</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>August 26, 2009</p>
           <p>This article was contributed by Jon Ashburn</p>
           </div>
<p>One downside to the  ever-increasing memory size available on computers
is an increase in memory failures.  As memory density increases, error
rates also rise.  To offset this increased error rate, recent processors
have included support for "poisoned" memory, an adaptive method for
flagging and recovering from memory errors.  The HWPOISON patch recently
developed by Andi Kleen and Fengguang Wu  provides the Linux kernel
support for memory poisoning.  Thus, when HWPOISON is coupled with the
appropriate fault-tolerant processors, Linux users can enjoy systems that
are more tolerant to memory errors in spite of increased memory
densities.</p>

<p>Memory errors are classified as either soft (transient) or hard
(permanent).   In soft errors, cosmic rays or random errors can toggle
the 
state of a bit in a SRAM or DRAM memory cell.  In hard errors, memory cells
become physically degraded.  Hardware can detect - and automatically
correct -
some of these errors via Error Correcting Codes (ECC).  While single bit
data errors can be corrected via ECC, multi-bit data errors cannot.   For
these uncorrectable errors,  the hardware typically generates a trap which,
in turn,
causes a kernel panic.</p>

<p>The blanket action of crashing the machine for all uncorrected soft and
hard memory errors is sometimes over-reactive.   If the detected memory
error never actually corrupts executing software, then ignoring or
isolating the error is the most desirable action.  Memory "poisoning", with
its delayed handling of errors, allows for a more graceful recovery from
and isolation of uncorrected memory errors rather than just crashing the
system.  However, memory poisoning requires both hardware and kernel
support.</p>

<p>The <a href="http://lwn.net/Articles/345340/">HWPOISON patch</a> is very
timely: Intel's recent preview of its Xeon 
processor (codenamed Nehalem-EX) promises support for memory poisoning.
Intel has included its Machine Check Abort (MCA) Recovery
architecture in Nehalem-EX.  Originally developed for ia64
processors,  Intel's MCA Recovery architecture supports memory poisoning
and various other hardware failure recovery mechanisms. While, HWPOISON
adopted Intel's usage of the term "poisoning", this should not be confused
with the unrelated Linux kernel concept of poisoning: writing a pattern to
memory to catch uninitialized memory.</p>

<p>While the specifics of how hardware and the kernel might implement
memory poisoning varies, the general concept is as follows.  First,
hardware detects an uncorrectable error from memory transfers into the system
cache or on the system bus.  Alternatively, memory may be occasionally
"scrubbed."   That is, a background process may initiate an ECC check on one or
more memory pages.  In either case, the hardware doesn't immediately cause
a machine check but rather flags the data unit as poisoned until read (or
consumed).  Later, when erroneous data is read by executing software, a
machine check is initiated.  If the erroneous data is never read, no
machine check is necessary.  For example, a modified cache line written
back to main memory may have a data word error that is marked as poisoned.
Once the poisoned data is actually used (loaded into a processor register,
etc.), a machine check occurs, but not before.  Thus, any poisoning machine
check event may happen long after the corresponding data error event.</p>

<p>HWPOISON is a  poisoned data handler invoked by the low-level Linux
machine check code.  Where possible, HWPOISON attempts to gracefully
recover from memory errors, and contain faulty hardware to prevent future
errors.  At first glance, an obvious solution for the poison handler would
focus on the specific process and memory address(es) associated with the
data error.  However, this is infeasible for two reasons. First, the
offending instruction and process cannot be determined due to delays
between the data error consumption and execution of the poison handler.
These delays include asynchronous hardware reporting of the machine check
event, and delayed execution of the handler via a workqueue.  Thus, a
different process may be executing by the time the HWPOISON handler is
ready to act.  Second,  bad-memory containment must be done at a level
where the kernel actually manages memory.  Thus, HWPOISON focuses on memory
containment at the page granularity rather than the low granularity
supported by Intel's MCA Recovery hardware.</p>

<p>HWPOISON finds the page containing the poisoned
data and attempts to isolate this page from further use.  Potentially
corrupted processes can then be located by finding all processes that have
the corrupted page mapped.  HWPOISON performs a variety of different
actions.  Its exact behavior depends upon the type of corrupted page and
various kernel configuration parameters. </p>

<p>To enable the HWPOISON handler,  the kernel configuration parameter
<tt>MEMORY_FAILURE</tt> must be set.  Otherwise, hardware poisoning will cause a
system panic. Additionally, the architecture must support data poisoning.
As of this writing, HWPOISON is enabled for all architectures to make
testing on any machine possible via a user-mode fault injector, which is
detailed below.</p>

<p>The handler must allow for multiple poisoning events occurring in a
short time window.  HWPOISON uses a bit in the <tt>flags</tt> field of a
<tt>struct page</tt> to mark and lock a page as poisoned.  Since page flags
are currently in short supply, this choice was not  made without
consternation and debate by kernel hackers.   See <a
href="http://lwn.net/Articles/335768/">this LWN article</a> for further
details about this issue.  In any case, this bit allows previously poisoned
pages to be ignored by the handler.</p>

<p>The handler ignores the following types of pages:  1)&nbsp;pages that have
been previously poisoned, 2)&nbsp;pages that are outside of kernel control (an
invalid page frame number), 3)&nbsp;reserved kernel pages, and 4)&nbsp;pages with usage count of
zero, which implies either a free or higher order kernel page.  The
poisoned bit in the flags field serves as a lock allowing rapid-fire
poisoning machine checks on the same page to be handled only once by
ignoring subsequent calls to the handler.  Reserved kernel pages and zero
count pages are ignored with the peril of a system panic. However, these
pages containing critical kernel data cannot be isolated. Thus, HWPOISON has
no useful options for recovery.

</p>
<p>In addition to ignoring pages, possible HWPOISON actions include
recovery, delay, and failure.  Recovery means HWPOISON took action to
isolate a page.  Ignore, failure, and delay are all similar in that the
page was not completely isolated, except for flagging the page as poisoned.
With delay, handling can be safely postponed until a later time when the
page might be referenced.  By delaying, some transient errors may not
reoccur or may be irrelevant. HWPOISON delays any action on kernel slab or
buddy allocator pages or free pages.  With failure,  HWPOISON could, but
does not support handling the page.    HWPOISON takes an action of failure
on unknown or huge pages.  Huge pages fail since reverse mapping is not
supported to identify the process which owns the page.
<p>
<p>Clean pages in either the swap or page cache can be easily recovered by
invalidating the cache entry for these pages.  Since these pages have a
duplicate backing copy on disk, the in-memory cache copy can be
invalidated.  Unlike clean pages, dirty pages in these caches have
differences between the memory and disk copies.   Thus,  poisoned dirty
pages may have important data corruption.   However, dirty pages in the
page cache are recovered by invalidation of the cache. Additionally, a page
error is set for the dirty page cache page so subsequent user system calls
on the file associated with the page will return an I/O error.  Dirty pages
in the swap cache are handled in a delayed fashion.  The dirty flag is
cleared for the page and the page  swap cache entry is maintained.  On a
later page fault the associated application will be killed.</p>

<p>To recover from poisoned,  user-mapped pages, HWPOISON first finds all
user processes which mapped the corrupted page.  For clean pages with
backing store, HWPOISON need not take recovery action since the process
does not need to be killed.  Dirty pages are unmapped from all associated
processes, which are subsequently killed.  Two VM <tt>sysctl</tt>
parameters are supported by HWPOISON with respect to killing user
processes: <tt>vm.memory_failure_early_kill</tt> and
<tt>vm.memory_failure_recovery</tt>.  Setting the
<tt>vm.memory_failure_early_kill</tt> parameter causes an immediate SIGBUS
to be sent to the user process(es).  The kill is done using a catchable
SIGBUS with BUS_MCEERR_AO. Thus, processes can decide how they want to
handle the data poisoning.  The <tt>vm.memory_failure_recovery</tt>
parameter delays the killing: the page is merely unmapped  by HWPOISON.
When this unmapped page is actually referenced at a later time then a
SIGBUS will be sent.</p>

<p>An HWPOISON patch git repository is available at 
<p>
<pre>
    git://git.kernel.org/pub/scm/linux/kernel/git/ak/linux-mce-2.6.git hwpoison
</pre>
<p>
Since faulty hardware that supports data poisoning is not easy to come by,
a fault injection test harness <tt>mm/hwpoison-inject.c</tt> has also been
developed. This simple harness uses debugfs to allow failures at an
arbitrary page to be injected.</p>

<p>While HWPOISON was developed for x86-based machines,  interest has been
expressed by supporters of other Linux server architectures, such as ia64
and sparc (discussed <a href="http://lkml.org/lkml/2009/8/5/274">
here</a>).  Thus, the patch may proliferate on future Linux server
distributions, allowing users of future Linux servers to enjoy increased
fault tolerance. Now that Intel is supporting MCA Recovery on x86 machines,
some desktop users may also enjoy its benefits in the near future.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Fault_tolerance">Fault tolerance</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#HWPOISON">HWPOISON</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Ashburn_Jon">Ashburn, Jon</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/348886/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor349359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2009 22:35 UTC (Thu)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/349359/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
First, hardware detects an uncorrectable error from memory transfers into the system cache or on the system bus.

<p>...

<p>Later, when erroneous data is read by executing software, a machine check is initiated.

<p>...

<p>First, the offending instruction and process cannot be determined due to delays between the data error consumption and execution of the poison handler. These delays include asynchronous hardware reporting of the machine check event,
</blockquote>

<p>
How can a machine check for accessing erroneous memory contents be asynchronous?  An instruction to load some data from memory didn't get the data because it's been destroyed.  How can the CPU continue executing and generate a machine check at some arbitrarily later time?

      
          <div class="CommentReplyButton">
            <form action="/Articles/349359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor349464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2009 4:31 UTC (Fri)
                               by <b>roelofs</b> (guest, #2599)
                              [<a href="/Articles/349464/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <FONT COLOR="#880044"><I>How can a machine check for accessing erroneous memory contents be asynchronous? An instruction to load some data from memory didn't get the data because it's been destroyed. How can the CPU continue executing and generate a machine check at some arbitrarily later time?</I></FONT>

<P>
Er, maybe I'm missing the thrust of your question, but I thought it was sort of straightforward:  the hardware detects the problem as soon as memory is read--imagine a bad bit in a single byte out of a page or a cacheline's worth read--but the specific bad subset of that memory (the byte) may not be used until much later, or not at all.

<P>
Or are you asking about something much more subtle?

<P>
Greg
      
          <div class="CommentReplyButton">
            <form action="/Articles/349464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor349494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2009 7:10 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/349494/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
the hardware detects the problem as soon as memory is read--imagine a bad bit in a single byte out of a page or a cacheline's worth read--but the specific bad subset of that memory (the byte) may not be used until much later, or not at all.
</blockquote>
<p>
Yes, that's the scenario in the sentences I excerpted from the article.
<p>
And they go on to say that the poison handler runs some time after the time that the specific bad subset is used.  It refers to the specific bad subset being used as "data error consumption" and the instruction that uses it as the "offending instruction" and says you can't simply locate the offending instruction and thereby the memory location and the process that are affected by the bad memory, because of the delay.
<p>
Maybe the article is confusing multiple scenarios.  I can definitely see a design where the machine check happens, and the OS deals with it, before the data error is consumed.  But that's not the case the article describes.

      
          <div class="CommentReplyButton">
            <form action="/Articles/349494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor349871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 6:36 UTC (Mon)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/349871/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <P>There are a couple things at play here:</P>
<UL><LI>The MCA can occur on any "word", where "word" is defined by the width of the ECC code applied at the corresponding level of memory.  It could be a 64-bit word on a 64-bit + 8-bit DRAM bus, or it could be on the order of a 64-byte cache line.  (I <I>think</I> Athlon's on-chip ECC works on whole cache lines, but I admit to not knowing for sure.  I know a particular DSP core's L2 cache ECC works in terms of 256-bit data phases on the chips that support that feature.)</LI>
<LI>The CPU need not have referenced the particular word that triggered the fault.  A CPU read, or better yet, a data prefetch (either triggered explicitly by an instruction or implicitly by a prefetch engine) may have triggered the memory reference that triggered the MCA.  If the faulting word is due to a prefetch, or is late in the cache line that was read due to a demand fetch, that data may arrive at the CPU quite long after the instruction that triggered that line fill.</LI>
<LI>Whether or not the CPU referenced the particular word that triggered the fault, the existing MCA may consider such faults catastrophic at the task level, and so does not bother to precisely track which instruction(s) may have consumed the bogus data.  (See Chapter 15 <A HREF="http://download.intel.com/design/processor/manuals/253668.pdf">in this reference</A> where it says: "The implementation of the machine-check architecture does not ordinarily permit the processor to be restarted reliably after generating a machine-check exception.")  All that's necessary is to keep track of which task(s) to kill, which is mainly a function of keeping track of the physical address that had a fault.</LI>
<LI>In some systems, the MC exception could be asserted by the chipset, not the CPU.  The chipset may actually detect the fault and alert the CPU via an exception pin, but nothing really aligns that exception to the data's arrival.  Note that this property would be system dependent&mdash;not all systems would necessarily be this imprecise.</LI>
</UL>
      
          <div class="CommentReplyButton">
            <form action="/Articles/349871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor349873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 6:41 UTC (Mon)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/349873/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, and I forgot to mention, some machine check exceptions/aborts could have been triggered due to background scrubbing.  Background scrubbing is entirely asynchronous to process execution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/349873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor349934"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 16:02 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/349934/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if background scrubbing triggers a read error with HWPOISON, that defeats the purpose of doing the HWPoISON in the first place, you may as well just die when you first detect the error.<br>
<p>
the key of HWPOISON is that not all memory locations contain irreplaceable data. in some cases the memory may not be allocated (so when the program goes to use it, whatever contents are there are going to be erased anyway), on other cases the data exists elsewhere (clean disk buffer pages that can be re-read from disk, etc)<br>
<p>
so instead of erroring out when memory corruption is detected, it only throws an error if something tries to make use of the corrupt data, and even then it throws an error that the OS can catch and deal with (since only the OS knows if the data can be replaced by something read from somewhere else)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/349934/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor349976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 18:50 UTC (Mon)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/349976/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <P>Background scrubbing works by reading memory locations, checking the ECC, and correcting correctable errors proactively before they become uncorrectable.  If background scrubbing detects something uncorrectable, it can (and it seems like it ought to) signal a machine check.</P>
<P>
Take a look here:
</P><P>
<A HREF="http://patchwork.kernel.org/patch/16897/">http://patchwork.kernel.org/patch/16897/</A>
</P><P>
There is a notion of an "action optional" machine check.  It's still a machine check, and it can be triggered by scrubbing.  Quoting:
</P><BLOCKQUOTE><I>Action Optional means that the CPU detected some form of corruption in
the background and tells the OS about using a machine check
exception. The OS can then take appropriate action, like killing the
process with the corrupted data or logging the event properly to disk.
</I></BLOCKQUOTE>
<P>This code snippet on the linked page illustrates some of the "action optional" machine check exceptions:</P>
<pre>
+
+	/* known AO MCACODs: handle by calling high level handler */
+	MASK(MCI_UC_SAR|0xfff0, MCI_UC_S|0xc0, AO,
+	     "Action optional: memory scrubbing error", SER),
+	MASK(MCI_UC_SAR|MCACOD, MCI_UC_S|0x17a, AO,
+	     "Action optional: last level cache writeback error", SER),
+
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/349976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor349993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 21:06 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/349993/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
yes, that is how things traditionally worked.<br>
<p>
however, the win here is to not generate a machine check when corrupted memory is detected, but instead wait to see if it matters.<br>
<p>
<p>
if a memory location is corrupted, but then written before it's read from, the fact that the memory location was corrupt doesn't matter, nothing ever tried to use the corrupted data.<br>
<p>
this can be done in hardware, transparent to the OS. it will make systems less likely to crash at the cost of a little more record keeping in the hardware.<br>
<p>
<p>
if a memory location is corrupted, but it happens to be in a page that is a clean cache, the OS can respond to the error by throwing away the cached page and retrieving a copy from disk.<br>
<p>
since in modern systems a _large_ percentage of memory ends up being occupied by caches, making it so that errors in that memory just cause a momentary slowdown (read to the disk) instead of a system crash is also a significant win.<br>
<p>
<p>
and finally, if both of the above fail (so the memory contents are irreplaceable) the OS can detect what program it was running on that CPU at the time the read took place, and kill just that program (and log that the program was killed due to hardware memory errors, not an application bug) rather than killing the entire system.<br>
<p>
<p>
none of these protections guarantee that the system won't crash when cosmic rays hit the ram, but each of these steps makes it less likely to crash.<br>
<p>
given common use cases, I wouldn't be surprised to find that these sorts of strategies make systems an order or two of magnitude less likely to crash as a result of memory errors (although the gains in application reliability will not be as large due to the fact that some of the gain is in killing applications instead of the entire system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/349993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor350023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 23:34 UTC (Mon)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/350023/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're missing the point.  MCE is the mechanism by which the hardware reports the bad page to the operating system.  "Action Optional" means the OS can do just as you suggest:  Try to keep everything running as smoothly as possible and only bringing down the affected tasks if any.<br>
<p>
You seem to be assuming "machine check" means "machine halt."  It's just the name of the exception vector.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor350024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 23:40 UTC (Mon)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/350024/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <P>I'll quote Andi Kleen's post (that I linked above) since I think it's abundantly clear:</P>
<BLOCKQUOTE><I>Newer Intel CPUs support a new class of <B>machine checks</B> called <B>recoverable action optional.</B>

Action Optional means that the CPU <B>detected some form of corruption in
the background</B> and tells the OS about using a machine check
exception. The OS can then take appropiate action, like killing the
process with the corrupted data or logging the event properly to disk.</I></BLOCKQUOTE>
<P>Read that again:  Background scrubbing gives a machine check.  The machine check is <I>action optional</I> and it can do just as you suggest.  It's still a machine check.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor350166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2009 17:59 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/350166/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
as I understand it, HWPOISON changes this.<br>
<p>
instead of the background scrub triggering a machine check at that point in time it instead just marks the memory as corrupt (poisoned). the poisoned flag gets cleared if the memory is written to.<br>
<p>
if nothing ever tries to read the poisoned memory a machine check happens at that point in time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor350203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2009 20:24 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/350203/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>That's not how I read <A HREF="http://download.intel.com/design/processor/manuals/253668.pdf">this</A>.  See section 15.6, "Recovery of Uncorrected Recoverable Errors" and especially 15.6.3, "UCR Error Classification".</P>
<P>The first two error types are the "an error was detected, but the CPU hasn't consumed the errant data yet" error types.  If you want to pick nits, the first one (UCNA) is not reported as a Machine Check <I>Exception</I>; rather it is reported as a Corrected Machine Check Error Interrupt (described in Section 15.5).  My bad for being sloppy; it <I>is</I> a Machine Check Error, but it isn't a Machine Check <I>Exception.</I>  The second recoverable error type (SRAO) <B>is</B> a Machine Check <I>Exception</I>, however.</P>
<P>In any case, <I><B>both</B> are machine checks.</I></P>
<P>Now flip with me to page 15-34 and look at what SRAO errors are architecturally defined, there in section 15.9.3.1:</P>
<BLOCKQUOTE><I> The following two SRAO errors are architecturally defined.
<UL><LI>UCR Errors <B>detected by memory controller scrubbing</B>; and</LI>
<LI>UCR Errors detected during L3 cache (L3) explicit writebacks.</LI></UL></I></BLOCKQUOTE>
<P>So there we have it.  Recoverable, Action Optional Machine Checks due to scrubbing.  Can it be any clearer?  In case you think this feature is old and was supplanted by something more recent, I urge you to flip back to 15-23 and read along here at the intro to Section 15.6:</P>
<BLOCKQUOTE><I>Recovery of uncorrected recoverable machine check errors is an enhancement in machine-check architecture. The first processor that supports this
feature is 45nm Intel 64 processor with CPUID signature DisplayFamily_DisplayModel encoding of 06H_2EH. This allow system soft-
ware to perform recovery action on certain class of uncorrected errors and
continue</I></BLOCKQUOTE>
<P>If I'm not mistaken, that's the processor family this article was referring to.  (This document is dated June 2009, so it's not like it's anceint.)</P>
<P>Do you have different documentation that suggests otherwise?</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor350216"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2009 21:28 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/350216/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ok, I think the question comes down to this<br>
<p>
is HWPOISON a hardware level feature or a OS level feature?<br>
<p>
if it's a hardware level feature (which is what I understood from the original article) then it wouldn't necessarily cause a machine check error ever.<br>
<p>
if this is instead a difference in how the OS responds to a memory error I just completely misunderstood what's happening.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350216/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor350246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2009 23:59 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/350246/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The overall "HWPOISON feature" is both a hardware feature and a software feature.  There is a hardware component (the newly improved Machine Check Architecture in the CPU), and then there's the OS handler that makes use of it.<br>
<p>
A machine check error (whether delivered as an exception or an interrupt--the new MCA does both depending on the error type) is a message from the hardware to the software.  In the most recent Intel architectures, they support a notion of "recoverable machine check," wherein the hardware tells the OS that no CPU state was corrupted when it noticed the problem.  If you look at that PDF I linked, there are a number of status bits (including AR--Action Required) that indicate the severity of the error.  There's a separate table in Intel's PDF that suggests the possible OS responses to a particular error.<br>
<p>
Once the hardware delivers the message to the OS (via a machine check), the OS is then free to deal with the machine check however it pleases.  For "Action Optional" machine checks that can happen asynchronously to program execution (such as due to scrubbing), the OS can queue up a handler to go deal with the affected page, either by poisoning it or unmapping it or what-have-you.  That's the stuff Andi Kleen and co.'s patch does.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor350210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2009 20:26 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/350210/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>I guess what you're missing is <I>who</I> marks the memory as poisoned.  The CPU sends a machine check to the OS.  The OS marks the memory as poisoned, or otherwise discards the contents of the page if it was clean.  The HWPOISON patch provides the OS handler and hooks <I>to poison</I> the page (or do whatever needs doing) when the machine check arrives.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/350210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor350218"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2009 21:31 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/350218/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, I was reading this as something new being implemented at the hardware layer by Intel<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350218/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor350245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2009 23:47 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/350245/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's both.  The hardware now supports a concept of recoverable machine check, and the software uses it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/350245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor349875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2009 7:28 UTC (Mon)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/349875/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>The vm.memory_failure_recovery parameter delays the killing: the page is merely unmapped by HWPOISON. When this unmapped page is actually referenced at a later time then a SIGBUS will be sent.</blockquote>

Perhaps this is handled properly, but by just unmapping, arn't you running the risk that some later memory allocation by that process might get the same virtual address and thus instead of a SIGBUS the process keeps running with corrupted memory?

ISTM you want to map a known bad page there instead.
      
          <div class="CommentReplyButton">
            <form action="/Articles/349875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor351394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2009 11:14 UTC (Tue)
                               by <b>robbe</b> (guest, #16131)
                              [<a href="/Articles/351394/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is this ALL-CAPS TECHNOLOGY? Was something in the engineers' <br>
infrastructure missing the fifth bits (due to faulty memory perhaps)?<br>
<p>
In a more serious vein, I found the article less clear and more hard to <br>
read than the usual material on the kernel page.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/351394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor365143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ECC is able to recover from multib(i|y)te errors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2009 9:00 UTC (Fri)
                               by <b>Milan</b> (guest, #26716)
                              [<a href="/Articles/365143/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <i>While single bit data errors can be corrected via ECC, multi-bit data errors cannot.</i>

<p>
It depends how log the data and the ECC code are. Longer ECC provides capability to correct (and detect) more bites.
      
          <div class="CommentReplyButton">
            <form action="/Articles/365143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor365175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ECC is able to recover from multib(i|y)te errors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2009 12:51 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/365175/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
in theory yes, but you are forgetting that we are talking about a very standardized use of ECC, namely what is implemented in RAM and memory controllers. that implementation only corrects single-bit errors<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/365175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor735144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2017 20:24 UTC (Fri)
                               by <b>mcoulter</b> (guest, #118826)
                              [<a href="/Articles/735144/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are several instances of a link to an Intel document:<br>
<a rel="nofollow" href="http://download.intel.com/design/processor/manuals/253668.pdf">http://download.intel.com/design/processor/manuals/253668...</a><br>
<p>
This link is broken.  I found a different 253668.pdf but it does not have:<br>
section 15.6, "Recovery of Uncorrected Recoverable Errors" <br>
or 15.6.3, "UCR Error Classification"<br>
<p>
Can anyone provide a current link to this manual?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/735144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor735150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">HWPOISON</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2017 22:14 UTC (Fri)
                               by <b>mcoulter</b> (guest, #118826)
                              [<a href="/Articles/735150/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Found it from <br>
<p>
Intel 64 and IA-32 Architectures Software Developer's Manuals<br>
	      <a rel="nofollow" href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.com/en-us/articles/intel-sdm</a><br>
<p>
in the 4 volume set<br>
<p>
Combined Volume Set of Intel® 64 and IA-32 Architectures Software Developer’s Manuals<br>
<p>
<a rel="nofollow" href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">https://software.intel.com/sites/default/files/managed/39...</a><br>
<p>
It is in volume 3:<br>
Intel® 64 and IA-32 architectures software developer's manual combined volumes 3A, 3B, 3C, and 3D: System programming guide<br>
<p>
<a rel="nofollow" href="https://software.intel.com/sites/default/files/managed/a4/60/325384-sdm-vol-3abcd.pdf">https://software.intel.com/sites/default/files/managed/a4...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/735150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
