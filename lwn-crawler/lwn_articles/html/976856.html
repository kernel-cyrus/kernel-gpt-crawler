        <!DOCTYPE html>
        <html lang="en">
        <head><title>Measuring and improving buffered I/O [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/976856/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/975975/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/976856/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Measuring and improving buffered I/O</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>June 5, 2024</br>
           <hr>
<a href="/Articles/lsfmmbpf2024/">LSFMM+BPF</a>
</div>
<p>
There are two types of file I/O on Linux, buffered I/O, which goes through
the page cache, and direct I/O, which goes directly to the storage device.
The performance of buffered I/O was reported to be a lot worse than direct
I/O, especially for one specific test, in Luis Chamberlain's 
<a
href="/ml/linux-fsdevel/Zdkxfspq3urnrM6I@bombadil.infradead.org/">topic
proposal</a> for a session at the 2024 <a
href="https://events.linuxfoundation.org/lsfmmbpf/">Linux Storage,
Filesystem, Memory Management, and BPF Summit</a>.
The proposal resulted in a lengthy mailing-list discussion, 
which also came up in <a
href="/Articles/974487/">Paul McKenney's RCU session</a> the next
day; Chamberlain led a 
combined storage and filesystem session to discuss those results with an
eye toward improving buffered I/O performance.
</p>

<h4>Testing goals</h4>

<p>
He began by outlining his goals with the testing, which were to
measure the limits of the 
page cache and to find ways that page-cache performance could be improved.
In order to improve the performance, it needs to be measured; in
particular, there needs to be a way to avoid introducing performance
regressions as part of the work.  He has done a lot of testing of the page
cache, but there is a need to try to distinguish between normal and
pathological use cases.
</p>

<p>
Based on the tests that he has done, and a suggestion for a "normal" test
case from Chris Mason, he wondered if it seemed reasonable to try to
achieve throughput parity between buffered and direct I/O on a six-drive,
RAID 0 configuration.  Dave Chinner said "absolutely not"; he does not
think it is possible to get parity between the two types of I/O in that
configuration. Chamberlain suggested that the summit would be a good place
to work out what the right tools, tests, and configurations would be to try
to measure and improve page-cache performance (thus, buffered I/O
performance). 
</p>

<p>
The pathological test case that he presented in the topic proposal is the
one that got the most attention.  On a well-resourced system, he reported
86GB/s writes for direct I/O and only 7GB/s writes using buffered I/O.
That is a huge difference; he wondered whether it was acceptable or is
something that should be investigated and, perhaps, fixed.
</p>

<p>
Chamberlain said that there were some other outcomes from the thread.
Matthew Wilcox <a
href="/ml/linux-fsdevel/Zds8T9O4AYAmdS9d@casper.infradead.org/">reported</a>
a problem with 64-byte random reads, which resulted in a <a
href="/ml/all/CAHk-=wjOogaW0yLoUqQ0WfQ=etPA4cOFLy56VYCnHVU_DOMLrg@mail.gmail.com">patch
from Linus Torvalds</a>; Kent Overstreet <a
href="/ml/all/yfzkhghkh36ww5nzmkdrdpcjy6w5v6us55ccmnh2phjla25mmz@xomuheona22l">did
some preliminary testing</a> and found that it provided a 25% performance
improvement.  Torvalds was <a
href="/ml/all/CAHk-=wi+Vcn0jhXqiwfK8eMXUOUqyU-uc+d-ACpZRjBs4SxiQA@mail.gmail.com">not
interested in pushing the patch</a> any further, but Chamberlain said he is
testing it some more to see that it does not crash.
</p>

<p>
He described a few other things that came up in the thread, some
of which were addressed with patches.  But the results from the
pathological case seem to 
be unexpected; what should be done about that?
</p>

<p>
These kinds of discussions are always about tradeoffs, Ted Ts'o said; you
trade some amount of safety, which you may not care about depending on the
workload, for improvement on a microbenchmark.  There may or may not be
user-space applications that actually care about the operations measured in
the microbenchmark, as well.  For example, he does not know of any
real-world application that needs to be able to do 64-byte random reads.
</p>

<p>
It takes work to determine if these things make a difference to real-world
applications, he continued, and more work to ensure that whatever changes
are being considered do not break other applications and make things worse.
There is a philosophical question that needs to be answered about whether
it even makes sense to spend the time to investigate any given problem.
</p>

<p>
He
contrasted the problems being discussed with the <a
href="/Articles/974578/">torn-write problem</a>, which has a clear and
obvious benefit for database performance if it gets solved; whether that is
also true about providing
high-performance for 64-byte I/O is unclear to him.  In the absence of a
customer, "is it worth it?"
But Wilcox said that the 64-byte-read problem came from a real (and large)
Linux-using customer. 
</p>

<p>
Ts'o's point is valid, Chamberlain said, but his goal in the session was
not to come 
up with areas to address; he wanted to raise some of the questions that
arose from his testing.
</p>

<h4>Not unexpected</h4>

<p>
Chinner said that the numbers from the pathological test were not
unexpected.  Part of the problem is that buffered I/O has a single
writeback thread per filesystem, so that I/O cannot go any faster than
that.  The
writeback thread is CPU-bound; "it is not that the page cache is slow, it
is cleaning the page cache that's slow", he said.  There are hacks to get
around that limitation somewhat, but what needs to be looked at is some way
to parallelize cleaning the page cache.  That could be multiple writeback
threads, using writethrough instead, or some other mechanism; the
architecture of the page cache is not scalable for the cleanup part.
Writethrough means that writes go into the page cache, but are also written
to storage immediately.
</p>

<p>
Chamberlain wondered if there was general agreement with Chinner in the room.
Wilcox said that he did not disagree, but that how the scaling is to be done is
an interesting question.  For example, a single huge file that needs
writeback to be done in multiple places will be harder to scale than
dealing with multiple small or medium-size files that need writeback.
</p>

<p>
Chinner said that much of the CPU time in writeback is spent scanning the
page cache looking for pages that need to be written, which does not really
change based on the size of the files.  There are some filesystem-specific
considerations as well, but a pure-overwrite workload will have higher
writeback rates because the amount of scanning needed is less; at that
point it runs 
into contention for the LRU lock.  Adding more threads into that mix will
not help at all and may make things worse.
</p>

<p>
One of the workloads that Chinner runs frequently simulates an untar
operation with lots of files, each of which gets created, 4KB is written to
it,
and it gets closed.
XFS gets stuck at around 50K files/s (roughly 200MB/s) on a device that can
normally handle 7-8GB/s; the limitation is the single writeback thread.
The rate goes way up (to 600K files/s or 2.4GB/s) if he does a flush when
the file is closed, which simulates a writethrough mechanism.  The
writeback problem for this workload is trivially parallelizable, but that
is not always true.  The key problem is how to get the data out of the page
cache and to the disk as efficiently as possible.
</p>

<p>
Jan Kara said that it would be difficult to add more writeback threads because there
are assumptions that there is only one at various levels.  He and Chinner
discussed ways to do so, though it sounds like there would be quite a bit
of work.  Part of the reason it has not really been investigated,
perhaps, is that SSDs are so fast that there is less of a push to optimize
these kinds of things, Ts'o said.  Getting a, say, 20% benefit on an
untar-and-build workload, which already runs quickly, is not all that
compelling. 
</p>

<p>
There may be opportunities to simply turn off writeback on certain classes
of devices, since writethrough performs so much better on high-end SSDs,
Ts'o said.  Chamberlain wondered if switching to writethrough would help
solve the buffered I/O atomic-write problem; Chinner said that it could.
With that, the session ran out of time, though there was talk of picking it
back up at BoF session later in the summit.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Buffered_IO">Buffered I/O</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2024">Storage, Filesystem, Memory-Management and BPF Summit/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/976856/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor977321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Real customer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2024 21:43 UTC (Wed)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/977321/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not my customer, and not a large customer. But 64-byte reads are a real workload and this customer notices the performance of the atomic inc/dec on the folio refcount.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Real customer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 22:05 UTC (Thu)
                               by <b>Heretic_Blacksheep</b> (guest, #169992)
                              [<a href="/Articles/977501/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm curious if this would be a natural result of 64k page sizes common on ARM &amp; Power?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Real customer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 22:10 UTC (Thu)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/977504/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The customer is using x86, so 4KiB page size.  The problem would be worse with a 64KiB page size as there would be more contention.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Write-through</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 10:16 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/977350/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting that turning off write-back boosts performance on fast storage. I would have expected us to reach this day sooner, but it has come at last.<br>
<p>
Maybe when there is a backlog of more than a certain number of pages to write back, any new write operations should switch to write-through?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Write-through</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 14:09 UTC (Thu)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/977387/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
could the write-through be batched using the device-level scatter-gather writes?  that wouldn't be 'parallel' exactly, but just 'more at once'.  And it depends on the underlying device supporting it, but most modern ones do these days, no?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Write-through</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 15:12 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/977395/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Write through isn’t terribly batchable since it’s immediate/synchronous - that’s what write through means.  So there’s no holding in cache and no opportunity to batch unless another write() call happens to be at the same spot when you get to issuing your IO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 15:10 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/977392/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don’t think switching from write back to write through would have a huge impact, it would be great to see some numbers on this.  In my experience the issues are around the mapping lock for getting pages in/out of one file - that’s really rough, a few GiB/s max - or the lru management for many files, which can be 10s of GiB/sec.<br>
<p>
FWIW, the file system I work - Lustre - is moving towards a “hybrid” model where larger buffered IOs are redirected to do direct IO via an internal bounce buffer to solve the alignment requirement.  Since there’s no cache, the required copy and allocation for that buffer can be multithreaded and the performance results are excellent - can hit 20 GiB/s from one user thread and scales when adding threads:<br>
<a href="https://www.depts.ttu.edu/hpcc/events/LUG24/slides/Day2/LUG_2024_Talk_12-Hybrid_IO_path_update.pdf">https://www.depts.ttu.edu/hpcc/events/LUG24/slides/Day2/L...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 16:04 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977415/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I don’t think switching from write back to write through would have a huge impact, it would be great to see some numbers on this. In my experience the issues are around the mapping lock for getting pages in/out of one file - that’s really rough, a few GiB/s max - or the lru management for many files, which can be 10s of GiB/sec.</span><br>
<p>
I don't know where I remember this from, but somebody did some tests on large file copies. By turning off the normal linux cache or something like that, I think the actual copy sped up by an order of magnitude. And system responsiveness during the copy didn't take anything like the usual hit, either.<br>
<p>
Makes sense in a way - by disabling linux' habit of stashing everything in the cache, you're not thrashing the memory subsystem.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 16:08 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/977444/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, "turning off the normal Linux cache" is underspecified - some folks mean "forcing a form of direct IO", which is totally different than "using write through".  Write through can just mean "we put it in the page cache and forced it out", which isn't expected to help that much, since the same basic locking behavior is maintained.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977458"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 17:02 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/977458/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does the "Hybrid I/O" mean that it does some small buffered I/O for the head and tail of the data, and then nicely aligned direct I/O for the middle part?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977458/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977596"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 17:25 UTC (Fri)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/977596/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, unfortunately, because unalignment doesn't work like that.  (That's what I hoped for when I started looking at it...)<br>
<p>
Alignment means "byte N in this page of memory is byte N in a block on disk".<br>
<p>
So let's say you want to do I/O from a 1 MiB malloc, and this 1 MiB buffer starts at 100 bytes into a page.<br>
<p>
*Every* byte in the IO is 100 bytes off, and that means there's not a 1-to-1 mapping between pages in memory and page on disk.  So you have to shift them *all*.  Allocate a 1 MiB buffer and copy everything to it.<br>
<p>
This is the same for the page cache, FWIW.  It has to shift *everything*.<br>
<p>
But since you can do the copying in parallel, it's still *really* fast.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977596/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977520"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 8:13 UTC (Fri)
                               by <b>Homer512</b> (subscriber, #85295)
                              [<a href="/Articles/977520/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My day job is streaming 20+ Gbit/s to disk for hours. One of my applications has 8 U.2 SSDs (3.7 GB/s each) being fed from 2x100 GBit connections. Buffered IO absolutely does not work for this.<br>
<p>
If we could have this happen automatically, it would help so much. For example we could go back to using standard file formats without having to reimplement them. Right now I'm using a custom TIFF file writer for one application simply because there is no way of getting libtiff to do direct IO. Same for things like HDF5.<br>
<p>
Heck, I can't even use cp or rsync for backups at the moment since for example rsync does not go faster than 800 MB/s on that server.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977520/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977527"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 9:57 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977527/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This sounds like you'd benefit massively from that half-remembered article of mine.<br>
<p>
Exactly the use case - shifting a huge volume of data that is going to be written to disk and that's it. What you do NOT want is linux sticking it in the disk cache "just in case". And I think the speedup was (low) orders of magnitude.<br>
<p>
I don't think it was even buffered i/o - if you can get linux to disable the disk cache on that machine, see what results you get with standard tiff, cp etc.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977527/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977598"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BIO vs DIO</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 17:29 UTC (Fri)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/977598/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, that sort of thing is exactly what this is for.  For applications that can't or won't modify to use DIO, or where you don't know your IO pattern in advance.  Libraries like HDF5 are exactly the sort of thing this is targeting, though honestly it's aimed pretty broadly.<br>
<p>
Some of the marketing folks at a Lustre vendor put together something showing improvements in PyTorch checkpointing, for example.<br>
<p>
It's something that would presumably be useful in other file systems too, but Lustre is out of tree, so it'll stay within Lustre for now.  (It's GPLv2, just out of tree.)<br>
<p>
<p>
<p>
If someone working in upstream wants to copy the idea, I won't object.  (Would like credit, of course!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977598/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 10:12 UTC (Fri)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/977526/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why are we talking about 86GB/s hardware, when Linux can't even achieve a fraction of possible write speeds on consumer NVMe disks?<br>
<p>
I recently upgraded to a new SSD: Intel 660p → Kingston KC3000 2TB. To my astonishment, after spending money and time migrating to the new disk, things did NOT get any faster. In the simplest possible sequential write tests, buffered writes capped out at ~700-800 MB/s! On an unencrypted ext4 file system. (Unless using O_DIRECT).<br>
<p>
The hardware can do sustained 6.5 GB/s writes for 110s (<a href="https://cdn.mos.cms.futurecdn.net/YzH49txwAWv3EBB6jF7gge-1200-80.png.webp">https://cdn.mos.cms.futurecdn.net/YzH49txwAWv3EBB6jF7gge-...</a>), but is limited to 3.5 GB/s for me because my system has PCIe 3.<br>
<p>
And this isn't just my problem, there are lots of similar reports on the web:<br>
* <a href="https://askubuntu.com/questions/1277708/why-are-writes-on-an-nvme-slower-under-linux-than-under-windows">https://askubuntu.com/questions/1277708/why-are-writes-on...</a><br>
* <a href="https://askubuntu.com/questions/1005396/ssd-slow-write-speed-on-ubuntu">https://askubuntu.com/questions/1005396/ssd-slow-write-sp...</a><br>
* <a href="https://askubuntu.com/questions/1300444/slow-nvme-performance-on-ubuntu-20-04">https://askubuntu.com/questions/1300444/slow-nvme-perform...</a><br>
* <a href="https://askubuntu.com/questions/1434255/nvme-slow-write-speed-capped-at-513-2-mb-s">https://askubuntu.com/questions/1434255/nvme-slow-write-s...</a><br>
<p>
After reformatting the drive from 512B -&gt; 4kB sectors, things did get better (1.1 GB/s write), but still nowhere near the capabilities of the hardware. And it is software limited on read speeds too!<br>
<p>
Results for buffered I/O: <a href="https://imgur.com/tsNQbmM">https://imgur.com/tsNQbmM</a> (write capped out at 1.1 GB/s, reads 2.2 GB/s)<br>
Results with O_DIRECT: <a href="https://imgur.com/hnWPDaF">https://imgur.com/hnWPDaF</a> (reaches 3.5 GB/s)<br>
<p>
(Some more details in this forum post: <a href="https://bbs.archlinux.org/viewtopic.php?id=292078">https://bbs.archlinux.org/viewtopic.php?id=292078</a>)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 11:24 UTC (Fri)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/977529/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry if the above comment came off as abrasive, I did not mean to antagonize anyone. I am just expressing my genuine astonishment about the lack of discusson/coverage/acknowledgement of the issue. I would very much like to hear explanations and discussion for why this is, how to troubleshoot it further, or even improve the situation.<br>
<p>
This is the first article I've seen covering the topic, but it makes it sound like the issue exists only for some high-end enterprise storage setups or obscure workloads.<br>
<p>
I would expect to be able to copy files at close to the speed that my hardware allows.<br>
<p>
If Linux was only able to use 3 cores out of a 16-core CPU, Phoronix would be chucking out articles about it with the frequency of a machine gun. Are people taking poor I/O performance for granted so it isn't even being discussed? Or maybe it's a problem that affects only some specific combination of hardware? But the list of other similar reports I found seems to indicate that it's not that rare.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 12:03 UTC (Fri)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/977532/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did you try to tune any of the parameters in /sys/block/&lt;device&gt;? I used to have to increase nr_requests quite a bit om large raid-systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977577"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 14:33 UTC (Fri)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/977577/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the pointer. I tried tweaking various settings in /sys/block/nvme1n1/queue: nr_requests, nomerges, scheduler, write_cache. None of them had positive impact, some decreased performance slightly.<br>
<p>
nr_requests was already at 1023 by default and could not be increased. Reducing it decreased performance.<br>
<p>
io_poll requires additional boot parameter (nvme.poll_queues), I will try it out later.<br>
<p>
Did I miss any important tunables?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977577/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 15:40 UTC (Fri)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/977584/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, that's it. In my experience nr_requests as high as it can go and scheduler to none are reliably the best on SSD. In some cases setting cache to write through have been helpful, but that's rare, you almost always want it as write back.<br>
<p>
Things keep changing, so it's good to try the options every now and then. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor977530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 12:16 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/977530/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't really want to comment on Linux pagecache performance, it can't make things faster, only slower, that's quite obvious.<br>
<p>
The answer in your case is probably different I/O scheduler +  filesystem mount options, TRIM and as you've already discovered -- LBA size.<br>
<p>
I want to comment on methodological traps and mistakes so to speak.<br>
<p>
1) dd<br>
<p>
dd is single threaded program. Comparing single threaded performance with report of  CrystalMark "SEQ 1MiB (Q=  8, T= 1):" is not correct.<br>
Q=8 means "queue depth 8" which means 8 NVMe commands in flight not 1.<br>
<p>
Internally SSDs are quite parallelised (imagine HDD with dozens of platters each having _independent_ actuator arm),<br>
so queue depth 1 is worst case performance for SSD. CrystalMark report have measly "130.946 MB/s" qd1, 4 KiB random ream, that's SSDs for you.<br>
<p>
Don't use dd, don't use those pretty apps unless you traced then and know how they open descriptors and issue I/O.<br>
<p>
Learn fio. It does O_DIRECT, maintains queue depth, can emulate dd(1)/cp(1) easily and have more config options than you can imagine.<br>
ioengine=libaio, iodepth=N. ioengine=psync to emulate dd/file copy routines.<br>
<p>
Windows may do QD&gt;1 copy, someone needs to check that. Naive POSIX read/write loop is not pinnacle of performance.<br>
<p>
Again, it is easy to check: find block size with peak qd=1 seq write performance, anything past that must be qd&gt;1.<br>
<p>
1a) dd bs=1G is bad idea.<br>
<p>
first you need to free 1 GiB by flushing everything else only to move big file through pagecache twice (not /dev/zero, lets say video).<br>
<p>
If target file is unused afterwards, do "dd oflag=direct" and big-but-not-really-big bs= .<br>
<p>
Internally, there is RAM buffer to keep the data, any write bigger than that has to be throttled!<br>
<p>
2) manufacturers do _not_ use filesystems for benchmarks. ...<br>
... because it only makes things slower, not faster, because they can't control host OS kernel, application, mount options, SCSI/NVMe stack and so on. <br>
<p>
Internally they may have even more stripped down environments (think DPDK) to separate what hardware can do from what OS kernel developers can do afterwards.<br>
<p>
So what happens, is some Gnome dev writes naive file copier and than users compare it with maximum possible number from real benchmarks which simulate maximum workload.<br>
<p>
3) numbers are sensitive to what's called preconditioning<br>
<p>
Manufacturers do preconditioning before benchmarks so that results aren't fudged. Those big enterprise buyers open devices with O_CONTRACT and reserve the right to reopen with O_LAWSUIT, so can't lie to them. Consumers benchmarks are crapshoot, of course.<br>
<p>
Writing 2-3-4 capacities _before_ doing the run to get real numbers is a must if you want to know what hardware is capable of.<br>
It's takes time and eats block erase count but it is necessary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 14:02 UTC (Fri)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/977535/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I don't really want to comment on Linux pagecache performance</span><br>
<p>
I guess I failed to put together a good narrative around my expectations, how it conflicted with reality, and what my benchmarks were supposed to illustrate.<br>
<p>
As a user, I *only* care about performance of the buffered I/O path, which includes page cache. Workloads on my desktop/laptop compter don't use O_DIRECT, they are extremely simple and non-parallel: Copy some files, unpack some files, install packages, git operations, etc. I upgraded the SSD so that I could do these operations faster.<br>
<p>
My expectation is that an operation as simple as copying a file should be able to mostly saturate the I/O bandwidth of my hardware. Not 100%, but I sure as hell wasn't expecting it to be ≤35%. I thought sequential I/O is simple. Is this a crazy expectation?<br>
<p>
(To put it anther way, I expected to reach 50% of SSD capability due to PCIe bandwidth limitation, but I got &lt;20%)<br>
<p>
Or if computers in 2024 are fundamentally unable to provide this, then it would be a fair argument that cp/tar/rsync implementations should all be rewritten with parallel I/O or O_DIRECT?<br>
<p>
<span class="QuotedText">&gt; dd is single threaded program.</span><br>
<p>
And so are the workloads I am interested in. cp, tar and rsync are all single-threaded in the write I/O path, as far as I am aware. Not sure about git.<br>
<p>
<span class="QuotedText">&gt; Comparing single threaded performance with report of CrystalMark "SEQ 1MiB (Q= 8, T= 1):" is not correct.</span><br>
<p>
I didn't compare to CrystalMark. Are you referring to the KDiskMark screenshots?<br>
<p>
More importantly, if KDiskMark with buffered I/O gives me 1.1 GB/s and `dd` (from the forum post) gives 1.3 GB/s, they're both in the same ballpark and way below my expectation. The additional queue depth didn't seem to make any difference. I think it's valid to demonstrate that?<br>
<p>
The reason for including the KDiskMark O_DIRECT results was to demonstrate that this is not a hardware limitation. To drive home the fact that Linux buffered I/O is the bottleneck.<br>
<p>
<span class="QuotedText">&gt;  Learn fio. It does O_DIRECT, maintains queue depth, can emulate dd(1)/cp(1)</span><br>
<p>
KDiskMark uses fio internally. I included the numbers for both O_DIRECT on and off. It's true that I didn't benchmark fio with QD=1, but as explaned above, it didn't make much difference and both highlight how much performance is left untapped compared to hardware capabilities.<br>
<p>
<span class="QuotedText">&gt; 1a) dd bs=1G is bad idea.</span><br>
<p>
I didn't use `bs=1G`. In the forum post, I used `dd bs=1M`.<br>
<p>
But again, it doesn't matter, I could also benchmark `cp` to copy a file from tmpfs to a real disk. The results are in the same ballpark and still a fraction of maximum I/O capacity.<br>
<p>
<span class="QuotedText">&gt; 2) manufacturers do _not_ use filesystems for benchmarks. ...</span><br>
<p>
Yes, I didn't expect that they would. My complaint is not with manufacturers. My complaint is with Linux leaving so much hardware capability underutilized. And how nobody seems to be talking about this.<br>
<p>
<span class="QuotedText">&gt; some Gnome dev writes naive file copier and than users compare it with maximum possible number from real benchmarks which simulate maximum workload.</span><br>
<p>
Exactly, this. Now we're getting somewhere. :D<br>
<p>
Why is a simple buffered I/O writer limited to 35% or less of potential hardware throughput?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977579"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 14:53 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/977579/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  (To put it anther way, I expected to reach 50% of SSD capability due to PCIe bandwidth limitation, but I got &lt;20%)</span><br>
<p>
The point is that that "SSD capability" (if not a completely theoretical maximum burst speed [1]) is, at best, derived from a synthetic multi-threaded benchmark that is all but guaranteed to bypass the I/O mechanisms available to real-world applications in real-world operating systems.<br>
<p>
<span class="QuotedText">&gt; Why is a simple buffered I/O writer limited to 35% or less of potential hardware throughput?</span><br>
<p>
Due to fixed overhead (eg making system calls, I/O scheduling, copying data into/out of buffers, servicing interrupts, and latencies for all of these meaning that your bus duty cycle is well below the theoretical maximum) -- and the problem that optimizations that maximize throughput for a single thread can severely penalize other usage patterns.   Case in point: the "bufferbloat" problem on wifi and ISP home routers.<br>
<p>
[1] eg quoting max speeds as the theroetical maximum PCIe transfer speed; other stratageies include not including IOP transactional overhead, using transfers that can fit entirely within the SSD's cache, and/or preconditioning the SSD in some way.  As the saying goes, "lies, damn lies, and benchmarks"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977579/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 15:30 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977580/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The point is that that "SSD capability" (if not a completely theoretical maximum burst speed [1]) is, at best, derived from a synthetic multi-threaded benchmark that is all but guaranteed to bypass the I/O mechanisms available to real-world applications in real-world operating systems.</span><br>
<p>
The point the other way, is that linux is caching a lot of disk i/o that is actually "write and forget". That cache is (a) expensive, and (b) pointless. <br>
<p>
I get that knowing the difference between useful and useless caching is a very difficult problem, but there's a lot of evidence that caching is a prime example of "premature optimisation is the root of all evil". If on average half of that written data is then re-used, the implication is that the cost of caching it is more than the cost of reading it again from disk ... not a good trade-off.<br>
<p>
I believe a lot of databases cache stuff they've read. Why is the disk caching it too? That's why I believe PostGRES uses direct i/o as a matter of course.<br>
<p>
Back in the day, Pick/MultiValue databases never cached data, because they could retrieve it from disk so fast (and I've seen them drive disks like that!) (That was with disks and ram measured in megabytes. Or even less.)<br>
<p>
What's needed is a - probably by device - toggle to turn direct/buffered/cached i/o on and off. That guy doing streaming to disk - if the disks were unbuffered all the normal utilities would work. Databases with a dedicated storage partition - they can control their own caching if they wish. Even normal users with a normal /home - do they really need caching? How often do they re-read the same file in normal usage? Probably pretty much never ...<br>
<p>
Buffered/cached i/o is an anachronism that probably doesn't make sense in a lot of workloads ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 15:42 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/977585/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Even normal users with a normal /home - do they really need caching? How often do they re-read the same file in normal usage? Probably pretty much never ...</span><br>
<p>
Devs need pagecache, all of it!<br>
<p>
# from cold cache, top end consumer NVMe SSD<br>
$ time rg -e 'page-&gt;private' -w -n<br>
real    0m1.498s<br>
<p>
# from pagecache<br>
real    0m0.093s<br>
<p>
rg(1) is multithreaded.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977676"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2024 18:46 UTC (Sat)
                               by <b>jkl</b> (subscriber, #95256)
                              [<a href="/Articles/977676/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; That's why I believe PostGRES uses direct i/o as a matter of course.</span><br>
<p>
It does not. It was just introduced as an optional experimental/dev only feature in PostgreSQL 16. <a href="https://wiki.postgresql.org/wiki/AIO">https://wiki.postgresql.org/wiki/AIO</a>. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977676/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor978723"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2024 17:03 UTC (Mon)
                               by <b>fest3er</b> (guest, #60379)
                              [<a href="/Articles/978723/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
«Even normal users with a normal /home - do they really need caching?»<br>
<p>
IMO, normal users benefit from disk cache, just as they benefit from having at least 4 CPU cores (GUI, disk IO, local program, other activity).<br>
<p>
Some years ago, I experimented to see the difference between Linux's disk caching and ramdisk. The system had 16GiB RAM and 8 or 16 CPU cores. I was working on a custom Linux system at the time. The whole build required about 13GiB, using as many CPU cores as any pkg could (GCC and Linux would use all allowed cores for minutes). First, I built it on spinning disk (after having dropped the cache). It took X minutes. Then I cleared it, loaded the tree into a 14GiB ramdisk formatted with some filesystem and built again. This build took X - (time to read files from spinning drive) minutes. My conclusion 10 years ago was that Linux's disk caching was quite efficient; reads weren't really noticeable and writes vanished into unused CPU cycles. But perhaps this isn't 'normal use'.<br>
<p>
Once upon a time, I noticed that EXT4 filesystems would 'lock' or 'hang' the system for some seconds while data were being flushed to disk, something I didn't see on other FSen (ReiserFS). But I haven't seen that happen for prolly 10 years now. (Maybe I had enabled something on that particular EXT4 FS and forgot I'd done did it.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978723/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2024 11:29 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/978751/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; IMO, normal users benefit from disk cache, just as they benefit from having at least 4 CPU cores (GUI, disk IO, local program, other activity).</span><br>
<p>
So you were doing a build. What exactly do you mean? <br>
<p>
If you're talking a compile-and-link, dev-type stuff, you're doing a lot of "write then read", and yes, and cache is useful. But how typical is that sort of behaviour for a normal user?<br>
<p>
<span class="QuotedText">&gt; Then I cleared it, loaded the tree into a 14GiB ramdisk formatted with some filesystem and built again. This build took X - (time to read files from spinning drive) minutes.</span><br>
<p>
So you're now measuring "time for first read from spinning rust". And how exactly is caching going to improve THAT figure? It's not! It'll make a big difference to "time to read it again", or "time to retrieve what I just wrote", but how much does that figure into a NORMAL USER'S workflow. If I'm working on a document, I'll read it ONCE, then it'll sit in ram til I'm finished with it. Cache saves me nothing.<br>
<p>
<span class="QuotedText">&gt; Once upon a time, I noticed that EXT4 filesystems would 'lock' or 'hang' the system for some seconds while data were being flushed to disk, something I didn't see on other FSen (ReiserFS).</span><br>
<p>
And that's background writes, again nothing to do with caching. Except that there's a LOT of evidence that leaving all that i/o behind in cache is damaging to performance.<br>
<p>
I'm an analyst. My whole job is to analyse performance. I'm looking at all this and thinking "where are the performance gains coming from?". All the evidence in front of me says that caching has a very measurable performance cost. And when  I try and work out where the offsetting gains are going to come from, there are some obvious places - development work for example. A "make" cycle will certainly benefit. But there are also places where I struggle to find any benefit - YOUR TYPICAL USER - for example.<br>
<p>
All I'm asking is "is caching worth the cost?". For servers, "it depends". Do they do their own caching, do they rely on the OS? For a development workstation, almost certainly, reading and writing the same files over and over will obviously benefit. But for a typical user PC? Caching will *interfere* with a normal work-pattern. And for a backup server? All the evidence is that caching is actually a major hindrance. I've very recently seen someone complaining about NVME performance - the difference in speed between cached and uncached i/o is about three HUNDRED percent.<br>
<p>
The ability to switch it on and off by volume is probably very useful.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 17:44 UTC (Tue)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/977980/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Due to fixed overhead (eg making system calls, I/O scheduling, copying data into/out of buffers, servicing interrupts, and latencies for all of these meaning that your bus duty cycle is well below the theoretical maximum) -- and the problem that optimizations that maximize throughput for a single thread can severely penalize other usage patterns.
</blockquote>

I don't see these issues as fundamentally limiting buffered I/O bandwidth, especially for the kinds of applications that intgr mentions.  I did

<pre>
strace cp lp_solve_2.2.tar.gz xxx
</pre>

cp performs 101 system calls, most of them startup stuff.  The actual work seems to be:

<pre>
openat(AT_FDCWD, "xxx", O_RDONLY|O_PATH|O_DIRECTORY) = -1 ENOENT (No such file or directory)
newfstatat(AT_FDCWD, "lp_solve_2.2.tar.gz", {st_mode=S_IFREG|0644, st_size=87030, ...}, 0) = 0
openat(AT_FDCWD, "lp_solve_2.2.tar.gz", O_RDONLY) = 3
newfstatat(3, "", {st_mode=S_IFREG|0644, st_size=87030, ...}, AT_EMPTY_PATH) = 0
openat(AT_FDCWD, "xxx", O_WRONLY|O_CREAT|O_EXCL, 0644) = 4
ioctl(4, BTRFS_IOC_CLONE or FICLONE, 3) = -1 EOPNOTSUPP (Operation not supported)
newfstatat(4, "", {st_mode=S_IFREG|0644, st_size=0, ...}, AT_EMPTY_PATH) = 0
fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0
copy_file_range(3, NULL, 4, NULL, 9223372035781033984, 0) = 87030
copy_file_range(3, NULL, 4, NULL, 9223372035781033984, 0) = 0
close(4)                                = 0
close(3)                                = 0
</pre>

If cp used direct I/O, the number of system calls would not be less, so system calls are not the issue.

<p>Let's assume that this performs a standard copy rather than a reflink.  Then inside the kernel a bunch of blocks (including some metadata blocks) are marked as dirty and will be written at some later time.  If you do a lot of such copies, a lot of dirty pages accumulate, and when the kernel decides to write this data, it can do that with as many threads as is appropriate.  If it uses too few, that's an optimization opportunity for the kernel.

<p>However, for the kind of usage that intgr mentions, as long as the data fits into RAM, it does not matter when the kernel starts and finishes writing the data to the disk, and what the bandwidth of that is.  So for this kind of usage the write bandwidth to the buffer cache is what counts, and it's no wonder that he does not see a speedup from switching to a faster SSD: In this setting the limit is RAM bandwidth, not bandwidth to the SSD.

<p>There is a catch: People who argue with the term O_PONIES for file systems with  bad crash consistency guarantees tell us that the applications need to sync at some points, and that syncs mean that the application waits every time until the data resides on the disk.  Unfortunately, last I looked, the only Linux file system with a good crash consistency guarantee is NILFS2.  So if applications sync frequently, write bandwidth to the SSDs would become the limiter.  The cp invocation I straced does not call anything that has "sync" in its name.

<p>My guess is that writing from buffered I/O to SSDs has not been optimized because it has not hurt kernel developers much.  In the usual case git performance is plenty fast (or maybe my repos are just too small to notice problems:-).


      
          <div class="CommentReplyButton">
            <form action="/Articles/977980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977601"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 18:10 UTC (Fri)
                               by <b>Tobu</b> (subscriber, #24111)
                              [<a href="/Articles/977601/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I would guess most of the reason why rsync and tar don't do multithreaded writes is that C makes concurrency hard and risky (with bad consequences for corruption in the write path; maybe it's not worth the risk of silently corrupted backups).

<p>Anyway, Rust makes correct and highly concurrent tools feasible, quite a few are best in their class. Try <a href="https://lib.rs/crates/cpz">cpz</a> and <a href="https://lib.rs/crates/rmz">rmz</a>. Also look at <a href="https://github.com/Byron/gitoxide">gitoxide</a>, not full featured (currently targetting use cases where it's embedded inside another app) but it can git checkout the kernel <a href="https://github.com/Byron/gitoxide/discussions/349">much faster</a>. Or fclones and ripgrep for more read-heavy use cases.



      
          <div class="CommentReplyButton">
            <form action="/Articles/977601/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2024 12:22 UTC (Sun)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/977697/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe try recompiling the kernel with a higher limit to nr_requests? I have no idea if this is easy to do or if it would corrupt your data. You may want to ask on linux-kernel. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978085"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 12:40 UTC (Wed)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/978085/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I already tested with various nr_requests values. I don't have the numbers, but I believe the delta between nr_requests=1 and nr_requests=1023 was only around 10-15%. And above values 100, the difference was in the noise. So I doubt that will help much, at least in my case.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978085/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2024 18:44 UTC (Sat)
                               by <b>dcoutts</b> (subscriber, #5387)
                              [<a href="/Articles/977665/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  [...] Linux pagecache performance, it can't make things faster, only slower, that's quite obvious.</span><br>
<p>
I think this is far from obvious. The crucial observation is that SSDs are highly parallel (with e.g. a 20x factor between serial (Q1) and parallel (QD32) use).<br>
<p>
Certainly, one can expect to achieve best I/O throughput and lowest CPU use by using nice modern async I/O APIs like io_uring, with O_DIRECT, and submitting I/O from multiple cores. That allows one to fully take advantage of the SSDs parallelism.<br>
<p>
But how can older programs written using classic serial I/O APIs take advantage of parallel I/O capabilities of SSDs? Or are all these programs condemned to poor serial performance or rewrites using new (non-portable) APIs? One potential answer is the page cache!<br>
<p>
The page cache allows a program using serial I/O APIs to quickly move data into the page cache, from where it should _in principle_ be possible to write it to disk in parallel. And similarly for reading data via readahead. The kernel readahead could use parallel I/O to get data from the SSD and put it into the page cache, while the application still uses serial I/O APIs to copy that data from the page cache.<br>
<p>
Of course this will have a substantially higher CPU overhead than using io_uring with O_DIRECT, but it should still be possible to achieve the full I/O throughput at least for current generation SSDs (e.g. in the 1M IOPS range).<br>
<p>
So in summary, the problem is how to mediate between parallel SSDs and (older) serial applications, and the page cache _should_ be the solution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor978002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 20:56 UTC (Tue)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/978002/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I don't really want to comment on Linux pagecache performance, it can't make things faster, only slower, that's quite obvious.</span><br>
<p>
That's an exceptionally stupid thing to say. It's a cache. Its entire purpose is to make things faster. If what you meant was "for an uncachable workload it can only make things slower", well, I disagree with that too. It decouples the application from the characteristics of the underlying storage, allowing write() of a single byte to succeed, no matter the block size of the underlying device.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977607"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 18:13 UTC (Fri)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/977607/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So large folios will help a lot once they’re supported, but yeah, the page cache is *expensive*.  It would be interesting to k ow how a very recent XFS - which I believe supports large folios on writes? - does on your test case.<br>
<p>
But this whole thing - buffered IO sucks but real apps don’t use direct IO - is why I’ve implemented something called hybrid IO for the Lustre parallel file system.  Starting from the observation that the main cost of using the page cache is locking and setup - not memory allocation and copying - it adds unaligned direct IO support by creating bounce buffers in the kernel, copying (in parallel) to those, and then doing DIO from those buffers.  Then this is used to bypass the page cache for larger IO sizes.  It can get up to about 20 GiB/s from one thread doing “buffered” IO if the IO size is large.  (Not having the cache for larger IO works out because it’s very, very rare to do a *large* write followed shortly by reading that data back.)<br>
<p>
This is something it would probably make sense to put in more file systems, but Lustre is out of tree (GPLv2, but out of tree), so that would fall to someone else.<br>
<p>
Some conference slides here:<br>
<a href="https://www.depts.ttu.edu/hpcc/events/LUG24/slides/Day2/LUG_2024_Talk_12-Hybrid_IO_path_update.pdf">https://www.depts.ttu.edu/hpcc/events/LUG24/slides/Day2/L...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977607/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not even close to saturating consumer NVMe disks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2024 15:51 UTC (Sun)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/977703/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It would be interesting to k ow how a very recent XFS - which I believe supports large folios on writes? - does on your test case.</span><br>
<p>
Interesting. Thanks for pointing that out. I ran a bunch of tests with multiple file systems on Linux kernel 6.9.3.<br>
<p>
XFS achieves roughly double the sequential write throughput and also has a significant lead in read throughput, compared to all the others (ext4, btrfs, bcachefs).<br>
<p>
Results from `dd if=/dev/zero of=./tempfile bs=1M count=8192 conv=fdatasync`: XFS 3.1 GB/s, btrfs 1.5 GB/s, bcachefs 1.5 GB/s, ext4 1.3 GB/s.<br>
<p>
The dd result of 3.1 GB/s is close enough to theoretical 3.5 that I'm happy with it.<br>
<p>
According to KDiskMark (fio) with buffered I/O, sequential write of XFS goes up to 1900 MB/s, compared to 900-1000 MB/s. Not sure where the measured discrepancy between dd vs fio comes from, but the uplift is consistent in both results.<br>
<p>
KDiskMark screenshots here: <a href="https://imgur.com/a/wJKKLZk">https://imgur.com/a/wJKKLZk</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor980757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">my test with gen5 CPU and raid0 two gen5 NVMe SSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2024 19:18 UTC (Thu)
                               by <b>gaowayne1</b> (guest, #172310)
                              [<a href="/Articles/980757/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
hello experts. I have different test results, need help more clarification. <br>
I tested with latest fio, gen5 CPU, gen5 NVMe SSD with kernel version, I raid0 two gen5 SSD, it can reach 15GB/s <br>
<p>
root@salab-bncbeta02:~/wayne/FlameGraph# uname -a<br>
Linux salab-bncbeta02 6.8.5-301.fc40.x86_64 #1 SMP PREEMPT_DYNAMIC Thu Apr 11 20:00:10 UTC 2024 x86_64 GNU/Linux<br>
<p>
when I test XFS, I can see even direct=0, fio can reach more than 14GB/s flush kworker CPU is only 20%. no issue at all.<br>
when I test ext4, I can reproduce this problem, flush kworker is 100% CPU. <br>
may I know what is difference and root cause for this? I got the perf flame svg for both ext4 and xfs, if anyone need, please reach me.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/980757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
