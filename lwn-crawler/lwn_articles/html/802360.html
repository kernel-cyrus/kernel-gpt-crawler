        <!DOCTYPE html>
        <html lang="en">
        <head><title>Really fixing getrandom() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/802360/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/802558/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/802360/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Really fixing getrandom()</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 17, 2019</br>
           </div>
The final days of the 5.3 kernel development cycle included <a
href="/Articles/800509/">an extensive discussion of the
<tt>getrandom()</tt> API</a> and the reversion of an ext4 improvement that
was indirectly causing boot hangs due to a lack of entropy.  Blocking
filesystem improvements because they are too effective is clearly not a
good long-term development strategy for the kernel, so there was a
consensus that some sort of better solution had to be found.  What was lacking
was an idea of what that solution should be.  It is thus surprising that
the problem appears to have been dealt with in 5.4 with little in the way
of dissent or disagreement.
<p>
The root of the problem in 5.3 was the blocking behavior of <a
href="http://man7.org/linux/man-pages/man2/getrandom.2.html"><tt>getrandom()</tt></a>,
which will prevent a caller from proceeding until enough entropy has been
collected to initialize the random-number generator.  This behavior was
subjected to a fair amount of criticism, and few felt the need to defend
it.  But changing <tt>getrandom()</tt> is not easy; any changes that might
cause it to return predictable "random" numbers risks creating
vulnerabilities in any number of security-sensitive applications.  So,
while various changes to the API were proposed, actually bringing about
those changes looks like a multi-year project at best.
<p>
There is another way to ensure that <tt>getrandom()</tt> doesn't block
during the bootstrap process: collect enough entropy to ensure that the
random-number generator is fully initialized by the time that somebody
needs it.  That can be done in a number of ways.  If the CPU has a hardware
random-number generator, that can be used; some people distrust this
solution, but mixing entropy from the hardware with other sources is
considered to be safe by most, even if the hardware generator is somehow
suspect.  But not all CPUs have hardware random-number generators, so this
solution is not universal in any case.  Other potential solutions, such as
having the bootloader or early user space initialize the random pool, can
work in some situations but are not universal either.
<p>
Another possible solution, though, is jitter entropy: collecting entropy
from the inherently nondeterministic nature of current hardware.  The
timing of even a simple sequence of instructions can vary considerably as
the result of multiple layers of cache, speculative execution, and other
tasks running on the system.  Various studies into jitter entropy over the
years suggest that it is real; it might not be truly nondeterministic, but
it is unpredictable, and data generated using jitter entropy can pass the
various randomness test suites.
<p>
Shortly after the 5.3 release, Thomas Gleixner <a
href="/ml/linux-kernel/alpine.DEB.2.21.1909290010500.2636@nanos.tec.linutronix.de/">suggested</a>
using a simple jitter-entropy mechanism to initialize the entropy pool.
Linus Torvalds <a
href="/ml/linux-kernel/CAHk-=wgjC01UaoV35PZvGPnrQ812SRGPoV7Xp63BBFxAsJjvrg@mail.gmail.com/">described</a>
this solution as "<q>not very reliable</q>", but he clearly thought
that the core idea had some merit.  He proposed a variant of his own that,
after some brief discussion, was <a
href="https://git.kernel.org/linus/50ee7529ec45">committed into the
mainline</a> at the end of the 5.4 merge window.
<p>
Torvalds's patch adds a new function, <a
href="https://elixir.bootlin.com/linux/v5.4-rc1/source/drivers/char/random.c#L1753"><tt>try_to_generate_entropy()</tt></a>,
which is called if somebody is requesting random data and the entropy pool
is not yet fully initialized.  It is simple enough to discuss in detail:
<p>
<pre>
    static void try_to_generate_entropy(void)
    {
	struct {
	    unsigned long now;
	    struct timer_list timer;
	} stack;
</pre>
<p>
This function starts by declaring a timer on the stack, which is a
relatively rare occurrence in the kernel.  Putting it onto the stack was a
deliberate choice, though; if the timer function runs on a different CPU,
it will cause cache contention (and unpredictable timing) for accesses to
this function's stack space.
<p>
<pre>
	stack.now = random_get_entropy();

	/* Slow counter - or none. Don't even bother */
	if (stack.now == random_get_entropy())
	    return;
	timer_setup_on_stack(&amp;stack.timer, entropy_timer, 0);
</pre>
<p>
On most architectures, <tt>random_get_entropy()</tt> just reads the
timestamp counter (TSC) directly.  The TSC increments for every clock
cycle, so two subsequent calls should always return different values.  Just
how different they will be, though, is where the unpredictability comes
in.  The
code above is simply verifying that the system on which the kernel is
running does indeed have a high-frequency TSC; without that, this algorithm
will not work.  Most current hardware does have a TSC, fortunately.
Assuming the TSC check passes, the timer is prepared for use.
<p>
<pre>
	while (!crng_ready()) {
	    if (!timer_pending(&amp;stack.timer))
		mod_timer(&amp;stack.timer, jiffies+1);
	    mix_pool_bytes(&amp;input_pool, &amp;stack.now, sizeof(stack.now));
	    schedule();
	    stack.now = random_get_entropy();
	}
</pre>
<p>

This loop is the core of the jitter-entropy algorithm.  The timer declared above
is armed to expire in the near future (the next "jiffy", which be anytime
between 0ms and 10ms); that expiration will happen by way of an
interrupt and may occur on a different CPU.  The expiration of the timer
adds complexity to the instruction stream (and, hopefully, more randomness
as well). 

<p>
Each time through the loop, the TSC is queried and its value is mixed into
the entropy pool.  If the timer has expired, it is re-armed to run again.
Then the scheduler is invoked, adding more complex code and an
unpredictable amount of execution before that call returns.
The loop itself runs until the entropy pool is deemed to be initialized.
Given that a lot can happen even in one jiffy, this loop can be expected
to run quite a few times and mix many TSC readings into the entropy pool.
<p>
<pre>
	del_timer_sync(&amp;stack.timer);
	destroy_timer_on_stack(&amp;stack.timer);
	mix_pool_bytes(&amp;input_pool, &amp;stack.now, sizeof(stack.now));
    }
</pre>
<p>
The post-loop cleanup gets rid of the timer and mixes in the last bit of
entropy.
<p>
The timer function itself looks like this:
<P>
<pre>
    static void entropy_timer(struct timer_list *t)
    {
	credit_entropy_bits(&amp;input_pool, 1);
    }
</pre>
<p>
In other words, every time the timer expires, the entropy pool is deemed to
have gained one bit of entropy.  It takes 128 bits of entropy for the pool
to be considered ready, so the jitter loop may have to run for up to 128
jiffies — potentially just over one second on a system with a 100HZ tick
frequency — if the system in question has no other sources of entropy.
That could result in a perceivable pause during the boot process, but it is
far better than blocking outright.
<p>
When Torvalds decided to merge this code, he <a
href="/ml/linux-kernel/CAHk-=wi0vxLmwEBn2Xgu7hZ0U8z2kN4sgCax+57ZJMVo3huDaQ@mail.gmail.com/">suggested</a>
that it might not be the definitive solution to the problem:
<p>
<div class="BigQuote">
	I'm not saying my patch is going to be the last word on the
	issue. I'm _personally_ ok with it and believe it's not crazy, and
	if it then makes serious people go "Eww" and send some improvements
	to it, then it has served its purpose.
</div>
<p>
He was thus following the time-honored practice of submitting a patch in
the hope that it would inspire somebody to create a better one.  Thus far,
though, there has been little in the way of commentary on this change —
somewhat surprising, given the diversity of opinions expressed earlier in
the discussion.  Unless somebody comes along with a better idea or shows
that the entropy produced by this algorithm is somehow predictable, this
change seems likely to stand.  Hopefully it achieves the goal of preventing
<tt>getrandom()</tt> blocking while, at the same time, ensuring that random
numbers from the kernel are always truly unpredictable.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/802360/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor802576"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 17, 2019 19:53 UTC (Thu)
                               by <b>azumanga</b> (subscriber, #90158)
                              [<a href="/Articles/802576/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Has anyone considered doing this from the very beginning of the kernel start, on every boot (or at least having an option to do that)?<br>
<p>
Making sure getrandom() gets initialised seems like a sensible thing to do, and doing it from when the kernel starts (or as early as is reasonable), while the kernel is setting up hardware / running other activities, will increase the randomness and avoid the delay. I can't imagine the overhead introduced will be measurable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802576/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802604"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 12:36 UTC (Fri)
                               by <b>Funcan</b> (subscriber, #44209)
                              [<a href="/Articles/802604/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like you'd be putting a one second pause early in everybody's boot process rather than a one second pause in the boot processes that need this... not convinced that's a win<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802604/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802607"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 12:59 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/802607/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not if that loop runs at the same time as all the other boot activity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802607/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor802606"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 13:20 UTC (Fri)
                               by <b>ebiederm</b> (subscriber, #35028)
                              [<a href="/Articles/802606/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are already mechanisms that have in most cases and should continue to do in the future collect enough randomness to initialize the random generator.<br>
<p>
The problem is when those mechanisms that we have lots of confidence in don't always provide randomness in a timely manner. <br>
<p>
What has been added is something that we have slightly less confidence in that the kernel performs on-demand. <br>
<p>
This allows userspace to rely on the kernel to always do the best that it is possible to do in collecting<br>
randomness.  Which keeps systems booting and hopefully prevents the generation of predictable long term keys.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802606/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor802592"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 1:24 UTC (Fri)
                               by <b>clugstj</b> (subscriber, #4020)
                              [<a href="/Articles/802592/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This reminds me of the solution I came up with once in the embedded world.  Certain test patterns would cause our T1 framer to frame on the wrong bit.  The code would, when a failure interrupt was received from the framer, reset the framer.  The problem was that the timing of this process was so consistent that the framer would re-frame on the same wrong bit over and over (I let it run once for hours).  The solution was to not reset the framer in the interrupt handler, but send a message to a thread and when the thread processed the message, it would do the reset.  The non-determinism was enough to, in at most a couple cycles, cause the framer to find the real frame bit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802592/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor804788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2019 14:46 UTC (Thu)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/804788/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't it be a lot more sensible (and reliable) to try each bit in turn?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/804788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor802603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 10:30 UTC (Fri)
                               by <b>patrakov</b> (subscriber, #97174)
                              [<a href="/Articles/802603/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Thus far, though, there has been little in the way of commentary on this change — somewhat surprising, given the diversity of opinions expressed earlier in the discussion.</font><br>
<p>
This can be partially explained by a different set of people in the CC:. For example, I was on the CC: list for the initial discussion of the problem, but not for the final patch.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor802625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 13:54 UTC (Fri)
                               by <b>imMute</b> (guest, #96323)
                              [<a href="/Articles/802625/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm really surprised getrandom() wasn't originally written such that it could provide both "secure" random numbers and "mostly-random" numbers.  From what I gathered from some of the mailing list messages, some userspace software switched from /dev/urandom to getrandom() because the syscall works in places where the device file doesn't (chroots and the like).  But there isn't a way to tell getrandom() that you don't need secure random numbers (perhaps you're just seeding a hash table or something), so the call does more than it really needs to.   Does anyone know why such a flag was left out of the design for getrandom()?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 14:43 UTC (Fri)
                               by <b>nicoonoclaste</b> (guest, #128640)
                              [<a href="/Articles/802632/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Essentially, because there is no point in such a flag: unlike <code>random(4)</code> (aka <code>/dev/random</code>), <code>getrandom(2)</code> never blocks once the system RNG was initialised <b>once</b> (usually, pretty early at boot time).<br />

Adding it would 1) provide userspace more opportunities to shoot itself in the foot  2) not meaningfully improve things.<br/>

You can see that in the solution that was eventually merged in: it doesn't change <code>getrandom(2)</code>... because there is nothing wrong in the syscall itself; it adds a new source of entropy to the pool (which is used by <code>getrandom(2)</code>, <code>random(4)</code>, <code>urandom(4)</code>, and by the kernel itself, internally), ensuring that “enough” entropy is eventually collected for the boot process to go forward. <br/>

P.S.: if you “don't need secure random numbers”, just use 6; worked well-enough for Sony  ;)
      
          <div class="CommentReplyButton">
            <form action="/Articles/802632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802657"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 16:46 UTC (Fri)
                               by <b>imMute</b> (guest, #96323)
                              [<a href="/Articles/802657/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Essentially, because there is no point in such a flag: unlike random(4) (aka /dev/random), getrandom(2) never blocks once the system RNG was initialised once (usually, pretty early at boot time).</font><br>
<p>
Can't that be exploited though?   If the RNG has 128 bits of state, there are 2^128 possible outputs.  If you gather "enough" samples, shouldn't it be possible to determine where in the sequence of 2^128 states it is currently at, and thus you can predict what the next output will be?<br>
<p>
Or is it that the state size of the RNG is so large that it's not *feasible* to actually gather "enough" data, even though the attack is theoretically possible?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802657/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802661"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 17:37 UTC (Fri)
                               by <b>bmenrigh</b> (subscriber, #63018)
                              [<a href="/Articles/802661/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
2^128 is much too large for that to be feasible. It’s also worth pointing out that AES keys are usually 128 bits and most modern stream ciphers like ChaCha tend to use 128 but keys.  If it were feasible to break getrandom()’s initial 128 bit state then it would also be feasible to break most modern crypto.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802661/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor802662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 17:45 UTC (Fri)
                               by <b>Otus</b> (subscriber, #67685)
                              [<a href="/Articles/802662/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Or is it that the state size of the RNG is so large that it's not *feasible* to actually gather "enough" data, even though the attack is theoretically possible?</font><br>
<p>
Yes, it has a 256-bit key, which is much too large to break by collecting samples. (It also has another 128-bit of state in the form of a counter and nonce.)<br>
<p>
Even if that were not true, like if the state somehow leaks, it gets reseeded every five minutes if there is enough entropy available.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor802664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 17:53 UTC (Fri)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/802664/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In theory, yes, but it's the same order of difficulty as brute-forcing encryption (it basically _is_ a cryptographic algorithm). If you assume that the cipher used is secure, it is practically impossible to deduce the state from the output. Adding to the difficulty in the case of the random number generator is that new entropy is continuously mixed into the state -- the call doesn't block after boot, but that doesn't mean that the seed is fixed. So you not only have to brute-force a strong cipher, you have to do it fast enough to provide useful information before too much new entropy gets mixed in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor803322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2019 15:33 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/803322/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wrote a long comment about this a few years ago: <a href="https://lwn.net/Articles/642839/">https://lwn.net/Articles/642839/</a><br>
<p>
In theory, gathering 128 bits of samples would be enough to determine what the state was. In practice, to determine the state from these 128 bits you would have to do on the order of 2^128 operations, which is not feasible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/803322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor802660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 17:06 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/802660/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But there isn't a way to tell getrandom() that you don't need secure random numbers (perhaps you're just seeding a hash table or something)</font><br>
<p>
Hash tables use random seeds for security, to protect against DOS attacks where an O(n) operation becomes O(n^2) with carefully-chosen inputs. If they didn't care about security, they could just use a hard-coded seed.<br>
<p>
Maybe that's not as security-critical as e.g. generating cryptographic keys, but trying to precisely specify different levels of security sounds impractical.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor802634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 15:03 UTC (Fri)
                               by <b>nicoonoclaste</b> (guest, #128640)
                              [<a href="/Articles/802634/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
The root of the problem in 5.3 was the blocking behavior of getrandom(), which will prevent a caller from proceeding until enough entropy has been collected to initialize the random-number generator. This behavior was subjected to a fair amount of criticism, and few felt the need to defend it.
</blockquote>

<p>
The author got that wrong: the thing which has been a subject of criticism for years is the behaviour of <code>random(4)</code>, which blocks at unpredictable times when the kernel's entropy pool “runs out”.  This is not only inconvenient for userspace applications, but also completely nonsense cryptographically: a well-designed RNG does not “run out of entropy” and become predictable if it was seeded with 256b of entropy and 256b of its outputs were revealed; claiming this is the case is essentially equivalent to claiming encryption, stream ciphers in particular, is impossible...
</p>

<p>
<code>getrandom(2)</code>'s blocking behaviour, on the other hand, is the correct one: <b>block once</b> in the lifetime of the system, until the RNG is initialised, then never block again.
</p>

<p>
To the author's credit, that misconception seems pretty widespread: even Linus Torvalds <a href="https://lkml.org/lkml/2019/9/15/316">gets it wrong.</a>
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/802634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 15:09 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/802654/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      What, exactly, did I get wrong?  The blocking (by default) behavior was, indeed, subjected to a lot of criticism.  The <tt>getrandom()</tt> API would be different if it could be redesigned now.  The fact that <tt>/dev/random</tt> <i>also</i> has its problems doesn't change that.
      
          <div class="CommentReplyButton">
            <form action="/Articles/802654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 16:30 UTC (Fri)
                               by <b>kroeckx</b> (guest, #65877)
                              [<a href="/Articles/802658/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
getrandom() has a had a non-blocking version from the start, by passing GRND_NONBLOCK. But applications that really want a secure random number have the following options:<br>
- Return an error, fail to start the application.<br>
- Wait until a secure random number is available.<br>
<p>
Since the first thing isn't an option for most things, and if getrandom() would not block by default, all applications would just need repeatedly call getrandom(). There is nothing an application can or should do to generate entropy. I don't see the advantage of not waiting in the kernel.<br>
<p>
You do not want openssh just fail to start during boot, never being able to log in. If there is no secure random number yet, you want it to wait.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802667"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 18:03 UTC (Fri)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/802667/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You've missed the whole discussion then, which centers around the fact that things that _don't_ need secure random numbers are calling getrandom(2), blocking, and stopping the boot from proceeding. Things that _actually_ need secure random numbers are generally well-written enough that they won't cause such problems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802667/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor802671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 18:42 UTC (Fri)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/802671/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There is nothing an application can or should do to generate entropy. </font><br>
<p>
The application could print a message to the screen instructing the user to bang on the keyboard, move the mouse etc. which would create entropy that the kernel can use. Not feasible for non-interactive usage, of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor805821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 30, 2019 8:52 UTC (Sat)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/805821/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
**We need to generate a lot of random bytes. It is a good idea to perform<br>
some other action (type on the keyboard, move the mouse, flood 192.0.2.30<br>
with IP traffic) during the prime generation; this gives the random number<br>
generator a better chance to gain enough entropy.<br>
Not enough random bytes available.  Please do some other work to give<br>
the OS a chance to collect more entropy! (Need 210 more bytes)**<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/805821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor802670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 18:40 UTC (Fri)
                               by <b>dkg</b> (subscriber, #55359)
                              [<a href="/Articles/802670/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      This definitely makes me concerned.
<p>
If userspace in early boot requests strong entropy, and the kernel doesn't have state, then blocking is the right thing to do.  If userspace is failing because of that, then userspace needs to make the decision about how to make that tradeoff.
<p>
Do we have any data about how this jitter-entropy mechanism plays out in actual hardware, or in common virtual machine platforms?  Do we have any tests that evaluate the entropy of the bits received, and are people actively running those tests against the proposed kernel at scale?
<p>
If we're not testing it and evaluating it, but just squinting at the code and guessing that it looks fine, we're setting Linux users up for a future security disaster (or ongoing series of security disasters, maybe, perhaps one per hardware/VM platform) that will make <a href="https://factorable.net/weakkeys12.extended.pdf">Mining Your Ps and Qs</a> look harmless by comparison.
      
          <div class="CommentReplyButton">
            <form action="/Articles/802670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 19:34 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/802674/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Jitter entropy actually works better on regular VMs. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802686"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 22:24 UTC (Fri)
                               by <b>dkg</b> (subscriber, #55359)
                              [<a href="/Articles/802686/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Do you have evidence for this?  I'd love it to be true, but I would want to understand why it's true, and to have some data.
<p>
Does it work better or worse under a threat model where an adversary controls the co-tenanted VMs on the same host?
      
          <div class="CommentReplyButton">
            <form action="/Articles/802686/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 22:30 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/802687/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here it is: <a href="https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/Studien/ZufallinVMS/Randomness-in-VMs.pdf?__blob=publicationFile&amp;v=3">https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publi...</a><br>
<p>
Jitter entropy works because parts of the system are not perfectly synchronized. Adding more sources of uncertainty adds even more unpredictability, unless hypervisors tamper with RDTSC.<br>
<p>
<font class="QuotedText">&gt; Does it work better or worse under a threat model where an adversary controls the co-tenanted VMs on the same host? </font><br>
Probably doesn't matter.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor802672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 19:56 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/802672/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If userspace is failing because of that, then userspace needs to make the decision about how to make that tradeoff.</font><br>
<p>
But expecting userspace to make this decision and to handle the situation well is no longer reasonable. A properly written userspace application would simply fail its transaction or, more likely, simply exit.[1] But then that makes the application unusable, which is intolerable as a practical matter in the vast majority of situations. The consequence is that userspace will attempt to reimplement hacks like the above (or not and still continue), except they're much more poorly positioned than the kernel to scrounge together any available entropy and are much more likely to get it horribly wrong.<br>
<p>
With ubiquitous use of cryptographic techniques (not just for transport, but for ASLR, hash seeding, etc) has come ubiquitous   reliance on a system entropy facility. We've crossed a threshold where applications expect a reliable entropy source, and rightly so. The prevalence of hardware entropy sources and drivers for those sources  hasn't *quite* kept pace, but it's close enough that most software authors can and do operate on the fiction that entropy is always available as justification for making ubiquitous use of it. From a global systems perspective (i.e. ecosystem of products, services, and software) overall security is improved, even though the fiction might prove catastrophic in a handful of circumstances. (But most of those circumstances involved IoT devices or VMs, and there's a strong argument that most if not all of the culpability for such catastrophes lie with the designers of those products for failing to ensure entropy is available at boot time.)<br>
<p>
Making this leap may actually be *necessary* to finally close the gap between reliance on and the actual prevalence of hardware sources. It puts those in the position to provide and support hardware sources on notice about the need for those sources; this much has been clear for at least a decade, but now it's clear that the responsibility is firmly and permanently in their court. In fact, IMO there's a case to be made that there should be *no* way for userspace to determine the availability of entropy. That forces systems designers to make the choice between ensuring availability of hardware sources and maintaining a hacked kernel, rather than wasting any more effort to sustain the status quo where they can shift blame to third-party code when things go wrong<br>
<p>
Expectation of and reliance on strong entropy is a great simplifier--not only architecturally but also in channeling efforts so that the expectations are actually met.<br>
<p>
[1] There's a weird argument going around that some applications use getrandom but don't actually *need* strong entropy for security. From a security engineering perspective that sounds like a horribly confused, brittle, and extremely risky state of affairs. If you think your system is "more secure with it", but "not insecure without it" then one of those statements is either wrong or will silently, inevitably become wrong. This is similar to the argument for why the jitter hack is bad--that it creates confused and risky expectations. But the jitter hack is 1) in principle temporary; 2) understood to be best effort (i.e. it's not making any specific claims); 3) centralized, well known, and significantly less of a hidden landmine; and 4) acts as a forcing function to actually improve the overall state of affairs.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor802676"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 20:34 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/802676/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>&gt; If userspace in early boot requests strong entropy, and the kernel doesn't have state, then blocking is the right thing to do. If userspace is failing because of that, then userspace needs to make the decision about how to make that tradeoff.

<p>I have several problems with that:
<ol>
<li><b>Userspace is not a monolith</b> - Unlike the kernel, a wide variety of disparate applications and services need to run during startup. Unless the system has been very carefully engineered, most of these applications and services have no or very little knowledge of one another. To some extent, distros can do a certain amount of centralized planning and testing to make sure that nothing is catastrophically incompatible, but auditing every early boot process for sane getrandom() usage may not be feasible. Also, distros lack specific knowledge of individual threat models and have to make these decisions with incomplete information.
<li><b>Userspace may not know what the Right Thing is</b> - A video game or other entertainment application "obviously" doesn't need secure randomness... unless people are betting real money on the outcome. OpenSSH "obviously" needs secure randomness... unless the whole machine or instance is untrusted, and we don't actually need any part of it to be secure in the first place. Are we going to put a flag on every single application that calls getrandom()? Of course not; the proper place to for a global setting like that is a kernel command-line argument, or maybe even compiling your own "unsafe getrandom()" kernel.
<li><b>The kernel exists to serve userspace</b> - so it's inappropriate for the kernel to break userspace and then demand that userspace fix the problem.
</ol>
      
          <div class="CommentReplyButton">
            <form action="/Articles/802676/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2019 22:24 UTC (Fri)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/802682/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many years ago, long before any sort of parallel startup on Linux was<br>
the norm, I configured a headless system to use /dev/random to create a<br>
key for encrypted swap, and hit the obvious problem:  the system would<br>
hang at startup waiting for entropy.<br>
<p>
Normally that entropy would have come from the disk IO that would have<br>
been produced by later stages of the system startup, but the system<br>
had blocked at this point in the very sequential boot process waiting<br>
for entropy.<br>
<p>
This system had no other inputs for entropy--the random device accepted<br>
neither timing jitter nor network packets for entropy, there were no<br>
other processes yet running to generate disk IO this early in the boot,<br>
the CPU had no RNG instruction, and the machine had no other IO devices<br>
connected to it like a mouse or keyboard.  It was a NAS box, one NIC and<br>
some disks were all the IO interfaces.  The kernel would never collect<br>
a single bit of further entropy under those conditions.<br>
<p>
It seemed weird that the kernel derived entropy from neither NIC activity<br>
nor timing jitter.  I didn't question it at the time--I presumed that<br>
people smarter than me had figured that these entropy sources were<br>
unusable (network too easy for an attacker to control, timing jitter<br>
not random enough?).  (Note this was a long time ago, I haven't checked<br>
recently whether the kernel still behaves this way)<br>
<p>
My fix at the time was to fork the encrypt/mkswap/swapon process.<br>
Swap would be added as soon as the running system had generated enough<br>
entropy for a key, and with a full suite of service daemons hammering<br>
all disks with IO that event was pretty much certain.<br>
<p>
I am pleased to see that a decade later we are still arguing about how<br>
to solve this problem.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor802718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 20, 2019 15:46 UTC (Sun)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/802718/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What I'm missing is a real discussion over the underlying assumptions. The issue is not that the kernel is not getting enough entropy, it's that the entropy is an estimate and extremely conservative one at that.<br>
<p>
For example, network traffic could in theory all be controlled by an attacker and so the safe choice was made to consider it adding no entropy, whereas in fact in the vast majority of cases it would add loads of entropy since attacks controlling all incoming packets is something that only happens in theory.<br>
<p>
Same with this patch, the kernel assumes it's only adding 1 bit each time, in fact it's probably adding much more than that, we just have no idea how much. Entropy is a rather theoretical measure.<br>
<p>
On the other side we have the consumption of random. It's assumed that if we extract 128 bits of random from a pool with 128 bits of entropy we could somehow predict what will be generated. But we also assume that if we have a 128-bit AES key we can encrypt megabytes of data with it safely for a long time. These can't both be true.<br>
<p>
The reality is that the random pool once initialised can generate all the randomness we ever need. As soon we we have the idea the pool has at least 128-bits of entropy, we can assume that it can produce secure output. No-one is going to attack the random pool by trying to predict its state from the output, they're going to use side-channel attacks to read it directly (cf the $5 wrench attack). Your defence is to simply keep adding new stuff as often as possible so that even if someone manages to read some of it it's useless moments later.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/802718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor804789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2019 14:49 UTC (Thu)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/804789/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Video games don't (usually) need true randomness. But on the other hand, having a video game hang on boot is not the end of the world. Having all your embedded devices have one of the same SSH keys because only a few bits of entropy were available *is* the end of the world and all your devices are now part of a botnet trying to take down Bruce Schneier's blog.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/804789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor803845"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Really fixing getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2019 7:22 UTC (Tue)
                               by <b>eduard.munteanu</b> (guest, #66641)
                              [<a href="/Articles/803845/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is a reasonable usecase when you can't preseed the CSPRNG? Most embedded devices have at least some persistent memory and you only need 16-32 bytes to store the state. The kernel should rather provide a way to save and reload this state.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/803845/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
