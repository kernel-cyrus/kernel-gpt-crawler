        <!DOCTYPE html>
        <html lang="en">
        <head><title>LFCS: The LLVMLinux project [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/549203/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/549089/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/549203/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>LFCS: The LLVMLinux project</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>May 7, 2013</br>
           </div>
<p>
The <a
href="http://events.linuxfoundation.org/events/collaboration-summit">Linux
Foundation Collaboration Summit</a> (LFCS) seems to be a likely venue for an 
update on the status of building the kernel with Clang/LLVM.  Both <a
href="/Articles/441018/">in 2011</a> and <a
href="/Articles/493312/">2012</a>, we covered those updates. LFCS 2013
continued the trend as <a
href="http://llvm.linuxfoundation.org/index.php/Main_Page">LLVMLinux
project</a> lead Behan Webster presented the status and plans for the
project at LFCS.  The gathering lived up to its name as well, since two
problems faced by the project were solved through collaboration at the summit. 
</p>

<img src="https://static.lwn.net/images/2013/lfcs-llvmlinux.png" align="right" hspace=5 width=135
height=135 alt="[LLVMLinux logo]">

<p>
Webster is a computer engineer who has worked in a lot of different
industries: automotive, telecommunications, embedded systems, etc.  For
20 years or so, he has worked on Linux, using it either as a development
environment 
or as the operating system of a shipping product.  He is the project lead
for the LLVMLinux project, which is an effort to get the Linux
kernel to build with Clang and LLVM.
</p>

<p>
<a href="http://llvm.org/">LLVM</a> is a set of libraries that can be used
to build tools, he said.  Those tools could be compilers, linkers, or JITs,
or they could be tools for source code analysis, metadata extraction, code
refactoring, and so forth.  Most of the latter kinds of tools don't
directly relate to LLVMLinux, but the toolchain for building C, C++, and
Objective C programs does.  The toolchain starts with <a href="http://clang.llvm.org/">Clang</a>, the frontend for C-family
programs, but
there are other pieces as well, including the <a
href="http://compiler-rt.llvm.org/">compiler-rt</a> library, <a
href="http://lld.llvm.org/">lld</a> and <a
href="http://code.google.com/p/mclinker/">MCLinker</a> linkers, <a
href="http://clang-analyzer.llvm.org/">checker</a> static analyzer, <a
href="http://lldb.llvm.org/">LLDB</a> debugger, and others.
</p>

<h4>Why?</h4>

<p>
There are a number of reasons, beyond just simply having a choice, that
make compiling Linux with LLVM a useful endeavor.  For one thing, it
compiles faster, which is important to reduce the time of the
code-compile-run-debug cycle.  LLVM is a fast-moving project, Webster said,
and it is "amazing how fast Clang has caught up" to GCC in some areas.  It
generates faster code than GCC in some areas&mdash;slower code in others.
</p>

<p>

LLVM is already being used in many different domains, like audio and video
in such projects as <a
href="http://www.mesa3d.org/llvmpipe.html">llvmpipe</a>, <a
href="https://developer.nvidia.com/what-cuda">CUDA</a>, and <a href="http://developer.android.com/guide/topics/renderscript/index.html">Renderscript</a>.  There is an
advantage to having a single toolchain used in all of these different
domains as compiler extensions only need to be written once and can then
apply in lots of different places.  LLVM also has a different
license&mdash;BSD-style&mdash;which is not better or worse than others, Webster
said, but it allows tool vendors to do things with LLVM that they couldn't
with GCC.  LLVM is also well-supported by a large group of full-time
developers.
</p>

<p>
The static analyzer for LLVM is "amazing", though it does not yet work on
the kernel code.  This tool has traditionally done better than other,
similar tools.  One of the headline features is "fix-it hints", which are
suggestions for fixing small, localized problems in the source; a similar
feature now appears 
in GCC 4.8.  That is one example where we are seeing "more and better"
development from both projects because of the competition between them,
Webster said.
</p>

<p>
The Google compiler team has built a tool around LLVM that shows a novel
use of the compiler toolkit.  The tool looks for common problems that
appear as certain patterns in the
LLVM intermediate representation 
and can map them back to the C++ code to show the programmer where they
made an error.  This shows things that you can do that we haven't seen
before, he said.
</p>

<p>
Beyond Android's use of LLVM for Renderscript and Gallium3D's llvmpipe
driver, there are also <a href="/Articles/487359/">distributions</a>
looking at building all or parts of 
their repositories using LLVM.  For Debian, Sylvestre Ledru has been
building the repository using Clang.  His most recent <a
href="http://sylvestre.ledru.info/blog/sylvestre/2013/02/06/rebuild_of_debian_using_clang_3_2">results</a>
show that there are more failures than before, Webster said, because new
versions of Clang are more strict.  Gentoo is <a
href="https://bugs.gentoo.org/show_bug.cgi?id=408963">looking at support
for LLVM/Clang</a>, as is <a href="https://wiki.freebsd.org/BuildingFreeBSDWithClang">FreeBSD</a>. 
</p>

<h4>LLVMLinux</h4>

<p>
The goal of the LLVMLinux project is to get to the point where the kernel
will build with LLVM.  Ultimately, that means that LLVM would have
everything it needs to build the kernel, while the kernel would get any changes
it requires so that it can be built with LLVM.  
</p>

<p>
To that end, the project has a <a
href="http://git.linuxfoundation.org/llvmlinux.git">Git repository</a> for
its build framework that
contains scripts and patches to build the kernel.  The scripts
fetch, patch, and build  various pieces, like LLVM/Clang, toolchains for
cross assembly and 
linking, the kernel, and QEMU. 
</p>

<p>
Several cross-toolchains are supported, including Codesourcery (which is
the default), Linaro/Ubuntu, and Android.  Those are necessary for the GNU
assembler and linker, as those pieces for LLVM are not yet mature enough to
use for building the kernel.  There
is support in the project's tree for various targets, including 
Versatile Express, x86-64, Raspberry
Pi, and Nexus&nbsp;7.  There are other
targets in progress, including the Galaxy S3 and BeagleBone. 
</p>

<p>
The project is using <a href="http://buildbot.net/">Buildbot</a> for
continuous integration.  Any time there is a commit in the project, LLVM, or
kernel repositories, a full build is kicked off.  In addition, the <a
href="http://ltp.sourceforge.net/">Linux Test Project</a> suite is run
nightly using QEMU for the Versatile Express.
</p>

<h4>Problem areas</h4>

<p>
Getting to this point has been "challenging", Webster said, as there are a
number of difficulties the project has run into.  To start with, LLVM's
integrated assembler (IA) can't be used on kernel code because it doesn't
handle the format used by the kernel's assembly code.  In addition, IA does
not handle 16-bit code.  Building would be faster using IA, he said, but
that's just 
not possible right now, which results in a dependency on the GNU toolchain.
</p>

<p>
The Linux code is GCC-specific in a number of ways.  GCC (and thus the
kernel) conforms to the 
gnu89 standard, while Clang conforms to gnu99 (which is "essentially C99"
with some GCC additions).  Webster thinks that a future version of GCC will
move to C99, which will help.  Kernel developers have long said that
the standard is insufficient, so the kernel code goes beyond it in various
ways.  But, the standards have largely caught up, he said, though there are
still some "notable exceptions".  It is almost as if the Linux kernel has
been driving the C standards. 

<p>
Beyond that, there are some GCC flags that
the kernel uses which are not supported by Clang.  Some of the built-in
functions are very different between Clang and GCC.  Another problem area
is Kbuild, which is also GCC-specific. In particular, unsupported flags
cause different return values from GCC and Clang.  In both cases, a warning
is issued, but the different return code causes problems.
</p>

<p>
There are several GCC flags that are not supported by Clang, including
<tt>-fconserve-stack</tt>, <tt>-fdelete-null-pointer-checks</tt>,
<tt>-fno-inline-functions-called-once</tt>, and
<tt>-mno-thumb-interwork</tt>.  More details on these can be found in the <a
href="http://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/09/2012-LPC-LLVMLinux-bw2.odp">slides
[ODP]</a> from Webster and Mark Charlebois's 2012 Linux Plumbers Conference
talk.
</p>

<p>
There are a handful of GCC language extensions that will never be part of
LLVM/Clang, he said, including variable-length arrays in structures
(VLAIS). Zero-length arrays at the end of structures are supported, as are
variable-length arrays outside of structures, but constructs like:
<pre>
    struct foo {
        char a[n];
    } bar;
</pre>
are not allowed by C99 or the more recent C11.  The LLVM developers are not
inclined to add VLAIS, as it makes the compiler harder to maintain, so
LLVMLinux has to try to convince kernel developers to remove them.
Currently, iptables, cryptographic hashing (HMAC), and a few other places
use VLAIS and the maintainers like the code the way it is, Webster said.
But the project has been running some tests on alternatives and getting the
same or slightly better performance by switching away from VLAIS. 
</p>

<p>
A member of the audience asked if it made sense to fork Clang to add VLAIS
support, but Webster downplayed that option.  All of the Clang developers
are of a single mind about this particular feature, he said, though they
would be supportive of a fork if someone decided to take that path.  In the
end, it comes down to changing "dozens 
of lines" of kernel code versus a "significant architectural change" in the
LLVM toolchain. 
Turning the arrays into pointers is an easy way to fix the problem, but
some maintainers don't want to take changes just to support a different
compiler, he said, in answer to follow-on questions.
</p>

<p>
Nested functions are another problem area, but they are used infrequently.
In general, when patches come in that have nested functions, the kernel
developers have pushed back and asked for a rewrite.  However, the Thinkpad
ACPI driver still has nested functions, though Webster sent a patch to
change that.  He has not yet heard back, but it is just a rearrangement of
the code, without any functional change.
</p>

<p>
Neither of those two features are in the C standard, nor are they used very
frequently in the kernel.  It would be relatively easy to not require
them.  The other extensions used by the kernel are "innocuous and simple",
he said.  For example, Clang does not support variables explicitly assigned
to specific CPU registers, but
he would 
like to see that support get added.
</p>

<p>
A recently discovered bug in Clang's C preprocessor is behind a problem
with section reference mismatches.  The attributes being used to put
<tt>__init</tt> and <tt>__exit</tt> functions into different ELF sections
are being mishandled.  Webster "firmly  
believes" that the kernel pushes the tools harder than any other code base,
and this is one example where that pushing has found bugs.  It is probably
just a corner case that had not been tested (or exercised by other code
built with Clang), resulting in various "section reference mismatch" and
"merged global" messages (as well as kernel module loading problems on x86)
when the kernel was linked. 
</p>

<p>
Webster then mentioned <tt>__builtin_const_p()</tt>, which GCC makes
available to test whether the argument is a constant value, but LLVM cannot
support as it cannot really make that distinction.  At that point,
Steven Rostedt started poking around in the kernel code, asking the
occasional question.  In a post-summit email, Webster said that Rostedt
tracked the use of <tt>__builtin_const_p()</tt> down to a particular commit
in <tt>mm/slab.c</tt> made by 
Christoph Lameter, who was also present at the summit.  Within 24 hours,
Rostedt and Lameter worked out a replacement; Rostedt was even
able to run it by Andrew Morton, who agreed in principle to the change.   
</p>

<h4>Status</h4>

<p>
For LLVM, all required patches from the project are now upstream.  There
are still some outstanding issues, including the section reference mismatch
problem above.  He believes that Clang 3.3 will mostly work out of the box
for building kernels with the LLVMLinux patches.

<p>
Another outstanding issue is a segmentation fault in Clang when  
it is compiling <tt>arch/arm/mm/context.c</tt>.  That problem seemed to be
related to using atomic_64 operations along with nearby inline assembly
code and Webster was having difficulty creating a simple test
case. After the talk, another attendee, Konstantin Serebryany, suggested
using <a 
href="http://embed.cs.utah.edu/creduce/">creduce</a>, which is an
LLVM-based tool that can bisect code to try to find a minimal subset that
reproduces a problem.  By the time Webster started figuring out the tool
later that day,
Serebryany had attached a minimal test case to the <a
href="http://llvm.org/bugs/show_bug.cgi?id=15676">bug report</a>.  Within
another few days, it was fixed in the LLVM tree.  In his email, Webster
paraphrased the famous saying by noting that LFCS showed him that
"the right eyes make bugs shallow". 
</p>

<p>
There are still some kernel patches that need to be pushed upstream as well.
Kbuild support, removing VLAIS use, handling <tt>__builtin_const_p()</tt>,
and so on, all need solutions either in the upstream kernel or elsewhere.

<p>
It is not strictly necessary, but he would like to use the LLVM integrated
assembler for its speed, too.  Getting the checker static analyzer to run
on the kernel would 
be useful as well.
</p>

<p>
Anyone wanting to help will find a variety of ways to do so, Webster said.
Helping to push patches upstream or work on unsupported features is one way.  In
addition, LLVMLinux is just working for x86 and ARM right now, adding MIPS and
other architectures would be nice.  As might be guessed, interested folks
will find information on mailing lists, IRC, and more on the project's web
page. 
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-LLVM">Development tools/LLVM</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Collaboration_Summit-2013">Collaboration Summit/2013</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/549203/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor549583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 7, 2013 17:43 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/549583/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <i> It is almost as if the Linux kernel has been driving the C standards. </i>
<p>
There is literal truth to this. Our own Paul McKenney was deeply involved in defining and standardizing a memory model that rigorously supports C++ multi-threading, for C++11. (Up until now all multi-threaded programs have relied on not-too-clever optimizers, the over-specified x86 memory bus, not-too-many cores, and luck.) The ISO C Standard committee adapted the C++ memory model for their own use, with compatible semantics.  The Linux kernel benefits from the newly rigorous C memory model.
<p>
The x86 over-specified memory bus design makes interaction of threads on more than a few cores impractical, as the bus spends a growing fraction of its time keeping all the caches up to date, leaving less time for real work.  The new C++ and C memory models relax some consistency requirements to make more parallelism practical, but that makes reasoning about shared memory in multi-threaded programs even trickier. (When core A writes to address P, when might core M see the new value there?)  While the rules are now rigorous, they are also too hard for mere mortals with other interests to use correctly: clever shortcuts fail for reasons that are hard to explain. Ultimately, better languages will apply the rules implicitly. In the meantime, we must rely on higher-level abstractions and avoid reasonable-seeming shortcuts.
      
          <div class="CommentReplyButton">
            <form action="/Articles/549583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor549591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 7, 2013 18:06 UTC (Tue)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/549591/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Do you know of any source that explains this new memory model in a way mere mortals can understand (and most importantly&mdash;provides examples of "good" and "bad" interactions)?
<p>I'd love to learn more, but from my experience with standards, they are generally the wrong source for study&hellip; (Except if you <em>really</em> want to spend significant time with the subject)
      
          <div class="CommentReplyButton">
            <form action="/Articles/549591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor549596"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 7, 2013 18:50 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/549596/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A good approximation is <br>
<p>
<a href="http://www.google.com/search?q=memory+model+herb+sutter">http://www.google.com/search?q=memory+model+herb+sutter</a><br>
<p>
The better you understand these topics, the less you will trust code that touches on them, and the more astonished you will be to see anything appear to work right.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549596/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor549663"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 8, 2013 16:18 UTC (Wed)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/549663/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That two part talk by herb was scary awesome, at least for this mortal, user-space programmer.  Thanks for the link.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549663/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor549739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 8, 2013 23:19 UTC (Wed)
                               by <b>bgmarete</b> (guest, #47484)
                              [<a href="/Articles/549739/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rather tangentially, I was recently very intrigued to learn that under Go's memory model, if one goroutine writes to a global variable, another goroutine need not ever see the new value unless you use a lock or a channel for synchronization. Not sure but I guess that this simplifies implementation on various machines (or in C).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor549941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 9, 2013 23:31 UTC (Thu)
                               by <b>jameslivingston</b> (guest, #57330)
                              [<a href="/Articles/549941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's similar to Java's memory model, where only synchronization causes happens-before constraints, meaning you need to use it, volatile variable or Atomic* to guarantee the other threads see changes.<br>
<p>
It both simplifies implementation and improves performance because unless you do something involving concurrency interactions you don't have to pay the cost for ensuring consistency between concurrent threads.<br>
<p>
<p>
It allows the JIT compiler to make what would otherwise be completely unsafe optimisations. For a chuck of code which contains none of those concurrency interaction points, the JIT compiler can assume that all values untouched by that code are effectively constants (even across method calls).<br>
<p>
In the mostly-uncontended case, the JIT compiler will even make known-unsafe optimisations, with a small "did another thread change anything" check which when it fails, causes it to bail out of the unsafely-optimised code into a "fix everything up" slow path. You can't really do that in C since you can do too many things in your own code :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor549594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 7, 2013 18:19 UTC (Tue)
                               by <b>tstover</b> (guest, #56283)
                              [<a href="/Articles/549594/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you have good link for more reading on this?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor550465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux driving C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 13, 2013 18:42 UTC (Mon)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/550465/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me, the formalizations of the C++11 memory model by a research group at Cambridge are the clearest description:<br>
<a href="http://www.cl.cam.ac.uk/~pes20/cpp/">http://www.cl.cam.ac.uk/~pes20/cpp/</a><br>
<p>
They also have a tool with which tells you about all the possible executions of small pieces of code:<br>
<a href="http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem">http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/550465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor549632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 8, 2013 9:57 UTC (Wed)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/549632/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Nested functions are another problem area, but they are used infrequently.</font><br>
<p>
Does GCC nowadays generate correct code for nested functions also on ARM?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor549741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 8, 2013 23:33 UTC (Wed)
                               by <b>csamuel</b> (<b>&#x272D; supporter &#x272D;</b>, #2624)
                              [<a href="/Articles/549741/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; LLVM also has a different license—BSD-style—which is not better</font><br>
<font class="QuotedText">&gt; or worse than others, Webster said, but it allows tool vendors</font><br>
<font class="QuotedText">&gt; to do things with LLVM that they couldn't with GCC.</font><br>
<p>
Like change it and not tell you how it's been changed; so if you're on an OS that bundles it you can no longer replicate that compilation environment yourself as you won't necessarily be able to get their changes to the compiler.<br>
<p>
I'm not sure that's an improvement (for me, at least).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor549764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 9, 2013 5:03 UTC (Thu)
                               by <b>hpa</b> (guest, #48575)
                              [<a href="/Articles/549764/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If LLVMLinux depends on the kernel removing all uses of __builtin_constant_p() then they might as well give up now.  It is an incredibly useful construct when building certain types of low-level building blocks, and we will continue to use it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor549821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 9, 2013 13:49 UTC (Thu)
                               by <b>jake</b> (editor, #205)
                              [<a href="/Articles/549821/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If LLVMLinux depends on the kernel removing all uses of</font><br>
<font class="QuotedText">&gt; __builtin_constant_p()</font><br>
<p>
Well, there must be something special about the one in mm/slab.c.  I'm not sure what that is, but, as you point out, there are lots of uses of it in the kernel; there was no mention of removing them all.<br>
<p>
jake<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/549821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor550481"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2013 1:37 UTC (Tue)
                               by <b>nlewycky</b> (guest, #63373)
                              [<a href="/Articles/550481/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      The premise of builtin_constant_p is that if the input can be folded into a constant then it returns true, else it returns false. The first problem is that compiler optimizers are a stack of transformations that run -- they don't iterate until the program converges. Consequently there is a fixed set of optimizations that will run before builtin_constant_p is evaluated and another fixed set of optimizations that run afterwards. If you choose to evaluate builtin_constant_p too early then it may fold to false even though the compiler ends up resolving the expression to a constant, but if you evaluate it too late then you're missing the optimizations that folding it will expose.
<p>
The most common use of builtin_constant_p looks something like this:
<pre>
  if (__builtin_constant_p(val)) {
    return __bswap_constant_64(val);
  } else {
    __asm__("bswap %0", ...);
</pre>
which is a really bad idea. Inline assembly is a great way to tie your compiler's hands and prevent any optimizations. Even if you called this with a constant input, the compiler sure can't optimize it now. The right answer isn't even __builtin_bswap64, it's to write the functionality in C and file bugs if your compiler doesn't emit the assembly it should.
<p>
Of course you might think that this sample code is fine anyways, because if there were constant arguments it takes the __bswap_constant_64 branch which folds it away. Setting aside the optimization ordering problem above, builtin_constant_p doesn't return true on everything you might consider constant.
<p>
For instance &ldquo;<tt>static const int x = 0x1234; bool test() { return __builtin_constant_p(x); }</tt>&rdquo;, returns false at -O0 and true at -O2. Here's another &ldquo;<tt>static const char *x = &quot;abc&quot;; bool test { return __builtin_constant_p(x); }</tt>&rdquo; that returns false even at -O2. Why? You see, glibc uses builtin_constant_p in its macro definition of strcpy in such a way that if builtin_constant_p were to return true and builtin_strlen failed to calculate the string length, it would miscompile your program (reading off the end of the string). If builtin_strlen can't fold it, builtin_constant_p must return false. Except that it also returns true on integers. Sometimes. My point is that there's rules here that are undocumented except that if you changed gcc's builtin_constant_p to return true more often and violated those assumptions you'd notice when programs built with glibc were miscompiled, so that's good I guess?
<p>
As for Clang, it evaluates builtin_constant_p() before any optimizations have run, which is correct but conservative. It also makes sense because your code already needs to work when builtin_constant_p returns false, unless you're actually relying on gcc's optimizer not changing in the future.
      
          <div class="CommentReplyButton">
            <form action="/Articles/550481/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor550499"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2013 5:08 UTC (Tue)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/550499/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Here's another “static const char *x = "abc"; bool test { return __builtin_constant_p(x); }” that returns false even at -O2. Why?</font><br>
<p>
I don't believe your explanation.<br>
<p>
To start with, x isn't const in your example: it can be modified. However, it seems that the optimizer *is* smart enough to figure out that a variable not declared const is actually never modified, and treat it as if it was const. That's good and sensible, and thus not actually the issue here.<br>
<p>
So, even with:<br>
  static const char * const x = "abc";<br>
gcc still returns false for __builtin_constant_p.<br>
<p>
This actually makes perfect sense, because you're actually asking if the pointer itself is a constant value, but said pointer value isn't known until link time. And __builtin_constant_p's contract is to return true only if it is a compile-time-constant (and thus if expressions containing it could be constant-folded).<br>
<p>
This appears to have nothing to do with builtin_strlen, which *does* in fact evaluate to a constant 3 as one might expect.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/550499/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor550504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2013 7:16 UTC (Tue)
                               by <b>nlewycky</b> (guest, #63373)
                              [<a href="/Articles/550504/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Sorry, I didn't mean to say that the only reason builtin_constant_p returned false for that example is because of its contract with builtin_strlen. I have no idea why it returns false in that case. I was trying to point out that these undocumented contracts exist.
<p>
<blockquote class="FormattedComment">
<font class="QuotedText">&gt;And __builtin_constant_p's contract is to return true only if it is a compile-time-constant (and thus if expressions containing it could be constant-folded).</font></blockquote>
<p>
Counterexample, <tt>__builtin_constant_p(&quot;string literal&quot;)</tt> is true, even though the address of that string isn't known at compile time. You already pointed out that the equivalent program written with a variable instead of a literal is not considered constant, which is surprising because it makes no difference to the optimizer or any program semantics. For more fun, try <tt>&amp;&quot;asd&quot;[0]</tt> and <tt>&amp;&quot;asd&quot;[1]</tt>.
<p>
So if it does return true for some pointers, why not the one in your example? I thought it's because some builtins are guaranteed to fold when their arguments are literals but not when their arguments are variables, even const variables, hence builtin_constant_p must be conservative enough to work with all builtins&mdash;but also aggressive enough to run after inlining or else user code will break once again. I thought &quot;some builtins&quot; included builtin_strlen, but apparently I'm mistaken.
<p>
I remembered my glibc example a little wrong. The parts I'm thinking of are bits/string2.h, from the #define strncmp (which uses strlen and builtin_constant_p) and ultimately calls down into the #define'd __strcmp_gc which in turn dereferences string[0] through string[3]. And consider a user's program:
<pre>
static unsigned char BOM[] = { 0xEF, 0xBB, 0xBF };
bool test() { return strncmp(..., (char *) BOM, 3)); }
</pre>
The only thing preventing that from reading off the end of BOM is a contract between builtin_constant_p and strlen (really builtin_strlen through more macros) that it won't return true for any pointers unless builtin_strlen can analyze them.
<p>
By the way, if glibc simply didn't #define strncmp, gcc would recognize the function by name and do all the right optimizations itself, better than it can with these builtin_constant_p-using macros in the way.

      
          <div class="CommentReplyButton">
            <form action="/Articles/550504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor550173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">llvm-based tools vs. clang-based tools</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2013 5:57 UTC (Sat)
                               by <b>nlewycky</b> (guest, #63373)
                              [<a href="/Articles/550173/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"The Google compiler team has built a tool around LLVM that shows a novel use of the compiler toolkit. The tool looks for common problems that appear as certain patterns in the LLVM intermediate representation and can map them back to the C++ code to show the programmer where they made an error. This shows things that you can do that we haven't seen before, he said."<br>
<p>
This paragraph is mixing two sorts of tools. There are tools based on the clang's ASTs which are normally static tools, such as the compiler warnings, the AST matchers and clang mapreduce. None of these involve matching on LLVM IR, rather, these work by matching patterns in your C++ code and can thus point to the problems in the written C++ code.<br>
<p>
Then there are tools based on LLVM IR which are (so far) all dynamic tools, address/thread/memory sanitizer, but they don't really map back to C++ code. They produce reports similar to valgrind.<br>
<p>
We don't have any tools that match patterns in LLVM IR and then point out bugs in the C++ code. You can match LLVM IR and point out bugs in the final binary, or you can match clang ASTs and point out bugs in the incoming source code. Trying to go from LLVM IR back up to the original C++ code is hard, not designed for, and we don't do it. (In essence, you're relying on the correctness of optimized debug info, which LLVM doesn't do yet.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/550173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor550334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2013 16:58 UTC (Sun)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/550334/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the weirdest things I've seen LLVM being used for is Emscripten. Emscripten is way to compile code that can be compiled with LLVM. To be compiled as JavaScript-code. They've compiled things like OpenGL-games with Emscripten to run in the browser with WebGL.<br>
<p>
They even went a step further as a fun side project and compiled LLVM itself:<br>
<p>
<a href="http://badassjs.com/post/39573969361/llvm-js-llvm-itself-compiled-to-javascript-via">http://badassjs.com/post/39573969361/llvm-js-llvm-itself-...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/550334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor550610"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LFCS: The LLVMLinux project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2013 23:08 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/550610/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Turning the arrays into pointers is an easy way to fix the problem, but some maintainers don't want to take changes just to support a different compiler, he said,</font><br>
<p>
Then "some" maintainers are not very clever.<br>
<p>
Supporting an additional compiler is effectively supporting an additional static analysis tool (in one form or the others), which means finding more bugs. Tested and verified multiple times. Briefly mentioned in the article above. If and when that comes for cheap then you should certainly celebrate how lucky you are and pay the price immediately.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/550610/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
