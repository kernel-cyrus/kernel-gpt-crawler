        <!DOCTYPE html>
        <html lang="en">
        <head><title>The Kernel Hacker's Bookshelf: UNIX Internals [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/296738/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/295852/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/296738/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The Kernel Hacker's Bookshelf: UNIX Internals</h1>
</div>
<div class="ArticleText">
<div class="GAByline">
           <p>September 3, 2008</p>
           <p>This article was contributed by Valerie Aurora</p>
           </div>
<p>
Back in 2001, I landed my (then) dream job as a full-time Linux kernel
developer and distribution maintainer for a small embedded systems company.
I was thrilled - and horrified.  I'd only been working as a programmer
for a couple of years and I was sure it was only a matter of time
before my new employer figured out they'd hired an idiot.  The only
solution was to learn more about operating systems, and quickly.  So I
pulled out my favorite operating systems textbook and read and re-read
it obsessively over the course of the next year.  It worked well
enough that my company tried very hard to convince me not to quit when
I got bored with my "dream job" and left to work at Sun.
</p>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
That operating systems textbook was
<a href=http://portal.acm.org/citation.cfm?id=225502><i>UNIX
Internals</i></a> by Uresh Vahalia.  <i>UNIX Internals</i> is a careful, detailed
examination of multiple UNIX implementations as they evolved over
time, from the perspective of both the academic theorist and the
practical kernel developer.  What makes this book particularly
valuable to the practicing operating systems developer is that the
review of each operating systems concept - say, processes and threads
- is accompanied by descriptions of specific implementations and their
histories - say, threading in Solaris, Mach, and Digital UNIX.  Each
implementation is then compared on a number of practical levels,
including performance, effect on programming interfaces, portability,
and long-term maintenance burden - factors that Linux developers care
passionately about, but are seldom considered in the academic
operating systems literature.
</p>

<p>
<i>UNIX Internals</i> was published in 1996.  A valid question is whether a
book on the implementation details of UNIX operating systems published
so long ago is still useful today.  For example, Linux is only
mentioned briefly in the introduction, and many of the UNIX variants
described are now defunct.  It is true that <i>UNIX Internals</i> holds
relatively little value for the developer actively staying up to date
with the latest research and development in a particular area.
However, my personal experience has been that many of the problems
facing today's Linux developers are described in this book - and so
are many of the proposed solutions, complete with the unsolved
implementation problems.  More importantly, the analysis is often
detailed enough that it describes exactly the changes needed to
improve the technique, if only anyone took the time to implement them.
</p>

<p>
In the rest of this review, we'll cover two chapters of <i>UNIX Internals</i>
in detail, "Kernel Memory Allocation" and "File System
Implementations."  The chapter on kernel memory allocation is an
example of the historical, cross-platform review and analysis that
sets this book apart, covering eight popular allocators from several
different flavors of UNIX.  The chapter on file system implementations
shows how lessons learned from the oldest and most basic file system
implementations can be useful when solving the latest and hottest file
system design problems.
</p>

<h3>Kernel Memory Allocation</h3>

<p>
The kernel memory allocator (KMA) is one of the most
performance-critical kernel subsystems.  A poor KMA implementation
will hurt performance in every code path that needs to allocate or free
memory.  Worse, it will fragment and waste precious kernel memory -
memory that can't be easily freed or paged out - and pollute hardware
caches with instructions and data used for allocation management.
Historically, a KMA was considered pretty good if it only wasted 50%
of the total memory allocated by the kernel.
</p>

<p>
Vahalia begins with a short conceptual description of kernel memory
allocation and then immediately dives into practical implementation,
starting with page-level allocation in BSD.  Next, he describes memory
allocation in the very earliest UNIX systems: a collection of
fixed-size tables for structures like inodes and process table
entries, occasional "borrowing" of blocks from the buffer cache, and a
few subsystem-specific ad hoc allocators.  This primitive approach
required a great deal of tuning, wasted a lot of memory, and made the
system fragile.
</p>

<p>
What constitutes a good KMA?  After a quick review of the functional
requirements, Vahalia lays out the criteria he'll use to judge the
allocators: low waste (fragmentation), good performance, simple
interface appropriate for many different users, good alignment,
efficient under changing workloads, reassignment of memory allocated
for one buffer size to another, and integration with the paging
system.  He also takes into consideration more subtle points, such as
the cache and TLB footprint of the KMA's code, along with cache and
lock contention in multi-processor systems.
</p>

<p>
<span class="PullQuote">
<span class="invisible">[PULL QUOTE: </span>
This is an
example of how even the oldest and clunkiest algorithms can influence the
design of the latest and greatest.
<span class="invisible"> END QUOTE]</span>
</span>


The first KMA reviewed is the resource map allocator, an extremely
simple allocator using a list of <tt>&lt;base, size&gt;</tt> pairs
describing each free segment of memory, sorted by base address.  The
charms of the resource map allocator include simplicity and allocation
of exactly the size requested; the vices include high fragmentation
and poor performance under nearly every workload.  Even this
allocation algorithm is useful under the right circumstances; Vahalia
describes several subsystems that still use it (System V semaphore
allocation and management of free space in directory blocks on some
systems) and some minor tweaks that improve the algorithm.  One tweak
to the resource map allocator keeps the description of each free
region in the first few bytes of the region, a technique later used in
the state-of-the-art SLUB allocator in the Linux kernel.  This is an
example of how even the oldest and clunkiest algorithms can influence the
design of the latest and greatest.
</p>

<p>
Each following KMA is discussed in terms of the problems it solves
from previous allocators, along with the problems it introduces.  The
resource map's sorted list of base/size pairs is followed by
power-of-two free lists with a one-word in-buffer header (better
performance, low external fragmentation, but high internal
fragmentation, esp. for exact power-of-two allocations), the
McKusick-Karels allocator (power-of-two free lists optimized for
power-of-two allocation; extremely fast, but prone to external
fragmentation), the buddy allocator (buffer splitting on power-of-two
boundaries plus coalescing of adjacent free buffers; poor performance
due to unnecessary splitting and coalescing), and the lazy buddy
allocator (buddy plus delayed buffer coalescing; good steady-state
performance but unpredictable under changing workloads).  The
accompanying diagrams of the data structures and buffers used to
implement each allocator are particularly helpful in understanding the
structure of the allocators.
</p>

<p>
After covering the simpler KMAs, we get into more interesting
territory: the zone allocator from Mach, the hierarchical allocator
from Dynix, and the SLAB allocator, originally implemented on Solaris
and later adopted by several UNIXes, including Linux and the BSDs.
Mach's zone allocator is the only fully garbage-collected KMA studied,
with the concomitant unpredictable system-wide performance slowdowns
during garbage collection, which would strike it from most developers'
lists of useful KMAs.  But as with the resource map allocator, we
still have lessons to learn from the zone allocator.  Many of the
features of the zone allocator also appear in the SLAB allocator,
commonly considered the current best-of-breed KMA.
</p>

<p>
The zone allocator creates a "zone" of memory reserved for each class
of object allocated (e.g., inodes), similar to kmem caches in the
later SLAB allocator.  Pages are allocated to a zone as needed, up to
a limit set at zone allocation time.  Objects are packed tightly
within each zone, even across pages, for very low internal
fragmentation.  Anonymous power-of-two zones are also available.  Each
zone has its own free list and once a zone is set up, allocation and
freeing simply add and remove items from the per-zone free list (free
list structures are also allocated from a zone).  Memory is reclaimed
on a per-page basis by the garbage collector, which runs as part of
the swapper task.  It uses a two-pass algorithm: the first pass counts
up the number of free objects in each page, and the second pass frees
empty pages.  Overall, the zone allocator was a major improvement on
previous KMAs: fast, space efficient, and easy to use, marred only by
the inefficient and unpredictable garbage collection algorithm.
</p>

<p>
The next KMA on the list is the hierarchical memory allocator for
Dynix, which ran on the highly parallel Sequent S2000.  One of the
major designers and implementers is our own Paul McKenney, familiar to
many LWN readers as the progenitor of the read-copy-update (RCU)
system used in many places in the Linux kernel.  The goal of the Dynix allocator was
efficient parallel memory allocation, in particular avoiding lock
contention between processors.  The solution was to create several
layers in the memory allocation system, with per-cpu caches at the
bottom and collections of large free segments at the top.  As memory
is freed or allocated, regions move up and down one level of the
hierarchy in batches.  For example, each per-cpu cache has two free
lists, one in active use and the other in reserve.  When the active
list runs out of free buffers, the free buffers from the reserve list
are moved onto it, and the reserve list replenishes itself with
buffers from the global list.  All the work requiring synchronization
between multiple CPUs happens in one big transaction, rather than
incurring synchronization overhead on each buffer allocation.
</p>

<p>
The Dynix allocator was a major advance: 3 - 5 times faster than the
BSD allocator even on a single CPU.  Its memory reclamation system was
far more efficient than the zone allocator's, performed on an on-going
basis with bounded worst case performance on each operation.
Performance on SMP systems was unparalleled.
</p>

<p>
The final KMA in this chapter is the SLAB allocator, initially
implemented on Solaris and later re-implemented on Linux and BSD.  The
SLAB allocator refined some existing techniques (simple allocation/free
computations for small cache footprint, per-object caches) and
introduced several new ones (cache coloring, efficient object reuse).
The result is an allocator that was both the best performing and the
most efficient by a wide margin - only 14% fragmentation versus 27%
for the SunOS 4.1.3 sequential-fit allocator, 45% for the 4.4BSD
McKusick-Karel allocator, and 46% for the SunOS 5.x buddy allocator.
</p>

<p>
Like the zone allocator, SLAB allocates per-object caches (along with
anonymous caches in useful sizes) called kmem caches.  Each cache has
an associated optional constructor and destructor function run on the
objects in a newly allocated and newly freed page, respectively (though the
destructor has since been removed in the Linux allocator).
Each cache is a doubly-linked list of slabs - large contiguous chunks
of memory.  Each slab keeps its slab data structure at the end of the
slab, and divides the rest of the space into objects.  Any leftover
free space in the slab is divided between the beginning and end of the
objects in order to vary the offset of objects with respect to the CPU
cache, improving cache utilization (in other words, cache coloring).
Each object has an associated 4-byte free list pointer.
</p>

<p>
The slabs within each kmem cache are in a doubly linked list, sorted
so that free slabs are located at one end, fully allocated slabs at
the other, and partially allocated slabs in the middle.  Allocations
always come from partially allocated slabs before touching free
slabs.  Freeing an object is simple: since slabs are always the same
size and alignment, the base address of the slab can be calculated
from the address of the object being freed.  This address is used to
find the slab on the doubly linked list.  Free counts are maintained
on an on-going basis.  When memory pressure occurs, the slab allocator
walks the kmem caches freeing the free slabs at the end of the cache's
slab list.  Slabs for larger objects are organized differently, with
the slab management structure allocated separately and additional
buffer management data included.
</p>

<p>
This section of <i>UNIX Internals</i> has aged particularly well, partly
because the SLAB allocator continues to work well on modern systems.
As Vahalia notes, the SLAB allocator initially lacked optimizations
for multi-processor systems, but these were added shortly afterward,
using many of the same techniques as the Dynix hierarchical allocator.
Since then, most production kernel memory allocators have been
SLAB-based.  Recently, Christoph Lameter rewrote SLAB
to get the SLUB allocator for Linux; both are available as kernel
configuration options. (The third option, the SLOB allocator, is not
related to SLAB - it is a simple allocator optimized for small
embedded systems.) When viewed in isolation, the SLAB allocator may
appear arbitrary or over-complex; when viewed in the context of
previous memory allocators and their problems, the motivation behind
each design decision is intuitive and clear.
</p>

<h3>File Systems Implementations</h3>

<p>
<i>UNIX Internals</i> includes four chapters on file systems, covering the
user and kernel file system interface (VFS/vnode), implementations of
on-disk and in-memory file systems, distributed/network file systems,
and "advanced" file system topics - journaling, log-structured file
systems, etc.  Despite the intervening years, these four chapters are
the most comprehensive and practical description of file systems
design and implementation I have yet seen.  I definitely recommend it
over
<a href=http://www.wiley.com/WileyCDA/WileyTitle/productCd-0471164836.html><i>UNIX
File System Design and Implementation</i></a> - a massive sprawling book
which lacks the focus and advanced implementation details of UNIX
Internals.
</p>

<p>
The chapter on file systems implementations is too packed with useful
detail to review fully in this article, so I'll focus on the points
that are relevant to current hot file system design problems.  The
chapter describes the System V File System (s5fs) and Berkeley Fast
File System (FFS) implementations in great detail, followed by a
survey of useful in-memory file systems, including tmpfs, procfs
(a.k.a. <tt>/proc</tt> file system), an early variant of a device file
system called specfs, and a sysfs-style interface for managing
processors.  This chapter also covers the implementation of buffer
caches, inode caches, directory entry caches, etc.  One of the
features of this chapter (as elsewhere in the book) is the carefully
chosen bibliography.  Bibliographies in research papers serve a double
purpose as demonstrations of the authors' breadth of knowledge in the
area and tend to be cluttered with more marginal references; the
per-chapter bibliographies in <i>UNIX Internals</i> list only the most
relevant publications and make excellent supplementary reading guides.
</p>

<p>
System V File System (s5fs) evolved from the first UNIX file system.  The
on-disk layout consisted of a boot block followed by a superblock
followed by a single monolithic inode table.  The remainder of the
disk is used for data and indirect blocks.  File data blocks are
located via a standard single/double/triple indirect block scheme.
s5fs has no block or inode allocation bitmaps; instead it maintains
on-disk free lists.  The inode free list is partial; when no more free
inodes are on the list, it is replenished by scanning the inode table.
Free blocks are tracked in a singly linked list rooted in the
superblock - a truly terrifying design from the point of view of file
system repair, especially given the lack of backup superblocks.
</p>

<p>
In many respects, s5fs is simultaneously the simplest and the worst
UNIX file system possible: its throughput was commonly as little as 5%
of the raw disk bandwidth, it was easily corrupted, it had a 14
character limit on file names, and so on.  On the other hand, elements
of the s5fs design have come back into vogue, often without addressing
the inherent drawbacks still unsolved in the intervening decades.
</p>

<p>
The most striking example of a new/old design principle illustrated by
s5fs is the placement of most of the metadata in one spot.  This
turned out to be a key performance problem for s5fs, as every uncached
file read virtually guaranteed a disk seek of non-trivial magnitude
between the location of the metadata at the beginning of the disk and
the file data, located anywhere except the beginning of the disk.  One
of the major advances of FFS was to distribute inodes and bitmaps
evenly across the disk and allocate associated file data and indirect
blocks nearby.  Recently, collecting metadata in one place has
returned as a way to optimize file system check and repair time as
well as other metadata-intensive operations.  It also appears in
designs that keep metadata on a separate high-performance device
(usually solid state storage).
</p>

<p>
The problems with these schemes are the same as the first time around.
For the fsck optimization case, most normal workloads will suffer from
the required seek for reads of file data from uncached inodes (in
particular, system boot time would suffer greatly).  In the separate
metadata device case, the problem of keeping a single,
easily-corrupted copy of important metadata returns.  Currently, most
solid-state storage is less reliable than disk, yet most proposals to
move file system metadata to solid state storage make no provision for
backup copies on disk.
</p>

<p>
Another cutting edge file system design issue first encountered in
s5fs is backup, restore, and general manipulation of sparse files.
System administrators quickly discovered that it was possible to
create a user-level backup that could not be restored because the
tools would attempt to actually write (and allocate) the zero-filled
unallocated portions of sparse files.  Even more intelligent tools
that do not explicitly write zero-filled portions of files still had
to pointlessly copy pages of zeroes out of the kernel when reading
sparse files.  In general, the file and socket I/O interface requires
a lot of ultimately unnecessary copying of file data into and out of
the kernel for common operations.  It has only been in the last few
years that more sophisticated file system interfaces have been
proposed and implemented, including SEEK_HOLE/SEEK_DATA
and <tt>splice()</tt> and friends.
</p>

<p>
The chapters on file systems are definitely frustratingly out of date,
especially with regard to advances in on-disk file system design.
You'll find little or no discussion of copy-on-write file systems,
extents, btrees, or file system repair outside of the context of
non-journaled file systems.  Unfortunately, I can't offer much in the
way of a follow-up reading list; most of the papers in my
<a href=http://lwn.net/Articles/196292/>file systems reading list</a>
are covered in this book (exceptions include the papers on soft
updates, WAFL, and XFS).  File systems developers seem to publish less
often than they used to; often the options for learning about the
cutting edge are reading the code, browsing the project wiki, and
attending presentations from the developers.  Your next opportunity
for the latter is the <a href=http://linuxplumbersconf.org/>Linux
Plumbers Conference</a>, which has a number of file system-related
talks.
</p>

<p>
Another major flaw in the book, and one of the few places where
Vahalia was charmed by an on-going OS design fad, is the near-complete
lack of coverage of TCP/IP and other networking topics (the index
entry for TCP/IP lists only two pages!).  Instead, we get an entire
chapter devoted to streams, at the time considered the obvious next
step in UNIX I/O.  If you want to learn more about UNIX networking
design and implementation, this is the wrong book; buy some of the
Stevens and Comer networking books instead.
</p>

<h3>Summary</h3>

<p>
<i>UNIX Internals</i> was the original inspiration for the Kernel Hacker's
Bookshelf series, simply because you could always find it on the
bookshelf of every serious kernel hacker I knew.  As the age of the
book is its most serious weakness, I originally intended to wait until
the planned second edition was released before reviewing it.  To my
intense regret, the planned release date came and went and the second
edition now appears to have been canceled.
</p>

<p>
<i>UNIX Internals</i> is not the right operating systems book for everyone;
in particular, it is not a good textbook for an introductory operating
systems course (although I don't think I suffered too much from the
experience).  However, <i>UNIX Internals</i> remains a valuable reference book
for the practicing kernel developer and a good starting point for
the aspiring kernel developer.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Kernel_Hackers_Bookshelf">Kernel Hacker's Bookshelf</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Aurora_Henson_Valerie">Aurora (Henson), Valerie</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/296738/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor296788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2008 21:11 UTC (Wed)
                               by <b>johnkarp</b> (guest, #39285)
                              [<a href="/Articles/296788/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I found this article interesting and enlightening. But more as an article about memory managers and filesystems, than about the book. The book seemed almost forgotten midway through.<br>
<p>
If the article were a wiki page, I'd split it into two articles: a book review, and a brief history of KMA and filesystems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 15:27 UTC (Thu)
                               by <b>salimma</b> (subscriber, #34460)
                              [<a href="/Articles/296921/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I understand it, those are the two most important chapters in the book, and the two with continuing relevance despite the book's age.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor296942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 16:41 UTC (Thu)
                               by <b>vaurora</b> (guest, #38407)
                              [<a href="/Articles/296942/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Jon won't publish straight book reviews - he insists on this annoying "technical content" business.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor296792"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2008 21:39 UTC (Wed)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/296792/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      It's really hard to make money from books like this. A lot of effort gets put into them, and then you're lucky if they sell 5000 copies, because only a very rarefied audience is interested in them. And these days, people are much more likely to get the information they want from the web.
      
          <div class="CommentReplyButton">
            <form action="/Articles/296792/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2008 22:07 UTC (Wed)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/296797/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <p style="border-style: none none none solid;
   border-color: rgb(51, 51, 255);
   border-width: 3px;
   padding: 0.2em 1em;
   color: darkred;
   max-width: 60em;
   margin-top: 1em;
   margin-left: 0.5em;">It's really hard to make money from books like this. A lot of effort gets put into them, and then you're lucky if they sell 5000 copies, because only a very rarefied audience is interested in them. And these days, people are much more likely to get the information they want from the web.</p>

<p>Which is a shame, really.  It's interesting to see how both the quality and availability of information increased substantially after the printing press was invented, but now with the Internet it seems that the quality is decreasing even though the availability continues to increase.</p>

<p>Thanks to Valerie for her contribution.  Articles like hers make my subscription to LWN all the more worthwhile.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/296797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2008 23:54 UTC (Wed)
                               by <b>mattdm</b> (subscriber, #18)
                              [<a href="/Articles/296808/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
       <p style="border-style: none none none solid;
   border-color: rgb(51, 51, 255);
   border-width: 3px;
   padding: 0.2em 1em;
   color: darkred;
   max-width: 60em;
   margin-top: 1em;
   margin-left: 0.5em;">Which is a shame, really. It's interesting to see how both the quality and availability of information increased substantially after the printing press was invented, but now with the Internet it seems that the quality is decreasing even though the availability continues to increase.</p>

I'm <i>certain</i> the exact same comment was made around 1450 or so about the printing press vs. hand-lettered books.

I think actually the 90%-of-everything rule still applies, just has it always has. It's just a lot easier for you to see more of it, and if you take a certain attitude it's easy to let the junk occlude the good stuff.
      
          <div class="CommentReplyButton">
            <form action="/Articles/296808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 1:32 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/296824/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Good point.  I was going on pure intuition when I mentioned that the quality of articles increased after the printing press was invented--my intuitive thought was that errors in hand-scribed articles likely decreased.  But then again, with the rapid proliferation of printing press-published books, those few errors that made it through propagated rapidly and extensively.  Not unlike the Internet of today....</p>

<p>And thanks to JoeBuck's comment below.  I agree that those who publish quality content online aren't doing so for the $$$ (or &euro;, &yen;, &pound;, or whatever). :)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/296824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor296830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">90%</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 3:03 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/296830/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The 90%-of-everything-is-crap rule is known as <a href="http://en.wikipedia.org/wiki/Sturgeon's_Law" >Sturgeon's Law</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/296830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor296815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 0:24 UTC (Thu)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/296815/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      These kinds of works are usually written to make reputations rather than to make money; having written the definitive work on some subject can certainly help with getting hired, or getting tenure.

      
          <div class="CommentReplyButton">
            <form action="/Articles/296815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 4:24 UTC (Thu)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/296835/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Yes. But what you see, sometimes, because of that is that the book is not revised because the goal of tenure, etc., has been reached and the author isn't motivated to make the investment. And some folks don't get the intangible rewards they wanted from being an author (not that tenure is really intangible).<p>Of the various books in my series, I think only the Samba one got done in Samba's source code repository, and that one is probably the one that has most continued to live. If I do a series again, I'll make sure that all books have online source code repositories. Prentice has not done a good job of making the source available for my first 24 titles. But even with the Samba book it was hard to get the publisher to do a second edition, because there were lots of books that would come back from stores.<p>I can think of another book on Unix that had high expectations but turned out to be pretty much a flop for its author. I'd better not say which one, it'll start a fight.
      
          <div class="CommentReplyButton">
            <form action="/Articles/296835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2008 14:41 UTC (Mon)
                               by <b>branden</b> (guest, #7029)
                              [<a href="/Articles/297289/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not give a shot, Bruce?  Don't muzzle the discussion--your thoughts might trigger the author to barrel into this forum and take stock of his publishing endeavors, rather than getting his breeches in a bunch; he might have been keeping his powder dry for the past few years, and now has some high-caliber insights to volley.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2008 20:05 UTC (Mon)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/297388/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      If you knew who I was talking about you'd not say that :-)
      
          <div class="CommentReplyButton">
            <form action="/Articles/297388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2008 20:09 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/297400/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I get the sense the poster knew exactly who you were talking about...
      
          <div class="CommentReplyButton">
            <form action="/Articles/297400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2008 20:12 UTC (Mon)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/297410/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Oops. I read right over the double-entendres.
      
          <div class="CommentReplyButton">
            <form action="/Articles/297410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2008 21:03 UTC (Tue)
                               by <b>branden</b> (guest, #7029)
                              [<a href="/Articles/297558/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bruce,<br>
<p>
I must be getting subtle in my old age...<br>
<p>
Perish the thought!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor296821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 0:58 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/296821/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sometimes, what's available online is excellent. Consider Ulrich Drepper's series on memory serialized here at LWN:<br>
<p>
<a href="http://lwn.net/Articles/250967/">http://lwn.net/Articles/250967/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor296816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Amusing quote</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 0:50 UTC (Thu)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/296816/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Performance on SMP systems was unparalleled.</font><br>
<p>
Funny way of putting it, especially given that "The goal of the Dynix allocator was efficient parallel memory allocation..."<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Amusing quote</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 16:35 UTC (Thu)
                               by <b>vaurora</b> (guest, #38407)
                              [<a href="/Articles/296940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was hoping someone would notice that. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor296869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 9:51 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/296869/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <p>Newsflash!</p>

<p>
Properly written garbage collectors don't cause "unpredictable system-wide performance 
slowdowns during garbage collection" any more.
</p>

<p>
Since the 1980s people have understood how to limit the amount of work done
by running the garbage collector in "slices".  It is also now well-understood how
to write efficient concurrent garbage collectors (well-suited to the multicore
systems of today).  We also now know how to trade off performance vs
wasted memory in garbage collection.  Some of the most advanced garbage
collectors can make real time guarantees.
</p>

<p>
Given that the Linux kernel is doing a lot of reference counting, which
is the worst performing, most wasteful form of garbage collection there is,
perhaps it is time to look again at doing real GC.
</p>

<p>Rich.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/296869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 13:04 UTC (Thu)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/296889/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought Python's GC also used reference counting. What better alternatives are there? Scanning memory for anything that looks like a pointer doesn't seem to be one. Perhaps built a reference graph of all allocated memory, and remove all disjunct pieces or something? But that seems to have more overhead than reference counting. I don't know much about GC...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296893"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 13:22 UTC (Thu)
                               by <b>knobunc</b> (subscriber, #4678)
                              [<a href="/Articles/296893/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The "What the Heck Is?" series of posts by Dan Sugalski was good:<br>
  <a href="http://www.sidhe.org/~dan/blog/archives/cat_what_the_heck_is.html">http://www.sidhe.org/~dan/blog/archives/cat_what_the_heck...</a><br>
<p>
In particular he has one about GC:<br>
  <a href="http://www.sidhe.org/~dan/blog/archives/000200.html">http://www.sidhe.org/~dan/blog/archives/000200.html</a><br>
<p>
He was posting good overviews of CS topics so that people could work on Parrot (the proposed Perl VM).<br>
<p>
But a more thorough review of GC technology on LWN would be appreciated!<br>
<p>
-ben<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296893/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor296902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 14:06 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/296902/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><i>I don't know much about GC...</i></p>

<p>
So it seems.  Have a look at <a 
href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Wikipedia</a> then 
for the serious end of garbage collection take a look at Richard Jones [no relation]'s <a 
href="http://www.cs.kent.ac.uk/people/staff/rej/gc.html">garbage collection resources page</a> 
and in particular his book.
</p>

<p>Rich.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/296902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2008 13:12 UTC (Fri)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/297113/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Umm, Wikipedia just mentions two basic types of GC, a reachability based one and a reference counting based one, and I mentioned both methods without knowing a thing about GC. Same for the "What the heck is: Garbage Collection" article mentioned in the comment above, and the book doesn't seem to mention anything fundamentally different either, just goes into details (same ideas, different algorithms, though interesting ones. Especially the copying one is smart, as it solves the fragmentation problem). Isn't there another paradigm of doing GC out there? Or is the little I know really all that's to know about GC on a high level?<br>
<p>
I was totally wrong on the overhead/cost though. ;-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor302694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2008 9:24 UTC (Sat)
                               by <b>anomalizer</b> (<b>&#x272D; supporter &#x272D;</b>, #53112)
                              [<a href="/Articles/302694/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you are interested in GC options in general, try reading up about the various GC developments that have been happening in the Java world. Things have moved a long way from reference counting algoithms. The caveat of course is that what works for Java is not going to work for the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/302694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor296919"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">But still, no point in using GC if not needed</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 15:45 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/296919/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are indeed a number of high-performance garbage collectors, even real-time garbage collectors.  However, even these garbage collectors impose significant overhead and slowdown -- the overhead/slowdown is not eliminated, but rather spread out in bite-sized chunks over time.  Alternatively, high-priority tasks are permitted to preempt the garbage collector, which has its own set of advantages and disadvantages.  And the key point is that KMAs can be constructed without requiring garbage collection in the common case.<br>
<p>
Less-common cases where KMA garbage collection can be helpful include: (1) when flat out of memory, reclaiming blocks from the per-CPU caches lets the system creep along a bit farther, perhaps giving OOM a chance to do its job, (2) when shipping blocks from one NUMA node to another upon kfree(), one might use a timeout to avoid leaving blocks pending for KMAs that care about segregating memory on a NUMA basis (and DYNIX/ptx needed to care, given the huge remote latencies of the NUMA-Q hardware), (3) where real-time response is required, high-priority processes might just dump memory onto a per-CPU list and let low-priority processes clean up after them, and (4) if the Linux kernel ever supported real garbage collection.  I don't expect this latter any time soon, especially given that a recent attempt to write a kernel in a garbage-collected language encountered severe GC-related overhead (<a href="http://web.cecs.pdx.edu/~mpj/pubs/plos07.html">http://web.cecs.pdx.edu/~mpj/pubs/plos07.html</a>).  :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296919/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor296924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 16:17 UTC (Thu)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/296924/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      This is a matter for much religious argument, although in cases like the kernel it's probably not a significant use of time or resources. Reference counting can be bug-prone, if you aren't using a language like C++ where it can be entirely automated. It is deterministic, uses very small slices per iteration, and works well at interrupt level. Even with reference counting, GC may be necessary to take care of a circular reference.<p>
I prefer a double-indirect system with reference counting and occasional GC, because it can resolve the fragmentation problem. CPUs could be built to optimize this similarly to the way they handle TLBs. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/296924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 16:36 UTC (Thu)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/296938/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p><i>It is deterministic, uses very small slices per iteration [...]</i></p>

<p>
But is it?  Is there not a case where you're freeing up blocks "deterministically" and
then the block you just freed happens to complete a large hole and kfree/free suddenly
goes off and does a lot of work to update its internal structures?  (Or
the corresponding case when allocating).
</p>

<p>These costs are often minimized
by proponents of manual allocation.  There's a rather well-known
<a href="http://www-cs.canisius.edu/~hertzm/gcmalloc-oopsla-2005.pdf">paper
about this</a> which goes into the subject in a lot of detail, and comes
to some mixed conclusions.  (Mind you, the benefit of GC is it
massively simplifies programming and removes a huge source
of error, which they don't take into account).
</p>

<p>Rich.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/296938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor296953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 17:10 UTC (Thu)
                               by <b>vaurora</b> (guest, #38407)
                              [<a href="/Articles/296953/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
Your description made me curious so I skimmed the paper.  I wouldn't describe this as a "mixed conclusion":
</p>

<blockquote>
When garbage collection has five times as much memory
as required, its runtime performance matches or slightly exceeds
that of explicit memory management. However, garbage collections performance degrades substantially when it must use smaller
heaps. With three times as much memory, it runs 17% slower on
average, and with twice as much memory, it runs 70% slower.
</blockquote>

<p>
I'm afraid five times the memory consumption is not an option for the kernel.  Your point about removing a source of programming error is well taken, but more applicable to random user space widgets.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/296953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor296959"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 17:12 UTC (Thu)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/296959/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>Is there not a case where you're freeing up blocks "deterministically" and then the block you just freed happens to complete a large hole and kfree/free suddenly goes off and does a lot of work to update its internal structures?</blockquote><p>I don't see how GC would <i>improve</i> that situation. It's reasonably trivial to code a kernel allocator that doesn't go into some loosely-bounded task at interrupt level.<p>
GC has its own errors, especially if it's the kind that assumes any word might be a pointer.
      
          <div class="CommentReplyButton">
            <form action="/Articles/296959/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor303774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">1978 called, wants its garbage collectors back</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2008 6:00 UTC (Sun)
                               by <b>rarecactus</b> (guest, #51688)
                              [<a href="/Articles/303774/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Reference counting has a number of advantages. Namely:<br>
<p>
1) Lowest space overhead of any garbage collection scheme.<br>
Memory is released immediately after it is no longer used, not "whenever I get around to it."<br>
<p>
I would rather not see the OOM killer kill my processes just because someone in the kernel was slow to release what he allocated.<br>
<p>
2) The best cache locality of any garbage collection scheme.<br>
In the kernel, we always have to explicitly say when we're done with an object. That will always involve making some change to the object in memory. While it's loaded into the CPU's cache, why not free it as well?<br>
<p>
If you sweep the trash under the rug, you just have to spend more effort puling it out later. Why not put it in the trash can the first time around?<br>
<p>
Have you looked at a chart of gates per CPU versus DRAM clock lately? They are growing at different rates-- those curves have different big-Os with respect to time. Algorithms like copying garbage collecting which involve touching lots and lots of memory look increasingly old-fashioned. They are guaranteed to ruin the cache. In userspace you also have the problem of the GC accessing memory paged out to disk, which leads to terrible performance.<br>
<p>
3) It allows the programmer to specify a "destructor" type callback which can run when the resource is no longer needed.<br>
This is a nice bonus.<br>
<p>
This was one of the best features of C++. The fact that Java lacks real destructors is an endless source of pain for people working in that language, and motivated the inclusion of a similar feature in C#.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/303774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor296937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Userspace Memory Allocation</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 16:28 UTC (Thu)
                               by <b>scottt</b> (guest, #5028)
                              [<a href="/Articles/296937/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Naive question: how much did userspace malloc's learn from the various kernel allocators?<br>
<p>
I remember reading on LWN that part of Firefox 3's performance improvement came from adopting jemalloc and avoiding memory fragmentation on Windows:<br>
<a href="http://lwn.net/Articles/273001/">http://lwn.net/Articles/273001/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/296937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor297002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2008 19:17 UTC (Thu)
                               by <b>usvyatsky</b> (guest, #53746)
                              [<a href="/Articles/297002/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Too bad Uresh had never released the second edition. It has been announced and Amazon even accepted pre-orders, but for whatever reason it has not been published. Among other things, the second edition would presumably cover Linux as well.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2008 17:58 UTC (Fri)
                               by <b>vaurora</b> (guest, #38407)
                              [<a href="/Articles/297165/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, the second edition was on my pre-order list for ages, too.  My sources tell me that there was never any serious chance of it happening, but the publisher jumped the gun and led a lot of people to believe it would.  I think the take-away is that the publisher is probably very receptive to offers to do the second edition of UNIX Internals HINT HINT HINT.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2008 5:06 UTC (Sun)
                               by <b>snits</b> (guest, #37976)
                              [<a href="/Articles/297241/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I actually sent an email to Uresh about it a couple of years ago when the 2nd edition was being advertised on Amazon, and he said he had turned down working on the project because he didn't have time available to work on it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor297053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2008 0:04 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/297053/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am not usually a huge fan of Val's articles, but this one is an absolute gem.  It should be held out as an example for anyone doing a technical book review.  As reading it you came away knowing what the book does well, and what it doesn't do so well.  You also got the feeling that Val has read a few of them, and so you could give her opinions some weight.  She even answered the question "why would I not be better off just looking at the SLAB source code"?  (Answer: because it complex, and you won't understand the reason for the complexity without the history).<br>
<p>
As for the book covering file systems - its the wrong time for that.  The SLAB allocator is both state of the art and stable.  File systems are anything but.  We are going through a sea change right now.  Disk drives are literally becoming too big for our existing file systems.  You can't copy them in a reasonable time, and in fact can't even reasonably ask the user to wait for an fsck on boot.  There are so many sectors that can't even be sure some won't silently change - with the changes undetected by the disks ECC.  It won't be long before a bad block scan will take a week.  There are solutions emerging - zfs, btrfs, tux3, hammer.  It reminds me of the activity in the version control space no so long ago.  In a few years we will know what "start of the art" is, and some will write books about it, and hopefully Val will review them.  But now is not the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2008 2:44 UTC (Fri)
                               by <b>pflugstad</b> (subscriber, #224)
                              [<a href="/Articles/297067/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
In a few years we will know what "start of the art" is, and some will write books about it, and hopefully Val will review them. But now is not the time.
</blockquote>
<p>
Shoot, Val will be <b>writing</b> them.
      
          <div class="CommentReplyButton">
            <form action="/Articles/297067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor297082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2008 7:24 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/297082/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given what she's worked on in the past (e.g. at Sun), I think it safe to <br>
say your tense is wrong, or at least not inclusive enough. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor297079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Kernel Hacker's Bookshelf: UNIX Internals</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2008 7:18 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/297079/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are also media with profoundly different semantics emerging: very <br>
large 'sectors' that are faster to read than to write, that can be written <br>
a distinctly finite number of times, and with no concept of head movement <br>
or rotational latency. FSes on flash certainly will look different in ten <br>
years: I hope I'm not restricted to buying ugly VFAT-faked-by-chip at that <br>
point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/297079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2008, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
