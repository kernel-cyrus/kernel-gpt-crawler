        <!DOCTYPE html>
        <html lang="en">
        <head><title>A new kernel polling interface [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/743714/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/742985/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/743714/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A new kernel polling interface</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 9, 2018</br>
           </div>
Polling a set of file descriptors to see which ones can perform I/O without
blocking is a useful thing to do — so useful that the kernel provides three
different system calls (<a
href="http://man7.org/linux/man-pages/man2/select.2.html"><tt>select()</tt></a>,
<a
href="http://man7.org/linux/man-pages/man2/poll.2.html"><tt>poll()</tt></a>,
and <a
href="http://man7.org/linux/man-pages/man2/epoll_wait.2.html"><tt>epoll_wait()</tt></a>
— plus some variants) to perform it.  But sometimes three is not enough;
there is now a proposal circulating for a fourth kernel polling interface.
As is usually the case, the motivation for this change is performance.
<p>
On January 4, Christoph Hellwig posted <a href="/Articles/742978/">a new
polling API</a> based on the asynchronous I/O (AIO) mechanism.  This may
come as a surprise to some, since AIO is not the most loved of kernel
interfaces and it tends not to get a lot of attention.  AIO allows for the
submission of I/O operations without waiting for their completion; that
waiting can be done at some other time if need be.  The kernel has had AIO
support since the 2.5 days, but it has always been somewhat incomplete.
Direct file I/O (the original use case) works well, as does network I/O.
Many other types of I/O are not supported for asynchronous use, though;
attempts to use the AIO interface with them will yield synchronous
behavior.
In a sense, polling is a natural addition to AIO; the whole point of
polling is usually to avoid waiting for operations to complete.
<p>
The patches add a new command (<tt>IOCB_CMD_POLL</tt>) that can be passed
in an I/O control block (IOCB) to <a
href="http://man7.org/linux/man-pages/man2/io_submit.2.html"><tt>io_submit()</tt></a>
along with any of the usual <tt>POLL*</tt> flags describing the type of I/O
that is desired — <tt>POLLIN</tt> for data available to read, for example.
This command, like other AIO commands, will not (necessarily) complete
before <tt>io_submit()</tt> returns.  Instead, when the indicated file
descriptor is ready for the 
requested type of I/O, a completion event will be queued.  A subsequent
call to <a
href="http://man7.org/linux/man-pages/man2/io_getevents.2.html"><tt>io_getevents()</tt></a>
(or the <tt>io_pgetevents()</tt> variant, added by the patch set,
that blocks signals during the operation)
will return that event, and the calling application will know that it can
perform I/O on the indicated file descriptor.  AIO poll operations always
operate in the "one-shot" mode; once a poll notification has been
generated, a new <tt>IOCB_CMD_POLL</tt> IOCB must be submitted for that
file descriptor if further notifications are needed.
<p>
Thus far, this interface sounds more difficult to use than the existing
poll system calls.  There is a payoff, though, that comes in the form of
the AIO ring buffer.  This poorly documented aspect of the AIO subsystem
maps a circular buffer into the calling process's address space.  That
process can then consume notification events directly from the buffer
rather than calling <tt>io_getevents()</tt>.  Multiple notifications can be
consumed without the need to enter the kernel at all, and polling for
multiple file descriptors can be re-established with a single
<tt>io_submit()</tt> call.  The result, Hellwig said in the patch posting,
is an up-to-10% improvement in the performance of the <a
href="http://www.seastar-project.org/">Seastar</a> I/O framework.  More
recently, he <a href="/Articles/743723/">noted</a> that the improvement
grows to 16% on kernels with <a href="/Articles/741878/">page-table
isolation</a> turned on.
<p>
Internally to the kernel, any device driver (or other subsystem that
exports a <a
href="http://elixir.free-electrons.com/linux/v4.14.12/source/include/linux/fs.h#L1692"><tt>file_operations</tt></a>
structure) can support the new poll interface, but some small changes will
be required.  It is not, however, necessary to support (or even know about)
AIO in general.  In current kernels, the polling system calls are all
supported by the <tt>poll()</tt> method in <tt>struct file_operations</tt>:
<p>
<pre>
    int (*poll) (struct file *file, struct poll_table_struct *table);
</pre>
<p>
This function must perform two actions: setting up notifications for when
the underlying <tt>file</tt> is ready for I/O, and returning the types of
I/O that could be performed without blocking now.  The first is done by
adding one or more wait queues to the provided <tt>table</tt>; the driver
will perform a wakeup call on one of those queues when the state of the
device changes.  The current readiness state is the return value from the
<tt>poll()</tt> method itself.
<p>
Supporting AIO-based polling requires splitting those two functions into
separate <tt>file_operations</tt> methods.  Thus, there are two new entries
to that structure:
<p>
<pre>
    struct wait_queue_head *(*get_poll_head)(struct file *file, int mask);
    int (*poll_mask) (struct file *file, int mask);
</pre>
<p>
(The actual patches use the new typedef <tt>__poll_t</tt> for the
<tt>mask</tt>, but that typedef isn't in the mainline kernel yet).  The
polling subsystem will call <tt>get_poll_head()</tt> to obtain a pointer to
the wait queue that will be notified when the device's I/O readiness state
changes; <tt>poll_mask()</tt> will be called to get the current readiness
state.  A driver that implements these two operations need not (and
probably should not) retain its implementation of the older <tt>poll()</tt>
interface.
<p>
One potential limitation built into this API is that there can only be a
single wait queue that receives notifications for a given <tt>file</tt>.
The current interface, instead, allows multiple queues to be used, and a
number of drivers take advantage of that fact to use, for example,
different queues for read and write readiness.  Contemporary wait queues
offer enough flexibility that the use of multiple queues should not be
necessary anymore.  If a driver cannot be changed, Hellwig said, "<q>the
driver just won't support aio poll</q>"
<p>
There have not been a lot of comments in response to the patch posting so
far; many of the relevant developers have been preoccupied with other
issues in the last week.  It is hard to argue with a 10% performance
improvement, though, so some form of this patch seems likely to get into
the mainline sooner or later — interested parties can keep checking the
mainline repository to see if it's there yet.  Whether we'll see a fifth
polling interface added in the future is anybody's guess, though.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Asynchronous_IO">Asynchronous I/O</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#poll">poll()</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/743714/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor743751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2018 22:09 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/743751/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At least QEMU is certainly interested in this! Being able to poll the ring buffer for socket events would be a useful addition indeed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Similar interface for futex?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2018 23:40 UTC (Tue)
                               by <b>Nagarathnam</b> (guest, #116887)
                              [<a href="/Articles/743758/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess even futex could use something similar. An additional flag passed along with FUTEX_WAIT could label it as an asynchronous wait and when the futex is available, the event could be directly queued on an epoll fd registered during FUTEX_WAIT. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Similar interface for futex?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 6:14 UTC (Wed)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/743795/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Or, turn this around completely and funnel readiness notifications to futex... shameless plug: <a href="https://dl.acm.org/citation.cfm?id=1400100&dl=ACM&coll=DL&CFID=849708271&CFTOKEN=88571267">Extending futex for Kernel to User Notification</a>
      
          <div class="CommentReplyButton">
            <form action="/Articles/743795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Similar interface for futex?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 12, 2018 0:14 UTC (Fri)
                               by <b>Nagarathnam</b> (guest, #116887)
                              [<a href="/Articles/744106/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting. Has the patch been sent out for review?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 0:06 UTC (Wed)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/743770/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Removing a kernel/userspace transition is quite a big win. Glad to see it, and I wonder where else it might be applicable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 0:29 UTC (Wed)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/743773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AIO polling is fine, but wouldn't it be better still to just asynchronously perform the IO operation that you're going to perform anyway once the AIO poll indicates readiness? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">netlink ring buffer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 1:20 UTC (Wed)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/743780/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There was a netlink ring mmap ring buffer in earlier kernel versions, but it was removed because of security issues. Using a ring buffer is hard for requests because check/use issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">netlink ring buffer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 19:32 UTC (Wed)
                               by <b>stefanha</b> (subscriber, #55072)
                              [<a href="/Articles/743948/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's worth auditing the fs/aio.c ring buffer but I don't think the ring buffer is a bad thing per se.<br>
<p>
The Linux AIO ring buffer has been upstream since pre-git history.  It is not a new attack surface and this patch series doesn't even appear to touch the ring buffer code.<br>
<p>
Ring buffers are used across other security boundaries like cpu&lt;-&gt;hardware and VM&lt;-&gt;hypervisor so they can be implemented in a secure fashion.  Just as with syscalls, it's important to copy in untrusted data before validating it.  Ring buffer producers and consumers typically maintain their own state that is not accessible across the trust boundary.  They publish their internal state (e.g. ring indices) to the ring and fetch the other side's state from the ring, but that is secure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">netlink ring buffer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 11, 2018 12:37 UTC (Thu)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/744031/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's worth noting that the AIO ring buffer has had significant security issues in the past. It's just that apparently this interface is important enough that it got fixed instead of removed. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743813"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 10:33 UTC (Wed)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/743813/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, so what I always find puzzling about all those poll()-like interfaces: the more fds you start to handle the more likely it is you need to *priorize* handling some of them. And none of the kernel interfaces really helps you with that, which generally means userspace then has to add another complex layer in front of it, to order triggered event sources by their priority. glib does that, and so does systemd's sd-event. Yes, with epoll one can build a hierarchy of priorities by giving each priority class its own epoll fd an then nest them, but this is complex, nasty and increases the number of syscalls one has to do in each iteration.<br>
<p>
I think it would be quite good if kernel folks designing those interfaces would have a look at what userspace actually does with those APIs and then make things less awful to use, because quite frankly, all of select(), poll(), ppoll(), epoll are just plain terrible, just to different levels. Have a look how glib or systemd's sd-event end up handling priorization (or guarantee event ordering) or hook up waitid() to event loops, it's terrible the choices one has to make there. All the great optimizations that epoll supposedly permits, and this aio stuff will permit too are so entirely useless if in this iteration again it all comes crashing down as this only works in synthetic, very specific test cases, and not for any of the generic event loops that are used in userspace IRL.<br>
<p>
I couldn't care less about yet another API for all of this, even if it reduces the number of syscalls in niche cases even further, if we can't get the basic stuff done properly before. I'd much rather have a safe childfd() concept, and guaranteed event ordering/priorization in epoll  before anything else. Or just a usable inotify() or fanotify() would be great...<br>
<p>
Lennart<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743813/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 18:42 UTC (Wed)
                               by <b>zyga</b> (subscriber, #81533)
                              [<a href="/Articles/743941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you think the CLONE_FD patches that were circulating earlier have a chance of providing a childfd-like API?<br>
For reference: <a href="https://lwn.net/Articles/636646/">https://lwn.net/Articles/636646/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 21:07 UTC (Wed)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/743957/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe the kernel could look to Windows for inspiration? People seem to tolerate the async API there. Would be a nice bonus if we get something that Wine can benefit from too...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 21:16 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/743969/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Windows NT kernel is inherently asynchronous. All the major operations (barring aberrations like FastIO) are structured as filters or sinks for IRPs that can go through layers asynchronously.<br>
<p>
Additionally, userspace API in Windows (overlapped IO) is designed decidedly better than epoll.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor744686"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2018 9:42 UTC (Thu)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/744686/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What's wrong with inotify and fanotify?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744686/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor746613"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2018 4:15 UTC (Tue)
                               by <b>fest3er</b> (guest, #60379)
                              [<a href="/Articles/746613/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was just wondering this myself. A form of inotify in which the kernel tells the user which FD is addressed and what its new state is: ready-to-read, ready-to-write, read-closed, write-closed, closed, read-no-network, write-no-network, etc. Call it fdnotify.<br>
<p>
This could solve the problem of inotify-wait never exiting because it will never again write to its socket/pipe to a userspace program, and thus will never detect that the reader of the pipe has gone away; the only way to detect that the reader end of a pipe is gone is to write to the pipe. Proof? Hot-plug a drive. Run inotify-wait looking for that /dev node to be deleted, and pipe it to a shell script that waits for the drive to be unplugged. When you unplug the drive, inotify-wait tells the script which then continues its processing and exits. But the inotify-wait program sits there forever because the file it was watching for deletion has been deleted and can never be deleted again; and because it will never receive another notice of the file's deletion, it will never again write to the pipe and, thus, it won't detect that the shell script (the pipe's reader) is gone. It's a deficiency in Linux. (And no, if you re-connect the drive and unplug it again, the comatose inotify-wait wakes not, because the /dev node that instance of inotify-wait is watching no longer exists and will never again exist.)<br>
<p>
Polling is always wasteful. Even when there're no other options. So have a thread that reads the fdnotify FD, a thread that reads the inotify FD, a thread that reads the eventloop pipe FD, a thread that handles timeouts. Have each feed the dispatcher. No more polling. Action occurs only when something happens. Data transfer on the fdnotify FD should be small: 32 bits for the FD and 32 bits for the reason.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/746613/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor758453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2018 16:30 UTC (Wed)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/758453/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To detect that the read end of the pipe was closed, poll/epoll the write end of the pipe. This will report POLLERR/EPOLLERR when that happens.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/758453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor744802"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2018 19:17 UTC (Fri)
                               by <b>davmac</b> (guest, #114522)
                              [<a href="/Articles/744802/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I'd much rather have a ... guaranteed event ordering/priorization in epoll before anything else</font><br>
<p>
I don't see a lot of benefit to moving prioritisation into the kernel. You have to pick a particular priority model (eg. assign all event sources a fixed numerical priority) and if the userspace needs a more complex model (weighting based on latency, or whatever) then you're pretty much back to square one anyway.<br>
<p>
As it is, userspace has to maintain a queue of events, and the kernel just provides the events that go into the queue (this is assuming of course that you even need priority levels for different event sources, and that's not always the case). That's a pain, but you generally don't have to actually do it yourself - by which I mean, there are plenty of event loop libraries now which handle this for you.<br>
<p>
The notion that the kernel itself needs to provide an API that is straightforward and generally usable from applications is flawed. It's much better to have flexibility than a rigid policy in the kernel, when any inherent complexity can always be hidden behind a library layer.<br>
<p>
OTOH I completely agree it would be nice if there was a decent, reliable, non-signal way of watching process status via a file descriptor rather than the mess of listening for signals.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744802/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744804"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2018 20:19 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/744804/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I don't see a lot of benefit to moving prioritisation into the kernel. You have to pick a particular priority model (eg. assign all event sources a fixed numerical priority) and if the userspace needs a more complex model (weighting based on latency, or whatever) then you're pretty much back to square one anyway.</font><br>
<p>
Perhaps userspace could provide an eBPF program that implements a partial order over events, and the kernel can use that to do a topological sort.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744804/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor747861"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface--EBF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2018 0:25 UTC (Fri)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/747861/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Implementing priorities with EBF and a partial sort is an interesting thought. The issue of prioritization is a policy issue and thus something that generally belongs in user space. If you can't actually implement it in user space, however, sending in a proxy in the form of EBF seems safe and, one hopes, reasonably fast. Still, you may be handling a huge number of file descriptors and a design that only re-evaluates priorities when necessary. I've worked with companies that use a huge number of file descriptors in the past but I mostly do embedded systems these days and would not want to speak on what their requirements actually are.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/747861/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor743816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 11:10 UTC (Wed)
                               by <b>sasha</b> (guest, #16070)
                              [<a href="/Articles/743816/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is not clear if this new interface supports something like epoll edge-triggered notification.  I.e. I know that this socket is readable, and I do not want to read the 1 byte it has in the receive queue, but I want to be notified when the socket receives more data.  Is it possible with this new API?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 19:24 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/743949/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems like it's level-triggered only.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2018 19:03 UTC (Fri)
                               by <b>davmac</b> (guest, #114522)
                              [<a href="/Articles/744800/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It seems like it's level-triggered only.</font><br>
<p>
From the article:<br>
<p>
<font class="QuotedText">&gt; AIO poll operations always operate in the "one-shot" mode</font><br>
<p>
While "one-shot" isn't precisely the same thing as edge-triggered, they can largely be used with similar effect. If you want edge triggering and you have one-shot, you can arm a level-triggered one-shot listener and it will fire either immediately on the next "up" edge. Your application is in control of the "down" edge (i.e. you read all the data from the socket until you receive EAGAIN) and if you re-arm after that point, you effectively get notified of the next "up" edge in the same way that edge-triggered notification would.<br>
<p>
The main differences are that (a) you have to explicitly re-arm and (b) you won't get extra notifications if you happen to get two edges while processing (i.e. if you drain all data from the socket but more comes in before you do another read and notice that the buffer is empty). The (a) point is a down-side, but (b) is pretty much essential if you want to poll for events from multiple threads, since you can otherwise end up with more than one thread trying to service the same active connection.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763570"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2018 23:50 UTC (Mon)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/763570/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This sounds inherently racy.  With edge-triggered hardware interrupts, you can register your interest while interrupts are still blocked, and if something happens between finishing and unblocking interrupt, you get interrupted again. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763570/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2018 9:23 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/763658/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>You can set that up with level-triggered notifications; use a software mutex mechanism to stop things happening in parallel on one event source if necessary, then ask for a new notification immediately upon receiving one (or at a good point in your processing of incoming events), and you will be notified of new events that happen while you're processing the older ones.
<p>This is basically how the IRQ controller on hardware that resignals edge-triggered interrupts that came in while interrupts are blocked works - bear in mind that on some (older) IRQ controllers, edge-triggered interrupts that came in while interrupts are still blocked would simply be lost by the hardware due to the race between unblocking and the interrupt arriving.
      
          <div class="CommentReplyButton">
            <form action="/Articles/763658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor743951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 19:28 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/743951/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 I admit I have never understood edge-triggered polling very well. You need ioctl(FIONREAD) to know how many bytes you have in the receive queue, why not read it immediately? (Also, the kernel connection multiplexer can help avoiding this too).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744045"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 11, 2018 15:05 UTC (Thu)
                               by <b>kpfleming</b> (subscriber, #23250)
                              [<a href="/Articles/744045/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doing it this way leaves the buffering in the kernel; if you know that you can't do anything with the received data until at least 'x' bytes have arrived (packet headers, checksums, etc.) then someone has to buffer until that many bytes have arrived. Letting the kernel do it keeps the userspace program from being complicated with an extra layer of buffering.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744045/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 12, 2018 2:31 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/744110/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's what SO_RCVLOWAT is supposed to be for, but Linux doesn't honor that for polling :(<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor750797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2018 5:49 UTC (Tue)
                               by <b>anmolsarma</b> (guest, #123439)
                              [<a href="/Articles/750797/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SO_RCVLOWAT support was added to tcp_poll() 10 years ago (c7004482e8d). Am I missing something?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/750797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor750862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2018 1:22 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/750862/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
According to "man 7 socket", poll and select pay no attention to the value of SO_RCVLOWAT. But read does. A blocking read will block until SO_RCVLOWAT bytes are available.<br>
<p>
Now, I don't know what the kernel actually does since I haven't looked. But that's what the documentation says.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/750862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor757880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about edge-triggered notification?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2018 17:03 UTC (Wed)
                               by <b>nyrahul</b> (guest, #119310)
                              [<a href="/Articles/757880/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The man page seems is not updated for the latest code. poll() does seem to honor SO_RCVLOWAT i.e. you get a read event on the socket only on reaching the watermark level. Tried and tasted.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/757880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor743913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A couple of notes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 16:33 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/743913/">Link</a>] 
      </p>
      
      </div>
      </summary>
      There is <a href="/Articles/743912/">a new version of the patch series</a> out; it changes the <tt>file_operations</tt> prototypes a bit.
<p>
I forgot to mention in the article that early Red Hat kernels had this functionality with the same API, which means that the <tt>libaio</tt> library already has support for it.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 11, 2018 1:49 UTC (Thu)
                               by <b>xanni</b> (subscriber, #361)
                              [<a href="/Articles/743999/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"interested parties can keep checking the mainline repository to see if it's there yet"... hmm, maybe we could implement some sort of buffer to reduce the cost of polling?  Perhaps reading LWN for notifications... :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor746617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2018 4:19 UTC (Tue)
                               by <b>fest3er</b> (guest, #60379)
                              [<a href="/Articles/746617/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But that's still polling. Better to ask the repo to tell you when a new feature has been added in a particular area.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/746617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor744126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 12, 2018 9:58 UTC (Fri)
                               by <b>kkourt</b> (subscriber, #48092)
                              [<a href="/Articles/744126/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There is a payoff, though, that comes in the form of the AIO ring buffer. This poorly documented aspect of the AIO subsystem maps a circular buffer into the calling process's address space. That process can then consume notification events directly from the buffer rather than calling io_getevents().</font><br>
<p>
Any pointers on how this works?<br>
<p>
The relevant thing I found was this: <a href="http://git.infradead.org/users/hch/libaio.git/blob/refs/heads/aio-poll:/src/aio_ring.h">http://git.infradead.org/users/hch/libaio.git/blob/refs/h...</a>, i.e,. a way to check if the ring buffer is empty. The code here: <a href="http://git.infradead.org/users/hch/libaio.git/blob/refs/heads/aio-poll:/src/io_getevents.c#l28">http://git.infradead.org/users/hch/libaio.git/blob/refs/h...</a> uses it to avoid the syscall if there is nothing in the queue.  But, it will still enter the kernel to consume events.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 15, 2018 9:11 UTC (Mon)
                               by <b>stefanha</b> (subscriber, #55072)
                              [<a href="/Articles/744322/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Any pointers on how this works?</font><br>
<p>
<a href="https://git.qemu.org/?p=qemu.git;a=blob;f=block/linux-aio.c;h=88b8d55ec71076e24436ba4a80ec6de4d711e896;hb=HEAD#l131">https://git.qemu.org/?p=qemu.git;a=blob;f=block/linux-aio.c;...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor744548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2018 6:40 UTC (Wed)
                               by <b>fuuuuuuc</b> (guest, #120531)
                              [<a href="/Articles/744548/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Heh, keep reinventing this until at some point you give in and have something like kqueue. TL;DR main take away is Polling APIs on Linux suck, BSDs are much better in this regard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor748911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2018 10:46 UTC (Fri)
                               by <b>dcg</b> (subscriber, #9198)
                              [<a href="/Articles/748911/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There was kevent which was inspired in kqueue, I still don't understand why it didn't got merged.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/748911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor758454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2018 16:41 UTC (Wed)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/758454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This puzzles me as well. kqueue that predates epoll is just a better interface, why not just copy it? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/758454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor834987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A new kernel polling interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2020 1:57 UTC (Fri)
                               by <b>sergeyn</b> (guest, #142693)
                              [<a href="/Articles/834987/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How to unblock a waiting thread ? I assume this is what IO_CMD_NOOP is for, but I didn&#x27;t find any examples how to use it. Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/834987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
