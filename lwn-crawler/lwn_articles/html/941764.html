        <!DOCTYPE html>
        <html lang="en">
        <head><title>Defending mounted filesystems from the root user [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/941764/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/941868/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/941764/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Defending mounted filesystems from the root user</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 21, 2023</br>
           </div>
Making a filesystem implementation robust in the face of maliciously
created filesystem images is a challenging task even when the
implementation is actively maintained, which <a
href="/Articles/939097/">many in the kernel are not</a>.  There is a way to
make that task even harder, though: modify that filesystem image behind the
implementation's back while it is mounted.  A recent discussion on the
linux-fsdevel list reveals an ongoing disagreement over whether (and how)
this threat should be addressed.
<p>
Gabriel Krisman Bertazi recently posted <a
href="/ml/linux-fsdevel/20230812004146.30980-1-krisman@suse.de/">a patch
series</a> adding support for negative dentries on case-insensitive ext4
and F2FS filesystems.  Negative dentries cache the results of lookups on
files that do not exist, accelerating subsequent lookups.  Since this kind
of operation happens frequently (consider, for example, iterating through a
<tt>PATH</tt> environment variable to find an executable), this is an
important optimization.  Currently, though, negative dentries do not work
with case-insensitive filesystems; this patch series rectifies that
problem.
<p>
In the review discussion for this series, Eric Biggers <a
href="/ml/linux-fsdevel/20230812015915.GA971@sol.localdomain/">asked</a>
about a specific check for the case where an inode shows up with the
case-insensitive flag set, even though the filesystem has not been mounted
for case-insensitive operation.  This check was <a
href="https://git.kernel.org/linus/6456ca6520ab">added by Ted Ts'o</a> in
2019 to fix a crash experienced while fuzzing the filesystem.  Biggers
wondered why the test was placed at the inode's point of use rather
than when that inode is first read from the disk.
<p>
Ts'o <a
href="/ml/linux-fsdevel/20230812230647.GB2247938@mit.edu/">answered</a>
that the inode can change <i>after</i> it has been read into memory, in
certain conditions:
<p>
<blockquote class="bq">
	It's not enough to check it in ext4_iget, since the casefold flag
	can get set *after* the inode has been fetched, but before you try
	to use it.  This can happen because syzbot has opened the block
	device for writing, and edits the superblock while it is mounted.
</blockquote>
<p>
One might think that the case of writing to a mounted filesystem behind the
implementation's back would be one of those "don't do that" situations.  It
is not an action that is going to lead to a satisfying conclusion.  There
is, however, disagreement over what should be done about this case; Ts'o
continued:
<p>
<blockquote class="bq">
	One could say that this is an insane threat model, but the syzbot
	team thinks that this can be used to break out of a kernel lockdown
	after a UEFI secure boot.  Which is fine, except I don't think I've
	been able to get any company (including Google) to pay for
	headcount to fix problems like this, and the unremitting stream of
	these sorts of syzbot reports have already caused one major file
	system developer to burn out and step down.
</blockquote>
<p>
Biggers <a
href="/ml/linux-fsdevel/20230813043022.GA3545@sol.localdomain/">replied</a>
that fixing problems caused this way is the wrong approach:
<p>
<blockquote class="bq">
	Well, one thing that the kernel community can do to make things
	better is identify when a large number of bug reports are caused by
	a single issue ("userspace can write to mounted block devices"),
	and do something about that underlying issue instead of trying to
	"fix" large numbers of individual "bugs".
</blockquote>
<p>
He pointed out that Jan Kara has posted <a
href="/ml/linux-fsdevel/20230704122727.17096-1-jack@suse.cz/">a patch
set</a> that addresses that issue by adding a configuration option to
prohibit writing to block devices that are currently mounted.  Applying
this series — and configuring the kernel appropriately — would simply close
off that entire avenue of attack and, Biggers said, make a large number of
syzbot-reported bugs go away.
<p>
There is a minor problem or two with this approach, though.  One is that,
as Kara describes in the cover letter, enabling this option breaks a number
of things in both kernel and user space, including Btrfs mounting, loopback
mounts, and filesystem resizing.  Fixing these problems is seemingly not
overly difficult, but one cannot just enable this option in the kernel
until they <i>have</i> been fixed, and those fixes have found their way
onto deployed systems.  That is a process that will take years.
<p>
Even then, this series will prevent writing to a mounted <i>partition</i>,
but not to the device as a whole.  If <tt>/dev/sda1</tt> is mounted it
cannot be written to, but <tt>/dev/sda</tt> (which covers the whole device,
including the <tt>sda1</tt> partition) is still fair game.  And even
if that were fixed, as Ts'o <a
href="/ml/linux-fsdevel/20230704205529.GH1178919@mit.edu/">pointed out</a>,
there are other possible attacks, such as opening the SCSI-generic device
and sending commands directly to the storage device.  There is, it seems,
always another way for a sufficiently privileged account to create mayhem. 
<p>
Yet another problem is that, <a
href="/ml/linux-fsdevel/20230814113852.GD2247938@mit.edu/">according to
Ts'o</a>, the syzbot developers <a
href="/ml/linux-fsdevel/CACT4Y+aEScXmq2F1-vqAfr-b2w-xyOohN+FZxorW1YuRvKDLNQ@mail.gmail.com/">are
unwilling</a> to turn on this configuration option unless disabling it
would be hidden behind a new <tt>CONFIG_INSECURE</tt> option (to indicate
that doing so would make the system insecure).  Ts'o
objected to that positioning "<q>because that's presuming a threat model
that we have not all agreed is valid</q>".
<p>
So, even if Kara's series is applied to the kernel, it is a partial (albeit
worthwhile) fix that cannot be enabled in deployed systems for years, and
which will not be enabled by the people running the fuzzers.  Filesystem
developers will be limited to occasionally fixing symptoms of the problem
as they appear while dealing with floods of fuzzing reports and questioning
the basis on which these reports are made.  It seems fair to say that this
is not a great situation for anybody involved.
<p>
The real problem, arguably, is that there is no consensus within the
community regarding the threats that the kernel should try to address.  A
threat model that includes defending the system against its own root user
will require a huge hardening effort that many developers feel is both
impossible and pointless and which, in any case, does not have the funding
it would need to have a chance at succeeding.  The subset of the community
that is pushing for this threat model thus finds itself in conflict with
the rest.  Resolving that disagreement may turn out to be the hardest
problem of all.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Security">Filesystems/Security</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security">Security</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/941764/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor942325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 17:51 UTC (Mon)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/942325/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think there's any way to mount a defense (as implied here) against the root user. For example CONFIG_BLK_DEV_NBD, and probably CONFIG_ATA_OVER_ETH, CONFIG_VIRTIO_BLK, CONFIG_BLK_DEV_UBLK would all allow root to modify a "disk" fs, while it is mounted (even with the proposed work arounds).<br>
<p>
In fact CONFIG_USB_CONFIGFS_F_FS could also be use as such (make "worse" by the fact that most distro will turn around and auto-mount your trojan "USB drive", without root even having to take that step).<br>
<p>
In my humble opinion, this attempt is never going to work out, and there will always be glaring holes in attempts to "secure" a system that way. <br>
<p>
It would be better(in that there's a possibility it might be achievable) to have a mode (sysctl/sysfs twiddle maybe) that prevent new processes with uid 0 (possibly enforced at exec time). Of course that would be hard. And probably abusive to the system owners well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 17:55 UTC (Mon)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/942330/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Small correction: CONFIG_USB_CONFIGFS_F_FS would also require CONFIG_USB_DUMMY_HCD to practically attack the same systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 18:29 UTC (Mon)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/942334/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And probably abusive to the system owners well.</span><br>
<p>
I'd imagine that "being abusive to the system owners" is rather the point of all this commotion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 10:39 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/942381/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It may be naive, but I think the right approach is to break out the things that can be done by uid 0 into capabilities (yes, adding more capabilities -- they really should not be a scarce resource) and then introduce a slightly lower-privileged "admin" user, uid 1, which can do most of the things you'd do as root, but not the most dangerous low-level stuff.  And that might allow you to guarantee that "admin" cannot break out of a Secure Boot kernel, which sounds like a more reasonable threat model than trying to retrofit security restrictions on what was traditionally meant to be an unlimited-power God-mode user account.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942451"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 2:57 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/942451/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The traditional design of Unix is that root (or whatever uid=0 is called) can do a relatively small set of things:<br>
<p>
* Open any file regardless of permissions.<br>
* Impersonate any user with setuid(2) (or some equivalent).<br>
* Send any signal to any process, and make other adjustments to the process's state (such as renicing it).<br>
* Mount and unmount filesystems.<br>
* And probably a few other highly standardized actions (i.e. *not* Linux-specific things) I've forgotten about.<br>
<p>
Problem is, traditionally, you couldn't actually design an OS where root could only do things like the above. You also needed an interface for doing more complicated stuff, and especially for doing things in kernelspace (loading modules, debugging, enabling realtime scheduling, etc.). There are a few ways around this, at least that I can think of:<br>
<p>
* We could try to partition off the kernelspace-modifying actions into a separate user, as you suggest, or at least into a separate set of capabilities(7) or the like. The difficulty is that you'd probably have to break up CAP_SYS_ADMIN for this to work, so it would be a lot of code churn. Ultimately, I think the existing capabilities would have to be fundamentally redesigned for this to make sense. It is not enough to split off a permission here and a permission there - we have to think logically about the transitive closure of everything that a process with capability X can ever do, directly or indirectly, and the current design does not even attempt to do that. And then we have to think about all possible combinations of capabilities, or at least all combinations that can plausibly interact with each other to escalate privileges.<br>
* We could say "if you want to modify your kernel, either don't enable secureboot, or reimage your kernel with the appropriate changes pre-configured." The effect would be to disable the kernelspace-modifying actions altogether, and maybe even patch out their codepaths entirely so that they can't be used as ROP gadgets, but only in secureboot-enabled kernels (so that people who "just want a normal kernel" and don't want to put up with this sort of thing can ignore it). The main difficulty here is that, to my understanding, much of the existing "pre-configure your system" tooling currently lives in userspace (e.g. systemd). You'd probably need to provide a rich set of kernelspace configuration options that can be set before the system is first booted, and I'm not sure how feasible that is.<br>
* We could partition off all of the "dangerous" permissions into a series of daemons like systemd and polkit, and administer the system by asking those daemons nicely to do it for us. That would extend secureboot trust to a much wider array of system services, which is probably undesirable (now your systemd has to be secureboot-signed?). OTOH, it's not like Microsoft maintains a strong segregation between the Windows NT kernel and the modern Windows userspace. From their perspective, I imagine the trusted component is a pretty large subset of the operating system, and I doubt they draw the line exactly at ring 0.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942451/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 3:47 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/942452/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  From their perspective, I imagine the trusted component is a pretty large subset of the operating system, and I doubt they draw the line exactly at ring 0.</span><br>
<p>
Microsoft has a notion of "protected processes" that block every access to themselves, even from the Administrator user. Linux doesn't really have a similar thing. The root user can trivially ptrace any process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 6:36 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/942461/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>The difficulty is that you'd probably have to break up CAP_SYS_ADMIN for this to work</blockquote>
Exactly right.  CAP_SYS_ADMIN is the "big kernel lock" of permissions.  Or it's fcntl().  Or any other design that started out as a reasonable idea but became more and more overloaded and treated as a receptacle for anything and everything.



      
          <div class="CommentReplyButton">
            <form action="/Articles/942461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 9:20 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/942470/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Problem is, traditionally, you couldn't actually design an OS where root could only do things like the above. You also needed an interface for doing more complicated stuff, and especially for doing things in kernelspace (loading modules, debugging, enabling realtime scheduling, etc.). There are a few ways around this, at least that I can think of:</span><br>
<p>
Going back to Pr1mos, the ONLY thing that was hard-coded into the OS (and even that could be patched out) was that user "system" could edit the root of the permissions tree. And not really even that - it simply set over-ride permissions, which I would often use when testing stuff ...<br>
<p>
SPAC &lt;system&gt; wol:none<br>
SPAC &lt;data&gt; wol:none<br>
<p>
then I would run loads of stuff in testing that could cause carnage if I'd made a mistake, secure in the knowledge that the live system was not even visible to my program.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942855"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2023 14:04 UTC (Sun)
                               by <b>Baughn</b> (subscriber, #124425)
                              [<a href="/Articles/942855/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; * We could say "if you want to modify your kernel, either don't enable secureboot, or reimage your kernel with the appropriate changes pre-configured."</span><br>
<p>
I have a computer that doesn’t boot with Secureboot disabled. They seem to be getting more common. <br>
<p>
At the moment, I’m still able to use it as a regular computer thanks to Linux not locking itself down hard enough to stop me modifying the kernel. If a rule like that was added, then i suppose it’s game over. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942855/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2023 14:03 UTC (Mon)
                               by <b>jwarnica</b> (subscriber, #27492)
                              [<a href="/Articles/942897/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We could do all of those things, or we could accept that some kernel being operated by some human running on real or virtual hardware requires a level of trust of that human.<br>
<p>
It's a weird mental model that "root is special, protect it". See: <a href="https://xkcd.com/1200/">https://xkcd.com/1200/</a>  In a more enterprisy sense: consider that some app team has full permissions to /var/lib/pgsql, but the OS team has root, so the app team needs to open a ticket to restart the server. Yah! I guess the app team isn't able to put a NIC in promiscuous mode, but who isn't using switches?<br>
<p>
Presume that which ever human runs the kernel has access to everything; that is either tolerable trust or a massive breach depending on the organizational requirement. And then protect the kernels running, from each other. Harden the VM layer, harden the network layer, harden the APIs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor942336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 19:56 UTC (Mon)
                               by <b>leromarinvit</b> (subscriber, #56850)
                              [<a href="/Articles/942336/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think this class of attack is only about root. Even if it were possible to perfectly prevent all local users from writing to the backing store of a mounted FS, there's no defense against malicious hardware. Emulate a USB storage device with a $2 microcontroller board, and you can change everything you like at any time you want - and no one can possibly stop you.<br>
<p>
I'm not sure I can see any workable solution for this other than carefully auditing all involved kernel code with that attack vector in mind. Even disabling USB or forbidding mounting removable media is not a 100% remedy, it only moves the bar up a bit (never mind such a setup not being terribly likely to be welcome for many use cases). A sufficiently motivated attacker might as well present this malicious device via a SATA or NVMe interface - maybe a bit more complicated and less ready-made hardware and software stacks to choose from, but not impossible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 1:30 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/942358/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I Googled [SATA to USB dongle] and got approximately 1 bajillion results. Can't you just emulate one of those devices, and lie about what's plugged into the (fictitious) "other end"? Or are those devices actually implementing a full SATA stack and presenting themselves as USB drives? I think the latter seems a bit excessive for something that can be had for under $10.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 7:45 UTC (Tue)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/942369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IIRC, the underlying transport for SATA and USB storage is very similar.<br>
<p>
I can easily imagine a small and cheap device with a USB host and a USB device connector, which sits between the computer and a USB memory stick, introducing (not so) random corruptions to data read from the memory stick to attack the host.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 8:53 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/942372/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A SATA-to-USB adapter is basically a SoC that implements both physical interfaces, plus some software that does SCSI-to-ATA emulation (because USB storage is based on SCSI). Likewise for microSD readers, except it's SCSI-to-SD of course. In both cases the cost of the hardware wildly dominates since software only has to be written once.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor942415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 16:03 UTC (Tue)
                               by <b>zeno_kdab</b> (guest, #165579)
                              [<a href="/Articles/942415/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the attacker has enough physical access to plug in a malicious SATA or NVMe device, isn't it rather too late to worry about security? I'd think at that point there are plenty hardware based attacks possible that no OS could defend against anyway.<br>
<p>
For external devices maybe an idea would be to just use unprivileged FUSE to mount? It seems rather unlikely to have a use case where you need maximum FS performance but at the same time can't trust your hardware...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 14:03 UTC (Wed)
                               by <b>draco</b> (subscriber, #1792)
                              [<a href="/Articles/942475/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not necessarily. As an analogy, let's say that the block device is cloud storage. The cloud storage has different threats than the rest of the computer.<br>
<p>
It's fair to say that in a scenario where you're computing in malicious environments that you must be able to trust some of your hardware — if you can't trust the CPU itself, you're doomed, sure. But with a trusted computing core and IOMMU, you can (in principle) mitigate malicious I/O if you write the drivers defensively.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 17:21 UTC (Wed)
                               by <b>zeno_kdab</b> (guest, #165579)
                              [<a href="/Articles/942519/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'll agree that it does seem theoretically possible to do so. Though I am doubtful that it is a good idea, besides the already mentioned concern of practical feasibility.<br>
<p>
Imho either you trust your hardware, and don't want your FS drivers to be slowed down by being implemented super defensively, always rechecking everything etc. Or you don't trust, but then you should be fine taking the perf hit by using FUSE or a VM to isolate the hardware handling from your host kernel.<br>
<p>
Having said that, I always dream about a new OS kernel that transcends the monolithic/micro-dichotomy by easily allowing to move all kinds of driver into userspace and back ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor942442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 20:06 UTC (Tue)
                               by <b>zorg24</b> (subscriber, #138982)
                              [<a href="/Articles/942442/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The issue of automounting USB drives was actually discussed in a previous article <a href="https://lwn.net/Articles/939097/">https://lwn.net/Articles/939097/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor942341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 20:47 UTC (Mon)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/942341/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why network doesn't have such problem? Arbitrary junk hit the fan on NIC, and everything breaking RFC is just dropped.<br>
<p>
Can the same thing be done for fs? Storage layer, which guarantee correctness of data for the next layer.<br>
<p>
May be filesystem is like HTTP working with Ethernet frames...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942342"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 21:29 UTC (Mon)
                               by <b>leromarinvit</b> (subscriber, #56850)
                              [<a href="/Articles/942342/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The layer that would need to drop invalid on-disk structures is the very FS code itself. Nothing else knows what is conforming and what isn't. To keep with the network analogy, the Ethernet layer can't defend a buggy HTTP parser against application-level attacks.<br>
<p>
Network protocols are usually designed to be easy to validate (at least sane ones), and nothing terrible typically happens when you drop non-conforming packets sent from a buggy, non-malicious source. And yet, even in networking, the common approach used to be "conservative in what you send out, liberal in what you accept" until relatively recently.<br>
<p>
File systems, OTOH, are usually designed with performance as the main goal, and malicious images aren't the top concern (and they certainly weren't when most of today's widely used file systems were designed). Also, resilience against corruption is a concern often diametrically opposed to strict validation - if corruption causes 10% of my files to contain garbage (or turns 10% of a single corrupted file into garbage), I'd much prefer my FS to give me the remaining 90% without fuss.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942342/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 11:57 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/942382/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;Nothing else knows what is conforming and what isn't.</span><br>
<p>
And it's often only possible to tell if a given on-disk metedata structure is "conformant" after loading *every other* bit of metadata into memory and effectively doing a full consistency/fsck pass.  Of course you're still vulnerable to stuff being written to disk behind your back, so the only way to handle that is to always keep the full metadata in memory, and never re-read anything from disk.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 13:39 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/942389/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But then you have to write all of it back because it might have changed on disk behind your back. Anything less and you're just deferring discovering the bogus writes until the next mount time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 14:10 UTC (Tue)
                               by <b>leromarinvit</b> (subscriber, #56850)
                              [<a href="/Articles/942395/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Trying to detect writes to a device (or the page cache) behind the file system's back is probably a futile endeavor. But making sure to never crash, no matter what any given read returns (and no matter if that's consistent with what was read elsewhere), seems like a goal that should be attainable in principle (even if, as many have said, it's a lot of work).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 16:08 UTC (Tue)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/942423/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly!  And big companies (Google, Oracle, Red Hat, etc) need to hire more people to meet that goal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 17:19 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/942396/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds like a futile endeavor to me. Sure, make things *better*, but *crash-proof* when you're in the realm of forced TOCTOU races (that iSCSI situation given above), deliberately bad actors messing with inode pointers/refcounts that may cause page cache confusions, or whatever else could possibly go wrong when you're in an absolutely uncontrollable and hostile environment…<br>
<p>
I don't know…the trust line has to go somewhere here. For example, Rust is not safe against `/proc/self/mem` editing. I'm not sure what one *could* do in the face of such power because the only thing you have is "my registers are not accessible" and "the program counter will keep moving".<br>
<p>
Note that I am usually all about defensive programming and covering bases, but I also don't interface with hardware directly and have some baseline level of viable behavior. The tales I've heard here (and from linked blogs, etc.) make me happy about my course so far. I am extremely grateful for those that do that work, but I do not envy their jobs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942466"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 17:13 UTC (Wed)
                               by <b>leromarinvit</b> (subscriber, #56850)
                              [<a href="/Articles/942466/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, perfection is impossible for anything sufficiently complex. What I really meant was fixing the issues one knows about, and having the attack vector in mind when designing and writing new code. Not saying the current maintainers have to tackle all that in addition to everything they're already doing - it's clear that adding more work either leads to everything moving at a slower pace, or someone needs to step in and fund more developers. (Someone volunteering is of course also possible, but I have a hard time imagining that "I can use root privileges to make the kernel do funny things" is many people's most important itch to scratch.)<br>
<p>
I also should probably have qualified the "never crash" with "in a way that potentially allows privilege escalation". If removable media were by default mounted using something like lklfuse, that would IMHO be a big step in the right direction. But I think this should be mainlined, or decoupled from the actual driver code so much that it can use arbitrary kernel images or modules. Using different versions of the same fs driver (with a different set of features and bugs), potentially interchangeably on the same device, sounds like a recipe for compatibility issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942466/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor942571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2023 7:12 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/942571/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Anything less and you're just deferring discovering the bogus writes until the next mount time.</blockquote>

Why is that a problem?


      
          <div class="CommentReplyButton">
            <form action="/Articles/942571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942600"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2023 12:33 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/942600/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Let's say you bring in all of the metadata from the FS into memory and work from there. If you don't edit any of them, there's no need to write. However, in a situation where the backing store is editable by some other mechanism (network-mounted block device, direct writes, whatever, these can be written without noticing (say, swapping two inodes in a directory listing). Without writeback, you're just deferring "something edited my FS" problems from "direct memory access" to "when I load from disk next time".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942600/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942607"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2023 14:16 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/942607/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>you're just deferring "something edited my FS" problems from "direct memory access" to "when I load from disk next time".</blockquote>

I get that. I just don't see why it's a problem. Surely checking for consistency and deciding what to do if there's a problem is easier at mount time than it is while the filesystem is in use?


      
          <div class="CommentReplyButton">
            <form action="/Articles/942607/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor943053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2023 9:45 UTC (Wed)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/943053/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At that point you are potentially working on a fictional version of your filesystem that doesn't exist on disk for months at a time. Considering persistent storage is the main purpose of a hard disk that doesn't seem like a good idea.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/943053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor942360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 1:49 UTC (Tue)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/942360/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Basically, filesystems are bigger than packets.<br>
<p>
The reason the attacks here are about data in the superblock and not e.g. within an inode is because you can reasonably cache a little bit of data in from the block device and then validate it once you've read it. Maybe you load a page worth of data, and then you validate its layout, and then you can use the validated page. For instance, maybe there's a uint32 that specifies how long the filename is, which is restricted by spec to something more reasonable like 1024 bytes. If you've already copied the data into memory you trust, you can check it and then have other functions use it directly without worrying about them doing a kmalloc(4G).<br>
<p>
For a network protocol parser (at any layer), that's all it does! It's received some bytes from the network into RAM, and then the authoritative copy of the data is in your own trusted RAM for you to handle as you like. You can parse it and interpret it and pass it on, or you can drop it. Then you get more bytes from the network. Even if you're receiving a large amount of data, you're handling one packet at a time, and each packet becomes fully yours when you receive it.<br>
<p>
For filesystems, you have terabytes of data that you're repeatedly going back to. There's a lot of structure of superblock to directories to inodes to data. Not all of those blocks stay in memory. So maybe you've read a superblock once, determined that it's valid, and then it changes and for whatever reason the superblock is no longer in memory. Then the next function down the line might not get the same bytes that you validated. You can't copy the entire filesystem into RAM up front because half the point of a filesystem is to be bigger than what you can fit in RAM. You can't parse things as you receive them because you're doing random access.<br>
<p>
You _can_ revalidate data each time you need it, but the argument being made is that writing code this way is a very unnatural and unpleasant experience.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 12:12 UTC (Tue)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/942383/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All this discussion makes me think about one of the things I'll eventually maybe get up to doing once I've done all the other important things in the world.<br>
<p>
To me, filesystems are in many ways an exceptionally nicely contained thing. They largely follow a well defined, narrow API with well defined semantics. Exceptions to it are probably fairly easy to express. Regardless of the filesystem, you can say things like "if I write a file, then read it back without other writes to the same file, I should get the same data (or an error) back".<br>
<p>
That is, they seem exceptionally amenable to formal specification and analysis, and from that perspective, how they are designed today seems quite ad hoc. It shouldn't be as hard as with many other systems to actually formally define the operations (up to what gets written to the disk where) and verify that the requires properties hold, as well as do a lot of analysis on performance etc., play with different design ideas without needing to convert and boot kernels, etc. You could treat tolerance to bogus data in the same way, allowing a conscious decision on exactly how you are allowed to fail in different situations.<br>
<p>
Now I'm not saying that should necessarily be the same as the code that gets executed (or even generated from it), but parts of it could well be if desired. Verifying the design should give quite a bit of confidence, and effort could be directed at the performance critical parts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor942345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 21:07 UTC (Mon)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/942345/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it's doable _with a reasonable amount of effort_, it may as well be done. Every threat model like this sounds insane until someone invents a better Rowhammer and suddenly it's the easiest way to get root.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 0:36 UTC (Tue)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/942357/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You've touched upon the issue -- it is not tractable with a reasonable amount of effort.  Writing a filesystem for a byzantine storage media is a huge effort, if it is even possible, and adapting historical filesystems not designed around byzantine media is Sisyphean.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 1:28 UTC (Tue)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/942359/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it’s obviously *possible*, but I agree we’re not well prepared for it (I’m a file system developer) and it may require a different threat model at time of design.  Not fun.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 2:04 UTC (Tue)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/942361/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think sufficiently-Byzantine filesystems just need to get deprivileged, honestly.<br>
<p>
<a href="https://github.com/lkl/linux">https://github.com/lkl/linux</a> is a fork of the Linux kernel that turns all the interesting routines into a library, with a couple of neat tech demos of what you can do with it - including a FUSE wrapper for the filesystems in the kernel. So any filesystem that's already been implemented once, in the kernel, now has a userspace version.<br>
<p>
There's also other ways to do it, such as UML or hardware-assisted virtualization.<br>
<p>
Yes, you will lose some performance. I think the triangle of security, performance, and nicheness is a "pick two" situation - if you want both security and performance, you will need to attract enough interest and enthusiasm to pick up the work, possibly defining newer and easier-to-handle on-disk formats as the work happens. Otherwise, you can use an old implementation that made sense in the '90s at full performance with the security of the '90s, or you can use it at the performance of the '90s (which should be enough, honestly!).<br>
<p>
(I'd also be very curious to see what the actual performance loss is even for day-to-day filesystems, and whether there are things that can be done to address performance like reviving the zero-copy FUSE patchset. I think I actually do very few things that are ridiculously sensitive to filesystem performance per se: most of the time I'm either working with large single files like giant CSVs or git pack files or game textures, for which the filesystem is essentially a constant factor and it's the raw I/O performance that matters, or reading and writing lots of small files like source code, which can mostly stay in the VFS cache, in theory. Applications that care very much about disk performance, like databases, tend to make a large contiguously-allocated single file anyway - and they subdivide it in userspace.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 9:48 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/942376/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>In a sane world we would have both. FUSE-filesystem to deal with USB or other untrusted sources and in-kernel implementation for root fs.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/942376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942588"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2023 10:29 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/942588/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>The only significant gotcha is that which implementation to use (userspace or kernelspace) is not about the filesystem in use, but rather about the degree to which the backing storage and the user are trustworthy.
<p>In one system, I might want to use both the kernelspace implementation of xfs for my root FS, using something like fs-verity to protect against a malicious root user, and the userspace implementation for home directories. For added fun, I might want the userspace implementation to run multiple instances, so that an exploit is less likely to affect other instances (only affects other instances if it can be used to write to the backing store); this comes in handy with something along the lines of Android's user-per-application model, where I won't be able to mutate in-memory state that affects another application.



      
          <div class="CommentReplyButton">
            <form action="/Articles/942588/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942883"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2023 23:32 UTC (Sun)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/942883/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I mean, we're talking about ext4, xfs, and btrfs.  Punting them to FUSE + LKL isn't really an option, IMO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942883/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2023 0:31 UTC (Mon)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/942884/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was mostly replying to the comment talking about historical filesystems - if we need to write an ext5 that makes this sort of robustness easier, that's certainly an option. We are, in any case, mostly just talking about lockdown/secure boot configs - it seems pretty reasonable to say, the upstream kernel will only let you use a very small set of filesystems when lockdown is on, and if distros want to take the risk of filesystems that haven't been audited, they can patch this check out. A lot of people run without kernel lockdown enabled (perhaps enforcing secure boot in some other way, like verifying a signature on an entire read-only rootfs) and won't be impacted by this. The people who do run with kernel lockdown should be able to expect that the kernel isn't just writing off ring-0 escalation risks.<br>
<p>
But also I don't think punting major filesystems to FUSE is really out of the question. It was the vision of the microkernels of the '90s, which failed not because there was anything fundamentally wrong with microkernels but because overhead was high. We've learned a lot about writing efficient software that spans multiple address spaces since then (it's in many senses similar to HPC work or GPU programming), and also the physical computers are way faster. As I mentioned, without an actual benchmark, I think saying that this just has to be done in kernelspace is premature optimization.<br>
<p>
(We also know a lot more about software fault isolation now than we did in the '90s - we could use something like eBPF or wasm or Native Client to keep these filesystems in the kernel but limit the impact of bugs.)<br>
<p>
We Linux folks rightly make fun of Windows for having done font rendering in the kernel for so long and having had a bunch of ring-0 privilege escalation bugs as a result. It made sense in the '90s when they cared a lot about font rendering performance and basically not at all about malicious fonts; it doesn't make sense today. I don't think filesystems are a fundamentally different story.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor942347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2023 21:44 UTC (Mon)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/942347/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;syzbot has opened the block device for writing, and edits the superblock while it is mounted. [...] writing to a mounted filesystem behind the implementation's back would be one of those "don't do that" situations.</span><br>
<p>
Well, syzbot just needs to find a code path which makes the filesystem implementation itself issue the destructive write. Then everyone will jump to fix it. :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2023 21:24 UTC (Fri)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/942785/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes... they would fix the filesystem issuing a destructive write.  That is a bug.  That is bad.<br>
<p>
A filesystem failing to handle concurrent modification is less of a bug.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor942363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 4:41 UTC (Tue)
                               by <b>ebiggers</b> (subscriber, #130760)
                              [<a href="/Articles/942363/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This article misses an important point, which is that the specific issue being discussed is writes to the block device's **page cache** while the filesystem is mounted.  It's virtually impossible for filesystems to maintain memory safety in that case.  Whereas it's possible (but difficult) for filesystems to maintain memory safety when their underlying storage changes.<br>
<p>
It is helpful to not conflate these two cases.  This makes it clear why it's useful to e.g. forbid writes to /dev/sda1 while still allowing /dev/sda.  Even just forbidding buffered writes would solve this problem; O_DIRECT writes could still be allowed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor942390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 13:43 UTC (Tue)
                               by <b>magfr</b> (subscriber, #16052)
                              [<a href="/Articles/942390/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For added fun you can put the file system on an iSCSI device, mount it from two computers concurrently, and then start writing from both.<br>
<p>
I do not expect the kernel to handle that scenario.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2023 16:13 UTC (Tue)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/942426/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
... unless it's GFS2 or OCFS which are designed for exactly that use case ;-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor942455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 5:03 UTC (Wed)
                               by <b>mcassaniti</b> (subscriber, #83878)
                              [<a href="/Articles/942455/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Disabling the ability to modify the whole block device means that new partitions cannot be created live (think expanding a VM disk), not can a partition be extended. While systemd isn't everyone's favourite, systemd-sysupdate can change the partition table and overwrite non-mounted partitions as part of an A/B update process. It's likely not the only tool to do so either.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2023 2:19 UTC (Fri)
                               by <b>smammy</b> (subscriber, #120874)
                              [<a href="/Articles/942741/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's always struck me as a little odd that we interact with partition tables by raw block device access from userspace. Surely it would be reasonable for the kernel to have partition table drivers with an API for manipulating them. Presumably calls to modify or delete a mounted partition would fail, while calls that add new partitions or modify/delete unmounted partitions could succeed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2023 3:15 UTC (Tue)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/942964/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Surely it would be reasonable for the kernel to have partition table drivers with an API for manipulating them. Presumably calls to modify or delete a mounted partition would fail, while calls that add new partitions or modify/delete unmounted partitions could succeed.</span><br>
<p>
In a way, this is the case. Think of the on disk partition table as a configuration "file" that tells the kernel how to configure its internal partition table. The API allows to re-read this configuration after userspace has changed it on disk. And it will fail, it the kernel thinks this is not safe to do. Back in the days, it was entirely impossible to re-read a partition table if any filesystem on the disk was mounted, always requiring a reboot if one modified the partition table on the primary disk. Nowadays it is a bit more permissive.<br>
<p>
You just have to mentally differ between the kernel partition table (which is always in RAM) and the partition table on disk. Changing the latter one is no issue at all, as it will only be used by the kernel when explicitly told so or on the next boot. And this design makes a lot of sense. You can do modifications on disk that are only safe to apply after the next boot and then reboot. If the only ways of changing the on disk partition table where by means of an API that directly manipulates the internal partition table such changes would always require to boot another OS (rescue CD etc.).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor942787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2023 22:49 UTC (Fri)
                               by <b>calumapplepie</b> (guest, #143655)
                              [<a href="/Articles/942787/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Yet another problem is that, according to Ts'o, the syzbot developers are unwilling to turn on this configuration option unless disabling it would be hidden behind a new CONFIG_INSECURE option (to indicate that doing so would make the system insecure). Ts'o objected to that positioning ""because that's presuming a threat model that we have not all agreed is valid"". </span><br>
<p>
The threat model of "root is evil" is apparently a valid one supported by kernel_lockdown(7).  However, it isn't valid unless the filesystem is booted up in lockdown mode: if it isn't, root can just use kmem and such.  At a minimum, we could gate edits to devices containing mounted filesystems and on touching the SCISI_GENERIC device behind a requirement that the kernel isn't locked down.  Kernel lockdown already breaks a number of things; what's a few more?<br>
<p>
Alternatively, start with a CONFIG_LOCKDOWN_STRICT option, which when enabled tightens the restrictions of lockdown to prohibit such things as mounted block-device writes.  For those users who require a root -&gt; kernel barrier, they can enable that option, and with it some more restrictions that might break semi-niche application code.  Yes, I'm considering online resizing to be 'semi-niche'.  If you really require the security guarantees of a strict lockdown, you enable the config; otherwise, leave it disabled.<br>
<p>
For those users who are just running a distro kernel, which enables CONFIG_LOCKDOWN_LSM but not STRICT because they want all the features available, this means that (for a period of time) they will be vulnerable to novel attacks using this threat model.  However, the goal will be to move this patch into the basic CONFIG_LOCKDOWN eventually; thus fixing all such bugs.  As we do so, we can add additional hardening behind CONFIG_LOCKDOWN_STRICT, for instance disabling a wider variety of sysfs files or locking down old drivers.  You can also remove the ability to disable the lockdown LSM on the command line; a command line which can be edited for the next boot by root on most machines.<br>
<p>
This two-phase mechanism ensures that those who want a strict lockdown will need to deal with the breakage that it causes in userspace.  Those who don't need a strict lockdown, but enable lockdown anyways for hardening get to benefit over time from the work of those who need a stricter mode.  It's similar to the realtime stuff; if you want a realtime kernel, you have to configure yourself a realtime kernel.  If you want a kernel that actually blocks all ring0 compromise, then you have to build it yourself.<br>
<p>
In other words: There are some folks who actually want this threat model secured, and many more who don't really care but appreciate the hardening it produces.  Differentiate between the two with config options, document the difference in all the places that talk about lockdown, and let those who want it strictly secured deal with the breakage and performance regressions from it.  <br>
<p>
TLDR: Make the security model of the kernel a kconfig option, and limit features for those using the root-is-evil threat model until those features can be made secure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor964986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2024 2:26 UTC (Mon)
                               by <b>lathiat</b> (subscriber, #18567)
                              [<a href="/Articles/964986/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ignoring all of the TOCTOU issues, this same functionality seems super helpful for preventing users from shooting themselves in the foot when trying to write an image to (the wrong) disk. Though would probably need to also protect the full device not just the partitions.<br>
<p>
This would be a nice default anyway, even if it has some kind of override method for the weird cases.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/964986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor964987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Defending mounted filesystems from the root user</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2024 5:09 UTC (Mon)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/964987/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; for preventing users from shooting themselves in the foot when trying to write an image to (the wrong) disk.</span><br>
<p>
or developers from running fio job with wrong filename=<br>
:-(<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/964987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
