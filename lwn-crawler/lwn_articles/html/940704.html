        <!DOCTYPE html>
        <html lang="en">
        <head><title>An ioctl() call to detect memory writes [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/940704/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/941047/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/940704/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>An ioctl() call to detect memory writes</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 10, 2023</br>
           </div>
It is the kernel's business to know when a process's memory has been
written to; among other things, this knowledge is needed to determine which
pages can be immediately reclaimed or to properly write dirty pages to backing
store.  Sometimes, though, user space also needs access to this information
in a reliable and fast manner.  <a
href="/ml/linux-mm/20230808104309.357852-1-usama.anjum@collabora.com/">This
patch series</a> from Muhammad Usama Anjum adds a new <tt>ioctl()</tt> call
for this purpose; using it requires repurposing an existing system call in
an unusual way, though.

<p>
The driving purpose for this feature, it seems, is to enable an efficient
emulation of the Windows <a
href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-getwritewatch"><tt>GetWriteWatch()</tt></a>
system call, which is evidently useful for game developers who want to
defend against certain kinds of cheating.  A game player who is able to
access (and modify) a game's memory can enhance that game's functionality
in ways that are not welcomed by the developers â€” or by other players.
Using <tt>GetWriteWatch()</tt>, the game is able to detect when crucial
data structures have been modified by an external actor, put up the modern
equivalent of a "Tilt" indicator, and bring the gaming session to a halt.
<p>
Linux actually provides this functionality now by way of the <a
href="https://docs.kernel.org/admin-guide/mm/soft-dirty.html"><tt>pagemap</tt>
file</a> in <tt>/proc</tt>.  The current dirty state of a range of pages
can be read from this file, and writing the associated <tt>clear_refs</tt>
file will reset the dirty state (useful, for example, after the game itself
has written to the memory of interest).  Accessing this file from user
space is slow, though, which runs counter to the needs of most games.  The
new <tt>ioctl()</tt> call is meant to implement this feature more
efficiently.  The <a href="https://criu.org/Main_Page">Checkpoint/Restore
In Userspace</a> (CRIU) project would also be able to make use of a more
efficient mechanism to detect writes; in this case, the purpose is to
identify pages that have been modified after the checkpoint process has
begun.
<p>
<h4>Soft dirty deemed insufficient</h4>
<p>
The kernel's "soft dirty" mechanism, which provides the <tt>pagemap</tt>
file, would seem to be the appropriate base on which to build a feature
like this.  All that should be needed is a more efficient mechanism to
query the data and to reset the soft-dirty information for a specific range
of pages.  According to the cover letter, though, this approach ended up
not working well.  There are various other operations, such as virtual
memory area merging
or <a
href="https://man7.org/linux/man-pages/man2/mprotect.2.html"><tt>mprotect()</tt></a>
calls, that can cause pages to be reported as dirty even though they have
not been written to.  That, in turn, can lead to a game concluding, incorrectly,
that its memory has been tampered with.
<p>
That can lead to undesirable results.  One rarely sees the level of anger
that can be reached by a game player who has been told, at the crux point
of a quest, that cheating has been detected and the game is over.
<p>
Fixing this false-positive problem, evidently, is not an option, so the
decision was made to work around it instead via an unexpected path.  The <a
href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html"><tt>userfaultfd()</tt></a>
system call allows a process to take charge of its own page-fault handling
for a given range of memory.  The patch set adds a new operation
(<tt>UFFD_FEATURE_WP_ASYNC</tt>) to <tt>userfaultfd()</tt> that changes how
write-protect faults are handled.  Rather than pass such faults to user
space, the kernel will simply restore write permission to the page in
question and allow the faulting process to continue.
<p>
Thus, <tt>userfaultfd()</tt>, which was designed to allow the handling of
faults in user space, is now being used to modify the handling of faults
directly within the kernel with no user-space involvement.  This
approach does have some advantages for the use case in question, though: it
allows specific ranges of memory to be targeted, and the use of write
protection to trap write operations provides for more reliable reporting of
writes to memory.  To see which pages have been written, it is sufficient
to query the write-protect status; if the page has been made writable, it
has been written to.
<p>
<h4>The <tt>ioctl()</tt> interface</h4>
<p>
With that piece in place, it is possible to create an interface to query
the results.  That is done by opening the <tt>pagemap</tt> file for the
process in question, then issuing the new <tt>PAGEMAP_SCAN</tt>
<tt>ioctl()</tt> call.  This call takes a relatively complex structure as
an argument:
<p>
<pre>
    struct pm_scan_arg {
	__u64 size;
	__u64 flags;
	__u64 start;
	__u64 end;
	__u64 walk_end;
	__u64 vec;
	__u64 vec_len;
	__u64 max_pages;
	__u64 category_inverted;
	__u64 category_mask;
	__u64 category_anyof_mask;
	__u64 return_mask;
    };
</pre>
<p>
The <tt>size</tt> argument contains the size of the structure itself; it is
there to enable the backward-compatible addition of more fields later.
There are two <tt>flags</tt> values that will be described below.  The
address range to be queried is specified by <tt>start</tt> and
<tt>end</tt>; the <tt>walk_end</tt> field will be updated by the kernel to
indicate where the page scan actually ended.  <tt>vec</tt> points to an
array holding <tt>vec_len</tt> structures (described below) to be filled in with
the desired information.
<p>
The final four fields describe the information the caller is looking for.
There are six "categories" of pages that can be reported on:
<p>
<ul>
<Li> <tt>PAGE_IS_WPALLOWED</tt>: the page protections allow writing.
<li> <tt>PAGE_IS_WRITTEN</tt>: the page has been written.
<li> <tt>PAGE_IS_FILE</tt>: the page is backed by a file.
<li> <tt>PAGE_IS_PRESENT</tt>: the page is present in RAM.
<li> <tt>PAGE_IS_SWAPPED</tt>: the (anonymous) page has been written to
swap.
<li> <tt>PAGE_IS_PFNZERO</tt>: the page-table entry points to the zero
page.
</ul>
<p>
Every page will belong to some combination categories; a calling program
will want to learn about the pages in the range of interest that are (or
are not) in a subset of those categories.  The usage of the masks is
described, to a point, in <a
href="/ml/linux-mm/20230808104309.357852-6-usama.anjum@collabora.com/">this
patch</a>, though it makes for difficult reading.  The code itself does the
following to determine if a given page, described by <tt>categories</tt>,
is interesting:
<p>
<pre>
    categories ^= p-&gt;arg.category_inverted;
    if ((categories &amp; p-&gt;arg.category_mask) != p-&gt;arg.category_mask)
	return false;
    if (p-&gt;arg.category_anyof_mask &amp;&amp; !(categories &amp; p-&gt;arg.category_anyof_mask))
	return false;
    return true;
</pre>
<p>
Or, in English: first, the <tt>category_inverted</tt> mask is used to flip
the sense of any of the selected categories; this is a way of selecting for
pages that do <i>not</i> have a given category set.  Then, the result must
have all of the categories described by <tt>category_mask</tt> set and, if
<tt>category_anyof_mask</tt> is not zero, at least one of those categories
must be set as well.  If all of those tests succeed, the page is of
interest; otherwise it will be skipped.
<p>
After the scan, those pages are reported back to user space in
<tt>vec</tt>, which is an array of these structures:
<p>
<pre>
    struct page_region {
	__u64 start;
	__u64 end;
	__u64 categories;
    };
</pre>
<p>
The <tt>return_mask</tt> field of the request is used to collapse the pages
of interest down to regions with the same categories set; for each such
region, the return structure describes the address range covered and the
actual categories set.
<p>
Finally, to return to the <tt>flags</tt> argument, there are two
possibilities.  If <tt>PM_SCAN_WP_MATCHING</tt> is set, the call will
write-protect all of the selected pages after noting their status; this is
meant to allow checking for pages that have been written and resetting the
status for the next check.  If <tt>PM_SCAN_CHECK_WPASYNC</tt> is set, the
whole operation will be aborted if the memory region has not been set up
with <tt>userfaultfd()</tt> as described above.
<p>
<h4>Checking for cheaters</h4>
<p>
To achieve the initial goal of determining whether pages in a given range
have been modified, the first step is to invoke <tt>userfaultfd()</tt> to
set up the write-protect handling.  Then, occasionally, the application can
invoke this new <tt>ioctl()</tt> call with both flags described above set,
and with both <tt>category_mask</tt> and <tt>return_mask</tt> set to
<tt>PAGE_IS_WRITTEN</tt>.  If no pages have been written, no results will
be returned; otherwise the returned structures will point to where the
modifications have taken place.  Meanwhile, the pages that were written to
will have their write-protect status reset, ready for the next scan.
<p>
This series is in an impressive <strike>27th</strike> <a
 href="/ml/linux-kernel/20230809061603.1969154-1-usama.anjum@collabora.com/">28th</a>
 revision as of this writing.  It was initially <a
 href="/ml/linux-kernel/20220726161854.276359-1-usama.anjum@collabora.com/">proposed</a>
 in mid-2022 as a new system call named <tt>process_memwatch()</tt> before
 eventually becoming an <tt>ioctl()</tt> call instead.  There is clearly
 some motivation to get this feature merged, but the level of interest in
 the memory-management community is not entirely clear.  The work has not
 landed in linux-next, and recent posts have not generated a lot of
 comments.  There do appear to be use cases for the feature, though, so a
 decision will need to be made at some point.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management">Memory management</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.7">Releases/6.7</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#userfaultfd">userfaultfd()</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/940704/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor941084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 14:41 UTC (Thu)
                               by <b>delroth</b> (subscriber, #110092)
                              [<a href="/Articles/941084/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This has more potential use cases than the "dubious" anti-cheat technique described in this article. For example, emulation of guest systems that have unified memory on host systems that don't. Back when I worked on the Dolphin Emulator (for GameCube/Wii) we spent a ton of CPU time hashing texture data which is shared in RAM between CPU/GPU on the original system, but has to be explicitly uploaded to the GPU on PC. It's not trivial to detect writes because that would happen in emulated PowerPC code, which gets JITed and which is very performance sensitive (so you can't "just" keep a list of tracked pages and do a hashtable lookup on each memory write to invalidate ranges). In a time pre-userfaultfd we tried to implement something like this using mmap(PROT_READ) and a SEGV handler, but this ended up not being much faster than simply re-hashing all shared memory resources before GPU command submission. We've wanted a feature like this for a while!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941096"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 15:53 UTC (Thu)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/941096/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The ideal solution would be to use the hardware accessed/dirty bits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941096/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor941131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 19:37 UTC (Thu)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/941131/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I agree the anti-cheat this is of dubious value.<br>
<p>
I can understand the frustration of a gamer who's game is malicious. However I don't think a reasonable solution to that is help game developers be more abusive[1].<br>
<p>
However the use for dolphin sounds awesome.<br>
<p>
<p>
[1] Authors of software have no business tell the owners of a computer system what memory regions/values they can write to. And to be honest, unless there is net play, one person cheating... is irrelevant. It's like cheating at solitaire.<br>
<p>
If there is net play, and your game isn't designed such that the server alone is sufficient to detect and prevent cheating... then you have always lost.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 23:03 UTC (Thu)
                               by <b>edeloget</b> (subscriber, #88392)
                              [<a href="/Articles/941164/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a common misconception here. When you design a network-played game you want the player to have the best possible experience. If you want to always verify everything on the server, you won't be able to get that for all players -- and, as a game developper, expecting that only those who have the highest bandwidth and the lowest latency will buy your game is both naive (people expect Cyberpunk 2077 to run fast on old CPUs with a dated GPU) and stupid (why would you want to purposedly avoid sells?).<br>
<p>
There's also the fact that not all cheating techniques rely on /checks/. Some only rely on informations that must be displayed by the client. For example, when an ennemy is visible on your screen then an auto-aim can get it and help you to get a kill. Auto-aiming might not be easy to catch on the server side (if your kill stats does a visible jump then there is a problem ; but if you're already a good player who wants to win more (for various reasons: fame, ranking... ; for this, see the unusually high number of already very good streamers that were caught red handed. At some pint, competitive gaiming is really... competitive). <br>
<p>
(Frankly, if I ever had to device an aimbot, I would market it as 'progressive', giving you better and better results as you use it in order to mimic a real player progression. How would a server detect that without risking to ban players that are really progressing fast?)<br>
<p>
Moreover, some cheats /are/ playing with the network. Some small variation in the rate at which your game clients send packets might not be detected by the server (because of natural jitter) but may provide you important advantages in some situations. This was the case in Minecraft for example, where a slight acceleration of the packet sending speed would allow you to run a bit faster -- nothing dramatic, but since all players are running at the same speed... This can be detected if overused but it's very difficult to detect if used in a clever way (for example to get a small boost during a few seconds here and there) unless you want to detect a lot of false positives.<br>
<p>
Expecting a server to always catch dubious things and rapidly act on them is not going to work well in practice. Game clients will always have to do some important checks in order to be usable, and of course they will always need to display information to the user.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 1:27 UTC (Fri)
                               by <b>KJ7RRV</b> (guest, #153595)
                              [<a href="/Articles/941175/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't a real, non-cheating player suddenly getting better possible? For example, I became much better at keeping my plane in FlightGear straight and level when I realized I was overcorrecting for minor deviations. Since I recognized that and started making smaller corrections, I have been flying a lot better. I'm assuming this could happen with most video games?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 3:34 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/941181/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>This is the ultimate end state of a lot of game cheats; the cheat acts to make you suddenly get much better in a way that's humanly plausible. It's thus impossible to distinguish cheaters from humans who learn from their mistakes, since the cheat improves your play over time in exactly the same way as would happen if you learnt over time.
<p>In the really extreme case, someone builds a machine that operates the same controls as you, in parallel to you, and that has machine vision and listening - this is now undetectable from within the game, since the inputs and outputs are the same as used by the human player.


      
          <div class="CommentReplyButton">
            <form action="/Articles/941181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor941197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 8:22 UTC (Fri)
                               by <b>edeloget</b> (subscriber, #88392)
                              [<a href="/Articles/941197/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Isn't a real, non-cheating player suddenly getting better possible?</span><br>
<p>
Yes, of course.<br>
<p>
Anyone can have a gotcha moment when playing a video game, resulting in a detectable jump in their playing abilities. Some players might just change their glasses and become suddenly better. Or you might start playing a game while being temporarily disabled (broken arm for example) and then become visibly better when that condition disapear.<br>
<p>
There are tons of reasons why a player might legitimately become better so the game server cannot act on this information alone (and in most case, that's only what it gets).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 10:22 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/941211/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And how is a local memory watch thing going to do this any better? (beyond the very short term)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 13:40 UTC (Fri)
                               by <b>rincebrain</b> (subscriber, #69638)
                              [<a href="/Articles/941226/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not the person you were replying to, but I think it's somewhat analogous to why modern games use copy-protecting DRM for the initial release and drop it after like 3-6 months.<br>
<p>
You aren't going to stop everything - if there's an enormous market for your project, people are going to throw themselves at it and eventually some portion are going to find ways around your mitigations.<br>
<p>
But if you, say, filter out 95% of the people trying to circumvent you by making the barrier high enough, that may result in a good enough result that the thing you're trying to optimize for (protecting the huge upfront hump of initial sales, preventing your multiplayer experience from having a reputation for being instakill aimbots with no stopping them) might be achievable.<br>
<p>
Of course, unlike that kind of use-until-burned DRM, cheat detection becomes an ongoing cat and mouse game for the game's lifecycle even if you are doing deeply invasive monitoring, so at some point you're (probably) going to end up having a tradeoff between using it as a varyingly weak signal to get human attention to look at a player and go "...are they obviously doing impossible things" and playing whack-a-mole with even more weird heuristics (and then, if you scale enough that you can't justify humans to do a priori review, just ban on the signal and clean up reports of false positives...).<br>
<p>
I'm not, to be clear, claiming that any of the above invasive monitoring is good, nor that even the arguments about using e.g. Denuvo for protecting week 1 sales are accurate, but that that is my understanding of the rationales and tradeoffs involved.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor941218"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 12:07 UTC (Fri)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/941218/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
I understand exactly why many modern games use client side anti-cheat. However I think my point was not conveyed. If anti-cheat has to be enforced on "not your hardware" then you have always lost.<br>
<p>
For example, unless your going to require people never use USB devices (somehow... seems immensely impractical to me), it will always be trivial (especially $$$-cost wise, but also in low in engineering effort) to simple stand up a beaglebone black (or any of the other oodles of commodity hardware out there) as a "normal"[1] input gadget. And that's just one way. There are endless way to circumvent that... because the "hostile"(cheating) party controls the whole system of relevance.<br>
<p>
My point is: if your game design requires some amount of anti-cheat be done client size, then your game is very fragile. You have no way to actually enforce that. <br>
<p>
<p>
<p>
[1] Or a normal game pad, or microphone, or what ever else you are expecting that uses standard hid drivers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941218/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 14:29 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/941272/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; My point is: if your game design requires some amount of anti-cheat be done client size, then your game is very fragile. You have no way to actually enforce that. </span><br>
<p>
Sure, but there are different options for responding to that situation:<br>
<p>
1) Stop making games like that.<br>
2) Keep making the games but give up trying to prevent cheats.<br>
3) Put a substantial amount of effort into trying to imperfectly reduce cheating.<br>
<p>
The problem with option 1 is that it includes basically all competitive action games (since they're inherently susceptible to client-side aimbots etc), which are some of the most popular games, with hundreds of millions of players and tens of billions of dollars of revenue. Players want those games and developers want to make those games.<br>
<p>
The problem with option 2 is that rampant cheating will kill a multiplayer game. If you're in a match with 12 or 24 or 100 players, and even one of them is cheating, it's usually no fun. A small percentage cheating can mean you'll encounter one in almost every match, and then you'll stop playing the game. And that makes the cheater-to-non-cheater ratio worse for the remaining non-cheaters, so they're increasingly likely to quit too. We don't want the games to die for the same reason as point 1.<br>
<p>
In practice, option 3 works. There are popular competitive action games on PC where cheating is rare enough that typical players won't be bothered by it. They use a combination of server-side and client-side techniques, plus other design techniques (like requiring a substantial investment of money and/or time before an account is allowed into competitive modes, so people can't trivially start cheating on a new account whenever their old one gets banned), and lawsuits against people selling cheats, etc. It's fragile and messy but it seems to be good enough, and I don't think I've seen any better ideas.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor941199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 8:50 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/941199/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If there is net play, and your game isn't designed such that the server alone is sufficient to detect and prevent cheating... then you have always lost.</span><br>
<p>
For many types of game, that's simply impossible. Of course the server can and should prevent the player teleporting or giving themselves infinite ammo (and some games even fail at that step, which is just bad design), but there's no way the server can prevent aimbots (where the client analyses the video output and simulates mouse movements to more accurately aim at enemies) or wall-hacks (where the client messes with the rendering so they can see enemies through solid walls), which can be a serious problem for competitive shooters.<br>
<p>
(Well, the server could avoid telling the clients about enemies that are meant to be completely obscured - but if the enemy has a nose or a shadow that's barely visible around the wall, or is making footstep sounds, then the client really needs to know about their position and cheat developers can make that enemy unnaturally visible. Some games do that and it helps but it's not perfect. See e.g. <a href="https://technology.riotgames.com/news/demolishing-wallhacks-valorants-fog-war">https://technology.riotgames.com/news/demolishing-wallhac...</a>)<br>
<p>
Game developers can add player reporting mechanisms and server-side heuristics to detect unnatural movements, but there's a significant risk of false positives, and cheat developers can make their cheats behave much more subtly and barely distinguishable from a highly skilled player. After that, it's just an arms race between client-side cheat detection and cheat-detection-avoidance. Game developers can't win that race, but they don't need to, they just need to make it sufficiently expensive for cheat developers to keep up that they have to charge large amounts of money for their cheats, so the total number of cheaters remains low enough that regular players are able to tolerate it and still enjoy the game.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941217"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 12:04 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/941217/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; they just need to make it sufficiently expensive for cheat developers to keep up that they have to charge large amounts of money for their cheats, so the total number of cheaters remains low enough that regular players are able to tolerate it and still enjoy the game.</span><br>
<p>
To add some actual numbers here: there was a Destiny 2 cheat seller who charged $13-$19 per day or $105-$169 per month, justifying the prices based on "the complex anti-cheat this game has . . . which means that high-quality cheats are expensive to create and maintain". They made about $150K over two years from 5,848 transactions, while the game developer claims to have "spent more than $2,000,000 on cheat mitigation (including staffing and software)" (though the mitigations were for all cheat sellers, not just this one). (<a href="https://thegamepost.com/wp-content/uploads/2023/02/bungie-venture-cheats-2-292023.pdf">https://thegamepost.com/wp-content/uploads/2023/02/bungie...</a>)<br>
<p>
Another seller charged $90 per month or $500 for lifetime access to Valorant cheats, and was believed to have sold "tens or hundreds of thousands of dollars". (<a href="https://www.polygon.com/2021/1/11/22224696/riot-bungie-destiny-2-valorant-cheat-maker-lawsuit">https://www.polygon.com/2021/1/11/22224696/riot-bungie-de...</a>)<br>
<p>
Those sound like quite high prices that will discourage many players from casually cheating, and reasonable but not huge incomes for cheat developers. It seems plausible that a modest increase in the difficulty of defeating anti-cheat techniques will change the economics enough for some of the cheat developers to give up and find something more valuable to spend their time on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941217/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor941132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 19:27 UTC (Thu)
                               by <b>KJ7RRV</b> (guest, #153595)
                              [<a href="/Articles/941132/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Couldn't the anti-cheat still be defeated with a patched kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 19:39 UTC (Thu)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/941140/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
you could probably defeat it with a an LD_PRELOAD.<br>
Or worse case, a patched ld.so (and an strace run to identify raw call sites)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor941149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2023 21:28 UTC (Thu)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/941149/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Iâ€™m purely speculating, but I suspect the goal is less â€˜help anti-cheat software to actually detect cheatsâ€™, more â€˜get existing anti-cheat software designed for Windows to stop producing false positivesâ€™.<br>
<p>
The difference is that in the latter case it doesnâ€™t matter how easy the mechanism is to bypass.  It might even be acceptable to trivially implement the API to always report that memory has not changed â€“ if that was enough to get games to work.  Except it might not be.  Some games might be specifically on the lookout for a dummy implementation â€“ not because they had Wine in mind, but because they thought some cheat running natively on Windows might hook GetWriteWatch.  So they might deliberately perform a write on some watched memory and verify that itâ€™s reported.<br>
<p>
And of course, some Windows applications may be using GetWriteWatch functioning correctly for purposes other than anti-cheat, so a dummy implementation might break them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 13:48 UTC (Fri)
                               by <b>stevie-oh</b> (subscriber, #130795)
                              [<a href="/Articles/941225/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, when I first read about GetWriteWatch, my thought wasn't anti-cheat.  It's similar to (but distinct from) the emulator case.<br>
<p>
Java and .NET are a garbage-collected languages.  This means that memory is not explicitly freed by code that executes in the JVM/CLR.  Instead, whenever the process starts to run low on memory, everything is paused and the garbage collector is run in order to free memory no longer in use.<br>
<p>
Determining which memory is in use is straightforward:<br>
<p>
- First, there are all the "roots": the memory immediately accessible to any thread in the process.  To access memory, (valid) code needs a reference to it. Such references will necessarily live inside the current CPU registers of threads, variables on threads' stacks, and global variables.<br>
<p>
From there, that memory can contain references to other memory. The GC (garbage collector) traces through all of these references recursively and keeps track of all memory that it can reach.  Any memory it _doesn't_ reach, therefore, is free.<br>
<p>
One inefficient thing about this is the global variables. Those tend to be static data that was initialized at (or near) program startup; they never change.  But every time memory reclaim is needed,  the GC needs to check through all those objects again.<br>
<p>
However, there's a trick here: old allocations can't refer to newer allocations unless they've been updated.  So the .NET GC uses GetWriteWatch on older allocations as a optimization:  If the old allocations haven't been written, then it knows these things:<br>
<p>
- all memory that was reachable from those older allocations is still around. don't free it.<br>
- no newer allocations can possibly be referenced and thus be kept alive by those older allocations.<br>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 14:05 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/941233/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some GCs maintain "generations" of heaps. Allocations start in the 0th generation heap. If they have not been freed after X_0 GC scans of that heap they are migrated to the 1st-gen heap; if not freed after X_1 scans, migrate to 2nd-gen heap; and so on.<br>
<p>
Each successive heap has a longer and longer scan time. I.e., X_0 &lt; X_1 &lt; ..., and X_i &lt; X_(i+1) for all i in N_0. So young objects get checked quickly, longer lived objects get checked less and less.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor941320"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2023 17:41 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/941320/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  So the .NET GC uses GetWriteWatch on older allocations as a optimization: If the old allocations haven't been written, then it knows these things</span><br>
<p>
.NET used to use the dirty bits to track the changes, but they switched to card marking ( <a href="https://mattwarren.org/2016/02/04/learning-how-garbage-collectors-work-part-1/">https://mattwarren.org/2016/02/04/learning-how-garbage-co...</a> ) a while ago. It turns out that games with virtual memory are slow, and the page-level granularity is a bit too big.<br>
<p>
They have never used GetWriteWatch though, but something different. There's a way in Windows to query a list of pages that have a "dirty" bit set, but the function name eludes me right now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941320/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor941814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2023 2:52 UTC (Thu)
                               by <b>irogers</b> (subscriber, #121692)
                              [<a href="/Articles/941814/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the area of page protections and special use-cases, Apple added a MAP_JIT flag to mmap [1]. Presumably MAP_JIT avoids certain TLB flushes and then fetches. Adding the flag to Linux would at least allow comparable optimizations on Apple Silicon.<br>
<p>
[1] <a href="https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon">https://developer.apple.com/documentation/apple-silicon/p...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/941814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor941835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2023 10:24 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/941835/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Reading the page you linked suggests that there's no optimizations involved in MAP_JIT. Instead, it's about compulsory code signing; by default, macOS will not let you mark a page as PROT_EXEC unless it has a verified code signature that traces back to a suitable root of trust. MAP_JIT changes this behaviour, and says that a page marked with MAP_JIT can be either PROT_EXEC, or PROT_WRITE, but not both at once, and that such pages do not need to have a code signature.
<p>You still need to call the appropriate TLB + cache management code yourself (wrapped up in sys_icache_invalidate) even if you use MAP_JIT; that's unchanged from before. The benefit of MAP_JIT is that it hardens applications against attackers; if you're not flagged as using a JIT, or if the attacker tries to make an existing data page executable (as opposed to one that was allocated with MAP_JIT), the page table update needed to mark the page executable will not happen. This reduces the exploit surface to gadgets already present in the application binary (see also return-oriented programming), and increases the chances that Apple will see enough telemetry showing attempts to execute code in a non-executable page with a signed binary that they can revoke your signature until you fix the bug.


      
          <div class="CommentReplyButton">
            <form action="/Articles/941835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor942526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2023 17:19 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/942526/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Another "benefit" is that the development version of Gforth does not work on MacOS on Apple Silicon, and when I spend the time to work around this breakage, the workaround will result in Gforth running significantly slower on MacOS than on Linux (on the same hardware).


      
          <div class="CommentReplyButton">
            <form action="/Articles/942526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor942584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An ioctl() call to detect memory writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2023 9:31 UTC (Thu)
                               by <b>jepsis</b> (guest, #130218)
                              [<a href="/Articles/942584/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I assume some very security critical software could utilize this to detect some tampering attempts to its configurations or other critical memory areas.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/942584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
