        <!DOCTYPE html>
        <html lang="en">
        <head><title>Protecting control dependencies with volatile_if() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/860037/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/860162/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/860037/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Protecting control dependencies with volatile_if()</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 18, 2021</br>
           </div>
Memory ordering issues are, as Linus Torvalds <a
href="/ml/linux-kernel/CAHk-%3DwgJZVjdZYO7iNb0hFz-iynrEBcxNcT8_u317J0-nzv59w%40mail.gmail.com/">recently
observed</a>, "<q>the rocket science of CS</q>".  Understanding
memory ordering is increasingly necessary to write scalable code, so kernel
developers often find themselves having to become rocket scientists.  The
subtleties associated with control dependencies turn out to be an
especially tricky sort of rocket.  A recent discussion about how to force
control dependencies to be observed shows the sorts of difficulties that
arise in this area.
<p>
<h4>Control dependencies</h4>
The C programming language was designed in the era of simple, uniprocessor
computers.  When a developer wrote a series of C statements, they could
expect those statements to be executed in the order written.  Decades
later, though, the situation has become much more complicated; code can be
extensively optimized by both compilers and CPUs to the point that it bears
little resemblance to what was originally written.  Code can be reordered
and even eliminated if the compiler (or the processor) thinks that the end
result will be the same.  The effects of this reordering on single-threaded
code are (in the absence of bugs) limited to making it run faster.  When
there are multiple threads of execution running simultaneously, though,
there can be surprises in store.  One thread may observe things happening
in a different order than others, leading to all sorts of unfortunate
confusion. 
<p>
When the visible order of operations across processors is important,
developers will often use barriers to ensure that operations are not
reordered in damaging ways.  There are, however, cases where developers can
count on things happening in the right order because there is no
alternative; these are described in terms of "dependencies".  There are
three broad classes of dependencies, described in <a
href="/Articles/850202/">this article</a> from our recent <a
href="/Articles/844224/">lockless patterns series</a>.
Consider, for example, a simple data dependency:
<p>
<pre>
    int x = READ_ONCE(a);
    WRITE_ONCE(b, x + 1);
</pre>
<p>
The write to <tt>b</tt> simply cannot be reordered ahead of the read
of&nbsp;<tt>a</tt> because neither the compiler nor the CPU knows what
value should be written.  The write has a data dependency on the preceding
read; that dependency will prevent those two operations from being
reordered.  That, of course, assumes that the compiler does
not conclude that it already knows what the value of&nbsp;<tt>a</tt> will
be, perhaps from a previous read; that is why <tt>READ_ONCE()</tt> is
used.  The <a href="/Articles/846700/">second article</a> in the  lockless
patterns series describes <tt>READ_ONCE()</tt> and 
<tt>WRITE_ONCE()</tt> in detail.
<p>
Control dependencies are a bit more complex.  Consider code like this:
<p>
<pre>
    if (READ_ONCE(a))
    	WRITE_ONCE(b, 1);
</pre>
<p>
There is no data dependency linking the read of <tt>a</tt> and the write
to&nbsp;<tt>b</tt>, but that write can only occur if <tt>a</tt> has a
non-zero value; the read of&nbsp;<tt>a</tt> must thus occur before the
write.  This ordering forced by a conditional branch is a control
dependency.  More generally, there are three
things that must be present to establish a control dependency:
<p>
<ul>
<li> A read from one location (<tt>a</tt> in the case above)
<li> A conditional branch that depends on the value that was read
<li> A write to another location in one or more branches
</ul>
<p>
When those conditions exist, there is a control dependency from the read to
the write that prevents the two operations from being reordered with
respect to each other.  
<p>
<h4>The evil optimizing compiler</h4>
<p>
Or, at least, it would be nice if things worked that way.  The problem is
that, while the <i>hardware</i> works that way,
the C&nbsp;language does not recognize the existence of control
dependencies or, as the infamous kernel <a
href="https://www.kernel.org/doc/Documentation/memory-barriers.txt"><tt>memory-barriers.txt</tt>
document</a> puts it: "<q>Compilers do not understand control
dependencies.  It is therefore your job to ensure that they do not break
your code.</q>"  While there does not appear to be much of a history of
code being broken through overly aggressive optimization of code with
control dependencies, it is something that developers worry about.  That
has led to the <a
href="/ml/linux-kernel/YLn8dzbNwvqrqqp5@hirez.programming.kicks-ass.net/">proposal</a>
by Peter Zijlstra of a mechanism called <tt>volatile_if()</tt>.
<p>
What sort of problem is this patch trying to address?  Consider an example <a
href="/ml/linux-kernel/20210604214010.GD4397@paulmck-ThinkPad-P17-Gen-1/">posted</a>
by Paul McKenney in the discussion:
<p>
<pre>
    if (READ_ONCE(A)) {
	WRITE_ONCE(B, 1);
	do_something();
    } else {
	WRITE_ONCE(B, 1);
	do_something_else();
    }
</pre>
<p>
This code has a control dependency between the read of <tt>A</tt> and the
writes to&nbsp;<tt>B</tt>; each write is in a branch of the conditional
statement and the fact that they write the same value does not affect the
dependency.  So one might conclude that the two operations
could not be reordered.  Compilers, though, might well rearrange the code to
look like this instead:
<pre>
    tmp = READ_ONCE(A);
    WRITE_ONCE(B, 1);
    if (tmp)
	do_something();
    else
	do_something_else();
</pre>
<p>
This code looks equivalent, but the test on the value read from <tt>A</tt>
no longer occurs 
before the write to&nbsp;<tt>B</tt>.  That breaks the control dependency,
freeing a sufficiently aggressive CPU to move the write ahead of the read,
possibly creating a subtle and unpleasant bug.
<p>
Since C doesn't recognize control dependencies, avoiding this kind of bug can
be difficult, even in cases where the developer is aware of the problem.
One sure solution is to read <tt>A</tt> with acquire semantics and write
<tt>B</tt> with release semantics, as described in the lockless patterns
series, but acquire and release operations can be expensive on some
architectures.  That expense is not usually needed in this case.
<p>
<h4>volatile_if()</h4>
<p>
Zijlstra wrote in his proposal that a good solution would be to add a
qualifier to the <tt>if</tt> statement to indicate that a dependency
exists:
<p>
<pre>
    volatile if (READ_ONCE(A)) {
    	/* ... */
</pre>
<p>
The compiler would respond by ensuring that a conditional branch is emitted
and that code from within the branches is not lifted out of those
branches. That, however, requires cooperation from compiler writers; as Segher
Boessenkool <a
href="/ml/linux-kernel/20210604153518.GD18427@gate.crashing.org/">noted</a>,
that is unlikely to happen unless the standards committee gives its blessing
to the idea of putting qualifiers like <tt>volatile</tt> on statements.
Failing that, Zijlstra proposed a magic macro:
<p>
<pre>
    volatile_if(condition) {
    	/* true case */
    } else {
        /* false case */
    }
</pre>
<p>
He provided implementations for a number of architectures; these generally
depend on hand-written assembly code to manually emit the
conditional branch instruction needed to create the control dependency at
the CPU level.
<p>
The resulting discussion focused on two main topics: the implementation of
<tt>volatile_if()</tt> and whether it is needed at all.  On the
implementation side, Torvalds <a
href="/ml/linux-kernel/CAHk-=wievFk29DZgFLEFpH9yuZ0jfJqppLTJnOMvhe=+tDqgrw@mail.gmail.com/">suggested</a>
a simpler approach:
<p>
<pre>
    #define barrier_true() ({ barrier(); 1; })
    #define volatile_if(x) if ((x) &amp;&amp; barrier_true())
</pre>
<p>
The <tt>barrier()</tt> macro causes no code to be emitted; it is just an
empty block presented to the compiler as assembly code.  That keeps the
compiler from reordering operations from one side of the barrier to the
other; it also, Torvalds said, would force the compiler to emit the branch
since it could only be evaluated on the "true" side of the branch.  Life
turned out to not be so simple, though; a redefinition of
<tt>barrier()</tt> along the lines <a
href="/ml/linux-kernel/20210606185922.GF7746@tucnak/">suggested</a> by
Jakub Jelinek would be required to make this scheme actually work.
<p>
But Torvalds also <a
href="/ml/linux-kernel/CAHk-=wiuLpmOGJyB385UyQioWMVKT6wN9UtyVXzt48AZittCKg@mail.gmail.com/">wondered</a>
why developers were worried about this problem in the first place, since he
does not think it can manifest in real code:
<p>
<blockquote class="bq">
	Again, semantics do matter, and I don't see how the compiler could
	actually break the fundamental issue of "load-&gt;conditional-&gt;store
	is a fundamental ordering even without memory barriers because of
	basic causality", because you can't just arbitrarily generate
	speculative stores that would be visible to others.
</blockquote>
<p>
And, indeed, evidence of such problems actually occurring is hard to find.
He did eventually <a
href="/ml/linux-kernel/CAHk-=whDrTbYT6Y=9+XUuSd5EAHWtB9NBUvQLMFxooHjxtzEGA@mail.gmail.com/">come
around</a> to seeing that a problem could potentially exist but also made
it clear that he doesn't think there is any code in the kernel now that
would be affected by it.
<p>
The conversation (eventually) wound down without coming to any real
conclusion on whether <tt>volatile_if()</tt> is needed or not.  Experience
says, though, that wariness toward compiler optimizations is usually a good
idea.  Even if no mechanism for explicitly marking control dependencies is
merged into the mainline now, it will be waiting in the wings should future
compiler releases create problems.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_barriers">Memory barriers</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/860037/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor860274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2021 19:41 UTC (Fri)
                               by <b>ndesaulniers</b> (subscriber, #110768)
                              [<a href="/Articles/860274/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the most interesting comment on that centithread came from Linus discussing the idea that perhaps full &quot;memory&quot; clobbers are somewhat overkill for some their current use cases, but that there&#x27;s no general way at the moment to permit just reads or just writes to be reordered by the compiler. Selected snippets:<br>
<p>
<font class="QuotedText">&gt; in the general barrier case, we very much want to have that &quot;memory&quot;</font><br>
<font class="QuotedText">&gt; clobber, because the whole point of the general barrier case is that</font><br>
<font class="QuotedText">&gt; we want to make sure that the compiler doesn&#x27;t cache memory state</font><br>
<font class="QuotedText">&gt; across it (ie the traditional use was basically what we now use</font><br>
<font class="QuotedText">&gt; &quot;cpu_relax()&quot; for, and you would use it for busy-looping on some</font><br>
<font class="QuotedText">&gt; condition).</font><br>
<p>
<font class="QuotedText">&gt; In the case of &quot;volatile_if()&quot;, we actually would like to have not a</font><br>
<font class="QuotedText">&gt; memory clobber, but a &quot;memory read&quot;. IOW, it would be a barrier for</font><br>
<font class="QuotedText">&gt; any writes taking place, but reads can move around it.</font><br>
<p>
<font class="QuotedText">&gt; I don&#x27;t know of any way to express that to the compiler.</font><br>
<p>
<font class="QuotedText">&gt; It would be much nicer to have a &quot;memory read&quot; marker instead, to let</font><br>
<font class="QuotedText">&gt; the compiler know &quot;I need to have done all pending writes to memory,</font><br>
<font class="QuotedText">&gt; but I can still cache read values over this op because it doesn&#x27;t</font><br>
<font class="QuotedText">&gt; _change_ memory&quot;.</font><br>
<p>
<font class="QuotedText">&gt; It&#x27;s actually not all that uncommon that you have a &quot;this</font><br>
<font class="QuotedText">&gt; doesn&#x27;t modify memory, but you can&#x27;t move writes around it&quot;.</font><br>
<p>
<font class="QuotedText">&gt; Anybody have ideas or suggestions for something like that?</font><br>
<p>
<a href="https://lwn.net/ml/linux-kernel/CAHk-=wjwXs5+SOZGTaZ0bP9nsoA+PymAcGE4CBDVX3edGUcVRg@mail.gmail.com/">https://lwn.net/ml/linux-kernel/CAHk-=wjwXs5+SOZGTaZ0bP9n...</a><br>
<a href="https://lwn.net/ml/linux-kernel/CAHk-=wiOTcBuxx1pYj=mQz-f0dvhbxq2a=ricTuHH5xwUKE5Yw@mail.gmail.com/">https://lwn.net/ml/linux-kernel/CAHk-=wiOTcBuxx1pYj=mQz-f...</a><br>
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100953">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100953</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor895251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2022 12:26 UTC (Sat)
                               by <b>liusy58</b> (guest, #158480)
                              [<a href="/Articles/895251/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This part is much harder for me. Could you please give a more detailed explanation?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/895251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor860288"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 2:48 UTC (Sat)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/860288/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The last example is not clear to me.  No matter which branch is taken, WRITE_ONCE(B, 1) will be executed first thing, before calling either do_something() or do_something_else().  How can there be any problem lifting that out of the branches and making it a single call before testing A?<br>
<p>
This assumes A and B are not aliases, such as being pointers to C; or IO addresses; and I imagine there are other special cases.  But with just ordinary memory, I don&#x27;t see how the re-ordering can cause any problems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860288/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 4:53 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/860290/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The only reason you would do this is if you *need* the read to happen before the write, notwithstanding the fact that the read and write are to unrelated objects/variables. In practice, that means you&#x27;re probably talking about some weird IO-mapped memory or the like. Or else it means you&#x27;re trying to do a weird lockless thing, which is a whole other ball of wax.<br>
<p>
Regardless, it&#x27;s not aliasing. If you play games with aliasing, one of two things happens:<br>
<p>
1. You do not violate the strict aliasing rule (e.g. because the types are the same, one of them is char, etc.). The compiler is required to assume that your pointers may alias. It must emit additional loads and stores as may be necessary; READ_ONCE() etc. are not required.<br>
2. You do violate the strict aliasing rule. Your code is meaningless garbage (UB happens), and no amount of READ_ONCE() etc. will fix it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 14:07 UTC (Sat)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/860300/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Eh, I guess I wasn&#x27;t clear.  What I want to know is, why is it considered bad (or &quot;wrong&quot;) to optimize that common WRITE_ONCE to before the READ?  I understand why if A and B are actually the same, or if there are I/O operations involved, etc.  But I do not understand for the normal memory case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 14:43 UTC (Sat)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/860301/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      It's all a matter of ordering as seen by others.  The write to <tt>B</tt> may be a "I'm dealing with it" flag; some other process may have changed <tt>A</tt> and wants to be sure that its change will be observed before <tt>B</tt> is written.
      
          <div class="CommentReplyButton">
            <form action="/Articles/860301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 16:01 UTC (Sat)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/860305/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But that too is a special case, only applying to threaded code (which I&#x27;ve written enough to be careful around).<br>
<p>
&quot;That breaks the control dependency, freeing a sufficiently aggressive CPU to move the write ahead of the read, possibly creating a subtle and unpleasant bug.&quot;<br>
<p>
So again, other than special cases, including aliased variables, I/O, threaded code, and other unenumerated special cases, what kind of subtle and unpleasant bugs can this create?  Or does that sentence only refer to special cases?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860307"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 17:47 UTC (Sat)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/860307/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      This is an article about kernel programming, where everything is threaded.  Or, as the article says, "The effects of this reordering on single-threaded code are (in the absence of bugs) limited to making it run faster.  When there are multiple threads of execution running simultaneously, though, there can be surprises in store. One thread may observe things happening in a different order than others, leading to all sorts of unfortunate confusion."
      
          <div class="CommentReplyButton">
            <form action="/Articles/860307/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 7:29 UTC (Sun)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/860324/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To state the obvious, this only applies if there aren&#x27;t any other ways that the ordering is guaranteed, the most obvious of which would be a spinlock or mutex.<br>
<p>
Control dependencies also do not matter in most lockless cases, much less control dependencies where the compiler does have meaningful optimizations that would break. Of course, sometimes they do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor860334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Help educate an old 8-bit assembler mindset</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 13:58 UTC (Sun)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/860334/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I had forgotten that this is about kernels, and thus always threaded.  I have written threaded user-space programs, and written ancient 8 bit kernels which were not threaded, and once even modified one line in the linux kernel (some RS-232 control line) for my own use; but never combined those, and lost track of that aspect for this (lwn) thread.<br>
<p>
Thanks to all concerned for my education.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor860289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 4:28 UTC (Sat)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/860289/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;   #define barrier_true() ({ barrier(); 1; })</font><br>
<font class="QuotedText">&gt;   #define volatile_if(x) if ((x) &amp;&amp; barrier_true())</font><br>
<font class="QuotedText">&gt;The barrier() macro causes no code to be emitted; it is just an empty block presented to the compiler as assembly code. </font><br>
<p>
Hmm, wouldn&#x27;t the code need __asm__ attribute to be presented as assembly code?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 23:37 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/860316/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, it probably is defined as something like::<br>
<p>
#define barrer() __asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;)<br>
<p>
What that says is: Here are some assembly instructions you must execute at this point in my code. The instruction somehow don&#x27;t need any of my variables in CPU registers, nor do the CPU registers need to be copied into any of my variables. However, these instructions touch memory somehow. Also, that list of instruction is empty.<br>
<p>
This is a very common trick, the compiler is used to seeing this, and won&#x27;t go &quot;Huh? But your list of instructions is empty&quot;. Since it claims to touch memory in an unspecified way, no optimisations may move reads or writes past this line, as that would alter the meaning of the program. This is of course exactly what everybody who writes this wanted to achieve and the compiler authors know that.<br>
<p>
Since the list of instructions is empty you don&#x27;t even need to know the assembly language of the target CPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 20:11 UTC (Sun)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860344/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So why (and how) can this be implemented more efficiently (on any architecture) than a combination of load_acquire(A) and store_release(B) ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 20:31 UTC (Sun)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860345/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
...or, in this case, just a load_acquire.<br>
<p>
How is a barrier like<br>
<p>
<font class="QuotedText">&gt;  #define barrer() __asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;)</font><br>
<p>
more effective than the barrier implied by load_acquire (on any architecture) ?<br>
(Not a rhetoric question.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 22:41 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/860355/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This barrier has *zero* impact on the machine, it doesn&#x27;t emit any instructions for the machine to run. This barrier only changes what the compiler will do. I can&#x27;t emphasise that enough. There might in fact be no difference in the machine code at all, the goal of barrier() is only to prevent the compiler from potentially spotting an optimisation that&#x27;s inappropriate and mustn&#x27;t happen. If your compiler was not in fact going to attempt an optimisation that&#x27;s now impossible the actual machine code is literally identical.<br>
<p>
In contrast acquire/ release have consequences for the machine as well as the compiler. So the compiler will emit different machine code to ensure that the sequence of operations has acquire/ release semantics, and then at runtime, the actual CPU may be doing something different to ensure the semantics you asked for are achieved.<br>
<p>
On x86-64 the instructions are only slightly different, and only in some cases, you actually pay for implicit acquire/ release semantics all the time on x86 without knowing it; on the original DEC Alpha it&#x27;s a horrible nightmare of locking and CPU barriers; and on some ARM CPUs you can literally say &quot;This load has acquire semantics&quot; and &quot;This store has release semantics&quot; and everything works nicely.<br>
<p>
So barrier() definitely CAN be faster because it doesn&#x27;t emit any instructions at all. However of course just because you wrote fewer instructions doesn&#x27;t make you faster. To find that out reliably in each case you&#x27;d have to benchmark. But first you&#x27;d have to be sure you care enough to go to that effort.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 0:24 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860359/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This barrier has *zero* impact on the machine, it doesn&#x27;t emit any instructions for the machine to run. This barrier only changes what the compiler will do.</font><br>
<p>
Are you sure? I&#x27;m not so sure that architectures with a so-called &quot;weaker&quot; memory model don&#x27;t require some kind of ordering instruction to avoid hardware re-ordering across instructions. In this case, it sounds like the conditional branch instruction might have (welcome) effects on hardware ordering. It is even called a &quot;dummy&quot; conditional branch. Specifically, there appears to be a certain equivalence on arm64 between<br>
<p>
	LDR	X0, [X1]<br>
	CBNZ	X0, 1f		// Dummy ctrl<br>
<p>
and (&quot;with LTO&quot;)<br>
<p>
	LDAPR	X0, [X1]	// RCpc<br>
<p>
<p>
<font class="QuotedText">&gt; In contrast acquire/ release have consequences for the machine as well as the compiler.</font><br>
<p>
Not necessarily. On modern x86, load_acquire and store_release are usually simple MOV instructions.<br>
<p>
My question is about the specifics of architectures where this isn&#x27;t so simple.<br>
<p>
The ordering required here isn&#x27;t really very different from acquire and/or release, and barrier() is apparently a very general tool. So it isn&#x27;t clear what advantages it is meant to have on specific architectures, especially as it would seem that otherwise barrier() could be used to implement even load_acquire.<br>
<p>
Or perhaps at the end of the email discussion, volatile_if is meant more as a convenience than as a possible performance optimization.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 2:16 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/860361/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you sure?</font><br>
<p>
Yes of course I&#x27;m sure. Why else would I write that I cannot emphasise this enough?<br>
<p>
<font class="QuotedText">&gt; I&#x27;m not so sure that architectures with a so-called &quot;weaker&quot; memory model don&#x27;t require some kind of ordering instruction to avoid hardware re-ordering across instructions</font><br>
<p>
Yes, most machines would need some explicit machine instructions to prevent the machine from re-ordering memory access if that was what you wanted to achieve. The Linux barrier() is a compiler barrier, not a CPU barrier. So it does not forbid the CPU from re-ordering memory accesses as it wishes, that is intentional. Use the right tool for the job.<br>
<p>
<font class="QuotedText">&gt; Not necessarily. On modern x86, load_acquire and store_release are usually simple MOV instructions.</font><br>
<p>
If you&#x27;d only read a whole sentence further I more or less spelled this out, it&#x27;s actually the opposite, with all that implies, simple MOV instructions have acquire/release semantics on x86. You are incurring the cost of an acquire or release and sometimes both for every access. Yet, that still isn&#x27;t quite enough for full-on sequential consistency. So naive x86 programs still have surprising races.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 3:00 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860362/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yes, most machines would need some explicit machine instructions to prevent the machine from re-ordering memory access if that was what you wanted to achieve. The Linux barrier() is a compiler barrier, not a CPU barrier. So it does not forbid the CPU from re-ordering memory accesses as it wishes, that is intentional. Use the right tool for the job.</font><br>
<p>
I&#x27;m afraid your answers are more confusing than clarifying.<br>
<p>
If __asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;) results only in a CPU barrier even on &quot;weaker&quot; architectures, then in this case, on some architectures, that alone would not be sufficient. It is those architectures that my question is about.<br>
<p>
It means that it requires something like the conditional branch instruction to complete the ordering.<br>
<p>
So the question remains: why would that not also be enough to implement load_aquire, such that load_acquire has the same performance as barrier + cond.branch ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 3:03 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860364/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If __asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;) results only in a CPU barrier even on &quot;weaker&quot; architectures,</font><br>
<p>
Obviously, I meant: if it only results in a *compiler* barrier....<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 9:59 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/860372/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; in this case, on some architectures, that alone would not be sufficient. It is those architectures that my question is about.</font><br>
<p>
On which architectures do you believe that the CPU exposes memory writes that only happen after a conditional branch, before actually evaluating that branch? Because that&#x27;s the scenario under consideration here. The compiler barrier is to prevent compilers from doing the same re-ordering, which can look fairly reasonable to them because they&#x27;ve got a different view of the situation.<br>
<p>
Linux is not a hypothetical program, so, it isn&#x27;t focused on executing correctly on hypothetical hardware, only real hardware.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 11:56 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860377/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; On which architectures do you believe that the CPU exposes memory writes that only happen after a conditional branch, before actually evaluating that branch?</font><br>
<p>
On none, as a hardware optimization I don&#x27;t expect that to happen.<br>
<p>
The question I&#x27;m asking is if and why (or why not), on any architecture (perhaps arm64), this:<br>
<p>
volatile_if(READ_ONCE(A)) {<br>
   WRITE_ONCE(B,1);<br>
}<br>
<p>
might be faster than this:<br>
 <br>
if (load_acquire(A)) {<br>
   WRITE_ONCE(B,1);<br>
}<br>
<p>
especially if the latter is well optimized by a compiler. I have the tendency to think that the second form using load_acquire can be just as fast, at least if the compiler does a good job. However perhaps there are architectures on which that isn&#x27;t true, and that is what my question is about.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor860368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 16:42 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/860368/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Because, on the very weakest implementations of (e.g.) AArch64, load acquire is more expensive than load followed by a dependent branch, but the load followed by a dependent branch is a sufficient barrier for the purposes at hand.
<p>Consider in terms of the following pseudo-code; thread 0 is writing to two memory locations, and before the two threads run on separate CPU cores, the memory at adr1 and adr2 is set to 0.
<pre><tt>
# Thread 0
MOV R0, #42
MOV R1, #99
STR [addr3], R1
STR [addr2], R1
STR_REL [addr1], R0

# Thread 1
MOV R5, 1
MOV R6, 1
LDR R4, [addr1]
CMP R4, #42
BEQ load
JMP end
.load
LDR R5, [addr2]
.end
LDR R6, [addr3]
</tt>
</pre>
<p>The question we're trying to answer is "what values are in R5 and R6 of thread 1 at the label end?".
<p>On an Alpha, there are 3 possible answers: if R4 is 42, then R5 and R6 must both be either 0 or 99, depending on whether or not the LDR R5 and LDR R6 observed the store to addr2 or not. If R4 is not 42, then R5 and R6 must be 1. Alpha is allowed to re-order the loads in thread 1 freely because they are independent of each other, and thus all of (R5 = 0, R6 = 0), (R5 = 0, R6 = 99), (R5 = 99, R6 = 0) and (R5 = 99, R6 = 99) are possible.
<p>On x86, the answer is either R5 = R6 = 1 or R5 = R6 = 99; once the load of R4 has taken place, thread 1 is guaranteed to see the stores to both addr1 and addr2, and thus the loads to R5 and R6 must see the store to addr2. Thus, if R4 is 42, R5 is guaranteed to be 99, while if R4 is not 42, R5 is guaranteed to be 1. Same reasoning applies to R6 as to R5.
<p>ARM's memory ordering is mostly weak, like Alpha's, but it adds in one more wrinkle; dependency chains act as ordering. Because of this, R5 is again either 1 or 99; however, this happens for slightly different reasons to x86. On ARM, the STR_REL guarantees that a load that observes the store to addr1 will also be able to observe the store to addr2; because the load of R5 has a dependency on the value of R4, the ARM memory ordering model guarantees that the load of R5 will take place after the load of R4, and hence will also observe the store to addr1. However, there's no such dependency in R6's control flow, and thus R6 is allowed to be either 0 or 99 if R4 is 42, because the CPU can reorder the load to happen before the conditional.
<p>If the load to R4 was a load-acquire, then all three processors would observe the same memory contents. However, both ARM and Alpha would be denied reordering opportunities by the load-acquire that they have without it, and hence could be slower.
      
          <div class="CommentReplyButton">
            <form action="/Articles/860368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 22:43 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860456/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Because, on the very weakest implementations of (e.g.) AArch64, load acquire is more expensive than load followed by a dependent branch, but the load followed by a dependent branch is a sufficient barrier for the purposes at hand. </font><br>
<p>
This is the claim I am interested in.<br>
<p>
<font class="QuotedText">&gt; Consider in terms of the following pseudo-code; thread 0 is writing to two memory locations, and before the two threads run on separate CPU cores, the memory at adr1 and adr2 is set to 0. </font><br>
<p>
Thanks for going into this detail. <br>
I&#x27;m assuming that you also meant addr3 to be initialized with 0.  It seems you changed the location of the label &quot;.end&quot; while you were writing your post. As it is, with the end label between the loads of R5 and R6, R6 couldn&#x27;t be 1 (assuming addr3 is initialized with 0).<br>
<p>
<font class="QuotedText">&gt; On an Alpha, there are 3 possible answers: if R4 is 42, then R5 and R6 must both be either 0 or 99, depending on whether or not the LDR R5 and LDR R6 observed the store to addr2 or not. If R4 is not 42, then R5 and R6 must be 1. Alpha is allowed to re-order the loads in thread 1 freely because they are independent of each other, and thus all of (R5 = 0, R6 = 0), (R5 = 0, R6 = 99), (R5 = 99, R6 = 0) and (R5 = 99, R6 = 99) are possible. </font><br>
<p>
R6 can be 1 only if the &quot;.end&quot; label is moved to the actual end. So here I am putting R6 aside, since then it will be like R5 (but see discussion of R6 for ARM.).<br>
<p>
My understanding is that &quot;volatile_if&quot; is meant to prevent a re-ordering of the effective load of R5 to a point before the load of R4. In fact, that appears to be the whole point (I don&#x27;t see any indication that it would be meant to affect only stores). If it does succeed in preventing that, then only (R5 = 99) is possible if R4 is 42, since 42 is written with a store_release.<br>
<p>
So if Alpha behaves as you say, I don&#x27;t see how the pseudo code would be sufficient to implement &quot;volatile_if&quot;. And I wouldn&#x27;t know what it takes to fix that, or how that would affect our discussion.<br>
<p>
<font class="QuotedText">&gt; On x86, the answer is either R5 = R6 = 1 or R5 = R6 = 99; once the load of R4 has taken place, thread 1 is guaranteed to see the stores to both addr1 and addr2, and thus the loads to R5 and R6 must see the store to addr2. Thus, if R4 is 42, R5 is guaranteed to be 99, while if R4 is not 42, R5 is guaranteed to be 1. Same reasoning applies to R6 as to R5. </font><br>
<p>
Yes.<br>
(R6 can be 1 only if the &quot;.end&quot; label is moved to the actual end.)<br>
<p>
<font class="QuotedText">&gt; ARM&#x27;s memory ordering is mostly weak, like Alpha&#x27;s, but it adds in one more wrinkle; dependency chains act as ordering. Because of this, R5 is again either 1 or 99; however, this happens for slightly different reasons to x86. On ARM, the STR_REL guarantees that a load that observes the store to addr1 will also be able to observe the store to addr2; because the load of R5 has a dependency on the value of R4, the ARM memory ordering model guarantees that the load of R5 will take place after the load of R4, and hence will also observe the store to addr1. However, there&#x27;s no such dependency in R6&#x27;s control flow, and thus R6 is allowed to be either 0 or 99 if R4 is 42, because the CPU can reorder the load to happen before the conditional. </font><br>
<p>
Here it seems that you want the &quot;.end&quot; label to really be between the loads of R5 and R6, as you also don&#x27;t claim that R6 could be 1. That means that you mean R6 to be outside of the volatile-if statement, and since also at the language level, volatile_if is meant to allow R6 to be 0 (regardless of R4&#x27;s value) in that case, I can see that ARM would be able to take advantage of that and perform the load before or during the conditional. Whereas x86 would not.<br>
<p>
In situations where an R6 does not exist, it still seems the compiler could optimize load_acquire to produce equivalent code also without a construct like volatile_if (in so far as that might be a distinct advantage), since R5 must be 99 either way, if R4 is 42.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860481"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2021 3:38 UTC (Tue)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860481/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A follow-up question for ARM would be:<br>
<p>
What if the load of R6 appears in both the &#x27;then&#x27; path and the &#x27;else&#x27; path of the BEQ conditional branch? Instead of after the conditional paths join. <br>
<p>
Then there would be two load instructions, each dependent on the conditional. Would that mean that loading R6 is now ordered, or is the CPU allowed to internally join the two paths and remove the dependency? Is ARM&#x27;s behavior defined in this case? I think it needs to be, and the straightforward definition would be that R6 is then ordered. (And that the compiler could use this for optimizations.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860481/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860505"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2021 9:47 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/860505/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>First, thank you for reading my previous comment as intended, not as written - I did make a lot of mistakes trying to put together a case where ARM's ordering is weaker than store-acquire, but you caught my intentions.
<p>Yes, if the load of R6 appears in both paths, then it's an ordered load, due to the data dependency affecting both cases, and thus ARM can't reorder in their memory model; in theory, the compiler can exploit this to get R6 ordered even though the load of R6 is unconditional, while still allowing future loads to be reordered before the load of R6. 
<p>The point of the ARM behaviour here is to give you a guarantee that code like the following Cish does what you intended without forcing full ordering between the two threads:
<pre><tt>
const int global42 = 42;
int global_int;
int *global_ptr;
void main() {
    global_ptr = &amp;global42;
    full_memory_barrier();
    start_threads(thread0, thread1);
    wait_for_threads();
}

void thread0() {
    global_int = 123;
    atomic_store_explicit(global_ptr, &amp;global_int, memory_order_release);
}

void thread1() {
    int *i = global_ptr;
    int j = *i;
    if (i == &amp;global_int) {
        assert(j == 123);
    } else {
        assert(j == 42);
    }
}
</tt></pre>
<p>Because the store to <tt>global_ptr</tt> is a release store, any thread which observes that store also observes the store to <tt>global_int</tt>. <tt>thread1</tt> can thus use the value of <tt>i</tt> to determine which value it loaded.
<p>On Alpha's memory model (which is as weak as you can get), it is permissible for <tt>i</tt> to point at <tt>global42</tt>, but for the load to read <tt>123</tt>, or vice-versa. ARM disallows this particular case.
<p>Another way of looking at it would be that you can fix <tt>thread1</tt> to work correctly on any standards-compliant C compiler by making it:
<pre><tt>
void thread1() {
    int *i = atomic_load_explicit(global_ptr, memory_order_consume);
    int j = *i;
    if (i == &amp;global_int) {
        assert(j == 123);
    } else {
        assert(j == 42);
    }
}</tt></pre>
<p>And on Alpha, the <tt>atomic_load_explicit</tt> needs to put appropriate memory ordering instructions into the instruction stream for <tt>thread1</tt>; on ARM, those ordering instructions are implicit in ordinary loads.
      
          <div class="CommentReplyButton">
            <form action="/Articles/860505/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860593"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2021 21:03 UTC (Tue)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860593/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The point of the ARM behaviour here ....</font><br>
<p>
Makes sense, and gives a good idea of ARM (and Alpha) in this regard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860593/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor860292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 6:02 UTC (Sat)
                               by <b>bartoc</b> (guest, #124262)
                              [<a href="/Articles/860292/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
wg14 (C) and wg21(c++) are extremely unlikely to be open to anything remotely like this idea. I&#x27;m less sure the feelings of wg14 folks   but wg21 folks really are not a fan of stuff like volatile at all. It&#x27;s extremely hard to specify, once specified in the standard&#x27;s wording it&#x27;s too weak to actually do what programmers want, and it&#x27;s best left as a compiler attribute with documented platform specific behavior. Is it possible that where the annotation is appropriate the only situation where the compiler could reorder the read and write would indicate a bug in your code _anyway_? Meaning maybe the attribute should emit an error if the compiler decides it _can_ reorder an indicated write across the if. <br>
<p>
many uses of normal volatile variables are deprecated and will emit a warning in c++20 (I&#x27;m aware there&#x27;s no C++ in linux, but the formal memory model used in C was developed in concert with C++, when both had to specify the memory model more precisely in order to standardize threads and atomics). In particular v |= something where v is volatile (this seems to be to make the read-modify-write explicit, I&#x27;m not sure I&#x27;m a fan in the specific case of &amp;= and |=, but basically agree in the case of += -= *= and /=)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 14:53 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/860302/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don’t really understand the objection to &amp;= and |= - is it a generalized objection to being able to write bitops like this?  Can you say why?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 18:47 UTC (Sat)
                               by <b>kkdwivedi</b> (subscriber, #130744)
                              [<a href="/Articles/860312/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a recent paper (P2327) addressing compound operations (those used to flip bits in particular).<br>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2327r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 0:47 UTC (Sun)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/860319/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, thanks - I realize now I misread the original post as objecting to them.  The decision of the standard to deprecate them seems ……. Let’s say “user hostile”.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 3:33 UTC (Mon)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/860365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that users expect volatile variables to be safe against interrupts/signals. And that is generally the case for read and write operations. So, by analogy, users expect `x |= 5;` on a volatile int to be the way to spell a read-modify-write which is also safe against interrupts. But, it has never guaranteed that -- neither in the spec nor in most implementations.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor860317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 0:08 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/860317/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The intended purpose of volatile is explicitly to cause actual memory reads/ writes, because perhaps the &quot;memory&quot; isn&#x27;t. it comes into existence because the computer they&#x27;re writing C on has memory-mapped I/O and early attempts at optimising C compilers are a huge step forward  for performance but break some of the device handling code.<br>
<p>
Today, volatile is rightly imagined as a property of actions, not variables. &quot;volatile write variable -&gt; $address &quot; =&gt; &quot;Literally write this to memory, even though it seems as though we&#x27;re never reading that memory and so needn&#x27;t bother, I promise that&#x27;s actually what must happen&quot;. &quot;volatile read $address -&gt; variable&quot; =&gt; Literally read this from memory, even though it seems as though we already know the value, I promise that&#x27;s actually what must be done&quot;. Whereas &quot;volatile variable&quot; is too vague.<br>
<p>
On some hardware, there may be very fine memory mapping, such that you can actually read or write a smaller value than the natural machine word to special memory regions, maybe the normal word size is 32 bits, but for a small range of &quot;memory&quot; it actually matters whether you use the 16-bit move instruction or the 32-bit one because they behave differently. In some cases this gets finer than a single byte, maybe there&#x27;s a flag in the bottom bit of address 0x0037 and you can actually read or write that single bit, from machine code and it has completely different behaviour from if you were to try to read or write the whole 0x0037 byte on that hardware.<br>
<p>
So, because volatile is defined so openly in C, your compiler vendor can say OK, we make this compiler for this weird hardware, and we promise if you say that this is a _volatile_ byte pointer to 0x0037 and then you use |= 0x01 we will actually emit the machine code for the single bit write, even though that&#x27;s not how it would be implemented for other occurrences of |= 0x01<br>
<p>
But the language standard can&#x27;t say anything about these platform specific details, so it just leaves that to your the compiler vendor, and with the exception of specialist compiler vendors who care very much about this stuff, the compiler vendor says as little about it as possible, hoping you will go away.<br>
<p>
Probably what _ought_ to happen if C was designed from scratch today is that these platforms provide a special intrinsic function and if you actually need to poke the bottom bit of address 0x0037 you call some intrinsic like __foocorp_bit_poke(0x0037, 0, 1) and how that&#x27;s actually implemented is only a problem for the platform compiler developer. Anybody who needs the intrinsic (e.g. someone porting Linux to the platform) uses it, everybody else is blissfully unaware. But at the time they just added this &quot;volatile&quot; qualifier to the C language as a dumping ground for all features about hardware memory reads/ writes and called it a day.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 2:44 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/860321/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not limited to foocorp though. A PCIe device (yes, even one designed today) can have vastly different behaviour for MMIO accesses that are single byte vs double-byte vs quad-byte. Most don&#x27;t because that&#x27;s painful for software to cope with, but you must define some form of generic MMIO accessor or the compiler cannot be used to write a device driver.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860349"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 22:07 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/860349/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, but I was talking about bit-addressing.<br>
<p>
Rust (sorry but I&#x27;ve spent lots of time staring at this recently so it&#x27;s at the top of my head) provides<br>
<p>
std::ptr::read_volatile(ptr) and std::ptr::write_votalite(ptr, foo)<br>
<p>
If you provide read_volatile with say a pointer to i16 (a 16-bit signed integer), that&#x27;ll compile and it&#x27;ll emit an actual double-byte memory read, assuming that i16 pointer was pointing at the MMIO for your PCIe device you&#x27;ll get what you wanted.  If you do it with a pointer to u8 (an 8-bit unsigned integer) that&#x27;ll do the single-byte read. And the same with the write equivalents.<br>
<p>
These are stable but unsafe APIs. That is, Rust promises these are expected to still work tomorrow, but it doesn&#x27;t vouch for the safety of just doing memory operations on raw addresses, so if this was a terrible idea you get to keep both halves when it breaks. They&#x27;re defined in a completely generic way, so you could imagine calling read_volatile(pointer-to-4x4-matrix) but of course your CPU is not completely generic so it&#x27;s between the CPU vendor, the compiler vendor, and the PCIe device maker whether that does anything useful.<br>
<p>
However, for bit-addressing it&#x27;s not at all obvious what the generic thing to do would be. So Rust just doesn&#x27;t, and I argue that unlike your PCIe MMIO trick, bit addressed volatile memory access is in fact a niche feature in 2021.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860349/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor860314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2021 22:52 UTC (Sat)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/860314/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding of this situation is far from complete, as for example I do not sufficiently understand the implications of acquire/release on all architectures.<br>
<p>
However it seems to me that this isn&#x27;t really about if-statements, but about order two specific memory accesses without impacting other compiler or hardware optimizations.<br>
<p>
So perhaps a construct like ORDER_ACCESS( A, B ) would better reflect the original intentions, and be applicable to a much larger group of use cases.<br>
<p>
This would specifically instruct the compiler to generate code that completes previous memory accesses to A before initiating following memory accesses to B.<br>
<p>
(And perhaps be best implemented as a compiler primitive or general language construct like barriers, and the code generation be informed by kernel engineers who have the practical experience across architectures and ideas regarding optimal code to be generated, such as using conditional branch instructions to create a hardware barrier.)<br>
<p>
So:<br>
tmp = READ_ONCE(A);<br>
ORDER_ACCESS( A, B );<br>
WRITE_ONCE(B, 1);<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor860318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 0:42 UTC (Sun)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/860318/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This sounds very similar to what the broken memory_order_consume is trying to do.  Is that thing practically fixable?<br>
<p>
Btw I feel a release order would be needed anyway on the write side, this form probably just exploits dependency order on the read side.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2021 12:08 UTC (Sun)
                               by <b>Bigos</b> (subscriber, #96807)
                              [<a href="/Articles/860332/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Linux kernel uses dependent READ_ONCE() in order to implement something akin to memory_order_consume. The assumption is that the compilers will never reorder instructions such as these due to there being a data dependency:<br>
<p>
int* ptr = READ_ONCE(slot);<br>
int value = READ_ONCE(ptr);<br>
<p>
This article is about cases where there is no data dependency but there is a control dependency. AFAIK most weak-memory-model architectures respect such a dependency if there is a jump instruction in the middle, but the compiler must first not reorder the instructions itself and must actually generate a jump instruction (which is not always obvious as it could be lowered to a cmove-like instruction).<br>
<p>
Regarding memory_order_consume (and [[carries_dependency]]), the problem is with ensuring that there is a dependency without involving the type system. If instead load(std::memory_order_consume) returned Dependent&lt;T&gt; and the compiler promised that loads using it are either data or control dependent on the original load then it would be a lot easier to define and implement. I think this is what the following is about:<br>
<p>
<a href="http://wg21.link/P0750">http://wg21.link/P0750</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor860366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2021 5:40 UTC (Mon)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/860366/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks, very informative; memory_order_consume was considered broken even before the day I first heard of it, so I didn&#x27;t look into its details and never realized the distinction between data dependency and control dependency.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor860724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Protecting control dependencies with volatile_if()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2021 7:10 UTC (Thu)
                               by <b>tpo</b> (subscriber, #25713)
                              [<a href="/Articles/860724/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would like to suggest to clarify the context of the topic of the article in the article.<br>
<p>
My argument comes from the position, that LWN articles such as this one informally also serve as documentation and as reference material. As such it&#x27;d be splendid if the article could be as clear and unambiguous as possible.<br>
<p>
My comment echoes felixfix&#x27;s comments and confusion above.<br>
<p>
The article is saying: &quot;When there are multiple threads of execution running simultaneously, though, there can be surprises in store.&quot;. In here lies (IMO) the core of the whole article. But to me that single phrase is *way* understated. That assertion should be stated in a as strong way as possible so that the reader will not miss it. Otherwise - I posit - the reader can not really understand the article.<br>
<p>
Also having multiple threads is *not* a sufficient condition leading to the troubles that are being sought to be solved in the article.<br>
<p>
The point is that *iif* there are multiple actors *and* A and B below are somehow causally related, then:<br>
<p>
LOAD A<br>
STORE B <br>
<p>
*must not be reordered*. By multiple actors I mean either something that can change state *or* has its own state that depends on either the value of A or B or the access thereof.<br>
<p>
&quot;Other actors&quot; can be:<br>
<p>
* an interrupt controller interrupting the execution of the code above and triggering execution of some different code<br>
* any device<br>
* another CPU core<br>
* another CPU<br>
* a different thread<br>
<p>
If any of the above exist and treat (the access to A or B) or (the values of A and B) as somehow logically interdependent then reordering LOAD A and STORE B can lead to trouble.<br>
<p>
Example: let&#x27;s take a networking hardware component: if &quot;LOAD A&quot; would mean to the networking hardware &quot;OK, the ethernet frame was read from the buffer which can now be used again&quot; then it is crucial to the correct functioning of the network stack that the &quot;STORE B&quot; (as in write new data into the buffer) is correctly ordered.<br>
<p>
Please note that I am not a kernel hacker and as such the above might not precisely reflect actual hardware. The point I&#x27;m tring to make is: a) the central problem should be stated much more clearly and b) the problem is as far as I&#x27;m able to tell much more generic than only multithreaded situations<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
