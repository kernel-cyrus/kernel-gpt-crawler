        <!DOCTYPE html>
        <html lang="en">
        <head><title>Object-oriented design patterns in the kernel, part 2 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/446317/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/446125/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/446317/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Object-oriented design patterns in the kernel, part 2</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we donâ€™t have to get good at marketing.
</blockquote>
<div class="GAByline">
           <p>June 7, 2011</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>
In the
<a href="/Articles/444910/">first part</a>
of this analysis we looked at how the polymorphic side of object-oriented
programming was implemented in the Linux kernel using regular C constructs.  In
particular we
examined method dispatch, looked at the different forms that vtables could
take, and the circumstances where separate vtables were eschewed in preference
for storing function pointers directly in objects.

In this conclusion we will explore a second important aspect of object-oriented
programming - inheritance, and in particular data inheritance.
<h3>Data inheritance</h3>
<p>
Inheritance is a core concept of object-oriented programming, though it
comes in many forms, whether prototype inheritance, mixin inheritance,
subtype inheritance, interface inheritance etc., some of which overlap.
The form that is of interest when exploring the Linux kernel is most
like subtype inheritance, where a concrete or "final" type inherits
some data fields from a "virtual" parent type.  We will call this "data
inheritance" to emphasize the fact that it is the data rather than the
behavior that is being inherited.
</p><p>
Put another way, a number of different implementations of a particular
interface share, and separately extend, a common data structure.  They
can be said to inherit from that data structure.
There are three different approaches to this sharing and extending
that can be found in the Linux kernel, and all can be seen by
exploring the <tt>struct inode</tt> structure and its history, though they
are widely used elsewhere.
</p>
<h4>Extension through unions</h4>
<p>
The first approach, which is probably the most obvious but also the
least flexible, is to declare a union as one element of the common
structure and, for each implementation, to declare an entry in that
union with extra fields that the particular implementation needs.

This approach was
<a href="http://git.kernel.org/?p=linux/kernel/git/history/history.git;a=commitdiff;h=eb79918f272fe119902db3028e0fbdc752f4942d#patch22">introduced</a>
to <tt>struct inode</tt> in Linux-0.97.2 (August 1992) when
</p><pre>
       union {
               struct minix_inode_info minix_i;
               struct ext_inode_info ext_i;
               struct msdos_inode_info msdos_i;
       } u;
</pre><p>
was added to struct inode.  Each of these structures remained empty
until 0.97.5 when <tt>i_data</tt> was
<a href="http://git.kernel.org/?p=linux/kernel/git/history/history.git;a=commitdiff;h=06d9f6ff137579551a2ee18661847915fe2bb812#patch32">moved</a>
from <tt>struct inode</tt> to
<tt>struct ext_inode_info</tt>.
Over the years several more "inode_info" fields were added for
different filesystems, peaking at 28 different "inode_info" structures in
2.4.14.2 when
<a href="http://git.kernel.org/?p=linux/kernel/git/tglx/history.git;a=blobdiff;f=include/linux/fs.h;h=935c6e9bfee8d331db28832c54e4bd99d6563e97;hp=33f3bb92af4011eb33a0b99c483803787c436d88;hb=a8a2069f432c5597bdf9c83ab3045b9ef32ab5e3;hpb=5db5272c0a5cd37e5a697e4750fbc4ce6317b7dc">ext3 was added</a>.
</p><p>
This approach to data inheritance is simple and straightforward, but
is also somewhat clumsy.  There are two obvious problems.
Firstly, every new filesystem implementation needs to add an extra
field to the union "u".  With 3 fields this may not seem like a
problem,  with 28 it was well past "ugly".  Requiring every filesystem to
update this one structure is a barrier to adding filesystems that is
unnecessary.
Secondly, every inode allocated will be the same size and will be
large enough to store the data for any filesystem.  So a filesystem
that wants lots of space in its "inode_info" structure will impose
that space cost on every other filesystem.
</p><p>
The first of these issues is not an impenetrable barrier as we will see
shortly.  The second is a real problem and the general ugliness of the
design encouraged change.  Early in the 2.5 development series
 this change began; it was completed by 2.5.7 when there were no
"inode_info" structures left in <tt>union&nbsp;u</tt> (though the union itself
remained until 2.6.19).
</p>
<h4>Embedded structures</h4>
<p>
The change that happened to inodes in early 2.5 was effectively an
inversion.  The change which
<a href="http://git.kernel.org/?p=linux/kernel/git/tglx/history.git;a=blobdiff;f=include/linux/fs.h;h=6bda17aed79ac146466c42bd2355c246e4814d0e;hp=4e5de1286d87969509d812eb9c2f813ae61fd252;hb=463727d199b089c420e750d43f75ea9403a45e12;hpb=0713f0290054eb9769d588120712e3dccfb3ec34">removed</a>
<tt>ext3_i</tt> from <tt>struct inode.u</tt> also
<a href="http://git.kernel.org/?p=linux/kernel/git/tglx/history.git;a=blobdiff;f=include/linux/ext3_fs_i.h;h=104aea4e0c1958fe684c5fe02f33d02484adaa30;hp=3c8d398a81039044765ad86adaf09d2018867fd1;hb=463727d199b089c420e750d43f75ea9403a45e12;hpb=0713f0290054eb9769d588120712e3dccfb3ec34">added</a>
a <tt>struct inode</tt>, called <tt>vfs_inode</tt>, to
<tt>struct ext3_inode_info</tt>.
So instead of the private structure being embedded in the common data
structure, the common data structure is now embedded in the private
one.

This neatly avoids the two problems with unions; now each filesystem
needs to only allocate memory to store its own structure without any need
to know anything about what other filesystems might need.  Of course
nothing ever comes for free and this change brought with it other
issues that needed to be solved, but the solutions were not costly.
</p><p>
The first difficulty is the fact that when the common filesystem code
- the VFS layer - calls into a specific filesystem it passes
a pointer to the common data structure, the <tt>struct inode</tt>.  Using
this pointer, the filesystem needs to find a pointer to its own
private data structure.  An obvious approach is to always place the
<tt>struct inode</tt> at the top of the private inode structure and simply
cast a pointer to one into a pointer to the other.  While this can
work, it lacks any semblance of type safety and makes it harder to
arrange fields in the inode to get optimal performance - as some
kernel developers are wont to do.
</p><p>
The solution was to use the
<a href="http://lxr.linux.no/#linux-bk+v2.5.2/include/linux/list.h#L145"><tt>list_entry()</tt></a>
macro to perform the
necessary pointer arithmetic, subtracting from the address of the
<tt>struct inode</tt> its offset in the private data structure and then casting
this appropriately.

The macro for this was called <tt>list_entry()</tt> simply because the
"list.h lists" implementation was the first to use this pattern of data
structure embedding.  The <tt>list_entry()</tt> macro did exactly
what was needed and so it was used despite the strange name.
This practice lasted until 2.5.28 when a new <tt>container_of()</tt> macro was
<a href="http://git.kernel.org/?p=linux/kernel/git/tglx/history.git;a=commitdiff;h=ec4f214232cfb99913308c20b9a3381e5fe1f04f#patch15">added</a>
which implemented the same functionality as <tt>list_entry()</tt>, though
with slightly more type safety and a more meaningful name.
With <tt>container_of()</tt> it is a simple
matter to map from an embedded data structure to the structure in which it is
embedded.
</p><p>
The second difficulty was that the filesystem had to be responsible
for allocating the inode - it could no longer be allocated by common
code as the common code did not have enough information to allocate
the correct amount of space.  This simply involved
<a href="http://git.kernel.org/?p=linux/kernel/git/tglx/history.git;a=blobdiff;f=include/linux/fs.h;h=4e5de1286d87969509d812eb9c2f813ae61fd252;hp=a01f0c3b4d34df475a84532417c42d46eb0974ed;hb=468e6d17ff42e6f291a88c87681b2b5e34e9ab33;hpb=d694597ed5e1f6613d0933ee692333ab2542b603">adding</a>
<tt>alloc_inode()</tt> and <tt>destroy_inode()</tt> methods to the
<tt>super_operations</tt> structure and calling them as appropriate.
</p>
<h4>Void pointers</h4>
<p>
As noted earlier, the union pattern was not an impenetrable barrier to adding
new filesystems independently.  This is because the <tt>union u</tt> had one
more field that was not an "inode_info" structure.
A generic pointer field
called <tt>generic_ip</tt> was
<a href="http://git.kernel.org/?p=linux/kernel/git/history/history.git;a=commitdiff;h=4aad5d636d7c5a543a82757d9be2e3f3e5c6724f#patch14">added</a>
in Linux-1.0.5, but it was not used until 1.3.7.

Any file system that does not own a structure in <tt>struct inode</tt> itself
could define and allocate a separate structure and link it to the inode
through <tt>u.generic_ip</tt>.  This approach addressed both of the problems
with unions as no changes are needed to shared declarations and each
filesystem only uses the space that it needs.  However it again
introduced new problems of its own.
</p><p>
Using <tt>generic_ip</tt>, each filesystem required two allocations
for each inode instead of one and this could lead to more wastage
depending on how the structure size was rounded up for allocation; it also
required writing more error-handling code.
Also there was memory used for the <tt>generic_ip</tt> pointer and often for a
back pointer from the private structure to the common <tt>struct inode</tt>.
Both of these are wasted space compared with the union approach or
the embedding approach.
</p><p>
Worse than this though, an extra memory dereference was needed to
access the private structure from the common structure; such
dereferences are best avoided.  Filesystem code will often need to
access both the common and the private structures.  This either
requires lots of extra memory dereferences, or it requires holding the
address of the private structure in a register which increases
register pressure.
It was largely these concerns that stopped <tt>struct inode</tt> from ever
migrating to broad use of the <tt>generic_ip</tt> pointer.  It was certainly
used, but not by the major, high-performance filesystems.
</p><p>
Though this pattern has problems it is still in wide use.
<tt>struct super_block</tt> has an <tt>s_fs_info</tt> pointer which serves the same
purpose as <tt>u.generic_ip</tt> (which has since been renamed to
<tt>i_private</tt> when the <tt>u</tt> union was finally removed - why it was
not completely removed is left as an exercise for the reader).  This is the only
way to store filesystem-private data in a super_block.  A simple search in
the Linux include files shows quite a collection of fields which are
void pointers named "private" or something similar.  Many
of these are examples of the pattern of extending a data type by using
a pointer to a private extension, and most of these could be converted to using
the embedded-structure pattern.
</p>
<h3>Beyond inodes</h3>
<p>
While inodes serve as an effective vehicle to introduce these three patterns
they do not display the full scope of any of them so it is useful to look
further afield and see what else we can learn.
</p><p>
A survey of the use of unions elsewhere in the kernel shows that they are widely
used though in very different circumstances than in <tt>struct inode</tt>.  The
particular aspect of inodes that is missing elsewhere is that a wide range of
different modules (different filesystems) each wanted to extend an inode in
different ways.  In most places where unions are used there are a small fixed
number of subtypes of the base type and there is little expectation of more
being added.  A simple example of this is
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/nfs_xdr.h#L34"><tt>struct nfs_fattr</tt></a>
which stores file attribute information decoded out of an NFS reply.  The
details of these attributes are slightly different for NFSv2 and NFSv3 so there
are effectively two subtypes of this structure with the difference encoded in a
union.  As NFSv4 uses the same information as NFSv3 this is very unlikely to
ever be extended further.
</p><p>
A very common pattern in other uses of unions in Linux is for encoding messages
that are passed around, typically between the kernel and user-space.
<a href="http://lxr.linux.no/#linux+v2.6.39/include/asm-generic/siginfo.h#L40"><tt>struct siginfo</tt></a>
is used to convey extra information with a signal delivery.
Each signal type has a different type
of ancillary information, so <tt>struct siginfo</tt> has a union to
encode six different subtypes.
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/coda.h#L654"><tt>union inputArgs</tt></a>
appears to be the largest current union with 22 different subtypes.  It is used
by the "coda" network file system to pass requests between the kernel module
and a user-space daemon which handles the network communication.
</p><p>
It is not clear whether these examples should be considered as the same pattern
as the original <tt>struct inode</tt>.  Do they really represent different
subtypes of a base type, or is it just one type with internal variants?
The
<a href="http://en.wikipedia.org/wiki/Eiffel_%28programming_language%29">Eiffel
object-oriented programming language</a>
does not support variant types at all except through subtype inheritance so
there is clearly a school of thought that would want to treat all usages of
union as a form of subtyping.  Many other languages, such as C++, provide both
inheritance and unions allowing the programmer to make a choice.  So the answer
is not clear.
</p><p>
For our purposes it doesn't really matter what we call it as long as we know
where to use each pattern.  The examples in the kernel fairly clearly show that
when all of the variants are understood by a single module, then a union is a
very appropriate mechanism for variants structures, whether you want to refer
to them as using data inheritance or not.  When different subtypes are managed
by different modules, or at least widely separate pieces of code, then one of
the other mechanisms is preferred.  The use of unions for this case has almost
completely disappeared with only
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/cyclomx.h#L43"><tt>struct cycx_device</tt></a>
remaining as an example of a deprecated pattern.
</p>
<h4>Problems with void pointers</h4>
<p>
Void pointers are not quite so easy to classify.  It would probably be fair to say
that void pointers are the modern equivalent of "goto" statements.  They can be
very useful but they can also lead to very convoluted designs.  A particular
problem is that when you look at a void pointer, like looking at a goto, you
don't really know what it is pointing at.  A void pointer called
<tt>private</tt> is even worse - it is like a "<tt>goto destination</tt>"
command - almost meaningless without reading lots of context.
</p><p>
Examining all the different uses that void pointers can be put to would be well
beyond the scope of this article.  Instead we will restrict our attention to
just one new usage which relates to data inheritance and illustrates how the
untamed nature of void pointers makes it hard to recognize their use in data
inheritance.

The example we will use to explain this usage is
<tt><a
href="http://lxr.linux.no/#linux+v2.6.39/include/linux/seq_file.h#L16">struct
seq_file</a></tt>
used by the seq_file library which makes it easy to synthesize simple
text files like some of those in <tt>/proc</tt>.  The "seq" part of seq_file
simply indicates that the file contains a sequence of lines corresponding to a
sequence of items of information in the kernel, so <tt>/proc/mounts</tt> is a
<tt>seq_file</tt> which walks through the mount table reporting each mount
on a single line.
</p><p>
When
<a href="http://lxr.linux.no/#linux+v2.6.39/fs/seq_file.c#L30"><tt>seq_open()</tt></a>
is used to create a new seq_file it allocates a
<tt>struct seq_file</tt> and assigns it to the <tt>private_data</tt> field of
the <tt>struct file</tt> which is being opened.  This is a straightforward
example of void pointer based data inheritance where the <tt>struct file</tt>
is the base type and the <tt>struct seq_file</tt> is a simple extension to that
type.  It is a structure that never exists by itself but is always the
<tt>private_data</tt> for some file.

<tt>struct seq_file</tt> itself has a <tt>private</tt> field which is a void
pointer and it can be used by clients of seq_file to add extra state to the
file.  For example
<a href="http://lxr.linux.no/#linux+v2.6.39/drivers/md/md.c#L6496"><tt>md_seq_open()</tt></a>
allocates a <tt>struct mdstat_info</tt> structure and attaches it via
this <tt>private</tt> field, using it to meet md's internal needs.  Again,
this is simple data inheritance following the described pattern.
</p><p>
However the <tt>private</tt> field of <tt>struct seq_file</tt> is used by
<a href="http://lxr.linux.no/#linux+v2.6.39/net/sunrpc/svc_xprt.c#L1239"><tt>svc_pool_stats_open()</tt></a>
in a subtly but importantly different way.
In this case the extra data needed is just a single pointer.
So rather than allocating a local data structure to refer to from
the <tt>private</tt> field, <tt>svc_pool_stats_open</tt> simply stores that pointer
directly in the <tt>private</tt> field itself.
This certainly seems like a sensible optimization - performing an allocation to
store a single pointer would be a waste - but it highlights exactly the source
of confusion that was suggested earlier: that when you look at a void
pointer you don't really know what is it pointing at, or why.
</p><p>
To make it a bit clearer what is happening here, it is helpful to imagine
"<tt>void *private</tt>" as being like a union of every different possible
pointer type.  If the value that needs to be stored is a pointer, it can be
stored in this union following the "unions for data inheritance" pattern.  If the
value is not a single pointer, then it gets stored in allocated space following
the "void pointers for data inheritance" pattern.

Thus when we see a void pointer being used it may not be obvious whether it is
being used to <b>point to</b> an extension structure for data inheritance, or being
used <b>as</b> an extension for data inheritance (or being used as something else
altogether).
</p><p>
To highlight this issue from a slightly different perspective it is instructive
to examine
<a href="http://lxr.linux.no/#linux+v2.6.39/include/media/v4l2-subdev.h#L490"><tt>struct v4l2_subdev</tt></a>
which represents a sub-device in a video4linux device, such as a sensor or
camera controller within a webcam.
According to the (rather helpful)
<a href="http://lxr.linux.no/#linux+v2.6.39/Documentation/video4linux/v4l2-framework.txt#L79">documentation</a>
it is expected that this structure will normally be embedded in a larger
structure which contains extra state.  However this structure still has not just one
but two void pointers, both with names suggesting that they are for private use
by subtypes:
</p>
<pre>
	/* pointer to private data */
	void *dev_priv;
	void *host_priv;
</pre>
<p>
It is common that a v4l sub-device (a sensor, usually) will be realized by,
for example, an I2C 
device (much as a block device which stores your filesystem might be realized
by an ATA or SCSI device).  To allow for this common occurrence,
<tt>struct v4l2_subdev</tt> provides a void pointer (<tt>dev_priv</tt>), so
that the driver itself
doesn't need to define a more specific pointer in the larger
structure which <tt>struct v4l2_subdev</tt> would be embedded in.

<tt>host_priv</tt> is intended to point back to a "parent" device such as a
controller which acquires video data from the sensor.  Of the three drivers
which use this field, <a
href="http://lxr.linux.no/#linux+v2.6.39/drivers/media/video/omap3isp/isp.c#L1751">one</a>
appears to follow that intention while the <a
href="http://lxr.linux.no/#linux+v2.6.39/drivers/media/video/pxa_camera.c#L1276">other</a>
<a
href="http://lxr.linux.no/#linux+v2.6.39/drivers/media/video/sh_mobile_ceu_camera.c#L904">two</a>
use it to point to an allocated extension structure. So both of these
pointers are intended to be used following the "unions for data
inheritance" pattern, where a void pointer is playing the role of a union
of many other pointer types, but they are not always used that way.
</p><p>
It is not immediately clear that defining this void pointer in case it is
useful is actually a valuable service to provide given that the device
driver could easily enough define its own (type safe) pointer in its extension
structure.
What is clear is that an apparently "private" void pointer can be intended for various qualitatively different 
uses and, as we have seen in two different circumstances, they may not be used exactly as expected. 

</p><p>
In short, recognizing the "data inheritance through void pointers" pattern is
not easy.  A fairly deep examination of the code is needed to determine the
exact purpose and usage of void pointers.
</p>
<h4>A diversion into <tt>struct page</tt></h4>
<p>
Before we leave unions and void pointers behind a look at
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/mm_types.h#L34"><tt>struct
page</tt></a>
may be interesting.  This structure uses both of these patterns, though they
are hidden somewhat due to historical baggage.  This example is particularly
instructive because it is one case where struct embedding simply is not an option.
</p><p>
In Linux memory is divided into pages, and these pages are put to a
variety of different uses.  Some are in the "page cache" used to store the
contents of files.  Some are "anonymous pages" holding data used by
applications. Some are used as "slabs" and divided into pieces to answer
<tt>kmalloc()</tt> requests.  Others are
simply part of a multi-page allocation or maybe are on a free list
waiting to be used.
Each of these different use cases could be seen as a subtype of the
general class of "page", and in most cases need some dedicated fields in
<tt>struct page</tt>,
such as a <tt>struct address_space</tt> pointer and <tt>index</tt>
when used in the page cache, or <tt>struct kmem_cache</tt> and
<tt>freelist</tt> pointers when used as a slab.
</p><p>
Each page always has the same <tt>struct page</tt> describing it, so if the
effective type of the page is to change - as it must as the demands for
different uses of memory change over time -  the type of the <tt>struct page</tt>
must change within the lifetime of that structure.  While many type systems are
designed assuming that the type of an object is immutable, we find here that
the kernel has a very real need for type mutability.  Both unions and void pointers
allow types to change and as noted, <tt>struct page</tt> uses both.
</p><p>
At the first level of subtyping there are only a small number of different
subtypes as listed above; these are all known to the core memory management
code, so a union would be ideal here.  Unfortunately <tt>struct page</tt> has three
unions with fields for some subtypes spread over all three, thus hiding the
real structure somewhat.
</p><p>
When the primary subtype in use has the page being used in the page cache, the
particular <tt>address_space</tt> that it belongs to may want to extend the
data structure further.  For this purpose there is a <tt>private</tt> field
that can be used.  However it is not a void pointer but is an <tt>unsigned
long</tt>.
Many places in the kernel assume an <tt>unsigned long</tt> and a <tt>void&nbsp;*</tt>
are the same size and this is one of them.  Most users of this field actually
store a pointer here and have to cast it back and forth.  The "buffer_head"
library provides macros
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/buffer_head.h#L239"><tt>attach_page_buffers</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/buffer_head.h#L132"><tt>page_buffers</tt></a>
to set and get this field.
</p><p>
So while <tt>struct page</tt> is not the most elegant example, it is an
informative example of a case where unions and void pointers are the only
option for providing data inheritance.
</p>
<h4>The details of structure embedding</h4>
<p>
Where structure embedding can be used, and where the list of possible subtypes
is not known in advance, it seems to be increasingly the preferred choice.
To gain a full understanding of it we will again need to explore a little bit
further than inodes and contrast data inheritance with other uses of structure
embedding.
</p><p>
There are essentially three uses for structure embedding - three reasons for
including a structure within another structure.  Sometimes there is nothing
particularly interesting going on.  Data items are collected together into
structures and structures within structures simply to highlight the closeness
of the relationships between the different items.  In this case the address of
the embedded structure is rarely taken, and it is never mapped back to
the containing structure using <tt>container_of()</tt>.
</p><p>
The second use is the data inheritance embedding that we have already
discussed.  The third is like it but importantly different.  This third use is
typified by  <tt>struct list_head</tt> and other structs used as an
<a href="/Articles/336255/">embedded anchor</a>
when creating abstract data types.
</p><p>
The use of an embedded anchor like <tt>struct list_head</tt> can be seen as a
style of inheritance as the structure containing it "is-a" member of a list
by virtue of inheriting from <tt>struct list_head</tt>.  However it is not a
strict subtype as a single object can have several <tt>struct list_head</tt>s
embedded - <tt>struct inode</tt> has six (if we include the
similar <tt>hlist_node</tt>).  So it is probably best to think of this sort of
embedding more like a "mixin" style of inheritance.   The <tt>struct
list_head</tt> provides a service - that of being included in a list - that can
be mixed-in to other objects, an arbitrary number of times.
</p><p>
A key aspect of data inheritance structure embedding that differentiates it from
each of the other two is the existence of a reference counter in the inner-most
structure.  This is an observation that is tied directly to the fact that the
Linux kernel uses reference counting as the primary means of lifetime
management and so would not be shared by systems that used, for example,
garbage collection to manage lifetimes.
</p><p>
In Linux, every object with an independent existence will have a
reference counter, sometimes a simple <tt>atomic_t</tt> or even
an <tt>int</tt>, though often a more explicit
<a href="/Articles/336224/"><tt>struct kref</tt></a>.
When an object is created using several levels of inheritance the reference
counter could be buried quite deeply.

For example a
<tt><a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/usb.h#L426">struct usb_device</a></tt>
embeds a
<tt><a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/device.h#L404">struct device</a></tt>
which embeds
<tt><a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/kobject.h#L60">struct kobject</a></tt>
which has a
<tt><a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/kref.h#L20">struct kref</a></tt>.
So <tt>usb_device</tt> (which might in turn be embedded in a structure for some
specific device) does have a reference counter, but it is contained several
levels down in the nest of structure embedding.

This contrasts quite nicely with a <tt>list_head</tt> and similar structures.
These have no reference counter, have no independent existence and simply
provide a service to other data structures.
</p><p>
Though it seems obvious when put this way, it is useful to remember that a
single object cannot have two reference counters - at least not two lifetime
reference counters (It is fine to have two counters like <tt>s_active</tt>
and <tt>s_count</tt> in <tt>struct super_block</tt> which count different
things).
This means that multiple inheritance in the "data inheritance" style is not
possible.  The only form of multiple inheritance that can work is the mixin
style used by <tt>list_head</tt> as mentioned above.
</p><p>
It also means that, when designing a data structure, it is important to think
about lifetime issues and whether this data structure should have its own
reference counter or whether it should depend on something else for its
lifetime management.  That is, whether it is an object in its own right, or
simply a service provided to other objects.  These issues are not really new
and apply equally to void pointer inheritance.  However an important difference
with void pointers is that it is relatively easy to change your mind later and
switch an extension structure to be a fully independent object.  Structure
embedding requires the discipline of thinking clearly about the problem up
front and making the right decision early - a discipline that is worth
encouraging.
</p><p>
The other key telltale for data inheritance structure embedding is the set of rules
for allocating and initializing new instances of a structure, as has already
been hinted at.
When union or void pointer inheritance is used the main structure is usually
allocated and initialized by common code (the mid-layer) and then a device
specific <tt>open()</tt> or <tt>create()</tt> function is called which can
optionally allocate and initialize any extension object.
By contrast when structure embedding is used the structure needs to be
allocated by the lowest level device driver which then initializes its own
fields and calls in to common code to initialize the common fields.
</p><p>
Continuing the <tt>struct inode</tt> example from above which has an
<tt>alloc_inode()</tt> method in the super_block to request allocation, we find
that initialization is provided for with
<a href="http://lxr.linux.no/#linux+v2.6.39/fs/inode.c#L342"><tt>inode_init_once()</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/fs/inode.c#L185"><tt>inode_init_always()</tt></a>
support functions.  The first of these is used when the previous use of a piece
of memory is unknown, the second is sufficient by itself when we know that the
memory was previously used for some other inode.
We see this same pattern of an initializer function separate from allocation in
<a href="http://lxr.linux.no/#linux+v2.6.39/lib/kobject.c#L270"><tt>kobject_init()</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/lib/kref.c#L22"><tt>kref_init()</tt></a>,
and
<a href="http://lxr.linux.no/#linux+v2.6.39/drivers/base/core.c#L587"><tt>device_initialize()</tt></a>.
</p><p>
So apart from the obvious embedding of structures, the pattern of "data
inheritance through structure embedding" can be recognized by the presence of a
reference counter in the innermost structure, by the delegation of structure
allocation to the final user of the structure, and by the provision of
initializing functions which initialize a previously allocated structure.
</p>
<h3>Conclusion</h3>
<p>
In exploring the use of method dispatch (last week) and data inheritance (this
week) in the
Linux kernel we find that while some patterns seem to dominate they are
by no means universal.  While almost all data inheritance could be
implemented using structure embedding, unions provide real value in a
few specific cases.  Similarly while simple vtables are common, mixin
vtables are very important and the ability to delegate methods to a
related object can be valuable.
</p><p>
We also find that there are patterns in use with little to recommend
them.  Using void pointers for inheritance may have an initial
simplicity, but causes longer term wastage, can cause confusion, and could
nearly always be replaced by embedded inheritance.  Using NULL pointers to indicate
default behavior is similarly a poor choice - when the default is
important there are better ways to provide for it.
</p><p>
But maybe the most valuable lesson is that the Linux kernel is not only a
useful program to run, it is also a useful document to study.  Such study can
find elegant practical solutions to real problems, and some less elegant
solutions.  The willing student can pursue the former to help improve their mind,
and pursue the latter to help improve the kernel itself.
With that in mind, the following exercises might be of interest to some.
</p>
<h4>Exercises</h4>
<ol>
<li><p> As inodes now use structure embedding for inheritance, void
  pointers should not be necessary.  Examine the consequences and
  wisdom of removing "i_private" from "struct inode".</p>

<li><p> Rearrange the three unions in <tt>struct page</tt> to just one
  union so that the enumeration of different subtypes is more explicit.
  </p>

<li><p> As was noted in the text, <tt>struct seq_file</tt> can be extended both
  through "void pointer" and a limited form of "union" data inheritance.
  Explain how <tt>seq_open_private()</tt> allows this structure to also be extended
  through "embedded structure" data inheritance and give an example by
  converting one usage in the kernel from "void pointer" to "embedded
  structure".
  Consider submitting a patch if this appears to be an improvement.
  Contrast this implementation of embedded structure inheritance
  with the mechanism used for inodes.
  </p>

<li><p>Though subtyping is widely used in the kernel, it is not uncommon
  for a object to contain fields that not all users are interested
  in.  This can indicate that more fine grained subtyping is possible.
  As very many completely different things can be represented by a
  "file descriptor", it is likely that <tt>struct file</tt> could be a
  candidate for further subtyping.
  </p><p>
  Identify the smallest set of fields that could serve as a generic
  <tt>struct file</tt> and explore the implications of embedding that in
  different structures to implement regular files, socket files, event
  files, and other file types.  Exploring more general use of the
  proposed
  <a href="https://lkml.org/lkml/2011/5/17/182"><tt>open()</tt></a>
  method for inodes might help here.
  </p>

<li><p> Identify an "object-oriented" language which has an object model
  that would meet all the needs of the Linux kernel as identified
  in these two articles.
  </p>
</ol><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-Patterns">Development model/Patterns</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/446317/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor446530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2011 21:57 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/446530/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is another variation on structure embedding I have used in the past, which is to have the subtypes' data appended directly to the structure containing the supertype, with appropriate macros / functions to map from one offset to the other and to do appropriate casting. This gives you the advantages of structure-embedding subtyping without costing a dereference or an extra allocation, but has disadvantages, notably that you have to ensure correct alignmewnt of the trailing subtype field (easy enough) and that sizeof() no longer works. So this is only really usable when the datatype is itself hidden and only used within one translation unit, such that it is the only thing that can take the sizeof this structure, and can add an appropriate size for the subtype in use whenever a sizeof is needed.<br>
<p>
Combine this with an ADT pointer and you have something pretty much identical in representation to C++ classes. The code is... a good bit hairier than C++ classes though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446534"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2011 22:29 UTC (Tue)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446534/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      I don't think any macros are really needed, just something like this:

<pre>
struct base {
int a;
int b;
char end[0] __attribute__((aligned(4)));
};

struct derived1 {
int a;
};

struct derived2 {
char b;
};
</pre>

Then you have stuff like this:
<pre>
void foo(struct base *b) {
    if (type == DERIVED1) {
        struct derived1 *d = (struct derived1*)b->end;
        ...
    }
}
</pre>

It isn't as nice as C++, but it's ok.<p>

Flexible array members were standardized in C99. Every compiler can do it, but I don't know if the syntax for forcing alignment is standardized yet.
      
          <div class="CommentReplyButton">
            <form action="/Articles/446534/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446559"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 4:52 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/446559/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <BLOCkQUOTE><I>I don't know if the syntax for forcing alignment is standardized yet. </I></BLOCKQUOTE>
<P>What if you just made it an array of "double" or "long double"?  Or, an array of a union of all of the "large" types, so you're guaranteed to get the most restrictively aligned type on the platform?
</P>
<PRE>
typedef union
{
    long long   ll;
    double      d;
    long double ld;
    void       *vp;
    void      (*fp)(void);  /* function pointer */
} align_u;
</PRE>
<P>Then replace<TT> char end[0] __attribute__((aligned(4))); </TT>with<TT> align_u end[0];</TT>.  Wouldn't that work?</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/446559/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 13:16 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/446585/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That does indeed work and is exactly what I did. A hallowed ancient trick: I don't know *how* long ago I first saw it. Decades back.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor446584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 13:14 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/446584/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah yes. You have access to flexible array members and can assume that you're using GCC. Alas, when I perpetrated this trick I could assume neither of these, so needed a suitable union as a final member to ensure correct alignment.<br>
<p>
The macros are just to make things less horrendously unreadable. :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor446560"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 4:55 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/446560/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <P>FWIW, this sort of hack is something Dennis Ritchie once referred to as <A rel="nofollow" HREF="http://c-faq.com/struct/structhack.html">"unwarranted chumminess with the implementation."</A>  I always found that phrase amusing.  :-)</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/446560/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446568"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 9:48 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/446568/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The outcome is also notable.<br>
<p>
Everybody did this, the implementations all allowed it, but the standard said you couldn't rely upon it.<br>
<p>
So they fixed the standard, introducing in C99 a way to explicitly ask for what everyone wanted here, and adding text insisting that implementations do what the developers expect in that case.<br>
<p>
Not every case can or should be treated this way, but it's a useful option. When the conflict is between reality and the standard, consider altering the standard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446568/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 10:07 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/446569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Oh, I agree.  C is quite a pragmatic language, drawing its pragmatism from many directions.  The fact that its compiler directive for turning on/off various vendor-defined features is named<TT> #pragma </TT>I think says a lot.</P>
<P>C99 also cleared up the meaning of<TT> const </TT>as it qualified pointer arguments to functions, offering up the much better suited<TT> restrict </TT>qualifier in its place.  That was a case where the cookie crumbled a bit differently, but still fit with the general pragmatism of the C working group and C language.  I can't really complain.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/446569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor446575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 11:06 UTC (Wed)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/446575/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C99 could have added a warning when a structure is created (and not a structure pointer allocated), so that this is catched:<br>
$ cat tmp.c<br>
struct str { unsigned len; char data[]; };<br>
void fct1(struct str *ptr);<br>
void fct2(struct str *initial) {<br>
    struct str copy = *initial;<br>
    fct1(&amp;copy);<br>
    }<br>
$ gcc -Wall -std=c99 -O2 -c tmp.c<br>
$ <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446577"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 11:14 UTC (Wed)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/446577/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it is the compiler which adds warnings, not the standard. So, you could report this as a bug to the gcc developers and they could add a warning, even if the standard thinks this is valid.<br>
<p>
That is, if the warning does not exist already. -Wall does not enable all warnings. Did you try -Wextra and check the manual for the warnings neither option enables?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446577/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446582"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 13:03 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/446582/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The standard requires some diagnostics, GCC complies with the standard in this regard when in 'pedantic' mode (of course you must also tell GCC which standard you intended to comply with to get anything useful)<br>
<p>
But yes, a useful compiler will definitely want to offer additional diagnostic information beyond that called out in the standard, and it may find that some diagnostics called for by the standard are just unhelpful, conflict with real world practice or obstruct a cool but non-standard feature they wish to offer, and so disable them at least by default.<br>
<p>
The case outlined above doesn't strike me as worth being called out in the standard, but I can see that at least some similar cases could be usefully mentioned by the compiler, like unadorned occurrences of the assignment operator in a boolean context. You _might_ mean what you say, but you probably don't, and if you really do, you could say it more clearly for the benefit of some future maintenance programmer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446582/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 15:34 UTC (Thu)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/446848/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The standard does *not* require any warnings. The diagnostics it requires are for violations of syntax rules or constraints, not for warning about questionable constructs.<br>
<p>
The standard says something works or it doesn't, it never says "this is ok but the implementation should warn about it", so cesarb is quite right, C99 could not have added a warning, and requests for such a warning should go to compiler implementations not the standard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2011 3:40 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/446867/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>That's largely true.  I did find at least one place (and there are likely others) where the standard <I>suggests</I> a warning.  It doesn't mandate it though, in Â§6.4.4.2:</P>
<BLOCKQUOTE><I><B>Recommended practice</B><BR><BR>
The implementation should produce a diagnostic message if a hexadecimal constant cannot be represented exactly in its evaluation format; the implementation should then proceed with the translation of the program.
</I></BLOCKQUOTE>
<P>If "produc[ing] a diagnostic" and "proceed[ing] with the translation of the program" doesn't constitute a warning, I don't know what does.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/446867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor446607"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 15:15 UTC (Wed)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/446607/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For this GCC version:<br>
$ gcc --version<br>
gcc (Ubuntu 4.4.3-4ubuntu5) 4.4.3<br>
<p>
I get no warnings:<br>
$ gcc -Wall -Wextra -pedantic -Wvla -std=c99 -O2 -c tmp.c<br>
$ <br>
<p>
But I never use this construct and I already have my own list of bugs for GCC in bugzillia.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446607/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor446586"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 13:21 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/446586/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh no. What Ritchie described *was* unwarranted chumminess with the implementation, because you're declaring a short array then allocating more space and walking off the end of it. That *is* forbidden by the Standard. But allocating enough space for one structure appended to the end of another one, then doing pointer addition and a typecast? That's allowed: you're not accessing off the end of one object at all, you're accessing the object you cast to.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446586/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor446572"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 10:45 UTC (Wed)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/446572/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Many places in the kernel assume an unsigned long and a void * are the same size and this is one of them.</font><br>
<p>
One should be using (u)intptr_t for these things instead, I suppose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446572/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 11:10 UTC (Wed)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/446574/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Linux kernel runs on two types of processors: 32-bit processors where both pointers and unsigned long are 32-bit, and 64-bit processors where both pointers and unsigned long are 64-bit.<br>
<p>
I do not think the kernel developers will bother until they decide to port to a processor where pointers are 128-bit.<br>
<p>
For userspace programs, it is different since at least one unnamed operating system has 64-bit pointers but only 32-bit unsigned long when running on a 64-bit processor.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 20:00 UTC (Wed)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/446680/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There was recently an attempt to port the kernel to a 48 bit pointer architecture that uses 16 bit segment registers with 32 bit offsets. The replies from kernel developers towards this were between "no way" and "as long as you fix all the bugs and make the code look prettier in the process."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor447219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2011 17:33 UTC (Sun)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/447219/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which architecture has that fascinating addressing scheme?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor447970"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2011 16:01 UTC (Thu)
                               by <b>siride</b> (guest, #62756)
                              [<a href="/Articles/447970/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
i386 of course<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447970/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor446777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 8:35 UTC (Thu)
                               by <b>janneke</b> (guest, #15012)
                              [<a href="/Articles/446777/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>
Thanks for your insightful article.
</p>

<p>
Pleasantly surprised as I was by the five Exercises you provide
at the end, I had been anticipating a question (if not a possible
answer itself in part 3) like
</p>

<blockquote>
5. Construct a miminal set of macros that implement the "object-oriented" boilerplating which has an object model that would meet all the needs of the Linux kernel as identified in these two articles.
</blockquote>

<p>
with your question #5 as an optional bonus
</p>

<blockquote>
[extra points]<br>6. Identify an "object-oriented" language which has an object model that would meet all the needs of the Linux kernel as identified in these two articles.
</blockquote>

<p>
What am I missing?
<p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 23:32 UTC (Thu)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446943/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you're missing the definition of "needed."  The articles did a good job of enumerating various object models in use as well as critiquing them.  Just because the kernel does things the way it does today does not mean it is the best way or even a close-to-best way.<br>
<p>
Any object model can be implemented in any sufficiently capable language.  The key differences are in what the languages support "natively."<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor447233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2011 3:24 UTC (Mon)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/447233/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The answer to Niel's leading question is clearly "C++", which invites the additional exercise "how practical would that be?".<br>
<p>
My answer: I'm not sure. The i_op pointer would become an opaque method table pointer, however it is clearly impractical to rewrite every filesystem in C++, so C code would require require a variant definition of struct inode with an explicit definition of the opaque pointer, and the opaque vtable it references would need an explicit definition available to C code. These structures are pretty simple, it might be possible to emulate them in C.<br>
<p>
I wrote a little program to test this theory. I defined a simple class with an integer field and a virtual function to increment that field. I know the vtable pointer is stored in the first word of a virtual object and by inspection I found that the first word of the vtable points at my member function. And I know that c++ passes the address of an object as a hidden parameter to any class member function. I stepped through a normal call to my virtual method to verify nothing mysterious is going on. Then I added some casts to retrieve the vtable pointer from an object, read the member address out of the vtable, and call that address as a function with one parameter, the object address. Aha, it works.<br>
<p>
Whether this is a good idea is another question. This behavior is compiler dependent, but on the other hand there aren't a lot of compilers in the running when it comes to Linux kernel. It could probably be made to work. Not that I would seriously suggest rewriting the VFS in C++. Perhaps a device driver.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor449608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 29, 2011 3:57 UTC (Wed)
                               by <b>xoddam</b> (guest, #2322)
                              [<a href="/Articles/449608/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Now that's what I'd call "unwarranted chumminess with the implementation". :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/449608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor447190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2011 23:39 UTC (Sun)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/447190/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wow Niel, thanks for the warm and fuzzies. I didn't realize I was doing polymorphic design at the time I cooked up that patch, I actually did not have a clue about object oriented anything, but I was troubled by three aspects of the old scheme:<br>
<p>
  * In order to define the union, fs.h used to include the headers of nearly all filesystems, breaking the VFS/filesystem layering and forcing a large part of the kernel to be recompiled after changing any header of those filesystems.<br>
<p>
  * Every inode had to be as big as the largest type of inode in the system, wasting bytes.<br>
<p>
  * Using the catch-all void pointer requires double allocation as well as wasting bytes.<br>
<p>
Since then I took the time to gain experience in object oriented design with C++, which is actually able to compile code in the pattern I developed here but with proper type safety and without kludges like the inode access macros. One day I hope Linus will actually take the time to learn C++ and gain a deep understanding of how badly faking these ideas in C really hurts maintainability, and how little substance there is to the usual arguments in support of the ban.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor451205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Refcounting and multiple inheritance</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2011 19:51 UTC (Mon)
                               by <b>Auders</b> (guest, #53318)
                              [<a href="/Articles/451205/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Though it seems obvious when put this way, it is useful to remember that a single object cannot have two reference counters - at least not two lifetime reference counters (It is fine to have two counters like s_active and s_count in struct super_block which count different things). This means that multiple inheritance in the "data inheritance" style is not possible. The only form of multiple inheritance that can work is the  mixin style used by list_head as mentioned above.</font><br>
<p>
The standard CPython implementation of Python uses reference counting, and yet it supports multiple inheritance. How is this possible?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/451205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor451229"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Refcounting and multiple inheritance</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2011 3:29 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/451229/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The standard CPython implementation of Python uses reference counting, and yet it supports multiple inheritance. How is this possible?</font><br>
<p>
A good question.  I suspect that when you find the answer you will have a deeper understanding of inheritance.<br>
<p>
I am not at all familiar with the CPython implementation or particularly familiar with multiple inheritance in Python so I cannot give a definitive answer.   However as I noted in the introduction, "inheritance" does not seem to be a very well defined term, and "multiple inheritance" even less so.  So the apparent contradiction could just be a confusion in the use of terms.<br>
<p>
The short answer is simply that whatever CPython allows one class to inherit from multiple other classes, it cannot include the reference counters.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/451229/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor920908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2023 14:21 UTC (Tue)
                               by <b>______A-1S____</b> (guest, #163294)
                              [<a href="/Articles/920908/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I understand the negatives of using void pointers, but how can you make a function type safe and yet generic?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor921796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2023 21:31 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/921796/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I understand the negatives of using void pointers, but how can you make a function type safe and yet generic?</span><br>
<p>
My starting point is that you cannot make functions "type safe" - only ever "type safer".<br>
<p>
A "type" is really just a set of values.  The "type" that a function can accept is the set of values that the programmer expects to be passed to the function.  In trivial cases the type system for the programming language can completely capture the programmer's expectations, but it general it cannot  For example, data structures often have a life-cycle.  They start out uninitialised, they then become partly initialised, then various other stages can happen before they are finally discarded.  Various functions might expect only data structures at some particular place in the life cycle.  Languages such as Rust can capture more of this than C, but they cannot capture everything that the programmer has in mind.<br>
<p>
So it isn't fair to ask "how can you make a function type safe" but it is perfectly reasonable to ask "how can you make a function MORE type safe".  One way is to use the "embedded anchor" pattern as described in the article, rather than using void pointers.  There are other approaches such as using macros and the "typeof()" operator.  Have a look in include/linux/minmax.h in the Linux kernel source.  It provides min() and max() functions which are generic and type-safe if that the two operands must be of the same type, but it can be any integer type.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/921796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
