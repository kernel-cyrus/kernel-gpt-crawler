        <!DOCTYPE html>
        <html lang="en">
        <head><title>The state of the page in 2024 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/973565/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/973074/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/973565/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The state of the page in 2024</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>May 15, 2024</br>
           <hr>
<a href="/Articles/lsfmmbpf2024/">LSFMM+BPF</a>
</div>
The advent of the <a href="/Articles/849538/">folio</a> structure to
describe groups of pages has been one of the most fundamental
transformations within the kernel in recent years.  Since the folio
transition affects many subsystems, it is fitting that the subject was
covered at the beginning of the 2024 <a
href="https://events.linuxfoundation.org/lsfmmbpf/">Linux Storage,
Filesystem, Memory Management, and BPF Summit</a> in a joint session of the
storage, filesystem, and memory-management tracks.  Matthew Wilcox used the
session to review the work that has been done in this area and to discuss
what comes next.
<p>
The first step of this transition, he began, was moving much of the
information traditionally stored in the kernel's <tt>page</tt> structure
into folios instead, then converting users of <tt>struct page</tt> to use
the new structure.  The
initial goal was to provide a type-safe representation for <a
href="/Articles/619514/">compound pages</a>, but the scope has expanded
greatly since then.  That has led to a bit of ambiguity: what, exactly, is
a folio in current kernels?  For now, a folio is still defined as "the
first page of a compound page".
<p>

<a href="/Articles/973587/"><img
src="https://static.lwn.net/images/conf/2024/lsfmm/MatthewWilcox-sm.png" alt="[Matthew Wilcox]"
title="Matthew Wilcox" class="rthumb"></a>

By the end of the next phase, the plan is for <tt>struct page</tt>
to shrink down to a single, eight-byte memory descriptor, the bottom few
bits of which describe what type of page is being described.  The
descriptor itself will be specific to the page type; slab pages will have
different descriptors than anonymous folios or pages full of page-table
entries, for example.
<p>
Among other motivations, a key objective behind the move to descriptors is
reducing the size of the memory map — the large array of <tt>page</tt>
structures describing every physical page in the system.  Currently, the
memory-map overhead is, at 1.6% of the memory it describes, too high.  On
systems where virtualization is used, the memory map is also found in
guests, doubling the memory consumed by the memory-map.  By moving to
descriptors, that overhead can be reduced to 0.2% of memory, which can save
multiple gigabytes of memory on larger systems.
<p>
Getting there, though, requires moving more information into the
<tt>folio</tt> structure.  Along the way, concepts like the pin count for a
page can be clarified, cleaning up some longstanding problems in the
memory-management subsystem.  This move will, naturally, increase the size
of the <tt>folio</tt> structure, to a point where it will be larger than
<tt>struct page</tt>.  The advantage, though, is that only one
<tt>folio</tt> structure is needed for all of the base pages that make up
the folio.  For two-page folios, the total memory use is about the same;
for folios of four pages or more, the usage is reduced.  If the kernel is
caching the contents of a 1GB file, it currently needs
<strike>60MB</strike> 16MB of <tt>page</tt> structures.  If that caching is
done entirely with base pages, that overhead will increase to 23MB in the
future.  But, if four-page folios are used instead, it drops to 9MB total.
<p>
Some types of descriptors, including those <a
href="/Articles/881039/">for slab pages</a> and <a
href="/Articles/937839/">page-table entries</a>, have already been
introduced.  The page-table descriptors are quite a bit smaller than
folios, since there are a number of fields that are not needed.  For
example, these pages cannot be mapped into user space, so there is no need
for a mapping count.
<p>
Wilcox put up a plot showing how many times <tt>struct page</tt> and
<tt>struct folio</tt> are mentioned in the kernel since 2021.  On the order
of 30% of the <tt>page</tt> mentions have gone away over that time.  He
emphasized that the end goal is not to get rid of <tt>struct page</tt>
entirely; it will always have its uses.  Pages are, for example, the
granularity with which memory is mapped into user space.
<p>
Since <a href="/Articles/931794/">last year's update</a>, quite a lot of
work has happened within the memory-management subsystem.  Many kernel
subsystems have been converted to folios.  There is also now a reliable way
to determine whether a folio is part of hugetlbfs, the absence of which
turned out to be a bit of a surprising problem.  The adoption of <a
href="/Articles/937239/">large anonymous folios</a> has been a welcome
improvement.
<p>
The virtual filesystem layer has also seen a lot of folio-related work.
The <tt>sendpage()</tt> callback has been removed in favor of a better API.
The <a
href="https://docs.kernel.org/filesystems/fsverity.html">fs-verity</a>
subsystem now supports large folios.  The conversion of the <a
href="/Articles/930173/">buffer cache</a> is proceeding, but has run into a
surprise:  Wilcox had proceeded with the assumption that buffer heads are
always attached to folios, but it turns out that the ext4 filesystem
allocates slab memory and attaches <i>that</i> instead.  That usage isn't
wrong, Wilcox said, but he is "about to make it wrong" and does not want to
introduce bugs in the process.
<p>
Avoiding problems will require leaving some information in <tt>struct
page</tt> that might have otherwise come out.  In general, he said, he
would not have taken this direction with buffer heads had he known where
it would lead, but he does not want to back it out now.  All is well for
now, he said; the ext4 code is careful not to call any functions on
non-folio-backed buffer heads that might bring the system down.  But there
is nothing preventing that from happening in the future, and that is a bit
frightening.
<p>
The virtual filesystem layer is now allocating and using large folios
through the entire write path; this has led to a large performance
improvement.  Wilcox has also added an internal function, <a
href="https://elixir.bootlin.com/linux/v6.9/source/mm/filemap.c#L1489"><tt>folio_end_read()</tt></a>,
that he seemed rather proud of.  It sets the up-to-date bit, clears the
lock bit, checks for others waiting on the folio, and serves as a memory
barrier — all with a single instruction on x86 systems.  Various other
helpers have been added and callbacks updated.  There is also a new
writeback iterator that replaces the old callback-based interface; among
other things, this helps to recover some of the performance that was taken
away by Spectre mitigations.
<p>
<a href="/Articles/973569/"><img
src="https://static.lwn.net/images/conf/2024/lsfmm/fs-folio-table-sm.png" alt="[Filesystem folio
conversion table]" width=300 height=144 align="right" border=0></a>

With regard to individual filesystems, many have been converted to folios
over the last year.  Filesystems as a whole are being moved away from the
<tt>writepage()</tt> API; it was seen as harmful, so no folio version was
created.  The bcachefs filesystem can now handle large folios — something
that almost no other filesystems can do.  The old NTFS
filesystem was removed rather than being converted.  The "netfs" layer has
been created to support network filesystems.  Wilcox put up a chart showing
the status of many filesystems, showing that a lot of work remained to be
done for most.  "XFS is green", he told the assembled developers, "your
filesystem could be green too".
<p>
The next step for folios is to move the mapping and index fields out of
<tt>struct page</tt>.  These fields could create trouble in the filesystems
that do not yet support large folios, which is almost all of them.  Rather
than risk introducing bugs when those filesystems are converted, it is
better to get those fields out of the way now.  A number of page flags are
also being moved; flags like <tt>PageDirty</tt> and <tt>PageReferenced</tt>
refer to the folio as a whole rather than to individual pages within it,
and thus should be kept there.  There are plans to replace the
<tt>write_begin()</tt> and <tt>write_end()</tt> address-space operations,
which still use bare pages.
<p>
Beyond that, there is still the task of converting a lot of filesystems,
many of which are "pseudo-maintained" at best.  The hugetlbfs subsystem
needs to be modernized.  The shmem and tmpfs in-memory filesystems should
be enhanced to use intermediate-size large folios.  There is also a desire
to eliminate all higher-order memory allocations that do <i>not</i> use
compound pages, and thus cannot be immediately changed over to folios; the
crypto layer has a lot of those allocations.
<p>
Then, there is <a href="/Articles/931943/">the "phyr" concept</a>.  A phyr
is meant to refer to a <i>physical</i> range of pages, and is "what needs
to happen to the block layer".  That will allow block I/O operations to
work directly on physical pages, eliminating the need for the memory map to
cover all of physical memory.
<p>
It seems that there will be a need for a <tt>khugepaged</tt> kernel thread
that will collapse mid-size folios into larger ones.  Other types of memory
need to have special-purpose memory descriptors created for them.  Then
there is the <a
href="https://docs.kernel.org/dev-tools/kmsan.html">KMSAN</a>
kernel-memory sanitizer, which hasn't really even been thought about.
KMSAN adds its own special bits to <tt>struct page</tt>, a usage that will
need to be rethought for the folio-based future.
<p>
An important task is adding large-folio support to more filesystems.  In
the conversions that Wilcox has done, he has avoided adding that support
except in the case of XFS.  It is not an easy job and needs expertise in
the specific filesystem type.  But, as the overhead for single-page folios
grows, the need to use larger folios will grow with it.  Large folios also
help to reduce the size of the memory-management subsystem's LRU list,
making reclaim more efficient.
<p>
Ted Ts'o asked how important this conversion is for little-used filesystems;
does VFAT need to be converted?  Wilcox answered that it should be done for
any filesystem where somebody cares about performance.  Dave Chinner added
that any filesystem that works on an NVMe solid-state device will need
large folios to perform well.  Wilcox closed by saying that switching to
large folios makes compiling the kernel 5% faster, and is also needed to
support other desired features, so the developers in the room should want
to do the conversion sooner rather than later.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Folios">Memory management/Folios</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2024">Storage, Filesystem, Memory-Management and BPF Summit/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/973565/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor973771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2024 15:05 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/973771/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’d be curious to hear about the size of the single threaded read/write performance improvements folks have observed on full conversion to large folios - both for buffered and direct IO.  I’d expect it to be significant in both cases but I’m not sure how much.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor973781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2024 17:39 UTC (Wed)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/973781/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm somehow amused they'd ask about VFAT for "do we need to convert this?" considering it's just about the most-used filesystem on any remotely modern system running Linux since it underpins UEFI support.<br>
<p>
I get it, it's not performance critical so the 'benefits' are a wash, but calling it "little used" seems like they forgot for a moment how it got a second lease on life in recent years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor973805"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2024 22:34 UTC (Wed)
                               by <b>Kamilion</b> (subscriber, #42576)
                              [<a href="/Articles/973805/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Eh? I thought those were supposed to be of type exfat in practice now? It's been a while, but so far as I recall, vfat (the driver) handles fat12b and fat16, and I'm not sure which of the two are used for fat32...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973805/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor973808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2024 22:45 UTC (Wed)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/973808/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, fat32 is handled by vfat driver as well. exfat is a different non-compatible beast altogether that used to be not be well supported in open source Linux (nor UEFI implementations) for a long time due to patents.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor973816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2024 0:23 UTC (Thu)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/973816/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup, it's a common oversight.<br>
<p>
I'm unaware of any UEFI firmware on x86 at least that supports exFAT, broadly speaking it's only ever been supported for 32GB and larger volumes because it started as literally the "64GB and larger flash card" option, and the UEFI "ESP" partition is rarely more than 500MB.<br>
<p>
In theory it can be used for that, but it'd be using unusually small cluster sizes which are almost never seen in the wild so vendors never test against them because they're not required to be supported.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor973825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2024 4:08 UTC (Thu)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/973825/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Funnily, VFAT isn't on my list. That's because VFAT and MSDOS both use the same address_space_operations, so I just counted it as one (FAT).<br>
<p>
I think it would make a lovely project for someone to convert the FAT FS from buffer_heads to iomap. That way you'd get large folio support basically for free.<br>
<p>
It's probably even a useful thing to do. The storage vendors are threatening us with 16KiB sector sizes and while the block layer should support this nicely, I will have a bit more confidence in the iomap layer. I hope to finish reviewing the bs&gt;PS patches tomorrow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor973834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2024 7:45 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/973834/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the other thing about vFAT is the entire UEFI filesystem would probably fit into a single large page (I might be exaggerating slightly here, but only just :-) so even if it were performance critical there might be pretty much no benefits to be had ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor973940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2024 18:30 UTC (Thu)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/973940/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My UEFI System Partition contains 160 megs of stuff, and no cruft. But of course, if the single page is large enough...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/973940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor973944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2024 18:44 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/973944/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>My laptop uses 1 GiB pages for most of the direct map of physical memory. Your UEFI System Partition would fit in one page :-)


      
          <div class="CommentReplyButton">
            <form action="/Articles/973944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor974272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2024 17:24 UTC (Sun)
                               by <b>rharjani</b> (subscriber, #87278)
                              [<a href="/Articles/974272/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;&gt; If the kernel is caching the contents of a 1GB file, it currently needs 60MB of page structures. If that caching is done entirely with base pages, that overhead will increase by 23MB in the future. But, if four-page folios are used instead, it drops to 9MB total.</span><br>
<p>
I didn't get the calculation here. If 1GB file uses struct page to cache the file contents today, isn't it 16MB in total (1G/ 64bytes) (since sizeof a page structure is 64bytes).  So where does 60MB came from?<br>
<p>
Continuing to the next line.. I think +23MB is assuming the size of struct folio will grow (which is also something not very clear to me as how exactly?). So "+23MB" will depend upon how much the struct folio will grow. Looks like that part of information is missed?<br>
And that info about increase in size of struct folio may clarify how order-2 (four-page) folios will drop the use to 9MB total?<br>
<p>
It will be helpful to get the answers to above questions please. Or maybe I will wait for the youtube video to come and try to figure out.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/974272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor974277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The state of the page in 2024</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2024 18:50 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/974277/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My slides say 16MB. I should put those on a webpage; our humble editor has a copy in his inbox, but I guess I spoke unclearly, and the notes weren't checked against the slides for that number.<br>
<p>
To re-run the calculation, 1GiB/4KiB * 64 is 16MiB. 1GiB/4KiB * 88 is 23MiB. 1GiB/16KiB * 144 is 9.2MiB.<br>
<p>
To explain those numbers, we need 8bytes/page for the memdesc. An order-0 folio is estimated to be 80 bytes (need to include pfn and needs to be a multiple of 16 bytes). A higher order folio will probably be 112 bytes for extra mapcount information and the deferred split list. Plus four 8byte memdescs gets us to 144 bytes.<br>
<p>
Hope that's helpful. Let me know if I skipped a necessary step.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/974277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
