        <!DOCTYPE html>
        <html lang="en">
        <head><title>Shadow stacks for user space [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/885220/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/885117/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/885220/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Shadow stacks for user space</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 21, 2022</br>
           </div>
The call stack is a favorite target for attackers attempting to compromise
a running process; if an attacker finds a way to overwrite a return address
on the stack, they can redirect control to code of their choosing, leading
to a situation best described as "game over".  As a result, a great deal of
effort has gone into protecting the stack.  One technique that offers
promise is a shadow stack; support for shadow stacks is thus duly showing up in
various processors.  Support for protecting user-space applications with
shadow stacks is taking a bit longer; it is currently under discussion
within the kernel community, but adding this feature is trickier than one
might think.  Among other things, these patches have been around for long
enough that they have developed some backward-compatibility problems of
their own.

<p>
<h4>Shadow-stack basics</h4>
<p>
Whenever one function calls another, information for the called function,
including any parameters  and the address to which the function should
return once it has done its work, is
pushed onto the call stack.  As the call chain deepens, the chain of return
addresses on the stack grows apace.  Normally, all works as intended, but
any corruption of the stack can cause one or more return addresses to be
overwritten; that, in turn, will cause execution to "return" to an
unintended location.  With luck, that will cause the application to crash;
if the corrupt data was deliberately placed there, instead, execution could
continue in a way that will cause worse things to happen.
<p>
Shadow stacks seek to mitigate this problem by creating a second copy of
the stack that (usually) only contains the return-address data.  Whenever a
function is called, the return address is pushed onto both the regular
stack and the shadow stack.  When that function returns, the return
addresses are popped off both stacks and compared; if they fail to match,
the system 
goes into red alert and (probably) kills the process involved.  Shadow
stacks can be implemented entirely in software; even if the shadow stack is
writable, it raises the bar for an attacker, who must now be able to
corrupt two areas of memory, one of which is at an arbitrary location.
Hardware support can make shadow stacks stronger, though.
<p>
Intel processors, among others, can provide that support.  If a shadow
stack has been set 
up (which is a privileged operation), the pushing of return addresses onto
that stack and comparison on function return are all done by the CPU
itself.  Meanwhile, the shadow stack is normally not writable by the
application (other than by way of the function-call and return
instructions), and thus not corruptible by an attacker.  The hardware also
requires the presence of a special "restore token" on the shadow stack itself that,
among other things, ensures that two processes cannot be sharing the same
shadow stack — a situation that, once again, would facilitate attacks.
<p>
<h4>Supporting user-space shadow stacks</h4>
<p>
The current version of the shadow-stack support patches has been <a
href="/ml/linux-kernel/20220130211838.8382-1-rick.p.edgecombe@intel.com/">posted
by Rick Edgecombe</a>; the bulk of the patches themselves were written by
Yu-cheng Yu, who has posted numerous earlier versions of this work.
Enabling this feature requires 35 non-trivial patches, and 
the problem is not entirely solved yet.  One might wonder why it is so
hard, since shadow stacks seem like a feature that most code could ignore
almost all of the time, but life is never so simple.
<p>
As might be expected, the kernel must contain the code to manage user-space
shadow stacks.  That includes enabling the feature at the processor level,
and handing it for each specific process.  Each process needs its own
shadow stack set up with a proper restore token, then the (privileged)
shadow-stack pointer register must be aimed at it.  Faults, both normal
page faults and things like integrity-violation traps, must be handled.
There is yet more information to be managed on context switches.  This is
all pretty normal stuff for a new feature of this sort.
<p>
The memory allocated for the shadow stack itself must be treated specially.
It belongs to user space, but user-space code must not normally be allowed
to write to it.  The processor must also recognize memory dedicated to
shadow stacks, so they must be marked specially in the page tables, and
that's where things get a little interesting.  There are a number of bits
set aside in each page-table entry (PTE) to describe the protections that apply
and various other types of status, but the x86 architecture does not
include a "this is a shadow-stack page" bit.  There <i>are</i> some PTE bits set
aside for the operating system's use; Linux does not use them all and could
have spared one for this purpose, but evidently certain other operating
systems have no spare PTE bits, so stealing one for this purpose would not be
welcome.
<p>
The solution that the hardware engineers arrived at might well be described
as a bit of a 
hack.  If a page's write-enable bit is clear (indicating that it cannot be
written to), but its dirty bit is set (indicating that it <i>has</i> been
written to), the CPU will conclude that the page in question is part of a
shadow stack.  This is a combination of settings that, in ordinary usage,
might not make sense, so it evidently seemed like fair game.
<p>
Unfortunately, Linux kernel developers came to a similar conclusion many
years ago, so Linux has its own interpretation for that combination of
PTE bits.  Specifically, that is how the kernel marks
copy-on-write pages.  The lack of write access will cause a trap should a
process attempt to write the page; the presence of the dirty bit then tells
the kernel to make a copy of the page and give the process write access to
it.  It all works well — until the CPU comes along and applies its own
interpretation to that bit combination.  So much of the patch set is
focused on grabbing one of those unused PTE bits for a new <tt>_PAGE_COW</tt>
flag and causing the memory-management code to use it.
<p>
Shadow stacks bring other complications as well, of course.  If a process
calls <a
href="https://man7.org/linux/man-pages/man2/clone.2.html"><tt>clone()</tt></a>,
a new shadow stack must be allocated for the child process; the kernel
handles this task automatically.  Signals, as
always, add complications of their own, since they already involve various
stack manipulations.  It gets worse if a process has set up an alternative
stack for signal handlers with <a
href="https://man7.org/linux/man-pages/man2/sigaltstack.2.html"><tt>sigaltstack()</tt></a>
— to the point that the current patch set does not handle that case at all.
From such details (and more), a long patch series is made.
<p>
<h4>ABI issues</h4>
<p>
The use of shadow stacks should be entirely transparent to most
applications; after all, developers rarely think about the
call stack in any case.  But there will always be applications that do tricky
things with their stacks, starting with multi-threaded programs that
explicitly manage the stack area for each thread.  Others may place their
own specially crafted <a
href="https://en.wikipedia.org/wiki/Thunk">thunks</a> onto the stack or
even more obscure things. 
Without special care, all of those applications will break if they are
suddenly set up with a shadow stack.  That sort of mass regression tends to
make security features unpopular, so various measures have been taken to
avoid it.
<p>
The carefully considered plan that emerged was to mark
applications (with a special property in the <tt>.note.gnu.property</tt>
ELF section) that are prepared to run with a shadow stack.  Applications
that do no stack trickery could simply be rebuilt and run with shadow
stacks thereafter.  For the more complicated cases, a set of <a
href="https://man7.org/linux/man-pages/man2/arch_prctl.2.html"><tt>arch_prctl()</tt></a>
operations was defined to enable the explicit manipulation of shadow
stacks.  The GNU C Library was enhanced to use these calls to configure the
environment properly on application startup, and the kernel would enable
shadow stacks whenever a suitably marked program was run.  Some
distributions, including Fedora and Ubuntu, have been building their
binaries for shadow stacks; all they need is a suitably equipped kernel to
run with the extra protection.
<p>
It is always dangerous to ship code using kernel features that have not yet
been accepted and merged; shadow stacks turn out to be an example of why.
According to the cover letter on the current series, the
<tt>arch_prctl()</tt> API was "<q>abandoned for being strange</q>".
But those shadow-stack-ready binaries deployed on systems worldwide were
built expecting that API, strange or not, to be present; if the kernel
respects the markings in the ELF file and enables shadow stacks for those
programs, some of them will break.  That would cause system administrators
worldwide to disable shadow stacks until at least 2040, rather defeating
the purpose of the whole exercise.
<p>
One obvious workaround for this problem would be to never recognize the
current ELF marker for shadow stacks and, instead, create a new one to mark
binaries using the interface actually supported by the kernel.  The
decision that was made, though, was to get the kernel out of the business
of recognizing shadow-stack-capable binaries entirely and let the C library
take care of it.  So, if this version of the ABI is adopted, the kernel
will never enable shadow stacks unless user space requests it.
<p>
<h4>The proposed interface</h4>
<p>
Overall control of shadow stack functionality is to be had with a
(presumably not strange) <tt>arch_prctl()</tt> call:
<p>
<pre>
    status = arch_prctl(ARCH_X86_FEATURE_ENABLE, ARCH_X86_FEATURE_SHSTK);
</pre>
<p>
There is also an <tt>ARCH_X86_FEATURE_DISABLE</tt> operation that can be
used to turn shadow stacks off, and <tt>ARCH_X86_FEATURE_LOCK</tt> to
prevent future changes.
<p>
While most applications need not worry about shadow stacks, some of them
will need to be able to create new ones.  Applications using <a
href="https://man7.org/linux/man-pages/man3/makecontext.3.html"><tt>makecontext()</tt></a>
and friends are a prominent example.  Creating a shadow stack requires
kernel support; the associated memory must have the special page bits set
as described above, and must also include the restore token.  So there is a
new system call for this operation:
<p>
<pre>
    void *map_shadow_stack(unsigned long size, unsigned int flags);
</pre>
<p>
The size of the desired stack is passed as <tt>size</tt>, while
<tt>flags</tt> has a single possibility: <tt>SHADOW_STACK_SET_TOKEN</tt> to
request that a restore token be stored in the stack.  The return value on
success is the address of the base of this stack.
<p>
Actually using this new stack is a matter of executing the
<tt>RSTORSSP</tt> instruction to make the switch, most likely done as a
part of a user-space context switch between threads.  That instruction will
perform the necessary verification of page permissions and the restore
token before making the switch.  It will also mark the token on the new
shadow stack as being busy, preventing that stack from being used by any
other process.
<p>
Applications doing especially tricky things may require the ability to
write to the shadow stack.  That access is normally not allowed for obvious
reasons but, as Edgecombe <a
href="/ml/linux-kernel/20220130211838.8382-35-rick.p.edgecombe@intel.com/">noted</a>,
that "<q>restricts any potential apps that may want to do exotic things
at the expense of a little security</q>".  For the exotic case, another
feature (<tt>LINUX_X86_FEATURE_WRSS</tt>) can be turned on with
<tt>arch_prctl()</tt>; that, in turn, enables the <tt>WRSS</tt>
instruction, which can write to shadow-stack memory.  Directly writing to
that memory by dereferencing a pointer is still disallowed in this case.
<p>
<h4>What next?</h4>
<p>
This work is not exactly new; an early version of it was covered in <a
href="/Articles/758245/">this 2018 article</a>. In its previous
incarnation, the shadow-stack patch set got up to <a
href="/ml/linux-kernel/20210830181528.1569-1-yu-cheng.yu@intel.com/">version&nbsp;30</a>.
The other half of the control-flow integrity work (indirect branch
tracking), which got up to <a
href="/ml/linux-kernel/20210820182245.1188-1-yu-cheng.yu@intel.com/">version&nbsp;29</a>
itself, has been set aside for the moment
(though Peter Zijlstra has just <a
href="/ml/linux-kernel/20220218164902.008644515@infradead.org/">shown
up</a> with a separate implementation).  With a new developer heading
up the work, a reduction in scope, and some asked-for changes, it is hoped,
this work can finally make some progress toward the mainline.
<p>
In a number of ways, it looks like that hope might be realized.  While
there were comments on various parts of the patch set, there does not
appear to be a lot of opposition to how it works at this point.  Developers
did express concern, though, about the lack of support for alternate signal
stacks.  That is a feature that seems certain to be wanted at some point,
so it would be good to see how it fits into the whole picture before this
functionality is merged.
<p>
There was also <a href="/ml/linux-kernel/YgDIIpCm3UITk896@lisas.de/">a
separate subthread</a> regarding problems with <a
href="https://criu.org/Main_Page">Checkpoint/restore in user space</a>
(CRIU), which engages in no end of underhanded tricks to get its job done.  One
part of the checkpoint process involves injecting "parasite" code into a
process to be checkpointed, grabbing the needed information, then doing a
special return out of the parasite to resume normal execution.  That is
just the sort of control-flow tampering that shadow stacks are meant to
prevent.  Various possible solutions were discussed, but nothing has
appeared in code form at this point.  A solution here, too, seems necessary
before shadow stacks can be merged; as Thomas Gleixner <a
href="/ml/linux-kernel/87fsozek0j.ffs@tglx/">put it</a>: "<q>We can't
break CRIU systems with a kernel upgrade</q>".
<p>
Finally, the range of supported hardware will almost certainly need to be
expanded.  Some AMD CPUs implement shadow stacks, evidently in a compatible
manner, but only Intel CPUs are supported in this patch set; a lack of
testing is cited as the reason.  That, at
least, will probably need to change for the work to go forward.  Shadow
stacks are also unsupported on 32-bit systems; fixing that may be harder
and it is not clear whether the motivation to do that work exists.  With or
without 32-bit support, though, there is clearly still work to be done
before this code enters the mainline.  It should not be expected to show up
in a near-future release.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Control-flow_integrity">Security/Control-flow integrity</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/885220/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor885688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 17:01 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/885688/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      I didn't understand this bit:
<blockquote>There are some PTE bits set aside for the operating system's use; Linux does not use them all and could have spared one for this purpose, but evidently certain other operating systems have no spare PTE bits, so stealing one for this purpose would not be welcome.</blockquote>
Surely if the system is running Linux, then Linux can use the PTE bits for whatever purposes it wants?  And when it's booted into another operating system, that OS doesn't have to care what interpretation Linux would give to the bits.  And I thought the page table entry was something purely OS specific anyway, but the article seems to imply it's provided by "the x86 architecture" itself.


      
          <div class="CommentReplyButton">
            <form action="/Articles/885688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885689"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 17:11 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/885689/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      Page tables are defined and used by the hardware — on x86, at least.  Some of the bits in the PTE are given over to software use.  Others, including the "present" and "dirty" bits, along with the permission bits, are defined by the hardware, so how the architecture interprets them matters.



      
          <div class="CommentReplyButton">
            <form action="/Articles/885689/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 17:31 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/885691/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for clarifying that the page table entry is defined by the CPU (on x86).  But I still don&#x27;t understand the comment about other operating systems.  If there are certain bits reserved for the OS&#x27;s use, then surely Linux can give any interpretation it wants to them, without worrying about what would happen if the machine were booted into a different OS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 17:35 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/885692/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, I see, it&#x27;s a roundabout way of saying that all the PTE bits are already used, in practice, and there isn&#x27;t one that can be used for this new feature.  The interpretation of the bit would have to be done by the hardware, not by the OS.  And while the hardware doesn&#x27;t currently care what happens to Spare Bit Number Three, some OSes might be using that bit, so it would be a backwards-incompatible change for the hardware to start taking notice of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 18:26 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/885701/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What the processor could do, would be to only start using Spare Bit Number Three if a certain bit has been set to 1 in a control register. For example, CR4.PKE and CR4.PKS control the interpretation of bit 59 to 62. However, our editor&#x27;s (presumably informed) guess is that somebody in Redmond begged Intel not to do that for the shadow stack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 17:00 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/885796/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If a PTE bit has been given to software / the OSes, then it is not a &quot;spare&quot; bit anymore. This is not just about Redmond begging, it&#x27;s about not &quot;stealing&quot; back something that was given.<br>
<p>
I think all the confusion about these bits comes from a lack of clarity about _who owns what_ and how. A bit ironic considering this is a feature meant to catch memory corruption.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 20:42 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/885819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Both Intel and software on Intel processors has learned this before: in the 286 days lots of software used reserved bits freely, and then the 386 started using them and all hell broke loose. It&#x27;s literally impossible to do that now, because the processor stops you.<br>
<p>
(ref: <a href="http://www.os2museum.com/wp/theres-more-to-the-286-xenix-story/">http://www.os2museum.com/wp/theres-more-to-the-286-xenix-...</a>)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2022 6:17 UTC (Sun)
                               by <b>oldtomas</b> (guest, #72579)
                              [<a href="/Articles/886929/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;If a PTE bit has been given to software / the OSes...&quot;<br>
<p>
The point Paolo is making is that there /is/ a protocol for the software/OS to tell the hardware &quot;go ahead, use this bit for your shadow stack&quot;.<br>
<p>
It seems that Redmond, though... well, we know that routine :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor885738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 5:46 UTC (Tue)
                               by <b>geuder</b> (guest, #62854)
                              [<a href="/Articles/885738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I also had some difficulty understanding  that part. You need to read further and it should befome clear.<br>
<p>
I guess the point is because the &quot;other operating system&quot; has no allocation for the extra bits the hardware designers chose not to use them for the new purpose. Instead they used the mentioned combination of previously used bits.<br>
<p>
Linux has no problem to use the extra bits. CoW is now being moved to one of them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor885745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 8:58 UTC (Tue)
                               by <b>jorgegv</b> (subscriber, #60484)
                              [<a href="/Articles/885745/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>In my opinion, if you remove the "operating" word, then all the paragraph makes much more sense to me:</p>

"There are some PTE bits set aside for the operating system's use; Linux does not use them all and could have spared one for this purpose, but evidently certain <b>other systems</b> have no spare PTE bits, so stealing one for this purpose would not be welcome."

<p>So this would mean that <b>Linux on X86</b> would be able to use the spare PTE bits, but <b>Linux on other systems</b> would not have those spare PTE bits available, and thus a different solution which could be available for LInux an all HW platform has been used.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/885745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 9:02 UTC (Tue)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/885748/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think so, we&#x27;re talking only about x86 (CPUs) here.<br>
<p>
But the *CPU* couldn&#x27;t take one of the &quot;OS reserved&quot; bits because non-Linux-OSes running on x86 hardware already use them for other purposes.<br>
<p>
Hence the CPU repurposes an otherwise invalid (to it, anyway) combination, necessitating the Linux use of this combination be moved to the &quot;OS reserved&quot; bits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 9:41 UTC (Tue)
                               by <b>jorgegv</b> (subscriber, #60484)
                              [<a href="/Articles/885749/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, yes, I have re-read that paragraph and the next couple of them, and now I understand. The COW bit combination needs to be migrated to use a new PTE bit because the HW engineers decided to use the same bit combination that Linux was using for COW.<br>
<p>
Thanks for the heads up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor885803"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 17:51 UTC (Tue)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/885803/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect that “other operating system” means Windows. Non-x86 is irrelevant here — no one expects any sort of page table compatibility across architectures.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885803/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor885928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2022 19:31 UTC (Wed)
                               by <b>jthill</b> (subscriber, #56558)
                              [<a href="/Articles/885928/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      It took me a bit too.
<p>
That part of the discussion is about hardware support for shadow stacks. The hardware PTEs have so-far-unused bits, left uninterpreted and unchecked so they're available to operating systems. Linux doesn't use all of those bits, but other operating systems do. So the hardware engineers implementing hardware-shadow-stack support were loath to claw back a PTE bit because it'd break those other operating systems.


      
          <div class="CommentReplyButton">
            <form action="/Articles/885928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2022 19:59 UTC (Wed)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/885931/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is interesting that HW guys choose the solution which required modification in Linux. The &quot;other system&quot; (could we guess it was MS Windows?) used all bits, so instead telling &quot;change your ways and do as Linux do&quot;, they told Linux &quot;you have to change&quot;. Isn&#x27;t that unfair?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor885933"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;Other operating systems&quot; and &quot;stealing&quot; a bit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2022 20:16 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/885933/">Link</a>] 
      </p>
      
      </div>
      </summary>
      All operating systems will need changes to make use of this feature; it doesn't seem all that terrible if asking this particular change from Linux turned out to be the path of least resistance.  Especially since Intel is actually doing the work to effect that change.


      
          <div class="CommentReplyButton">
            <form action="/Articles/885933/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor885730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shadow stacks for user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 21, 2022 21:22 UTC (Mon)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/885730/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For other ways to think about this... <a href="http://millcomputing.com/wiki/Protection">http://millcomputing.com/wiki/Protection</a><br>
<p>
Vaporware, but helpful to dream about, I suppose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor885747"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Shadow stacks for user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2022 9:00 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/885747/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not really looking forward to making rr support this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885747/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor885949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Other operating systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 4:02 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/885949/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wondering... Linux doesn&#x27;t use all the bits, so can claim one to label a COW page. But $other does use them all, already. So, $other can&#x27;t use Linux&#x27;s method. What can $other do, instead? Has it already used one of those bits to tag a COW page, i.e. it already does what Linux will do?<br>
<p>
And, there is more than one $other. Does anybody know whether all of them can make this work? Can Intel have succeeded in quizzing everybody who has an OS that might want shadow stacks?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/885949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Other operating systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 14:44 UTC (Mon)
                               by <b>jtaylor</b> (subscriber, #91739)
                              [<a href="/Articles/886362/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I understood it because others do not have free bits, the cpus use the combination of write-enable and dirty bits.<br>
<p>
Linux uses that combination already but that can be changed as it has free bits.<br>
<p>
So only an OS has a problem if it has both no free page bits and is also interpreting write-enable + dirty bits. Probably this is sufficiently unlikely to exist in the real world.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor888490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Other operating systems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2022 8:12 UTC (Sat)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/888490/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IIUC, COW is purely software so Linux can do whatever it wants with the invalid bits combinations. Shadow stack requires hardware support too (unless I&#x27;m mistaken) so it&#x27;s a different story.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/888490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
