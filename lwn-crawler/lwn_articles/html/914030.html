        <!DOCTYPE html>
        <html lang="en">
        <head><title>Moving past TCP in the data center, part 2 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/914030/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/913642/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/914030/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Moving past TCP in the data center, part 2</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>November 9, 2022</br>
           <hr>
<a href="/Archives/ConferenceIndex/#Netdev-2022">Netdev</a>
</div>
<p>
At the end of <a href="/Articles/913260/">our earlier article</a> on John
Ousterhout's talk at <a
href="https://netdevconf.info/0x16/">Netdev&nbsp;0x16</a>, he had concluded
that TCP was unsuitable for data-center environments for a variety of
reasons.  He also argued that there was no way to repair TCP so that it
could serve the needs of data-center networking.  In order for software to
be able 
to use the full potential of today's networking hardware, TCP needs to be
replaced with a protocol that is different in almost every way, he said.
The second 
half of the talk covered the <a
href="https://homa-transport.atlassian.net/wiki/spaces/HOMA/overview">Homa
transport protocol</a> that he and others at Stanford have been working on
as a possible replacement for TCP in the data center.
</p>

<p>
The Homa project set out to design a protocol from scratch that would be
ideal for the needs of data-center networking today.  It turned out to be
different from TCP in each of the five aspects that he had covered in the
first half of the talk; the choices made by Homa for those work well
together to 
"produce a really really high-performance data-center protocol".  But, he
stressed, Homa is not suitable for wide-area networks (WANs); it is only
for data 
centers. 
</p>

<h4>Homa overview</h4>

<p>
To start with, Homa is message-based, rather than byte-stream-based, which
means that the "dispatchable units" are recorded in the protocol.  Each
message is made up of multiple packets on the wire that get assembled into
a full 
message for application processing. This
solves the thread load-balancing problems that TCP has, because multiple threads
can safely read from a single socket; it will also allow network interface cards
(NICs) to directly dispatch messages to threads in the future should NICs ever
gain that support.
</p>

<p>
Homa is connectionless; its fundamental unit is a remote procedure call
(RPC), which consists of two messages: a request and a response. "The
notion of 'round trip' is explicit in the Homa protocol."  RPCs are
independent with no ordering guarantees between them; multiple RPCs can be
initiated and can finish in any order.
There is no long-lived connection state stored by Homa; once an RPC
completes, all of its state is removed.  There is a small amount
(roughly&nbsp;200 bytes) of state stored for each peer host, for IP routing
information and the like, however.  There is also no connection setup
overhead and a single socket can be used to send any number of RPCs to any
number of peers.   Homa ensures that an RPC either completes or an error is
returned, so application-level timers are not needed.
</p>

<p>
Congestion control in Homa is receiver-driven, which has major advantages
over the sender-driven congestion control used by TCP.  Ousterhout
described how flow control works in
Homa.  When a message needs to be sent to a receiver, the sender can transmit a
few "unscheduled packets" immediately, but additional "scheduled packets"
must each wait for 
an explicit "grant" from the receiver.  The idea is that there are enough
unscheduled packets to cover the round-trip time between the hosts; if there
is no congestion, the sender will have received some grants by the time it has
sent all of the unscheduled packets.  That allows sending at the hardware
line speed.
</p>

<p>
A receiver can choose not to send grants if it detects congestion in its
top-of-rack (TOR) switch; it can pause or slow the grants until that
condition subsides.  It can also prioritize messages by sending or
denying grants based on the remaining size of the message.  Having the
message size available in the protocol is helpful because "message sizes
allow us to 
predict the future".  Once a single packet of a message is received, the
receiver knows how many unscheduled packets are coming, how many scheduled
packets remain after that, and it can quickly decide on a strategy to
minimize the congestion that could result from all of the different
in-progress messages it is receiving.  It can react much more quickly than
TCP can. 
</p>

<p>
Homa also takes advantage of the priority queues that modern switches have;
each egress 
port in those switches typically has&nbsp;8-16 priority queues.  It uses
the queues to
implement the "shortest remaining processing time" (SRPT) algorithm; when a
receiver has multiple messages in progress, it allows the shorter messages
to use the higher-priority queues on the switch.  In addition, the queues
provide a way to achieve a "much better tradeoff between throughput and
latency". 
</p>

<p>
"Buffers are funny; you can't live with them, but you can't live without
them either."  Some amount of buffering is needed at the switch to ensure
that link 
bandwidth is not wasted if the higher-priority senders stop sending for any
reason.  Throughput is maintained by having lower-priority packets queue up
and be sent when there is a lull from a higher-priority sender; Homa can
then send grants to other senders to get them ramped up.  This
"overcommitment" of granting more messages than can be handled, coupled
with the prioritized buffering leads to higher throughput with low latency
on the important, shorter messages, he said.
</p>

<p>
One might think that long messages could potentially suffer from starvation
on a loaded network.  He said that he tried to produce that behavior in Homa so
that he could study it, but he found it really hard to do; he can create
starvation scenarios, but had to "contort the benchmarks" to do it.  But,
in order to avoid starvation, Homa takes a small portion of the receiver's
bandwidth (typically&nbsp;5-10%) and uses it for the oldest message, rather
than the shortest message as strict SRPT would dictate.  That guarantees
that those messages make progress; eventually their remaining size gets
small enough to be prioritized with the other small messages.
</p>

<p>
Homa does not rely on in-order packet delivery; packets can arrive in any
order and the receivers will sort them as needed.  In practice, the packets
arrive nearly in order anyway, he said, so it is not computationally
expensive to do the reordering.  He believes that Homa eliminates
core-congestion problems in data centers, unless there is simply too much
traffic overall, 
because packets can take different paths through the core fabric.  That
leads to better load balancing in the fabric as 
well as across CPU cores on the receiving hosts.
</p>

<h4>Replacing TCP?</h4>

<p>
It is hard to imagine a standard more entrenched than the TCP protocol is,
Ousterhout said, so
"I undertake this with full realization that I may be out of my mind".
Based on the results he has seen from Homa, he has set a personal mission to
figure out a way for Homa to take over a substantial portion of TCP's
traffic in the data center.  Either that, or learn why it is not
possible; "I'm going to keep going until I hit a roadblock that I simply
can't solve".
</p>

<p>
The first step to doing that is to have a production-quality implementation
of Homa "that people can actually use". He is "maybe a little bit of a
freak among academics", he said, because he loves to write code.  A few
years ago, he set out to write a Linux kernel driver for Homa; he "knew
nothing about the Linux kernel", but now has a <a
href="https://github.com/PlatformLab/HomaModule">working driver for Homa</a>.
</p>

<p>
The Homa module runs on Linux&nbsp;5.17 and&nbsp;5.18 and is not meant as a
"research prototype", which is a term that he does not like.  A research
prototype is something that does not work, "but you can somehow write a
paper about it and make claims 
about it, even though it doesn't actually really work".  The Homa module is
nearing production quality at this point, he said; the only way to find and
fix the remaining bugs is to start running it in production.
</p>

<p>
In terms of performance, Homa "completely dominates" TCP and <a
href="https://www.rfc-editor.org/rfc/rfc8257">Data Center
TCP</a> (DCTCP) for all workloads and all message sizes, he said.
He gave a few sample benchmarks that showed&nbsp;3-7x improvements in
short-message latency at the&nbsp;50th percentile, and&nbsp;19-72x
improvements in the&nbsp;99th percentile (the "tail latency").  More
information about the kernel driver for Homa can be found in 
his <a
href="https://www.usenix.org/system/files/atc21-ousterhout.pdf">paper</a>
from the&nbsp;2021 USENIX annual technical conference.
</p>

<h4>Applications</h4>

<p>
The biggest problem he sees with his mission is the huge number of
applications that directly use TCP via the socket interface.  Homa's
message-based API is different and he has been unable to find a way to
"slide it in under the existing TCP sockets interface".  
But it is not
realistic to plan to convert even a substantial fraction of those applications.
Many, perhaps most, of the applications that directly use TCP sockets also
need to work over the WAN, where Homa is not a good choice; others really
do not need the performance boost that Homa brings.  The applications that
will really benefit from Homa are the newer data-center applications that
mostly use one of a handful of RPC frameworks.  
</p>

<p>
Adding Homa support to RPC frameworks would allow applications that use
them to switch to Homa with a small configuration change, instead of a
major code change; much like applications can change the server name they
use, they 
would be able to choose Homa instead of TCP.  He has <a
href="https://github.com/PlatformLab/grpc_homa">work in progress</a> on
adding Homa support to <a href="https://grpc.io/">gRPC</a>.  The C++ gRPC
integration is working now, though without support for encryption, while
the Java 
gRPC support for Homa is 
"embryonic" but currently underway.
</p>

<p>
Working with gRPC has made him "very sad", however, because it is "unimaginably
slow". The round-trip latency for gRPC on TCP is&nbsp;90µs, with two-thirds of
that time spent in the gRPC layers on the client and server&nbsp;(30µs each).
If the goal is to get to&nbsp;5µs round trips, it is pretty clear it cannot
be done using gRPC, he said. With Homa, gRPC is roughly twice as fast, even
in the gRPC 
layers on the endpoints, which he does not really have an explanation for.
But even that is far from the goal, so he believes a "super lightweight"
framework needs to be developed eventually.
</p>

<p>
Even with Homa, though, performance is still an order of magnitude off from
what the hardware is capable of, he said. "Network speeds are increasing at
this amazing rate, CPU speeds aren't changing much."  Software simply
cannot keep up and he sees no solution to that problem.  So software
implementations of transport protocols no longer make sense; those
protocols need to move into the NICs.
</p>

<h4>Moving to user space</h4>

<p>
Some people will say that you simply need to get "those terrible operating
systems" out of the way and move everything to user space;  that will help
some, he said, but it is not enough.  In the <a
href="https://ramcloud.atlassian.net/wiki/spaces/RAM/overview">RAMCloud
storage project</a>, Stanford researchers implemented Homa in user space
and were able to achieve&nbsp;99th percentile round-trip latencies
of&nbsp;14µs, while the tail latency for Homa on Linux is&nbsp;100µs.
</p>

<p>
The primary culprit for high tail latencies is software overhead and, in
particular, load-balancing overhead.  A single core cannot handle more than
10Gbps but as soon as you split the job over multiple cores, there is an
inherent performance penalty just for doing the split. Beyond that, there
is the problem of hot spots, where too much work ends up on certain cores
while others are idle or nearly so; those can cause spikes of high
latency. 
</p>

<p>
He has not measured it, but his theory is that the inherent slowdown from
splitting up the job to multiple cores is due to cache interference.  Lots of
cache-coherency traffic coming from the split reduces the performance when
compared to doing the processing on a single core.  It is not just his Homa
implementation that sees a problem of this magnitude; he looked at Google's
<a
href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36f0f9b41e969a00d75da7693571e988996c9f4c.pdf">Snap/Pony</a>
system, which sees a&nbsp;4-6x efficiency loss when moving from single to
multiple cores.  He said that the rule of thumb is that if you need to go
beyond a single core, a second or third core is not enough; "you actually
have to go to four cores before you actually get any performance
improvement over one core".  
</p>

<p>
If you look at some of the numbers from various papers, Ousterhout said,
you might conclude that moving the protocol processing to user space is a
good idea.  But, all of those user-space implementations are "basically
just research
prototypes and they are way oversimplified"; they do not do a lot of the
processing that any production system would require.  They are also
measured under 
the most ideal conditions, with either no load balancing or
perfect by-hand partitioning, handling only short messages ("that's easy"),
and so on. 
</p>

<p>
But Snap is a production-quality user-space implementation that can be
compared; it is 
roughly 2x better than Homa in the Linux kernel.  If you look at the number
of cores needed to drive&nbsp;80Gbps (an&nbsp;80% loaded&nbsp;100Gbps
network) bidirectionally, Snap requires&nbsp;9-14 cores, while Linux Homa
requires&nbsp;17.  So user space is better, but not on the scale needed to
hit the goals.
</p>

<h4>To the NIC</h4>

<p>
The only alternative that he sees is to move the protocol
processing of the transport layer into the NIC.
Applications would 
access the NIC directly, bypassing the kernel, via a message-based
interface; "the notion of a packet never gets to software".  Other features
like load balancing by choosing an idle application thread,
virtualization, and encryption should be added to the NICs as well.
</p>

<p>
The architecture for these NICs is not going to be easy to figure out, he
said; they 
need to process packets at line rate, while being programmable to support
multiple protocols.  It is also important that the programs for those protocols
can still be open source,
Ousterhout said. None of the existing "smart NIC" architectures is
adequate, he thinks, so it makes for an interesting problem for computer
architects to 
solve. 
</p>

<p>
Homa is "not without its controversies"; there have been several papers
that have claimed to find problems with Homa.  There are also some
alternatives being proposed in other papers, but "all of these papers have
pretty significant flaws in them, unfortunately". They have used Homa in
unrealistic configurations or hobbled it in some fashion in his opinion;
while he does not "want to get into a food fight" about them, he has
gathered some of his responses on the <a
href="https://homa-transport.atlassian.net/wiki/spaces/HOMA/overview#Related-Work">Homa
wiki</a>. 
</p>

<p>
But there is a bigger "meta question" that needs to be answered: "do
applications actually care about harnessing the full network performance?"
Today, we are "stuck in a no-chicken-no-egg cycle", there are no
applications that require the full hardware capabilities, because there
would be no way to run them.  So today's applications make do with the
performance provided by today's network stacks and there is no real
incentive to make the infrastructure faster, because there is no one who
is "screaming for it". 
</p>

<p>
So, he wondered, if we make the networking "as blindingly fast as I think
we can do", will new applications appear that people have not even thought
about today because the capability is not available?  He would be
interested in hearing about any applications that would be dramatically
improved by these performance improvements.  As an academic, he does not
actually need to have a market; he can build something and hope that the
applications come along later, but that "would be a terrible way to do a
startup". 
</p>

<p>
He concluded by reiterating the main points of what he thinks needs to be
done if applications are going to take advantage of the amazing advances in
networking speeds.  A new transport protocol is needed; he is obviously a
Homa advocate but would be happy to discuss other possibilities for that.
Beyond that, a new lightweight RPC framework will be important, and,
ultimately, whatever transport protocol is used will need to move down into
the NIC.  Ousterhout's keynote laid out a vision of a fairly radical
reworking of the state of 
data-center 
networking today; it will be interesting to see how it plays out over
the coming years.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-Protocols">Networking/Protocols</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Netdev-2022">Netdev/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/914030/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor914271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2022 21:23 UTC (Wed)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/914271/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So...................they reinvented UDP, with a bit of cruft on top?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2022 21:36 UTC (Wed)
                               by <b>fraetor</b> (subscriber, #161147)
                              [<a href="/Articles/914273/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the idea is that it is a reliable transport.<br>
<p>
I could potentially see this being useful for some kind of Plan9-esq system to get truly massive vertical scaling.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor914285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2022 22:27 UTC (Wed)
                               by <b>wmf</b> (guest, #33791)
                              [<a href="/Articles/914285/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, flow/congestion control is not "a bit of cruft" especially when it delivers 10x performance improvement.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor914274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2022 21:50 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/914274/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Working with gRPC has made him "very sad", however, because it is "unimaginably slow". The round-trip latency for gRPC on TCP is 90µs, with two-thirds of that time spent in the gRPC layers on the client and server (30µs each)</span><br>
<p>
That's because gRPC is a huge framework with its own HTTP/2 implementation, support for streaming, asynchronous programming, etc. You can actually swap protobuf there for other serialization frameworks.<br>
<p>
You don't need any of it if you want to make a simple request/reply framework. We used Twitch's Twirp as the base: <a href="https://twitchtv.github.io/twirp/docs/spec_v7.html">https://twitchtv.github.io/twirp/docs/spec_v7.html</a> and did tweaks on top of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor914278"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2022 21:53 UTC (Wed)
                               by <b>invidian</b> (subscriber, #131837)
                              [<a href="/Articles/914278/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if projects like Ceph, so large storage systems would benefit a lot from Homa. I'm also curious if running TCP over Homa would make sense, for virtualization and software defined networks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914278/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2022 7:46 UTC (Fri)
                               by <b>jcolledge</b> (subscriber, #153588)
                              [<a href="/Articles/914506/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I also wonder if a filesystem or block layer protocol would be an interesting application for Homa.<br>
Ceph is an option, as mentioned.<br>
NBD (Network Block Device) could be an easy place to start, but I'm not sure how much it is used.<br>
NVMe-oF (NVMe over Fabrics)?<br>
DRBD (Distributed Replicated Block Device)?<br>
NFS?<br>
<p>
People always want better performance at file and block levels. These protocols don't require complete ordering, so using TCP is a waste of resources.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor914298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 4:00 UTC (Thu)
                               by <b>gcarothers</b> (subscriber, #63072)
                              [<a href="/Articles/914298/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess I’d like to understand better how this relates to InfiniBand vs TCP. Seems to be solving the same sort of problems?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 13:14 UTC (Thu)
                               by <b>jtaylor</b> (subscriber, #91739)
                              [<a href="/Articles/914332/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
from first article <a href="https://lwn.net/Articles/913452/">https://lwn.net/Articles/913452/</a><br>
the paper has a small section on it, direct link: <a href="https://arxiv.org/abs/2210.00714">https://arxiv.org/abs/2210.00714</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914339"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 14:05 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/914339/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ha, beat me to it! :)  (I started typing an answer, got distracted by something, and then when I finished it you had already answered almost an hour before..)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914339/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor914337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 14:02 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/914337/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the comments part 1 the same question was asked, I wrote <a href="https://lwn.net/Articles/913452/">https://lwn.net/Articles/913452/</a> :<br>
<p>
From <a href="https://web.stanford.edu/~ouster/cgi-bin/papers/replaceTcp.pdf">https://web.stanford.edu/~ouster/cgi-bin/papers/replaceTc...</a> (which I guess is the paper this presentation is based on), section 6 deals with Infiniband.<br>
<p>
<span class="QuotedText">&gt; However, RDMA shares most of TCP’s problems. It is</span><br>
<span class="QuotedText">&gt; based on streams and connections (RDMA also offers unre-</span><br>
<span class="QuotedText">&gt; liable datagrams, but these have problems similar to those for</span><br>
<span class="QuotedText">&gt; UDP). It requires in-order packet delivery. Its congestion con-</span><br>
<span class="QuotedText">&gt; trol mechanism, based on priority flow control (PFC), is dif-</span><br>
<span class="QuotedText">&gt; ferent from TCP’s, but it is also problematic. And, it does not</span><br>
<span class="QuotedText">&gt; implement an SRPT priority mechanism.</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor914468"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 21:23 UTC (Thu)
                               by <b>MattBBaker</b> (guest, #28651)
                              [<a href="/Articles/914468/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Honestly it feels like most of the criticisms of IB based RDMA is based on misunderstanding what RDMA means. IB will share many of TCP's problems if you use the send()/recv() pattern seen in TCP, but if you use the one sided PUT/GET protocols and active messages all sorts of exciting communication patterns are possible that just aren't possible in TCP land.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914468/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914766"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2022 11:07 UTC (Mon)
                               by <b>gurugio</b> (guest, #113827)
                              [<a href="/Articles/914766/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree that Infiniband/RDMA is different. But the worst point of Infiniband/RDMA is cost. If a new protocol uses the Ethernet network and faster than TCP/Ethernet, it might be best.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914766/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor914301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 4:55 UTC (Thu)
                               by <b>da4089</b> (subscriber, #1195)
                              [<a href="/Articles/914301/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd like to see an implementation of the Homa API over TCP (or even UDP) so that applications could directly use Homa for highest performance where it's available, but then fall back to a Homa-over-TCP where that's not possible.<br>
<p>
I also think it'd be useful to have Homa implemented using some kernel-bypass stacks: the Mellanox/NVIVIDA one, or the Solarflare/Xilinx/AMD one -- having a kernel module is fine and good, but ... if we really care about latency, why suffer the system call overhead?<br>
<p>
Both of those tasks should be relatively simple given the kernel module code exists, although perhaps it's a better investment to jump straight to the FPGA implementation of Homa and avoid the additional software layers altogether.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914508"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2022 8:06 UTC (Fri)
                               by <b>nilsmeyer</b> (guest, #122604)
                              [<a href="/Articles/914508/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps it's possible to have some sort of ring buffer system like io_uring but directly connected to the NIC? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914508/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2022 16:13 UTC (Sun)
                               by <b>blablok</b> (guest, #160937)
                              [<a href="/Articles/914733/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's pretty much what DPDK does. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 16:14 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/915281/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And AF_XDP.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor914316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not over the Internet?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 9:29 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/914316/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Homa is not suitable for wide-area networks (WANs)".  Why not?  If there is retrying at the application level it ought to work well enough.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not over the Internet?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 11:55 UTC (Thu)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/914326/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      As I read it, a very low round-trip time is a key part of the assumptions.
<blockquote>
When a message needs to be sent to a receiver, the sender can transmit a few "unscheduled packets" immediately, but additional "scheduled packets" must each wait for an explicit "grant" from the receiver
</blockquote>
which requires one round trip for each RPC larger than "a few" packets, then at least another one for the rest of the data and the response. If you have a suitable protocol running over TCP, the connection will already be set up and you can send all the data at once.
<p>
Also, I suspect that
<blockquote>A receiver can choose not to send grants if it detects congestion in its top-of-rack (TOR) switch; it can pause or slow the grants until that condition subsides</blockquote>
embeds the assumption that this is where congestion will occur.






      
          <div class="CommentReplyButton">
            <form action="/Articles/914326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914349"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not over the Internet?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 14:25 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/914349/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; &gt; When a message needs to be sent to a receiver, the sender can transmit a few "unscheduled packets" immediately, but additional "scheduled packets" must each wait for an explicit "grant" from the receiver </span><br>
<p>
Isn't this similar to the problem of window size scaling in TCP? I.e. in a network with a big bandwidth delay product, you need a bigger window in TCP, or more 'unscheduled packets' and more in-flight 'grants' in Homa?<br>
<p>
<span class="QuotedText">&gt; the assumption that this is where congestion will occur. </span><br>
<p>
That might actually be an issue, yes. If the idea is to not use packet drops as a congestion signal, how is congestion somewhere in the middle of the path detected? Guess you would need some kind of BBR-style timing based congestion control?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914349/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not over the Internet?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 17:03 UTC (Thu)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/914391/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It's somewhat similar, but the difference is that TCP <em>as it is used today</em> has long-lived connections to which you can attach things like window size.<p>
From the article:<blockquote>There is no long-lived connection state stored by Homa; once an RPC completes, all of its state is removed</blockquote> including anything like window size. The next RPC (larger than a "few packets") has to discover that all over again.
<p>
Or so I understand.



      
          <div class="CommentReplyButton">
            <form action="/Articles/914391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor914448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not over the Internet?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 19:22 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/914448/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; That might actually be an issue, yes. If the idea is to not use packet drops as a congestion signal, how is congestion somewhere in the middle of the path detected? Guess you would need some kind of BBR-style timing based congestion control?</span><br>
<p>
According to https://homa-transport.atlassian.net/wiki/spaces/HOMA/pages/262171/Concerns+Raised+About+Homa, this should not be a problem if different packets can be routed differently from each other.<br>
<p>
In theory, you could still run out of bandwidth for the entire network overall, but that probably requires a much higher volume than is typical of a TCP-driven network, and should likely be dealt with using some combination of explicit provisioning and QoS (both of which are far more suitable to a closed DC-type network than to an open WAN).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor914327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not over the Internet?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 12:03 UTC (Thu)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/914327/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Random guesses (I haven't read the Homa paper): Receiver-initiated control doesn't work well when time scales are milliseconds and not microseconds (you very quickly run out of credits). Lack of encryption. More packet loss requires more sophisticated retransmit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor914328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not over the Internet?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 12:11 UTC (Thu)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/914328/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WAN is ??? about where each link goes and what routes are available. Datacentre cabling is very controlled and very specific, so you also guess at maximal link capability in designing a protocol for it; maybe the summary is that TCP survives the worst link-failure/link-capacity cases where Homa aims to maximise known-good links in known-good configurations.<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor914317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 9:31 UTC (Thu)
                               by <b>andrewsh</b> (subscriber, #71043)
                              [<a href="/Articles/914317/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      For those wondering, the presenter is indeed <i>the</i> John Ousterhout, the creator of the Tcl programming language.



      
          <div class="CommentReplyButton">
            <form action="/Articles/914317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 12:16 UTC (Thu)
                               by <b>interalia</b> (subscriber, #26615)
                              [<a href="/Articles/914330/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks, this was definitely what I was wondering when I saw the name!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor914443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 19:13 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/914443/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An alternative title for his talk would be “Why you should not use Tcp”. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor914351"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 14:28 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/914351/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not a networking expert, but how does a SRPT style priority mechanism deal with non-cooperative flows? That is, what if an application splits up its messages into lots of small messages, in order to get preferential treatment?<br>
<p>
(I guess a bit similar to how Bittorrent games TCP by launching a gazillion streams?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914351/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 19:34 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/914450/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Then SRE turns that application off until its developers agree to fix it.<br>
<p>
Or maybe Homa has some sort of mechanism to deal with this, I don't know, but you can't just run random adversarial code in a DC and expect to get away with it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 16:18 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/915282/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're on a datacenter, so presumably you can agree with other teams to Just Don't Do That (TM) I think. As someone else mentioned, the SRE can enforce this, misbehave and will shut your service off until you fix it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor914352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 14:32 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/914352/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Homa does have some similarities with Amazon SRD: <a href="https://assets.amazon.science/a6/34/41496f64421faafa1cbe301c007c/a-cloud-optimized-transport-protocol-for-elastic-and-scalable-hpc.pdf">https://assets.amazon.science/a6/34/41496f64421faafa1cbe3...</a> , in that both provide an unordered reliable datagram service as the fundamental primitive.<br>
<p>
SRD congestion control is different though, seems inspired by BBR, based on measuring RTT.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor914438"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2022 18:59 UTC (Thu)
                               by <b>nickodell</b> (subscriber, #125165)
                              [<a href="/Articles/914438/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Something I don't follow about this new protocol: one of the benefits is the elimination of per-connection state. But then how are RPC messages larger than one packet handled? It seems like it requires some kind of re-assembly on the receiving end, which requires the receiver to keep per-RPC state. How does Homa avoid this?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914438/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor914543"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2022 14:07 UTC (Fri)
                               by <b>MattBBaker</b> (guest, #28651)
                              [<a href="/Articles/914543/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the article it says that Homa is message/reply structure with a grant mechanism for sending more packets after the first few. I imagine that the grant comes with metadata/cookie for the expected granted packets so that the receiver can reassemble the message based on headers that includes the cookie. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/914543/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor915010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2022 1:23 UTC (Wed)
                               by <b>RobertBrockway</b> (guest, #48927)
                              [<a href="/Articles/915010/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would moving Homa in to user space improve performance?<br>
<p>
There's a push to put QUIC in the Linux kernel to improve performance, and this is a general trend.  I understand this aims to minimise context switches.<br>
<p>
One of the main arguments again microkernels is that putting core OS functionality in user space kills performance. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving past TCP in the data center, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2022 16:10 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/915280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why would moving Homa in to user space improve performance?</span><br>
<span class="QuotedText">&gt; </span><br>
<span class="QuotedText">&gt; There's a push to put QUIC in the Linux kernel to improve performance, and this is a general trend. I understand this aims to minimise context switches.</span><br>
<span class="QuotedText">&gt; </span><br>
<span class="QuotedText">&gt; One of the main arguments again microkernels is that putting core OS functionality in user space kills performance. </span><br>
<span class="QuotedText">&gt; </span><br>
<p>
It's a bit more complicated than that. The kernel has some extra work due to not needing the exact needs of a given userspace service. It involves extra copies as well, you need to keep a separate buffer where you get the actual packages from the NIC, then a buffer per socket, then if you don't use a memory map yet another buffer in userspace for reading into. All this copying is irrelevant in latency insensitive contexts, but they quickly pile up.<br>
When a single application owns the whole traffic you can perform either a single copy (memory allocated for DMA to userspace) or zero (if your driver allows direct access to the DMA area). For the common case this simply can't be done, but when you fire a VM for a single application in a datacenter this is an entirely viable approach.<br>
<p>
QUIC in the kernel improves performance because you can do things like packet filtering, decryption without extra copies, etc, without having to map the driver and have a single owner, i.e. an approach that is viable for a multitasking system such as what anything running a browser will have.<br>
<p>
Note this is not the same as what microkernels do, where processes still copy data, just between userspace servers and applications, so instead of saving copies you just added extra IPC+scheduling overhead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
