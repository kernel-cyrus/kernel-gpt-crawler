        <!DOCTYPE html>
        <html lang="en">
        <head><title>A bcache update [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/497024/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/496626/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/497024/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A bcache update</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>May 14, 2012</br>
           </div>
Flash-based solid-state storage devices (SSDs) have a lot to recommend
them; in particular, they can be quite fast even when faced with highly
non-sequential I/O patterns.  But SSDs are also relatively small and
expensive; for that reason, for all their virtues, they will not be fully
replacing rotating storage devices for a long time.  It would be nice to
have a storage device that provided the best features of both SSDs and
rotating devicesâ€”the speed of flash combined with the cheap storage
capacity of traditional drives.  Such a device could simultaneously reduce
the performance pain that comes with rotating storage and the financial
pain associated with solid-state storage.
<p>
The classic computer science response to such a problem is to add another
level of indirection in the form of another layer of caching.  In
this case, a large array of drives could be hidden behind a much smaller
SSD-based cache that provides quick access to frequently-accessed data and
turns random access patterns in something closer to sequential access.
Hybrid drives and high-end storage arrays have provided this kind of
feature for some time, but Linux does not currently have the ability to
construct such two-level drives from independent components.  That
situation could change, though, if the <a
href="/Articles/496782/">bcache</a> patch set finds its way into the
mainline.
<p>
LWN last <a href="/Articles/394672/">looked at bcache</a> almost two years
ago.  Since then, the project has been relatively quiet, but development
has continued.  With the current v13 patch set, bcache creator Kent Overstreet
says:
<p>
<div class="BigQuote">
	Bcache is solid, production ready code. There are still bugs being
	found that affect specific configurations, but there haven't been
	any major issues found in awhile - it's well past time I started
	working on getting it into mainline.
</div>
<p>
The idea behind bcache is relatively straightforward: given an SSD and one
or more storage devices, bcache will interpose the SSD between the kernel
and those devices, using the SSD to speed I/O operations to and from the
underlying "backing store" devices.  If a read request can be satisfied
from the SSD, the backing store need not be involved at all.  Depending on
its configuration, bcache can also buffer write operations; in this mode,
it serves as a sort of extended I/O scheduler, reordering operations so
that they can be sent to the backing device in a more seek-friendly manner.
Once one gets into the details, though, the problem starts to become more
complex than one might imagine.
<p>
Consider the buffering and reordering of write operations, for example.
Some users may be uncomfortable with anything that delays the arrival of
data on the backing device; for such situations, bcache can be run in a
write-through caching mode.  When write-through behavior is selected, no
write operation is considered to be complete until it has made it to the
backing device.  Clearly, in this case, the SSD cache is not going to
improve write performance at all, though it may still improve performance
overall if that data is read while it remains in the cache.
<p>
If, instead, writeback caching is enabled, bcache will mark the completion of
writes once they make it to the SSD.  It can then flush those dirty blocks
out to the backing device at its leisure.  Writeback caching can allow the
system to coalesce multiple writes to the same blocks and to achieve better
on-disk locality when the writes are eventually flushed out; both of those
should improve performance.  Obviously, writeback caching also carries the
risk of losing data if the system is struck by a meteorite before the
writeback operation is complete.  Bcache includes a fair amount of code
meant to address this concern; the SSD contains an index as well as the
cached data, so dirty blocks can be located and written back after the
system comes back up.  Providing meteorite-proof drives is beyond the scope
of the bcache patch set, though.
<p>
Of course, maintaining this index on the SSD has some performance costs of
its own, especially since bcache takes pains to only write full erase
blocks at a time.  One write operation from the kernel can turn into
several operations at the SSD level to ensure that the on-SSD data
structures are consistent at all times.  To mitigate this cost, bcache
provides an optional journaling layer that can speed up operations at the
SSD level.
<p>
Another interesting problem that comes with writeback caching is the
implementation of barrier operations.  Filesystems use barriers
(implemented as synchronous "force to media" operations in contemporary
kernels) to ensure that the on-disk filesystem structure is consistent at
all times.  If bcache does not recognize and implement those barriers, it
runs the risk of wrecking the filesystem's careful ordering of operations
and corrupting things on the backing device.  Unfortunately,
bcache does indeed lack such support at the moment, leading to a strong
recommendation to mount filesystems with barriers disabled for now.
<p>
Multi-layer solutions like bcache must face another hazard: what happens if
somebody accesses the underlying backing device directly, routing around
bcache?  Such access could result in filesystem corruption.  Bcache handles
this possibility by requiring exclusive access to the backing device.  That
device is formatted with a special marker, and its leading blocks are
hidden when accessing the device by way of bcache.  Thus, the beginning of
the device under bcache is not the same as the beginning when the device is
accessed directly.  That means that a filesystem created through bcache
will not be recognized by the filesystem code if an attempt is made to
mount the backing device directly.  Simple attempts to shoot one's own feet
should be defeated by this mechanism; as always, there is little point in
doing more to protect those who are really determined to injure themselves.
<p>
There seems to be a reasonable level of consensus that bcache would be a
useful functionality to add to the kernel.  There are some obstacles to
overcome before this code can be merged, though.  One of those is that
bcache adds its own management interface involving a set of dedicated tools
and a complex sysfs structure.  There is resistance to adding another API
for block device management, so Kent has been encouraged to integrate
bcache into the device mapper code.  Nobody seems to be working on that
project at the moment, but Dan Williams has posted <a
href="/Articles/496925/">a set of patches</a> integrating bcache into the
MD RAID layer.  With these patches, a simple <tt>mdadm</tt> command is
sufficient to set up an array with SSD caching added on top.  Once that
code gets into shape, presumably the user-space interface concerns will be
somewhat lessened.
<p>
A harder problem to get around may be the simple fact that the bcache patch
set is large, adding over 15,000 lines of code to the kernel.  Included
therein is a fair amount of tricky data structure work such as a complex
btree implementation and "closures," being "<q>asynchronous refcounty
things based on workqueues</q>".  The complexity of the code will make
it hard to review, but, given the potential for trouble when adding a new
stage to the block I/O path, developers will want this code to be well
reviewed indeed.  Getting enough eyeballs directed toward this code could
be a challenge, but the benefit, in the form of faster storage devices,
could well be worth the trouble.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer-Caching">Block layer/Caching</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/497024/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor497122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 20:07 UTC (Mon)
                               by <b>blitzkrieg3</b> (guest, #57873)
                              [<a href="/Articles/497122/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Obviously, writeback caching also carries the risk of losing data if the system is struck by a meteorite before the writeback operation is complete. </font><br>
<p>
It isn't clear to me why this is true. SSDs are persistent storage and the data is still in the SSD, so why can't this be persistent? The only way this could be a problem is if the mapping is in memory and not written out to the SSD ever.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 20:10 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/497123/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Yes, exactly...as I tried to explain in that same paragraph.  The data does exist on SSD, but it's only useful if the post-meteorite kernel knows what data is there.  So the index and such have to be saved to the SSD along with the data.
      
          <div class="CommentReplyButton">
            <form action="/Articles/497123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bcache cache-sets</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 20:49 UTC (Mon)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/497126/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also as briefly mentioned in the older article: bcache has cache-sets, you can assign several SSDs to a backing store.<br>
<p>
Eventually bcache is supposed to get support for mirroring the dirty data, so your dirty data will be stored on two SSDs before it is written to your already redundant backing store (like a RAID1 of HDDs).<br>
<p>
Any data that is only a cached copy of data already written to the backing store will only be stored ones on one of the SSDs.<br>
<p>
When that has been added that should take away most concerns people might have about their data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor497138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 23:28 UTC (Mon)
                               by <b>russell</b> (guest, #10458)
                              [<a href="/Articles/497138/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
could it be that the SSD is a single point of failure in front of a redundant set of disks.  So writing to the SSD is probably no better than keeping it in RAM.  Power supply failure vs SSD failure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 7:56 UTC (Tue)
                               by <b>Tobu</b> (subscriber, #24111)
                              [<a href="/Articles/497157/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I think the SSD will be a single point of failure in writeback mode, because the underlying filesystem would have megabytes of metadata or journal blocks not written in the right order, which is bad corruption. I don't know how SSDs tend to fail; if they fail into a read-only the writes would still be recoverable in this case, as long as bcache can replay from a read-only SSD. Maybe a filesystem that handles SSD caching itself could avoid that risk.
      
          <div class="CommentReplyButton">
            <form action="/Articles/497157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 9:05 UTC (Tue)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/497161/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did you see my other comment ?<br>
<p>
About how bcache will support more than one SSD in the future and how it will save 2 copies of your precious data on different SSDs instead of one:<br>
<p>
<a href="http://lwn.net/Articles/497126/">http://lwn.net/Articles/497126/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor497219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 19:13 UTC (Tue)
                               by <b>dwmw2</b> (subscriber, #2063)
                              [<a href="/Articles/497219/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><i>"SSDs are persistent storage and the data is still in the SSD, so why can't this be persistent? The only way this could be a problem is if the mapping is in memory and not written out to the SSD ever."</i></blockquote>

Or if your SSD is like almost all SSDs ever seen, where the internal translation is a "black box" which you can't trust, which is known for its unreliability especially in the face of unexpected power failure, and which you can't debug or diagnose when it goes wrong.
      
          <div class="CommentReplyButton">
            <form action="/Articles/497219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 20:51 UTC (Mon)
                               by <b>alankila</b> (guest, #47141)
                              [<a href="/Articles/497127/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's also the facebook flashcache which does something similar. I've been running it experimentally as a writeback cache on a test server and so far it seems to do what it promises. It can be experimented with today, and contains only about 6400 lines of code by a quick count, and can be insmod'd into kernel rather than patched in.<br>
<p>
Maybe it's somehow critically far worse, but then again, perhaps it's true that perfect is the enemy of good. We'll probably know when we can benchmark these technologies against each other.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 21:18 UTC (Mon)
                               by <b>Beolach</b> (guest, #77384)
                              [<a href="/Articles/497130/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The bcache wiki has a <a href="http://bcache.evilpiepirate.org/#Performance">Performance</a> section, which includes <a href="http://www.accelcloud.com/2012/04/18/linux-flashcache-and-bcache-performance-testing/">a link</a> to just such a comparison.
      
          <div class="CommentReplyButton">
            <form action="/Articles/497130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 21:37 UTC (Mon)
                               by <b>alankila</b> (guest, #47141)
                              [<a href="/Articles/497131/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmh. Looks like garbage comparison. They use XFS, which was changed a lot between 2.6.32 (which is their flashcache kernel) and 3.1 (for bcache).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor497134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 22:40 UTC (Mon)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/497134/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
why such a negative style, Jon ? You could just as well have written<br>
<p>
<font class="QuotedText">&gt; Such a device could simultaneously increase the performance ecstasy that comes with solid-state storage and the overwhelming financial joy associated with rotating storage.</font><br>
<p>
(just kidding.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 4:15 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/497152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That reads like poorly translated Japanese or Chinese documentation...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 23:25 UTC (Mon)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/497137/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My number one question is does bcache preserve the (safely written) contents of the cache across restarts?  That would be a major advantage in avoiding cache warm up time in many applications, particularly large databases.<br>
<p>
In addition, clearing out the first block of the backing device doesn't seem like such a great idea on simple configurations.  If the SSD fails, the remaining filesystem would practically be guaranteed to be in a seriously inconsistent state upon recovery. I would be concerned about using this in a sufficiently critical setup without the ability to mirror the cache devices.<br>
<p>
It would also seem that the best way to run such a cache would be with a relatively tight integration with the raid layer, such that backing store devices are marked with metadata indicating the association with the cache device, so that the group of them can properly be reassembled after a hardware failure, possibly on a different system.  The raid layer could then potentially use the cache as a write intent log as well, which is a big deal for raid 5/6 setups.<br>
<p>
If you want write performance improvements, the ideal thing to do is not to synchronously flush dirty data in the cache to the backing store on receipt of a write barrier, but rather to journalize all the writes themselves on the cache device, so that they can be applied in the correct order on system recovery. Otherwise you get a milder version of problem where synchronous writes are held up by asynchronous ones, which can dramatically affect the time required for an fsync operation, a database commit, and other similar operations, if there are other asynchronous writes pending.<br>
<p>
On the other hand, a device like this could make it possible for the raid / lvm layers to handle write barriers properly, i.e. with context specific barriers, that only apply to one logical volume, or subset of the writes from a specific filesystem, without running the risk of serious inconsistency problems due to the normal inability to write synchronously to a group of backing store devices. If you have a reliable, low overhead write intent log, you can avoid that problem, and do it right, degrading to flush the world mode when a persistent intent log is not available.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 23:54 UTC (Mon)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/497140/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; My number one question is does bcache preserve the (safely written) contents</font><br>
<font class="QuotedText">&gt; of the cache across restarts? That would be a major advantage in avoiding cache</font><br>
<font class="QuotedText">&gt; warm up time in many applications, particularly large databases.</font><br>
<p>
Yes. That's been priority #1 from the start - it's particularly critical if you <br>
want to be able to use writeback... at all.<br>
<p>
<font class="QuotedText">&gt; In addition, clearing out the first block of the backing device doesn't seem</font><br>
<font class="QuotedText">&gt; like such a great idea on simple configurations. If the SSD fails, the</font><br>
<font class="QuotedText">&gt; remaining filesystem would practically be guaranteed to be in a seriously</font><br>
<font class="QuotedText">&gt; inconsistent state upon recovery. I would be concerned about using this in a</font><br>
<font class="QuotedText">&gt; sufficiently critical setup without the ability to mirror the cache devices.</font><br>
<p>
Yeah. For now, you can just use a raid1 of SSDs. Eventually, I'll finish <br>
multiple cache device support - you'll be able to have multiple SSDs in a cache<br>
set, and only dirty data and metadata will be mirrored.<br>
<p>
<font class="QuotedText">&gt; It would also seem that the best way to run such a cache would be with a</font><br>
<font class="QuotedText">&gt; relatively tight integration with the raid layer, such that backing store</font><br>
<font class="QuotedText">&gt; devices are marked with metadata indicating the association with the cache</font><br>
<font class="QuotedText">&gt; device, so that the group of them can properly be reassembled after a hardware</font><br>
<font class="QuotedText">&gt; failure, possibly on a different system. The raid layer could then potentially</font><br>
<font class="QuotedText">&gt; use the cache as a write intent log as well, which is a big deal for raid 5/6</font><br>
<font class="QuotedText">&gt; setups.  </font><br>
<p>
I think if you're using bcache for writeback caching on top of your raid5/6, <br>
things will work out pretty well without needing any tight integration;<br>
bcache's writeback tries hard to gather up big sequential IOs, and raid5/6 will<br>
handle those just fine.<br>
<p>
<font class="QuotedText">&gt; If you want write performance improvements, the ideal thing to do is not to </font><br>
<font class="QuotedText">&gt; synchronously flush dirty data in the cache to the backing store on receipt of</font><br>
<font class="QuotedText">&gt; a write barrier, but rather to journalize all the writes themselves on the</font><br>
<font class="QuotedText">&gt; cache device, so that they can be applied in the correct order on system</font><br>
<font class="QuotedText">&gt; recovery. Otherwise you get a milder version of problem where synchronous</font><br>
<font class="QuotedText">&gt; writes are held up by asynchronous ones, which can dramatically affect the time</font><br>
<font class="QuotedText">&gt; required for an fsync operation, a database commit, and other similar</font><br>
<font class="QuotedText">&gt; operations, if there are other asynchronous writes pending.  </font><br>
<p>
Yes. But all that's really required for that is writeback caching (things get <br>
complicated if you only want to use writeback caching for random writes, but <br>
I'll handwave that away for now).<br>
<p>
<font class="QuotedText">&gt; On the other hand, a device like this could make it possible for the raid /</font><br>
<font class="QuotedText">&gt; lvm layers to handle write barriers properly, i.e. with context specific</font><br>
<font class="QuotedText">&gt; barriers, that only apply to one logical volume, or subset of the writes from a</font><br>
<font class="QuotedText">&gt; specific filesystem, without running the risk of serious inconsistency problems</font><br>
<font class="QuotedText">&gt; due to the normal inability to write synchronously to a group of backing store</font><br>
<font class="QuotedText">&gt; devices. If you have a reliable, low overhead write intent log, you can avoid</font><br>
<font class="QuotedText">&gt; that problem, and do it right, degrading to flush the world mode when a </font><br>
<font class="QuotedText">&gt; persistent intent log is not available.  </font><br>
<p>
Well, old style write barriers have gone away - now there's just cache flushes <br>
(and FUA), which are much saner to handle.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 0:55 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/497145/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; It would also seem that the best way to run such a cache would be with a relatively tight integration with the raid layer, such that backing store devices are marked with metadata indicating the association with the cache device, so that the group of them can properly be reassembled after a hardware failure, possibly on a different system. The raid layer could then potentially use the cache as a write intent log as well, which is a big deal for raid 5/6 setups.</font><br>
<p>
<font class="QuotedText">&gt;I think if you're using bcache for writeback caching on top of your raid5/6,</font><br>
things will work out pretty well without needing any tight integration;<br>
bcache's writeback tries hard to gather up big sequential IOs, and raid5/6 will handle those just fine.<br>
<p>
Where tight integration would be nice would be if bcache can align the writeback to the stripe size and alignment the same way that it tries to align the SSD writes to the eraseblock size and alignment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 3:43 UTC (Tue)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/497150/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For that we wouldn't really need tight integration - you could conceivably just tell bcache the stripe size of the backing device, and it wouldn't consider partial stripes sequential with full stripes.<br>
<p>
But for that to be useful we'd have to have writeback specifically pick bigger sequential chunks of dirty data and skip smaller ones, and I'm not sure how useful that actually is. Right now it just flushes dirty data in sorted order, which makes things really easy and works quite well in practice - in particular for regular hard drives, even if your dirty data isn't purely sequential you're still minimizing seek distance. And if you let gigabytes of dirty data buffer up (via writeback_percent) - the dirty data's going to be about as sequential as it's gonna get.<br>
<p>
But yeah, there's all kinds of interesting tricks we could do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 22:34 UTC (Tue)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/497238/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But for that to be useful we'd have to have writeback specifically pick bigger sequential chunks of dirty data and skip smaller ones, and I'm not sure how useful that actually is</font><br>
<p>
That's certainly an important optimization for mixed random/sequential write workloads whose working set is larger than the SSD. To make best use of both kinds of disks, random writes should persist on the SSD as long as possible, whereas longer sequential writes should be pushed out quickly to make more room for random writes.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2012 1:52 UTC (Wed)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/497262/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you want the sequential writes to bypass the cache, which is what bcache does.<br>
<p>
If you can show me a workload that'd benefit though - I'm not opposed to the idea, it's just a question of priorities.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497297"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2012 7:35 UTC (Wed)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/497297/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well, you want the sequential writes to bypass the cache, which is what bcache does</font><br>
<p>
Oh, I didn't realize that. That should take care of most of it. There's probably still some benefit to sorting writeback by size, but I'm not sure whether it's worth the complexity.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497297/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor497729"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2012 13:54 UTC (Fri)
                               by <b>Spudd86</b> (guest, #51683)
                              [<a href="/Articles/497729/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another solution if you're using btrfs is to just set up a bcache for each btrfs device you want to use (Which is the only way it would work if you're using btrfs internal RAID, I suppose). Then your data is redundant always...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497729/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor497143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2012 23:56 UTC (Mon)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/497143/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Another interesting problem that comes with writeback caching is the</font><br>
<font class="QuotedText">&gt; implementation of barrier operations. Filesystems use barriers (implemented as</font><br>
<font class="QuotedText">&gt; synchronous "force to media" operations in contemporary kernels) to ensure that</font><br>
<font class="QuotedText">&gt; the on-disk filesystem structure is consistent at all times. If bcache does not</font><br>
<font class="QuotedText">&gt; recognize and implement those barriers, it runs the risk of wrecking the</font><br>
<font class="QuotedText">&gt; filesystem's careful ordering of operations and corrupting things on the</font><br>
<font class="QuotedText">&gt; backing device. Unfortunately, bcache does indeed lack such support at the</font><br>
<font class="QuotedText">&gt; moment, leading to a strong recommendation to mount filesystems with barriers</font><br>
<font class="QuotedText">&gt; disabled for now.</font><br>
<p>
I need to delete that from the wiki, it's out of date - it's only old style <br>
(pre 2.6.38) barriers that were a problem, because they implied much stricter <br>
ordering. Cache flushes/FUA are much easier, and are handled just fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 4:16 UTC (Tue)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/497151/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Do you mean the advice to mount filesystems with &ldquo;<tt>-o nobarrier</tt>&rdquo; is outdated?
      
          <div class="CommentReplyButton">
            <form action="/Articles/497151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 7:13 UTC (Tue)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/497156/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yep. I took it out of the wiki, no need anymore.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor497147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 2:42 UTC (Tue)
                               by <b>omar</b> (guest, #18331)
                              [<a href="/Articles/497147/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are there any plans to turn this into a module which can be used by something like a RHEL 2.6.32 kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor497172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 12:29 UTC (Tue)
                               by <b>arekm</b> (guest, #4846)
                              [<a href="/Articles/497172/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"That device is formatted with a special marker, and its leading blocks are hidden when accessing the device by way of bcache."<br>
<p>
This would mean that I can't add ssd bcache to existing device/filesystem, right? Would be nice to be able to add and remove bcache when needed for a existing dev/fs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor507081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2012 16:30 UTC (Tue)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/507081/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"This would mean that I can't add ssd bcache to existing device/filesystem, right? Would be nice to be able to add and remove bcache when needed for a existing dev/fs."<br>
<p>
I believe if you've formatted your device ones for bcache you can still always add/remove a cache device. In other words, it should run just fine without any cache device.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/507081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Similar/related project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2012 16:35 UTC (Tue)
                               by <b>aorth</b> (subscriber, #55260)
                              [<a href="/Articles/497208/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cool!  I like the idea of using faster, less-reliable storage as a layer above slow, more-reliable storage.  On that note, another interesting read/write through cache is RapidDisk's RapidCache.  Check it out:<br>
<p>
<a href="http://rapiddisk.org/index.php?title=RapidCache">http://rapiddisk.org/index.php?title=RapidCache</a><br>
<p>
RapidCache uses RAM, so you can't cache AS MUCH, but it's probably faster... probably some scenarios where you'd want to use one or the other depending on your data set, applications, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Similar/related project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2012 6:01 UTC (Wed)
                               by <b>Rudd-O</b> (guest, #61155)
                              [<a href="/Articles/497291/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
RapidCache does exactly what the LRU block cache already does.  There is no gain in fixing and setting aside an amount of RAM to do RapidCache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Similar/related project</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2012 10:42 UTC (Wed)
                               by <b>aorth</b> (subscriber, #55260)
                              [<a href="/Articles/497322/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Ok, it's a bit over my head, but I'd imagine there must be <em>some</em> benefit to RapidCache.  Surely the developer had a legitimate reason to warrant developing it?
      
          <div class="CommentReplyButton">
            <form action="/Articles/497322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor497290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2012 5:59 UTC (Wed)
                               by <b>Rudd-O</b> (guest, #61155)
                              [<a href="/Articles/497290/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seriously,<br>
<p>
Compared to the ZIL and the L2ARC (both in ZFS and available now in-kernel for Linux), bcache is not even *remotely* close.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ZFS on Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2012 9:02 UTC (Wed)
                               by <b>abacus</b> (guest, #49001)
                              [<a href="/Articles/497308/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Has someone already published a comparison of the in-kernel <a href="http://zfsonlinux.org/">ZFS on Linux</a> and BTRFS ? Some people claim that <a href="http://rudd-o.com/linux-and-free-software/ways-in-which-zfs-is-better-than-btrfs">ZFS is better</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/497308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ZFS on Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 20, 2012 0:25 UTC (Sun)
                               by <b>jospoortvliet</b> (guest, #33164)
                              [<a href="/Articles/497909/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
no s* sherlock... ZFS is what, 5 years older? Yeah, it is probably still ahead in many scenarios...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 1:27 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/497454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would like to see something to back that up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor497387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2012 18:14 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/497387/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Next question.  Considering that there is a write back cache on persistent media, does that mean when the block layer issues a write cache flush (force unit access) command, that bcache synchronously forces the blocks to SSD, but _not_ synchronously to the backing store device?<br>
<p>
Assuming the cache is reliable and persistent, that is exactly what you want in most situations. If a higher level cache flush command actually forces a cache flush of a persistent write back cache, write back mode will be approximately useless.  You might as well just leave it in RAM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 1:29 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/497455/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that if you haven't been writeback caching _everything_ - i.e. your sequential writes have been bypassing the cache - you still need that cache flush to the backing device.<br>
<p>
If a mode where all writes were writeback cached and cache flushes were never sent to the backing device would be useful, it'd be trivial to add.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor497477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2012 6:30 UTC (Thu)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/497477/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is why the block layer really ought to support write "threads" with thread specific write barriers.  It is trivial to convert a barrier to a cache flush where it is impractical to do something more intelligent, but thread specific barriers are ideal for fast commits of journal entries and the like.<br>
<p>
In a typical journalling filesystem, it is usually only the journal entries that need to be synchronously flushed at all. Most writes can be applied independently. If a mounted filesystem had two or more I/O "threads" (or flows), one for journal and synchronous data writes, and one for ordinary data writes, an intelligent lower layer could handle a barrier on one thread by flushing a small amount of journal data, while the other one takes its own sweet time - with a persistent cache, even across a system restart if necessary.<br>
<p>
Otherwise, the larger the write cache, the larger the delay when a journal commit comes along.  Call it a block layer version of buffer bloat.  As with networking, other than making the buffer smaller, the typical solution is to use multiple class or flow based queues. If you don't have flow based queuing, you really don't want much of a buffer at all, because it causes latency to skyrocket.<br>
<p>
As a consequence, I don't see how write back caching can help very much here, unless all writes (or at least meta data for all out of order writes) are queued in the cache, so that write ordering is not broken. Am I wrong?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/497477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor498551"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2012 11:58 UTC (Thu)
                               by <b>ViralMehta</b> (guest, #80756)
                              [<a href="/Articles/498551/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It looks close to the idea what Windows is doing when we attach USB drive, isn't it ? It uses USB drive's memory as extended RAM.... <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/498551/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor498965"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A bcache update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 27, 2012 18:22 UTC (Sun)
                               by <b>dev</b> (guest, #34359)
                              [<a href="/Articles/498965/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess it's dangerous until it supports barriers and can't be used for databases. Even standard FS can get corrupted on power failure...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/498965/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
