        <!DOCTYPE html>
        <html lang="en">
        <head><title>Theoretical vs. practical cryptography in the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/828705/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/828741/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/828705/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Theoretical vs. practical cryptography in the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 13, 2020</br>
           </div>
Shortly before the release of the 5.8 kernel, a <a
href="https://git.kernel.org/linus/f227e3ec3b5c">brief patch</a> to a
pseudo-random-number generator (PRNG) used by the networking stack was quietly
applied to the kernel.  As is the norm for such things, the changelog gave
no indication that a security vulnerability had been fixed, but that turns
out indeed to be the case.  The resulting controversy had little to do with
the original vulnerability, though, and everything to do with how
cryptographic security is managed in the kernel.  Figuring prominently in
the discussion was 
the question of whether theoretical security can undermine security in the
real world.
<p>
Port numbers assigned to network sockets are not an especially secure
item — they are only 16&nbsp;bits, after all.  That said, there is
value in keeping them from being predictable; an attacker who can guess
which port number will be assigned next can interfere with communications
and, in the worst case, inject malicious data.  Seemingly back in March,
Amit Klein reported a port-guessing vulnerability to the kernel's security
team; properly exploited, this vulnerability could be used to inject
malicious answers to DNS queries, as one example.
<p>
The source of the problem comes down to how the kernel selects port
numbers, which should be chosen randomly so as to not be guessable
by an attacker.  The kernel is able to generate random numbers that, as far
as anybody knows, are not predictable, but doing so takes time — more time
than the network stack is willing to wait.  So, instead, the networking
code calls <a
href="https://elixir.bootlin.com/linux/v5.8/source/lib/random32.c#L53"><tt>prandom_u32()</tt></a>,
which is a much simpler PRNG; it is effectively a <a
href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">linear-feedback
shift register</a>.  That makes it fast, but unsuited to
cryptographic operations; its output is a relatively simple function of its
state, so anybody who can figure out what its internal state is can predict
its output going forward.  Klein, it seems, was able to do exactly that by
observing the port numbers assigned by the kernel.
<p>
Since the problem results from an attacker having worked out the internal
state of <tt>prandom_u32()</tt>, an obvious way to address the problem is
to change that state, preferably before the attacker learns what it is.
The patch that was applied (written by Willy 
Tarreau) does this by mixing some random data into the pool used by
<tt>prandom_u32()</tt> on every interrupt.  This reseeding is also done
when process accounting is performed, just to ensure that it happens even
if no interrupts are coming in.  An attacker can figure out the internal
state just as easily as before but, the reasoning goes, by the time that
has been done and the information can be used, said state has changed.
<p>
<h4>The complaints</h4>
<p>
On August 4, Marc Plumb <a
href="/ml/netdev/aef70b42-763f-0697-f12e-1b8b1be13b07@gmail.com/">posted a
request</a> that Tarreau's patch be immediately reverted and rethought.
His concerns came down to this: "<q>it allows an attacker to determine the
state and [from] there [the] output of /dev/random. I sincerely hope that
this was not
the intended goal&nbsp;:)</q>".  Since <tt>/dev/random</tt> is the kernel's
"real" random-number generator, compromising its state could lead to far
worse consequences than guessable port numbers; that was indeed not
anybody's intended goal.
<p>
Perturbing the state of <tt>prandom_u32()</tt> doesn't seem like something
that could wreck the security of an unrelated random-number generator, so
it is worth looking into the specifics of the complaint.  Those were best
<a href="/ml/netdev/20200808152628.GA27941@SDF.ORG/">explained</a> by
George Spelvin (a pseudonym associated with a long-time occasional kernel
developer).  In short: an attacker might be able to work out the value
of the additional random bits, and those same bits are fed into the
kernel's main entropy pool.
<p>
As Spelvin explained, the motivation for adding noise to the PRNG's state is
a fear that an attacker may know the current contents of that state.  An
attacker with that knowledge can, obviously, predict the future "random"
values that will be generated by the PRNG.  If you inject <i>k</i> bits of
random data into the PRNG, the attacker will lose that knowledge — to an
extent.  But, if <i>k</i> is sufficiently small, this attacker can simply
try the PRNG with all 2<sup><i>k</i></sup> possibilities and see which one
corresponds to the actual observed output.  Once that has
been done, the attacker has determined the value of those <i>k</i> bits and
regained knowledge of the PRNG's internal state.
<p>
That might be bad enough, suggesting that the fix that was applied may be
ineffective at actually closing the vulnerability.  The other part of the
complaint, though, is that the 32&nbsp;bits applied to the PRNG come from
the "fast pool", which can be thought of as a sort of queue of random bits
waiting to be fed into <tt>/dev/random</tt>.  These bits are not removed
from the fast pool; they are still, eventually, used to add entropy to the
primary random-number generator.  This, it is argued, gives the attacker
insight into the kernel's real random numbers and might compromise the
random-number generator entirely.
<p>
There is general agreement in the kernel community that such a compromise
is highly unlikely to lead to anything good.  That is where the agreement
stops, though.
<p>
If nothing else, Spelvin argued, the injection of random data into the PRNG
must be done in a way that does not allow the guessing of that data.  In
practice, that means making <i>k</i> sufficiently large that a brute-force
attack to calculate <i>k</i> bits becomes impractical; this "catastrophic
reseeding" makes the use of that data safer.  Even better, of course, would
be to replace the simple PRNG with something that does not so readily
expose its internal state.
<p>
<h4>Responses</h4>
<p>
Tarreau <a href="/ml/netdev/20200808174451.GA7429@1wt.eu/">responded</a>
that the assumption that the attacker knows the PRNG state is not
warranted; the purpose of adding the noise was to make guessing that
state much more difficult.  If the time required to calculate the PRNG's
internal state is longer than the time between perturbations, there should
never be a point where the attacker truly knows that state.  If that is
true, then concerns about exposing the random bits added to the PRNG go
away.
<p>
He also <a href="/ml/netdev/20200805024941.GA17301@1wt.eu/">questioned</a>
the practicality of any attack on <tt>/dev/random</tt> even if those bits
<i>are</i> exposed:
<p>
<div class="BigQuote">
	I'd be particularly interested in seeing this reality demonstrated,
	considering that the whole 128 bits of fast_pool together count as
	a single bit of entropy, and that as such, even if you were able to
	figure the value of the 32 bits leaked to net_rand_state, you'd
	still have to guess the 96 other bits for each single entropy bit.
</div>
<p>
Linus Torvalds's <a
href="/ml/netdev/CAHk-=wiSw7zYVUxiGT=_TPx1fqtNNYgu0L6rC=GaSGpCDnDbVw@mail.gmail.com/">response</a>
was rather more direct and categorical:
<p>
<div class="BigQuote">
	I want to hear _practical_ attacks against this whole "let's mix in
	the instruction pointer and the cycle counter into both the
	'serious' random number generator and the prandom one".
<p>
	Because I don't think they exist. And I think it's actively
	dangerous to continue on the path of thinking that stable and
	"serious" algorithms that can be analyzed are better than the one
	that end up depending on random hardware details.
</div>
<p>
More generally, he said, the insistence on theoretical security has often
had the effect of making the kernel <i>less</i> secure, and he had a number
of examples to cite.  The random-number generator traditionally blocked in the
absence of sufficient entropy to initialize it, causing users to avoid it
entirely; this issue was only <a href="/Articles/808575/">addressed</a> in
late 2019.  The insistence that only "analyzable" entropy sources could be
used to feed the random-number generator has led to systems with no sources
of entropy at all, resulting in vast numbers of embedded devices having the
same "random" state.  And more; the whole message merits a read.
<p>
This same problem, he <a
href="/ml/netdev/CAHk-=wh00nvUwT-yck2gt3eKgix-mBZ4RcGe1WJ6C5VDW4e6zw@mail.gmail.com/">added
later</a>, delayed the resolution of the port-number-guessing problem:
<p>
<div class="BigQuote">
	And that was actually reported to us back in early March.

	Almost five months later, nothing had been done, all the discussion
	bogged down about "theoretical randomness" rather than to actual
	real-life security.
</div>
<p>

The addition of noise, he said, can also be useful in the face of a
Meltdown-style vulnerability.  In that case, an attacker may well be able
to read out the state of the random-number generator, but the regular
mixing of noise should limit the usefulness of that information.  In
general, adding noise is the opposite of the "analyzability" that (he
argues) crypto people want, and that is a good thing.  It is better, he
said, if the internal state of any random-number generator is not
susceptible to analysis.  Torvalds was quite clear that he would entertain
no patches addressing theoretical problems.
<p>
<h4>Where to from here</h4>
<p>
It seems evident that the patch in question will not be reverted anytime
soon; that would require the demonstration of a practical attack, and it is
far from clear that anybody can do that.  So, for now, port numbers
generated by Linux should be a bit harder to guess and, presumably, the
random pool as a whole remains uncompromised.
<p>
That said, nobody felt the need to defend the simple PRNG that underlies
<tt>prandom_u32()</tt> now; the door is clearly open to replacing it
outright if a suitable alternative can be found.  That alternative would
have to be something that does not make guessing its internal state so
easy, but it would also have to retain the performance characteristics of
the current implementation.  Torvalds has proclaimed that he will not
accept a replacement that slows things down.
<p>
Spelvin has <a
href="/ml/netdev/20200809065744.GA17668@SDF.ORG/">proposed</a> a
replacement described as "<q>a homebrew cryptographic PRNG based
on the SipHash round function, which is in turn seeded with 128 bits
of strong random key</q>"; Tarreau played with it some and
discussions over how to improve it have been ongoing.  Tarreau  also <a
href="/ml/netdev/20200806063035.GC18515@1wt.eu/">said</a> that he is
working on a replacement based on the <a
href="https://arxiv.org/pdf/1704.00358.pdf">Middle Square Weyl Sequence
random-number generator [PDF]</a>, but no patches have been posted yet.
<p>
Meanwhile, Ted Ts'o, the maintainer of the kernel's random-number
generator, has <a
href="/ml/netdev/20200805220550.GA785826@mit.edu/">expressed worries</a>
that perhaps <tt>prandom_u32()</tt> is being used in places where it
shouldn't be:
<p>
<div class="BigQuote">
	That being said, a quick "git grep prandom_u32" shows that there
	are a *huge* number of uses of prandom_u32() and whether they are
	all appropriate uses of prandom_u32(), or kernel developers are
	using it because "I haz a ne3D for spE3d" but in fact it's for a
	security critical application is a pretty terrifying question.  If
	we start seeing CVE's getting filed caused by inappropriate uses of
	prandom_u32, to be honest, it won't surprise me.
</div>
<p>
Replicating that grep suggests that there are nearly 500 call sites to be
worried about — and that doesn't count any BPF programs in the wild using
<tt>bpf_get_prandom_u32()</tt>.  Replacing <tt>prandom_32()</tt> might help
to mitigate such concerns, but it will not eliminate them.  The whole point
of <tt>prandom_32()</tt> is that performance takes priority over security,
so if it is being used in places that require a proper random-number
generator, there may indeed be a need for some changes in the near future.
<p>
Overall, random-number generation remains a surprisingly difficult
problem.  It's hard to predict which issues will occupy kernel developers
in, say, 2030, but chances are good that random numbers will be one of
them.  Meanwhile, Linux has always been a bit of a battleground between
theoretically superior solutions and those that are deemed to work in
real-world situations; that, too, is unlikely to change anytime soon.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Random_number_generation">Security/Random number generation</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/828705/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor828773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2020 21:56 UTC (Thu)
                               by <b>mrecho</b> (guest, #53167)
                              [<a href="/Articles/828773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What&#x27;s interesting is that there is __prandom_timer() that reseeds the state every so often. Could the __init be setup with the same thing? <br>
Or would that &#x27;random&#x27; re seeding cause issues?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor828774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2020 22:03 UTC (Thu)
                               by <b>jkingweb</b> (subscriber, #113039)
                              [<a href="/Articles/828774/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nicely concise summary. My compliments to the chef. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor828778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would appreciate review of the language used</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2020 23:32 UTC (Thu)
                               by <b>ms-tg</b> (subscriber, #89231)
                              [<a href="/Articles/828778/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I noticed yesterday that the discussion between Linus and George Spelvin included some *heated* language, including “FFS” and “idiot”.<br>
<p>
Given how recently the terms of respectful discussion of the Linux kernel were a focus of articles at LWN, I was wondering if it might benefit all of us to also write an article reviewing the tone and forms taken in this discussion, in addition to this excellent coverage of the substance of it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would appreciate review of the language used</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 18:58 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/828834/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linus is an engineer - to him the correct question is &quot;does it work&quot;.<br>
<p>
Is George Spelvin a theoretician?<br>
<p>
I guess George was simply refusing to see Linus&#x27; point of view that it&#x27;s no point having a system that doesn&#x27;t work. I have the same problem with filesystem devs, especially the transition from ext3 to 4 ... by accident 3&#x27;s journal made sure that the CONTENTS of files were saved. 4 changed that. The filesystem guys&#x27; arguments seemed to be &quot;but we can get the computer up and running quicker if we don&#x27;t care about the contents&quot;. But if you DON&#x27;T KNOW whether the user&#x27;s data has been corrupted, a few minutes less booting the system is most definitely NOT a worthwhile tradeoff against having to run a data restore or integrity check over a multi-terabyte database ...<br>
<p>
At the end of the day, the point of the computer is not to run the operating system - it&#x27;s to do jobs for users, and unlike a lot of computer guys Linus doesn&#x27;t forget that. That&#x27;s why linux has conquered pretty much everything except the desktop - and that&#x27;s why MS is so hard to dislodge from the desktop, because they know that too ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828851"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would appreciate review of the language used</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 15:38 UTC (Sat)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/828851/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
George is not just a theoretician. I&#x27;ll disclaim that I actually don&#x27;t know him personally, but from his comments he comes across as someone who understands both the engineering and the theory. His position seems to be that it&#x27;s not that hard to do the right thing anyway, so why bother with some half-baked code. He&#x27;s certainly not proposing a &quot;system that doesn&#x27;t work&quot;.<br>
<p>
And let&#x27;s please not rehash the ext3 vs ext4 flamewar.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828851/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor828843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would appreciate review of the language used</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 6:34 UTC (Sat)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/828843/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So like a ranked list of who was more abusive?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor828844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would appreciate review of the language used</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 7:22 UTC (Sat)
                               by <b>ragnar</b> (guest, #139237)
                              [<a href="/Articles/828844/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think a review of one particular discussion is that useful. What would be very interesting though is an analysis of if there has been an improvement in the tone and language used since the adoption of the CoC. And perhaps even more importantly if there has been an improvement in how welcoming the community is to new contributors of all colors and shapes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Would appreciate review of the language used</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 12:29 UTC (Mon)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/830048/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is why people were so upset about the imposition of a code of conduct in the first place: what was supposedly to be introduced to handle sexism, racism, extremely toxicity, extremely abusive language etc. was obviously going to be used to try to stop people from saying things like &#x27;FFS&#x27;.<br>
<p>
It&#x27;s an internet mailing list. People say &#x27;FFS&#x27; on internet mailing lists and have done since before I was born. Get used to it or get off the internet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor828783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 1:02 UTC (Fri)
                               by <b>robert.cohen@anu.edu.au</b> (subscriber, #6281)
                              [<a href="/Articles/828783/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One part of the complaint was &quot;the 32 bits applied to the PRNG come from the &quot;fast pool&quot;, which can be thought of as a sort of queue of random bits waiting to be fed into /dev/random. These bits are not removed from the fast pool; they are still, eventually, used to add entropy to the primary random-number generator.&quot;<br>
<p>
How hard would it be to remove the bits from the &quot;fast pool&quot; when they are added to prandom_u32. That way they wouldnt be added to both RNG&#x27;s.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 7:21 UTC (Fri)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/828790/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can&#x27;t really. The &quot;fast pool&quot; is 128 bits and any new information is &quot;mixed&quot; in, you can&#x27;t really &quot;unmix&quot; it.<br>
<p>
I also think the issue is way overblown. So 32-bits of this fast pool are used elsewhere. Even if they were completely exposed, it doesn&#x27;t help you with the other 96-bits and they are eventually mixed even more before being fed to the actual pool.<br>
<p>
If you require that all inputs to your random number generator be verifiably random then you have set your goals impossibly high as the article states. Entropy is a theoretical measure, there is no actual way to determine how random something actually is. You&#x27;d need to examine the entire multiverse and count the number of universes which are (apparently) identical except for those bits. A better approach seems to me to collect as much unpredictable data as you can and keep on mixing. Estimating the actual randomness is (IMHO) a fool&#x27;s game.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2020 4:36 UTC (Sun)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/828867/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As pointed out in the article, even if you can access and read the whole pool of 128 bits you have to be know exactly when it&#x27;s inserted in the RNG and time it all perfectly at each step.  There&#x27;s been plenty of news about how the RNG&#x27;s input data can be determined using various methods (like the RNG data pulled from the network port) but you still have the base problem of knowing exactly when that data is put in the RNG and to what program which RNG bit&#x27;s go and that just sounds like something that would be nearly impossible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 11:52 UTC (Mon)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/830057/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;You&#x27;d need to examine the entire multiverse and count the number of universes which are (apparently) identical except for those bits. &quot;<br>
<p>
Hold my beer ...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor828788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 2:45 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/828788/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How useful would a general RNG API be for cleaning this up? Call a function with some flags (secure/seedable/hardware), dial a minimum bandwidth and maximum read length, and the kernel either gives back some object that can satisfy those constraints or says no. The API user shouldn&#x27;t have to care or know what algorithm they&#x27;re using; when they do is usually when crypto stuff starts to go wrong.<br>
<p>
(I guess this would sound more appealing if we didn&#x27;t already have getrandom(2)…)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 18:47 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/828833/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Trouble is, if the kernel says &quot;no&quot;, how many applications will actually check for it?<br>
<p>
If a flag says &quot;wait until sufficient entropy is available&quot; how many people will use it anyway, and then wonder why their system fails to boot ... <br>
<p>
At the  end of the day if programmers don&#x27;t understand (or more likely bother to read) the documentation, ANY attempted fix is going to be a disaster.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2020 9:50 UTC (Thu)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/829660/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not so much a case of &quot;people don&#x27;t read documentation&quot;, after all &quot;no&quot; is not so spectacularly complicated.<br>
<p>
The real issue is that there is no reasonable response a program can make when it is told &quot;no&quot;.  If you asked for random, you need that random to continue, there is no way around that. You can read or write as much documentation as you want, but the situation doesn&#x27;t change.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor828836"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 19:49 UTC (Fri)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/828836/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This probably would not help because the main users of entropy on highly loaded system are TCP port generation and address space randomization.<br>
Both could easily use up all the available entropy for other high need users.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828836/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 21:04 UTC (Fri)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/828837/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This does not make sense. Entropy does not &quot;get used up&quot;. If the state of the csprng is unpredictable once, it will always be unpredictable (precluding any bugs that let you read the pool).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2020 22:38 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/828839/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, it depends.<br>
<p>
If the PRNG is not very secure, as in this case, then it is possible for an attacker to work out the PRNG&#x27;s state. Once a plausible adversary has the ability to determine the value of an input to the PRNG (i.e. its seed), then that seed is no longer unpredictable, and it is not unreasonable to call it &quot;used up&quot; in that case, particularly if the same seed has also been reused for other purposes under the assumption that it was unpredictable. However, this characterization is problematic, because it encourages the (wrong) assumption that generating N bits of random data &quot;uses up&quot; f(N) bits of input entropy for some f() - which is certainly not the case with a proper CSPRNG. This was the whole problem with the random(4) interface randomly blocking for (in most cases) no good reason.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor828841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 3:06 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/828841/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And here we have theory vs practice again.  There are a lot of users of randomness, many of them are themselves cryptographic.  The vast majority of them would like to use “new” random bits that have not been used elsewhere, and they do not want them generated by a prng that was seeded once and left to run.<br>
<p>
The idea of reseeding (/mixing in new entropy in to) a prng, by the way, is much like the idea of re-keying in cryptography.  It resets the search space for anyone trying to crack it.  But if only one bit was added...?  So we *have* to try to measure entropy.<br>
<p>
What if we made heavy use of a source that turns out to be predictable or mostly predictable?  The effective state space of the prng seed is dramatically reduced.<br>
<p>
You say if the state of a prng is not known it doesn’t get easier to crack as its use continues.  Given this, why does anyone ever rekey in cryptography?  There are in fact many cryptographic attacks that require large quantities of cypher text (obviously with the same key).  So, you rekey a lot, whether or not you know such an attack exists.  Same for the prng handling ‘random‘.<br>
<p>
So, we *have* to try to measure/guess entropy of our inputs - attackers certainly will.  And, sure, we can’t do it perfectly, but we can get a decent idea of how predictable things are in practice, and use that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 13:55 UTC (Sat)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/828848/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So, we *have* to try to measure/guess entropy of our inputs - attackers certainly will. </font><br>
<p>
I don&#x27;t see how this follows. Since entropy is only additive there is no reason not to simply include any and every piece of data that could possibly contain some entropy. For attackers it might be interesting to try and estimate the entropy, but for the system (Linux in this case) the only useful tactic is to be adding entropy faster than an attacker can constrain the search space.<br>
<p>
Rekeying in data streams is indeed for resetting the search space. For a CSPRNG this means adding entropy equal to the size of the internal state. However, unlike in a data stream you don&#x27;t actually need to know or care when this happens. There&#x27;s no actual reason to be trying to estimate the entropy since it doesn&#x27;t actually make a difference.<br>
<p>
So throw in the block numbers of data being read from disk. Do they contain entropy? Who knows? Let a theoretical attacker worry about it. We&#x27;ve at least wasted their time having to think about it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 18:38 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/828860/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And if the &quot;addition&quot; algorithm is not transitive ( ie OldSeed + LBA1 + LBA2 != OldSeed + LBA2 + LBA1), then we&#x27;ve thrown yet another randomness into the system, namely what has the i/o elevator done to the order of writes. Seeing as, if done at a low-enough level, this depends on the location of the disk heads as the system tries to optimise read or write accesses, this will be *horribly* hard for an attacker to predict ... :-) It depends on SO many system-specific quirks (including what other programs happen to be accessing the disk at the time ...).<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2020 5:37 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/828869/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ever since Spectre, I&#x27;ve become increasingly wary of the &quot;no reasonable attacker&quot; line. It&#x27;s the &quot;no true Scotsman&quot; of computer security. The reality is that attackers are a lot smarter than we often give them credit for. And setups are also a lot more predictable than we tend to assume. For example, take a server farm with 10k machines, all physically identical, plugged into the same network, etc., and then run 30k (untrusted) guest VMs on those 10k machines. Are you really, truly sure that the post-mixing entropy on one of those VMs will display no correlation whatsoever with the entropy of another? Of course, many companies actually use this business model (with different numbers), so this is not at all theoretical. Those companies, and their clients, want cryptographic security, not a handwavy &quot;it&#x27;s probably good enough&quot; argument on LKML.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829640"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2020 20:04 UTC (Wed)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/829640/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 Each of those vm will use network. Each hypervisor host will use network. The difference on frame timings due to different cable length and port order is enough to cause change in the event order in the kernel. I really, really would like to see a server farm with trully identical timings with disregard of hardware topology and speed of light in copper.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829640/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor828881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2020 18:55 UTC (Sun)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/828881/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you&#x27;re missing what the crypto guys are actually saying. They&#x27;re not saying don&#x27;t mix in low-entropy or unknown-entropy inputs at all. They&#x27;re saying, don&#x27;t do it too often, and don&#x27;t reuse those bits.<br>
<p>
The reason to reseed any PRNG, CS or not, is because you are concerned about an attacker using some means to exfiltrate the state of the PRNG (for a non-CSPRNG, this might be as easy as observing a moderate number of outputs, an LFSR just requires observing a number of outputs that is proportional to the state size, for example).<br>
<p>
Given the scenario that reseeding is protecting against, adding small amounts of entropy at a time provides almost no additional security, and has two problems. Firstly, it effectively &quot;wastes&quot; that entropy: if you had waited to accumulate enough entropy and add it all at the same time, you could actually have gained security. Secondly, it actually reveals the bits you are mixing in to the attacker. If those bits are then also used later to seed a different PRNG, you&#x27;ve reduced the security of that PRNG as well, for no gain in security of the first one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2020 14:16 UTC (Mon)
                               by <b>ecree</b> (guest, #95790)
                              [<a href="/Articles/829462/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; adding small amounts of entropy at a time provides almost no additional security, and has two problems. Firstly, it effectively &quot;wastes&quot; that entropy: if you had waited to accumulate enough entropy and add it all at the same time, you could actually have gained security.</font><br>
<p>
Except that this isn&#x27;t actually true.<br>
<p>
Viewing the attack from the information-theoretical perspective, there is _no difference_ between &quot;mix in the entropy in dribs and drabs as you collect it&quot; and &quot;save it up until you can catastrophically re-seed&quot;: either you&#x27;re adding entropy faster than it leaks (in which case you&#x27;re fine) or you&#x27;re leaking state faster than you add entropy (in which case you&#x27;re screwed).<br>
<p>
The difference only appears when you consider the amount of work required to brute-force-invert the mixing function _if_ state is leaking fast enough to allow the information-theoretic attack; partial-state-extension on frequent small re-seedings adds up to less total work than one big re-seed because the 2^k factor dominates.<br>
<p>
Catastrophic re-seeding is thus important if your security depends on the cryptographic strength of your PRNG, but _not_ if your security depends on adding noise to the state faster than the attacker can obtain information to constrain that state (e.g. by observing outputs) — in which case cat reseed may actually _harm_ you by letting the attacker reach a greater partial state in the (longer) interval between re-seed events.<br>
<p>
<font class="QuotedText">&gt; for a non-CSPRNG, this might be as easy as observing a moderate number of outputs, an LFSR just requires observing a number of outputs that is proportional to the state size, for example</font><br>
<p>
From the information-theoretical perspective, the same is true of any PRNG, CS or no, because you can always enumerate all possible states and see which one matches.  Observing (on average) n consecutive outputs and doing O(n*2^n) work will crack an n-bit CSPRNG just fine.  The difference with the LFSR is that there&#x27;s a fairly easy &#x27;cryptanalysis&#x27; that lets you do it with much less work than brute force.<br>
<p>
One of the things that drove me crazy reading the original thread on netdev was the way some people (especially Spelvin) equivocated between the information-theoretical argument and the work argument.  Tbh it looked like taking the Schneier cat-reseed paper and cargo-culting it into some kind of panacea-cum-universal-necessity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor828853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 16:09 UTC (Sat)
                               by <b>imMute</b> (guest, #96323)
                              [<a href="/Articles/828853/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;You say if the state of a prng is not known it doesn’t get easier to crack as its use continues. Given this, why does anyone ever rekey in cryptography? </font><br>
<p>
One answer is damage mitigation.  If the encryption key gets leaked, how much data is immediately available?  <br>
<p>
<font class="QuotedText">&gt;What if we made heavy use of a source that turns out to be predictable or mostly predictable? The effective state space of the prng seed is dramatically reduced.</font><br>
<p>
That&#x27;s why you use more that one source of entropy.  Suppose you don&#x27;t trust RDRAND.  I say mix it into the entropy pool anyway and just don&#x27;t &quot;credit&quot; those bits.  So far I&#x27;ve not seen anyone show that an untrusted entropy source is capable of *reducing* entropy of the pool.<br>
It seems Linus is in a similar line of thinking - who cares if we can&#x27;t *prove* that all these things are secure, throw a shitload of them into the mix and make the attackers job *extremely* difficult.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2020 23:18 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/828863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So far I&#x27;ve not seen anyone show that an untrusted entropy source is capable of *reducing* entropy of the pool.</font><br>
<p>
There&#x27;s the idea shown in &quot;Prototyping an RDRAND Backdoor in Bochs&quot; (<a href="https://archive.org/stream/pocorgtfo03#page/n17/mode/1up">https://archive.org/stream/pocorgtfo03#page/n17/mode/1up</a>). If code does something like &quot;entropy_pool ^= RDRAND()&quot; to mix in the new randomness, a malicious implementation of RDRAND could return &quot;entropy_pool ^ x&quot; where x is a random-looking value that is known to the attacker, cancelling out all the previous entropy. To someone who doesn&#x27;t know x, the output of RDRAND would still look perfectly random, and the CPU is otherwise following the architecture specification perfectly (which makes it harder for users to observe any malicious behaviour).<br>
<p>
That&#x27;s probably not very useful in an emulator, because a malicious emulator could leak the content of entropy_pool in plenty of other ways, and it&#x27;s probably difficult in a physical CPU without affecting the timing or performance counters in a way that someone would eventually notice. But still, it means in principle RDRAND can reduce entropy without doing anything other than returning a carefully constructed value.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor828877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2020 16:23 UTC (Sun)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/828877/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There’s still an issue here:<br>
If you add a bunch of stuff that turns out to not be random, then you could make the state predictable if you didn’t get enough data with real randomness in.  Linus is having an argument of degree here - this stuff looks pretty random, let’s add it in.  He’s very much not suggesting you add ... whatever ... to the pool.<br>
<p>
Cryptography is hard; the idea that we can add whatever to the pool forever is a dangerous one (the possibility of deliberately tainted inputs noted above, for example).  I don’t think Linus is making that argument.  He’s arguing about where the fence goes, not about removing it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor828879"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2020 16:49 UTC (Sun)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/828879/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If you add a bunch of stuff that turns out to not be random, then you could make the state predictable if you didn’t get enough data with real randomness in.</font><br>
<p>
Umm, I don&#x27;t think that&#x27;s how it works at all. Adding a gigabyte of zeros to the pool doesn&#x27;t reduce the entropy in it at all. It doesn&#x27;t add anything either, but it doesn&#x27;t hurt.<br>
<p>
Tainted inputs are an issue, but that just means to need to add as many sources as you can find, and you have to be careful how you add things. If any untainted source is included you have basically made it infeasible for the attacker.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828879/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Theoretical vs. practical cryptography in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 20, 2020 4:43 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/829136/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; If you add a bunch of stuff that turns out to not be random, then you could make the state predictable if you didn’t get enough data with real randomness in.</font><br>
<p>
<font class="QuotedText">&gt; Umm, I don&#x27;t think that&#x27;s how it works at all. Adding a gigabyte of zeros to the pool doesn&#x27;t reduce the entropy in it at all. It doesn&#x27;t add anything either, but it doesn&#x27;t hurt.</font><br>
<p>
The original quote is in fact true, but does not mean what you think it means. If you didn&#x27;t get enough data with real randomness, then you could have a predictable state. This happens regardless of whether or not you also added a bunch of stuff that wasn&#x27;t random.<br>
<p>
The problem, therefore, is whether they should do something with the entropy accounting, not whether they should allow reusing the fast pool bits in this fashion at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor828899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">You can in fact &quot;add whatever to the pool forever&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2020 7:18 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/828899/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For example if you use an HMAC for your mixing primitive then an adversary doesn&#x27;t benefit at all by spewing &quot;a bunch of stuff that turns out not to be random&quot; as input.<br>
<p>
HMAC(oldState, &quot;Predictable stuff&quot;) -&gt; newState<br>
<p>
Doesn&#x27;t tell us anything about oldState or newState, even though we&#x27;re quite certain what &quot;Predictable stuff&quot; is. Worse, if we&#x27;re a traitor inside the machine we can&#x27;t usefully influence newState despite knowing exactly what oldState was and having total control over &quot;Predictable stuff&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">You can in fact &quot;add whatever to the pool forever&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 18:29 UTC (Wed)
                               by <b>tanriol</b> (guest, #131322)
                              [<a href="/Articles/830426/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m pretty sure that, unless special attention is paid to make mixing always preserve all information from the original pool state, that&#x27;s not the case.<br>
<p>
In the HMAC example, before the &quot;mixing&quot; you had an N-bit pool in one of the 2**N possible states and when mixing every input state becomes an output state. However, as multiple input states can become a single output state, the final number of possible state decreases after this operation. This looks like the birthday paradox setting, so I&#x27;d guess that a series of known random mappings applied to the pool can reduce the number of possible states to sqrt(2**N)  at most.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">You can in fact &quot;add whatever to the pool forever&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 11:31 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/830908/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Mmm. You can experiment with this by building a toy HMAC that uses a too small hash so that the numbers are tractable. My guess is that for non-trivial N this takes a very long time (lots of data you 100% control shoved in as &quot;random&quot;) to not do very much at all to the pool.<br>
<p>
I don&#x27;t see why a method that exploits this for real (on an actual HMAC with an actual N-bit pool) wouldn&#x27;t also work perfectly well to collide arbitrary hashes, which is not supposed to be practical. But maybe you can explain why it doesn&#x27;t do that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">You can in fact &quot;add whatever to the pool forever&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 12:11 UTC (Tue)
                               by <b>tanriol</b> (guest, #131322)
                              [<a href="/Articles/830909/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, looks like I&#x27;ve been unclear. On the other hand, I&#x27;m not a cryptographer so you&#x27;ve been right to double-check for yourself :-)<br>
<p>
In the original statement you said that spewing a bunch of something does not benefit the adversary *at all*. The way I understood that was that the N-bit pool still has N bits of entropy. That&#x27;s obviously not the case because the number of possible states goes down, and quick experiments with a really small toy HMAC confirm that (repeatedly running it causes the entropy to reduce from the original 16 bits to 8 or so, just as expected from the birthday paradox style configuration). To avoid that you need your primitive to be an (input-driven, obviously) permutation in the state space so that the number of states stays the same. There are constructions like this - IIUC, SHA3 uses one, unlike MD5/SHA1/SHA2 - but you need to pay attention to this.<br>
<p>
On the other hand, for collision attacks N/2 is already the baseline due to the birthday paradox, so by itself this effect does not provide any improvements over that - a hash resistant to collision attacks would also be resistant to this effect.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">You can in fact &quot;add whatever to the pool forever&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 10:00 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/831015/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, so you can get from N to N/2 (half the pool size) but no further? I guess I can see no intuitive objection to that and if you&#x27;ve done the experiment then it must be so. I agree that&#x27;s significantly weaker than my original claim though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
