        <!DOCTYPE html>
        <html lang="en">
        <head><title>Guest-first memory for KVM [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/949277/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/949838/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/949277/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Guest-first memory for KVM</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 2, 2023</br>
           </div>
One of the core objectives of any confidential-computing implementation is
to protect a guest system's memory from access by actors outside of the
guest itself.  The host computer and hypervisor are part of the group that
is to be excluded from such access; indeed, they are often seen as 
threat in their own right.  Hardware vendors have added features like memory
encryption to make memory inaccessible to the host, but such features can
be difficult to use and are not available on all CPUs, so there is ongoing
interest in software-only solutions that can improve confidentiality.  The
<a
href="/ml/linux-kernel/20231027182217.3615211-1-seanjc@google.com/">guest-first
memory patch set</a>, posted by Sean Christopherson and containing work by
several developers, looks poised to bring some software-based protection to
an upcoming kernel release.
<p>
Protecting memory from the host in the absence of encryption tends to rely
on address-space isolation — arranging things so that the host has no path
by which to access a guest's memory.  The protection in this case is less
complete — an overtly hostile host kernel can undo it — but it can be
effective against many host-side exploits.  Back in 2020, the <a
href="/Articles/835342/">KVM protected memory work</a> created a new
hypercall with which a guest could request that the host unmap a range of
memory in use by that guest; that would render the host system (at both the
kernel and user-space levels) unable to access that memory.  That work ran
into a number of problems, though, and never found its way into the
mainline.
<p>
The guest-first-memory work takes a similar approach, but it moves the
control to the host and reduces the available protection.  Specifically, it
adds a new KVM <tt>ioctl()</tt> command, called
<tt>KVM_CREATE_GUEST_MEMFD</tt>, that takes a size in bytes as a parameter
and returns a new file descriptor.  The operation is similar to <a
href="https://man7.org/linux/man-pages/man2/memfd_create.2.html"><tt>memfd_create()</tt></a>,
in that the returned descriptor refers to an anonymous file, with the
requested size, that lives entirely in memory.  The differences are that
this memfd is tied to the virtual machine for which it was created, and it
cannot be mapped into user space on the host (or into any other virtual
machine).  This memory <i>can</i> be mapped into the guest's "physical"
address space, though, with a variant on the usual KVM memory-management
operations.
<p>
With this operation, the hypervisor can allocate memory resources for a
guest without being able to access that memory itself.  That protects the
guest from having its memory contents disclosed or modified, either by
accident or by malicious behavior on the part of a (possibly compromised)
hypervisor.  Unlike some previous attempts (including KVM protected
memory), this operation does not take the affected memory out of the host
kernel's direct memory map.  Thus, while a guest using this memory is
protected from user-space threats on the host, it could still be attacked
by a compromised kernel.  The bar to a successful attack has been raised
significantly, but the protection is not total.
<p>
There are a number of advantages to using guest-first memory, according to
the patch description.  Currently, KVM does not allow guests to have a
higher level of access to memory than the hypervisor does; if memory is to
be mapped writable in the guest, it must be both mapped and writable in the
hypervisor as well, even if the hypervisor has no need to be able to write
that memory.  Guest-first memory, by dispensing with the hypervisor mapping
entirely, clearly gets around that problem.
<p>
Guest-first memory can also be useful in the presence of hardware-based
memory encryption.  Encrypted memory is already protected from access by
the hypervisor; should the hypervisor attempt to do so anyway, the CPU will
generate a trap, which is likely to lead to the hypervisor's demise.  If
that memory is not mapped into the hypervisor to begin with, though, it
cannot be touched by accident.  Unmappable memory can also be useful for
the development and debugging of hypervisors meant to work with
hardware-based confidential-computing features, even on hardware lacking
those features.
<p>
Longer term, this feature may also be useful for the management of
dedicated memory pools; a guest memfd could be set up on the pool without
the need for access from the host.  It could, perhaps, allow memory for
guest systems to be managed (on the host) without using <tt>struct
page</tt> at all, reducing overhead on the host and increasing the
isolation of that memory.  Also with an eye on the longer term, this patch
series creates a more general concept of a "protected virtual machine" that
is intended to be a container for confidential-computing mechanisms within
KVM. 
<p>
Meanwhile, though, guest-first memory has the downside that it <a
href="/ml/linux-kernel/20231027182217.3615211-15-seanjc@google.com/">cannot
be migrated</a>, meaning that host-side memory-management processes (such
as compaction) will have to work around it.  This limitation was seen as a
significant problem when KVM protected memory was under discussion, but it
has not been addressed in this series and will not be "<q>at least not in
the foreseeable future</q>".
<p>
Even so, Paolo Bonzini (the KVM maintainer) has <a
href="/ml/linux-kernel/80471c15-a37e-4129-8101-d30b8f73cb9f@redhat.com/">let
it be known</a> that he plans to apply this series after the 6.7 merge
window with the idea of getting it into linux-next and, later, pushing it
upstream for the 6.8 kernel release.  He also said that he intends to apply
the series to a future RHEL kernel, meaning that guest-only memory will
show up in an RHEL release at some point in the (presumably not too
distant) future.  That is still unlikely to happen, though, before
guest-only memory has landed in the mainline and the API has settled down.
<p>
Some settling may be required; this is a 35-part patch series adding nearly
3,000 lines of code, so it would not be surprising if, even after
13&nbsp;revisions, there were some adjustments needed.  Still, it looks
like progress is being made on a multi-year effort to increase the amount
of address-space isolation afforded to guest systems.  With luck, users of
shared cloud systems (of whom there are a lot) will all benefit from this
sort of hardening.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Confidential_computing">Confidential computing</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Address-space_isolation">Memory management/Address-space isolation</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.8">Releases/6.8</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/949277/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor949887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 17:15 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/949887/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  The differences are that this memfd is tied to the virtual machine for which it was created, and it cannot be mapped into user space on the host (or into any other virtual machine). This memory can be mapped into the guest's "physical" address space, though, with a variant on the usual KVM memory-management operations. </span><br>
<p>
Just to complicate things further, guestmemfd _files_ are tied to the VM but there are plans to allow moving the _inode_ from one VM to another (with only one of file being usable at a given time). This is needed for in-place upgrade of the userspace process that runs the VM.<br>
<p>
Also, protected KVM will probably want to mmap() parts of the memory into the host virtual address space. However, most of the memory will be private to the VM and will cause a SIGSEGV if accessed from the host.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor950022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 12:15 UTC (Fri)
                               by <b>spacefrogg</b> (subscriber, #119608)
                              [<a href="/Articles/950022/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have never understood what is the actual attack scenario that these kinds of measures want to defend against.<br>
<p>
When I, as a tenant, want to run code in a rented guest, I still have to trust the host system. There is simply no way to deliver the secret key into the guest system and making sure the host is unable to spy or manipulate. And the guest will need a secret key or there is no encrypted guest memory to begin with.<br>
<p>
Is this about plausible deniability of the hoster against law enforcement? This also only goes so far. Several jurisdictions require that a hoster must provide lawful interception interfaces.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 12:25 UTC (Fri)
                               by <b>danpb</b> (subscriber, #4831)
                              [<a href="/Articles/950023/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  When I, as a tenant, want to run code in a rented guest, I still have to trust the host system. There is simply no way to deliver the secret key into the guest system and making sure the host is unable to spy or manipulate. And the guest will need a secret key or there is no encrypted guest memory to begin with.</span><br>
<p>
Confidential computing provides way to boot the guest with encrypted memory, validate the integrity of that guest, and then securely released secrets to the guest without the host having any ability to spy them. This will greatly reduce the amount of trust that needs to be placed on the host and/or cloud in general.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 13:41 UTC (Fri)
                               by <b>bluca</b> (subscriber, #118303)
                              [<a href="/Articles/950032/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It will also be possible to encrypt a VM against the public key of the TPM of a specific instance, that the cloud vendor won't have access to, so that even the provisioning process can be protected<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 14:10 UTC (Fri)
                               by <b>spacefrogg</b> (subscriber, #119608)
                              [<a href="/Articles/950065/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's complete nonsense, I am sorry for being so direct. A tenant has no way of verifying that the hoster actually provided the public key of the TPM. For this, he would need physical access to the host. He still needs to trust the hoster completely. The easiest counter-argument is, that qemu provides a soft-TPM for testing purposes. Tell me how the guest (or tenant) knows it is not running against that but rather a hardware TPM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 14:20 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/950070/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>Fundamentally, because the soft TPM will not have the expected public key.
<p>The hoster does not provide the public key to the tenant; the TPM vendor provides the public key to all and sundry, usually via a CA type system that verifies that the public key you're being offered is one from the TPM vendor (<em>not</em> the hoster). The TPM vendor also guarantees that the TPM, if installed correctly, will produce certain hashes of data that goes between the TPM and CPU during operation; if the hoster changes the hardware so that different data goes between the TPM and CPU, those hashes change.
<p>From this, we can build a setup where the hoster does not need to be trusted, but the TPM vendor and CPU vendor do. The CPU vendor guarantees that there will be certain exchanges between the TPM and the CPU, such that if it's a real TPM and not a soft TPM, the hashes the TPM will sign and disclose can be predicted. As the tenant, you can take those signed hashes, validate that the TPM's public key is signed by the TPM vendor's CA (so isn't compromised by the hoster), and then send a secret, encrypted using the TPM's private key if, and only if, the hashes match what you expect from the platform.
<p>If you want the gory details, look up how Intel TDX and AMD SEV work; they're not perfect (implementations are buggy), but the mathematics of the verification side work out, and reduce the trust domain from "hoster + CPU maker + TPM maker" to "CPU maker + TPM maker".


      
          <div class="CommentReplyButton">
            <form action="/Articles/950070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 4:03 UTC (Sun)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/950252/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unless you're expecting a live human person to validate all these things, a malicious host can just re-write the memory of the guest OS and alter what it expects. Or just read the public key and expected hashes out of the guest's memory.<br>
<p>
An analog: when running malware that attempted to check if it was running in a VM, I would just open it up in a disassembler (perhaps after going through some unpacking steps), and patch the check for a VM to return false. No reason a host can't do this to a guest. There's some kind of integrity check on the code, you say? Well, patch that out too.<br>
<p>
The reality is you *have* to trust the host at some point.<br>
<p>
What this helps with is not a fully Byzantine malicious failure scenario, but, rather, a host that is trusted at startup, but is not trusted to remain trusted after.<br>
<p>
That is, it helps with a host that may eventually be compromised. As far as helping with a fully malicious host, this does absolutely nothing.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 5:30 UTC (Sun)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/950258/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Attestation to the guest would fail for the reasons you describe. That's why this generally involves remote attestation - the guest proves to something else that it's in a trustworthy state. So you have some infrastructure that *you* own that can verify the attestations from all your guest instances running in the cloud, which allows you to prove at least a subset of the state of that guest. Once you move onto something like SEV the attestation is coming from the CPU itself, at which point you have (in theory) entirely decoupled yourself from the cloud provider. And, well, if you can't trust the thing that's executing your instructions, it feels pretty difficult to say that anything is trustworthy (which is, of course, an entirely valid position!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor950273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 10:20 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/950273/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Note that a CPU that's designed for this also prevents the host from reading or writing the memory of the guest OS without the guest's co-operation (memory encryption). You still have to trust the CPU and the TPM, but that's better than having to trust the entire hosting platform.
<p>And yes, the attestation has to be to something outside the guest; but the idea is that I can stand up a microserver in my office, which I can trust because I have full control of it, and then not have to trust the hosting company.


      
          <div class="CommentReplyButton">
            <form action="/Articles/950273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor950069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 14:15 UTC (Fri)
                               by <b>spacefrogg</b> (subscriber, #119608)
                              [<a href="/Articles/950069/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Tell me how, please, I want to believe! Yet, nobody could show me how to securely deliver the initial secrets. As it stands, you are merely citing the deus ex machina. I'd like to see it one time.<br>
<p>
Telling me that confidential computing works by confidential booting, tells me nothing. Especially, when I need to suspect that confidential booting needs confidential computing itself in order to be set up securely, in which case we have come full circle in our argument.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 23:57 UTC (Fri)
                               by <b>stefanha</b> (subscriber, #55072)
                              [<a href="/Articles/950168/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Look into remote attestation. The guest cannot establish trust itself (for the reasons you described), but it's possible to establish trust remotely using an entity not under the hoster's control.<br>
<p>
I don't know the details, but my understanding is that remote attestation works because only the TPM/CPU vendor has the private key underpinning the attestation report. Therefore the hoster cannot forge the attestation report.<br>
<p>
This allows a remote entity to conclude that the environment hasn't been tampered with. Together with the CPU protections (memory encryption, virtualization instruction set for confidential computing, etc) that stop the hypervisor or host kernel from accessing the guest, it becomes possible to trust that the host does not have access to the guest...until design or implementation flaws break the whole thing again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 4:07 UTC (Sun)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/950253/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given that every interaction the guest has with any input is mediated by the host, and a fully malicious host has the ability to rewrite any code or memory in the guest, remote attestation of any type is merely just another hoop a malicious host has to jump through to trick the guest.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 5:39 UTC (Sun)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/950259/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a few layers to this. Yes, a hostile hypervisor can either modify the state of a guest or misconfigure security state such that another piece of hardware can do so. But think of attack surface here - there's a lot more to a cloud environment than just the hypervisor. The entire control plane is full of things that have security implications (you say "Boot this image", the control plane actually boots a backdoored version instead). And there are many more people with the ability to commit code to a public cloud provider's control plane than there are able to modify the hypervisor. Measured boot gets you to the point where you don't have to trust the control plane any more, and that's already a large reduction in attack surface.<br>
<p>
But sure what if the hypervisor *is* hostile? That's what things like AMD's SEV and Intel's TDX are meant to achieve. The CPU knows whether it's executing in the context of the hypervisor or a guest. So, when a customer requests it, the hypervisor asks the CPU to generate a memory encryption key, and the CPU gives an opaque encrypted version of this key to the hypervisor. Whenever control is passed to the guest, the hypervisor gives the CPU that key, and the memory controller transparently encrypts or decrypts all memory accesses. Any event that passes control back to the hypervisor will trigger a context switch that the CPU is aware of, and so it stops doing that. The hypervisor has no way to view guest memory, and no way to modify it in any sort of predictable way. And since in this case the initial remote attestation comes from the CPU, it can prove that the guest is in this state and the hypervisor has no way to interfere with that.<br>
<p>
Obviously we're still trusting the CPU, and so if when you say "a fully malicious host" you're taking into account the possibility that the CPU vendor backdoored the chip before shipping it, yes, that could still be an issue. But before you were trusting your CPU vendor *and* your cloud vendor, and now you only need to trust your CPU vendor, so it's still an improvement.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 19:49 UTC (Sun)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/950295/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You still need to trust that the hosting entity is not physically tampering with the CPU, as neither SEV-SNP nor TDX include physical tamper protection.  There is even a glitch attack that allowed completely compromising SEV-SNP by taking over the AMD Secure Processor.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor950445"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2023 16:07 UTC (Mon)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/950445/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds to me like all you would need is a stolen key at the TPM vendor to break that whole system permanently since there is no way to get from a compromised key to a secure state again and so the TPM likely has no way to update the key.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950445/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2023 17:17 UTC (Mon)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/950456/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The TPM vendor never sees any private keys generated on the TPM, they just provide certificates for them (same as how CA vendors never see client private keys). Those certificates can be revoked and are stored in nvram so can also (in theory) be updated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor950318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2023 1:26 UTC (Mon)
                               by <b>stefanha</b> (subscriber, #55072)
                              [<a href="/Articles/950318/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; a fully malicious host has the ability to rewrite any code or memory in the guest</span><br>
<p>
This is incorrect. See the "CPU protections (memory encryption, virtualization instruction set for confidential computing, etc) that stop the hypervisor or host kernel from accessing the guest" that I mentioned. mjg59's paragraph about AMD SEV and Intel TDX describes them more.<br>
<p>
That said, confidential computing isn't a silver bullet so I think you're right that it's another hoop that a malicious host needs to jump through. There will still be security holes in implementations and sometimes in the specific design for a given system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor950161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 22:19 UTC (Fri)
                               by <b>neggles</b> (subscriber, #153254)
                              [<a href="/Articles/950161/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's about protecting the guest from a *compromised* host, i.e. in the event of another guest using a hypervisor escape exploit, other guests would still be safe<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 4:08 UTC (Sun)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/950254/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This, exactly. Compromised after a trusted boot.<br>
<p>
But a fully malicious host? Yeah, this isn't going to do anything.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor950033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 13:41 UTC (Fri)
                               by <b>bluca</b> (subscriber, #118303)
                              [<a href="/Articles/950033/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is great, especially for being able to implement these workflows without letting the CPU manufacturers run the show<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor956106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guest-first memory for KVM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 25, 2023 6:16 UTC (Mon)
                               by <b>wenqian</b> (guest, #162897)
                              [<a href="/Articles/956106/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
“That work ran into a number of problems, though, and never found its way into the mainline.”<br>
Has memfd_secret() not been merged into the kernel? why I found it exists in v6.7-rc6, refer to <a rel="nofollow" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sys_ni.c?id=ceb6a6f023fd3e8b07761ed900352ef574010bcb#n254">https://git.kernel.org/pub/scm/linux/kernel/git/stable/li...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/956106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
