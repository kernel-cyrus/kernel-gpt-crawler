        <!DOCTYPE html>
        <html lang="en">
        <head><title>Moving Google toward the mainline [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/871195/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/871391/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/871195/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Moving Google toward the mainline</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>October 5, 2021</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2021-Open_Source_Summit_North_America">OSSNA</a>
</div>
<p>
Two Google engineers came to <a
href="https://events.linuxfoundation.org/open-source-summit-north-america/">Open
Source Summit North America</a> 2021 to talk about a project to change the
way the company creates and maintains the kernel it runs in its data
centers on its production
systems. Andrew Delgadillo and Dylan Hatch described the current production
kernel (Prodkernel) and the problems that occur because it is so far from
the mainline.  Project Icebreaker is an effort to change that and to
provide a near-mainline kernel for development and testing within Google;
the talk looked at the project, its risks, its current status, and its plans.
</p>

<h4>Prodkernel</h4>

<p>
Delgadillo began the talk with
Prodkernel, which runs on most of the machines in Google's data centers;
those systems are used for handling search requests and "other jobs both
externally facing and internally facing", he said.
Prodkernel consists of around
9000 patches on top of an older upstream Linux kernel.  Those patches
implement various internal APIs (e.g. for Google Fibers), provide hardware
support, add performance optimizations, and contain other "tweaks that are needed
to run binaries that we use at Google".  Every two years or so, those
patches are rebased onto a newer kernel version, which provides a number of
challenges.  For one thing, there are a <i>lot</i> of changes in the kernel
in two years; even
if the rebase of a feature seems to go well, tracking down any bugs that
crop up involves a "very large search space".
</p>

<a href="/Articles/871984/">
<img src="https://static.lwn.net/images/2021/ossna-delgadillo-sm.jpg" border=0 hspace=5
align="right" alt="[Andrew Delgadillo]" title="Andrew Delgadillo" width=200
height=300>
</a>

<p>
There were some specific internal needs and timelines that drove the need
for Prodkernel, he said, which is why Google could not simply use the
mainline and push any of the extra features needed into that.  He gave some
examples of the features that are needed for Google's production
workloads but that are not available in the mainline; those included a need to
be able to set quality of service values from user space for outgoing
network traffic, to have specific rules 
for the out-of-memory (OOM) killer, and to add a new API for cooperative
scheduling in user space.
</p>

<p>
One of the big problems with Prodkernel is that it detracts from upstream
participation, he said.  Any features that Google creates for production are
developed and tested on Prodkernel, which can be as much as two years
behind the mainline kernel.  If the developer wants to
propose the feature  for the mainline, the Prodkernel model imposes two main hurdles.
For one, the feature needs to be rebased to the mainline, which may be a
difficult task when the delta between the versions is large.
Even if that
gets done, there is a question of the testing of the feature.  The feature
has been validated on Prodkernel with production workloads, but now it has been taken to a new
environment and been combined with  totally new source code.  That new
combination cannot be tested in production because the mainline lacks the
other features of Prodkernel.
</p>

<p>
Google's workloads tend to uncover  bottlenecks, deadlocks,
and other types of bugs, but the use of Prodkernel means that the
information is not really useful to others.  If Google is running something
close to an LTS stable kernel, for example, reporting the bug might lead
the team to a fix
that could be backported; generally, though, finding and fixing the bugs is
something that Google has to do for itself, he said.  In addition, any fixes are
probably not useful to anyone else since they apply to a years-old kernel.
Also, any bugs that have been fixed in more recent kernels do not
get picked up until either they are
manually found and backported or the next rebase is done.
</p>

<p>
The rebasing process is "extremely costly" because it takes away time that
developers could be working on other things.   Each patch has to have any
conflicts resolved with respect to the upstream kernel; it may well be that
the developer has not even looked at the code for a year or more since they
developed it, but they have to dig back in to port it forward.
Then, of course,
the resulting kernel has to be revalidated with Google's workloads.  Bugs
that are found in that process can be difficult to track down. Kernel
bisection is one way, of course, but conflicts from rebasing need to be
resolved at every step; that could perhaps be automated but it still makes
for a difficult workflow, he said.
</p>

<p>
The delay associated with the rebasing effort worsens the problems with
upstream participation, which makes the next rebase take that much more
time.  It is a pretty clear example of technical debt, Delgadillo said, and
it just continues to grow.  Each Prodkernel rebase increases the number of
patches, which lengthens the time it takes to do the next one; it is not
sustainable.  So an effort is needed to reduce the technical debt, which
will free up time for more upstream participation—thus further reducing the
technical debt.
</p>

<h4>Icebreaker</h4>

<a href="/Articles/871987/">
<img src="https://static.lwn.net/images/2021/ossna-hatch-sm.jpg" border=0 hspace=5
align="right" alt="[Dylan Hatch]" title="Dylan Hatch" width=200
height=300>
</a>

<p>
Hatch then introduced Project Icebreaker, which is a new kernel project at
Google with two main goals.  The first is to stay close to the upstream
kernel; the idea is to release a new Icebreaker kernel for every major
upstream kernel release.  Those releases would be made "on time, we want to
stay caught up with upstream Linux".   That will provide developers with a
platform for adding features that is close enough to the mainline that
those features can be proposed upstream.
</p>

<p>
The second goal is to be able to run arbitrary Google binaries in
production on that kernel. It would be "a real production kernel" that
would allow validating the upstream changes in advance of the Prodkernel
rebase.  Under the current scheme, Google has been "piling everything into
the tail end of this two-year period", he said.  With Icebreaker, that testing can
begin almost as soon as a new mainline  kernel gets released.
</p>

<p>
Those goals are important because the team needs "better participation
upstream".  Developers working on features for kernels far removed from
the current mainline have a hard time seeing the benefit of getting that
feature upstream.  There is a lot of work that needs to be done to untangle
the feature from Prodkernel, test it on the mainline kernel, and then
propose it upstream—all of which may or may not result in the feature being
merged.  The alternative is to simply wait for the rebase; time will be
made available to do that work, but once the new Prodkernel is
qualified, it is already too late for the feature to go upstream.
</p>

<p>
Having kernels closer to mainline will also help Google qualify and verify all
of the upstream patches that much sooner.  Rather than waiting until the
two years are up and doing a huge rebase and retest effort, the work can be
amortized over time
</p>

<h4>Structure</h4>

<p>
There are two sides to consider when looking at the structure of the
Icebreaker effort, he said.  On one side is how features can be developed
in order to get them deployed on an Icebreaker kernel.  On
the other is how those patches need to be upgraded in order to get them
onto a new mainline kernel for the next Icebreaker release. 
</p>

<p>
Icebreaker creates a fork from the mainline at the point of a major
release.  It adds a bunch of feature branches (also known as "topic
branches") to that, each of which is a
self-contained set of patches for one chunk of functionality that is being
added by Google.  That is useful in and of itself, because each of those
branches is effectively a patch series that could be proposed upstream; "so
you are starting with something upstreamable and not going the other way
around", Hatch said.
</p>

<p>
Development proceeds on those feature branches, with bug fixes and new
functionality added as needed.  Eventually, those feature branches get
merged into subsystem-specific staging branches for testing.  The staging
branches then get merged into a next branch for the release.  The next branch is
an Icebreaker kernel that is "ready to go, but it still has its roots in
these feature branches", he said.
After the release is made, a "fan-out merge into the staging branches" is
done, in order to synchronize them with the release version.  Importantly,
this fan-out merge is not done into the feature branches.  Those stay in a
pristine upstreamable state.
</p>

<p>
By following the life of one of these feature branches, we can see how the
upgrade process goes, he said.  When a new mainline kernel is released, a
new branch for the feature is created and the branch for the earlier kernel
is merged onto it.  The SHA1 values for the commits on the earlier feature
branch are maintained and the conflict resolution is contained in the merge commit.
</p>

<p>
Bug handling is easier with this workflow.  The bugs can be fixed on the earliest
supported feature branch where they occur and then merged into all of the successive
feature branches.  The SHA1 of the commit that introduced the bug and that
of the fix will remain the same on those other branches.  There is no need
to carry extra metadata to track the different fix patches in each of the
different supported kernel versions.
</p>

<p>
The Icebreaker model is much more upstream-friendly than the current
Prodkernel scheme, Hatch said.  The Icebreaker feature branches are done on an
up-to-date mainline kernel and they get tested that way, so the test
results are more relevant to upstream.  This will allow developers to
propose features for the mainline far more easily.
Much of the Icebreaker branch structure and the like can be seen in the
diagrams in the
<a href="https://static.sched.com/hosted_files/osselc21/f1/OSS%202021%20-%20Icebreaker.pdf
">slides</a> from the talk.
</p>

<h4>Risks</h4>

<p>
"There are some risks with Icebreaker, unfortunately", he said.  One of the
bigger ones is that there needs to be a lot of feature branch testing.
There may be a tendency to treat those branches like a file cabinet, where
patches are stored and merged into wherever they are needed. But that is
not useful if it is not known whether "it builds or boots or passes any tests".
</p>

<p>
Thus it is important to validate just the feature branch before merging it
elsewhere. If it is known that it was working before the merge, then any
subsequent breakage will have been caused by something in the merge.
Otherwise, it is just complicating 
the whole process to merge a feature in an unknown state into a new tree.
The same goes when upgrading to a new mainline kernel version, he said.
</p>

<p>
The dependencies between features could be a risk for Icebreaker as well.
The model is that features are mostly self-contained, but that is not
completely true; there are some dependencies.  They can range from APIs
being used in another feature to performance optimizations that are needed
for a feature to do its job correctly.  That could be handled by resolving
the dependencies on the staging branch, but those branches are not carried
along to the next Icebreaker kernel, only the feature branches are.
</p>

<p>
The answer is to do merges between feature branches, which does work, but
adds some complexities into the mix.  There is a need to figure out which
branches can be merged into each other. "How crazy can we let these merges
become?", he asked.  There are no rules for when two feature branches should simply be
turned into a single feature branch or when there is utility in keeping
them separate; those things will have to be determined on a case-by-case basis.
</p>

<p>
Another risk is that Icebreaker is much less centralized than the
Prodkernel process is.  Feature owners and subsystem maintainers within
Google will need to participate and buy into this new workflow and model.
They will need to trust that this new Icebreaker plan—confusing and complicated
in the early going—will actually lead to better outcomes and a reduction in
the technical debt.
</p>

<p>
The last risk that Hatch noted is that features in Icebreaker do actually
need to get upstream or it will essentially devolve into Prodkernel again.
If more and more patches are added to Icebreaker without a reduction from
some being merged due to features going upstream, the team will not be able
to keep up with the mainline.  The production kernel team needs to take
advantage of the fact that Icebreaker is so close to mainline and get its
features upstream.
</p>

<h4>Status and plans</h4>

<p>
Delgadillo took over to talk about the status of Icebreaker.  At the time of the talk,
it was based on the&nbsp;5.13 kernel, at a time when the 5.15 kernel is in
the release-candidate stage.  So the project is essentially one major
release behind the mainline, which is "a lot closer that we have ever
been". 
</p>

<a href="/Articles/871988/">
<img src="https://static.lwn.net/images/2021/ossna-delgadillo-hatch-sm.jpg" border=0 hspace=5
align="left" alt="[Dylan Hatch &amp; Andrew Delgadillo]"
title="Dylan Hatch (l) &amp; Andrew Delgadillo" width=266
height=400>
</a>

<p>
In the process, some 30 patches were dropped from the tree because they
were merged upstream.  Out of 9000 patches being carried, 30 may not sound
like a lot, he said, but it is a start.  It is not something that would
have happened without a project like Icebreaker.
The team is working on&nbsp;5.14 now and was able to drop 12 feature
branches as part of that.  Those were for features Google was backporting
from the mainline, but that does not need to be done for recent kernels.  That is
another reduction in the technical debt, he said. Hopefully that process will get
"easier and easier as we go along".
</p>

<p>
In addition, issues have been found and fixed, then reported upstream or
have been sent to the stable trees for backporting.  That is not something that
happened frequently with Prodkernel because it was so far behind the
mainline.  In general, they were build fixes and the like, he said, but
were useful to others, which is a plus.
</p>

<p>
Looking forward, Icebreaker plans to catch up to upstream at&nbsp;5.15 or&nbsp;5.16,
which will be a turning point for the project.  It will be "riding the
wave" of upstream at that point, which will allow "us to relax the cadence
at which we need to update our tree", he said.  One of the problems that has
occurred is that feature maintainers have had to rebase and fix conflicts
every three or four weeks as Icebreaker worked on catching up; in the
Prodkernel model, that would only happen every two years or so.  Once the project
has caught up, there will only need to be rebases every ten or so weeks,
aligned with the mainline schedule.
</p>

<p>
Testing the Icebreaker feature branches on top of mainline kernel release
candidates is also something the project would like to do.  That would
allow Google to participate in the release-candidate process and help test
those kernels.  Once Icebreaker is aligned with mainline, it will make
upstream development of features possible in a way that simply could not be
done with Prodkernel.
</p>

<p>
At that point, Delgadillo and Hatch took questions.  The first was about
the plans for Prodkernel: will there still be the giant, two-year rebase?
Hatch said that for now Icebreaker and Prodkernel would proceed in
parallel.  Delgadillo noted that Icebreaker is new, and has not necessarily
worked out all of its kinks. He also said that while Icebreaker is meant to
be functionally equivalent to Prodkernel, it may not be at parity
performance-wise.  It is definitely a goal to run these kernels in
production, but that has not really happened yet.
</p>

<p>
Readers may find it interesting to contrast
this talk with <a href="/Articles/357658/">one from the 2009 Kernel
Summit</a> that gives a perspective 
on how things worked 12 years ago.
</p>

<p>
[I would like to thank LWN subscribers for supporting my travel to Seattle
for Open Source Summit North America.]
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Google">Google</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Open_Source_Summit_North_America-2021">Open Source Summit North America/2021</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/871195/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor871998"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2021 23:05 UTC (Tue)
                               by <b>ndesaulniers</b> (subscriber, #110768)
                              [<a href="/Articles/871998/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Forking is a high-interest credit card of tech debt accumulation unless you can &#x27;outrun&#x27; upstream.<br>
<p>
There are cases where using the credit card make sense, but it&#x27;s easy to get into a case where you&#x27;re stuck paying off revolving balance without making a dent in principal.<br>
<p>
Getting prodkernel building with LLVM was an exercise in deja-vu; they weren&#x27;t using branches of stable, so we had to chase backports again that we had already done for Android and CrOS.  Makes me wonder how much duplicated effort goes into backports for distros not using stable...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871998/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 1:15 UTC (Wed)
                               by <b>tsoni.lwn</b> (subscriber, #139617)
                              [<a href="/Articles/872002/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How about Google use the GKI model for the Server development as well? Keep all the downstream features as modules and upstream them one by one while keeping the core kernel clean (not so clean w/ hooks but controlled). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 10:17 UTC (Wed)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/872014/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s not easy for e.g. core memory-management patches.<br>
<p>
BTW, I find it amusing that “the prod kernel” now seemingly has the name “Prodkernel”.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2021 4:50 UTC (Thu)
                               by <b>tsoni.lwn</b> (subscriber, #139617)
                              [<a href="/Articles/872092/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
GKI has &quot;tracehooks&quot; approach to make the &quot;core&quot; framework changes working through modules. Lot of vendors using GKI are already doing it including the scheduler and core memory framework changes. There may be very tiny penalty due to tracehooks depending on the path of the code.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor872012"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 9:28 UTC (Wed)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/872012/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thing about backports that I always wonder about is if the people demanding backports (instead of updating to upstream) realize that they are basically working with a new, untested version of the software anyway, one created by someone often not terribly familiar with the upstream project.<br>
<p>
This might make some sense with central, mature libraries in a stable distro but anything without major reverse dependencies (e.g. almost all binaries or other leaf nodes in the dependency graph) or with a very active development breaking APIs and ABIs all the time should not use the backport model.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872012/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 21:56 UTC (Wed)
                               by <b>gps</b> (subscriber, #45638)
                              [<a href="/Articles/872073/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &quot;&quot;&quot;people demanding backports (instead of updating to upstream) realize that they are basically working with a new, untested version of the software anyway&quot;&quot;&quot;</font><br>
<p>
This is the Linux Kernel project we&#x27;re talking about here. Upstream is effectively untested.<br>
<p>
Especially when compared to the real world testing needed before mass multi-billion dollar production use.<br>
<p>
&quot;It boots on my dev box and can compile a new kernel&quot; is not testing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872078"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 22:21 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/872078/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &quot;It boots on my dev box and can compile a new kernel&quot; is not testing.</font><br>
<p>
Just because the tests they run don&#x27;t include your particular workloads doesn&#x27;t mean something isn&#x27;t tested.<br>
<p>
(Over the years, the &quot;can it compile a new kernel&quot; has been a far more useful &quot;test&quot; than most synthetic stress tests..)<br>
<p>
Meanwhile, feel free to contribute your own test suite to those working upstream.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872078/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2021 15:43 UTC (Thu)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/872175/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Upstream is effectively untested.</font><br>
<p>
For what it&#x27;s worth, as one of the knfsd maintainers, I have a set of NFS-focused test suites (xfstests, connectathon, pynfs, a few smaller tests, run over a variety of NFS protocol versions and security flavors) that I run on anything that I publish.  I also run them nightly on the latest trees from Linus, stable, and linux-next, and a few other NFS developers.<br>
<p>
I&#x27;m by no means the most conscientious.  Maintainers do this kind of thing all the time.<br>
<p>
I also get pretty regular mail from bots run on mainline and linux-next, and their coverage seems to be improving over time.<br>
<p>
&quot;It boots on a dev box and can compile a new kernel&quot; isn&#x27;t really the current situation.<br>
<p>
I mean, I think I&#x27;m with you on the basic sentiment, testing is really important and we can and should do better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 4:59 UTC (Fri)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/872236/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One thing we learn very quickly when we try to use software to implement a production service is that there are two kinds of software:  software we tested, and software we haven&#x27;t tested yet.  We can say a lot of things about the first kind, like it definitely works for some things and definitely doesn&#x27;t work for other things, and various behaviors have changed in good and bad ways between versions.  We can define boundaries around what we do and don&#x27;t know about code behavior, and we can assess deployment risks based on empirical data.<br>
<p>
All we can say about the second kind of software is that it hasn&#x27;t been tested on our workload, so we don&#x27;t know any of those things.  Sure, it might have been tested by some group of domain-expert people, and certified by another group of accredited generalist people, and a third group of people with a lot of reddit upvotes swears it&#x27;s awesome, and some robots didn&#x27;t notice any of the more common problems--in fact, we&#x27;d insist on most or all of that before we bother downloading it for a test build.  None of that fancy pedigree matters if we throw our production app on it, and it immediately falls over because we&#x27;re doing something nobody else does.  If we&#x27;re providing a production service on a commercial scale with the software, it&#x27;s highly likely we&#x27;re doing something nobody else does.  Even if others start doing what we do, we&#x27;d write some new code and be doing something different again.  Maybe we&#x27;re doing something wrong, and our tests (and only our tests) will make the problem visible.<br>
<p>
The QA gatekeeper in front of the production server farm has one job:  keep the server farm producing at least whatever it is producing now.  They can keep running the kernel they already have, so they have no incentive to take risks that might jeopardize that.  The gatekeeper will not accept broad assurances of quantity testing--they&#x27;ll need to be *convinced* to upgrade, with evidence of monotonic improvement in the new versions, or dire and irreparable problems arising in the old versions.  &quot;Personally tested by the maintainer and a team of leading experts in the subsystem&quot; is an excellent start, but we&#x27;ll run our own test suite on it before we call it &quot;tested.&quot;<br>
<p>
At every node in the integration graph, from developer&#x27;s laptop to integration tree to merge window to release, LTS, and production deployment, someone is doing testing and deciding whether the code they pulled as input to their node is good enough to push to the output of their node (or in the case of testing robots, snooping on the edges between nodes and advising the node owners).  Every node must consider its inputs &quot;effectively untested,&quot; or the integration graph doesn&#x27;t work.  That&#x27;s the whole point of having an integration graph: to combine diverse and isolated pools of domain expertise into a comprehensive testing workflow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor872017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 12:25 UTC (Wed)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/872017/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;At the time of the talk, it was based on the 5.13 kernel, at a time when the 5.15 kernel is in the release-candidate stage. So the project is essentially<br>
one major release behind the mainline.&quot; and &quot;The team is working on 5.14 now.&quot;<br>
<p>
IMHO that&#x27;s too late: I&#x27;m working on v5.16. That is (at the time of the talk) v5.15-rc3 + lots of for-next branches from subsystems I care about.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 17:32 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/872047/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree it’s too late to be right for dev, but they’re trying to build a system where they can take this kernel in to production - that’s the one they’re talking about here.  And you’d never take this pile you’ve built in to production, even if it’s the right place to do dev.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 18:08 UTC (Wed)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/872052/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They also talk about the need to upstream some of their features. To do that efficiently, you have to be on top of the latest development kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 20:38 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/872065/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It only matters to be close enough. Patches written for 5.13 are easy to forward port to 5.16, and then they will be absorbed in the 5.16 rebase a few months from now.<br>
<p>
The team doing the rebases won&#x27;t even be the same that is doing the upstream contributions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 5:05 UTC (Fri)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/872239/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m sure you know this but, Depending on version of Android a user could be running kernel 2.xx to 4.xx. Android tends to uses really old kernels and the tech debt porting from 5.xx to 3.xx or even 4.xx is going to be huge. You might be easily able to port from 5.13 to 5.16 (because they are only a few months apart), but tell me it&#x27;s that easy to go from 5.13 to 4.13 or 3.13. <br>
<p>
The Pixel 5, up until a few weeks ago was the newest google headset and it uses 4.19. When it pulls down Android12 it might be slightly newer but I doubt it will even be in the 5 series kernels and that means years old, not months.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 6:49 UTC (Fri)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/872245/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The Pixel 5, up until a few weeks ago was the newest google headset and it uses 4.19. When it pulls down Android12 it might be slightly newer but I doubt it will even be in the 5 series kernels and that means years old, not months.</font><br>
<p>
I think Android 12 is using a 5.10 kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor873111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2021 6:29 UTC (Sat)
                               by <b>codewiz</b> (subscriber, #63050)
                              [<a href="/Articles/873111/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kernel support really depends on the SoC in your device. Each Android release supports a range of kernel versions.<br>
<p>
In theory it would be possible to &quot;uprev&quot; the kernel on a particular SoC, but most vendors just don&#x27;t bother because adding features to discontinued SoCs doesn&#x27;t help them sell more of their newer SoCs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/873111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor872079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2021 22:20 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/872079/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They’re compromising between these two things.  They’re not going to hit on the same answer as someone just doing dev.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor872093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2021 4:54 UTC (Thu)
                               by <b>tsoni.lwn</b> (subscriber, #139617)
                              [<a href="/Articles/872093/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn&#x27;t it a nightmare when you have to continuously apply the LTS updates every week on the production kernel which has 9000 patches modifying various core kernel changes? I am sure we will need Engineers just doing the merge conflict resolutions, talking w/ Engineers who wrote these patches, building and testing. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2021 7:01 UTC (Thu)
                               by <b>jonas.bonn</b> (subscriber, #47561)
                              [<a href="/Articles/872103/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What value of gc.rerereResolved do people use in practice? The default 60 days doesn&#x27;t seem sufficient... Or are merges redone often enough that the conflict resolutions get their cached age somehow reset? A bit of extra insight into the practical usage of git rerere for this would be of interest. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Embedded toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2021 16:27 UTC (Thu)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/872184/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The embedded world, with the move to extensive offloads, has much more technical debt accumulated, without a revenue stream and developers enabled to pay it down.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Embedded toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 11:58 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872257/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The embedded world doesn&#x27;t have a revenue stream?  I got my TV for free?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Embedded toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 1:18 UTC (Sun)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/872389/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Their software divisions are given enough budget to ship a product, not a robust product. You&#x27;re usually lucky to even get malicious compliance with the GPL2 on one of these things without fighting for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Embedded toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 1:21 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/872390/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly. There&#x27;s plenty of money; they&#x27;re just choosing not to spend it on software.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872627"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Embedded toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2021 8:11 UTC (Tue)
                               by <b>JanC_</b> (guest, #34940)
                              [<a href="/Articles/872627/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most hardware is no better than the software when it comes to doing just enough to get something to work (and often the software has to work around the hardware bugs).<br>
<p>
Most money is going to marketing, I suppose (and that’s probably necessary to get people to ignore the bad quality &amp; support they get).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872627/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor872255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 11:23 UTC (Fri)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/872255/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The link to 2009 was quite interesting to see where the kernel performance challenges were back then.  Things like the BadRam patches.  I remember that existed but I couldn&#x27;t say at all what happened to it in the end...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor873092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2021 21:01 UTC (Fri)
                               by <b>SomeOtherGuy</b> (guest, #151918)
                              [<a href="/Articles/873092/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the things Google have (I read this in one of their papers) is load averages which don&#x27;t count processes waiting for IO - I&#x27;d love that<br>
<p>
I did look at patching it, but load averages are surprisingly complicated - at least in implementation!<br>
<p>
<p>
(ADVICE WELCOME AND YES I&#x27;D LOVE THIS LOAD-AVERAGE - don&#x27;t question that please)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/873092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor873168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2021 9:43 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/873168/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Depending on your precise use case for a CPU-only load average, you might want to look at <a href="https://www.kernel.org/doc/html/latest/accounting/psi.html">Pressure Stall Information (PSI)</a> as a mainline feature that gets some of what you want.
<p>PSI is a different formulation of the load average concept - instead of looking at total utilization, it looks at how much time is spent with a task blocked completely on a resource. <a href="https://facebookmicrosites.github.io/psi/docs/overview">The Facebook PSI microsite</a> has a good explanation of how the different numbers are calculated; basically, though, the `avg` numbers are %age of the time on which either some tasks, or the full set of tasks, are blocked waiting for a given resource to be made available to them. As per the <a href="https://elixir.bootlin.com/linux/latest/source/kernel/sched/psi.c">source code comments</a>, for CPU time, <tt>full</tt> only exists when tasks are restricted from using 100% of available CPU via cgroups, but <tt>some</tt> is present all the time.
<p>A task is deemed stalled on a resource (CPU, memory, I/O) if the task would run now, but it's waiting for this resource. So, an I/O stall means that the task would be runnable if it wasn't waiting on I/O (whether via blocking I/O calls, or because it's blocked in epoll or the like on an I/O that's not yet completed), while a CPU stall means that the task is runnable, but none of the CPUs it's allowed to run on are idle.
<p>The clever bit is that what's output is stall percentage, not time in which there's a stall; so a value avgXXX=10.0 means that with 10% more of this particular resource (memory, I/O, CPU), there would have been no tasks waiting for resource. This matters when you see a CPU stall of the form "some avg60=10.00"; it means that with 10% more CPU cores, all tasks would have run immediately they were able to; similarly, a CPU stall of the form "full avg300=5.00" means that something limited a cgroup to not use all CPU cores, but if that limit had been raised by 5%, nothing would have waited for a CPU core.
<p>Not the same as a load average, but possibly of use to you in fixing whatever problem you're facing where a CPU-only load average is interesting.


      
          <div class="CommentReplyButton">
            <form action="/Articles/873168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor873172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving Google toward the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2021 10:38 UTC (Mon)
                               by <b>teksturi</b> (guest, #153896)
                              [<a href="/Articles/873172/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You should consider rolling release stable as your base.<br>
<p>
This way every time new rolling stable tag comes your feature branches will be rebased top of that (maybe to new branch). Then your feature maintainer will get info if there is conflict. Some of your maintainers will be little bit more far of from rolling release stable than others, but this will be totally ok. You can very easily see which are bottlenecks.<br>
<p>
You can at any time start new kernel internal kernel. Just choose highest version number which all of yours feature branch is compared to rolling stable. Example feature A got big conflict in 5.14 and it takes 3 weeks resolve it. When conflicts are resolved most likely there will be just small conflicts against newest rolling stable (example 5.14.5) and those will be resolved quickly in feature A. Now that bottleneck work in feature A you choose to make new internal kernel. You guys notice that highest as you can go right now is 5.14.3 as there is couple maintainers who are working some issues introduced in 5.14.4. So now 5.14.3 is chosen and testing can start with it.<br>
<p>
This way kernel community will be very very happy that you also take stable stuff. Taking 5.14.0 as base make no sense as it gets fixes all the time and then you kinda have to resolve those internal. This is also nice to your maintainers as they can resolve conflicts as they come and some can be aligned all the time with upstream. Usually there will not be many conflict in y.y.x versions. So probably when your conflict resolving work is done you can choose highest stable kernel as internal base.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/873172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
