        <!DOCTYPE html>
        <html lang="en">
        <head><title>Perfcounters added to the mainline [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/339361/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/338579/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/339361/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Perfcounters added to the mainline</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jake Edge</b><br>July 1, 2009</br>
           </div>
<p>
We last <a
href="http://lwn.net/Articles/311850/">looked</a> at the perfcounters
patches back in 
December, shortly after they appeared.  Since that time, a great deal of
work has been done, culminating in perfcounters being included into the
mainline during 
the recently completed 2.6.31 merge window.  Along the way, a
tool to use perfcounters, called <tt>perf</tt>, was added to the mainline
as well.
</p>

<p>
Adding <tt>perf</tt> to the kernel <tt>tools/</tt> directory is one of the
more surprising aspects of the perfcounters merge.  Kernel hackers have
long been leery of adding user-space tools into the kernel source tree, but
Linus Torvalds was <a href="/Articles/339406/">unconvinced</a> by multiple
complaints about that approach.  He pointed to <tt>oprofile</tt> to explain:
<div class="BigQuote">
 It took literally 
months for the user mode tools to catch up and get the patches to support 
new functionality into CVS (or is it SVN?), and after that it took even 
longer for them to become part of a release and be picked up by 
distributions. In fact, I'm not sure it is part of a release even now - I 
had to make a bug report to Fedora to get atom and Nehalem support in my 
tools: I think they took the unofficial patch.
</div>
</p>

<p>
Others were not so sure that the <tt>oprofile</tt> being developed
separately from the kernel was the root cause of those failures.  Christoph
Hellwig <a href="/Articles/339409/">had other ideas</a>: "<q>I don't
think oprofile has been a [disaster] because of any kind of split, 
but because the design has been a failure from day 1.</q>"  But,
Torvalds wants to <a href="/Articles/339410/">try including the tool</a> to
see 
where it leads: "<q>Let's give a _new_ approach a chance, and 
see if we can avoid the mistakes of yesteryear this time.</q>"
</p>

<p>
The <tt>perf</tt> tool itself is a fairly simple command-line tool, which
can be built from the <tt>tools/perf</tt> directory.  It also includes
some documentation, in the form of man pages that are also
available via <tt>perf help</tt> (as well as in HTML and other formats).
At its simplest, it gathers and reports some statistics for a particular
command: 
<pre>
    $ perf stat ./hackbench 10
    Time: 4.174

     Performance counter stats for './hackbench 10':

	8134.135358  task-clock-msecs     #      1.859 CPUs
	      23524  context-switches     #      0.003 M/sec
	       1095  CPU-migrations       #      0.000 M/sec
	      16964  page-faults          #      0.002 M/sec
	10734363561  cycles               #   1319.669 M/sec
	12281522014  instructions         #      1.144 IPC
	  121964514  cache-references     #     14.994 M/sec
	   10280836  cache-misses         #      1.264 M/sec

	4.376588249  seconds time elapsed.
</pre>
This summarizes the performance events that occurred while running the
<tt>hackbench</tt> micro-benchmark program.  There are a combination of
hardware events (cycles, instructions, cache-references, and cache-misses)
as well as software events (task-clock-msecs, context-switches,
CPU-migrations, and page-faults) that are derived from the kernel code and
not the processor-specific performance monitoring unit (PMU).  Currently,
support for hardware events is available for Intel, AMD, and PowerPC
PMUs, but other architectures still have support for the software
events. 
</p>

<p>
There is also a <tt>top</tt>-like mode for observing which kernel functions
are being executed most frequently in a continuously updating display:
<pre>
    $ perf top -c 1000 -p 3216

    ------------------------------------------------------------------------------
       PerfTop:     360 irqs/sec  kernel:65.0% [1000 cycles],  (target_pid: 3216)
    ------------------------------------------------------------------------------

		 samples    pcnt         RIP          kernel function
      ______     _______   _____   ________________   _______________

		 1214.00 -  5.3% - 00000000c045cb4d : lock_acquire
		 1148.00 -  5.0% - 00000000c045d1d3 : lock_release
		  911.00 -  4.0% - 00000000c045d377 : lock_acquired
		  509.00 -  2.2% - 00000000c05a0cbc : debug_locks_off
		  490.00 -  2.2% - 00000000c05a2f08 : _raw_spin_trylock
		  489.00 -  2.1% - 00000000c041d1d8 : read_hpet
		  488.00 -  2.1% - 00000000c04419b8 : run_timer_softirq
		  483.00 -  2.1% - 00000000c04d5f72 : do_sys_poll
		  477.00 -  2.1% - 00000000c05a34a0 : debug_smp_processor_id
		  462.00 -  2.0% - 00000000c043df85 : __do_softirq
		  404.00 -  1.8% - 00000000c074d93f : sub_preempt_count
		  353.00 -  1.5% - 00000000c074d9d2 : add_preempt_count
		  338.00 -  1.5% - 00000000c0408a76 : native_sched_clock
		  318.00 -  1.4% - 00000000c074b4c3 : _spin_lock_irqsave
		  309.00 -  1.4% - 00000000c044ea10 : enqueue_hrtimer
</pre>

This is a static version of the output from looking at a largely quiescent
firefox process (pid 3216), sampling every 1000 cycles. 
</p>

<p>
There is quite a bit more that <tt>perf</tt> can do.  There is a
<tt>record</tt> sub-function that gathers the performance counter data into
a <tt>perf.data</tt> file which can be used by other commands:
<pre>
    $ perf record ./hackbench 10
    Time: 4.348
    [ perf record: Captured and wrote 2.528 MB perf.data (~110448 samples) ]

    $ perf report --sort comm,dso,symbol | head -15

    #
    # (110146 samples)
    #
    # Overhead           Command  Shared Object              Symbol
    # ........  ................  .........................  ......
    #
	10.70%         hackbench  [kernel]                   [k] check_bytes_and_report
	 9.07%         hackbench  [kernel]                   [k] slab_pad_check
	 5.67%         hackbench  [kernel]                   [k] on_freelist
	 5.28%         hackbench  [kernel]                   [k] lock_acquire
	 5.03%         hackbench  [kernel]                   [k] lock_release
	 3.19%         hackbench  [kernel]                   [k] init_object
	 3.02%         hackbench  [kernel]                   [k] lock_acquired
	 2.47%         hackbench  [kernel]                   [k] _raw_spin_trylock
</pre>

This output shows the top eight kernel functions executed while running
<tt>hackbench</tt>.   The same data file can also be used by <tt>perf
annotate</tt> (when given a symbol name and the appropriate
<tt>vmlinux</tt> file) 
to show the disassembled code for a function, along with the 
number of samples recorded on each instruction.  There is clearly a wealth
of information that can be derived from the tool.
</p>

<p>
The original posting of the perfcounters patches <a
href="http://lwn.net/Articles/310260/">came as somewhat of a surprise</a>
to St&eacute;phane Eranian, who had long been working on another
performance monitoring solution, "perfmon".  While he is still a bit
skeptical of perfcounters, which were originally proposed by Ingo Molnar
and Thomas Gleixner, he has been reviewing the patches, and providing
<a href="/Articles/339432/">lengthy comments</a>.  Molnar, also <a
href="/Articles/339433/">responded at length</a>, breaking his reply into
multiple chunks which can be found in the thread. 
</p>

<p>
Perfmon was targeted at exposing as much of the underlying PMU data as
possible to user space, but Molnar explicitly <a
href="/Articles/339436/">rejects that goal</a>:
<div class="BigQuote">
So for every "will you support advanced PMU feature X, Y and Z" 
question you ask, the first-level answer is: 'please show the 
developer usecase and integrate it into our tools so we can see how 
it all works and how useful it is'.
<p>
"A tool might want to do this" is not a good enough answer. We now 
have a working OSS tool-space with 'perf' where such arguments for 
more PMU features can be made in very specific terms: patches, 
numbers and comparisons. Actual hands-on utility, happy developers 
and faster apps is what matters in the end - not just the list of 
PMU features we expose.
</div>
</p>

<p>
His focus, presumably shared with his co-maintainers Peter Zijlstra and Paul 
Mackerras, is to generalize performance measurement features so that they
are not dependent on any particular CPU and that they fit well with
developer work flow: "<q>I do claim we had few if any sane performance
analysis tools before 
under Linux, and i think we are still in the stone ages and still 
have a lot of work to do in this area.</q>"  From Molnar's perspective,
that ease of use for users and developers is one of the main areas where
perfmon fell short.
</p>

<p>
Molnar is not shy about pointing out that perfcounters still needs a lot of
work, but the framework is there, so features can be added to that.  As
yet, there is no documentation in the kernel <tt>Documentation/</tt>
directory, but one presumes that will be handled sometime soon.  Overall,
perfcounters and the <tt>perf</tt> tool look to be a highly useful addition
to the kernel, one that should start providing benefits&mdash;in the form
of better performance&mdash;in the near term.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Performance_monitoring">Performance monitoring</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/339361/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor339518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 3:39 UTC (Thu)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/339518/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Linux does not use coloring algorithms when allocating page frames to virtual addresses.  On popular architectures with large caches and small pages and small associativity (including x86 of the last few years) most statistics on cache misses are subject to large variances because of the uneven mapping of virtual address space to physical cache lines.  The statistics have only small predictive value, and thus are little help to application programmers.  I have seen the numbers vary by 15% for consecutive invocations of the same long-running CPU-bound deterministic program on the same data (the sequence of virtual addresses accessed by each run was identical) on an "otherwise idle" machine.  Do not use the output of <b>perf stat</b> to tune your application.
      
          <div class="CommentReplyButton">
            <form action="/Articles/339518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339629"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 14:14 UTC (Thu)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/339629/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I disagree. I used oprofile, not perf, but the principle is the same. Looking at areas of high cache misses can tell you where to add cache prefetch code. This always helps, virtual memory layout oddities or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339629/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 23:38 UTC (Fri)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/339939/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>
Correct.
<p>
Another thing to note is that perf stat has a '--repeat N' parameter. This option directs perf stat to run the measured command N times. It saves the various counter results, and then emits basic (avg, std-dev) statistics about them.
<p>
For example, running the 'hackbench' messaging benchmark 10 times gives:
<p>
<pre>
aldebaran:~> perf stat --repeat 10 ./hackbench 10
Time: 0.121
Time: 0.091
Time: 0.114
Time: 0.094
Time: 0.090
Time: 0.095
Time: 0.094
Time: 0.107
Time: 0.094
Time: 0.095

 Performance counter stats for './hackbench 10' (10 runs):

    1259.878957  task-clock-msecs         #     10.597 CPUs    ( +-   1.799% )
          51812  context-switches         #      0.041 M/sec   ( +-   5.103% )
           3519  CPU-migrations           #      0.003 M/sec   ( +-   4.915% )
          17870  page-faults              #      0.014 M/sec   ( +-   0.392% )
     3802645216  cycles                   #   3018.262 M/sec   ( +-   1.747% )
     1588586719  instructions             #      0.418 IPC     ( +-   0.837% )
       16885948  cache-references         #     13.403 M/sec   ( +-   1.503% )
        7328059  cache-misses             #      5.816 M/sec   ( +-   1.773% )

    0.118889101  seconds time elapsed   ( +-   3.398% )


</pre>
<p>
Shows us the statistical properties of the counters. If your system is 'noisy', or if the metric is a fundamentally volatile one (cycles, or cache-misses), the noise level will be higher.
<p>
Other metrics such as instructions or branches executed are a lot more stable.
<p>
But for any of the metrics, 'perf stat --repeat 10' gives you a good guess about how reliable that metric is on that particular system.
<p>
Somewhat surprisingly, for this particular workload, the most noisy metric is 'context-switches' and 'CPU-migrations' - which measures the number task switches and the number of cross-CPU task migrations. (this is not a PMU metric but a perfcounter metrics offered by the kernel.)
<p>
(The reason for the noise here is that hackbench starts and stops a lot of tasks in a bursty way, and any noise in initial conditions get magnified by the chance placement of tasks. 100 msecs is not a lot of time to run, so depending on when the scheduler's balancing algorithm kicks in the placement of tasks is randomized to a certain degree (due to the high overload) and the metric gets spread out.)
<p>
The conclusion is that noisy metrics are just as useful as stable metrics, as long as you can measure the noise and as long as you know how to reduce the noise to acceptable levels. Modern CPUs with huge caches and complex heuristics are fundamentally random in their characteristics, so deterministic results can rarely be expected.
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/339939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor340010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Call-graph / call-chain support</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2009 10:28 UTC (Sun)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/340010/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
btw., another thing worth mentioning about perfcounters is turn-key call-graph support and call-graph visualization:
<p>
<pre>
 $ perf record -g -f ./pipe-test-1m
 [ perf record: Captured and wrote 8.169 MB perf.data (~356901 samples) ]

 $ perf report --sort symbol --callchain fractal,5 | cat

 #
 # (80245 samples)
 #
 # Overhead  Symbol
 # ........  ......
 #
     4.50%  [k] pipe_read
                |          
                 --99.00%-- do_sync_read
                           vfs_read
                           sys_read
                           system_call_fastpath
                           __GI___libc_read
                           __libc_start_main

     4.39%  [.] main

     4.27%  [k] __switch_to
                |          
                |          |          
                |          |--50.97%-- __GI___libc_write
                |          |          
                |           --49.06%-- __GI___libc_read
                |                     __libc_start_main
                |          
                 --11.19%-- thread_return
                           |          
                           |--51.44%-- __GI___libc_write
                           |          
                            --48.83%-- __GI___libc_read
                                      __libc_start_main

     3.75%  [k] copy_user_generic_string
                |          
                |--52.11%-- do_sync_read
                |          vfs_read
                |          sys_read
                |          system_call_fastpath
                |          __GI___libc_read
                |          __libc_start_main
                |          
                 --45.39%-- pipe_write
                           do_sync_write
                           vfs_write
                           sys_write
                           system_call_fastpath
                           __GI___libc_write
                           __libc_start_main

     3.36%  [k] avc_has_perm_noaudit
                |          
                 --96.59%-- avc_has_perm
                           inode_has_perm
                           file_has_perm
                           selinux_file_permission
                           security_file_permission
                           rw_verify_area
                           |          
                           |--51.34%-- vfs_read
                           |          sys_read
                           |          system_call_fastpath
                           |          __GI___libc_read
                           |          __libc_start_main
                           |          
                            --48.66%-- vfs_write
                                      sys_write
                                      system_call_fastpath
                                      |          
                                       --99.53%-- __GI___libc_write
                                                 __libc_start_main

     3.29%  [k] schedule
                |          
                |--50.34%-- sysret_careful
                |          __GI___libc_write
                |          
                 --46.55%-- pipe_wait
                           pipe_read
                           do_sync_read
                           vfs_read
                           sys_read
                           system_call_fastpath
                           __GI___libc_read
                           __libc_start_main

     2.89%  [k] switch_mm
                |          
                 --97.67%-- schedule
                           |          
                           |--50.75%-- pipe_wait
                           |          pipe_read
                           |          do_sync_read
                           |          vfs_read
                           |          sys_read
                           |          system_call_fastpath
                           |          __GI___libc_read
                           |          __libc_start_main
                           |          
                            --49.29%-- sysret_careful
                                      __GI___libc_write

     2.85%  [.] __GI___libc_write

     2.70%  [.] __GI___libc_read

     2.60%  [k] file_has_perm
                |          
                |--93.67%-- selinux_file_permission
                |          security_file_permission
                |          rw_verify_area
                |          |          
                |          |--55.02%-- vfs_write
                |          |          sys_write
                |          |          system_call_fastpath
                |          |          |          
                |          |           --99.81%-- __GI___libc_write
                |          |                     __libc_start_main
                |          |          
                |           --44.98%-- vfs_read
                |                     sys_read
                |                     system_call_fastpath
                |                     __GI___libc_read
                |                     __libc_start_main
                |          
                 --6.33%-- security_file_permission
                           rw_verify_area
                           |          
                           |--52.27%-- vfs_write
                           |          sys_write
                           |          system_call_fastpath
                           |          |          
                           |          |--97.10%-- __GI___libc_write
                           |          |          __libc_start_main
                           |          |          
                           |           --4.35%-- __write_nocancel
                           |          
                            --47.73%-- vfs_read
                                      sys_read
                                      system_call_fastpath
                                      __GI___libc_read
                                      __libc_start_main

     2.15%  [k] pipe_write
                |          
                 --98.31%-- do_sync_write
                           vfs_write
                           sys_write
                           system_call_fastpath
                           __GI___libc_write
                           __libc_start_main

     2.05%  [k] system_call
                |          
                |--50.64%-- __GI___libc_write
                |          |          
                |           --49.46%-- __libc_start_main
                |          
                 --49.24%-- __GI___libc_read
                           __libc_start_main
</pre>
<p>
Here we record and output full call-chains (down to and including user-space call-chains) and display the overhead in a tree - detailing the call-path that results in that profile entry - and recursively so. (the '5' is a 5% filter - to skip entries below a 5% (relative-)overhead threshold)
<p>
For example this portion:
<p>
<pre>     3.75%  [k] copy_user_generic_string
                |          
                |--52.11%-- do_sync_read
                |          vfs_read
                |          sys_read
                |          system_call_fastpath
                |          __GI___libc_read
                |          __libc_start_main
                |          
                 --45.39%-- pipe_write
                           do_sync_write
                           vfs_write
                           sys_write
                           system_call_fastpath
                           __GI___libc_write
                           __libc_start_main
</pre>
Tells us that in this workload there's a combined overhead of 3.75% from user-copies (copy_user_generic_string()), and that ~52% overhead of that comes from a user-space read() and 45% comes from a user-space write() call.
<p>
With traditional 'flat' profiling output we'd only know that there's 3.75% overhead in copy_user_generic_string() - we would not know where it comes from.
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/340010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor340013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Call-graph / call-chain support</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2009 11:52 UTC (Sun)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/340013/">Link</a>] 
      </p>
      
      </div>
      </summary>
      That's lovely. What would be even more lovely would be the ability to output KCacheGrind's format <a href="http://kcachegrind.sourceforge.net/cgi-bin/show.cgi/KcacheGrindCalltreeFormat">(documentation)</a>, or at least something easily parseable (with less ascii art) and thus mungeable into said format, if that's possible?
      
          <div class="CommentReplyButton">
            <form action="/Articles/340013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor339635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 14:59 UTC (Thu)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/339635/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A few comments.<br>
<p>
* Not all Intel chips have full hardware counter support under perf.  Most notably, Pentium Pro/II/III or Pentium 4.  One might argue that these are old and don't matter, but they are supported by perfmon2.  Pentium 4 is the troublesome one, because the performance counters for that architecture don't map well at all to the abstraction chosen by the perf developers.<br>
<p>
* I find calling perf a "simple" command line tool to be a bit deceptive.  It is quite complicated and not very well documented yet.<br>
<p>
* There is still some lingering bitterness about how Ingo took over perfcounters, sort of the same way he took over amd64 and the CFS scheduler.  Mainly because he is re-inventing everything from scratch and making many mistakes that the other implementations already learned the hard way.  Also the perf implementation does a lot of things, such as abusing ioctl()s, that the perfmon2 developers were told would not be allowed in the kernel and they wasted a lot of time working around these issues, only to find out it didn't matter in the end.<br>
<p>
* I will admit the perf developers can be helpful, especially if you bug them enough.  Upon prompting, they've reduced the static aggregate count overhead in the perf tool from a few thousand instructions to near zero.<br>
<p>
* I personally think the abstraction they chose of having "common" counters hard-wired in the kernel to be a bad one, because as they are already finding out every chip and chip revision has different counters with different issues.  perfmon2 took the saner route to do this in user-space; once 2.6.31 is released the ABI is frozen and we're going to be stuck with this.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 20:01 UTC (Thu)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/339775/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not only is he re-inventing the wheel, he's forcing users to add yet another perfctr-alike support layer.  PAPI has been around a long time and has many users, but the package and its users keep being declared not to exist.  Bizarre.  Many performance counter tools are one-shots meant to work for a particular application or stack.  That's one reason why we (users) don't have a "flagship application" to wave in front of other developers.  We want a flexible way to dig at the hardware without waiting for kernel developer X to decide a particular counter is worth-while.  Let us deal with things in user space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339794"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2009 21:53 UTC (Thu)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/339794/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there is hope that soon PAPI and pfmon (the perfmon2 tool) will be ported to perfcounters, so assuming the features they need are available, things might work out in the end once things stabilize for a few months/years.<br>
<p>
It will be nice that _finally_ performance counters will be available under Linux without having to patch the kernel.  It's just a shame that it happened the way it did.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339794/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor339935"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 22:54 UTC (Fri)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/339935/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i> * I personally think the abstraction they chose of having "common" counters hard-wired in the kernel to be a bad one, because as they are already finding out every chip and chip revision has different counters with different issues. perfmon2 took the saner route to do this in user-space; once 2.6.31 is released the ABI is frozen and we're going to be stuck with this.
</i>
<p>
Not really. The days of weird x86 PMUs changing with every CPU model are gone, fortunately.
<p>
The AMD PMU programming low level details have stayed pretty stable since around the K7 or so - for many years.
<p>
Intel has also introduced 'architectural performance monitoring' starting with Core2 (and has extended it in Corei7) which too is a future-proof method.
<p>
Also, even assuming weird PMUs, the perfcounters ABI does not hard-code low level details like that. Proof of this is in the fact that most Power CPUs are supported by perfcounters - which all have PMUs that are wildly different from x86 PMUs.
<p>
The reason perfcounters abstracts away common events is utility: it is convenient to tools to use a 'cycles' or a 'branches executed' events regardless of which CPU model they are running on. perfmon/pfmon, despite many years of development, never achieved this kind of basic utility.
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/339935/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor339937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 23:09 UTC (Fri)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/339937/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>
* There is still some lingering bitterness about how Ingo took over perfcounters [...]
</i>
<p>
(Just a question - from your post i gather that you are an (ex?) perfmon developer. If yes then i'm not surprised that you feel bitter about it - still it would have been nice had you openly disclosed your direct involvement and bias in this matter.)
<p>
The thing is, perfmon, despite being available for years, never achieved any measurable usage amongst kernel developers. You can check this yourself, just type: "git log --grep=pfmon" in an upstream kernel repository. It comes up empty: no-one ever found it important to mention pfmon in an upstream kernel changelog. Not one commit out of more than 150,000 upstream kernel commits ever mentioned that pfmon was used to measure something or to solve a problem.
<p>
The reason? I cannot speak for other kernel developers but i have my guesses: i tried it, and the thing is close to unusable to kernel developers. It has way too much overhead to measure workloads with lots of tasks and lots of overhead. It relies on a fat and quirky library and takes way too much effort to install and use. Its sampling (profiling) does not read ELF symbols as far as i could see.
<p>
perfmon had many other design problems as well (not directly visible to users) - i explained the reasons in the (many) posts i wrote about perfcounters in the past ~6 months. The main failure was that it tried to abstract on a way too low level, on an almost register basis - without the kernel having any knowledge about the structure of the hardware it abstracts away.
<p>
That design choice is lethal: it has shut off many interesting capabilities that perfcounters offers here and today: inherited counters, software counters, transparent workload monitoring, nested counters, various context-switch performance optimizations, etc. etc.
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/339937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor339938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 23:24 UTC (Fri)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/339938/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>
* Not all Intel chips have full hardware counter support under perf. Most notably, Pentium Pro/II/III or Pentium 4. One might argue that these are old and don't matter, but they are supported by perfmon2. Pentium 4 is the troublesome one, because the performance counters for that architecture don't map well at all to the abstraction chosen by the perf developers.
</i>
<p>
Those chips are indeed old, abandoned and dont matter. perfmon has support for them partly because perfmon was started when those chips were still relevant. Alas, IMO, this also created a wrong design and the wrong mindset for perfmon.
<p>
So in a sense, perfcounters was lucky to have come later, when saner PMUs emerged on x86.
<p>
The central concept of perfmon is to expose the PMU to user-space and to push all the complexity to user-space.
<p>
The central concept of perfcounters is to provide rich, kernel-based abstractions to measure performance characteristics of a Linux system in a coherent, unified framework - regardless of whether the information comes from a PMU, a software counter, a tracepoint or some data field somewhere.
<p>
Those are two wildly different and fundamentally conflicting sets of design goals.
<p>
But you would be wrong to suggest that P4 support is not possible under perfcounters. For example PowerPC support (which was cited as the primary counter argument against perfcounters in the perfmon vs. perfcounters discussions) is alive, well and kicking under perfcounters.
<p>
The reason why people are not rushing to implement perfcounters for P4 is probably that Core2 and later CPUs are just so much more different from a performance profile than the abandoned Netburst architecture. They are also a lot more pleasant CPUs from many perspectives.
<p>
It also makes little sense to profile on too old CPUs, as any performance optimization would have to be re-validated on more recent CPUs as well. People who care about performance tend to try to stay on the hardware edge as well, and dont tend to use obsolete systems.
<p>
As the years advance, so will perfcounter's currently 'cutting edge' PMU support create the same kind of backwards-pointing trail of CPU models. Or, if anyone cares about P4 PMU support, it can be implemented just fine as well - patches are certainly welcome.
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/339938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor339825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 4:14 UTC (Fri)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/339825/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does anyone know what is meant about oprofile being an "abject failure"? (This is an honest question, I use it all the time and for my use it's awesome.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339832"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 6:56 UTC (Fri)
                               by <b>graydon</b> (guest, #5009)
                              [<a href="/Articles/339832/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Caveat: I use oprofile every couple of days, and I helped write some of the drivers for it. Still, I'm sympathetic to complaints about it. From what I've observed:<br>
<p>
 - There's a lot of drift between userspace and kernelspace. Event names and communication mechanisms seem to change from release to release. I've had to edit the shell scripts and source code repeatedly on installed versions.<br>
<p>
 - Apparently the kernel people wanted a much faster cycle time on new hardware support, and oprofile userspace is "lightly maintained". This hasn't been as much of a problem for me since I stay behind the curve intentionally, and mostly just want to monitor clocks, CPI, and crude cache and branch-mispredict hotspots; but I also know where to patch in userspace if necessary.<br>
<p>
 - There is further drift against libbfd, gcc, and the various toolchain pieces involved in mapping samples to reasonable debug information. I don't expect the kernel developers to do much more on this than snark about how userspace sucks; but who knows, maybe they'll write another toolchain and be free at last.<br>
<p>
 - The drift has been sufficiently bad that most non-kernel, non-oprofile developers on linux I talk to have no idea how to "get oprofile working" and need to be hand-held through it. And when they do get it working and it suddenly stops (or lies, which it can do if the drift is *just shy* of enough to break it), they don't know how to fix it. <br>
<p>
 - As an additional data point, I've seen two (perhaps three now?) separate projects spring up that ship *both* their own batch of replacement userspace tools *and* their own forked copy of the oprofile kernel module, in order to keep the interface, expectations and capabilities pinned down.<br>
<p>
All that aside though, I really do use oprofile all the time and find it (and kcachegrind) *way* more useful for performance tuning than, say, shark or vtune. Totally worth the price of admission. The other-platform competition seems to lie, crash, wedge, and otherwise misbehave even worse.<br>
<p>
Maybe there were some other complaints I missed?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/339832/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor339836"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2009 9:04 UTC (Fri)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/339836/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Thanks for the explanation. On further thought, the tools *could* be somewhat better. I do now recall stalking people in #oprofile a few years ago to get them to explain what some of the output fields actually were, and the upstream oprofile-to-kcachegrind script is ~useless. (But then, that's partly my fault for not <a href="http://roberts.vorpus.org/~njs/op2calltree.py">sending patches</a>. I wouldn't want to live with oprofile long without real call tree visualization.)
<p>
That doesn't seem like the sort of thing the kernel folks would deign to notice, though.
<p>
Certainly it makes sense in general to keep coupled tools together, to reduce drift and lower the barrier to entry. When it comes to maintaining an ABI, though, I think I trust the kernel folks (when they decide they care) a bit more than binutils...

      
          <div class="CommentReplyButton">
            <form action="/Articles/339836/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor340865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2009 14:36 UTC (Fri)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/340865/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the upstream oprofile-to-kcachegrind script is ~useless ...</font><br>
<font class="QuotedText">&gt; I wouldn't want to live with oprofile long without real call tree </font><br>
visualization.<br>
<p>
Because of that, I've used this:<br>
  <a rel="nofollow" href="http://code.google.com/p/jrfonseca/wiki/Gprof2Dot">http://code.google.com/p/jrfonseca/wiki/Gprof2Dot</a><br>
<p>
(Not as nice as having Kcachegrind + code browsing, but mostly good <br>
enough.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/340865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor340009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2009 10:04 UTC (Sun)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/340009/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>
As yet, there is no documentation in the kernel Documentation/ directory, but one presumes that will be handled sometime soon.
</i>
<p>
It can be found under: tools/perf/design.txt
<p>
It moved to that place when Documentation/perf_counter/ moved to tools/perf/. I suspect we could move the .txt file back.
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/340009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor340011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Perfcounters added to the mainline</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2009 10:41 UTC (Sun)
                               by <b>mingo</b> (guest, #31122)
                              [<a href="/Articles/340011/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>
<pre>
    $ perf top -c 1000 -p 3216
[...]
</pre>
<p>
This is a static version of the output from looking at a largely quiescent firefox process (pid 3216), sampling every 1000 cycles. 
</i>
<p>
A sidenote: for the profiling of largely idle workloads one can use 'auto-frequency counters'. These are counters where the kernel does not used a fixed period sampling, but adapts dynamically to the workload's intensity.
<p>
This can be done via the -F/--freq parameter to perf record and perf top:
<p>
<pre>
   $ perf top -F 1000 -p $(pidof firefox-bin)
</pre>
<p>
This will sample Firefox with 1KHz, regardless of its intensity. If Firefox executes a lot then the cyclce-sampling intervals increase automatically - if Firefox is more idle then they shorten.
<p>
(All the perf tools handle such type of 'dynamic samples' correctly so the resulting profile will not be skewed by workload fluctuations.)
<p>
The advantage of auto-freq counters is convenience: one does not have to guess '1000 cycles' magic interval that you had to use in your example above (you probably first tried the default 100,000 cycles - then saw that no output was coming then you went down to 10,000 and then to 1000?) - and the sampling will also be more workload-uniform.
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/340011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor340876"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about GPU perf counters?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2009 15:07 UTC (Fri)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/340876/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding the "Infrastructure for tracking driver performance events" <br>
patch article listed later on the LWN kernel page... Why intel GPUs (or <br>
just that particular GPU?) don't have performance counters?  Or if they/it <br>
actually do have them, could this perfcounters thing expose them in <br>
addition to the CPU counters?<br>
<p>
It would be pretty important information for anything 3D related, maybe <br>
even just for today's composited Desktops.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/340876/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
