        <!DOCTYPE html>
        <html lang="en">
        <head><title>Huge pages part 1 (Introduction) [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/374424/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/373989/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/374424/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Huge pages part 1 (Introduction)</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="GAByline">
           <p>February 16, 2010</p>
           <p>This article was contributed by Mel Gorman</p>
           </div>
[<i>Editor's note: this article is the first in a five-part series on the
use of huge pages with Linux.  We are most fortunate to have core VM hacker
Mel Gorman as the author of these articles!  The remaining installments
will appear in future LWN Weekly Editions.</i>]
<p>
One of the driving forces behind the development of Virtual
Memory (VM) was to reduce the programming burden associated with fitting
programs into limited memory. A fundamental property of VM is that the CPU
references a virtual address that is translated via a combination
of software and hardware to a physical address. This allows
information only to be paged into memory on demand (demand
paging) improving memory utilisation, allows modules to be arbitrary
placed in memory for linking at run-time and provides a mechanism for
the protection and controlled sharing of data between processes. Use of
virtual memory is so pervasive that it has been described as &#147;one of
the engineering triumphs of the computer age&#148;&nbsp;[denning96], but this
indirection is not without cost.
<p>
Typically, the total number of translations required by a program
during its lifetime will require that the page tables are stored in
main memory. Due to translation, a virtual memory reference necessitates
multiple accesses to physical memory, multiplying the cost of an ordinary
memory reference by a factor depending on the page table format. To cut
the costs associated with translation, VM implementations take advantage of
the principal of locality&nbsp;[denning71] by storing recent
translations in a cache called the Translation Lookaside Buffer
(TLB)&nbsp;[casep78,smith82,henessny90]. The amount of memory that can
be translated by this cache is referred to as the "TLB reach"
and depends on the size of the page and the number of TLB entries.
Inevitably, a percentage of a program's execution time is spent accessing
the TLB and servicing TLB misses.
<p>
The amount of time spent translating addresses depends on the workload as
the access pattern determines if the TLB reach is sufficient to store all
translations needed by the application. On a miss, the exact cost depends
on whether the information necessary to translate the address is in the CPU
cache or not. To work out the amount of time spent servicing the TLB misses,
there are some simple formulas:
<p>
<blockquote>
Cycles<sub>tlbhit</sub> = TLBHitRate * TLBHitPenalty
<p>
Cycles<sub>tlbmiss_cache</sub> = TLBMissRate<sub>cache</sub> * TLBMissPenalty<sub>cache</sub>
<p>
Cycles<sub>tlbmiss_full</sub> = TLBMissRate<sub>full</sub> * TLBMissPenalty<sub>full</sub>
<p>
TLBMissCycles = Cycles<sub>tlbmiss_cache</sub> + Cycles_<sub>tlbmiss_full</sub>
<p>
TLBMissTime = (TLB Miss Cycles)/(Clock rate)
</blockquote>
<p>
If the TLB miss time is a large percentage of overall program
execution, then the time should be invested to reduce the miss rate and
achieve better performance.  One means of achieving this is to translate
addresses in larger units than the base page size, as supported by many
modern processors.
<p>
Using more than one page size was identified in the 1990s as one means of
reducing the time spent servicing TLB misses by increasing TLB reach. The
benefits of huge pages are twofold. The obvious performance gain is from
fewer translations requiring fewer cycles.  A less obvious benefit is that
address translation information is typically stored in the L2 cache. With
huge pages, more cache space is available for application data, which means that
fewer cycles are spent accessing main memory. Broadly speaking, database
workloads will gain about 2-7% performance using huge pages whereas
scientific workloads can range between 1% and&nbsp;45%.
<p>
Huge pages are not a universal gain, so transparent support for huge pages
is limited in mainstream operating systems. On some TLB implementations,
there may be different numbers of entries for small and huge pages. If the
CPU supports a smaller number of TLB entries for huge pages, it is possible
that huge pages will be slower if the workload reference pattern is very
sparse and making a small number of references per-huge-page. There may
also be architectural limitations on where in the virtual address space
huge pages can be used.
<p>
Many modern operating systems, including Linux, support huge pages in a
more explicit fashion, although this does not necessarily mandate application
change. Linux has had support for huge pages since around 2003 where it was
mainly used for large shared memory segments in database servers such as
Oracle and DB2. Early support required application modification, which was
considered by some to be a major problem.  To compound the difficulties,
tuning a Linux system to use huge pages was perceived to be a difficult
task. There have been significant improvements made over the years to huge
page support in Linux and as this article will show, using huge pages today
can be a relatively painless exercise that involves no source modification.
<p>
This first article begins by installing some huge-page-related utilities
and support libraries that make tuning and using huge pages a relatively
painless exercise. It then covers the basics of how huge pages behave under
Linux and some details of concern on NUMA. The second article covers the
different interfaces to huge pages that exist in Linux. In the third article,
the different considerations to make when tuning the system are examined
as well as how to monitor huge-page-related activities in the system. The
fourth article shows how easily benchmarks for different types of application
can use huge pages without source modification. For the very curious, some
in-depth details on TLBs and measuring the cost within an application are
discussed before concluding.
<p>
<h3>1 Huge Page Utilities and Support Libraries</h3>
<p>
There are a number of support utilities and a
library packaged collectively as <a
href="http://sourceforge.net/projects/libhugetlbfs/">libhugetlbfs</a>. Distributions
may 
have packages, but this article assumes that
libhugetlbfs&nbsp;2.7 is installed. The latest version can always be cloned
from git using the following instructions
<p>
<pre>
  $ git clone git://libhugetlbfs.git.sourceforge.net/gitroot/libhugetlbfs/libhugetlbfs
  $ cd libhugetlbfs
  $ git checkout -b next origin/next
  $ make PREFIX=/usr/local
</pre>
<p>
There is an <tt>install</tt> target that installs the library
and all support utilities but there are <tt>install-bin</tt>,
<tt>install-stat</tt> and <tt>install-man</tt> targets available
in the event the existing library should be preserved during installation.
<p>
The library provides support for automatically backing text, data,
heap and shared memory segments with huge pages. In addition,
this package also provides a programming API and manual pages. The
behaviour of the library is controlled by environment variables
(as described in the <tt>libhugetlbfs.7</tt> manual page) with
a launcher utility <tt>hugectl</tt> that knows how to configure
almost all of the variables. <tt>hugeadm</tt>, <tt>hugeedit</tt>
and <tt>pagesize</tt> provide information about the system and provide
support to system administration. <tt>tlbmiss_cost.sh</tt> automatically
calculates the average cost of a TLB miss. <tt>cpupcstat</tt> and
<tt>oprofile_start.sh</tt> provide help with monitoring the current
behaviour of the system. Manual pages are available describing in further
detail each utility.
<p>
<a name="hpfb"></a>
<h3>2 Huge Page Fault Behaviour</h3>

<p>
In the following articles, there will be discussions on how different type
of memory regions can be created and backed with huge pages. One important
common point between them all is how huge pages are faulted and when the
huge pages are allocated. Further, there are important differences between
shared and private mappings depending on the exact kernel version used.
<p>
In the initial support for huge pages on Linux, huge pages were faulted at the
same time as <tt>mmap()</tt> was called. This guaranteed that all references
would succeed for shared mappings once <tt>mmap()</tt> returned successfully.
Private mappings were safe until <tt>fork()</tt> was called. Once called,
it's important that the child call <tt>exec()</tt> as soon as possible
or that the huge page mappings were marked <tt>MADV_DONTFORK</tt>
with <tt>madvise()</tt> in advance. Otherwise, a Copy-On-Write
(COW) fault could result in application failure by either parent or
child in the event of allocation failure.
<p>
Pre-faulting pages drastically increases the cost of <tt>mmap()</tt> and can
perform sub-optimally on NUMA. Since 2.6.18, huge pages were faulted the
same as normal mappings when the page was first referenced.  To guarantee
that faults would succeed, huge pages were reserved at the time the shared
mapping is created but private mappings do not make any reservations. This
is unfortunate as it means an application can fail without <tt>fork()</tt>
being called. <tt>libhugetlbfs</tt> handles the private mapping problem
on old kernels by using <tt>readv()</tt> to make sure the mapping is safe
to access, but this approach is less than ideal.
<p>
Since 2.6.29, reservations are made for both shared and private mappings. Shared
mappings are guaranteed to successfully fault regardless of what process accesses
the mapping.
<p>
For private mappings, the number of child processes is indeterminable so
only the process that creates the mapping <tt>mmap()</tt> is guaranteed to
successfully fault. When that process <tt>fork()</tt>s, two processes are
now accessing the same pages. If the child performs COW, an attempt will
be made to allocate a new page. If it succeeds, the fault successfully
completes. If the fault fails, the child gets terminated with a message
logged to the kernel log noting that there were insufficient huge pages. If
it is the parent process that performs COW, an attempt will also be made to
allocate a huge page. In the event that allocation fails, the child's pages
are unmapped and the event recorded. The parent successfully completes the
fault but if the child accesses the unmapped page, it will be terminated.
<p>
<h3>3 Huge Pages and Swap</h3>
<p>
There is no support for the paging of huge pages to backing storage.
<p>
<h3>4 Huge Pages and NUMA</h3>
<p>
On NUMA, memory can be local or remote to the CPU, with significant
penalty incurred for remote access.  By default, Linux uses a node-local
policy for the allocation of memory at page fault time.  This policy
applies to both base pages and huge pages.  This leads to an important
consideration while implementing a parallel workload.
<p>
The thread processing some data should be the same thread that caused the
original page fault for that data.  A general anti-pattern on NUMA is when
a parent thread sets up and initialises all the workload's memory areas
and then creates threads to process the data.  On a NUMA system this can
result in some of the worker threads being on CPUs remote with respect
to the memory they will access.  While this applies to all NUMA systems
regardless of page size, the effect can be pronounced on systems where the
split between worker threads is in the middle of a huge page incurring more
remote accesses than might have otherwise occurred.
<p>
This scenario may occur for example when using huge pages with OpenMP,
because OpenMP does not necessarily divide its data on page boundaries.
This could lead to problems when using base pages, but the problem is
more likely with huge pages because a single huge page will cover
more data than a base page, thus making it more likely any given huge
page covers data to be processed by different threads.  Consider the
following scenario.  A first thread to touch a page will fault the full
page's data into memory local to the CPU on which the thread is running.
When the data is not split on huge-page-aligned boundaries, such a thread
will fault its data and perhaps also some data that is to be processed by
another thread, because the two threads' data are within the range of the
same huge page.  The second thread will fault the rest of its data into
local memory, but will still have part of its data accesses be remote.
This problem manifests as large standard deviations in performance when
doing multiple runs of the same workload with the same input data.
Profiling in such a case may show there are more cross-node accesses
with huge pages than with base pages.  In extreme circumstances, the
performance with huge pages may even be slower than with base pages.
For this reason it is important to consider on what boundary data is
split when using huge pages on NUMA systems.
<p>
One work around for this instance of the general problem is to use
MPI in combination with OpenMP. The use of MPI allows division of the
workload with one MPI process per NUMA node.  Each MPI process is bound
to the list of CPUs local to a node.  Parallelisation within the node
is achieved using OpenMP, thus alleviating the issue of remote access.
<p>
<h3>5 Summary</h3>
<p>
In this article, the background to huge pages were introduced, what the
performance benefits can be and some basics of how huge pages behave on Linux.
The next article (to appear in the near future) discusses the interfaces
used to access huge pages.
<p>
Read the successive installments:
<p>
<ul>
<li> <a href="http://lwn.net/Articles/375096/">Part 2</a>: Interfaces
<li> <a href="http://lwn.net/Articles/376606/">Part 3</a>: Administration
<li> <a href="/Articles/378641/">Part 4</a>: Benchmarking
<li> <a href="http://lwn.net/Articles/379748/">Part 5</a>: A deeper look at
TLBs and costs
</ul>
<p>
Details of publications referenced in these articles can be found in the <a href="/Articles/379748/#bibliography">bibliography</a> at the end of Part 5.

<p>

<font size="smaller"><i>
This material is based upon work supported by the Defense Advanced Research
Projects Agency under its Agreement No. HR0011-07-9-0002.  Any opinions,
findings and conclusions or recommendations expressed in this material
are those of the author and do not necessarily reflect the views of the
Defense Advanced Research Projects Agency.</i>
</font><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Huge_pages">Huge pages</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#hugetlbfs">hugetlbfs</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Huge_pages">Memory management/Huge pages</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Gorman_Mel">Gorman, Mel</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/374424/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor374972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Well-written article</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2010 11:12 UTC (Thu)
                               by <b>sdalley</b> (subscriber, #18550)
                              [<a href="/Articles/374972/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Well done Mel Gorman for writing about a deeply technical topic in such a comprehensible way! I actually understood it 80% on the first pass.</p>

<p>It's a real art to be able to define unfamiliar concepts as you go without over-simplifying on the one hand or being lost in nested interrupts on the other.</p>

<p>The only things I had to look up were <a href="http://en.wikipedia.org/wiki/Message_Passing_Interface">MPI</a> and <a href="http://en.wikipedia.org/wiki/OpenMP">OpenMP</a> but that was easily done.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/374972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor375029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About NUMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2010 14:35 UTC (Thu)
                               by <b>cma</b> (guest, #49905)
                              [<a href="/Articles/375029/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      I'm curious...

If my app is NUMA aware (let's say it's an old fashioned threaded app), in
this case woould it be interesting in enabling in BIOS (in concrete for a
Dell R610 server) the memory option NODE INTERLEAVING? Or just let BIOS
enable NUMA behavior (NODE INTERLEVING disabled)?

Thanks and congrats for this great article!

Regards
      
          <div class="CommentReplyButton">
            <form action="/Articles/375029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About NUMA - corrigenda</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2010 14:36 UTC (Thu)
                               by <b>cma</b> (guest, #49905)
                              [<a href="/Articles/375031/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Sorry about the typo: I was meaning: if my app WAS NOT NUMA aware...
      
          <div class="CommentReplyButton">
            <form action="/Articles/375031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor375036"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About NUMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2010 15:00 UTC (Thu)
                               by <b>mel</b> (guest, #5484)
                              [<a href="/Articles/375036/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I'm curious... If my app is NUMA aware (let's say it's an old fashioned threaded app), in this</font><br>
<font class="QuotedText">&gt; case woould it be interesting in enabling in BIOS (in concrete for a Dell R610 server) the </font><br>
<font class="QuotedText">&gt; memory option NODE INTERLEAVING? Or just let BIOS enable NUMA behavior (NODE </font><br>
<font class="QuotedText">&gt; INTERLEVING disabled)? Thanks and congrats for this great article!</font><br>
<p>
s/NUMA aware/not NUMA aware/<br>
<p>
It depends on whether your application fits in one node or not. If it fits in one node, then leave <br>
NODE_INTERLEAVING off and use taskset to bind the application to one nodes worth of CPUs. <br>
The memory will be allocated locally and performance will be decent.<br>
<p>
If the application needs the whole machine and one thread faults all of the memory before <br>
spawning other threads (a common anti-pattern for NUMA), then NODE_INTERLEAVING will give <br>
good average performance. Without interleaving, your performance will sometimes be great <br>
and other times really poor depending on if the thread is running on the node that faulted the <br>
data or not. You don't need to go to the bios to test it out, launch the <br>
application with<br>
<p>
numactl --interleave=all your-application<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375036/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About NUMA</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2010 18:17 UTC (Thu)
                               by <b>cma</b> (guest, #49905)
                              [<a href="/Articles/375100/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Mel, thanks A LOT! It's all very clear now!

Best regards!
      
          <div class="CommentReplyButton">
            <form action="/Articles/375100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor375220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2010 10:57 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/375220/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I find myself looking at huge pages and thinking that huge pages are a feature that will be useful only for special-purpose single-use machines (basically just the two Mel mentions: simulation and databases, and perhaps here and there virtualization where the machine has *lots* of memory) until the damn things are swappable. Obviously we can't swap them as a unit (please wait while we write a gigabyte out), so we need to break the things up and swap bits of them, then perhaps reaggregate them into a Gb page once they're swapped back in. Yes, it's likely to be a complete sod to implement, but it would also give that nice TLB-hit speedup feeling without having to worry if you're about to throw the rest of your system into thrash hell as soon as the load on it increases. (Obviously once you *do* start swapping speed goes to hell anyway, so the overhead of taking TLB misses is lost in the noise. In the long run, defragmenting memory on swapin and trying to make bigger pages out of it without app intervention seems like a good idea, especially on platforms like PPC with a range of page sizes more useful than 4Kb/1Gb.)<br>
<p>
IIRC something similar to this being discussed in the past, maybe as part of the defragmentation work? ... I also dimly remember Linus being violently against it but I can't remember why.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2010 12:03 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/375222/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>What you really want (but it's difficult to do sanely on x86) is transparent huge pages. Where possible, the kernel gives you continguous physical pages for continguous virtual pages, and it transparently converts suitable sets of continguous virtual pages to the next size of mapping up when it can do so, and splits large mappings into the next size down when they're not in use, or when there's memory pressure.
<p>The pain on x86 is twofold: first, instead of getting to aggregate (e.g.) 16 4K pages into a 16K page, then 16 16K pages into a 256K page, you get to do things like aggregate 1024 4K pages into a 4M page, and 256 4M pages into a 1GB page. Second, typical x86 TLBs are split by page type; so it's not uncommon to have something like the Core 2 Duo, where you have 128 entries for 4K pages, and just 4 entries for 4M pages (Instruction TLB).
<p>Given that split, most workloads gain more from having the kernel always in the TLB, than from evicting the kernel in favour of your own code (which would have been in the 4K page size TLB otherwise).
      
          <div class="CommentReplyButton">
            <form action="/Articles/375222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2010 14:15 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/375234/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doesn't Linux already use huge pages for the kernel? Or am I misremembering <br>
something?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2010 14:19 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/375236/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>It does. The work being done is for huge pages for userspace, which is a whole different ballgame, and could result in the kernel's hugepage mapping being pushed out of the TLB.
<p>If/when someone does the work, it'll need benchmarking not just on the latest and greatest, but also on real-world older systems with more restrictive TLBs, to see if it's a net loss.
      
          <div class="CommentReplyButton">
            <form action="/Articles/375236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2010 16:33 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/375327/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This stuff could presumably autotune, kicking in only on CPUs for which it <br>
is a net win.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor375325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2010 16:31 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/375325/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, hell, I forgot about the split TLB. That makes the whole resource <br>
allocation problem drastically harder :/ Still, does the kernel need more <br>
than one or two entries? If you're not using hugepages currently, it seems <br>
to me that some of those hugepage TLB entries are actually wasted...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor375751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Alan Cox on FreeBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2010 5:22 UTC (Tue)
                               by <b>man_ls</b> (guest, #15091)
                              [<a href="/Articles/375751/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      You are probably thinking of <a href="http://lwn.net/Articles/250335/">this excellent LWN article</a> from 2007 and the excellent <a href="http://en.scientificcommons.org/42636713">Navarro paper</a> (with a contribution by Alan Cox). The fact that they decided to bring transparent huge pages support to FreeBSD and not to Linux is funny, considering.
      
          <div class="CommentReplyButton">
            <form action="/Articles/375751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Alan Cox on FreeBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2010 6:10 UTC (Tue)
                               by <b>viro</b> (subscriber, #7872)
                              [<a href="/Articles/375753/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ac != alc...  IOW, it's not who you probably think it is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor375882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Alan Cox on FreeBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2010 21:53 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/375882/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wish I had been thinking of that paper, but I had no idea it existed. <br>
Unfortunately all the links to it appear dead :( 10.1.1.14.2514 is not a <br>
valid DOI as far as I can tell, and the source link throws an error page <br>
at me...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor375999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Alan Cox on FreeBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2010 19:37 UTC (Wed)
                               by <b>biged</b> (guest, #50106)
                              [<a href="/Articles/375999/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Try here: <a href="http://www.usenix.org/events/osdi02/tech/full_papers/navarro/navarro_html/">http://www.usenix.org/events/osdi02/tech/full_papers/nava...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/375999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor376035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Alan Cox on FreeBSD</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2010 22:47 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/376035/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yay, thank you!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/376035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor395104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 7, 2010 4:48 UTC (Wed)
                               by <b>glennewton</b> (guest, #64085)
                              [<a href="/Articles/395104/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I've collected a number of good resources for huge pages for Linux, Java, Solaris, MySql, AMD here: <a rel="nofollow" href="http://zzzoot.blogspot.com/2009/02/java-mysql-increased-performance-with.html">Java, MySql increased performance with Huge Pages</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/395104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor530694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Huge pages part 1 (Introduction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 26, 2012 8:00 UTC (Wed)
                               by <b>heguanjun</b> (guest, #88525)
                              [<a href="/Articles/530694/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
well, now there is another huge page implementation: Transparent huge pages. and with many benefits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/530694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
