        <!DOCTYPE html>
        <html lang="en">
        <head><title>How 3.6 nearly broke PostgreSQL [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/518329/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/517825/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/518329/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>How 3.6 nearly broke PostgreSQL</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 2, 2012</br>
           </div>
In mid-September, the 3.6 kernel appeared to be stabilizing nicely.  Most
of the known regressions had been fixed, the patch volume was dropping, and
Linus was relatively happy.  Then Nikolay Ulyanitsky showed up with <a
href="/Articles/518330/">a problem</a>: the <tt>pgbench</tt> PostgreSQL
benchmark ran 20% slower than under 3.5.  The resulting discussion shows
just how hard scalability can be on contemporary hardware and how hard
scheduling can be in general.
<p>
Borislav Petkov was able to reproduce the problem; a dozen or so bisection
iterations later he narrowed down the problem to <a
href="http://git.kernel.org/linus/970e178985cadbca660feb02f4d2ee3a09f7fdda">this
patch</a>, which was duly reverted.  There is just one little problem left: the
offending patch was, itself, meant to improve scheduler performance.
Reverting it fixed the PostgreSQL regression, but at the cost of losing an
optimization that improves things for many (arguably most) other
workloads.  Naturally, that led to a search to figure out what the real
problem was so that the optimization could be restored without harmful
effects on PostgreSQL.
<p>
<h4>What went wrong</h4>
<p>
The kernel's <a href="/Articles/80911/">scheduling domains</a> mechanism
exists to optimize scheduling decisions by modeling the costs of moving
processes between CPUs.  Migrating a process from one CPU to a
hyperthreaded sibling is nearly free; cache is shared at all levels, so the
moved process will not have to spend time repopulating cache with its
working set.  Moving to another CPU within the same physical package will
cost more, but mid-level caches are still shared, so such a move is still
much less expensive than moving to another package entirely.  The current
scheduling code thus tries to keep processes within the same package
whenever possible, but it also tries to spread runnable processes across the
package's CPUs to maximize throughput.
<p>
The problem that the offending patch (by Mike Galbraith) was trying to
solve comes from the fact that the number of CPUs built into a single
package has been growing over time.  Not too long ago, examining every
processor within a package in search of an idle CPU for a runnable process
was a relatively quick affair.  As the number of CPUs in a package
increases, the cost of that search increases as well, to the point that it
starts to look expensive.  The current scheduler's behavior, Mike said at
the time, could also result in processes bouncing around the package
excessively.  The result was less-than-optimal performance.
<p>
Mike's solution was to organize CPUs into pairs; each CPU gets one "buddy"
CPU.  When one CPU wakes a process and needs to find a processor for that
process to run on, it examines only the buddy CPU.  The process will be
placed on either the original CPU or the buddy; the search will go no
further than that even if there might be a more lightly loaded CPU
elsewhere in the package.  The cost of iterating
over the entire package is eliminated, process bouncing is reduced, and
things run faster.  Meanwhile, the scheduler's load balancing code can
still be relied upon to distribute the load across the available CPUs in
the longer term.  Mike reported significant improvements in <tt>tbench</tt>
benchmark results with the patch, and it was quickly accepted for the 3.6
development cycle.
<p>
So what is different about PostgreSQL that caused it to slow down in
response to this change?  It seems to come down to the design of the
PostgreSQL server and the fact that it does a certain amount of its own
scheduling with user-space spinlocks.  Carrying its own spinlock
implementation does evidently yield performance benefits for the PostgreSQL
project, but it also makes the system more susceptible to problems
resulting from scheduler changes in the underlying system.

In this case, restricting the set of CPUs on which a newly-woken process
can run increases the chance that it will end up preempting another
PostgreSQL process.  If the new process needs a lock held by the preempted
process, it will end up waiting until the preempted processes manages to
run again, slowing things down.  Possibly even worse is that preempting the
PostgreSQL dispatcher 
process — also more likely with Mike's patch — can slow the flow of tasks
to all PostgreSQL worker processes; that, too, will hurt performance.
<p>
<h4>Making things better</h4>
<p>
What is needed is a way to gain the benefits of Mike's patch without making
things worse for PostgreSQL-style loads.  One possibility, <a
href="/Articles/518351/">suggested by Linus</a>, is to try to reduce the
cost of searching for an idle CPU instead of eliminating the search
outright.  It appears that there is some low-hanging fruit in this area,
but it is not at all clear that optimizing the search, by itself, will
solve the entire problem.  Mike's patch eliminates that search cost, but it
also reduces movement of processes around the package; a fix that only
addresses the first part risks falling short in the end.
<p>
Another possibility is to simply increase the scheduling granularity,
essentially giving longer time slices to running processes.  That will
reduce the number of preemptions, making it less likely that PostgreSQL
processes will step on each other's toes.
Increasing the
granularity does, indeed, make things better for the <tt>pgbench</tt>
load.  There may be some benefit to be had from messing with the
granularity, but it is not without its risks.  In particular, increasing
the granularity could have an adverse effect on desktop interactivity;
there is no shortage of Linux users who would consider that to be a bad
trade.
<p>
Yet another possibility is to somehow teach the scheduler to recognize
processes — like the PostgreSQL dispatcher — that should not be preempted
by related processes if it can be avoided.  Ingo Molnar <a
href="/Articles/518358/">suggested</a> investigating this idea:
<p>
<div class="BigQuote">
	Add a kernel solution to somehow identify 'central' processes and
   	bias them. Xorg is a similar kind of process, so it would help
   	other workloads as well. That way lie dragons, but might be worth
   	an attempt or two.
</div>
<p>
The problem, of course, is the dragons.  The O(1) scheduler, used by Linux
until the Completely Fair Scheduler (CFS) was merged for 2.6.23, had, over
time, accumulated no end of heuristics and hacks designed to provide the
"right" kind of scheduling for various types of workloads.  All these
tweaks complicated the scheduler code considerably, making it fragile and
difficult to work with — and they didn't even work much of the time.  This
complexity inspired Con Kolivas's "staircase deadline scheduler" as a much
simpler solution to the problem; that work led to the writing (and merging)
of CFS.  
<p>
Naturally, CFS has lost a fair amount of its simplicity since it was merged;
contact with the real world tends to do that to scheduling algorithms.  But
it is still relatively free of workload-specific heuristics.  Opening the
door to more of them now risks driving the scheduler in a less
maintainable, more brittle direction where nothing can be done without
a significant chance of creating problems in unpredictable places.  It
seems unlikely that the development community wants to go there.
<p>
A potentially simpler alternative is to let the application itself tell the
scheduler that one of its processes is special.  PostgreSQL could request
that its dispatcher be allowed to run at the expense of one of its own
workers, even if the normal scheduling algorithm would dictate otherwise.
That approach reduces complexity, but it does so by pushing some of the
cost into applications.  Getting application developers to accept that cost
can be a challenge, especially if they are interested in supporting
operating systems other than Linux.  As a general rule, it is far better if
things just work without the need for manual intervention of this type.
<p>
So, in other words, nobody really knows how this problem will be solved at
this time.  There are several interesting ideas to pursue, but none that
seem like an obvious solution.  Further research is clearly called for.
<p>
One good point in all of this is that the problem was found before the
final 3.6 kernel shipped.  Performance regressions have a way of hiding,
sometimes for years, before they emerge to bite some important workload.
Eventually, tools like <a href="/Articles/487701/">Linsched</a> may help to
find more of these problems early, but we will always be dependent on users
who will perform this kind of testing with workloads that matter to them.
Without Nikolay's 3.6-rc testing, PostgreSQL users might have had an
unpleasant surprise when this kernel was released.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler">Scheduler</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/518329/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor518378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2012 23:43 UTC (Tue)
                               by <b>xorbe</b> (guest, #3165)
                              [<a href="/Articles/518378/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linus has already noted the right solution: one can't just throw out possible cpu execution resources.  We've been through this before.  For the masses, a reliable and predictable scheduler is far better than one that makes 99% of things run a touch faster, but hoses the remaining 1% -- eventually it snags some major oft-used package.  The other proposed ideas in the article seem crazy.  Leave the fine scheduler tuning for shops that need to squeeze out the last few percent for a dedicated work load.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 1:01 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/518382/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree.<br>
<p>
My thought when I read about this problem is that PostgreSQL is causing it with their user-space locking and so PostgreSQL needs to fix it. Perhaps it should pin its processes to particular cores, ensuring that it spreads out across all the cores. It could also nice its worker processes while leaving the dispatcher at normal. Or it could negative-nice (would that be making the process mean?) its dispatcher.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 2:34 UTC (Wed)
                               by <b>fdr</b> (guest, #57064)
                              [<a href="/Articles/518385/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no user-space locking that is portable, bug-free, and fast enough to satisfy PostgreSQL on its supported platforms.  So, as far as I know, this is pretty much off the table, and there are good reasons for that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 3:19 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/518387/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How much faster is PostgreSQL's userspace locking than futexes?  In theory, futexes have no kernel overhead when acquired uncontended, and minimal overhead (just the overhead of blocking in the scheduler) when contended.  The only case I can think of that would have less overhead would involve busy-waiting in userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 4:30 UTC (Wed)
                               by <b>fdr</b> (guest, #57064)
                              [<a href="/Articles/518389/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think someone wrote up a prototype (actually, I think that may be several across many years, this being the latest incarnation I know of):<br>
<p>
<a href="http://archives.postgresql.org/pgsql-hackers/2012-06/msg01588.php">http://archives.postgresql.org/pgsql-hackers/2012-06/msg0...</a><br>
<p>
This actually uses futexes indirectly, in my understanding from the post, and it's not the most awful thing for Linux.<br>
<p>
It's possible that Linux futexes are not a bad idea (but it's also not clearly a huge improvement), but s_lock does okay and has existed an awfully long time (with iteration), so there's some inertia there.<br>
<p>
Also, I think I oversimplified the parent's post, he could have simply meant that something about s_lock is not very good, as opposed to "self-rolled user space spinlocks? That's ridiculous!" (as a straw man).  It's possible s_lock could be improved, however, it was fine before and doesn't clearly seem at fault right now.  I think the suggestion of having to manhandle the platform-specific scheduler also seems excessive.  There may be a better solution to serve everyone; somehow I can't see PostgreSQL's spinlocks being one-of-a-kind in this pathology, but I haven't attempted to prove that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor518456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 18:56 UTC (Wed)
                               by <b>jberkus</b> (guest, #55561)
                              [<a href="/Articles/518456/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; My thought when I read about this problem is that PostgreSQL is causing it with their user-space locking and so PostgreSQL needs to fix it. </font><br>
<p>
So there's a couple major problems with the idea that this issue should be fixed in the PostgreSQL code:<br>
<p>
1. PostgreSQL is not the only application with its own spinlock implementatation.  There is, for example, Oracle.<br>
<p>
2. While we might be able to change locking in future versions of PostgreSQL, we can't change locking in past ones.<br>
<p>
Even if the next version of PostgreSQL (9.3) has a modified locking implementation which doesn't hit the issues in 3.6, the number of people running older versions of PostgreSQL will far outnumber the folks running the latest version for quite some time. What you'd be saying to all of those folks is, effectively, "don't upgrade Linux".<br>
<p>
So any solution which hinges on "make these modifications to PostgreSQL" will instead result in PostgreSQL users deciding to stay on old versions of the Kernel.  If this problem is equally bad for Oracle, you might even see RedHat refusing to deploy a version based on 3.6.<br>
<p>
There's also the fact that PostgreSQL's locking implementation is complex and quite highly tuned.  So the idea that the PostgreSQL project could make changes which wouldn't result in a worse regression in a few months is optimistic.  Implementing things like futex support could take literally years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 19:00 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/518459/">Link</a>] 
      </p>
      
      </div>
      </summary>
      FWIW, the discussion in kernelland was based on the assumption that this regression was the kernel's problem.  Nobody there suggested telling the PostgreSQL developers to come up with a new locking scheme.
      
          <div class="CommentReplyButton">
            <form action="/Articles/518459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor518384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 2:13 UTC (Wed)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/518384/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems to me that a more lightly-loaded core should be put to work first recruiting work from its more heavily-loaded neighbors, offloading both scheduling activity and finally other processes from them.  Is there something very cheap that a busy core could do that allows its neighbors to make better decisions about what work to take away from it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 12:36 UTC (Wed)
                               by <b>rvfh</b> (guest, #31018)
                              [<a href="/Articles/518406/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unless I misread the code, it's more or less what happens now: if a core becomes idle and no load balancer exists in the system, it will start assuming that role and try to get some work to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2012 10:28 UTC (Fri)
                               by <b>amit.kucheria</b> (subscriber, #59246)
                              [<a href="/Articles/518673/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Except when you're trying to optimize for power, which we're trying to do in the ARM world. :)<br>
<p>
Consolidating work onto fewer cores[1] is something we're actively looking into. <br>
<p>
[1] <a href="https://blueprints.launchpad.net/linaro-power-kernel/+spec/power-aware-scheduler">https://blueprints.launchpad.net/linaro-power-kernel/+spe...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2012 7:35 UTC (Sat)
                               by <b>rodgerd</b> (guest, #58896)
                              [<a href="/Articles/519688/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not just the ARM world, really; consider the turbo mode available with newer Intel and AMD processors.  If you're doing work that runs better with fewer, faster threads rather than more slower ones, you'd want to aggregate the workload onto fewer cores and let the CPU ratchet the clock up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor518392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 7:31 UTC (Wed)
                               by <b>ajb</b> (guest, #9694)
                              [<a href="/Articles/518392/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having only one 'buddy' core divides the set of cores into isolated pairs, Checking two would allow processes to move anywhere within the set, as in a skew cache or cuckoo hashing. Maybe that would work better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 8:07 UTC (Wed)
                               by <b>Zenith</b> (guest, #24899)
                              [<a href="/Articles/518393/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am not familiar with skew caches or cuckoo hashing, so I may just be restating your solution.<br>
<p>
Would a better solution than the one suggested by Mike not be to have 3 cores in each set, and then make the sets overlap.<br>
<p>
So say we have a 4-core CPU (labelled A, B, C, and D), that then gets divided into two sets X = (A, B, C) and Y = (A, C, D).<br>
That way the load can migrate from one set (X) of CPU's into another set (Y), provided that the load migration code gets lucky on selecting set Y.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 12:03 UTC (Wed)
                               by <b>ajb</b> (guest, #9694)
                              [<a href="/Articles/518403/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your example has convinced me that I was wrong to say that you could get away with only two buddies. If you have only two, the best you can do is have a ring of cpus. This is different from the case of cuckoo hashing and skew caches, where only two places are sufficient.<br>
<p>
However, in your example, A and C have 3 buddies, but B and D have only two. It seems like the scheduling algorithm would be just as efficient if they all had three, and there would be a better chance that migrations would be beneficial. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 13:31 UTC (Wed)
                               by <b>and</b> (guest, #2883)
                              [<a href="/Articles/518408/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I understood that approach differently: If core A has B as its buddy, B's buddy does not necessarily need to be A. This would imply kind of a ring buffer of buddies within the package (A-&gt;B-&gt;C-&gt;D-&gt;A)...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor518533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2012 10:46 UTC (Thu)
                               by <b>dunlapg</b> (guest, #57764)
                              [<a href="/Articles/518533/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, it seems like if the problem is there are "too many" cores per socket, that instead of fixing on 2, it should be fixed on "almost but not quite too many" -- e.g., 4 for example?  So if you have 4-cores per socket, it looks exactly like it does before; but if you have 8, you still only look at 4 other cores.  Having the sets overlap seems like an obvious way to make sure things can find a good optimum within a few iterations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2012 8:13 UTC (Sat)
                               by <b>eternaleye</b> (guest, #67051)
                              [<a href="/Articles/518785/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another option might be to use a Kautz digraph - it seems like in terms of a migration problem like this, it might be very nearly optimal.<br>
<p>
I've found this to be a far clearer explanation than the Wikipedia article: <a rel="nofollow" href="http://pl.atyp.us/wordpress/index.php/2007/12/the-kautz-graph/">http://pl.atyp.us/wordpress/index.php/2007/12/the-kautz-g...</a><br>
<p>
In learning about them myself, I wrote a perl script to generate a Kautz graph: <a rel="nofollow" href="http://ix.io/36j/">http://ix.io/36j/</a><br>
<p>
It takes the degree as the first argument and the dimension and the second, and outputs a list of edges as &lt;from&gt; &lt;to&gt; tuples, one per line.<br>
<p>
I still need to write the Kautz::Graph class (stubbed in the file above) to embody a full set of the Kautz nodes with the same degree and dimension parameters, and see about modifying it to generate dot so it can make a nice graphic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2012 8:26 UTC (Sat)
                               by <b>eternaleye</b> (guest, #67051)
                              [<a href="/Articles/518786/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
...And I just realized I misread my own code. It actually prints the names of the nodes, it's just that the symbols of the name are space-separated since they can be any positive integer &lt;= degree.<br>
<p>
Well, one more thing to remedy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2012 8:45 UTC (Sat)
                               by <b>eternaleye</b> (guest, #67051)
                              [<a href="/Articles/518788/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Alright, here's a version that has a Kautz::Graph class, and prints both nodes and edges when run: <a rel="nofollow" href="http://ix.io/36k/">http://ix.io/36k/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor518405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 12:40 UTC (Wed)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/518405/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Possibly even worse is that preempting the PostgreSQL dispatcher process — also more likely with Mike's patch — can slow the flow of tasks to all PostgreSQL worker processes; that, too, will hurt performance.</font><br>
The thing you could describe as a dispatcher, the "postmaster" process, which forks to create individual backends after receiving a connection requests doesn't do any relevant locking. So preemting it should be mostly harmless.<br>
There are other processes though which might have something like the effect described above. Namely the 'wal writer', 'checkpointer' (9.2+, included in bgwriter before) and bgwriter processes. Especially if you have a write intensive concurrent workload interactions between individual connection backends and the wal writer can get contended. So its somewhat likely that preemption might get painful there.<br>
<p>
Postgres is *far* from the only application doing its own spinlock implementation and contending on the locks every now and then. I am pretty sure that if the patch had made its way into 3.6 more performane regression reports would have come in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 18:22 UTC (Wed)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/518449/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems like anyone who uses pthread_spin_lock or a similar thing could run into this problem.  Whenever one thread waits on another, without telling the kernel, the kernel might make a scheduling decision that ends up being suboptimal (like putting them both on the same core.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor518461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2012 19:09 UTC (Wed)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/518461/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed.  My limited opinion is simply that spinning is a sometimes neccessary evil; avoid it whenever possible; use a kernel supported mechanism if you expect to get consistent kernel behavior.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2012 20:45 UTC (Fri)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/518745/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Couldn't libpthreads notify the kernel that pthread_spin_lock() is in use?  You certainly wouldn't want to introduce a system call on every use but having to branch on the first use by a given pid shouldn't be too expensive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor519488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2012 21:29 UTC (Thu)
                               by <b>bbulkow</b> (guest, #87167)
                              [<a href="/Articles/519488/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm somewhat pained by the "we can't make the desktop less responsive" argument.<br>
<p>
As a high performance server author (currently <a rel="nofollow" href="http://Aerospike.com/">http://Aerospike.com/</a> ), I am working hard to avoid context switch overhead in a few places. We are getting hurt by core scheduling issues - we often recommend turning off hyperthreading.<br>
<p>
I have tried signalling to the OS heuristic I think make my server go faster. I've used sched_setscheduler(), which seemed to be effective before CFS but makes no difference in "modern" kernels.<br>
<p>
As Linux is more beloved as a server OS, what's so bad about having known tuning parameters / API calls to change the scheduling heuristics? Is sched_setscheduler() to be avoided?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor519526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How 3.6 nearly broke PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2012 1:27 UTC (Fri)
                               by <b>bjmaz</b> (guest, #87170)
                              [<a href="/Articles/519526/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seems to me a solution to this problem could be to dedicate a core to scheduling. This, of course, would assume a many-core, homogenous system. The scheduler could then keep track of free resources/running processes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
