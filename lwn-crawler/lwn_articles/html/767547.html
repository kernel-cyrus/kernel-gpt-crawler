        <!DOCTYPE html>
        <html lang="en">
        <head><title>New AT_ flags for restricting pathname lookup [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/767547/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/767620/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/767547/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>New AT_ flags for restricting pathname lookup</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 4, 2018</br>
           </div>
System calls like <tt><a
href="http://man7.org/linux/man-pages/man2/open.2.html">openat()</a> </tt>
have access to the entire filesystem —
or, at least, that part of the filesystem that exists in the current mount
namespace and which the caller has the
permission to access.  There are times, though, when it is desirable to
reduce that access, usually for reasons of security; that has proved to be
especially true in many container use cases.  A new <a
href="/ml/linux-kernel/20180929103453.12025-1-cyphar@cyphar.com/">patch
set</a> from Aleksa Sarai has revived an old idea: provide a set of
<tt>AT_</tt> flags that can be used to control the scope of a given
pathname lookup operation.
<p>
There have been previous attempts at restricting pathname lookup, but none
of them have been merged thus far.  David Drysdale <a
href="/Articles/619146/">posted an <tt>O_BENEATH</tt> option</a> to
<tt>openat()</tt> in 2014 that would require the eventual target to be
underneath the starting directory (as provided to <tt>openat()</tt>) in the
filesystem hierarchy.  More 
recently, Al Viro suggested <tt><a
href="/Articles/723057/">AT_NO_JUMPS</a></tt> as a way of preventing
lookups from venturing outside of the current directory hierarchy or the
starting directory's mount point.  Both ideas have attracted interest, but
neither has yet been pushed long or hard enough to make it into the
mainline.
<p>
Sarai's venture into this territory takes the form of several new
<tt>AT_</tt> flags that can be used with system calls like
<tt>openat()</tt>:
<p>
<ul class="spacylist">
<li> <tt>AT_BENEATH</tt> would, similar to <tt>O_BENEATH</tt>, prevent
     the pathname lookup from moving above the starting point in the
     filesystem hierarchy.  So, as a simple example, an attempt to open
     <tt>../foo</tt> would be blocked.  This option <i>does</i> allow the
     use of "<tt>..</tt>" in a pathname as long as the result remains below
     the starting point, though, so opening <tt>foo/../bar</tt> would
     work. 
<li> <tt>AT_XDEV</tt> prevents the lookup from crossing a mount-point
     boundary in either the upward or downward direction.
<li> <tt>AT_NO_PROCLINK</tt> prevents the following of symbolic links found
     in the <tt>/proc</tt> hierarchy; in particular, it is aimed at the
     links found under <tt>fd/</tt> in any specific process's directory.
<li> <tt>AT_NO_SYMLINK</tt> prevents following any symbolic links at all,
     including those blocked by <tt>AT_NO_PROCLINK</tt>.
<li> <tt>AT_THIS_ROOT</tt> performs the equivalent of a <a
     href="http://man7.org/linux/man-pages/man2/chroot.2.html"><tt>chroot()</tt></a>
     call (to the starting directory) prior to the beginning of pathname
     lookup.  This option, too, is meant to constrain lookups to the given
     directory hierarchy; it will also change how absolute symbolic links
     are interpreted.
</ul>
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
There are numerous use cases for these new flags, but the driving
force this time around would appear to be container workloads and, in
particular, runtime systems for containers.  Those systems often
have to look 
inside a container and, perhaps, act on files within a container's
directory hierarchy.  If the container itself is compromised or otherwise
malicious, it can attempt to play games with its filesystems to confuse the
runtime system and gain access to the host.
<p>
This posting got a reception that was positive overall, but with a number
of concerns about the details.  For example, Jann Horn <a
href="/ml/linux-kernel/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/">liked
<tt>AT_BENEATH</tt></a>, but would rather that it forbade the use of
"<tt>..</tt>" entirely, even if the result remains beneath the starting
point.  Doing so would help to block exploitation of various types of
directory-traversal bugs, he said.  Sarai <a
href="/ml/linux-kernel/20181001160431.emb6b2hf32b754cl@ryuk/">responded</a>
that 37% of all the symbolic links on his system contained "<tt>..</tt>";
"<q>this indicates to me that you would be restricting a large amount of
reasonable resolutions because of this restriction</q>".  That said, he
indicated a willingness to change the behavior if need be.
<p>
Horn also <a
href="/ml/linux-kernel/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/">complained</a>
about the "<q>footgun potential</q>" of <tt>AT_THIS_ROOT</tt> which,
he said, shares all of the security failings of <tt>chroot()</tt>.  He
described a scenario where a hostile container could force an escape by
moving directories around: "<q>If the root of your walk is below an
attacker-controlled directory, this of course means that you lose
instantly</q>".  A possible mitigation here would be to require the
starting directory in <tt>AT_THIS_ROOT</tt> lookups to be a mount point;
Sarai was <a
href="/ml/linux-kernel/20181001054246.gfinmx3api7kjhmc@ryuk/">amenable</a>
to making this change as well.
<p>
Horn, along with <a
href="/ml/linux-kernel/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/">Andy
Lutomirski</a>, questioned the container-management use case; as Lutomirski
put it: "<q>Any sane container is based on
pivot_root or similar, so the runtime can just do the walk in the container
context</q>".  In this particular case, it <a
href="/ml/linux-kernel/20181001054246.gfinmx3api7kjhmc@ryuk/">turns
out</a> that part of the problem is the result of the fact that the
container runtime in question is written in Go:
<p>
<div class="BigQuote">
	You're right about this -- for C runtimes. In Go we cannot do a raw
	clone() or fork() (if you do it manually with RawSyscall you'll end
	with broken runtime state). So you're forced to do fork+exec (which
	then means that you can't use CLONE_FILES and must use
	SCM_RIGHTS). Same goes for CLONE_VFORK.
</div>
<p>
Since the system cannot use the relatively cheap ways to get into a
container's context, it has to use an expensive workaround instead; this
expense could be avoided if files could be opened with the new
<tt>AT_</tt> flags.  Lutomirski <a
href="/ml/linux-kernel/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/">responded</a>
that he is "<q>not very sympathetic to the argument that 'Go's
runtime model is incompatible with the simpler solution'</q>".  He
proposed an alternative that might work in this setting without adding the
new flags.
<p>
That alternative might work, but the fact remains that there are other use
cases for restricting the scope of pathname lookups; that is why the idea
continues to pop up on the kernel's mailing lists.  And Lutomirski, too, <a
href="/ml/linux-kernel/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/">agreed</a>
that some of the flags seem useful.  Whether this implementation will be
the one that manages to go all the way to the mainline remains to be seen,
but it seems likely that, one of these years, the kernel will gain the
ability to control lookups in a way similar to the one that has been
proposed here.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Virtual_filesystem_layer">Filesystems/Virtual filesystem layer</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Virtual_filesystem_layer">Linux kernel/Virtual filesystem layer</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/767547/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor767637"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2018 21:36 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/767637/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't understand why the Go team is so resistant to adding the ability to explicitly pin a goroutine to a machine thread. Goroutines are an amazing, almost ideal construct. But there's a very obvious and unresolvable impedance mismatch between how a goroutine implement threading (linear flow of logical execution) and how traditional operating systems do. A similar mismatch exists with FFI ABIs (i.e. stack details) and with the blocking semantics of some syscalls. In those cases a goroutine *is* pinned to a machine thread; indeed, the very architecture of the Go runtime (the [G]oroutine, OS [M]achine thread, and [P]rocessor scheduling abstractions) is built around this mismatch. It's inexplicable to me why they refuse to expose the scheduling levers that must necessarily exist.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767637/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767639"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2018 21:45 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/767639/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can pin a goroutine to a thread using LockOSThread, but it basically locks this thread out of running other goroutines.<br>
<p>
(Personally, I'd like for them to add goroutine IDs)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767639/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor767656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 7:13 UTC (Fri)
                               by <b>kostix</b> (guest, #119803)
                              [<a href="/Articles/767656/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That wouldn't have helped anyway: the problem with not being able to do the classic fork+exec in Go programs is that the code executing in each of them heavily relies on the live Go runtime (which is linked with/into any compiled Go executable and actually manages the whole lifecycle of the program), and that runtime exploits multiple OS threads — both to run the program's goroutines and do its own chores.<br>
<p>
Since fork() clones the state of just a single thread — the one which happened to execute that syscall, — as soon as the control resumes in the child process, there is literally no Go runtime anymore around the goroutine "awoken" in the cloned thread, and as soon as it happens to call anything which would normally reach for the runtime, it is hosed. And normally such a call would happen pretty soon.<br>
<p>
So basically the only sensible thing one might safely do after forking a process running a Go program is to do a controlled set of preparations and exec().<br>
And actually that's what the syscall.ForkExec does — with some added complexity stemming from Go having an execution model other than C ;-)<br>
<p>
You can look at ForkExec in <a href="https://golang.org/src/syscall/exec_unix.go">https://golang.org/src/syscall/exec_unix.go</a> and then at forkAndExecInChild in <a href="https://golang.org/src/syscall/exec_linux.go">https://golang.org/src/syscall/exec_linux.go</a> — the code is very easy to follow for any programmer with a C background, and it is extensively commented.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2018 1:37 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/767745/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Shouldn't it be possible to quiesce the runtime (pause GC, park all other goroutines, and join all kernel threads)? All the machinery in the scheduler must already be there, more or less. Maybe some component is currently running in a dedicated thread in an infinite loop, but conceptually it could be refactored to be able to enter and exit its core loop.<br>
<p>
It might not be particularly efficient and come with a ton of gotchas, but it would at least make some currently impossible things possible, such as using geteuid and forking helper processes. Those things tend to happen early on, anyhow, so performance and other limitations wouldn't matter much.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor767645"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2018 22:52 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/767645/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Surely this could be vastly simplified by allowing an eBPF program to be attached to a file descriptor so that when a path_lookup starts from that file descriptor, the eBPF program is used to vet or modify the lookup of each component.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767645/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767646"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2018 23:03 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/767646/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No......<br>
<p>
Please, no more eBPF. It never ever works outside of kernel developers' machines.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767646/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767659"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 7:31 UTC (Fri)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/767659/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe neilbrown was joking.  I have no evidence for this, but I am desperately choosing to believe it anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767659/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 7:34 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/767660/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope so. I've just spent a day debugging a eBPF filter written by somebody else and it's NOT a nice experience at all.<br>
<p>
Debugging infrastructure is sorely lacking for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 12:10 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/767669/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
eBPF is a nice thing to have if machine-generated (it's a rather nice and orthogonal assembler, and the ability to add helpers is just a killer feature that I wish real assemblers had!), but it's about as pleasant to debug programs written in it as any other assembler: i.e. fairly easy if you're familiar with the code generator, a nightmare otherwise, doubly so if this is the less regular land of handwritten code, disassembled and devoid of comments.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 17:14 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/767719/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's way worse than assembly. With assembly you can typically use debuggers to trace the execution and inspect the environment. Nothing comparable exists for eBPF.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 22:24 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/767741/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Generally I do the same thing when debugging eBPF that I do when debugging other programs: printf()! In the case of eBPF you throw in a helper that does a printk() and chuck in calls to the helper liberally. (This is not so useful if you can't modify the eBPF, mind you.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor767648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2018 23:55 UTC (Thu)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/767648/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be “simple” in the sense that getting the eBPF right would be at least as difficult as getting the kernel code with the AT flags right would be.  But with eBPF, no one would ever review it carefully or fix the bugs.<br>
<p>
eBPF is flexible, but it’s not magic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor767654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 4:13 UTC (Fri)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/767654/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      openat() is one of those Linux system calls whose rationale I don't quite understand. It allows opening files relative to a particular directory, but can't you do the same thing by manipulating the path name, or by using chdir() first?

      
          <div class="CommentReplyButton">
            <form action="/Articles/767654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 4:33 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/767655/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can't, not in a race-free way anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor767664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 10:47 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/767664/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For one, chdir affects the entire process rather than the current thread only.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor767668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 12:08 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/767668/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Others have commented on the problems with chdir(). The problem with using long absolute pathnames is twofold: firstly, you race with people modifying symlinks and/or renaming out from underneath you (*at() can at least reduce this by nailing the walk to specific directory inodes). Secondly, the length of pathnames is capped at pathconf(..., _SC_PATH_MAX): but you can make directory trees of arbitrary depth, with absolute paths much deeper than this and indeed deeper than the hardware page size. Nobody does this manually, but it can and does happen with machine-generated hierarchies, and the deep parts of such hierarchies are *only* traversable via chdir() or the *at() syscalls: while you can compose an absolute path that should reach those parts, the kernel will reject it with -ENAMETOOLONG.<br>
<p>
So generic code has no choice but to use chdir() or *at() to traverse hierarchies or fail on such deep hierarchies, and generic multithreaded code or library code which might be run in multithreaded contexts has no choice but to use *at().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor767787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2018 17:22 UTC (Sun)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/767787/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Manipulating pathnames means "doing string operations", something that's fairly cumbersome in C. For an example, consider the following toy-program:

<pre>
#define _GNU_SOURCE

#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;

static char *cwd[] = {
    ".",
    NULL
};

int main(int argc, char **argv)
{
    DIR *dir;
    struct dirent *d_ent;
    struct stat st;
    int dirfd, rc;
    
    ++argv;
    if (!*argv) argv = cwd;
    do {
        dirfd = open(*argv, O_RDONLY, 0);
        if (dirfd == -1) {
            perror("open");
            continue;
        }
        
        dir = fdopendir(dirfd);
        if (!dir) {
            perror("fdopendir");
            continue;
        }

        printf("-----\nfiles in %s\n-----\n", *argv);
        while ((d_ent = readdir(dir))) {
            rc = fstatat(dirfd, d_ent-&gt;d_name, &amp;, 0);
            if (rc == -1) {
                if (errno != ENOENT) perror("fstatat");
                continue;
            }

            if (S_ISREG(st.st_mode))
                printf("%s\t\t%zu bytes\n", d_ent-&gt;d_name, (size_t)st.st_size);
        }

        closedir(dir);
    } while (*++argv);

    return 0;
}
</pre>

This takes a list of directory pathnames as arguments and prints the names and sizes of all files in any of the directories. It uses <em>fstatat</em> because the names returned by <em>readdir</em> are filenames relative to the directory being read.  Thanks to the <em>*at</em>-call, they can be accessed without doing dynamic string manipulation and buffer management and also without changing the cwd of the process forward and backward for each directory.
<p>
Also, <em>chdir</em> is basically unusable in multi-threaded processes as it changes the working directory of the process, ie, it affects all threads, not just the one executing it <strong>and</strong>, as seen by another thread, the cwd change is an unpredictable, asynchronously occuring event. Eg, a thread desiring to create two files in the same directory might end up creating them in different directories.
<p>
Lastly, the directory a process was started in might have been picked intentionally, eg, as location where core dumps should go to, and the process shouldn't change it except if there's a very good reason for that (and this should be documented).

      
          <div class="CommentReplyButton">
            <form action="/Articles/767787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2018 19:27 UTC (Sun)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/767789/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
rc = fstatat(dirfd, d_ent-&gt;d_name, &amp;, 0);<br>
<p>
This should have been<br>
<p>
rc = fstatat(dirfd, d_ent-&gt;d_name, &amp;st, 0);<br>
<p>
and was but got deleted when "htmlifying" the source ... :-(<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor767806"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2018 4:18 UTC (Mon)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/767806/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Thanks to all for explaining the need and use of the <i>something</i>at() calls.

      
          <div class="CommentReplyButton">
            <form action="/Articles/767806/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor767658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Places to block filesystem traversal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 7:11 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/767658/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It’s not just containers. Path-traversal bugs are a common exploit in archivers like tar or unzip, where unpacking a malicious archive file overwrites things elsewhere in the filesystem. I imagine web servers might also use this flag as an additional defence to make sure they only serve content from the right directory. If the flag existed on all operating systems, a lot of userspace path sanitizing code could be removed. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Places to block filesystem traversal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2018 14:24 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/767690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, userspace sanitation depends on the fact that no second thread exists that modifies the sanitized path before it's passed to the kernel. In-kernel defenses against that sort of thing at least work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor767769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2018 0:34 UTC (Sun)
                               by <b>judas_iscariote</b> (guest, #47386)
                              [<a href="/Articles/767769/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is quite unfortunate that kernel developers insist on extending openat()  with more and more contrived semantics, I wish they just added new syscalls with well defined behaviour.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor767773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New AT_ flags for restricting pathname lookup</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2018 4:36 UTC (Sun)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/767773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Something like resolveat(2)? The problem is that this would necessarily be conceptually identical to openat(O_PATH). Maybe O_PATH should've been a different syscall but we are mostly stuck with it now, and I think it would be strange to have two methods of opening an O_PATH descriptor. Though, there are some aspects of O_PATH that I think need to be fixed (and would require more convoluted O_ flags -- maybe a new syscall is warranted to fix some of the semantics of O_PATH. I'm not sure.)<br>
<p>
And remember that the widespread utility of any resolveat(2) syscall would likely require having AT_EMPTY_PATH support for every *at(2) syscall (which is unfortunately far from the case currently).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
