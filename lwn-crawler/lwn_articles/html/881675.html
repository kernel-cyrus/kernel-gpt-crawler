        <!DOCTYPE html>
        <html lang="en">
        <head><title>The kernel radar: folios, multi-generational LRU, and Rust [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/881675/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/881968/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/881675/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The kernel radar: folios, multi-generational LRU, and Rust</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 20, 2022</br>
           </div>
The kernel community is a busy place, so it is not even remotely possible
to write full-length articles about everything that is going on.  Other
topics may be of interest, but not require a longer treatment.  The
answer is a collection of short topics covering developments that are on
the radar; the selection this time around includes folios, the
multi-generational LRU, and Rust in the kernel.
<p>
<h4>A folio update</h4>
<p>
Folios have been an active topic since they were first <a
href="/Articles/849538/">covered here</a> less than one year ago.  A folio,
recall, is just a container for a <tt>struct page</tt> that is guaranteed
not to be a tail page.  It can thus be used to refer to memory, in units of
a single page or larger, in a way that is more type-safe and requiring
fewer run-time checks than when working directly with <tt>page</tt>
structures.  After some <a href="/Articles/868598/">extensive
discussion</a>, the first set of folio patches was merged for the 5.16
kernel.
<p>
A large change of that nature to the memory-management subsystem naturally
leads to fears of regressions, but the work in 5.16 appears to have been
relatively problem-free.  So 5.17 saw another round of folio-related
changes, mostly focused 
on the page cache (which caches file data).  In current kernels, the page
cache holds,
unsurprisingly, pages, but the 4KB page size used on most systems is often
far too small to be efficiently managed.  When dealing with files of
anything but the smallest size, there is value in caching larger chunks at
a time.  The 5.17 conversion of the page cache to use folios is intended,
among other things, to allow the use of "large folios" (a name chosen
because the more descriptive "multi-page folios" was a little too long).
Large folios might be huge pages, but they don't have to be limited to the
huge-page sizes supported by the CPU; the plan is to
support any folio size, as long as it is a power of two.
<p>
The 5.17 work adds the machinery to support large folios in the page
cache, the low-level filesystem-support code, and in the XFS filesystem,
but does not actually start using them yet.  As Matthew Wilcox said in <a
href="/ml/linux-mm/YdyuuBCe4EPmr3k2@casper.infradead.org/">his pull
request</a>: "<q>there may still be places I've overlooked which still
have page size assumptions</q>".  So the coming development cycle will,
presumably, focus on finding any such places so that the transition can
happen in 5.18.  Meanwhile, the more adventurous among us can <a
href="/ml/linux-kernel/20220116121822.1727633-1-willy@infradead.org/">enable
large folios in 5.17</a> and help find the remaining sharp edges.
<p>
<h4>The multi-generational LRU</h4>
<p>
Another significant memory-management change that has been under
development over the last year is the <a
href="/Articles/856931/">multi-generational LRU</a>, which reworks how the
kernel decides which pages to evict when memory is tight.  Current kernels
use a two-queue system, one each for pages deemed "active" and "inactive".
Pages move between the queues based on accesses; when memory is needed, pages
are reclaimed off the end of the inactive queue.  The multi-generational
work generalizes this setup into a larger number of queues, a change that
seemingly improves the kernel's ability to identify the pages that are
unlikely to be needed in the near future.
<p>
When Yu Zhao <a
href="/ml/linux-kernel/20220104202227.2903605-1-yuzhao@google.com/">posted</a>
the sixth version of this patch set in early January, he added <a
href="/ml/linux-kernel/YdSuSHa/Vjl6bPkg@google.com/">a request</a> for
review and a verdict as to whether it could be merged for 5.17.  That
sparked a long discussion on the state of this
work.  As part of that discussion, Michal Hocko (who also did a lot of
detailed review of the patches) <a
href="/ml/linux-kernel/YdxTR4+FL08XyFuO@dhcp22.suse.cz/">repeated</a> a
theme that has been heard with previous postings: that it would be better
to see this work as a series of incremental changes rather than a big
addition of new reclaim mechanism:
<p>
<blockquote class="bq">
	Changes in the reclaim path are paved with failures and reverts and
	fine tuning on top of existing fine tuning.  The difference from
	your patchset is that they tend to be much much smaller and go
	incremental and therefore easier to review.
</blockquote>
<p>
Jesse Barnes <a
href="/ml/linux-kernel/CAJmaN=n=kn9-gC8if5wp8Gfj7uN+QVrX0ex=9JPXC7rPvGf1Qg@mail.gmail.com/">responded</a>
that an incremental series might be worse in this case:
<p>
<blockquote class="bq">
	I understand the desire for an "incremental approach that gets us
	from A-&gt;B".  In the abstract it sounds great.  However, with a
	change like this one, I think it's highly likely that such a path
	would be littered with regressions both large and small, and would
	probably be more difficult to reason about than the relatively
	clean design of MGLRU.  On top of that, I don't think we'll get the
	kind of user feedback we need for something like this *without*
	merging it.
</blockquote>
<p>
Linus Torvalds <a
href="/ml/linux-kernel/CAHk-=whAOM+xQm9vMe33qf8X1LX2QQZ7RBgKe_KH2C3LB=6Jdw@mail.gmail.com/">responded</a>
to Barnes, saying that this work "<q>is worth going with</q>".  Hocko
<a href="/ml/linux-kernel/Yd1et2VFOX4xxgly@dhcp22.suse.cz/">didn't
disagree</a> with Barnes, but did note that there are a lot of things
needing fixing before the code could be merged in any case.
<p>
Zhao, meanwhile, has been actively trying to get supporters of this work to
post to the list in favor of its inclusion.  Those who responded include <a
href="/ml/linux-kernel/ca3a7d27-150d-ed06-c8f8-0c74c4f00667@applied-asynchrony.com/">Holger
Hoffstätte</a>,
<a
href="/ml/linux-kernel/20220111160455.2773-1-szhai2@cs.rochester.edu/">Shuang
Zhai</a> ("<q>the performance improvement is fabulous</q>"),
<a
href="/ml/linux-kernel/CABCjUKBiECMEgnMaCrfApVbWPgw3UuwNH+-Y9ME+2ogJSm+p-Q@mail.gmail.com/">Suleiman
Souhlal</a> ("<q>Android on ChromeOS has been using MGLRU for a while
now, with great results</q>"), <a
href="/ml/linux-kernel/CAMwLHrZi0ZGFsuc74Yj3DErT1zyG2DEudS3ZgPEsexj0XfZJyA@mail.gmail.com/">Sofia
Trinh</a>, <a
href="/ml/linux-kernel/e2db335efc02c61f4a4035dd2270e256@chaos-reins.com/">Donald
Carr</a>, and <a
href="/ml/linux-kernel/11900935.O9o76ZdvQC@natalenko.name/">Oleksandr
Natalenko</a>.
<p>
There is clearly some interest in getting this work merged; it is just as
clearly 
not in the cards for 5.17, though.  Normally one would expect that a change
this fundamental could take a long time yet to get in; given the pressure
and the approval from Torvalds, though, it could happen a bit more quickly
this time.  Merging for 5.18 still seems optimistic, but sometime in 2022
could be a real possibility.
<p>
<h4>Rust for Linux</h4>
<p>
The project to make it possible to develop kernel modules in the Rust
programming language continues to move forward; the <a
href="/ml/linux-kernel/20220117053349.6804-1-ojeda@kernel.org/">third
version</a> of the Rust-support patch set was posted on January&nbsp;17.  A
number of changes had been made to keep up with the Rust community and to
get this work closer to ready for inclusion.
<p>
This version of the patch set supports (and thus requires) the recent <a
href="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html">1.58
release</a> of the compiler.  The build system is now able to determine
automatically whether a suitable Rust toolchain is available for building
and, if something is missing, it will tell the developer what is needed.
The cover letter notes that a couple of the unstable Rust features required
for kernel work are becoming stable in near-future compiler releases.
There is, however, still <a
href="https://github.com/Rust-for-Linux/linux/issues/2">a discouragingly
long list</a> of 
required unstable features.
<p>
The series itself starts by increasing the maximum length of symbols that
can be managed in the "kallsyms" mechanism.  It seems that the
name-mangling used by Rust can expand names considerably, to the point that
255 characters is not enough to store some names.  Developers will not
normally need to see the mangled names, but they will show up in kallsyms
and may be surprising.

Another preliminary step is to add C helper functions for a long list of
things that already look like functions in the kernel — <tt>readb()</tt> or
<tt>kmap()</tt>, for example — that are actually macros or are inlined.
Those cannot be called directly from Rust, so they need to be turned into
proper functions first.
<p>
Most of the Rust code itself currently appears in two crates.  The first,
called <a
href="/ml/linux-kernel/20220117053349.6804-7-ojeda@kernel.org/"><tt>alloc</tt></a>,
deals with memory allocation.  The Rust language 
wasn't built with the idea that code might need to continue when a memory
allocation fails; instead, the normal result is an immediate crash.  Since
crashing in kernel code is considered to be impolite, a modified allocator
that can handle failures is required.  As a Rust developer would expect, it
returns a 
<tt>Result</tt> object that contains either a pointer to the allocated
memory or an error indication, depending on what happened.  Evidently the
work to support fallible allocations is meant to go into the upstream Rust
library, so the kernel's version of this crate may eventually be able to go
away. 
<p>
The other big crate is called <a
href="/ml/linux-kernel/20220117053349.6804-10-ojeda@kernel.org/"><tt>kernel</tt></a>;
it contains the rest of the impedance-matching code that makes kernel APIs
look like proper Rust interfaces.  These provide interfaces for char devices,
the clock framework, <tt>file</tt> structures, <tt>file_operations</tt>
vectors, memory-mapped I/O functions, mutexes, spinlocks, and more.  A
surprising amount of code is dedicated to the implementation of generic
linked lists.
<p>
All told, it represents a lot of work toward making it possible to write
kernel code in Rust.  It is quite a bit of code that, at some point, is
going to need to be more widely exercised if it is to progress in useful
directions.  That, of course, would be helped by getting this support into
the mainline kernel where more developers can look at and work with it.
Torvalds indicated at the <a href="/Articles/870555/">2021 Maintainers
Summit</a> that he expected to merge this work, but
there is no indication of when that might happen.  The
timing is likely to come down to Torvalds and when he thinks that the time has
come to open the door to this new language.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Folios">Memory management/Folios</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Page_replacement_algorithms">Memory management/Page replacement algorithms</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/881675/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor882024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2022 22:49 UTC (Thu)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/882024/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, as I&#x27;ve heard Brian Cantrill say during a twitter space podcast thing, Rust and it&#x27;s compiletime ownership-checks really doesn&#x27;t work well with the concept of linked lists. After all &quot;if you have b-trees, why would you use anything else?&quot; And Rust&#x27;s ownership checking makes (generically implemented) b-trees easy where as in C or other languages they tend to end up being a horrible buggy mess.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2022 23:29 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/882032/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The stability list isn&#x27;t TOO bad once you consider it standing back a few paces.<br>
<p>
I count 17 items, 4 are cfg() parameters, to switch off features from the allocator and, in one case, the core Rust library†. That latter is worth a moment&#x27;s thought: Rust says you can format floating point numbers. Linux, of course, would very much rather you didn&#x27;t use floating point numbers at all. So, Rust-for-Linux wants to tell the core library that we aren&#x27;t going to be formatting any floating point numbers, blow up code that tries to do that, that&#x27;s not valid Linux code. However, ultimately you _could_ do this surgery by hand and in effect &quot;fork&quot; the core library, especially if you knew a real fix was coming later.<br>
<p>
2 more are -Z compiler flags. Rust&#x27;s compiler has flags marked as not being stable with a Z prefix. It&#x27;s not as though the kernel has never taken a dependency on compiler specific flags before, but clearly having a stable flag is better because it&#x27;s a social contract not to move this particular feature unexpectedly.<br>
<p>
Some of the others have community momentum behind them because they&#x27;re things most Rust users want, GATs and more const are in that category. If Rust for Linux didn&#x27;t engage with the main Rust community at all for 12 months, those things have traction and will make progress anyway. On the other hand, there are few applications outside the kernel for some of the compiler internals stabilization that Rust for Linux wants, if they never did this I for example, writing userspace code, would never ever notice.<br>
<p>
It overall certainly means I don&#x27;t expect to be running a Linux kernel with Rust in it in 2022 on my PC. But it also doesn&#x27;t feel insurmountable, I could imagine reading an LWN piece before the end of the year about the &quot;one big piece&quot; missing, I just can&#x27;t guess which piece that will be.<br>
<p>
† Rust has a core library, which is at the heart of the standard library but must exist anyway. A few things in here are literally mandatory to Rust, e.g. the Drop trait must exist, it needn&#x27;t be called Drop, but if there isn&#x27;t one that&#x27;s not Rust any more, the i32 type must exist, I don&#x27;t even think you&#x27;re allowed to call it something else, just too bad you must implement 32-bit signed integers - however a whole lot more are just useful, and not actually needed by Rust itself even if ordinary developers would be sad not to have them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2022 23:43 UTC (Thu)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/882037/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am trying to parse both your message as well as the one to which you are responding.<br>
<p>
And I&#x27;m a FORTRAN (yes, all caps, including WATFIV) / APL / C person.  With a background in more formal language systems like ML.<br>
<p>
Please define your terminology,  It appears as if yet another terminology is a major hurdle for acceptance.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 0:57 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/882040/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am happy within reason to define terms, and it&#x27;s likely others could help too, but of course I need to know what you didn&#x27;t understand.<br>
<p>
For example maybe with ML in your background Generic Associated Types are obvious, or maybe not, with GATs Rust can express the idea that some trait can have associated types which are generic. So e.g. today an Iterator has an associated type saying which Item type it iterates over, but that associated type has to be specific, like this is an Iterator over Strings, there are some traits people would like to write where you&#x27;d want to express that the associated type has some generic properties but not tie down the specifics. Evidently the Rust for Linux have some use for this feature.<br>
<p>
But equally maybe you don&#x27;t know what Rust&#x27;s traits are. Traits are similar to the &quot;interfaces&quot; feature in many object oriented languages, in that they express some capability or property common to multiple types. A trait must be explicitly implemented for any particular type, either with the definition of the type itself, or with the definition of the trait, and each such implementation stands alone. So you can be sure that if SomeTrait is implemented for ThisThing, either the author of ThisThing intended that, or the author of SomeTrait or perhaps both, as a result traits have Semantics - there is no risk of their being a mere accident of syntax as with say C++ Concepts.<br>
<p>
Maybe you know about Rust stability, or maybe not, in Rust there&#x27;s a concept of &quot;unstable&quot; features. These features exist, and they work in whatever build of Rust you have, but tomorrow there might be a new Rust version and they&#x27;re altered, or renamed, or gone. In contrast all the stable features of Rust are promised to still work into the indefinite future, none have been removed since 1.0 in 2015. You have to specifically opt in to having unstable features, and to each specific unstable feature you want. Today Rust for Linux needs several such features. Internally Rust uses some unstable features, but without opting in you can&#x27;t and probably most people shouldn&#x27;t, thus it is desirable for Rust for Linux to rely as much as possible on stable features only.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 14:21 UTC (Fri)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/882068/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, I thought GAT was a misspelling of GADT.  And traits sound more like type classes...  So essentially this is another version of ML module signatures / Haskell type classes.  I&#x27;m guessing it looks more friendly to folks coming from C/C++.<br>
<p>
Stability is pre-standardization like C/C++ attributes, or would be if there were multiple compilers out there.  (gcc was on its way at some point, right?)  Many mostly-single-vendor languages have stable v. implementation gizmos.  At least this term is fairly well shared.<br>
<p>
Rust isn&#x27;t useful in my daily life (heavily shared memory structures being changed rapidly), so I haven&#x27;t really poked at it. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor882138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 19:25 UTC (Fri)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/882138/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there an usable subset of rust without object metadata ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2022 18:37 UTC (Wed)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/882769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What do you mean with object metadata? Rust doesn&#x27;t have RTTI if that&#x27;s what you mean. Aside from DWARF information it only has vtables for trait objects that are used in the code (bare minimum, those things are basically structs with function pointers like one would use in C for this same problem). If you&#x27;re referring to the name mangling (the loooong type signatures) those have more to do with the way Rust solves diamond dependency conflicts and the liberal usage of templated types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor882175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2022 1:02 UTC (Sat)
                               by <b>plugwash</b> (subscriber, #29694)
                              [<a href="/Articles/882175/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;However, ultimately you _could_ do this surgery by hand and in effect &quot;fork&quot; the core library, especially if you knew a real fix was coming later.&quot;<br>
<p>
The rust standard library uses and will probably always use features that will not be part of stable rust. So forking the standard library doesn&#x27;t really help you with future-proofing your code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2022 21:32 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/882226/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What I&#x27;m getting at is that your fork can literally rip out the code that does floating point math. Rust&#x27;s actual standard library won&#x27;t do that, but it will probably some day take that cfg() parameter to turn off floating point math or agree some other way forward. Meanwhile Rust for Linux gets a library it can ship in Linux.<br>
<p>
It&#x27;s future proofed in that the assumption is some day Rust will have a way to disable or sidestep this, and at that point Rust for Linux can just ship the normal core library (in this respect).<br>
<p>
The fact Rust&#x27;s standard library relies on Rust&#x27;s nightly features is orthogonal, this configuration parameter isn&#x27;t relying on yet-to-stabilise feature, it&#x27;s just that the code in core wants to do floating point maths, and Linux doesn&#x27;t want that to be a possibility. In that specific case just ripping out the offending code is an effective solution, you could do it once for each Linux release and while somewhat tiresome it&#x27;s not unmanageable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor882042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 3:07 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/882042/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, I&#x27;ll bite ... How do you efficiently implement an LRU with a B-tree? Every time you access an element (let&#x27;s say an inode) in the inode cache, you remove it from wherever it currently is in the B-tree and move it to the highest unused index. That&#x27;s two O(log n) operations, versus a linked list, which is two O(1) operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 4:40 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/882046/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can use heaps, not full B-trees. That actually would be interesting to measure, it&#x27;s quite possible that not having to chase the pointers might speed them up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor882049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 9:00 UTC (Fri)
                               by <b>ldearquer</b> (guest, #137451)
                              [<a href="/Articles/882049/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the linked list, wouldn&#x27;t it require O(n) finding the node? Then place it on the highest index O(1)? So you would have O(n) (+ O(1)) vs 2·O(log n)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 12:11 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/882057/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Usually Linux uses intrusive linked lists. They allow the same node to be part of multiple data structures, so you find the node in a different data structure (for example an array or hash table) and juggle the pointers in the node to move it to the end of the LRU list.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882061"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 12:36 UTC (Fri)
                               by <b>ldearquer</b> (guest, #137451)
                              [<a href="/Articles/882061/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see, thanks for clarifying :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882061/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 12:45 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/882062/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      I'll add that Rust in general does not support intrusive data structures very well, because it is not very much friend with data that can be reached in different ways. You would have to wrap it with a reference count (<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><tt>Rc</tt></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><tt>Arc</tt></a>) and with either run-time borrow checking or a mutex (respectively <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><tt>RefCell</tt></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><tt>Mutex</tt></a>).




      
          <div class="CommentReplyButton">
            <form action="/Articles/882062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 17:41 UTC (Fri)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/882125/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is <a href="https://crates.io/crates/intrusive-collections">https://crates.io/crates/intrusive-collections</a> for example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 18:10 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/882131/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, I only said it doesn&#x27;t support them &quot;very well&quot;. If you check <a href="https://docs.rs/intrusive-collections/0.9.3/intrusive_collections/#links-and-adapters">https://docs.rs/intrusive-collections/0.9.3/intrusive_col...</a>, having the same object in many lists (which is a major advantage of intrusive collections) requires reference counting.<br>
<p>
This is enough of a disadvantage that the same crate includes an unsafe primitive to avoid this (<a href="https://docs.rs/intrusive-collections/0.9.3/intrusive_collections/#safety">https://docs.rs/intrusive-collections/0.9.3/intrusive_col...</a>).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 20:45 UTC (Fri)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/882144/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not sure that&#x27;s really much less ergonomic than C? You still have the same issue there. Once you put things into multiple collections you need some way of knowing whether you should free items when removing them. That&#x27;s true regardless of whether the compiler notices it.<br>
<p>
If you don&#x27;t know whether it&#x27;s the last reference, you need some kind of reference count and if you do you&#x27;ll need to prove it, either to yourself or preferably some program. It&#x27;s not much different.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2022 4:15 UTC (Tue)
                               by <b>artem</b> (subscriber, #51262)
                              [<a href="/Articles/882496/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Once you put things into multiple collections you need some way of knowing whether you should free items when removing them. </font><br>
<p>
<font class="QuotedText">&gt; If you don&#x27;t know whether it&#x27;s the last reference, you need some kind of reference count </font><br>
<p>
With multiple intrusive lists, you can declare some of them owning and some of them non-owning.<br>
<p>
When a thing is not on any of the owning lists, it&#x27;s removed from the rest and dropped.<br>
<p>
No reference counting necessary.<br>
<p>
How would one do that in Rust?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2022 9:42 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/882506/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, I hadn&#x27;t considered that you could mutate a lists through another one...<br>
<p>
I don&#x27;t immediately see any reason why it shouldn&#x27;t be possible. Rust&#x27;s weak references have similar semantics albeit still require reference counting because it can&#x27;t just go and remove the remaining references like with a list. I don&#x27;t think it&#x27;s natively supported by the intrusive-collections crate mentioned above though. But you should be able to express it with a safe interface.<br>
<p>
Evidently there doesn&#x27;t seem to be a lot of demand for something like that from existing rust users though. intrusive-collections is already not exactly widely used. I&#x27;ve personally never found a reason to use it despite looking for excuses, there&#x27;s just too many specialized high quality data structure libraries to justify it. Maybe some day.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor882059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 12:30 UTC (Fri)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/882059/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><i>The Rust language wasn't built with the idea that code might need to continue when a memory allocation fails; instead, the normal result is an immediate crash. </i></blockquote>
<p>
A surprising feature in a language that has been touted as a C replacement for low-level programming. Of course, when you are out of memory, there typically are no good options, but a language for low-level programming must allow the programmer to decide what happens next.



      
          <div class="CommentReplyButton">
            <form action="/Articles/882059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 14:22 UTC (Fri)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/882069/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Modula-3 tried really, really hard to come up with generalizable semantics to apply when allocation fails.  I don&#x27;t believe they ever did.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor882126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 17:43 UTC (Fri)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/882126/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article phrased this poorly.  The Rust *language* is independent of the default standard library.  Plenty of use cases (including Rust-for-Linux) use &quot;no-std&quot; which fully supports writing code with fallible allocations.  Plenty more at e.g. <a href="https://doc.rust-lang.org/stable/embedded-book/intro/no-std.html">https://doc.rust-lang.org/stable/embedded-book/intro/no-s...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor882123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 18:03 UTC (Fri)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/882123/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not really accurate that the language wasn&#x27;t built with the Idea in mind. Just like C, Rust does not depend on any kind of allocator, fallible or not. All of the difficulties here are just from the desire to reuse a userspace library (alloc) in the kernel. They certainly could have just written their own allocator api, list types, etc. just like the kernel does, but since the standard library developers were willing to support their use case it was just more convenient to share.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor882237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2022 3:01 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/882237/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, let&#x27;s compare to the (userspace) alternatives:<br>
<p>
1. In a managed language, like Java, you get some sort of &quot;out of memory&quot; exception. Handling these exceptions safely is complicated and error-prone, and the official documentation will often encourage the programmer to just &quot;let it crash&quot; instead of trying to deal with the problem gracefully. In most cases, these languages will try to reclaim previously allocated memory with the garbage collector before throwing these exceptions.<br>
2. In C++, std::bad_alloc is thrown, which is like the managed case except that stack unwinding will cause destructors to run (in the managed case, finalizers *might* run, but there is no guarantee of when they get called). If any of those destructors tries to allocate any memory, for any reason, it might cause a second std::bad_alloc to get thrown, and if a destructor throws an exception while another exception is already pending, the runtime gives up and calls std::terminate. Therefore, if you want to handle fallible allocations, every destructor in your entire program must be in on the joke.<br>
3. In C, malloc returns a null pointer. If you forget to check for it, undefined behavior occurs (but in practice, you probably just segfault most of the time). If you remembered to check for it, you can handle it in whatever way you like, but in most cases you either return an error to your caller, or call longjmp(3) on a pre-allocated jmp_buf to go back to the main event loop or some other top-level scope that can reasonably figure out what to do next.<br>
4. Regardless of language, it&#x27;s possible for the OS to lie to you and give you memory which doesn&#x27;t actually exist, then kill you when you try to use it. Linux actually does this,* and I believe it&#x27;s common in other modern OSes as well. Where this functionality is enabled, any program can crash upon the system running out of memory, and there&#x27;s nothing the programmer can reasonably do about it.<br>
<p>
Sure, discount (1) all you like, but the practical reality is that running out of memory is really hard to handle safely when you&#x27;re running in userspace, regardless of whether you&#x27;re a high-level language or a low-level language.<br>
<p>
* The OOM killer is more complicated than what I have described here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor882240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2022 10:07 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/882240/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>As a side note, the Rust team are working on providing a decent API for fallible allocations. The raw <a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html"><tt>Allocator</tt> trait</a> that's going to be the interface between allocators and the rest of the language only has fallible functions that may allocate. The only function in that API that must succeed is <tt>free</tt>.
<p>Then, there's effort ongoing to <a href="https://rust-lang.github.io/rfcs/2116-alloc-me-maybe.html">support fallible allocation in container APIs</a>, with its own <a href="https://github.com/rust-lang/rust/issues/48043">tracking issue</a>.
<p>There's a lot of effort going in to making this a supportable API for the long term; the key "odd" decision Rust seems to be making here is that instead of requiring every operation that could allocate to cope with the risk of allocation failure, there will be a mechanism (<tt>try_reserve</tt> on collections, for example) that guarantees that you can do a certain number of operations without allocating, and that mechanism can fail. It's then up to the users of the APIs to ensure that memory is either reserved up-front, or to take the risk of surprise allocation failure.
<p>And this matches the underlying observation you've made; it's incredibly hard to handle allocation failure if it can happen at any time, and thus the entire application needs to either be bug-free in handling the rare error case (allocation failure), which in C++ means that everything has to meet the strong exception safety guarantee, or you need to confine allocation failures to a few places where you have hardened your code.


      
          <div class="CommentReplyButton">
            <form action="/Articles/882240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor883908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2022 3:02 UTC (Sun)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/883908/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 2. In C++, std::bad_alloc is thrown, which is like the managed case except that stack unwinding will cause destructors to run (in the managed case, finalizers *might* run, but there is no guarantee of when they get called). If any of those destructors tries to allocate any memory, for any reason, it might cause a second std::bad_alloc to get thrown, and if a destructor throws an exception while another exception is already pending, the runtime gives up and calls std::terminate. Therefore, if you want to handle fallible allocations, every destructor in your entire program must be in on the joke.</font><br>
<p>
Well, most destructors don&#x27;t require allocation but do free up some memory. This means that when a bad_alloc is thrown, there&#x27;s a pretty good chance that by the time you reach a destructor that allocates, some memory has already been freed by a destructor that ran before, and so your allocation may very well succeed. There are cases where it&#x27;s better to try to recover from an allocation failure and sometimes fail than to not try at all.<br>
<p>
Also, you might be able to allocate whatever memory you need to run the destructor in the constructor, thus avoiding the need to allocate in the destructor. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/883908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886709"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The kernel radar: folios, multi-generational LRU, and Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 18:19 UTC (Thu)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/886709/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are a variety of approaches to out-of-memory issues in different languages, and there has been quite an interesting on-and-off debate in computing about fault-intolerant languages (which can be useful because a program isn&#x27;t trying to limp on with an uncertain state).<br>
<p>
In a microkernel, where you might very well want a module to crash cleanly and get restarted, a fault-intolerant language would seem to make a lot of sense. Rust might well be ideal for writing modules in the L4 world. I&#x27;m not sure how it makes sense in Linux, although if the primary kernel developers say it does then there&#x27;s an excellent chance it does even if I can&#x27;t see it.<br>
<p>
There are other languages that might have value (or even more value) in the kernel, but they&#x27;re either hopelessly obscure or too difficult to find a 64-bit compiler for, and I seriously doubt there would be interest in yet another language until Rust succeeds/fails, the reasons are known and there are people who might credibly actually use such a provision.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886709/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
