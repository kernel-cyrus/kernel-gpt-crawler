        <!DOCTYPE html>
        <html lang="en">
        <head><title>vDSO, 32-bit time, and seccomp [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/795128/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/795102/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/795128/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>vDSO, 32-bit time, and seccomp</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 2, 2019</br>
           </div>
The <a
href="http://man7.org/linux/man-pages/man2/seccomp.2.html"><tt>seccomp()</tt></a>
mechanism is notoriously difficult to use.  It also turns out to be easy to
break unintentionally, as the development community discovered when a
timekeeping change meant to address the <a
href="/Articles/776435/">year-2038 problem</a> created a regression for
<tt>seccomp()</tt> users in the 5.3 kernel.  Work is underway to mitigate
the problem for now, but <tt>seccomp()</tt> users on 32-bit systems are
likely to have to change their configurations at some point.
<p>
The <a href="/Articles/615809/">virtual dynamic shared object</a> (vDSO)
mechanism is an optimization provided by the kernel to reduce the cost of
certain frequently used system calls.  The vDSO is a small region of
kernel-provided memory that is normally mapped into the address space of 
every user-space process; it contains implementations of system calls that
can, in some circumstances at least, do their work in a user-space
context.  That allows the caller to avoid making a real system call and,
thus, to avoid the cost of a context switch into kernel mode.  System calls
related to timekeeping, such as <a
href="http://man7.org/linux/man-pages/man2/gettimeofday.2.html"><tt>gettimeofday()</tt></a>
are implemented in the vDSO, since they can often run quickly in user space
and they tend to be called frequently.
<p>
The vDSO has generally been implemented in an architecture-specific way, even
though the functions it performs are mostly the same across
architectures.  In the 5.2 development cycle, Vincenzo Frascino <a
href="https://git.kernel.org/linus/00b26474c2f1">added a generic vDSO implementation</a> that factored
out much of the architecture-specific code into a single implementation
that could be used on all architectures.  During the 5.3 merge window,
the x86 architecture <a
href="https://git.kernel.org/linus/7ac870747988">switched over</a> to the
generic version, and all was well — or so it seemed.
<p>
<h4><tt>seccomp()</tt> sadness</h4>
<p>
In mid-July, Sean Christopherson (among others) <a
href="/ml/linux-kernel/20190719170343.GA13680@linux.intel.com/">reported</a>
that the generic vDSO change broke some <tt>seccomp()</tt> users on 32-bit
x86 systems.  <tt>seccomp()</tt>, remember, allows user space to provide a
BPF program (still "classic BPF", not eBPF as is used almost everywhere
else in a contemporary Linux system) to control which system calls may be
made.  It is used to reduce the attack surface of code that might be
exposed to attackers in one way or another; using it correctly is hard, but
the number of users has been on the rise.
<p>
While the vDSO can usually implement timekeeping system calls in user
space, that is not always possible.  If the calling program wants an
esoteric clock that has not been implemented, or if the timekeeping
hardware available on the system is not amenable to vDSO access, then the
vDSO must fall back to calling into the kernel.  Prior to 5.3, the
architecture-specific vDSO used the native <a
href="http://man7.org/linux/man-pages/man3/clock_gettime.3.html"><tt>clock_gettime()</tt></a>
call on
the system it was running on; that meant calling the 32-bit
<tt>clock_gettime()</tt> on 32-bit kernels.
<p>
The 32-bit time format is, of course, going to run out of range in January
2038.  Quite a bit of work has gone into preparing systems for this
particular apocalypse, though much work still remains.  Given this problem,
adding new users of 32-bit time interfaces is a way to become rather
unpopular in kernel-development circles, so the generic vDSO
implementation naturally used <tt>clock_gettime64()</tt> as the fallback
timekeeping system call on all architectures. That is not the sort of thing
that one would ordinarily even have to think about much; nobody wants to
create a generic vDSO implementation that contains yet another year-2038
problem in need of fixing.
<p>
But there is a problem here.  A surprising number of programs want to know
what time it is at some point or another.  Anybody putting together a
<tt>seccomp()</tt> policy for a given program will almost certainly allow
system calls like <tt>gettimeofday()</tt>; otherwise the target program
will probably break.  A program that fails to run is generally
secure, but users, being generally unreasonable, tend to get disgruntled
anyway.
<p>
Any rational <tt>seccomp()</tt> policy will, thus, allow for the fallback
system call when the vDSO is unable to provide the time directly.  But it
turns out that, while these policies allowed <tt>clock_gettime()</tt> on
32-bit systems, they lacked the foresight to let <tt>clock_gettime64()</tt>
through as well.  The end result is that, when a program protected by one
of these <tt>seccomp()</tt> policies runs on a 5.3 kernel, it is quickly
and rudely killed when it tries to make a disallowed system call.
<p>
Kernel developers might protest that this change is required to avoid
year-2038 problems.  They might also be naturally inclined to disregard
lame excuses about how <tt>clock_gettime64()</tt> was never needed before,
or about how that system call didn't even exist until the 5.1 release.
But, in the end, this is a regression, and the kernel community's policy on
such things is fairly unambiguous.  Somehow, programs running under
existing <tt>seccomp()</tt> policies will need to continue to work when the
final 5.3 kernel comes out.
<p>
<h4>Fixing the problem</h4>
<p>
Various ideas were raised for how that could be done, starting with a
not-entirely-serious suggestion that the generic vDSO change could simply
be reverted.  Perhaps <tt>seccomp()</tt> rules could be bypassed for system
calls that originate in the vDSO; this idea didn't get far given that,
among other things, faking a vDSO return address is not a difficult thing
to do.  Bypassing <tt>seccomp()</tt> for <tt>clock_gettime64()</tt>
specifically is an option, but that would defeat administrators who want to
block all access to timekeeping information.

The concept of "system-call aliases" was circulated, <a
href="/ml/linux-kernel/19EF7AC8-609A-4E86-B45E-98DFE965DAAB@amacapital.net/">initially</a>
by Andy Lutomirski; it would create a short list of "equivalent" system
calls that take the same arguments and do the same thing.  If one call in
the list was rejected by a <tt>seccomp()</tt> 
filter, the kernel would retry the policy with any aliases that might exist.
<p>
The alias idea got further than many, but it has problems of its own.
For example, authors of <tt>seccomp()</tt> policies might genuinely want to
discriminate between "equivalent" system calls.  It seems like the sort of
mechanism that could generate surprising results in general.  Aliases might
still be the long-term solution for this problem but, as Lutomirski <a
href="/ml/linux-kernel/CALCETrUe50sbMx+Pg+fQdVFVeZ_zTffNWGJUmYy53fcHNrOhrQ@mail.gmail.com/">pointed
out</a>, "<q>it's getting quite late to start inventing new seccomp
features to fix this</q>".  Something simpler is needed, at least for
the 5.3 release.
<p>
That something is likely to be based on <a
href="/ml/linux-kernel/20190728131251.622415456@linutronix.de/">this patch
series</a> from Thomas Gleixner, which simply causes the vDSO to fall back
to the 32-bit <tt>clock_gettime()</tt> system call on 32-bit systems.  It
is a solution that is pleasing to nobody, but it solves the regression
issue for now.
<p>
Some other solution will be required eventually; it is not possible to
support 32-bit time indefinitely.  One possibility is that the authors of
<tt>seccomp()</tt> policies change their code to allow
<tt>clock_gettime64()</tt> as well.  But, even if that could be done and
widely deployed, there is no strong incentive for developers to do this
work, since their existing policies will continue to function as intended.
Some sort of multi-year deprecation process could be considered as a way to
force policies to be fixed.  But the eventual solution may just have to
live in <tt>seccomp()</tt> instead, 
perhaps in the form of an alias list or other special exception.  A
long-term solution that is pleasing to everybody is difficult to envision.
<p>
This situation highlights a problem with <tt>seccomp()</tt> in general: it
is difficult to write robust policies at that level of detail, and the
resulting policies 
tend to be brittle 
in the best of times.  Even if the kernel community avoids incompatible changes, a
change in a library somewhere can invoke a new system call that a given
<tt>seccomp()</tt> policy may frown upon.  While the <a
href="https://man.openbsd.org/pledge">OpenBSD <tt>pledge()</tt></a>
mechanism may not offer the degree of control provided by
<tt>seccomp()</tt>,  its use of relatively broad categories of
functionality makes it easier to avoid problems like this.  But Linux has
<tt>seccomp()</tt>, with all its power and complexity.  It seems highly
likely that developers will unwittingly run into this sort of regression
again in the future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-seccomp">Security/seccomp</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#vDSO">vDSO</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Seccomp">Linux kernel/Seccomp</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/795128/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor795238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 18:15 UTC (Fri)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/795238/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like seccomp rules should be a runtime config instead of a compile time thing (aka program reads in the seccomp rules from a file and then loads them, instead of being program data).<br>
<p>
Or we just ditch all precompiled 32-bit programs with builtin seccomp in 2038<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 21:12 UTC (Fri)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/795251/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Precompiled programs are not even the main problem, as long as the C library doesn't start using the new system calls to implement the compatibility symbols to implement the old time32 based interfaces.<br>
<p>
The problem with seccomp is much bigger when an application is recompiled with the time64 C library interfaces that have to use the 64-bit system calls. However, when you do that, you also have to deal with other problems, this is just one of many things we need to address to have a 32-bit distro that can survive y2038, and one of many things that can go with seccomp as we add new system calls that act as replacements for old ones.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 22:41 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/795287/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or we could ditch seccomp and go with something sane that doesn't require constant invasive changes to the kernel, libc and applications...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795297"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 20:40 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/795297/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which is what?<br>
<p>
It's not pledge(), which is "we have studied all the applications anyone has ever written or ever will write and come up with a list of set of policies that work for them".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795297/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 20:45 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/795299/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
pledge() is definitely not a universal cure, but it's extremely practical and works well for a surprising variety of servers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 22:10 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/795308/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, it's not hard to turn seccomp into a pledge-wannabe: make it accept "target kernel version" in addition to BPF.<br>
<p>
Then kernel would know which syscalls are "alien" to this particular version and would use it's alias database.<br>
<p>
Heck, this way you could introduce some "fake" versions which only know about very few syscalls (and thus only allow rough yet simple setup).<br>
<p>
This is similar to how Android (well, bionic) handles such things - and works well enough in practice (even if it's easy to construct artificial example which would fall apart in such scheme)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2019 5:13 UTC (Sat)
                               by <b>gnoack</b> (subscriber, #131611)
                              [<a href="/Articles/796509/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This would be a good start, but the problems with not understanding user space behaviour are still big compared to kernel compatibility issues.<br>
<p>
For example, different libcs use different syscalls, which is the first thing to be compatible with.<br>
<p>
Shared library loading can lead to very unexpected behaviour as well. LD_PRELOAD is one example. Another one is that when resolving hostnames, libnss in glibc loads shared modules for resolution behavior, and it's very difficult to predict what these will do. (OpenBSDs pledge has a special case for DNS as well, I believe so that they can distinguish between DNS and other UDP.)<br>
<p>
In the end, with seccomp you need a very good control of how a program is built, which libc it uses, and in the case of glibc+DNS even how the system is configured. That seems unrealistic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor795399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2019 7:42 UTC (Tue)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/795399/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps system-call sites could be annotated and processed by the compiler (or a plug in) to add an ELF section describing the source and return address of each system call.  This section could then be read or mapped into protected memory when an executable or shared object is loaded and used to provide policy that automatically checks the program is executing as intended when it was compiled and that it hasn't obviously been compromised. <br>
<p>
Relocation processing and such may make this fiddly to implement, but given most things would by dynamically linked against glibc where the system calls commonly come from, it might be possible to reduce overhead to just when loading that shared library with minimal loss for most other programs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795557"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2019 23:37 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/795557/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sort of thing could be good but it's hard because it's very important you check the system-call number, and obtaining that statically is impossible in general (e.g. for the syscall performed by the syscall() function).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795557/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795581"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2019 11:31 UTC (Wed)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/795581/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
syscall() may well be a potential problem, though I imagine 99% of uses would pass the first argument from a SYS_xxx constant - it might be possible to use macro trickery with __builtin_constant_p() to still make the correct specific annotation data.  <br>
<p>
The other 1% of uses may be either bugs, bad code, or exploitable gadgets?  It would be interesting research to find out.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795581/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor795825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2019 15:03 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/795825/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This trivially requires solving the halting problem in the limit. The problem isn't really which syscall is invoked: other than syscall() that is easy to determine. The problem is that figuring out the source and return addresses, which might well be in intricately-constructed data structures, is *horrifically* hard. You can't do it by brute force (it's not *quite* as bad as enumerating all busy beavers but it's clearly ridiculous) which means you have to do it by formal analysis of the program. And that... well, good luck doing it without significant programmer help. Not a chance at all of your being able to do it in randomly-chosen C programs.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2019 15:06 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/795826/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh wait you're not talking about checking the arguments, are you? I'm talking nonsense. If you're just checking that the syscalls invoked are syscalls present in the program, and that they're being called from (and for most syscalls returning to) the right places... that sounds practical, at least for PT_GNU_STACK binaries that do not intentionally execute code that the compiler didn't generate. :) But it won't help stop attackers who are using ROP gadgets: the whole point of those is that they carry out arbitrary computation *using* only code actually present in the program, via sufficiently demented crafted stacks. (You'd have to check that the stacks return to loci where there are actually function calls, and that's going to be much more expensive.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2019 6:47 UTC (Sat)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/795860/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But it won't help stop attackers who are using ROP gadgets</font><br>
<p>
That's why I suggest verifying the return addresses as well as call sites - to make chaining ROP gadgets harder.  Combined with something like Pointer Authentication Codes in user space, this could button up call flows nicely to ensure code executes as designed when compiled.<br>
<p>
That said, I'm not sure if it is possible to 'fake' the return address of a supervisor call or exception on any architectures.<br>
<p>
<font class="QuotedText">&gt; (You'd have to check that the stacks return to loci where there are actually function calls, and that's going to be much more expensive.)</font><br>
<p>
All security has an overhead.  The question is whether such a system could be made efficient enough to be worth the benefit.  The idea here is be to leverage the compiler to produce the needed records and fix them up when loading/dynamic linking so that execution overhead could be as simple as some table lookups in the kernel around system calls.  It will never be for free, and even hardware assisted things like PAC add instructions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor795759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2019 17:25 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/795759/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If not pledge(), maybe we could have a LSM that reads Content-Security-Policy headers. I hear they're popular with the kids and as easy to understand as SELinux rules.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor795240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 18:21 UTC (Fri)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/795240/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fix doesn’t quite fall back to the 32-bit syscall on 32-bit systems. It falls back to the 32-bit syscall for 32-bit clock_gettime() calls. This seems fine in the long run. A Y2038-ready 32-bit program will use the vDSO’s clock_gettime64, which will fall back to the new syscall.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 20:02 UTC (Fri)
                               by <b>chris_se</b> (subscriber, #99706)
                              [<a href="/Articles/795245/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't this a much more generic problem with seccomp? Let's say glibc<br>
decides to switch its stat() wrapper to use the new statx() system call<br>
(for similar reasons) - then any seccomp policy (which is defined by<br>
programs outside of glibc) allowing stat() but not statx() would<br>
suddenly start to kill programs left and right. Sure, in this case it<br>
was the vDSO of the kernel instead of glibc that caused the problem,<br>
but in both cases the upgrade of a very basic system component broke<br>
the application.<br>
<p>
And from a historical perspective it's always been the case that any<br>
wrapper around a system call may internally do other things as well,<br>
as long as it follows the documented contract. seccomp() breaks this<br>
understanding that has long existed to some extent.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 20:27 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/795248/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, it is. glibc's change to not cache getpid() results (so that it worked better with containers, etc) in the 2.25 timeframe broke BIND's named because it was relying on the cache and not allowing getpid() through its seccomp rules. In the end seccomp support was just removed from BIND because it was reducing reliability more than it was gaining in security.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 23:19 UTC (Fri)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/795256/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right. I'm really not a fan of using seccomp and SELinux to ban random system calls to "reduce attack surface". This practice can cause hard-to-debug problems when programs that legitimately use supported system calls in rare cases see unexpected errors. Security should, IMHO, work on the basis of protecting data, not code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2019 23:33 UTC (Fri)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/795257/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Android people had the gall to complain to me because the shell I maintain uses stat() for the test builtin (things like file existence) and they disallow stat in their SELinux policies…<br>
<p>
I agree, this is ridiculous.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 0:57 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/795260/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
... how else are you supposed to implement it? Use fstatat in particular, or something? And then what happens if someone else has a different policy?<br>
<p>
This is ridiculous. It drives a truck through ABI stability guarantees, even guarantees as carefully maintained as (say) glibc's.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 1:06 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/795261/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The practice of blacklisting arbitrary system calls also creates a perverse incentive: if I, a program author, want to maintain flexibility, I should have my program call as many different system calls as I can lest I lose access to the ones I don't call.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 4:38 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/795264/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think there is a balance here.<br>
<p>
A hypothetical crypto library should not need to call into the sockets API, create processes, manipulate shared memory, access the filesystem, or do a wide variety of other I/O-ish things. A malicious actor trying to exploit a buffer overrun would very much like to do those things, for all manner of reasons, but particularly for key exfiltration. We can reasonably foresee a malicious actor being able to cause such a buffer overrun in a crypto library, because it's actually happened numerous times. Not all of those bugs would have been stopped by seccomp (see for example Heartbleed), but no security measure claims to solve all problems.<br>
<p>
At the other extreme, of course a shell is going to call all manner of I/O syscalls (except *maybe* for the sockets API). It really doesn't make sense to try and limit what a shell can do, because the whole point of a shell is to facilitate arbitrary code execution (by the user who is typing commands). Yes, restricted shells exist, but those tend to be sandboxed along different dimensions than "which syscalls are fair game."<br>
<p>
Most software is going to fall somewhere between these extremes. So where does that leave us? If I were an upstream, the lesson I would take from this is to just write sensible code, and let downstreams figure out their own security policies. If they file a bug telling me that some of my code is unreasonable, and therefore tripping seccomp, I might fix it. If they file a bug telling me that my code does something that is inconvenient for them, but not unreasonable from where I sit, I would WONTFIX it and let the pieces fall where they may.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 6:17 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/795267/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A hypothetical crypto library should not need to </font><br>
<font class="QuotedText">&gt; call into the sockets API</font><br>
Except to set up the kernel-level TLS acceleration. Or it might need to make outgoing connections to validate CRLs, for example.<br>
<p>
<font class="QuotedText">&gt; create processes</font><br>
OK.<br>
<p>
<font class="QuotedText">&gt; manipulate shared memory</font><br>
Except if it wants to use uring, maybe?<br>
<p>
<font class="QuotedText">&gt; access the filesystem</font><br>
<font class="QuotedText">&gt; or do a wide variety of other I/O-ish things.</font><br>
Read CA bundles.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 7:01 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/795268/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Except to set up the kernel-level TLS acceleration.</font><br>
<p>
Sure, if that's the specific thing that you are doing. But then the application logic knows you are doing that, and can avoid sandboxing it.<br>
<p>
<font class="QuotedText">&gt; Or it might need to make outgoing connections to validate CRLs, for example.</font><br>
<p>
Gods, no. If the application wants to use a CRL, it downloads it separately, and before applying the sandbox. The crypto library could, of course, provide a helper function for that, but it should not be part of the "main" codepath unless the caller has somehow asked for it. You don't make outgoing connections behind the application code's back.<br>
<p>
<font class="QuotedText">&gt; Read CA bundles.</font><br>
<p>
read(2) poses substantially less of a security risk than write(2) and open(2), so I don't actually have a problem with this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 9:24 UTC (Sat)
                               by <b>storner</b> (subscriber, #119)
                              [<a href="/Articles/795272/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; Or it might need to make outgoing connections to validate CRLs, for example.</font><br>
<p>
<font class="QuotedText">&gt;Gods, no. If the application wants to use a CRL, it downloads it separately, and before applying the sandbox. The crypto library could, of course, provide a helper &gt;function for that, but it should not be part of the "main" codepath unless the caller has somehow asked for it. You don't make outgoing connections behind the &gt;application code's back.</font><br>
<p>
Gods, no. CRL's from a public CA are huge and the cost (time, bandwidth, storage) of downloading one would be prohibitive in most cases. You normally use OCSP which requires an HTTP(S) network connection. So socket/network access is needed.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 10:56 UTC (Sat)
                               by <b>chris_se</b> (subscriber, #99706)
                              [<a href="/Articles/795276/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Gods, no. CRL's from a public CA are huge and the cost (time, bandwidth, storage) of downloading one would be prohibitive in most cases. You normally use OCSP which requires an HTTP(S) network connection. So socket/network access is needed.</font><br>
<p>
Although in an ideal word everybody would use OCSP Stapling - that way it wouldn't require the client to do OCSP requests to arbitrary destinations, and only each server would need to perform such a request every two days or so, and that only to its own CA.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 18:20 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/795381/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A MitM can cause OCSP requests to fail, at which point most stacks choose fail-open. So OSCP provides no security benefit and should be removed to reduce attack surface and network chatter. Or else you should make it fail-closed, but nobody actually does that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor795295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 20:27 UTC (Sun)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/795295/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Filtering on system calls is somewhat ridiculous anyway.  The proper way to do this is with capabilities.  You are given a ticket which allows certain operations (eg. access a subdirectory in the filesystem), and you can create new tickets which are subsets of those operations that you hand down to the libraries and components you use.  Capabilities are supported by the operating system so diagnosing problems and working out what capabilities are needed to carry out a whole task can be done at the level of the whole system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 21:00 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/795298/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm all for capabilities but the goal of seccomp is to reduce the attack surface of kernel code that the confined process can trigger execution of, and capabilities aren't always an appropriate way to express that.<br>
<p>
For example almost every application needs read(). Most don't need the features provided by preadv2(), and those features trigger execution of a bunch of relatively new and untested kernel code. How would you use capabilities to control the ability of a confined process to access those features?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 21:11 UTC (Sun)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/795302/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
preadv2 and other new system calls provide new capabilities. These new capabilities let programs do a better job of serving the user. How are these programs supposed to deliver this improved utility to users if security policy blocks the new system calls?<br>
<p>
It's circular: we have to block them because they're rare, and they're rare because we block them. We can't make progress that way.<br>
<p>
I'm all for addressing specific known vulnerabilities, but this practice is reflexively blocking anything new has got to stop.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 21:36 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/795305/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In practice, security needs vary, seccomp policies vary, and lots of software runs without a seccomp policy at all, so there is no circular deadlock.<br>
<p>
Also, many seccomp policies are tailed to the needs of the software they confine, rather than the other way around. Don't tell Chrome or Firefox that they should stop using seccomp policies to sandbox their browser processes because the kernel community needs additional testing of kernel code ... which their browser processes only exercise if they've been compromised.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 0:04 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/795312/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Chrome actually works just fine with pledge() - <a href="http://undeadly.org/cgi?action=article;sid=20160107075227">http://undeadly.org/cgi?action=article;sid=20160107075227</a><br>
<p>
Raw syscall filtering really is looking like a bad solution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 0:49 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/795313/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, after modifying pledge() to make it work just fine with Chrome. <a href="https://marc.info/?l=openbsd-cvs&amp;m=145207222327683&amp;w=2">https://marc.info/?l=openbsd-cvs&amp;m=145207222327683&amp;...</a><br>
<p>
But that has nothing to do with this sub-thread, which is about whether capabilities obviate the need for seccomp.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 3:51 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/795318/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I honestly don't mind this approach. Fully generalized systems are not always the best solution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor795328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 14:06 UTC (Mon)
                               by <b>MarcB</b> (subscriber, #101804)
                              [<a href="/Articles/795328/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This raises the question what seccomp is supposed to be.<br>
<p>
Should it be some "personal firewall" to protect potentially vulnerable kernel code or should it restrict the functionality available to processes based on their needs (i.e. classical sandboxing)?<br>
<p>
Personally, I think only the second concept is feasible. In that approach, there would be no difference whatsover between read() and preadv2() - or  clock_gettime64() and  clock_gettime(). Those syscalls are equivalent in the sense that they allow a process to do exactly the same things.<br>
<p>
If seccomp is used to filter arbitrary syscalls, this will lead to ossifications (can't reliably use new syscalls) and maintenance or portability nightmares (just look at the circumstances needed to trigger this problem here). And frankly, if the Linux kernel really needed such a protective filter, it would be high time to switch operating systems (or to significantly change Linux' development process wrt syscalls).<br>
<p>
Applications and administrators should define security in term of the security model provided by the operating system and not start second-guessing it. Doing so would cause the same madness operating system developers are currently experiencing with those hardware vulnerabilities, but on a much larger scale.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 21:48 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/795391/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Google developed seccomp-bpf for the Chrome sandbox and "protect potentially vulnerable kernel code" was explicitly a goal. I don't know why you think that isn't feasible; it is feasible, and it's working.<br>
<p>
<font class="QuotedText">&gt; And frankly, if the Linux kernel really needed such a protective filter, </font><br>
<p>
It does. See <a href="https://events.linuxfoundation.org/wp-content/uploads/2017/11/Syzbot-and-the-Tale-of-Thousand-Kernel-Bugs-Dmitry-Vyukov-Google.pdf">https://events.linuxfoundation.org/wp-content/uploads/201...</a><br>
The situation has not improved.<br>
<p>
<font class="QuotedText">&gt; it would be high time to switch operating systems (or to significantly change Linux' development process wrt syscalls).</font><br>
<p>
Maybe so but for now seccomp-bpf is needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor795284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 18:22 UTC (Sat)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/795284/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A hypothetical crypto library should not need to call into the sockets API, create processes, manipulate shared memory, access the filesystem, or do a wide variety of other I/O-ish things.</font><br>
<p>
A crypto lib, in a program that can not do any of those things is kind of useless.  (or alternately, last I check seccomp applies to processes not shared libs)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 19:51 UTC (Sat)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/795285/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True! And isn’t t̲h̲a̲t̲ part of the problem why the current solutions are useless (or rather, do more harm and create unreliability than they do good and create security)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 13:09 UTC (Mon)
                               by <b>leromarinvit</b> (subscriber, #56850)
                              [<a href="/Articles/795325/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought the intended way to use seccomp was to compartmentalize your program into different processes, each allowed to use only the syscalls they need, communicating via some IPC mechanism? Of course that's more work than using plain function calls into a library, but is there anything stopping a library from implementing something like that internally, with the user-visible API just passing the data to the actual worker process?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 13:27 UTC (Mon)
                               by <b>dullfire</b> (guest, #111432)
                              [<a href="/Articles/795326/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
you aren't wrong, but the example in question explicitly precludes IPC<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795356"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 15:59 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/795356/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The example doesn't preclude IPC. The crypto library doesn't need to be able to open files, set up new sockets, or create/map/unmap shared memory areas, but it can use files, sockets, or shared memory areas which are provided to it. For file- or socket-based IPC it just needs the read() and write() system calls inside the sandbox.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795356/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor795262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 1:15 UTC (Sat)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/795262/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
access(2), which is broken in many different ways on too many operating systems to list here.<br>
<p>
In contrast to the freedesktop.org/systemd/GNOME people and, apparently, Google, I care for more than just GNU/Linux/{amd,arm}64.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 15:01 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/795279/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm just amazed that anyone could expect you to implement an entire shell without using stat-family syscalls but only using access(). WTF no that's just ridiculous. (Or that anyone would think that sandboxing a *shell* with seccomp, the very definition of something whose whole purpose is to execute arbitrary code, made any sense at all.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2019 16:17 UTC (Sat)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/795282/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not seccomp, selinux. Though the overall point remains.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor795359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 16:32 UTC (Mon)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/795359/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a bit of a tangent, but: if you use stat to implement test, doesn't that require reimplementing (a subset of) the permission model yourself, and potentially missing system-specific mechanisms such as "there's an additional ACL here granting permission" or "the underlying filesystem is read-only / noexec"?<br>
<p>
Also, I'd be curious what problems you've observed with the access system call on various operating systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">a tangent (was vDSO, 32-bit time, and seccomp)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2019 22:13 UTC (Thu)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/797001/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
<p>
the shell uses stat and looks at the various bits (mtime, mode, …) for tests.<br>
<p>
The condition “read-only filesystem” is not in the scope of the tests (it’s more of a run-time vs. how-the-fs-tree-is-set-up question) and EROFS will be thrown on actual accesses by the kernel.<br>
<p>
Most tests are very low-level:<br>
<p>
            -g file            file's mode has the setgid bit set.<br>
<p>
Others aren’t, but…<br>
<p>
            -w file            file exists and is writable.<br>
<p>
… considering this is a Unix shell, the Unix file attributes are checked, no extended ones, and I know of no portable way to check for them. (That being said, I do not deal with extended attributes at all, and mksh is normally developed on MirBSD which doesn’t have them anyway, but I understand at least OS/2 and Cygwin/Interix/UWIN/PW32 out of the supported platforms do, if HPFS/NTFS is the underlying filesystem; I’m not familiar enough with these.)<br>
<p>
I’d have to look why access(2) is not normally used. If it’s only false negatives, we could check _both_ access and stat, and if one fails return a failure. This would be dead slow on most operating systems, so I’d only enable it for those that really need it.<br>
<p>
I do know that access(2) says the file is executable if the caller is root and the file isn’t. There’s already an access wrapper in the code, and another one for OS/2 (that deals with adding .exe automatically if needed)…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor795310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 22:37 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/795310/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the architecture-specific vDSO used the native clock_gettime() call on the system it was running on; that meant calling the 32-bit clock_gettime() on 32-bit kernels.</font><br>
<p>
<font class="QuotedText">&gt; the generic vDSO implementation naturally used clock_gettime64() as the fallback timekeeping system call on all architectures.</font><br>
<p>
<font class="QuotedText">&gt; During the 5.3 merge window, the x86 architecture switched over to the generic version, </font><br>
<p>
If the version of clock_gettime() invoked was really the *internal* implementation detail it seemed to be, there wouldn't have been any issue. Just like firewalls, the seccomp approach doesn't seem to care about layers and abstractions. This basically "promotes" internal implementation details to API rank, right? What could possibly go wrong.<br>
<p>
<font class="QuotedText">&gt; Even if the kernel community avoids incompatible changes, a change in a library somewhere can invoke a new system call that a given seccomp() policy may frown upon. </font><br>
<p>
Sounds like a "yes".<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor795300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 21:04 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/795300/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It makes sense to protect code, as well as data, because the more kernel code a malicious process can cause to execute, the more kernel bugs it can trigger for exploitation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor795291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Put a version number on the policy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2019 7:49 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/795291/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Surely the seccomp policy should be tagged with the kernel version it was originally written for. If the policy is for an old kernel (or predates the existence of version numbers) then apply the weird backwards compatibility workarounds that when you allow one system call you really intended to allow another one too. If the policy is for a new enough kernel then apply it as-is. If the policy is truly ancient, the kernel could refuse it altogether (so the backwards compatibility code doesn’t have to be maintained for ever and ever). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor795382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 19:07 UTC (Mon)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/795382/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If the calling program wants an esoteric clock that has not been implemented</font><br>
<p>
The use of "esoteric" here is IMO misleading.  Any clock that doesn't have vDSO support is essentially useless unless you only want to call it rarely... and most of the nonstandard clocks are there precisely to provide the kind of precise timing that is needed when calling them often.<br>
<p>
I'm glad that as of the generic rewrite it appears that CLOCK_MONOTONIC_RAW will _finally_ get the vDSO treatment (on intel).  This clock has been known to be virtually useless for years, with many blog posts pointing out (often without understanding why) that it's hundreds of times slower than CLOCK_MONOTONIC even though its behavior is actually what people want when measuring time intervals and the clock_gettime() man page makes it sound like it should be the most efficient option.<br>
<p>
If you investigate the reasons why vDSO CLOCK_MONOTONIC_RAW isn't already available you'll run across a somewhat depressing example of the kernel development model failing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2019 13:24 UTC (Tue)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/795406/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please explain how you find it to be a depressing failure.<br>
<p>
CLOCK_MONOTONIC_RAW for the x86 vDDO was merged just a couple months after patches showed up. If there were significantly earlier requests, no one told me about them, and I’m the maintainer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor795511"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2019 18:01 UTC (Tue)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/795511/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe I've got the timeline wrong: I'm not sure if by "a couple months" you mean the recent merge of the generic vDSO implementation, or something else.<br>
<p>
Google shows that patches to add vDSO for Intel CLOCK_MONOTONIC_RAW were sent in March 2018 but it seems they were never applied; I can't find info on them via Google or "git log --grep".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795511/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor795396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2019 23:41 UTC (Mon)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/795396/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That something is likely to be based on this patch series from Thomas Gleixner, which simply causes the vDSO to fall back to the 32-bit clock_gettime() system call on 32-bit systems. It is a solution that is pleasing to nobody, but it solves the regression issue for now. Some other solution will be required eventually; it is not possible to support 32-bit time indefinitely.</font><br>
<p>
But to match the existing ABI of clock_gettime(), the return value of the function will have to fit a 32-bit struct timespec anyway in the end. So how is it an improvement to have the VDSO to make a 64-bit clock_gettime64() call just to immediately truncate the seconds to 32 bits? Am I missing something?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/795396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor796514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">vDSO, 32-bit time, and seccomp</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2019 7:43 UTC (Sat)
                               by <b>mcortese</b> (guest, #52099)
                              [<a href="/Articles/796514/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When a function is replaced by a new one with additional features and you know that the old one will eventually become deprecated, then it's preferable to use the new one even if you don't need the additional features.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/796514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
