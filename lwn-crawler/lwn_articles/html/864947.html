        <!DOCTYPE html>
        <html lang="en">
        <head><title>The edge-triggered misunderstanding [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/864947/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/865310/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/864947/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The edge-triggered misunderstanding</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 5, 2021</br>
           </div>
The <a href="https://blog.google/products/android/android-12-beta/">Android
12 beta release</a> first appeared in May of this year.  As is almost
obligatory, this release features "<q>the biggest design change in
Android's history</q>"; what's an Android release without requiring
users to relearn everything?  That historical event was not meant to
include one change that many beta testers are noticing, though: a kernel
regression that breaks a significant number of apps.  This problem has just
been fixed, but it makes a good example of why preventing regressions can
be so hard and how the kernel project responds to them when they do happen.

<p>
Back in late 2019, David Howells <a
href="/ml/linux-kernel/157558502272.10278.8718685637610645781.stgit@warthog.procyon.org.uk/">made
some changes to the pipe code</a>
to address a couple of problems.  Unfortunately, that work caused the
sort of regression that the kernel community finds most unacceptable: it
<a
href="/ml/linux-kernel/CAHk-=wj9pprDUeoJd5EeN-2x7+GXdSsm44mSv1y9f5e7MrTZ2A@mail.gmail.com/">slowed
down (or even hung) kernel builds</a>.  After <a 
href="/ml/linux-kernel/20191206135604.GB2734@twin.jikos.cz/">an extensive
discussion</a>, an unfortunate interaction with the GNU <tt>make</tt> job
server was identified and  a <a
href="https://git.kernel.org/linus/1b6b26ae7053">a fix by Linus Torvalds
was applied</a> that 
made the problem go away.  The 5.5 kernel was released shortly afterward,
kernel builds sped back up, and the problem was deemed to have been solved.
<p>
<h4>Not done yet</h4>
<p>
At the end of July, Sandeep Patil <a
href="/ml/linux-kernel/20210729222635.2937453-1-sspatil@android.com/">informed
the community</a> that, while the GNU <tt>make</tt> problem may have been fixed,
the fix created a new problem of its own.  He included a patch to revert
Torvalds's fix.  That revert clearly was never going to be applied on its
own — kernel developers still lack an appetite for slower builds — but it
did spark an investigation of the real problem.
<p>
The 2019 pipe rework and subsequent fix had been much more painful than
Torvalds thought they
should be, so he made a number of changes to both the organization and the
behavior of the
code.  Specifically, an important change was made to how
pipes work with system calls like <a
href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html"><tt>epoll_wait()</tt></a>,
<a
href="https://man7.org/linux/man-pages/man2/poll.2.html"><tt>poll()</tt></a>,
and <a
href="https://man7.org/linux/man-pages/man2/select.2.html"><tt>select()</tt></a>.
If the desired type of I/O is not possible without blocking, these calls
will put the calling process onto a wait queue.  When the situation changes
(data can now be read or written), the processes on the appropriate wait
queue are woken so that they can request their I/O.
<p>
The 2019 fix changed the way that wakeup was performed.  Before, a write to
a pipe would unconditionally wake any waiting readers; indeed, it could
wake them multiple times in a single system call.  The fix changed this
behavior to only perform the wakeup if the pipe buffer was empty at the
start of the operation; a write to a pipe that already contained data
waiting to be read would simply add the new data without causing the
wakeup.  The reasoning 
behind this change was straightforward enough: the polling system calls will
return immediately if data is already available for reading, so there
should not <i>be</i> any waiters if the pipe has available data.
<p>
<h4>On the edge</h4>
<p>
There is, however, a mode to <tt>epoll_wait()</tt> called "edge triggered"
(or <tt>EPOLLET</tt>) that behaves a little differently.  A process
requesting an edge-triggered wait will <i>not</i> see an immediate return
from <tt>epoll_wait()</tt> if there is available data; instead, it will
wait until the situation changes.  At least, that is how it worked before
the 2019 patches.  Once the pipe driver stopped performing wakeups any time
that data arrived, processes initiating edge-triggered waits when there was
already data available would not see the "edge" and would not wake.
<p>
There was, evidently, reason to wonder if this kind of problem would ever
arise.  The previous version of <tt>pipe_write()</tt> included this helpful
comment:
<p>
<pre>
    /* Always wake up, even if the copy fails. Otherwise
     * we lock up (O_NONBLOCK-)readers that sleep due to
     * syscall merging.
     * FIXME! Is this really true?
     */
</pre>
<p>
It turns out that it was really true.  There are a number of Android
libraries, such as <a href="https://github.com/realm/realm-core">Realm</a>,
that depend on getting edge-triggered wakeups even if there had been data
waiting in the pipe before the <tt>epoll_wait()</tt> call was made.  The
purpose, evidently, is to wait until the pipe buffer is full, then read 
all of the data in a single operation.  Those
libraries broke when the 5.10 kernel went into the Android&nbsp;12 beta,
bringing down a set of apps with them.  Realm has since worked around the
problem but, as Patil pointed out, the joy of bundling means that "<q>it
will be a while 
before all applications incorporate the updated library</q>".  Fixing
the kernel would repair the problem for all apps.
<p>
There seems to be widespread agreement that these libraries manifest a
misunderstanding of what "edge-triggered" means and are using the
edge-triggered mode incorrectly.  As Torvalds <a
href="https://lwn.net/ml/linux-kernel/CAHk-=witY33b-vqqp=ApqyoFDpx9p+n4PwG9N-TvF8bq7-tsHw@mail.gmail.com/">explained</a>:
<p>
<blockquote class="bq">
	This is literally an epoll() confusion about what an "edge" is.
<p>
	An edge is not "somebody wrote more data". An edge is "there was no
	data, now there is data".
<p>
	And a level triggered event is *also* not "somebody wrote more data".
	A level-triggered signal is simply "there is data".
<p>
	Notice how neither edge nor level are about "more data". One is
	about the edge of "no data" -&gt; "some data", and the other is
	just a "data is available".
</blockquote>
<p>
That, however, is not how edge-triggered operation was implemented for
pipes.  Unsurprisingly, in a demonstration of <a
href="https://www.hyrumslaw.com/">Hyrum's law</a> in action, applications
began to rely on the actual behavior 
of the system rather than the intended semantics.  The <a
href="https://man7.org/linux/man-pages/man7/epoll.7.html"><tt>epoll()</tt></a>
man page agrees with Torvalds's description, describing just the sort of
blocking behavior experienced by the broken apps.  In the distant past,
kernel developers might have just answered that these libraries are doing
it wrong.  But that's not how the kernel works now; thus, Torvalds
continued:
<p>
<blockquote class="bq">
	But we have the policy that regressions aren't about documentation
	or even sane behavior.
<p>
	Regressions are about whether a user application broke in a
	noticeable way.
</blockquote>
<p>
That interpretation of "regression" requires that the problem be fixed.
And indeed that was done with <a
href="https://git.kernel.org/linus/3a34b13a88ca">a new fix</a> that was
merged for 5.14-rc4 at the end of July and was included in the 5.10.56 and
5.13.8 stable 
updates.  This patch does not quite restore the old behavior; specifically,
it will only perform one wakeup per write operation.  It does appear to have
fixed the problem, though.
<p>
<h4>Problem solved?</h4>
<p>
The 5.5 kernel was released in January 2020 — a time when few of us
understood what was about to descend upon us, and a significant kernel
regression is just another addition to the list.  This regression thus endured
for a year and a half, and found its way into the 5.10 long-term-stable release
last December.  The fact that it only surfaced now suggests a testing gap
among certain users; happily, it was caught before the next Android release
was finalized.
<p>

The ominous question that remains, though, is whether, in that year and a
half, any applications became dependent on the newer semantics.  And,
indeed, there is already <a
href="/ml/linux-kernel/20210802024945.GA8372@xsang-OptiPlex-9020/">a
report</a> (from Intel's automated test system) that the <a
href="https://manpages.ubuntu.com/manpages/bionic/man8/hackbench.8.html">hackbench</a>
benchmark regressed by nearly 13% after the latest fix was applied.
Torvalds <a
href="/ml/linux-kernel/CAHk-=whr-zgf41B0BPsWnL-WWqhdk71rKffhV0fzdCuem3=SCQ@mail.gmail.com/">responded</a>
that he is "<q>not sure how much hackbench really matters</q>" and
that the regression "<q>probably doesn't matter one whit</q>".  Even
so, he posted <a
href="/ml/linux-kernel/CAHk-=whYu7f=itjJJTfAWdDN2Baz0whdU1bzxh_5RAfj+LyB3g@mail.gmail.com/">a
new patch</a> that provides something closer to the older behavior — but
only if the pipe is being used with one of the polling functions.  Should
it turn out that the hackbench regression does matter, there will be a fix
in hand.
<p>
If the latest fix breaks something else, though, kernel developers may
have a difficult choice to make.  It is possible that there is no way
forward without leaving a broken application somewhere; this is why it is
important to catch regressions early.
With luck, that sort of breakage won't happen and
this particular episode will now be finally done.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Android">Android</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Epoll">Epoll</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/864947/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor865369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 17:38 UTC (Thu)
                               by <b>scientes</b> (guest, #83068)
                              [<a href="/Articles/865369/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Android release also exists in this creepy world where Google has their own Top Level Domain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 21:01 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/865383/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the other hand, this world also has TLDs for: .bar, .beer and .coffee! It can&#x27;t be THAT bad.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 21:06 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/865382/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      They own <a href="https://en.wikipedia.org/wiki/List_of_Internet_top-level_domains">a whole bunch of TLDs</a>: several named after products they're in the process of killing, common english words and suffixes, .ads (predictably), .dev (which they effectively stole from the commons by forcing HSTS and breaking a lot of internal network setups), and for some reason, .zip.


      
          <div class="CommentReplyButton">
            <form action="/Articles/865382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 21:14 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/865384/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; .dev (which they effectively stole from the commons by forcing HSTS and breaking a lot of internal network setups)</font><br>
<p>
AFAIK, `.dev` was never a protected TLD. Tor had `.onion` officially protected through IETF for just this reason. I don&#x27;t know why `.dev` wasn&#x27;t protected as well if it was so widely used.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">.dev</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 22:32 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/865387/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Tor project had a rationale for how names in .onion actually work, resulting in them having global meaning. The various incompetent .dev hijackers don&#x27;t have any rationale, their idea is they should just get to make up whatever they want and they&#x27;re astonished that this doesn&#x27;t work. Accordingly you could hardly expect them to get around to actually going through the process to reserve these names (which took a bunch of time to produce RFC 7686), and if they had attempted to do so you can expect they&#x27;d immediately have started bickering about how everybody else&#x27;s usage is wrong and only theirs is OK.<br>
<p>
The more popular hijacked TLDs were .mail, .corp, and .home - ICANN concluded that these names were so poisoned it couldn&#x27;t delegate them. There was in fact an attempt to write an ID for those TLDs but as expected it descended into squabbling and went nowhere.<br>
<p>
Hijacking is a perfectly reasonable way to carve out space if you have the numbers on your side. The IETF&#x27;s OID arc 1.3.6.1 was hijacked. 1.3.6 means the US Department of Defense but of course the DoD didn&#x27;t delegate the arc to the IETF, instead the IETF simply hijacked it, reasoning that the fledgling Internet needs a OID arc and if they understood that the DoD would obviously donate 1.3.6.1 so why waste time actually figuring out who, if anybody, had authority to authorise it. Today you use OIDs under 1.3.6.1 all over the place and think nothing of it, the hijacking was entirely successful, it would be unthinkable to &quot;give back&quot; 1.3.6.1<br>
<p>
But the .dev users didn&#x27;t have the numbers on their side and so .dev is now a somewhat successful TLD with HSTS enabled. Unsuccessful hijack attempts go badly for the hijackers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 23:03 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/865390/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In general, IETF doesn&#x27;t really like this sort of &quot;make up your own fake TLD&quot; nonsense, at least with respect to &quot;real&quot; DNS (although &quot;fake&quot; DNS such as mDNS does get to reserve names like .local). They did reserve .home.arpa for use in &quot;home networks&quot; - but there&#x27;s no equivalent for other networks. I read that less as an endorsement than as a tacit acknowledgement that home networks are, for most consumers, an unfixable clusterfuck, and so we&#x27;d rather just partition it off to a subdomain of .arpa (which is already a weird no-man&#x27;s land) rather than trying to get non-technical end users excited about configuring their networks properly. Also, telling every end user in the world to go buy their own domain name is just never going to work.<br>
<p>
For &quot;real&quot; (business) networks, I think it&#x27;s wiser to use a subdomain of example.com (which you own), and configure DNS to search from there (which you can do via DHCP or as part of your client provisioning setup). The net effect of this is that users can type http://foo/ in their web browsers, and it automatically expands to (say) foo.dev.example.com, with no potential for confusion with foo.dev. That will allow you to acquire a certificate for *.dev.example.com and run &quot;real&quot; TLS to any client device, without having to install custom root certificates on the client, run your own internal CA, etc. It also means that, when a user copies and pastes a URL, they always get the FQDN, so that it will work even on devices which have not been set up for this DNS search chicanery (assuming, of course, that your security policies allow such devices to connect in the first place).<br>
<p>
Disclaimer: I work for Google.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 23:17 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/865396/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I use `.internal` as the TLD in my home network. IIRC, that is one of the reserved names as well that doesn&#x27;t route over the global DNS network. I had been using `dev.&lt;mydomain&gt;`, but it just got too messy trying to sync up public DNS routing and internal routing with the same names that I just gave up and used something private internally.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 12:26 UTC (Fri)
                               by <b>Jonno</b> (subscriber, #49613)
                              [<a href="/Articles/865428/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I use `.internal` as the TLD in my home network. IIRC, that is one of the reserved names as well that doesn&#x27;t route over the global DNS network.</font><br>
<p>
It isn&#x27;t. The only reserved TLDs are: .example, .invalid, .local, .localhost, .onion, and .test. There are also some reserved subdomains of other TLDs, see [special-use-domain-names] for a complete list.<br>
<p>
There are two current proposals for adding new reserved TLDs: .alt [draft-ietf-dnsop-alt-tld] and the country codes that ISO-3166-1 specifies will never be assigned to a territory (.aa .qm .qn .qo .qp .qq .qw .qs .qt .qu .qv .qw .qx .qy .qz .xa .xb .xc .xd .xe .xf .xg .xh .xi .xj .xk .xl .xm .xn .xo .xp .xr .xs .xt .xu .xv .xw .xx .xy .xz .zz) [draft-ietf-dnsop-private-use-tld].<br>
<p>
There was a 2017 proposal for .internal [draft-wkumari-dnsop-internal], but it was not adopted.<br>
<p>
[special-use-domain-names] <a href="https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml">https://www.iana.org/assignments/special-use-domain-names...</a><br>
[draft-ietf-dnsop-alt-tld] <a href="https://datatracker.ietf.org/doc/draft-ietf-dnsop-alt-tld/">https://datatracker.ietf.org/doc/draft-ietf-dnsop-alt-tld/</a><br>
[draft-ietf-dnsop-private-use-tld] <a href="https://datatracker.ietf.org/doc/draft-ietf-dnsop-private-use-tld/">https://datatracker.ietf.org/doc/draft-ietf-dnsop-private...</a><br>
[draft-wkumari-dnsop-internal] <a href="https://datatracker.ietf.org/doc/draft-wkumari-dnsop-internal/">https://datatracker.ietf.org/doc/draft-wkumari-dnsop-inte...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865467"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 13:29 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/865467/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah I missed that the `.internal` RFC was never adopted. I guess I&#x27;ll put migration to…something else on my list. Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865467/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor865481"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 16:14 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/865481/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; IIRC, that is one of the reserved names as well that doesn&#x27;t route over the global DNS network.</font><br>
<p>
Somebody else already explained that in fact .internal is not reserved although there was effort in that direction. But I want to particularly respond to &quot;doesn&#x27;t route over the global DNS network&quot; because this is a grave misunderstanding of what&#x27;s going on.<br>
<p>
Your bogus names _will_ leak. If you&#x27;ve just made up bogus names for some service you would cheerfully have given a name in the public DNS that&#x27;s delegated to you then it&#x27;s no worse than before. But a LOT of people have this idea that their bogus names are &quot;not routed&quot; and so magically this is safer, the exact same mistake that happens for RFC 1918 addressing and with the same consequences.<br>
<p>
These bogus names aren&#x27;t special, nothing magically says &quot;Oh this name is a double-secret internal name, protect it&quot;, it just goes in the big pile of bogus names like all the others. Unsurprisingly bad guys are much more interested in what&#x27;s in that pile, although infrastructure researchers pick through it too.<br>
<p>
<font class="QuotedText">&gt; it just got too messy trying to sync up public DNS routing and internal routing with the same names</font><br>
<p>
But your eventual solution doesn&#x27;t sync up to public DNS either. So, just don&#x27;t do that. It makes plenty of sense that I have some.internal.tlrmx.org without there being any public DNS records for that name. But unlike hijacking a TLD I *can* add public DNS records later if I want to, because it&#x27;s in a namespace I actually control.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865481/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 17:18 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/865495/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I should say that I&#x27;m not worried about leakage so much as squatting, so I wasn&#x27;t clear there. If someone knows I have a local DNS name of `git` or can guess my naming scheme for hosts…so be it.<br>
<p>
We just used to use a `foobar.com` for internal routing (related to our actual domain name, but not publicly registered) at $DAYJOB. &quot;Hilarity&quot; ensued when someone *did* register that name and we started getting hosts external to our network responding to our SSH queries. I presume they were watching dead DNS queries pile up and snatched it in the hopes to get something juicy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2021 4:55 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/865535/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As mentioned upthread, it is completely safe to use fake subdomains of home.arpa, because it was explicitly reserved for this purpose (RFC 8375). Of course, they can still leak, but if you&#x27;re running a local recursive resolver, you can at least configure it to avoid routing home.arpa queries outside of your homenet (because they will never be valid in the global DNS). So in principle, you can prevent fake DNS queries from reaching the external world, if you really want to. It&#x27;s just a lot of work for questionable benefit, IMHO.<br>
<p>
Technically, RFC 8375 positions itself as a &quot;correction&quot; to RFC 7788, but it also acknowledges that you don&#x27;t have to be doing HNCP to use home.arpa. Which is a Good Thing, because I still can&#x27;t figure out if HNCP is even a real protocol, or just a stack of &quot;wouldn&#x27;t it be nice if consumer products did [X]&quot; ideas wearing a trenchcoat.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor865430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 12:12 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/865430/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Also, telling every end user in the world to go buy their own domain name is just never going to work.</font><br>
<p>
Which is why, back in the day, demon was such a good IAP (Internet *access* provider). You opened an account, and you got &lt;account&gt;.demon.co.uk. Whether you used it as a host, or a subdomain, or whatever, was up to you. You also got a static IPv4, which you again could use for your host, or an RFC1918 network, or whatever, was up to you ...<br>
<p>
The problem, of course, was this implied the user had some technical nous, which back then they typically did. Then, of course, the bean counters took demon over, and everything just imploded ...<br>
<p>
(Obviously, the bean counters were massively helped by clueless telcos and regulators ...)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2021 4:13 UTC (Sun)
                               by <b>motiejus</b> (subscriber, #92837)
                              [<a href="/Articles/865583/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How can I get a real tls cert for a subdomain.exame.com? I did a bit of searching, to no avail.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TLS for private subdomains</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2021 9:40 UTC (Mon)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/865648/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Assuming you own the parent domain, you use DNS verification. You would have to (temporarily) create a public TXT record in the parent domain's DNS, as specified by the certificate authority: for example, you could put a record for _acme-challenge.test.internal.example.com in the public example.com DNS.
<p>
This would (tend to) confirm that the subdomain exists, but if you want a "real" TLS certificate, the subdomain will be included in public Certificate Transparency logs.
<p>
You would not have to publish any A or AAAA records for the subdomain, nor would you have to make any computers on the subdomain available to the outside world.









      
          <div class="CommentReplyButton">
            <form action="/Articles/865648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865653"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TLS for private subdomains</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2021 12:54 UTC (Mon)
                               by <b>motiejus</b> (subscriber, #92837)
                              [<a href="/Articles/865653/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought you literally meant internal.example.com :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865653/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor865381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 21:01 UTC (Thu)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/865381/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
It is possible that there is no way forward without leaving a broken application somewhere; this is why it important to catch regressions early.
</blockquote>

sigh... This regression was reported quite a while ago... <a href="https://lore.kernel.org/lkml/300cb158-5ab1-ed55-404f-8abc9cbdcae0@gmail.com/">https://lore.kernel.org/lkml/300cb158-5ab1-ed55-404f-8abc9cbdcae0@gmail.com/</a>:

<blockquote>
Yes, user space code does surprising things. But, give people
enough time and every detail of API behavior will come
to be depended upon by someone. We don't know if anyone
depends on the old pipe EPOLLET behavior. I also imagine the
chances are small, but if users do depend on it, they are
in for an unpleasant surprise (missed notifications).
</blockquote>





      
          <div class="CommentReplyButton">
            <form action="/Articles/865381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 23:31 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/865394/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Is that a report of a regression though? i.e. Does a change in behaviour count as a regression if no users actually rely on the legacy unintended (buggy) semantics.</p>

<p>Yes, ultimately a user <em>did</em> rely on those semantics, so it turned out to be a regression, but that was not known then and at the time it was merely a hypothetical possibility where "the chances are small" of it being an issue.</p>

<p>(And, to be fair, of the millions of places that Linux is used, and from the millions of software projects that run on it, in 18 months only 1 library has been found to rely on the buggy behaviour. The chances were indeed small.)</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/865394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 23:34 UTC (Thu)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/865397/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
The epoll() man page agrees with Torvalds's description, describing just the sort of blocking behavior experienced by the broken apps.
</blockquote>

Well, that is questionable. Elsewhere, the page says:

<blockquote>
Since even with edge-triggered epoll, multiple events can be generated
upon  receipt of multiple chunks of data, the caller has the option to
specify the EPOLLONESHOT flag, to tell epoll to disable the associated
file  descriptor  after  the  receipt  of an event with epoll_wait(2).
</blockquote>

As I argued in Oct 2020, the existence of EPOLLONESHOT is, in my estimation, an argument against Linus's interpretation.

And:

<blockquote>
That, however, is not how edge-triggered operation was implemented for pipes.
</blockquote>

In fact, every other mechanism that I tested (Internet domain stream sockets, POSIX message queues, terminals, hierarchical epoll) behaves the same as EPOLLET historically behaved for epoll.


      
          <div class="CommentReplyButton">
            <form action="/Articles/865397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 0:10 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/865400/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, the man page (epoll(7)) also says this:<br>
<p>
<font class="QuotedText">&gt; An application that employs the EPOLLET flag should use</font><br>
<font class="QuotedText">&gt; nonblocking file descriptors to avoid having a blocking read or</font><br>
<font class="QuotedText">&gt; write starve a task that is handling multiple file descriptors.</font><br>
<font class="QuotedText">&gt; The suggested way to use epoll as an edge-triggered (EPOLLET)</font><br>
<font class="QuotedText">&gt; interface is as follows:</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt;   a) with nonblocking file descriptors; and</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt;   b) by waiting for an event only after read(2) or write(2) return</font><br>
<font class="QuotedText">&gt;      EAGAIN.</font><br>
<p>
My read is that the admonition about EPOLLONESHOT is simply a warning that you are guaranteed *at least* one notification per edge event, rather than exactly one notification per edge event, so if you don&#x27;t want to get duplicate notifications, you have to explicitly say you don&#x27;t want them. That doesn&#x27;t mean that you should rely on getting duplicate notifications, just that the kernel won&#x27;t promise to prevent them altogether.<br>
<p>
But OTOH the pattern described above is clearly wrong, because there is a race between read(2)/write(2) returning EAGAIN and you calling epoll_wait(2), during which more data could become available. This is safe as long as you don&#x27;t use EPOLLONESHOT, because an event will still be generated even if you are not waiting for it (and then epoll_wait will return immediately). But if you use EPOLLONESHOT, then you have to re-arm the epoll before calling read or write to avoid the race, which renders the whole thing rather pointless because now you have another race between epoll_ctl and read/write, where you can still receive duplicate notifications anyway.<br>
<p>
The last time I had to look at this man page (many years ago), I felt that the entire EPOLLET mode of operation was a disaster waiting to happen, and frankly I&#x27;m still not sure what problem it solves that can&#x27;t be more easily solved using EPOLLLT. If there&#x27;s more data to consume, don&#x27;t you want to, I don&#x27;t know, actually consume it?<br>
<p>
Disclaimer: I work for Google, but not on Android.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 0:44 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/865404/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The last time I had to look at this man page (many years ago), I felt that the entire EPOLLET mode of operation was a disaster waiting to happen, and frankly I&#x27;m still not sure what problem it solves that can&#x27;t be more easily solved using EPOLLLT. If there&#x27;s more data to consume, don&#x27;t you want to, I don&#x27;t know, actually consume it?</font><br>
<p>
After doing some further research, I think the intended use case was &quot;multiple threads call epoll_wait and the kernel dispatches work to them automatically.&quot; Which is nice and all, but IMHO this is more safely handled with explicit userspace thread pooling and work queueing. That way, you can guarantee that exactly one &quot;logical work object&quot; is handled by exactly one thread at a time, and you can be completely confident that you won&#x27;t end up with duplicate or missed notifications (you use EPOLLLT, the controller thread calls epoll_ctl(..., EPOLL_CTL_DEL, ...) on the notified file descriptor when an event happens, and the worker thread does the reverse once it&#x27;s finished with the resulting work object).<br>
<p>
Sure, you burn an extra thread, but threads are cheap, and this design is extensible to more complex work objects (e.g. involving more than one file descriptor).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 1:24 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/865407/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; you use EPOLLLT, the controller thread calls epoll_ctl(..., EPOLL_CTL_DEL, ...) on the notified file descriptor when an event happens, and the worker thread does the reverse once it&#x27;s finished with the resulting work object).</font><br>
<p>
This entirely defeats the purpose of epoll, which is O(1) polling. A design that requires deleting/adding or rearming a descriptor on every event devolves to similar performance as poll(2). This is why Zed Shaw&#x27;s Mongrel2 ended up switching to poll (as a performance &quot;optimization&quot;) for non-long-poll connections, though I don&#x27;t think he realized the issue. The issue was the design and composition of the internal Mongrel2 APIs, which necessitated the delete/add for every event.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 3:44 UTC (Fri)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/865413/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looking at the implementation of epoll, it keeps the list of descriptors in a red-black tree, so I&#x27;d expect adding and deleting them to be O(log n), a far cry from poll()&#x27;s O(n).  And I&#x27;d be surprised if the tree walk itself was a major component of the cost.  Locking overhead and system call overhead, on the other hand, make this pattern probably best to avoid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 5:57 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/865416/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Though, if you are using Linux specific system calls, polling with either io_submit or io_uring is preferable anyway...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 15:37 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/865477/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Locking overhead and system call overhead, on the other hand, make this pattern probably best to avoid.</font><br>
<p>
But that applies just as well to EPOLLONESHOT! So what&#x27;s the point of it?<br>
<p>
The way I see it, either you can tolerate duplicate events, or you can&#x27;t. If you can&#x27;t, then you *must* do some sort of explicit syscall to tell the kernel when you&#x27;re done with a given event and that it is now safe to dispatch another event. But as I explained above, if you want to use EPOLLONESHOT and epoll_ctl(..., EPOLL_CTL_MOD, ...) for that purpose, then you have to call epoll_ctl either before or after the read/write, and both ways result in a race condition. So you just can&#x27;t use EPOLLONESHOT for that purpose, and must instead use single-threaded EPOLLLT with explicit add/remove. There&#x27;s no other safe, duplicate-free way to use this API.<br>
<p>
OTOH, if you can tolerate duplicate notifications, then I don&#x27;t see the point of EPOLLONESHOT at all. Just use EPOLLLT (single-threaded) or EPOLLET (multi-threaded, but you somehow don&#x27;t care about the threads walking all over each other when the same fd gets signalled multiple times).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865489"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 16:55 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865489/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well that depends on how EPOLLONESHOT is implemented in epoll when you rearm it, if epoll checks the state of the fd (aka if there is a buffer on EPOLLIN or if it can write on EPOLLOUT) then it can avoid a race condition here. Also epoll could guess that if EPOLLONESHOT is used then the fd will be rearmed again so it could retain the fd in it&#x27;s internal list but only mark it as being temporarily disabled.<br>
<p>
I have not checked any of the kernel sources though so I don&#x27;t know if any of this is actually implemented, but it could be.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865489/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865497"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 17:30 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/865497/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well that depends on how EPOLLONESHOT is implemented in epoll when you rearm it, if epoll checks the state of the fd (aka if there is a buffer on EPOLLIN or if it can write on EPOLLOUT) then it can avoid a race condition here.</font><br>
<p>
That&#x27;s how EPOLLLT behaves. If you&#x27;re using EPOLLET, then you have explicitly asked for the opposite behavior (i.e. to only notify when the fd *changes states*). There is nothing in epoll(7) (or any of the other pages I looked at) which suggests that a &quot;disabled&quot; EPOLLONESHOT fd can still receive events, which are saved until the fd is re-armed. The implication is that the events are simply dropped.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865497/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 21:17 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865518/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
EPOLLONESHOT was introduced so that you could load balance reads over multiple threads, if this race that you talk about would exist then it would make the whole idea of the flag moot (and a lot of software out there completely broken). It was introduced after Bryan Cantrill&#x27;s epoll-rant in 2015 <a href="https://www.youtube.com/watch?v=l6XQUciI-Sc&amp;t=3420s">https://www.youtube.com/watch?v=l6XQUciI-Sc&amp;t=3420s</a> where he critiques that epoll cannot be used to load balance reads in multiple threads (among other things).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 21:34 UTC (Fri)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/865521/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It was introduced after Bryan Cantrill&#x27;s epoll-rant in 2015</font><br>
<p>
EPOLLONESHOT appeared in Linux 2.6.2, in 2004. I think you perhaps are thinking of EPOLLEXCLUSIVE.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865527"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2021 2:07 UTC (Sat)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865527/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes it seems like Wikipedia mixed them up, he does speak about epoll in that video as if EPOLLONESHOT didn&#x27;t exist though which is why I was fooled, come to think of it I should have reacted to the date of 2015 since I&#x27;ve used the flag for many years before that :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865527/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor865522"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 22:21 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/865522/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe the documentation is incomplete or misleading, but as it stands, the man page says you get a race condition. If this race condition does not in fact exist, then the man page should explicitly call that out, rather than tacitly assuming that we all watch random YouTube videos of BSD developers criticizing Linux.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865522/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2021 2:18 UTC (Sat)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865529/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok so I&#x27;m trying to find the actual discussion on LKML that led to the flag but atleast the comment that Davide Libenzi have on the code is this:<br>
<p>
+	 * EPOLLONESHOT bit that disables the descriptor when an event is received,<br>
+	 * until the next EPOLL_CTL_MOD will be issued.<br>
<p>
Note the &quot;when an even it received _until_&quot; so the event is put on hold until the fd is re-armed by a EPOLL_CTL_MOD.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2021 3:23 UTC (Sat)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865533/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well the manpage should perhaps made a bit clear because the behaviour is specifically like the one I&#x27;ve described. I just made a test of this using pipes on a 5.11 kernel, strace: (* lines from a different pid)<br>
<p>
* write(4, &quot;6\334\177&quot;, 3)             = 3<br>
epoll_create1(EPOLL_CLOEXEC)            = 5<br>
epoll_ctl(5, EPOLL_CTL_ADD, 3, {EPOLLIN|EPOLLONESHOT|EPOLLET, {u32=3, u64=2581266273925070851}}) = 0<br>
epoll_wait(5, [{EPOLLIN, {u32=3, u64=2581266273925070851}}], 1, -1) = 1<br>
read(3, &quot;6\334\177&quot;, 3)             = 3<br>
* write(4, &quot;6\334\177&quot;, 3)             = 3<br>
clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=10, tv_nsec=0}, 0x7fff71722d70) = 0<br>
epoll_ctl(5, EPOLL_CTL_MOD, 3, {EPOLLIN|EPOLLONESHOT|EPOLLET, {u32=3, u64=2581266273925070851}}) = 0<br>
epoll_wait(5, [{EPOLLIN, {u32=3, u64=2581266273925070851}}], 1, -1) = 1<br>
read(3, &quot;6\334\177&quot;, 3)             = 3<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor865498"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 17:37 UTC (Fri)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/865498/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At the time you call epoll_ctl to add or re-enable a fd, the kernel will always check whether the fd is already ready and queue an event for it if so. [1] To this extent, it acts &#x27;level-triggered&#x27; regardless of whether you request level-triggered or edge-triggered mode.  So it should be safe to use epoll with EPOLLET plus EPOLLONESHOT, and always start by adding/enabling the FD, not calling read/write.  Then once you receive an event, you call read/write, then re-arm with EPOLL_CTL_MOD.  If another event comes between the read/write and the re-arm, you will still get notified.<br>
<p>
However, this does directly contradict the man page&#x27;s &quot;suggested way&quot; of using EPOLLET [2] which is to only use epoll after read/write return EAGAIN.  And the behavior of checking for readiness at add/enable time doesn&#x27;t seem to be documented, so it&#x27;s hard to say if this is meant to be guaranteed.<br>
<p>
[1] <a href="https://stackoverflow.com/questions/12920243/if-a-file-is-readable-before-epoll-ctl-is-called-in-edge-triggered-mode-will-a">https://stackoverflow.com/questions/12920243/if-a-file-is...</a><br>
<p>
[2] <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">https://man7.org/linux/man-pages/man7/epoll.7.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865498/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor865493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 17:12 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865493/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Checking the man page shows that re-arming the fd on EPOLLONESHOT is done via EPOLL_CTL_MOD and not EPOLL_CTL_ADD so the fd remains in the epoll internal list of descriptors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 17:19 UTC (Fri)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/865494/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That still takes the lock and walks the tree, but at least it doesn&#x27;t have to allocate a new `struct epitem` like EPOLL_CTL_ADD does.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 18:20 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865504/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And more importantly I think that it also means that there is no race condition between read returning EAGAIN and you re-arming the fd since epoll can mark the fd since it remains in the list.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor865421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 7:56 UTC (Fri)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/865421/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW, EPOLLONESHOT is not really relevant for most applications, and doesn&#x27;t have a lot to do with edge-triggering. I believe the original use-case was a socket where you only wanted to connect() and see whether there was anything at all on the given port (some P2P server needed it).<br>
<p>
As background information: The way edge-triggering works is that you keep your socket in the set all the time (so there&#x27;s no race against epoll_add). The simplest example is a socket where you have a lot of data you want to write, but it could get filled up; you write until the socket buffer is full and get EAGAIN (now the level is low), and then you know that you will get a wakeup through epoll when there&#x27;s room the next time (the level goes from low to high). With level-triggering, you would have to take the socket in and out of the epoll set all the time, so edge-triggering is more efficient. (But you have to be really careful never to forget about the socket in the high-level state, since you won&#x27;t ever get any wakeups for it then!) A similar pattern exists for reads, where you could need to pause reading due to your own buffers getting full.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 14:05 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/865469/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; FWIW, EPOLLONESHOT is not really relevant for most applications, and doesn&#x27;t have a lot to do with edge-triggering. I believe the original use-case was a socket where you only wanted to connect() and see whether there was anything at all on the given port (some P2P server needed it).</font><br>
<p>
I use EPOLLOUT | EPOLLONESHOT on a dummy fd that is always ready as a generic way for another thread to wakeup epoll_wait without using signals.  Another way would be to write data to a pipe and then read it out after it woke up the epoll_wait, but that would require more syscalls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 14:37 UTC (Fri)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/865473/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn&#x27;t that what eventfd is for? It sounds more idiomatic than modifying the epoll set from another thread (which is what you&#x27;re doing, right?).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 15:30 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/865475/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for pointing that out; I hadn&#x27;t seen eventfd before.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor866720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 19, 2021 7:31 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/866720/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; FWIW, EPOLLONESHOT is not really relevant for most applications [...] I believe the original use-case was a socket where you only wanted to connect() and see whether there was anything at all on the given port (some P2P server needed it).</font><br>
<p>
It&#x27;s also useful for working around epoll&#x27;s weird ambiguities between file descriptors/file descriptions -- if you get into the situation where your fd table and epoll&#x27;s fd table don&#x27;t match up, then EPOLLONESHOT is the only way to escape infinite wakeup loops:<br>
<p>
<a rel="nofollow" href="https://github.com/python-trio/trio/blob/cb48b33a42b09dde955617f93923ed8f5fa02426/trio/_core/_io_epoll.py#L106">https://github.com/python-trio/trio/blob/cb48b33a42b09dde...</a><br>
<p>
Of course correct code should never hit this case in the first place, but for generic library code that wants to degrade gracefully it&#x27;s very useful.<br>
<p>
It also reduces syscalls if you&#x27;re using epoll to implement a higher-level API that&#x27;s built around issuing read/write operations (like you see with Go/io_uring/IOCP), rather than &quot;register an fd for repeated usage&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/866720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor865542"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2021 6:31 UTC (Sat)
                               by <b>jonas.bonn</b> (subscriber, #47561)
                              [<a href="/Articles/865542/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The true benefit of edge notifications is for _writeability_ notifications. It allows to forego the enable/disable EPOLLWR dance every time a message is enqueued and thus saves a large number of syscalls.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865542/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor865392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2021 23:09 UTC (Thu)
                               by <b>Bigos</b> (subscriber, #96807)
                              [<a href="/Articles/865392/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my current understanding of the kernel workflow, if the Android project uses kernel code from 1.5 years ago and releases it only now it should manage any regressions by itself.<br>
<p>
I understand that such regressions only come into light when the code is used, but this is what the &quot;beta&quot; distributions are about. With such a slow development workflow, we need a testing window in this waterfall scheme. If a piece of code (like a kernel) is updated every year (or more), you will see bugs and regressions each time they are updated.<br>
<p>
What can upstream do about bugs that are filed years after they are produced? They can fix them immediately, but that is already years after they have been introduced. For a downstream that is lagging behind, it is thus their responsibility to deal with this whole situation.<br>
<p>
And then what about the &quot;no regression policy&quot;? This is indeed a difficult question. When the regression is reported so long after it has been introduced it is difficult to measure if reverting to the old behavior is good or not. The policy is about &quot;not breaking userspace&quot;, but there are many &quot;userspace&quot; in parallel that are using the kernel, each using different kernel/userpace combo. The policy makes sense when the userspace is using a recent kernel, but falls apart when the kernel used is so old the upstream forgot about it, but the kernel is &quot;new&quot; for a particular downstream.<br>
<p>
--------------------------------<br>
Wild delusions below...<br>
<p>
For the kernel itself, the policy should thus change, in my opinion. If the downstream doesn&#x27;t want to update the kernel in a &quot;reasonable&quot; timeframe (which would need to be defined), the no-regression-policy should not apply (or rather, not apply universally; not breaking current downstream would take priority over not breaking past downstream). I am just a bystander dreamer, though, understanding that such a thing would be difficult to impose and the benefits might be questionable...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 0:53 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/865405/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In CMake (which largely has the same regression policies except that undocumented or explicitly internal bits are more of a &quot;why are you fiddling around there?&quot; than Linux), the policy is that if the regression is more than a release behind, there&#x27;s not much we can do in the general case. With a lack of a report in a timely manner, there&#x27;s not much to be done as the *new* behavior is also legitimately something that may be depended upon. But, we also have fairly quick uptake in the development distros which help to find issues with builds that are hosted in such projects at least as well (since user testing isn&#x27;t quite as necessary for CMake&#x27;s &quot;did we break something?&quot; detection).<br>
<p>
Basically, test things as much as possible, but if you fall behind, it&#x27;s going to be a tough decision to figure out what is the right behavior going forwards.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865508"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 19:11 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/865508/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; except that undocumented or explicitly internal bits are more of a "why are you fiddling around there?" than Linux</font>

<p>Linux have <b>insane</b> number of unstable interfaces. And if changes to <b>these</b> break apps then no one would even think twice.</p>

<p>But syscalls are sacred. <b>These</b> are fixed in case of regressions religiously. And that's certainly a good thing.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/865508/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor865506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 19:07 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/865506/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>You are <b>almost</b> correct but devil is in details. Let me show you with a change in the quote:</p>

<font class="QuotedText">&gt; In my current understanding of the kernel workflow, if the Android project uses kernel code from 1.5 years ago and releases it only now it should manage any <s>regressions</s> backporting by itself.</font>

<p>And yes, sure. They will.</p>

<font class="QuotedText">&gt; What can upstream do about bugs that are filed years after they are produced?</font>

<p>Fix them? Why is that so hard to understand for some? Regressions are regressions. They have to be fixed if there are real programs used by real users (as in: anything that existed before introduction of regression and not made specifically to show-off that you can write superfragile code which may be broken by any unrelated change in the kernel).</p>

<p>Remember <a href="https://lwn.net/Articles/494993/">that story with autofs</a>? Please pay close attention to that line: <i>automount program from the autofs-tools package, which is still in use on a great many systems, had run into this problem a number of years ago</i>.</p>

<p>Yet it was fixed, because, you know, regressions are regressions.</p>

<font class="QuotedText">&gt; For a downstream that is lagging behind, it is thus their responsibility to deal with this whole situation.</font>

<p>Oh, sure. Of course. After regression is fixed in all supported kernels the job of Linus and kernel developers is done. Backporting these changes to older, already usupported, kernels is not their job.</p>

<p>But it have to be fixed in Linus tree even if it was introduced 10 years ago.</p>

<p>That's the rule and <b>that</b> is why linux is the most popular OS kernel (maybe by now more popular than all others combined on an MMU-equipped devices).</p>

<p>And yes, sometimes it requires quite a dozy solutions to satisfy both apps and libraries developed before regression happened and after. I guess at some point it would just be impossible to support them all. But AFAIK this never happened till now (or, more likely, it happened, but nobody noticed: that old <a href="https://lkml.org/lkml/2010/11/19/359">if nobody notices, it's not broken</a> rule).</p>

<font class="QuotedText">&gt; I am just a bystander dreamer, though, understanding that such a thing would be difficult to impose and the benefits might be questionable...</font>

<p>Depends on who would you ask, obviously. Apple, Google, Microsoft would be delighted by such a decision. Maybe even <a href="https://en.wikipedia.org/wiki/Google_Fuchsia">Fuchsia</a> get a chance. But it's hard to see what this adoption of <a href="https://www.jwz.org/doc/cadt.html">CADT model</a> would bring to Linux.</p>







      
          <div class="CommentReplyButton">
            <form action="/Articles/865506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor866784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 19, 2021 14:45 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/866784/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Fix them? Why is that so hard to understand for some? Regressions are regressions. They have to be fixed if there are real programs used by real users (as in: anything that existed before introduction of regression and not made specifically to show-off that you can write superfragile code which may be broken by any unrelated change in the kernel).</font><br>
<p>
Except when two contradictory behaviors have been in the wild for a while, fixing the regression may be a regression itself. Only time will tell, but if/when it happens, which one will you pick? In that scenario someone will be broken in userspace, inevitably. The wording in what you quoted wasn&#x27;t necessarily the best, but this is the real issue. In fact, the current regression is a bugfix, if we believe the docs, regardless of the &quot;not breaking userspace rule&quot;, an implementation contradicting the documented promise is a bug.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/866784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor865408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 2:05 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/865408/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a potential future user of epoll, it seems &quot;one wakeup per write operation&quot; is the best and cleanest definition for edge-triggered so far. (Assuming, of course, the wake up comes after all the data from the write is available for reading.) Depending on the use case, I would want to use either the newest version of edge-triggered, or level-triggered.<br>
<p>
It doesn&#x27;t seem clear what the benefit of the kernel 5.5 version of edge-triggered would be intended to be, compared to level triggered. How is &quot;there was no data, now there is data&quot; sufficiently different from &quot;there is data&quot;? After reading all the data?<br>
<p>
The documentation in the man page says:<br>
<font class="QuotedText">&gt; edge-triggered mode delivers events only when changes occur on the monitored file descriptor</font><br>
Without knowing the internals of a file descriptor, I would expect that all writes count as a change to the file, not just writes to an empty file. The latter would require additional reasoning and documentation.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 9:30 UTC (Fri)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/865423/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; How is &quot;there was no data, now there is data&quot; sufficiently different from &quot;there is data&quot;?</font><br>
<p>
This was explained upthread: <a href="https://lwn.net/Articles/865404/">https://lwn.net/Articles/865404/</a><br>
<p>
<font class="QuotedText">&gt; After doing some further research, I think the intended use case was &quot;multiple threads call epoll_wait and the kernel dispatches work to them automatically.&quot;</font><br>
<p>
With level-triggered behavior, all events would be dispatched to all threads. Edge-triggered instead behaves as if the event is &quot;consumed&quot; after dispatching.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 13:20 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/865431/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This was explained upthread: <a href="https://lwn.net/Articles/865404/">https://lwn.net/Articles/865404/</a></font><br>
<p>
Actually I already wrote about using it in a multi-thread scenario, in another discussion.<br>
However, such a scenario isn&#x27;t obvious at all and not described in the man page documentation. Not the normal use case.<br>
And it works as intended *only* with the 5.5 version.<br>
<p>
So in my opinion, a bit of a stretch. Even if some might like such a scenario, having a mode that is useful only in such a specific way, would require pointing out such use cases, in order to make sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865468"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 14:18 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/865468/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; With level-triggered behavior, all events would be dispatched to all threads. Edge-triggered instead behaves as if the event is &quot;consumed&quot; after dispatching.</font><br>
<p>
I missed that this is still part of the reply to my post, so I&#x27;m sorry for splitting my response and not responding to the intended meaning at first.<br>
<p>
Are you suggesting that edge-triggered will not wake more than one thread? I can see why you might interpret the comment further above in that way,<br>
but it doesn&#x27;t seem documented in that way, and I also haven&#x27;t noticed any indication in that direction anywhere else. I am not convinced it is actually so, as I would expect that to be a separate option, if it really were an option. (Though perhaps a useful one.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865468/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 14:40 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/865471/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you suggesting that edge-triggered will not wake more than one thread? I can see why you might interpret the comment further above in that way,</font><br>
<font class="QuotedText">&gt; but it doesn&#x27;t seem documented in that way, [...]</font><br>
<p>
Sorry once more, I was too quick. This is actually described by the epoll man page as a special case, at the end:<br>
<p>
<font class="QuotedText">&gt; If multiple threads (or processes, if child processes have</font><br>
<font class="QuotedText">&gt; inherited the epoll file descriptor across fork(2)) are blocked</font><br>
<font class="QuotedText">&gt; in epoll_wait(2) waiting on the same epoll file descriptor and a</font><br>
<font class="QuotedText">&gt; file descriptor in the interest list that is marked for edge-</font><br>
<font class="QuotedText">&gt; triggered (EPOLLET) notification becomes ready, just one of the</font><br>
<font class="QuotedText">&gt; threads (or processes) is awoken from epoll_wait(2).</font><br>
<p>
This behavior seems to apply only in that special case, like an additional option. It is not the general meaning of &quot;edge-triggered&quot;. However certainly an interesting feature. I would hope that it generally applies when multiple threads use the same epoll file descriptor from the same epoll_create, so that it is not limited to forks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor865472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 14:42 UTC (Fri)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/865472/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you suggesting that edge-triggered will not wake more than one thread?</font><br>
<font class="QuotedText">&gt; it doesn&#x27;t seem documented in that way</font><br>
<p>
It&#x27;s documented that way in the current version of the man page at least<br>
<a href="https://manpages.debian.org/testing/manpages/epoll.7.en.html">https://manpages.debian.org/testing/manpages/epoll.7.en.html</a><br>
<p>
<font class="QuotedText">&gt;       If multiple threads (or processes, if child processes have</font><br>
<font class="QuotedText">&gt;       inherited the epoll file descriptor across fork(2)) are blocked</font><br>
<font class="QuotedText">&gt;       in epoll_wait(2) waiting on the same epoll file descriptor and a</font><br>
<font class="QuotedText">&gt;       file descriptor in the interest list that is marked for edge-</font><br>
<font class="QuotedText">&gt;       triggered (EPOLLET) notification becomes ready, just one of the</font><br>
<font class="QuotedText">&gt;       threads (or processes) is awoken from epoll_wait(2).  This</font><br>
<font class="QuotedText">&gt;       provides a useful optimization for avoiding &quot;thundering herd&quot;</font><br>
<font class="QuotedText">&gt;       wake-ups in some scenarios.</font><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 14:49 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/865474/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It&#x27;s documented that way in the current version of the man page at least</font><br>
<p>
Yes, I just realized that and corrected myself in the post just (2 minutes) before yours. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor865429"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 12:07 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/865429/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; it seems &quot;one wakeup per write operation&quot; is the best and cleanest definition for edge-triggered so far.</font><br>
<p>
I can assure you that the notion of &quot;level-triggered&quot; vs &quot;edge-triggered&quot; is universally used between binary states, as it comes from the world of electronics when signals are sampled (clock, interrupts etc). There&#x27;s no such a thing as &quot;raising the signal to strengthen the interrupt&quot;. Either you report the interrupt as long as the signal is high (or low), or you report the interrupt only when it flips (hence the name &quot;edge&quot; because when you see the signal on an oscilloscope, you have an edge there).<br>
<p>
Now the fact that you need it to work differently is another matter and I do think that there&#x27;s a lot of value in plenty of userspace programs for a mechanism that wakes you up each time the conditions change.<br>
<p>
Regardless, the rules for EPOLLET are pretty clear: only EAGAIN will re-arm the notification, so if you do not try to read/write and are reported a state change, you may very well never be aware that a buffer was fully consumed.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865429/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865466"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 13:45 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/865466/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Regardless, the rules for EPOLLET are pretty clear: only EAGAIN will re-arm the notification, ...</font><br>
<p>
How would that be clear as a &quot;rule&quot;?  In the man page linked in the article, which is also referenced up thread, it is just a &quot;suggested way of use&quot;:<br>
<p>
<font class="QuotedText">&gt; The suggested way to use epoll as an edge-triggered (EPOLLET) interface is as follows:</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt;       a) with nonblocking file descriptors; and</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt;       b) by waiting for an event only after read(2) or write(2) return EAGAIN.</font><br>
<p>
However, the best I can tell, if used in this way, &#x27;level-triggered&#x27; would accomplish the same thing, and using &#x27;edge-triggered&#x27; in this scenario seems redundant and pointless.<br>
<p>
It does not say there that EAGAIN is necessary to &quot;re-arm&quot; the notification. Later on, it just says that reading until EAGAIN is necessary to make sure that all the data is read, however that is quite obvious anyway. And nothing else is implied by the example above.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865466/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2021 16:31 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/865710/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s &quot;suggested&quot; in that it&#x27;s an illustration of one way to do it. The crux of this is that you&#x27;re not guaranteed to be notified again until you reach EAGAIN which rearms the event. And that&#x27;s the normal way to deal with edge-triggered signals, it&#x27;s not specific to epoll. Simply see it as a test-and-set on whether or not this requires to be reported. That&#x27;s particularly efficient and does not guarantee that you will not get multiple notifications from other situations but it&#x27;s the right way to make sure events are not reported more often than needed.<br>
<p>
I do remember some old docs back in the 2.5.x days where it was clearly stated that you *had* to maintain your own event cache so that if you can&#x27;t read till EAGAIN you need to know by yourself that you have to try again once possible. And that&#x27;s how highly efficient I/Os are achieved anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865750"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2021 20:12 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/865750/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I do remember some old docs back in the 2.5.x days where it was clearly stated that you *had* to maintain your own event cache so that if you can&#x27;t read till EAGAIN you need to know by yourself that you have to try again once possible.</font><br>
<p>
With edge-triggered, that is still true, since there won&#x27;t necessarily be another write (or not for a long time). So you&#x27;d need a timeout or something (in a single-threaded scenario) and maintain the info that you haven&#x27;t encountered EAGAIN yet (unless you will try to read anyway, for example in certain intervals).<br>
<p>
This makes sense if the fact that data did arrive, and the data itself, are handled at different times; for example if data is usually buffered for some time, but some other action is taken immediately.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865750/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor865491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2021 17:05 UTC (Fri)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865491/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Regardless, the rules for EPOLLET are pretty clear: only EAGAIN will re-arm the notification</font><br>
<p>
Not really, and this is why EPOLLONESHOT was introduced. EPOLLET will re-arm when there is a new write (unless it was done on a pipe on v5-v15) so if you use the same epoll fd in multiple threads with EPOLLET then once thread A have called read and there is a new write, epoll will notify thread B about EPOLLIN on the same fd. EPOLLINESHOT is the only solution to solve this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2021 16:43 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/865714/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not exactly, EPOLLONESHOT is different, it&#x27;s for when you&#x27;re waiting for a single event and do not want to remain subscribed after that. It performs the EPOLL_CTL_DEL automatically for you. A typical example is that you read a request from a client, you get all of it and are not interested in reading whatever happens after until you&#x27;re done processing it, because, maybe you&#x27;ve released the buffer and cannot allocate a new one in this case. Normally you would have to unregister the event. With EPOLLONESHOT you don&#x27;t need, you&#x27;ll get notified exactly once and you will have to subscribe again if needed.<br>
<p>
The problem with pollers is that many users tend to consider them as providing exact guarantees, but they should not, instead a poller must be used as a hint that something happend on an FD, and the reported flags provide more or less accurate indications of the details. For example:<br>
  - the poller returns EPOLLIN but when you try to read you get EAGAIN. Why ? Because you&#x27;re on UDP, the checksum was calculated on the fly during recvmsg(), which figured it was incorrect and destroyed the result.<br>
  - the poller returns the same event multiple times regardless of EPOLLET: there might be different conditions whose precedence cause it to be reported.<br>
  - you&#x27;ve read all the response from an FD, not reached EAGAIN, but you&#x27;re certain based on the sockets you&#x27;re using that you&#x27;ve reached the end. Usually you can consider that you&#x27;ll be called again but there&#x27;s no such guarantee<br>
  - EPOLLHUP and EPOLLRDHUP used to be wrong several times in the past<br>
  - epoll + splice() have done funny things at a time where splice() was quite bogus (before 2.6.25). For example splice() could report EAGAIN if the target was full, thus was not reading the input at all, yet this EAGAIN was irrelevant to the recv condition that was supposed to re-arm the poller.<br>
<p>
The sole purpose of a poller is &quot;only sleep if you&#x27;re absolutely certain you can sleep; in doubt, wake up and notify me&quot;. It&#x27;s not the poller&#x27;s job to be exact about all conditions, it&#x27;s the application&#x27;s. In doubt the poller must wake up. In some cases I&#x27;m pretty sure that even EPOLLET will wake up more often than needed and that must not be a problem for the application.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2021 2:13 UTC (Tue)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865793/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you use it that way they you are leaving behind a larger and larger watch list for epoll. EPOLLONESHOT does not call EPOLL_CTL_DEL automatically for you, it simply marks the fd on the watch list as temporarily disabled after it wakes up.<br>
<p>
It can be used for the scenario that you described but you have to do a manual call to EPOLL_CTL_DEL to really remove the fd from the internal watchlist and remove a potential memory leak.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2021 4:08 UTC (Tue)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/865800/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; EPOLLONESHOT does not call EPOLL_CTL_DEL automatically for you, it simply marks the fd on the watch list as temporarily disabled after it wakes up.</font><br>
<p>
From the epoll(7) man page: &quot;When the EPOLLONESHOT flag is specified, it is the  caller&#x27;s  responsibility to rearm the file descriptor using epoll_ctl(2) with EPOLL_CTL_MOD&quot;.<br>
<p>
You can use it for example to wait for a connect() to complete without having to disable polling on the FD when you don&#x27;t intend to use the connection immediately (e.g. when preparing connection pools).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor865881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The edge-triggered misunderstanding</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2021 16:50 UTC (Tue)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/865881/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, that goes exactly into what I was saying. Re-arming it resets the disabled flag in the internal watchlist. That you have to do this with EPOLL_CTL_MOD and not EPOLL_CTL_ADD should already there tell you that EPOLLONESHOT does not call EPOLL_CTL_DEL automatically.<br>
<p>
So if you use this flag as a way to not have to call EPOLL_CTL_DEL then you have a memory leak (as well as an inefficient watchlist in epoll).<br>
<p>
Not really sure where you are going with this since non of this contradicts what I have written now several times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
