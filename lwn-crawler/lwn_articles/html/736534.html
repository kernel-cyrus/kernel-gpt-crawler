        <!DOCTYPE html>
        <html lang="en">
        <head><title>A block layer introduction part 1: the bio layer [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/736534/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/736913/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/736534/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A block layer introduction part 1: the bio layer</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="GAByline">
           <p>October 25, 2017</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>One of the key values provided by an operating system like Linux is
that it provides abstract interfaces to concrete devices.  Though the
original "character device" and "block device" abstractions have been
supplemented with various others including "network device" and
"bitmap display", the original two have not lost their importance.  The
block device interface, in particular, is still central to managing
persistent storage and, even with the growth of persistent memory, this
central role is likely to remain for some time.  Unpacking and
explaining some of that role is the goal of this pair of articles.</p>

<p>The term "block layer" is often used to talk about that part of the
Linux kernel which implements the interface that applications and
filesystems use to access various storage devices.  Exactly which code
constitutes this layer is a question that reasonable people could
disagree on.  The simplest answer is that it is all the code inside
the <tt>block</tt> subdirectory of the Linux kernel source.  This collection
of code can be seen as providing two layers rather than just one; they are
closely related but clearly distinct.  I know of no generally agreed
names for these sub-layers and so choose to call them the "bio layer"
and the "request layer".  The remainder of this article will take us
down into the former while the latter will be left for a subsequent
article.</p>

<h4>Above the block layer</h4>

<p>Before digging into the bio layer it will be useful to provide
context by describing the parts of Linux that sit just above the
block layer.  "Above" in this sense means closer to user-space (the
top) and further from hardware (the bottom) — it covers the clients
that might use the services provided by the block layer and below.</p>

<blockquote>
<img src="https://static.lwn.net/images/2017/neil-blocklayer.png" 
alt="[Block layer diagram]" class="photo">
</blockquote>


<p>Access to block devices generally happens through block special devices
in <tt>/dev</tt>, which map to <tt>S_IFBLK</tt>
inodes in the kernel.  These inodes act a little bit like symbolic links
in that they don't represent the block device directly but simply contain
a pointer to the block device as a "major:minor" number pair.  Internally
the <tt>i_bdev</tt> field in the inode contains a link to 
a <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/fs.h?h=v4.13#n415"><tt>struct
block_device</tt></a> that represents the target device.  This block
device holds a reference to a second
inode: <tt>block_device-&gt;bd_inode</tt>.  This inode is more closely
involved in I/O to the block device, the original inode in <tt>/dev</tt> is
just a pointer.</p>

<p>The main role that this second inode plays (which is implemented in <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/block_dev.c?h=v4.13"><tt>fs/block_dev.c</tt></a>,
<a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/buffer.c?h=v4.13"><tt>fs/buffer.c</tt></a>,
and elsewhere) is to provide a page cache.  When the device file is opened
without the <tt>O_DIRECT</tt> flag, the page cache associated with the
inode is used to buffer reads, including readahead, and to buffer writes,
usually delaying writes until the normal writeback process flushes them
out.

When <tt>O_DIRECT</tt> is used, reads and writes go directly to the block
device.  Similarly when a filesystem mounts a block device, reads and
writes from the filesystem usually go directly to the device, though
some filesystems (particularly the <tt>ext*</tt> family) can access the same
page cache (traditionally known as the buffer cache in this context)
to manage some of the filesystem data.</p>

<p>Another <tt>open()</tt> flag of particular relevance to block devices is
<tt>O_EXCL</tt>.  Block devices have a simple advisory-locking scheme
whereby each block device can have at most one "holder".  The holder is
specified when activating the block device (e.g. using a <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/block_dev.c?h=v4.13#n1566"><tt>blkdev_get()</tt></a>
or similar call in the kernel); that will fail if a different holder has
already claimed the device.  Filesystems usually specify a holder when
mounting a device to ensure exclusive access.  When an application opens a
block device with <tt>O_EXCL</tt>, that causes the newly created <tt>struct file</tt> to
be used as the holder; the open will fail if a filesystem is mounted
from the device.  If the open is successful, it will block future mount
attempts as long as the device remains open.  Using <tt>O_EXCL</tt> doesn't
prevent the block device from being opened without <tt>O_EXCL</tt>, so
it doesn't prevent concurrent writes completely — it just makes it easy
for applications to test if the block device is in use.</p>

<p>Whichever way a block device is accessed, the primary interface involves
sending read or write requests, or various other requests
such as discard, 
and eventually getting a reply.  This interface is provided by the bio
layer.</p>

<h4>The bio layer</h4>

<p>All block devices in Linux are represented by <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/genhd.h?h=v4.13#n171"><tt>struct
gendisk</tt></a> — a "generic disk".  This structure doesn't contain a
great deal of information and largely serves as a link between the
filesystem interface "above" and the lower-layer interface "below".
Above the gendisk is one or more <tt>struct block_device</tt>, which, as we
already saw, are linked from inodes in <tt>/dev</tt>.  A gendisk can be
associated with multiple <tt>block_device</tt> structures when it has a partition table.
There will be one <tt>block_device</tt> that represents the whole gendisk, and
possibly some others that represent partitions within the
gendisk.</p>

<p>The "bio" that gives its name to the bio layer is a data structure
(<a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/blk_types.h?h=v4.14-rc1#n46"><tt>struct
bio</tt></a>) that carries read and write requests, and assorted other 
control requests, from the <tt>block_device</tt>, past the gendisk, and on
to the driver.  A bio identifies a target device, an offset in the
linear address space of the device, a request (typically READ or
WRITE), a size, and some memory where data will be copied to or from.

Prior to Linux 4.14, the target device would be identified in the bio
by a pointer to the <tt>struct block_device</tt>.  Since <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=74d46992e0d9">then</a> it holds
a pointer to the <tt>struct gendisk</tt> together with a partition number,
which can be set by <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bio.h?h=v4.14-rc1#n505"><tt>bio_set_dev()</tt></a>.  This is more natural given the
central role of the gendisk structure.</p>

<p>Once constructed, a bio is given to the bio layer by calling <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/block/blk-core.c?h=v4.13#n2114"><tt>generic_make_request()</tt></a>
or, equivalently, <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/block/blk-core.c?h=v4.13#n2228"><tt>submit_bio()</tt></a>.
This does not normally wait for the request to complete, but merely queues
it for subsequent handling.  <tt>generic_make_request()</tt> can still
block for short periods of time, to wait for memory to become
available, for example.  A useful way to think about this behavior is that it might wait
for previous requests to complete (e.g. to make room on the queue), but not
for the new request to complete.  If the <tt>REQ_NOWAIT</tt> flag is set in
the <tt>bi_opf</tt> field, <tt>generic_make_request()</tt> shouldn't wait
at all if there is insufficient space and should, instead, cause the bio to
complete with the status set to 
<tt>BLK_STS_AGAIN</tt>, or possibly <tt>BLK_STS_NOTSUPP</tt>.  As of this
writing, this feature is not yet implemented correctly or consistently.</p> 

<p>The interface between the bio layer and request layer requires devices
to register with the bio layer by calling <tt>blk_queue_make_request()</tt>
and passing a <tt>make_request_fn()</tt> function that takes a bio.
<tt>generic_make_request()</tt> will call that function for the device
identified in the bio.  This function must arrange things such that, when
the I/O
request described by the bio completes, the <tt>bi_status</tt> field is set
to indicate success or failure and call <tt>bio_endio()</tt> which, in
turn, will call  the <tt>bi_end_io()</tt> function
stored in the structure.</p>

<p>The two most interesting features of the bio layer, beyond the simple
handling of bio requests already described, are the recursion
avoidance and the queue plugging.</p>

<h4>Recursion avoidance</h4>

<p>It is quite possible for the use of virtual block devices such as "md"
(used for software RAID) and "dm" (used, for example, by LVM2) to
result in a stack of block devices, each of which modifies a bio and
sends it on to the next device in the stack.  A simple implementation
of this would cause a large stack of devices to result in excessive
use of the kernel's call stack.  In the distant past (before Linux
2.6.22) this would sometimes cause problems, particularly when the bio
was submitted by a filesystem that was already using a considerable
amount of the stack.</p>

<p>Instead of allowing this recursion, <tt>generic_make_request()</tt> detects
when it is being called recursively and does <em>not</em> pass the bio down
to the next layer.  Instead it queues the bio internally (using
<tt>current-&gt;bio_list</tt> in the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sched.h?h=v4.13#n519"><tt>struct task_struct</tt></a> for the current
process) and submits it only after the parent bio submission
completes.  As <tt>generic_make_request()</tt> is not expected to wait for
the bio to complete, it is normally safe to not even start processing
immediately.</p>

<p>This recursion avoidance often works perfectly, but it sometimes leads to
deadlocks.  The key to understanding these deadlocks is the observation
made above that submission of a bio (i.e. the <tt>make_request_fn()</tt>
called by <tt>generic_make_request()</tt>) is permitted to wait for
previously submitted bios to complete.  If it waits for a bio that is
still on the <tt>current-&gt;bio_list</tt> queue managed by
<tt>generic_make_request()</tt>, then it will wait forever.</p>

<p>The dependencies that cause one bio to wait for an earlier one are
often subtle and usually found through testing rather than code
inspection.  A simple example involves the occasional need to split
a bio using a <a href="https://lwn.net/Articles/22909/">mempool</a>.  If a bio is submitted to a device that
has limits on the size or alignment of I/O requests,
the <tt>make_request_fn()</tt> might choose to
split the bio into two parts which are handled separately.  The bio
layer provides functions (<a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/block/bio.c?h=v4.13#n1843"><tt>bio_split()</tt></a>
and <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/block/bio.c?h=v4.13#n326"><tt>bio_chain()</tt></a>)
that make
this quite easy to do, but the operation requires that a second bio structure be
allocated.  Allocating memory must be done cautiously in the block
layer since, when there is a shortage of free memory, a key strategy used by
Linux is to write out dirty pages, through the block layer, so they
can then be discarded.  If that write-out needs to wait for memory to
be allocated, it can cause problems.  A standard mechanism is to use a
mempool, which pre-allocates a small amount of memory for a
specific purpose.  Allocating from a mempool may wait for previous
users of the mempool to return the memory they used, but will not wait
for general memory reclaim to finish.  When a mempool is used to
allocate bios, this waiting can introduce the sort of dependency that
can cause <tt>generic_make_request()</tt> to deadlock.</p>

<p>There have been several attempts to provide an easy way to avoid these
deadlocks.  One is embodied in the "<tt>bioset</tt>" processes that you might
see in a <tt>ps</tt> listing.  This mechanism focuses specifically on the
deadlock 
scenario described above and allocates a "rescuer" thread for each
mempool used for allocating bio structures.  If an allocation attempt
cannot be easily satisfied, any bios from the same bioset that are in
the <tt>current-&gt;bio_list</tt> queue are handed to the <tt>bioset</tt> thread for
processing.  This approach is fairly heavy-handed, resulting in the
creation of many threads that are almost never used, and only
addresses one particular deadlock scenario.  Most, if not all, deadlock
scenarios involve splitting bios into two or more parts, but they
don't always involve waiting on mempool allocation.</p>

<p>Recent kernels only depend on this for a few isolated cases and
generally avoid creating the <tt>bioset</tt> thread when it isn't needed.
Instead, an alternate approach, which was <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=79bd99596b7305">introduced</a> by changes to
<tt>generic_make_request()</tt> in Linux 4.11, is
used.  It is more general and imposes less overhead on a running system, but
instead places requirements on how drivers are written.</p>

<p>The main requirement is that when a bio is split, one of the halves
should be submitted directly to <tt>generic_make_request()</tt> so that it
can be handled at the most appropriate time.  The other half may be
processed in whatever way is appropriate.  This gives
<tt>generic_make_request()</tt> a little more control over what happens.  It
makes use of this control by sorting all the bios based on how deep in
the device stack they were submitted.  It then always handles bios
destined for lower devices before upper devices.  This simple
expedient removes all the annoying deadlocks.</p>

<h4>Device queue plugging</h4>

<p>Storage devices often have significant per-request overheads, so it
can be more efficient to gather a batch of requests together and
submit them as a unit.  When the device is relatively slow it will
often have a large queue of pending requests and that queue provides
plenty of opportunity for identifying suitable batches.  When a device
is quite fast, or when a slow device is idle, there is less
opportunity to find batches naturally.  To address this challenge,
the Linux block layer has a concept called "plugging".</p>

<p>Originally, plugging applied only to an empty queue.  Before
submitting a request to an empty queue, the queue would be plugged so
that no requests could flow through to the underlying device for a while.
Bios submitted by the 
filesystem could then queue up and allow batches to be identified.  The
queue would be unplugged explicitly by the filesystem requesting it, or
implicitly after a short timeout.  It is hoped that by this time some
suitable batches would have been found and that the small delay in starting
work is more than compensated for by the larger batches that are ultimately
submitted.  Since Linux 2.6.39 a <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=73c101011926c58">new
plugging mechanism</a> has been in place that works on a per-process basis
rather than per-device.  This scales better on multi-CPU machines.</p>

<p>When a filesystem or other client of a block device submits requests it
will normally bracket a collection of <tt>generic_make_request()</tt> calls
with <tt>blk_start_plug()</tt> and <tt>blk_finish_plug()</tt>.  This sets
up <tt>current-&gt;plug</tt> to point to a <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/blkdev.h?h=v4.13#n1258">data
structure</a> that can contain a list of <tt>struct blk_plug_cb</tt> (and
also a list of <tt>struct request</tt> that we find out more about in the
next article).  As these lists are per-process, entries can be added without any
locking.  The <tt>make_request_fn</tt> that is given individual bios can
choose to add the bio to a list in the plug if that might allow it to work
more efficiently.</p>

<p>When <tt>blk_finish_plug()</tt> is called, or whenever the process calls
<tt>schedule()</tt> (such as when waiting for a mutex, or when waiting for
memory allocation), each entry stored in <tt>current-&gt;plug</tt> is processed.
This processing will complete everything that the driver would have
done if it had not decided to add the bio to the plug list, or if no
plug has been enabled.</p>

<p>The fact that the plug is processed from <tt>schedule()</tt> calls means that
bios are only delayed while new bios are being produced.  If the
process blocks to wait for anything, the list assembled so far is
processed immediately.  This protects against the possibility that the
process might be waiting for a bio that has already been submitted,
but is currently queued behind the plug.</p>

<p>Performing the plugging at the process level like this maintains the
benefit that batches of related bios are easy to detect and keep
together, and adds the benefit that locking can be reduced.  Without
this per-process plugging a spinlock, or at least an atomic
memory operation, would be needed to handle every individual bio.  With
per-process plugging, it is often possible to create a per-process list
of bios, and then take the spinlock just once to merge them all into
the common queue.</p>

<h4>Bio and below</h4>

<p>In summary, the bio layer is a thin layer that takes I/O requests in
the form of bio structures and passes them directly to the
appropriate <tt>make_request_fn()</tt> function.  It provides various
support functions to simplify splitting bios and scheduling the sub-bios,
and to allow plugging of the queue.  It also performs some other simple
tasks such as updating the <tt>pgpgin</tt> and <tt>pgpgout</tt> statistics
in <tt>/proc/vmstat</tt>, but mostly it just lets the next level down get
on with its work.</p>

<p>Sometimes the next layer is just the final driver, as with <tt>drbd</tt>
(The Distributed Replicated Block Device) or <tt>brd</tt> (a RAM based
block device).  More often the next layer is an intermediate layer such as
for the virtual devices provided by <tt>md</tt> and <tt>dm</tt>.  Probably
the most common is when that intermediate layer is the remainder of the block
layer, which I have chosen to call the "request layer".  Some of the
intricacies of this layer will be the topic of <a
href="/Articles/738449/">the second part of this 
overview</a>.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer">Block layer</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/736534/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor737369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2017 9:55 UTC (Wed)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/737369/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Jon ,I think little change is needed in this line ..<br>
<p>
"The remainder if this article will take us down into the former while the latter will be left for a subsequent article."<br>
<p>
Should be :<br>
<p>
"The remainder of this article will take us down into the former while the latter will be left for a subsequent article."<br>
<p>
Diff if&gt;&gt;of<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2017 10:30 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/737372/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Fixed, thanks.
<p>
For future reference, this sort of typo report is best sent via email so that readers don't need to plow through them.
      
          <div class="CommentReplyButton">
            <form action="/Articles/737372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2017 10:53 UTC (Wed)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/737375/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure. Will follow.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor737373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2017 10:42 UTC (Wed)
                               by <b>javigon</b> (guest, #99358)
                              [<a href="/Articles/737373/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On recursion avoidance, would be relevant to mention direct_make_request, which is being pushed by Christoph ("block: provide a direct_make_request helper").<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor737416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2017 19:12 UTC (Wed)
                               by <b>edos</b> (guest, #116377)
                              [<a href="/Articles/737416/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I didn't get completely about deadlock in the article.<br>
How is that possible when we have stacked block devices to produce a deadlock based on interdependency? It is not clear for me still<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2017 21:34 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/737426/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A simple, though extremely unlikely, scenario that could cause a deadlock is:<br>
- Suppose I have a RAID1 array where each of the member devices is a RAID0 array with a 4K chunk size.<br>
- An 8K write BIO arrives for the RAID1 array.  raid1 code allocates two bios from a private pool and sends an 8K bio to each of the RAID0 devices.  These two bios gets queued by generic_make_request.<br>
- Then generic_make_request starts processing the first RAID0 bio.  raid0 code needs to split it into 2 4K bios and so allocates a bio from a private pool and submits the new bio and the old bio (now reduced in size) to the underlying devices.  These two bios get queued by generic_make_request.<br>
- Then generic_make_request starts processing the second RAID0 bio (newer code will have sorted this to the end of the list, to help avoid the deadlock).  Again raid0 code needs to split the bio.<br>
<p>
Now, suppose there is no free memory, suppose the private mempool has 16 preallocated entries, and suppose 16 threads all perform exactly this 8K write submission (to different addresses in the RAID1) at the same time.<br>
We will end up with 16 threads all trying to allocate a second bio from the same private pool, while the 16 preallocated entries are each trapped, one per thread, in the generic_make_request queue.  The allocations will wait for a previously allocated bio to complete, and those previous bios won't be processed by generic_make_request() until after the allocation completes.<br>
<p>
There are other scenarios that are more complex, but are likely enough to actually happen in practice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2017 22:03 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/737428/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've been looking at the bio layer and I'm wondering if BIO can have a "limp along" mode where it stops all threads and does synchronous submission from one thread? It then can either use a "last reserve" mempool or unsplit pending BIOs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737437"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2017 4:03 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/737437/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What would be the purpose, or value, of this "limp along" mode.  I don't understand...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737437/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2017 4:06 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/737439/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Crawl out of the out-of-memory situation to resolve the deadlock. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2017 5:57 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/737447/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Crawl out of the out-of-memory situation to resolve the deadlock. </font><br>
<p>
Surely it is better to design the code to be dead-lock free.  It isn't that hard once the problem is understood. (and if the problem isn't understood, then a workaround like that might not be a complete solution).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2017 6:04 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/737448/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm confused. Can the abovementioned scenario deadlock with the current bio layer?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737568"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2017 2:01 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/737568/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Can the abovementioned scenario deadlock with the current bio layer?</font><br>
<p>
No, hence the parenthetical comment (newer code will have sorted this to the end of the list, to help avoid the deadlock).<br>
Providing drivers which split bios only process one of them and submit the other directly to generic_make_request(), there should be no deadlock (of this sort).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737568/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor737473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2017 8:49 UTC (Thu)
                               by <b>edos</b> (guest, #116377)
                              [<a href="/Articles/737473/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice example, thank you!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor737588"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2017 10:18 UTC (Fri)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/737588/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I somehow dislike current block level in Linux.<br>
<p>
Many years ago I found an easily reproducible bug within linux kernel. It requires just a two SATA drives pugged together into SAS enclosure and connected to LSI HBA (Pretty common configuration for many servers).<br>
<p>
I found that a very simple shell script (3 lines, literally) can cause whole enclosure of disks to become unresponsive. This script is available here: <a href="https://github.com/amarao/lsi-sata-fuckup">https://github.com/amarao/lsi-sata-fuckup</a><br>
<p>
I reported it to upstream bugzilla (<a href="https://bugzilla.kernel.org/show_bug.cgi?id=98121">https://bugzilla.kernel.org/show_bug.cgi?id=98121</a> for some other special case), I reported it to LSI. No fixes or reaction insofar (5 years!).<br>
<p>
One may think that this is 'one driver issue'. May be.  But I found that other parts of kernel handle this situation really badly. If one device become 'dead' (unresponsive), any process accessing it falls into 'D' state (TASK_UNINTERRUPTIBLE) and it couldn't be terminated (even with kill -9) until server reboot. Moreover, it couldn't be even 'Ctrl-Z' or SIGSTOP'ed, locking console forever.<br>
<p>
Why? Why no one care about such grossly inadequate behavior?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737588/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor737655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2017 4:56 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/737655/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
 the problem you describe here is not directly related to the block layer.  It is probably a driver bug, possible a SCSI-layer bug, but definitely not a block-layer problem.<br>
Reporting bugs against Linux is, unfortunately, a bit of a hit-and-miss affair.  Some developers refused to touch bugzilla, some love it, and some (like me) only use it begrudgingly.<br>
The alternative is to send email.  For that you need to choose the right list and maybe  the right developer, and you need to catch them when they are in a good mood or aren't too busy or not on holidays.  Some people will make an effort to respond to everything, others are completely unpredictable - and that is for me who usually sends a patch with any bug report.  If you just have a bug that you barely understand yourself, your expected response rate is probably lower.  Sad, but true.<br>
<p>
Lots of bugs do get responded to and dealt with, but lots do not.<br>
<p>
I don't think it is fair to say that nobody cares, but it probably is true that nobody sees it as being as important as you do.  If you want a solution, then you need to drive it.  One way to drive it is to spend money on a consultant or with a support contract from a distributor.  I suspect that isn't possible in your situation.  Another way is to learn how the code works and find a solution yourself.  Lots of people do that, but again it might not be an option for you.  Another way is to keep raising the issue on different relevant forums until you get a response.  Persistence can bear fruit.  You would need to be prepared to perform whatever testing is asked of you, possibly including building a new kernel to test.<br>
<p>
If you are able to reproduce this problem on a recent kernel (4.12 or later) I suggest that you email a report to<br>
linux-kernel@vger.kernel.org, linux-scsi@vger.kernel.org, and me (neilb@suse.com) (note that you do not need to subscribe to these lists to send mail, just send it).  Describe the hardware and how to trigger the problem.<br>
Include the stack trace of any process in "D" state.  You can get this with<br>
  cat /proc/$PID/stack<br>
where "$PID" is the pid of the process.<br>
<p>
Be sure to avoid complaining or saying how this has been broken for years and how it is grossly inadequate.  Nobody cares about that.  We do care about bugs and generally want to fix them.  So just report the relevant facts.<br>
Try to include all facts in the mail rather than via links to somewhere else.  Sometimes links are necessary, but in the case of your script, it is 8 lines long so just include it in the email (and avoid descriptions like "fuckup"; just call it "broken" or similar).  Also make sure your email isn't sent as HTML.  We like just plain text.  HTML is rejected by all @vger.kernel.org mailing lists.  You might need to configure your email program to not send HTML.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor737710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A block layer introduction part 1: the bio layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2017 15:19 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/737710/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If one device become 'dead' (unresponsive), any process accessing it falls into 'D' state (TASK_UNINTERRUPTIBLE) and it couldn't be terminated (even with kill -9) until server reboot. Moreover, it couldn't be even 'Ctrl-Z' or SIGSTOP'ed, locking console forever.</font><br>
<p>
This is heritage from traditional Unix.  About 10 years ago, Linux added a new state -- TASK_KILLABLE.  Of course, it takes a long time to go through and change all the UNINTERRUPTIBLE sleeps into KILLABLE sleeps.  Every time you want to do that, you need to add error handling and back out of the operation appropriately.  It's really hard.  It requires a lot of knowledge of the code you're changing and a lot of thinking about what might have gone wrong in order for this operation to have failed and what the appropriate response is.  Some people have done sterling work to make tasks more killable, but the work will probably never be completed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/737710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
