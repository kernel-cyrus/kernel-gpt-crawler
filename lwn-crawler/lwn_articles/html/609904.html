        <!DOCTYPE html>
        <html lang="en">
        <head><title>The RCU API, 2014 Edition [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/609904/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/609799/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/609904/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The RCU API, 2014 Edition</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="GAByline">
           <p>September 4, 2014</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<p>Read-copy update (RCU) is a synchronization mechanism that was added to
the Linux kernel in October&nbsp;2002.
RCU is most frequently described as a replacement for reader-writer locking,
but has also been used in a number of other ways.
RCU is notable in that RCU readers do not directly synchronize with
RCU updaters,
which makes RCU read paths extremely fast, and also
permits readers to accomplish useful work even
when running concurrently with updaters.

</p><p>Although the basic idea behind RCU has not changed in
the decades following its introduction into DYNIX/ptx in 1993, the RCU API has
evolved significantly even over the nearly four years since a
<a href="/Articles/418853/">2010 article covering the RCU API</a>,
most recently due to software-engineering concerns.
This evolution is documented by the following sections.

</p><ol>
<li>	<a href="#Summary of RCU API Additions">
	Summary of RCU API additions</a>
</li><li>	<a href="#RCU%20has%20a%20Family%20of%20Wait-to-Finish%20and%20Data-Access%20APIs">
	RCU has a family of wait-to-finish and data-access APIs</a>
</li><li>	<a href="#RCU%20has%20List-Based%20Publish-Subscribe%20and%20Version-Maintenance%20APIs">
	RCU has list-based publish-subscribe and version-maintenance APIs</a>
</li><li>	<a href="#Kernel Configuration Parameters">
	Kernel configuration parameters</a>
</li><li>	<a href="#How Did Those 2010 Predictions Turn Out?">
	How did those 2010 predictions turn out?</a>
</li><li>	<a href="#What Next for the RCU API?">
	What next for the RCU API?</a>
</li></ol>

<p>These sections are followed by
<a href="#Answers%20to%20Quick%20Quizzes">answers to the Quick Quizzes</a>.

</p><h4><a name="Summary of RCU API Additions">
Summary of RCU API additions</a></h4>

<div class="tlr">
<p><a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
Why is extreme caution required for <code>call_srcu()</code>
and <code>srcu_barrier()</code>?
<br><a href="#qq1answer">Answer</a>
</div>

<p>The largest change to the RCU API since
2010
has been to SRCU (Sleepable RCU), which was reimplemented from scratch by
Peter Zijlstra, myself, and finally by Lai Jiangshan.
The new implementation offers much lower-latency grace periods
(which was important for KVM),
and, unlike other RCU implementations, allows readers in the
idle loop and even in offline CPUs.
In addition, this new SRCU implementation provides the full RCU API,
including the <code>call_srcu()</code> and <code>srcu_barrier()</code>
functions that were omitted from the previous version.
That said, these new APIs should be used with extreme caution.

<p>Another important addition is <code>kfree_rcu()</code>, which
allows &ldquo;fire and forget&rdquo; freeing of RCU-protected data.
Given a structure <tt>p</tt> with an <code>rcu_head</code> field imaginatively
named <code>rh</code>, you can now
free a structure pointed to by <code>p</code> as follows:

<blockquote>
	<code>kfree_rcu(p, rh);</code>
</blockquote>

<p>Before <code>kfree_rcu()</code> was available, something like this
was instead required:

<blockquote>
<pre>
static void free_by_callback(struct rcu_head *rhp)
{
	struct foo *p = container_of(rhp, struct foo, rh);

	kfree(p);
}

...

	call_rcu(&amp;p-&gt;rh, free_by_callback);
</pre>
</blockquote>

<div class="tlr">
<p><a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
If <code>kfree_rcu()</code> is so popular, why isn't there a
<code>kfree_rcu_bh()</code>, <code>kfree_rcu_sched()</code>, or
<code>kfree_srcu()</code>?
For that matter, why not a <code>kmem_cache_free_rcu()</code>?
<br><a href="#qq2answer">Answer</a>
</div>

<p>The use of <code>kfree_rcu()</code> therefore saves a bit of code,
so that this API now has almost 200 uses in the Linux kernel.
Equally important, if your loadable module uses <code>call_rcu()</code>,
you will need to use <code>rcu_barrier()</code> at module-unload time,
as described
<a href="/Articles/217484/">here</a>.
If you can convert all of your module's <code>call_rcu()</code>
invocations to <code>kfree_rcu()</code>, then the <code>rcu_barrier()</code>
is not needed.

<p>A new bitlocked linked list (<code>hlist_bl_head</code> and
<code>hlist_bl_node</code>) was added. 
The bitlocked linked list is useful when you need a lock
	associated with each linked list, but memory pressures
	prohibit associating a spinlock_t with each list.  As the
	name suggests, a bitlocked linked list reduces the size of
	the lock down to a single bit that is placed in the low-order
	bit of a pre-existing pointer.
Bitlocked linked lists required the RCU-safe
accessors
<code>hlist_bl_for_each_entry_rcu()</code>,
<code>hlist_bl_first_rcu()</code>,
<code>hlist_bl_add_head_rcu()</code>,
<code>hlist_bl_del_rcu()</code>,
<code>hlist_bl_del_init_rcu()</code>, and
<code>hlist_bl_set_first_rcu()</code>.

<p>Performance issues in networking led to the addition of
<code>RCU_INIT_POINTER()</code>, which can be used in place of
<code>rcu_assign_pointer()</code> in a few special cases, and that
omits <code>rcu_assign_pointer()</code>'s barrier and volatile cast.
Ugly-code issues led to the addition of
<code>RCU_POINTER_INITIALIZER()</code>, which may be used to initialize
RCU-protected pointers in structures at compile time.

<p>The <code>rcu_access_index()</code> primitive was requested
as a RCU-protected-index counterpart to <code>rcu_access_pointer()</code>
for integers used as array indexes.
The <code>rcu_access_index()</code> and <code>rcu_access_pointer()</code>
functions may be used in cases where the index or pointer will not be
dereferenced; for example, when it is just being compared.
Therefore, <code>rcu_access_index()</code> and <code>rcu_access_pointer()</code>
need not use <code>smp_read_barrier_depends()</code>, however, given
that <code>smp_read_barrier_depends()</code> is free on most platforms,
this is not much of a motivation.
The motivation instead is that these primitives can be safely used outside
of RCU read-side critical sections, thus avoiding the need to worry
about lockdep-RCU complaints.

<p>The <code>rcu_dereference_raw_notrace()</code>,
<code>rcu_is_watching()</code>, and
<code>hlist_for_each_entry_rcu_notrace()</code> primitives
were needed for special cases in the tracing code.
The motivation here is that the tracing code uses RCU, but also needs
to be able to trace RCU's primitives.
Providing these <code>_notrace</code> variants allows the tracing
implementation to more easily avoid self-recursion.

<p>Lower-level list APIs for stepwise traversal of RCU-protected lists
were added:
<code>list_first_or_null_rcu()</code>,
<code>list_next_rcu()</code>,
<code>hlist_first_rcu()</code>,
<code>hlist_next_rcu()</code>,
<code>hlist_pprev_rcu()</code>,
<code>hlist_nulls_first_rcu()</code>, and
<code>hlist_nulls_next_rcu()</code>.
In addition, the hlist-nulls primitive
<code>hlist_nulls_del_init_rcu()</code>
was added as as counterpart to the hlist
<code>hlist_del_init_rcu()</code> primitive.

<p>The <code>rcu_lockdep_assert()</code> primitive allows functions
to insist that they be invoked within the specified RCU and locking
contexts:
Experience indicates that RCU-lockdep splats get the prompt attention
required to ensure that such functions are called in the required
environment.

<p>Finally, <code>RCU_NONIDLE()</code> may be used to protect
RCU read-side critical sections in idle loops, which would otherwise
be illegal.
<code>RCU_NONIDLE()</code> is not used much because almost all the
idle-loop uses of RCU are due to tracing, which supplies a trace
functions with an <code>_rcuidle</code> suffix for idle-loop use.
However, non-tracing uses of RCU within the idle loop should use
<code>RCU_NONIDLE()</code>.
There is some discussion of restricting the region of idle-loop code
that RCU considers to be idle, and if this region becomes small
enough, it might be possible to dispense with both
<code>RCU_NONIDLE()</code> and the <code>_rcuidle</code> suffix.

<p>The next sections discuss aspects of the RCU API, highlighting
recent changes.
</p>

<h4><a name="RCU has a Family of Wait-to-Finish and Data-Access APIs">
RCU has a family of wait-to-finish and data-access APIs</a></h4>

<p>The most straightforward answer to &ldquo;what is RCU?&rdquo; is that RCU is
an API used in the Linux kernel, as summarized by <a
href="/Articles/609973/#RCU Per-Flavor API Table">the big API table</a>
and the following discussion.
Or, more precisely, RCU is a four-member family of APIs as shown
in the table,
with four columns that correspond to each of the family members and
the last column containing generic APIs that apply across families.

</p><p>If you are new to RCU, you might consider focusing on just one
of the columns in the big RCU API table.
For example, if you are primarily interested in understanding how RCU
is most frequently used in the Linux kernel, &ldquo;RCU&rdquo;
would be the place to start.
On the other hand, if you want to understand RCU for its own sake,
&ldquo;SRCU&rdquo; has the simplest API.
In both cases, you will need to refer to the final &ldquo;Generic&rdquo;
column.
You can always come back to the other columns later.
If you are already familiar with RCU, this table can
serve as a useful reference.

</p><p>The green-colored RCU API members are those that
existed back in the 1990s, a time when I was under the delusion
that I knew all that there is to know about RCU.
The blue-colored cells correspond to the RCU API members that are new
since the
2010 RCU API documentation
came out.

</p><p>The &ldquo;RCU&rdquo; column corresponds to the
original RCU implementation,
in which RCU read-side critical sections are delimited by
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>, which
may be nested.
RCU-protected data is accessed using <code>rcu_dereference()</code> and
<code>rcu_dereference_check()</code>, with the former used
within RCU read-side critical sections and the latter used by code
shared between readers and updaters.
In both cases, the pointers must be C-language lvalues.
These read-side APIs are lightweight, although the
two data-access APIs must
<a href="http://www.openvms.compaq.com/wizard/wiz_2637.html">execute a memory barrier on DEC Alpha</a>.
RCU's performance and scalability advantages stem from the lightweight
nature of these read-side APIs.

</p><p>The corresponding synchronous update-side primitives,
<code>synchronize_rcu()</code>, along with its synonym,
<code>synchronize_net()</code>, wait for any currently executing
RCU read-side critical sections to complete.
The length of this wait is known as a &ldquo;grace period&rdquo;.
If grace periods are too long for you, <code>synchronize_rcu_expedited()</code>
speeds things up by about an order of magnitude, but at the expense of
significant CPU overhead and of latency spikes on all CPUs, even the
CPUs that are currently idle.

<p>
The asynchronous update-side primitive, <code>call_rcu()</code>,
invokes a specified function with a specified argument after a
subsequent grace period.
For example, <code>call_rcu(p,f);</code> will result in
the &ldquo;RCU callback&rdquo; <code>f(p)</code>
being invoked after a subsequent grace period.
There are situations,

such as when unloading a module that uses <code>call_rcu()</code>,
when it is necessary to wait for all
outstanding RCU callbacks to complete.
The <code>rcu_barrier()</code> primitive does this job.
The <code>kfree_rcu()</code> primitive serves as a shortcut for
an RCU callback that does nothing but free the structure passed to it.
Use of <code>kfree_rcu()</code> can both simplify code and
reduce the need for <code>rcu_barrier()</code>.
Finally, the <code>rcu_read_lock_held()</code> may be used in assertions
and lockdep expressions to verify that RCU read-side protection is
in fact being provided.
This primitive is conservative, and thus can produce false negatives,
particularly in kernels built with <code>CONFIG_PROVE_RCU=n</code>.

</p><p>The &ldquo;RCU BH&rdquo; column contains the RCU-bh primitives.
	RCU-bh differs from RCU in that RCU-bh read-side
	critical sections (<code>rcu_read_lock_bh()</code> and
	<code>rcu_read_unlock_bh()</code>) disable bottom-half (i.e.
	softirq) processing.  RCU-bh also features somewhat lower-latency
	grace periods in CONFIG_PREEMPT=n kernels due to the fact that any
	point in the code where bottom halves are enabled is an RCU-bh
	quiescent state.  The overall effect is that RCU-bh trades off
	slightly increased read-side overhead to gain shorter and more
	predictable grace periods.  These shorter grace periods allow
	the system to avoid out-of-memory (OOM) conditions in the face
	of network-based denial-of-service attacks.

<div class="tlr">
<p><a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
What happens if you mix and match RCU and RCU-Sched?
<br><a href="#qq3answer">Answer</a>
</div>

</p><p>In the &ldquo;RCU Sched&rdquo; column, anything that disables preemption acts as an RCU read-side critical section, however,
<code>rcu_read_lock_sched()</code> and <code>rcu_read_unlock_sched()</code>
are the official read-side primitives.
Other than that, the RCU-sched primitives are analogous to their RCU
counterparts, though, again, RCU-sched lacks a counterpart to
<code>synchronize_net()</code> and <code>kfree_rcu()</code>.
This RCU API family was added in the 2.6.12 kernel, which split the
old <code>synchronize_kernel()</code> API into the current
<code>synchronize_rcu()</code> (for RCU) and
<code>synchronize_sched()</code> (for RCU Sched).
There are also <code>call_rcu_sched()</code>,
<code>synchronize_sched_expedited()</code>, and
<code>rcu_barrier_sched()</code> primitives, which are analogous to their
&ldquo;RCU&rdquo; counterparts.

<div class="tlr">
<p><a name="Quick Quiz 4"><b>Quick Quiz 4</b>:</a>
Can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?
If so, why?  If not, why not?
<br><a href="#qq4answer">Answer</a>
</div>

</p><p>The "SRCU" column displays a specialized RCU API that permits
general sleeping in RCU read-side critical sections, as was
described in the LWN article
&ldquo;<a href="/Articles/202847/">Sleepable RCU</a>&rdquo;.
SRCU is also the only RCU flavor whose read-side primitives may
be freely invoked from the idle loop and from offline CPUs.
Of course,
use of <code>synchronize_srcu()</code> in an SRCU read-side
critical section can result in
self-deadlock, so it should be avoided.
SRCU differs from earlier RCU implementations in that the caller
allocates an <code>srcu_struct</code> for each distinct SRCU
usage, which must either be statically allocated using
<code>DEFINE_SRCU()</code> or be initialized after dynamic allocation
using <code>init_srcu_struct()</code>.

<div class="tlrw" style="width: 55%;">
<p><a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Why isn't there an
<code>smp_mb__after_rcu_read_unlock()</code>,
<code>smp_mb__after_rcu_bh_read_unlock()</code>, or
<code>smp_mb__after_rcu_sched_read_unlock()</code>?
<br><a href="#qq5answer">Answer</a>
</div>

This approach prevents SRCU read-side critical sections from blocking
unrelated <code>synchronize_srcu()</code> invocations.
In addition, in this variant of RCU, <code>srcu_read_lock()</code>
returns a value that must be passed into the corresponding
<code>srcu_read_unlock()</code>.

There is also an <code>smp_mb__after_srcu_read_unlock()</code>
that, when combined with an immediately prior <code>srcu_read_unlock()</code>,
provides a full memory barrier.
Finally, as with RCU-bh and RCU-sched, there is no counterpart to
RCU's <code>synchronize_net()</code> and <code>kfree_rcu()</code> primitives.</p>

</p><p>The final column contains a few additional RCU APIs that apply
equally to all four flavors.

</p><p>The following primitives do initialization:

<ul class="spacylist">
<li>	<code>RCU_INIT_POINTER()</code> may be used instead of
	<code>rcu_assign_pointer()</code> to assign a value to an RCU-protected
	pointer in a few special cases where reordering from both the
	compiler and the CPU can be tolerated.
	These special cases are as follows:
<p>
	<ul>
	<li>	You are assigning <code>NULL</code> to the pointer, or
	<li>	You have prevented RCU readers from accessing the
		pointer, for example, during initialization when
		RCU readers do not yet have a path to the pointer
		in question, or
	<li>	The pointed-to data structure whose pointer is being
		assigned has already been exposed to readers, and
<p>
		<ul>
		<li>	You have not made any reader-visible changes
			to the pointed-to data structure since then, or
		<li>	It is OK for readers to see the old state of
			the structure.
		</ul>
		An example of this third case is when removing an element
		from an RCU-protected linked list, in which case that
		element's successor has already been exposed to readers.
	</ul>
<li>	<code>RCU_POINTER_INITIALIZER()</code> is used for compile-time
	initialization of RCU-protected pointers within a structure.
</ul>

<p>The following primitives access RCU-protected data:

<ul class="spacylist">
<li>	<code>rcu_access_index()</code> fetches an RCU-protected
	index in cases where ordering is not required, for example,
	when the only use of the value fetched is for a comparison.
<li>	<code>rcu_access_pointer()</code> fetches an RCU-protected
	pointer in cases where ordering is not required.
	This primitive may be used instead of one of the
	<code>rcu_dereference()</code> group of primitives when
	only the value of the RCU-protected pointer is used without
	being dereferenced; for example, the RCU-protected pointer
	might simply be compared against <code>NULL</code>.
	There is, therefore, no need to protect against concurrent
	updates, and there is also no need to be under the protection
	of <code>rcu_read_lock()</code> and friends.
<li>	<code>rcu_dereference_index_check()</code> fetches an
	RCU-protected index, and takes a lockdep expression identifying
	the locks and types of RCU that protect the access.
	Unfortunately, this primitive also disables sparse-based checking,
	so it is possible that this primitive will be deprecated in the
	future; any remaining uses should shift from using indexes to the
	equivalent pointers.
	(So if you know of an RCU-protected index that cannot be easily
	converted to an RCU-protected pointer, this would be a really
	good time to speak up.)
<li>	<code>rcu_dereference_protected()</code> is used to
	access RCU-protected pointers from update-side code.
	Because the update-side code is using some other synchronization
	mechanism (locks, atomic operations, single updater thread,
	etc.), it does not need to put RCU read-side protections in
	place.
	This primitive also takes a lockdep expression that can be
	used to assert that the right locks are held and that any
	other necessary conditions hold.
<li>	<code>rcu_dereference_raw()</code> disables lockdep checking,
	which allows it to be used in cases where the lockdep correctness
	condition cannot be expressed in a reasonably simple way.
	For example, the RCU list macros might be protected by any
	combination of RCU flavors and locks, so they use
	<code>rcu_dereference_raw()</code>.
	That said, some <code>_bh</code> list-macro variants have
	appeared, so it is possible that lockdep-enabled variants
	of these macros will appear in the future.
	However, where you use <code>rcu_dereference_raw()</code>,
	please include a comment saying why its use is safe and
	why other forms of <code>rcu_dereference()</code>
	cannot be used.
<li>	<code>rcu_dereference_raw_notrace()</code> is similar to
	<code>rcu_dereference_raw()</code>, but additionally
	disables function tracing.
</ul>

<p>The following primitive updates RCU-protected data:

<ul class="spacylist">
<li>	<code>rcu_assign_pointer()</code> acts like an assignment statement,
	but does debug checking and enforces ordering on both compiler
	and CPU as needed.
</ul>

<p>Finally, the following primitives do validation:

<ul class="spacylist">
<li>	<code>__rcu</code> is used to tag RCU-protected pointers, allowing
	<code>sparse</code> to check for misuse of such pointers.
<li>	<code>init_rcu_head_on_stack()</code> initializes an on-stack
	<code>rcu_struct</code> structure for debug-objects use.
	The debug-objects subsystem checks for memory-allocation
	usage bugs, for example, double-<code>kfree()</code>.
	If the kernel is built with
	<code>CONFIG_DEBUG_OBJECTS_RCU_HEAD=y</code>,
	this checking is extended to double <code>call_rcu()</code>.
	Although debug-objects automatically sets up its state for
	global variables and heap memory, explicit setup is required
	for on-stack variables, hence the
	<code>init_rcu_head_on_stack()</code>.
<li>	<code>destroy_rcu_head_on_stack()</code> must be used on
	any on-stack variable passed to
	<code>init_rcu_head_on_stack()</code> before returning
	from the function containing that on-stack variable.
<li>	<code>init_rcu_head()</code> and
	<code>destroy_rcu_head()</code> also initialize objects for
	debug-objects use.
	These are normally not needed because the first call to 
	<code>call_rcu()</code> will implicitly set up debug-objects
	state for non-stack memory.
	However, if that <code>call_rcu()</code> occurs in the memory
	allocator or in some other function used by debug-objects,
	this implicit <code>call_rcu()</code>-time invocation can
	result in deadlock.
	Functions called by debug-objects that also use <code>call_rcu()</code>
	should therefore manually invoke <code>debug_init_rcu_head()</code>
	during initialization in order to break such deadlocks.
<li>	<code>rcu_is_watching()</code> checks to see if the
	current code may legally contain RCU read-side critical
	sections.
	Examples of places where RCU read-side critical sections
	are <i>not</i> legal include the idle loop (but see
	<code>RCU_NONIDLE()</code> below) and offline CPUs.
	Note that SRCU read-side critical sections are legal
	anywhere, including in the idle loop and from offline CPUs.
<li>	<code>rcu_lockdep_assert()</code> is used to verify that
	the code has the needed protection.
	For example:
<pre>
    rcu_lockdep_assert(rcu_read_lock_held(), "Need rcu_read_lock()!");
</pre>
	is a way to enforce the toothless comments stating that
	the current function must be invoked within an RCU
	read-side critical section.
	But please note that the kernel must be built with
	<code>CONFIG_PROVE_RCU=y</code> for this enforcement
	to take effect.
<li>	<code>RCU_NONIDLE()</code> takes a C statement as its
	argument.
	It informs RCU that this CPU is momentarily non-idle,
	executes the statement, then informs RCU that this
	CPU is once again idle.
	Note that event tracing uses RCU, which means that
	if you are doing event tracing from the idle loop,
	you must use the <code>_rcuidle</code> form of the
	tracing functions, for example:
	<code>trace_rcu_dyntick_rcuidle()</code>.
</ul>

<p>The Linux kernel currently has a surprising number of RCU APIs and
implementations.
There is some hope of reducing this number, but
careful inspection and analysis will be required before
removing either an implementation or any API members, just as
would be required before removing one of the many locking APIs
in the kernel.
Besides which, recent trends have been very much in the opposite direction.
The next section describes RCU's list-based APIs, which have seen some
growth since
2010.

</p><h4><a name="RCU has List-Based Publish-Subscribe and Version-Maintenance APIs">
RCU has list-based publish-subscribe and version-maintenance APIs</a></h4>

<p>
	Although in theory <code>rcu_dereference()</code> and
	<code>rcu_assign_pointer()</code> are sufficient to implement
	pretty much any data structure, in practice this approach would
	be time-consuming and error-prone.  RCU therefore provides
	specialized list-based publish-subscribe and version-maintenance
	APIs.
Fortunately, most of RCU's list-based publish-subscribe and
version-maintenance primitives shown in
<a href="/Articles/609973/#RCU List APIs">this table</a>
apply to all of the variants of RCU discussed above.
This commonality can, in some cases, allow more code to be shared,
which certainly reduces the API proliferation that would otherwise
occur.
However, it is quite likely that software-engineering considerations
will eventually result in variants of these list-handling primitives
that are specialized for each given flavor of RCU, as has, in fact,
happened with
<code>hlist_for_each_entry_rcu_bh()</code> and
<code>hlist_for_each_entry_continue_rcu_bh()</code>.

<p>The APIs in the first column of the
table
operate on the Linux kernel's
<code>struct&nbsp;list_head</code> lists, which are circular, doubly-linked
lists.
These primitives permit lists to be modified in the face of concurrent
traversals by readers.
The list-traversal primitives are implemented with simple instructions,
so are extremely lightweight, although they also
execute a memory barrier on DEC Alpha.
The list-update primitives that add elements to a list incur memory-barrier
overhead, while those that only remove elements from a list are implemented
using simple instructions.
The <code>list_splice_init_rcu()</code> primitive incurs not only
memory-barrier overhead, but also grace-period latency, and is therefore
the only blocking primitive shown in the table.

</p><p>The APIs in the second column of the
table
operate on the Linux kernel's
<code>struct&nbsp;hlist_head</code>, which is a linear doubly linked list.
One advantage of <code>struct&nbsp;hlist_head</code> over
<code>struct&nbsp;list_head</code> is that the former requires only
a single-pointer list header, which can save significant memory in
large hash tables.
The <code>struct&nbsp;hlist_head</code> primitives in the table
relate to their non-RCU counterparts in much the same way as do the
<code>struct&nbsp;list_head</code> primitives.
Their overheads are similar to that of their list counterparts in the
first two categories in the table.

<div class="tlr">
<p><a name="Quick Quiz 6"><b>Quick Quiz 6</b>:</a>
Why would anyone need to distinguish lists based on their NULL
pointers?  Why not just remember which list you started searching?
<br><a href="#qq6answer">Answer</a>
</div>

</p><p>The APIs in the third column of the
table
operate on Linux-kernel
hlist-nulls lists, which are made up of <code>hlist_nulls_head</code> and
<code>hlist_nulls_node</code> structures.
These lists have special multi-valued <code>NULL</code> pointers, which
have the low-order bit set to 1 with the upper bits available to the
programmer to distinguish different lists.
There are hlist-nulls interfaces for non-RCU-protected lists as well.

</p><p>A major advantage of hlist-nulls lists is that updaters can
free elements to <code>SLAB_DESTROY_BY_RCU</code> slab caches without
waiting for an RCU grace period to elapse.
However, readers must be extremely careful when traversing such lists:
Not only must they conduct their searches within a single RCU read-side
critical section, but, because any element might be freed and then
reallocated at any time, readers must also validate each element that
they encounter during their traversal.

<div class="tlr">
<p><a name="Quick Quiz 7"><b>Quick Quiz 7</b>:</a>
Why is there no <code>hlist_nulls_add_tail_rcu()</code>?
<br><a href="#qq7answer">Answer</a>
</div>

</p><p>The APIs in the fourth and final column of the
table
operate on Linux-kernel
hlist-bitlocked lists, which are made up of <code>hlist_bl_head</code> and
<code>hlist_bl_node</code> structures.
These lists use the low-order bit of the pointer to the first element
as a lock, which allows per-bucket locks on large hash tables while
still maintaining a reasonable memory footprint.

</p><h5><a name="List Initialization">
List Initialization</a></h5>

<p>The new <code>INIT_LIST_HEAD_RCU()</code> API member allows
a normal list to be initialized even when there are concurrent readers.
This is useful for constructing list-splicing functions.

</p><h5><a name="Full Traversal">
Full Traversal</a></h5>

<p>The macros for full list traversal must be used within an
RCU read-side critical section.
These macros map to a C-language <code>for</code> loop, just as their
non-RCU counterparts do.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_for_each_entry_rcu()</code>: Iterate over an RCU-protected
	list from the beginning.
<li>	<code>hlist_for_each_entry_rcu()</code>: Iterate over an RCU-protected
	hlist from the beginning.
<li>	<code>hlist_for_each_entry_rcu_bh()</code>: Iterate over an
	RCU-bh-protected hlist from the beginning.
<li>	<code>hlist_for_each_entry_rcu_notrace()</code>: Iterate over an
	RCU-protected hlist from the beginning, but disable tracing.
	This macro can thus be safely used within the tracing code.
<li>	<code>hlist_nulls_for_each_entry_rcu()</code>: Iterate over an
	RCU-protected hlist-nulls from the beginning.
<li>	<code>hlist_bl_for_each_entry_rcu()</code>: Iterate over an
	RCU-protected bitlocked hlist from the beginning.
</ul>

</p><h5><a name="Resume Traversal">
Resume Traversal</a></h5>

<p>The macros for resuming list traversal must also be used within an
RCU read-side critical section.
It is the caller's responsibility to make sure that the list element
where traversal has started remains in existence, and the usual
way to do this is to make sure that the same RCU read-side critical
section covers both the original traversal and the resumption.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_for_each_entry_continue_rcu()</code>: Iterate over an
	RCU-protected list from the specified element.
<li>	<code>hlist_for_each_entry_continue_rcu()</code>: Iterate over an
	RCU-protected hlist from the specified element.
<li>	<code>hlist_for_each_entry_continue_rcu_bh()</code>: Iterate over an
	RCU-bh-protected hlist from the specified element.
</ul>

</p><h5><a name="Stepwise Traversal">
Stepwise Traversal</a></h5>

<p>The macros for doing stepwise traversal are used when more control
is required.
When repeatedly invoking these macros to step through a list, the
full set of macro invocations must be enclosed in an RCU read-side
critical section.
If you must split the traversal into more than one RCU read-side
critical section, you must also
do something else to guarantee the existence of the relevant elements
during the time between successive RCU read-side critical sections.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_entry_rcu()</code>: Given a pointer to a
	<code>list_head</code> structure, return a pointer to the
	enclosing element.
<li>	<code>list_first_or_null_rcu()</code>: Return a pointer to the
	first element on an RCU-protected list, or <code>NULL</code> if the list
	is empty.
<li>	<code>list_next_rcu()</code>: Return a pointer to the
	next element on the list, which must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_first_rcu()</code>: Return a pointer to the
	first element on an RCU-protected hlist, or <code>NULL</code> if the
	hlist is empty.
	If non-NULL, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_next_rcu()</code>: Return a pointer to the
	next element on an RCU-protected hlist, or <code>NULL</code> if at
	the end of the hlist.
	If non-NULL, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_pprev_rcu()</code>: Return a pointer to the
	previous element's pointer to the current element.
	This must not be used by RCU readers because the -&gt;pprev pointer
	is poisoned at deletion time.
<li>	<code>hlist_nulls_first_rcu()</code>: Return a pointer to the
	first element on an RCU-protected hlist-nulls, or
	<code>NULL</code> if the hlist is empty.
	If non-NULL, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_nulls_next_rcu()</code>: Return a pointer to the
	next element on an RCU-protected hlist-nulls, or <code>NULL</code>
	if at the end of the hlist.
	If non-NULL, it must be handed to one of the
	<code>rcu_dereference()</code> family of primitives if used by
	an RCU reader.
<li>	<code>hlist_bl_first_rcu()</code>: Return a pointer to the
	first element on the bitlocked hlist, applying
	<code>rcu_dreference()</code>.
	The caller must either be in an RCU read-side critical
	section or have locked the hlist.
	Note that this cannot be an RCU-bh, RCU-sched, or SRCU
	read-side critical section, only an RCU read-side critical
	section will do.
</ul>

</p><h5><a name="List Addition">
List Addition</a></h5>

<p>The list-addition APIs require some form of mutual exclusion,
for example, using locking or single designated updater task.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_add_rcu()</code>: Add an element at the head of
	the RCU-protected list.
<li>	<code>list_add_tail_rcu()</code>: Add an element at the tail of
	the RCU-protected list.
<li>	<code>hlist_add_after_rcu()</code>: Add an element after the
	specified element in the RCU-protected hlist.
<li>	<code>hlist_add_before_rcu()</code>: Add an element before the
	specified element in the RCU-protected hlist.
<li>	<code>hlist_add_head_rcu()</code>: Add an element to the beginning
	of the RCU-protected hlist.
<li>	<code>hlist_nulls_add_head_rcu()</code>: Add an element to the
	beginning of the RCU-protected hlist-nulls.
<li>	<code>hlist_bl_add_head_rcu()</code>: Add an element to the
	beginning of the RCU-protected bitlocked hlist.
<li>	<code>hlist_bl_set_first_rcu()</code>: Add an element to the
	beginning of the RCU-protected bitlocked hlist, which must
	initially be empty.
</ul>

</p><h5><a name="List Deletion">
List Deletion</a></h5>

<p>The list-deletion APIs also require some form of mutual exclusion,
for example, using locking or a single designated updater task.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_del_rcu()</code>: Delete the specified element from
	its RCU-protected list.
<li>	<code>hlist_del_rcu()</code>: Delete the specified element from
	its RCU-protected hlist.
<li>	<code>hlist_del_init_rcu()</code>: Delete the specified element from
	its RCU-protected hlist, initializing its pointer to form an
	empty list.
<li>	<code>hlist_nulls_del_rcu()</code>: Delete the specified element from
	its RCU-protected hlist-nulls.
<li>	<code>hlist_nulls_del_init_rcu()</code>: Delete the specified
	element from its RCU-protected hlist-nulls, initializing its
	pointer to form an empty list.
<li>	<code>hlist_bl_del_rcu()</code>: Delete the specified element from
	its RCU-protected bitlocked hlist.
<li>	<code>hlist_bl_del_init_rcu()</code>: Delete the specified
	element from its RCU-protected bitlocked hlist, initializing its
	pointer to form an empty list.
</ul>

</p><h5><a name="List Replacement">
List Replacement</a></h5>

<p>The list-replacement APIs replace an existing element with a new
version.
The caller is responsible for disposing of the old (existing) element.
These also require some form of mutual exclusion,
for example, using locking or a single designated updater task.

<p>The individual API members are as follows:

<ul class="spacylist">
<li>	<code>list_replace_rcu()</code>: Replace an element in an
	RCU-protected list.
<li>	<code>hlist_replace_rcu()</code>: Replace an element in an
	RCU-protected hlist.
</ul>

</p><h5><a name="List Splice">
List Splice</a></h5>

<p>The list-splice APIs join a pair of lists into a single combined list.
This also requires some form of mutual exclusion,
for example, using locking or a single designated updater task.

<p>The sole API member is as follows:

<ul class="spacylist">
<li>	<code>list_splice_init_rcu()</code>: Splice a pair of lists
	together, initializing the source list to empty.
	Note that this primitive waits for a grace period to elapse.
	You determine the RCU flavor by passing in the corresponding
	grace-period-wait primitive, for example, <code>synchronize_rcu()</code>
	for RCU and <code>synchronize_rcu_bh()</code> for RCU-bh.
</ul>

</p><h4><a name="Kernel Configuration Parameters">
Kernel configuration parameters</a></h4>

<p>RCU's kernel configuration parameters can be considered to be part of the
RCU API, most especially from the viewpoint of someone building a
kernel intended for a specialized device or workload.
This section summarizes the RCU-related configuration parameters.

</p><p>The first set of Kconfig parameters controls the underlying
behavior of 
the RCU implementation itself, and is defined in <code>init/Kconfig</code>.

<ul class="spacylist">
<li>	<code>CONFIG_PREEMPT=n</code> and <code>CONFIG_SMP=y</code>
	implies <code>CONFIG_TREE_RCU</code>, selecting the non-preemptible
	tree-based RCU implementation that is appropriate for
	server-class SMP builds.  It can accommodate a very large
	number of CPUs, but scales down sufficiently well for
	all but the most memory-constrained systems.
	<code>CONFIG_TREE_RCU</code> provides the following boot parameters:
	<ul>
	<li>	<code>rcutree.blimit=</code> sets the maximum number of
		RCU callbacks to process in one batch, which defaults
		to ten callbacks.
		This limit does not apply to offloaded CPUs.
	<li>	<code>rcutree.qhimark=</code> sets the threshold of
		queued RCU callbacks beyond which
		<code>rcutree.blimit</code> will be ignored.
		This defaults to 10,000 callbacks.
	<li>	<code>rcutree.qlowmark=</code> sets the threshold of
		queued RCU callbacks below which
		<code>rcutree.blimit</code> will once again have effect.
		This defaults to 100 callbacks.
	<li>	<code>rcutree.jiffies_till_first_fqs=</code> sets the
		number of jiffies to wait
		between grace-period initialization and the
		first force-quiescent-state scan that checks (among other
		things) for idle CPUs.
		The default depends on the value of <code>HZ</code> and
		the number of CPUs on the system.
		All systems wait for at least one jiffy, with one
		additional jiffy for <code>HZ</code> greater than 250,
		an additional jiffy for <code>HZ</code> greater than 500,
		and one additional jiffy for each 256 CPUs on the system.
	<li>	<code>rcutree.jiffies_till_next_fqs=</code> sets the
		number of jiffies to wait between successive
		force-quiescent-state scans.
		The default is the same as for
		<code>rcutree.jiffies_till_first_fqs</code>.
	<li>	<code>rcutree.jiffies_till_sched_qs=</code> sets the
		number of jiffies that a grace period will wait before
		soliciting help from <code>rcu_note_context_switch()</code>,
		which will involve sending IPIs to the holdout CPUs.
	<li>	<code>rcupdate.rcu_expedited=</code> causes normal
		grace-period primitives to act like their expedited
		counterparts.
		For example, invoking <code>synchronize_rcu()</code>
		will act as if <code>synchronize_rcu_expedited()</code>
		had been invoked.
	</ul>
<li>	<code>CONFIG_PREEMPT=y</code> implies
	<code>CONFIG_TREE_PREEMPT_RCU</code>, selecting the
	preemptible tree-based RCU implementation that is appropriate
	for real-time and low-latency SMP builds.
	It can also accommodate a very large number of CPUs, and
	also scales down sufficiently well for all but
	the most memory-constrained systems.
	The boot parameters for <code>CONFIG_TREE_RCU</code> also
	apply to <code>CONFIG_TREE_PREEMPT_RCU</code>.
<li>	<code>CONFIG_PREEMPT=n</code> and <code>CONFIG_SMP=n</code>
	implies <code>CONFIG_TINY_RCU</code>, selecting the non-preemptible
	uniprocessor RCU implementation that is appropriate for
	non-real-time UP builds.  It has the smallest memory
	footprint of any of the current in-kernel RCU implementations. In
	fact, its memory footprint is so small that it doesn't even 
	have any kernel boot parameters.
</ul>

<div class="tlr">
<p><a name="Quick Quiz 8"><b>Quick Quiz 8</b>:</a>
Why doesn't the <code>rcupdate.rcu_expedited=</code> boot parameter
also apply to <code>CONFIG_TINY_RCU</code>?
<br><a href="#qq8answer">Answer</a>
</div>

<p>The second set of Kconfig parameters controls RCU's energy-efficiency
features.
These are also defined in <code>init/Kconfig</code>.

<ul class="spacylist">
<li>	<code>CONFIG_RCU_FAST_NO_HZ=y</code> improves RCU's energy
	efficiency by reducing the number of times that RCU wakes
	up idle CPUs.
	The downside of this approach is that it increases RCU
	grace-period latency somewhat.
	<ul>
	<li>	<code>rcutree.rcu_idle_gp_delay=</code>
		specifies the number of jiffies an idle CPU
		with callbacks should remain idle before
		rechecking RCU state.
		The default is four jiffies.
	<li>	<code>rcutree.rcu_idle_lazy_gp_delay=</code>
		specifies the number of jiffies an idle CPU
		with callbacks, where all callbacks are lazy, should
		remain idle before rechecking RCU state.
		(A &ldquo;lazy&rdquo; callback is one that RCU
		knows will do nothing other than free memory.)
		The default is six seconds, or <code>6*HZ</code> jiffies.
	</ul>
<li>	<code>CONFIG_RCU_NOCB_CPU=y</code>
	<a
	href="http://www2.rdrop.com/users/paulmck/realtime/paper/AMPenergy.2013.04.19a.pdf">fortuitously
	improves RCU's energy efficiency [PDF]</a>
	by eliminating wakeups due to
	RCU callback processing.
	However, it was intended for real-time use, so it is covered in
	the next section.
</ul>

<p>Please note that these features do not pertain to
<code>CONFIG_TINY_RCU</code>, whose job description emphasizes
small memory footprint over energy efficiency.

<p>The third set of Kconfig parameters controls RCU's real-time features,
which are also defined in <code>init/Kconfig</code>.

<ul class="spacylist">
<li>	<code>CONFIG_RCU_NOCB_CPU=y</code> allows callback processing to
	be <a href="/Articles/522262/">offloaded from selected CPUs</a>
	(&ldquo;NOCB&rdquo; stands 
	for &ldquo;no callbacks&rdquo;) onto <tt>rcuo</tt> kthreads.
	The CPUs to offload can be specified at boot time, or by one
	of the following Kconfig parameters, all of which depend on
	<code>CONFIG_RCU_NOCB</code>:
<p>
	<ul>
	<li>	<code>CONFIG_RCU_NOCB_CPU_NONE=y</code>:
		No CPUs will be offloaded unless specified at boot time.
	<li>	<code>CONFIG_RCU_NOCB_CPU_ZERO=y</code>:
		CPU&nbsp;0 will be offloaded, and other CPUs can
		be specified as offloaded at boot time.
	<li>	<code>CONFIG_RCU_NOCB_CPU_ALL=y</code>:
		All CPUs will be offloaded.
	</ul>
<p>
	The following kernel boot parameters also apply to callback
	offloading:
	<ul>
	<li>	<code>rcu_nocbs=</code> may be used to
		specify offloaded CPUs at boot time.
		For example, <code>rcu_nocbs=1-3,7</code> would
		cause CPUs 1, 2, 3, and 7 to have their callbacks
		offloaded to <code>rcuo</code> kthreads.
		The set of offloaded CPUs cannot be changed at runtime:
		In all such cases thus far, offloading all CPUs has sufficed.
	<li>	<code>rcu_nocb_poll=</code> also offloads the need to do
		wakeup operations from the offloaded CPUs.
		On the other hand, this means that all of the <code>rcuo</code>
		kthreads must poll, which probably is not what you want
		on a battery-powered system.
	<li>	<code>rcutree.rcu_nocb_leader_stride=</code>
		sets the number of NOCB kthread groups, which
		defaults to the square root of the number of CPUs.
		Larger numbers reduces the wakeup overhead
		on the per-CPU grace-period kthreads, but increases
		that same overhead on each group's leader.
	</ul>
<li>	<code>CONFIG_NO_HZ_FULL=y</code> implies
<code>CONFIG_RCU_USER_QS</code>, 
	which causes RCU to treat userspace execution as an extended
	quiescent state similar to RCU's handling of dyntick-idle CPUs.
<li>	<code>CONFIG_RCU_BOOST=y</code> enables RCU priority boosting.
	This could be considered a debugging option, but it is one that
	pertains primarily to real-time kernels, so is included in
	the real-time section.
	This Kconfig parameter causes blocked RCU readers to be
	priority-boosted in order to avoid indefinite prolongation 
	of the current RCU grace period.
	The following Kconfig parameters control the boosting process:
<p>
	<ul>
	<li>	<code>CONFIG_RCU_BOOST_PRIO=</code> specifies the
		real-time priority to boost to, and defaults to
		priority one, the least-important real-time
		priority level.
		You should set this priority level to be greater
		than the highest-priority real-time CPU-bound thread.
		The default priority is appropriate for the common
		case where there are no CPU-bound threads running
		at real-time priority.
	<li>	<code>CONFIG_RCU_BOOST_DELAY=</code> specifies how
		long RCU will allow a grace period to be delayed
		before starting RCU priority boosting.
		The default is 300 milliseconds, which seems to
		work quite well in practice.
	</ul>
</ul>

<p>Please note that these Kconfig options do not pertain to
<code>CONFIG_TINY_RCU</code>, which again is focused on small
memory footprint, even at the expense of real-time response.

<p>The fourth set of Kconfig parameters may also be specified to tune the
data-structure layout of <code>CONFIG_TREE_RCU</code> and
<code>CONFIG_TREE_PREEMPT_RCU</code>:
<ul class="spacylist">
<li>	<code>CONFIG_RCU_FANOUT=</code> controls the fanout
	of non-leaf nodes of the tree.
	Lower fanout values reduce lock contention,
	but also consume more memory and increase the
	overhead of grace-period computations.
	The default values have always sufficed with the exception
	of RCU stress testing.
<li>	<code>CONFIG_RCU_FANOUT_LEAF=</code> controls the fanout
	of leaf nodes of the tree.
	As for <code>CONFIG_RCU_FANOUT</code>,
	lower fanout values reduce lock contention,
	but also consume more memory and increase the
	overhead of grace-period computations.
	The default values are sufficient in most cases,
	but very large systems (thousands of CPUs) will want
	to set this to the largest possible value, namely 64.
	Such systems will also need to boot with skew_tick=1
	to avoid massive lock contention on the leaf
	<code>rcu_node</code> <code>-&gt;lock</code> fields.
	This fanout can also be set at boot time:
<p>
	<ul>
	<li>	<code>rcutree.rcu_fanout_leaf=</code> sets the number
		of CPUs to assign to each leaf-level <code>rcu_node</code>
		structure.
		This defaults to 16 CPUs.
		Very large systems (many hundreds of CPUs) can benefit
		from setting this to its maximum (64 on 64-bit systems),
		but such systems should also set <code>skew_tick=1</code>.
	</ul>
<li>	<code>CONFIG_RCU_FANOUT_EXACT=y</code> forces the tree
	to be as balanced as possible.
	Again, to the best of my knowledge, the default values
	have always been sufficient.
</ul>

<p>The fifth set of kernel configuration parameters controls debugging
options:

<ul class="spacylist">
<li>	<code>CONFIG_RCU_TRACE=y</code> enables <code>debugfs</code>-based
	tracing as well as event tracing.
	In <code>CONFIG_TINY_RCU</code> kernels, it also enables
	RCU CPU stall warnings; see
	<code>CONFIG_RCU_CPU_STALL_TIMEOUT</code> below for more details.
<li>	<code>CONFIG_SPARSE_RCU_POINTER=y</code> enables sparse-based
	checks of proper use of RCU-protected pointers.
	Please note that this is a build-time check: use
	&ldquo;make C=1&rdquo; to cause sparse to check source files that
	would have been rebuilt by &ldquo;make&rdquo;, and use
	&ldquo;make C=2&rdquo; to cause sparse to unconditionally
	check source files.
<li>	<code>CONFIG_DEBUG_OBJECTS_RCU_HEAD=y</code> enables
	debug-objects checking of multiple invocations of
	<code>call_rcu()</code> (and friends) on the same structure.
<li>	<code>CONFIG_PROVE_RCU=y</code> enables lockdep-RCU checking.
	If <code>CONFIG_PROVE_RCU_REPEATEDLY</code> is also
	specified, then the lockdep-RCU checking can output multiple
	lockdep-RCU &ldquo;splats&rdquo;, otherwise only a single
	lockdep-RCU splat will be emitted per boot.
<li>	<code>CONFIG_RCU_TORTURE_TEST=y</code> or
<code>CONFIG_RCU_TORTURE_TEST=m</code> enables RCU torture 
	testing.
	This is a tri-state parameter, permitting <code>rcutorture.c</code>
	to be compiled into the kernel, built as a module, or omitted
	entirely.
	When <code>rcutorture.c</code> is built into the kernel
	(<code>CONFIG_RCU_TORTURE_TEST=y</code>), then
	<code>CONFIG_RCU_TORTURE_TEST_RUNNABLE</code>
	starts RCU torture testing during boot.
	Please don't try this on production systems.
<li>	<code>CONFIG_RCU_CPU_STALL_TIMEOUT=</code> specifies the maximum
	grace-period duration that RCU will tolerate without
	complaint.
	Excessively long grace periods are usually caused by CPUs
	or tasks failing to find their way out of an RCU read-side
	critical section in a timely manner.
	CPU stalls can be caused by a number of bugs, as described
	in <code>Documentation/RCU/stallwarn.txt</code>.
	This Kconfig variable defaults to 21 seconds.
<p>
	<ul>
	<li>	<code>rcupdate.rcu_cpu_stall_suppress=</code>
		suppresses RCU CPU stall warning messages.
	<li>	<code>rcupdate.rcu_cpu_stall_timeout=</code>
		overrides the build-time
		<code>CONFIG_RCU_CPU_STALL_TIMEOUT</code> setting.
	</ul>
<li>	<code>CONFIG_RCU_CPU_STALL_VERBOSE=y</code> causes
	detailed per-task
	information to be printed when a CPU stall is encountered.
<li>	<code>CONFIG_RCU_CPU_STALL_INFO=y</code>
	prints out additional per-CPU diagnostic information
	when a CPU stall is encountered.
</ul>

<p>If you are working with code that uses RCU, please do us all
a favor and test that code with <code>CONFIG_PROVE_RCU</code>
and <code>CONFIG_DEBUG_OBJECTS_RCU_HEAD</code> enabled.
Please also consider running sparse with
<code>CONFIG_SPARSE_RCU_POINTER</code>.
If you are modifying the RCU implementation itself, you will need to
run rcutorture, with multiple runs covering the relevant kernel
configuration parameters.
A one-hour rcutorture run on an 8-CPU machine qualifies as light
rcutorture testing.
The automated scripts invoked by
<code>tools/testing/selftests/rcutorture/bin/kvm.sh</code> can
be quite helpful.
</p>

<p>Yes, running extra tests can be a hassle, but I am here to tell you
that extra testing is <i>much</i>
easier than trying to track down bugs in your RCU code.
</p>

<h4><a name="How Did Those 2010 Predictions Turn Out?">
How did those 2010 predictions turn out?</a></h4>

How good were those old
<a href="/Articles/418853/#What Next for the RCU API?">predictions</a>?

<ul class="spacylist">
<li>	&ldquo;Complete implementation of RCU priority boosting
	(<code>TINY_RCU</code> submission slated for 2.6.38,
	<code>TREE_RCU</code> implementation in progress).&rdquo;
	<p>
	RCU priority boosting is now in mainline, although the
	<code>TINY_PREEMPT_RCU</code> implementation is now
	<a href="/Articles/541037/">gone entirely</a>.
	Uniprocessor preemptible kernels now use <code>TREE_PREEMPT_RCU</code>.
	Uniprocessor non-preemptible kernels still use <code>TINY_RCU</code>
	for its small memory footprint.
	<p>
<li>	&ldquo;Support for running certain types of user applications without
	scheduler ticks.
	There was a spirited discussion on this topic at Linux Plumbers
	Conference, but at this writing it appears that only small
	tweaks to RCU will be required.&rdquo;
	<p>
	This <a href="/Articles/549580/">work</a>
	is mostly completed, with many thanks to Frdric Weisbecker
	for doing much of the heavy lifting.
	The RCU work included unplanned support for
	callback offloading
	and
	<a href="/Articles/558284/">energy efficiency</a>.
	<p>
<li>	&ldquo;Merge the implementation of SRCU into <code>TINY_RCU</code>
	and <code>TREE_RCU</code>.
	A design for this is in mostly in place.
	This effort is likely to result in <code>call_srcu()</code>
	and <code>srcu_barrier()</code>.
	If it does, please be <i>very</i> careful with these primitives!!!&rdquo;
	<p>
	This never happened.
	Instead, SRCU was rewritten from scratch by Peter Zijlstra,
	Lai Jiangshan, and myself, with Lai's implementation being
	accepted into the kernel.
	That said, you should still be very careful with the new
	<code>call_srcu()</code> and <code>srcu_barrier()</code> primitives.
	<p>
<li>	&ldquo;Make <code>RCU_FAST_NO_HZ</code> work for <code>TREE_PREEMPT_RCU</code>.&rdquo;
	<p>
	This work was completed.
	In fact, the <code>RCU_FAST_NO_HZ</code> code was reworked
	several times, culminating in the current implementation,
	which actually provides measurable energy savings on real hardware.
	<p>
<li>	&ldquo;Drive the choice between <code>TINY_PREEMPT_RCU</code>,
	<code>TINY_RCU</code>, <code>TREE_PREEMPT_RCU</code>, and
	<code>TREE_RCU</code> entirely off of <code>SMP</code>
	and <code>PREEMPT</code>.
	This would allow cutting code and test scenarios, but
	first <code>TINY_PREEMPT_RCU</code> must prove itself.&rdquo;
	<p>
	This is done.
	Now only the most dedicated kernel hackers manually
	choose the RCU implementation, editing the Kconfig files
	to impose their will on the kernel.
	<p>
<li>	&ldquo;It is possible that <code>rcu_dereference_index_check()</code> will
	be retired if it is reasonable to convert all current use of
	RCU-protected indexes into RCU-protected pointers.&rdquo;
	<p>
	Nope, <code>rcu_dereference_index_check()</code> is still with us.
	<p>
<li>	&ldquo;It is quite possible that large systems might encounter problems
	with <code>synchronize_rcu_expedited()</code> scalability.&rdquo;
	<p>
	There have been complaints about the realtime latency impact
	of starting new normal grace periods
	(problem described
	<a
	href="http://www2.rdrop.com/users/paulmck/realtime/paper/bigrt.2012.07.10a.pdf">here
	[PDF]</a>,
	fix described
	<a href="/Articles/518953/">here</a>),
	but no complaints about the scalability of
	<code>synchronize_rcu_expedited()</code>, so no scalability
	work on expedited grace periods has been done.
	<p>
<li>	&ldquo;Make RCU be more aggressive about entering
	dyntick-idle state when running on lightly
	loaded systems with four or more CPUs.&rdquo;
	<p>
	The aforementioned <code>RCU_FAST_NO_HZ</code>
	and callback-offloading work has done just this.
</ul>

<p>So, as predictions go, they weren't too bad.  :&ndash;)

<p>It is also illuminating to list the unexpected changes.
Some of these are hinted at above, but bear repeating:

<ul class="spacylist">
<li>	Getting rid of <code>TINY_PREEMPT_RCU</code>.
<li>	Callback offloading.
<li>	Although the need for increased energy efficiency was no
	surprise, the need for energy efficiency while running
	applications without scheduler-clock ticks certainly was.
<li>	The need for SRCU to be usable in the idle loop and from
	offline CPUs.
<li>	The need for deep sub-millisecond realtime response on
	systems with 4096 CPUs.
<li>	The need to handle interrupts that never return, as well
	as the need to return from interrupts that never happened.
<li>	The fact that the RCU CPU stall warning code needed to be
	written with just as much careful attention to concurrency
	as the rest of RCU.
	My attitude in 2010 was that if the stall had been proceeding
	for a full 60 seconds, there was no need to be dainty.
	I have spent much time in the intervening four years learning,
	one bug at a time, just how much daintiness is required.
<li>	The heavy use of RCU from within the idle loop, which resulted
	in the <code>RCU_NONIDLE()</code> macro and the <tt>_rcuidle</tt>
	suffix for 
	event tracing.
<li>	That I would have eliminated all day-one bugs from RCU.
	Of course, the way I eliminated all day-one bugs was to
	eliminate all the day-one code, which some might consider
	to be cheating.
</ul>

<h4><a name="What Next for the RCU API?">
What next for the RCU API?</a></h4>

<p>The most honest answer is that I do not know.
The next steps for the RCU API will be decided as they always have
been, by the needs of RCU's users and by the limits of the technology
at the time.
That said, the following seem to be a few of the more likely directions:

<ul class="spacylist">
<li>	It is possible that <code>rcu_dereference_index_check()</code> will
	be retired if it is reasonable to convert all current use of
	RCU-protected indexes into RCU-protected pointers.
	Yes, I am doubling down on this one.
<p>
<li>	It is quite possible that large systems might encounter problems
	with <code>synchronize_rcu_expedited()</code> scalability.
	I am doubling down on this one as well, and extending it to
	normal grace-period operations.
	For example, it might be necessary to parallelize grace-period
	operations.
	For another example, it might be necessary to make
	<code>synchronize_rcu_expedited()</code> stop interrupting
	dyntick-idle CPUs.
<p>
<li>	Additional diagnostics will be required, for example, detecting
	pointers leaking out of RCU read-side critical sections.
<p>
<li>	A <code>kmem_struct</code> counterpart to <code>kfree_rcu()</code>
	will likely be required.
<p>
<li>	Inlining of <code>TREE_PREEMPT_RCU</code>'s <code>rcu_read_lock()</code>
	primitive.
</ul>

<p>But if the past is any guide, new use cases and workloads will place
unanticipated demands on RCU.

</p><h4>Acknowledgments</h4>

<p>We are all indebted to a huge number of people who have used,
abused, poked at, and otherwise helped to improve the RCU API.
I am grateful to Jim Wasko for his support of this effort.

</p>

<h4><a name="Answers to Quick Quizzes"></a>
Answers to Quick Quizzes</h4>

<a name="qq1answer"></a>
<p><b>Quick Quiz 1</b>:
Why is extreme caution required for <code>call_srcu()</code>
and <code>srcu_barrier()</code>?


</p><p><b>Answer</b>:
Because SRCU readers are allowed to block indefinitely, these two
primitives might take a long time to return, if they return at all.
So if you use either <code>call_srcu()</code> or
<code>srcu_barrier()</code>, it is your responsibility to make sure
that readers complete in a timely fashion, lest large numbers of
<code>call_srcu()</code> calls OOM the kernel or your
<code>srcu_barrier()</code> refuse to ever return.
Or, alternatively, it is your responsibility to make sure that your
code does not care that <code>call_srcu()</code> and
<code>srcu_barrier()</code> take forever to find the end of the
grace period.


</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

<a name="qq2answer"></a>
<p><b>Quick Quiz 2</b>:
If <code>kfree_rcu()</code> is so popular, why isn't there a
<code>kfree_rcu_bh()</code>, <code>kfree_rcu_sched()</code>, or
<code>kfree_srcu()</code>?
For that matter, why not a <code>kmem_cache_free_rcu()</code>?


</p><p><b>Answer</b>:
Because there are a lot fewer uses of <code>call_rcu_bh()</code>,
<code>call_rcu_sched()</code>, and <code>call_srcu()</code> than
there are of <code>call_rcu()</code>, there was much greater
motivation for <code>kfree_rcu()</code> than for the others.
In particular, there are only about four uses of <code>call_rcu_bh()</code>
that could instead use a <code>kfree_rcu_bh()</code>, only one
use of <code>call_rcu_sched()</code> that could instead use a
<code>kfree_rcu_sched()</code>, and no uses of <code>call_srcu()</code>
that could instead use a <code>kfree_srcu()</code>.
Should any of these reach ten uses, it might be time
to introduce the corresponding <code>kfree_</code>-style primitive.

<p>A <code>kmem_cache_free_rcu()</code> might make sense given a
sufficiently simple and fast implementation.
There are not yet enough uses for any of <code>kmem_cache_free_rcu_bh()</code>,
<code>kmem_cache_free_rcu_sched()</code>, or
<code>kmem_cache_free_srcu()</code> to be worth adding.


</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

<a name="qq3answer"></a>
<p><b>Quick Quiz 3</b>:
What happens if you mix and match RCU and RCU-Sched?


</p><p><b>Answer</b>:
In a <code>CONFIG_TREE_RCU</code> or a
<code>CONFIG_TINY_RCU</code> kernel, mixing these
two works "by accident" because in those kernel builds, RCU and RCU-Sched
map to the same implementation.
However, this mixture is fatal in <code>CONFIG_TREE_PREEMPT_RCU</code> builds,
due to the fact that RCU's read-side critical
sections can then be preempted, which would permit
<code>synchronize_sched()</code> to return before the
RCU read-side critical section reached its <code>rcu_read_unlock()</code>
call.
This could, in turn, result in a data structure being freed before the
read-side critical section was finished with it,
which could, in turn, greatly increase the actuarial risk experienced
by your kernel.

</p><p>Even in <code>CONFIG_TREE_RCU</code> and
<code>CONFIG_TINY_RCU</code> builds, such mixing and matching is of
course very strongly discouraged.
Mixing and matching other flavors of RCU is even worse: it can result
in hard-to-debug bad-pointer bugs.


</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

<a name="qq4answer"></a>
<p><b>Quick Quiz 4</b>:
Can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?
If so, why?  If not, why not?


</p><p><b>Answer</b>:
In theory, you can use
<code>synchronize_srcu()</code> with a given <code>srcu_struct</code>
within an SRCU read-side critical section that uses some other
<code>srcu_struct</code>.
In practice, however, such use is almost certainly a bad idea,
as it means that the SRCU readers take a long time to complete.
Worse yet, the following could still result in deadlock:

</p><blockquote>
<pre>idx = srcu_read_lock(&amp;ssa);
synchronize_srcu(&amp;ssb);
srcu_read_unlock(&amp;ssa, idx);

/* . . . */

idx = srcu_read_lock(&amp;ssb);
synchronize_srcu(&amp;ssa);
srcu_read_unlock(&amp;ssb, idx);
</pre>
</blockquote>

<p>The reason that this code fragment can result in deadlock is that we
have a cycle.
The <code>ssa</code> read-side critical sections can wait on an
<code>ssb</code> grace period, which waits on <code>ssb</code> read-side
critical sections, which contains a <code>synchronize_srcu()</code>, which
in turn waits on <code>ssa</code> read-side critical sections.

</p><p>So if you do include <code>synchronize_srcu()</code> in SRCU
read-side critical sections, make sure to avoid cycles.
Of course, the simplest way to avoid cycles is to avoid using
<code>synchronize_srcu()</code> in SRCU read-side critical sections
in the first place.


</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>

<a name="qq5answer"></a>
<p><b>Quick Quiz 5</b>:
Why isn't there an
<code>smp_mb__after_rcu_read_unlock()</code>,
<code>smp_mb__after_rcu_bh_read_unlock()</code>, or
<code>smp_mb__after_rcu_sched_read_unlock()</code>?


</p><p><b>Answer</b>:
Because these primitives never imply any sort of barrier.
In contrast, the current implementation of <code>srcu_read_unlock()</code>
actually does imply a full barrier, so
<code>smp_mb__after_srcu_read_unlock()</code>
can be an informative no-op.


</p><p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a>

<a name="qq6answer"></a>
<p><b>Quick Quiz 6</b>:
Why would anyone need to distinguish lists based on their NULL
pointers?  Why not just remember which list you started searching???


</p><p><b>Answer</b>:
Suppose that CPU 0 is traversing such a list
within an RCU read-side critical section,
where the elements are allocated from <code>SLAB_DESTROY_BY_RCU</code>
slab cache.
The elements could therefore be freed and reallocated at any time.
If CPU 0 is referencing an element while CPU 1 is freeing that element,
and if CPU 1 then quickly reallocates that same element and adds it to
some other list,
then CPU 0 will be transported to that new list along with the element.
In this case, remembering the starting list would clearly be unhelpful.

</p><p>To make matters worse, suppose that CPU 0 searches a list and
fails to find the element that it was looking for.
Was that because the element did not exist?
Or because CPU 0 got transported to some other list in the meantime?
Readers traversing <code>SLAB_DESTROY_BY_RCU</code> lists must carefully
validate each element and check for being moved to another list.
One way to check for being moved to another list is for each list to
have its own value for the <code>NULL</code> pointer.
These checks are subtle and easy to get wrong, so please be careful.


</p><p><a href="#Quick%20Quiz%206"><b>Back to Quick Quiz 6</b>.</a>

<a name="qq7answer"></a>
<p><b>Quick Quiz 7</b>:
Why is there no <code>hlist_nulls_add_tail_rcu()</code>?


</p><p><b>Answer</b>:
Suppose that CPU 0 is traversing an hlist-nulls
list under RCU protection.
Suppose that while CPU 0 is referencing list element A, CPU 1 frees
it and reallocates it, adding
it to another list, which CPU 0 unwittingly starts traversing.
Suppose further that while CPU 0 is referencing an element B in the
new list, CPU 2 frees and reallocates it, moving it back to the original list.
When CPU 0 comes to the end of the original list, it sees that the
<code>NULL</code> pointer has the proper value, so does not realize that it
has been moved.

</p><p>If CPU 2 had added element B at the tail of the list,
CPU 0 would be within its rights to conclude that it had fully searched
this list when in fact it had not.
But given that it is only possible to add elements to the head of an
hlist-nulls list, any CPU coming to the end of the same list it started
traversing can be sure that it really did search the entire list.
Possibly several times, if it was extremely unlucky.

</p><p>Therefore, there is not and should never be a primitive to
add to the middle or the end of an RCU-protected hlist-nulls list.
Except maybe at initialization time, before any readers have access
to the list.


</p><p><a href="#Quick%20Quiz%207"><b>Back to Quick Quiz 7</b>.</a>

<a name="qq8answer"></a>
<p><b>Quick Quiz 8</b>:
Why doesn't the <code>rcupdate.rcu_expedited=</code> boot parameter
also apply to <code>CONFIG_TINY_RCU</code>?


</p><p><b>Answer</b>:
Because <code>CONFIG_TINY_RCU</code>'s normal grace-period primitives
are no-ops, they are already maximally expedited.
Nothing is faster than doing nothing.


</p><p><a href="#Quick%20Quiz%208"><b>Back to Quick Quiz 8</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/609904/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor611773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2014 Edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2014 21:33 UTC (Fri)
                               by <b>jonabbey</b> (guest, #2736)
                              [<a href="/Articles/611773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LWN is invaluable for things like this.  Bravo.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/611773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor617867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2014 Edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2014 4:16 UTC (Fri)
                               by <b>dirtyepic</b> (guest, #30178)
                              [<a href="/Articles/617867/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This article was worth it for just the explanation of the kernel config options.  I've been looking for that kind of info for a while now.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/617867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
