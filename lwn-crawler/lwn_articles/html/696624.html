        <!DOCTYPE html>
        <html lang="en">
        <head><title>Better types in C using sparse and smatch [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/696624/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/696346/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/696624/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Better types in C using sparse and smatch</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>August 10, 2016</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>The primary motivation for my recent examinations of <a
href="https://lwn.net/Articles/689907/">sparse</a> and <a
href="https://lwn.net/Articles/691882/">smatch</a> came from a fascination
with the idea that they can be used to make a better, safer version of C.
They cannot be used to make it easier to write good programs, but they can
make it harder to write bad programs by detecting 
constructs that are unwanted even though they are not errors in true C.</p>

<p>Sparse already provides for <tt>address_space</tt> and
<tt>bitwise</tt> annotations on pointers and integers, respectively,
ensuring that types the programmer wants to keep distinct can be kept
distinct.  Motivated by this existing functionality, and a particular need
of my own, I set out to discover if either sparse and smatch (or both) could
be used to keep track of which pointers might be null and to warn about any
code that could lead to a null pointer being dereferenced.  Though I cannot
yet declare complete success, the results have been fairly encouraging and
distinctly educational.  In the interests of sharing this education, the
current state of success and failure is presented below.</p>

<h4>Preliminary observations</h4>

<p>Dereferencing null pointers in C is far from a new concern, so it would
be surprising if there was nothing already available to address this
concern; a quick scan of
the GCC documentation reveals that it already has a
&quot;<tt>nonnull</tt>&quot; attribute for functions.  The example in <a
href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes">the
documentation</a> shows:</p>

<pre>
    extern void *my_memcpy(void *dest, const void *src, size_t len)
              		  __attribute__((nonnull (1, 2)));
</pre>

<p>This declaration tells the compiler that the first and second argument
will never 
be null.  Further examination shows that this is not useful for my purposes
as it facilitates optimizations more than warnings.  The compiler is free
to remove any code in <tt>my_memcpy()</tt> that would only be run if
one of those pointers were null, and it <i>may</i> sometimes warn
if a null value is passed as an argument.  Since it provides no certainty of
warning and only applies to function arguments and not, for example,
structure fields, I find it of little use.</p>

<p>My particular use case is the <a
href="http://git.neil.brown.name/?p=edlib.git;a=summary">editor-building
framework project</a> that I <a href="http://youtu.be/kjfHEGeqpIY">spoke
about at linux.conf.au  
in January [video]</a>, which currently contains about 18,000 lines of C code.
I started out, as in many projects, not really being sure how I wanted
various aspects to work.  As the project matured, I realized that there were
a great many places where I had assumed pointers would be non-null, but
where I really should check.  This doesn't apply to all pointers; some, by
design, must never be null.  Others merely <i>should</i> never be null, so checking
is indicated.  I could audit all that code manually, but I would much
rather have a tool to help me.</p>

<p>Looking more closely at the tools at hand, I discovered that sparse knows
about a rarely used "<tt>safe</tt>" attribute that is meant for
"non-null/non-trapping pointers".  If a variable is
declared to be <tt>safe</tt> as, for example, in:</p>

<pre>
    char *p __attribute__((safe));
</pre>

<p>then any attempt to test whether the value of that variable
is (or is not) null produces a warning.  While this functionality is not,
by itself, hugely useful, the fact 
that sparse already parses and stores the annotation is; it provides a
basis on which to build.</p>

<p>A few moments thought are enough to determine that, while it must always
be safe to dereference a <tt>safe</tt> variable, it does not follow
that it is always unsafe to dereference other variables.  As a trivial
example:</p>

<pre>
    if (p)
	*p = 0;
</pre>

<p>must always be safe, at least against dereferencing a null pointer.  This sort
of dependency is not something that sparse is able to resolve, but it is
exactly the sort of thing that smatch was built to handle.
<p>
As smatch was built on sparse, it has access to the <tt>safe</tt> attribute
too, though it doesn't keep track of attributes quite as well as sparse and
needs some coaxing.  Once this attribute is tracked properly, smatch should
be able to know when a variable is safe, either because it was annotated
as being safe, or because its value has recently been tested and found to
be non-null. As we found in my recent analysis, it is quite easy to extend
smatch with a new checker, so that seemed like a profitable course to
follow.


<h4>Building a checker for safe pointer dereferencing</h4>

<p>Building a new checker for smatch is quite easy, though I must thank Dan
Carpenter for providing me with an early example to work from.  That
example has since been discarded and rebuilt from scratch, but the
knowledge gained was invaluable.  A sanitized development history of my
checker can be seen on <a
href="https://github.com/neilbrown/smatch/compare/06e59b03b...14646fee3">GitHub</a>
with the <a
href="https://github.com/neilbrown/smatch/commit/833066fdf55c">first
revision</a> limited to reporting all the places in the code where the
<tt>DEREF_HOOK</tt> is called.  As this checker will eventually expect
to find <tt>safe</tt> annotations and so will complain extensively about
any program that isn't appropriately annotated, the checker will only
activate if <tt>SMATCH_CHECK_SAFE</tt> is set in the environment.  With
this environment variable set, the enhanced smatch can be run on any C
program and will report all the places were a pointer dereference is found.
Somewhat surprisingly, it reports on a lot more too.</p>

<p>In most of the computer programming world, the term
&quot;dereference&quot; is <a
href="https://en.wikipedia.org/wiki/Dereference_operator">reserved for
pointers</a>.  A &quot;reference&quot; is another name for a
&quot;pointer&quot;, and when code accesses the memory pointed to, it is
said to be &quot;dereferencing&quot; that pointer.

However, in sparse, the
term <tt>DEREF</tt> — or more specifically <tt>EXPR_DEREF</tt> — refers
to the operation of accessing a member within a structure, that is the dot
(&quot;<tt>.</tt>&quot;) operator.  So a construct like
<tt>a-&gt;b</tt> is converted to <tt>(*a).b</tt> and parsed as:
<p>
<pre>
	EXPR_DEREF( EXPR_PREOP('*', EXPR_SYMBOL('a')), 'b')
</pre>
<p>
so dereferencing is a <tt>*</tt> prefix operation, and the dot operator
is called <tt>EXPR_DEREF</tt>.  Since sparse uses this terminology,
it makes some sense for smatch to use it too, so <tt>DEREF_HOOK</tt>
hooks fire both for member access and for real pointer dereference with the
<tt>*</tt> operator.  Once this is understood, it is easy to <a
href="https://github.com/neilbrown/smatch/commit/84fea8bc43da">only
consider</a> <tt>DEREF_HOOK</tt> calls when an <tt>EXPR_PREOP</tt>
expression is given.</p>

<p>With this more proper accounting, my project reports 7104 dereference
operations — some of which I know to be unsafe, most of which I hope are
safe and that I want the checker to confirm are safe.  Now that the
prototype checker is finding the target expressions, the
<tt>implied_not_equal()</tt> interface provided by smatch can be used
to start ignoring dereferences that can be determined to be safe.  <a
href="https://github.com/neilbrown/smatch/commit/e92c259f9c93">Adding that
call</a> reduces the number of dereferences reported to 1643.  This large
drop might seem to suggest that I had already been quite careful but, alas,
this is not the case.  When smatch notices that a pointer has been
dereferenced, it <a
href="https://github.com/neilbrown/smatch/blob/2016-aug/smatch_extra.c#L1083">records</a>
that it must now have a value in the range for valid pointers. This means
that subsequent dereferencing on the same value will notice that the value
is certainly not <tt>NULL</tt>.  So a large part of this drop is just
removing noise rather than detecting known-safe usage.</p>

<p>The next step involves adding a large number of
<tt>__attribute__((safe))</tt> annotations and <a
href="https://github.com/neilbrown/smatch/commit/b3a18cf62329">updating the
code to check for these</a>.  The word <tt>safe</tt> currently appears
871 times in my code, so this was not a trivial task, but as I had a tool
to help me find places where it was needed, it was largely a mechanical
one.  Here the use of sparse in parallel with smatch was particularly
useful.  Though smatch shares much code with sparse, it does not perform
all the same tests.  In particular it doesn't complain if a
<tt>safe</tt> value is tested, and doesn't complain if a function
declaration uses different annotations from the function definition.  Using
sparse, I could be sure that functions were declared consistently and would
often be warned when I declared something as <tt>safe</tt> that I probably
shouldn't have.</p>

<p>Actually adding the text <tt>__attribute__((safe))</tt> throughout
the project would have resulted in extremely ugly code, but that is just
the sort of problem that the C pre-processor turns into a non-problem:</p>

<pre>
    #ifdef __CHECKER__
    #define safe __attribute__((safe))
    #else
    #define safe
    #endif
</pre>

<p>Now I just use the simple word <tt>safe</tt>. e.g.</p>

<pre>
    struct pane *focus safe;
</pre>

<p>With lots of annotations and a version of my checker that ignores
<tt>safe</tt> values, I had reduced the number of interesting pointer
dereferences down to 786; still too many, but there was still some
low-hanging fruit to be removed.  One pattern that showed up repeatedly when 
adding <tt>safe</tt> annotations was that a <tt>safe</tt> value,
possibly from a function parameter or a structure member, would be assigned
to a local variable, and then the local variable would be dereferenced.
Marking that local variable as <tt>safe</tt> seemed excessive; tracking
this sort of status is exactly what smatch is good for.</p>

<p>After <a
href="https://github.com/neilbrown/smatch/commit/4a41fa893f82">a little
code rearrangement</a>, a <a
href="https://github.com/neilbrown/smatch/commit/cf1abbea88e5">new hook</a>
was added to process all assignments and to mark the variable on the left
as <tt>safe</tt> if the value on the right was known to be non-null.  As
with dereferences, we need to be selective about which assignments are
considered: assignments like &quot;<tt>+=</tt>&quot; will never change
the <tt>safe</tt> status of the left-hand-side, so only simple
&quot;<tt>=</tt>&quot; assignments need to be considered.  The easiest
way to mark a variable as <tt>safe</tt> is to define a smatch state and
associate that with the left-hand expression, and to be sure to remove it
when there is the possibility of a null value being assigned.  Doing this
brings the number of interesting dereferences down to 374.</p>

<p>We are now using two distinct states to record that a variable may be
safe to reference: the new &quot;<tt>safe</tt>&quot; state that is
assigned when a value is assigned with a safe value, and the numeric-range
state that is maintained internally by smatch.  This causes a little
confusion when the two need to be merged.  For example in the code
fragment:</p>

<pre>
    if (!p)
	p = safe_pointer;
    *p = 0;
</pre>

<p>For the case where <tt>p</tt> was originally null, the checker will
mark <tt>p</tt> with the <tt>safe</tt> state when <tt>safe_pointer</tt> is
assigned to it.  For the case where <tt>p</tt> was
not null, smatch will record this fact in its numeric-range state.  When
the code <tt>*p&nbsp;=&nbsp;0</tt> is reached, those two states will not have
been merged as they are incompatible.  Instead, the checker would need to
examine the tree of historical states (described in the previous smatch
article) and ensure that 
each branch is safe.  This issue doesn't affect many cases in my code and
so hasn't been addressed yet.</p>

<p>Once we have the option of marking variables, fields, functions, and
function parameters as <tt>safe</tt>, we have introduced new places
where errors can occur: only safe values may be assigned to, returned from,
or passed into these various places.  Given the infrastructure we already have,
these checks can be <a
href="https://github.com/neilbrown/smatch/commit/4c03b3771adf">added to the
assignment hook</a>, to <a
href="https://github.com/neilbrown/smatch/commit/7b1d4a18f51a">a new
function call hook</a>, and <a
href="https://github.com/neilbrown/smatch/commit/c2345b2d4d4b">to a return
hook</a> with a minimum of fuss, though, as the return hook doesn't know the
type of the function, it needs to pass information to the end-of-function
hook.</p>

<p>These various checks add nearly 500 new warning sites and, while this
sounds like a lot, it doesn't really add new classes of errors.  A good
number of these reports are the actual errors that I wanted to find, where
I haven't been careful enough and want to be reminded that I should add
proper checking.  Most of the rest fit into one of a small number of
categories, some of which can be addressed with improvements to the
assessment of when a value is <tt>safe</tt>, but some that will require
more major surgery to properly resolve.</p>

<h4>Detecting more &quot;safe&quot; values</h4>

<p>Handling pointer arithmetic is obviously necessary in order to handle
array references, as these are translated to pointer addition early in the
parsing process.
Using the lower-order bits of a pointer (that would normally be zero) to
store some flags or other data is a technique that should be familiar
to most kernel programmers. A simple example of this is the
&quot;red-black tree&quot; code which stores <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/rbtree.h?id=523d939ef98fd712632d93a5a2b588e477a7565e#n35">the
&quot;color&quot; of a node in the least significant bit of the parent
pointer</a>.  The bit masking needed to extract a pointer, like the
addition needed for arrays, needs to be recognized and handled by the
dereference checker so that they don't cause it to lose track of which
pointers are <tt>safe</tt>.  This is not particularly hard, but requires
more care than the other steps.  <a
href="https://github.com/neilbrown/smatch/commit/78cca86f9c17">Adding
this</a> reduces the number of possible null dereferences from 374 to
319.</p>

<p>A slight variation of pointer arithmetic is taking the address of a
member of a structure.  If <tt>ptr</tt> is a safe pointer to a
structure containing the field <tt>member</tt>, then
<tt>&amp;(ptr-&gt;member)</tt> must be a safe pointer as well.  Though
such a construct will rarely be dereferenced directly, it will often be
passed as an argument to a function.  When trying to recognize a construct
such as this within smatch, it is important to remember that the
<tt>expression</tt> data structures used have not been completely
normalized yet so, for example, parentheses and casts might still be
present.  Smatch provides <a
href="https://github.com/neilbrown/smatch/blob/2016-aug/smatch_helper.c#L556"><tt>strip_parens()</tt></a>
that will just remove any enclosing parentheses, and <a
href="https://github.com/neilbrown/smatch/blob/2016-aug/smatch_helper.c#L571"><tt>strip_expr()</tt></a>
that will also strip away casts and a few other constructs that are often
uninteresting.
Using these, an expression that finds the address of a structure member by
way of a dereferenced pointer <a
href="https://github.com/neilbrown/smatch/commit/14646fee3fa4">can be
detected</a>, and then the safety of that inner pointer assessed.  Adding
this check removed nearly 160 warnings about unsafe values being passed as
function arguments.</p>

<p>Making allowances for code included from common header files is
sometimes easy and sometimes challenging.  If it is just a function
declaration that needs some <tt>safe</tt> annotation, then just adding a
new declaration to a local header files will often suffice:</p>

<pre>
    char *strncat(char *s1 safe, char *s2 safe, int n) safe;
</pre>

<p>The Python C-API provides some interfaces as macros that will
dereference pointers that the programmer cannot declare as
<tt>safe</tt> without changing the installed header files.  Smatch
provides an easy way to see if some code came from a macro expansion, but
doesn't make it easy to tell if that macro was defined in a system include
file — and so could be treated leniently — or in a local file — and so
should be treated strictly.  <a
href="https://github.com/neilbrown/smatch/commit/196d98fe0702">Adding a
check for macros</a> and ignoring any dereference that came from them
removes about 100 warnings from external macros, but, unfortunately, it
also removes about 70 warnings from macros
local to the package that should be treated more strictly.</p>

<h4>A need for a richer type language</h4>

<p>After the easy (and the not-quite-so-easy) mechanisms for
tracking safe pointers have been dealt with, the remaining warnings are a
fairly even mix of bugs 
that should be fixed and use cases that I know are safe for reasons that
cannot be described with a simple <tt>safe</tt> annotation.  These fit
into two general classes.</p>

<p>First, there some structures in which certain fields are normally
guaranteed to be non-null, but within specific regions of code — typically
during initialization — they might be null.  I really want two, or maybe
more, variants of a particular structure type: one where various fields are
<tt>safe</tt> and one where they aren't.  Then, when using a pointer
to the non-safe type in a context where the safe version is needed, the
individual members could be analyzed and warning given if the members
weren't as safe as they should be.  More generally, this seems to fit the
concept of a parameterized type where the one type can behave differently
in different contexts.  Allowing some attribute to apply to a structure in
a way that affects members of the structure seems conceptually simple
enough.  Retro-fitting the parsing and processing of those attributes to
sparse would be a more daunting task.</p>

<p>The second class is best typified by an extensible buffer like:</p>

<pre>
    struct buf {
	char *text;
	unsigned int len;
    };
</pre>

<p>If <tt>len</tt> is zero, then <tt>text</tt> may be
<tt>NULL</tt>.  If <tt>len</tt> is not zero, then text will not be
<tt>NULL</tt> (i.e. will be <tt>safe</tt>) and in fact will have
<tt>len</tt> bytes allocated.  I feel I want to write:</p>

<pre>
    char * text __attribute__((&quot;cond-safe&quot;,len &gt; 0));
</pre>

<p>This is similar to a parameterized type except that the variation in
type is caused by a value within the structure rather than an attribute or
parameter imposed on the structure.  This sort of construct is normally
referred to as a &quot;dependent type&quot;, as the type of one field is
dependent on the value of another.  I have no doubt that smatch could be
taught to handle the extra dependency of these dependent types, providing
that sparse could parse them and record the dependency properly.</p>

<p>Properly resolving these two would require a substantial effort and so
is unlikely to happen quickly.  As an alternative, the time-honored
tradition in C of using a type cast to hide code that the compiler cannot
verify can be used.  If I have a pointer that I know to be safe, I can cast
it to <tt>(TYPE&nbsp;*safe)</tt>, or, if I have a value that sparse thinks
is safe but which I want to test anyway, I can test
<tt>(void&nbsp;*)safe_pointer</tt>.  With luck, this will allow
all of the current warnings to be removed without too much ugliness.</p>

<h4>Other possibilities</h4>

<p>While I was working on this extension to smatch, the preliminary email
discussions leading towards this year's Linux Kernel Summit were underway
and Eric Biederman, quite independently, <a
href="https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2016-July/002755.html">started
a discussion thread</a> titled &quot;More useful types in the linux
kernel&quot; to explore the idea of strengthening the type system of C in
order to benefit the development of the Linux kernel.</p>

<p>Biederman was initially thinking of a GCC plugin rather than
enhancements to sparse, and his interest in pointer safety was more around
whether appropriate locks and reference counts were held, rather than my
simple question of whether the pointers are null or not.  Stepping back
from those details, though, the general idea seemed similar to my overall
goal and it was pleasing to know that if this was a crazy idea I, at least,
wasn't the only one to have it.</p>

<p>Subsequent discussion showed that, though <a
href="https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2016-July/002772.html">not
everyone wants to run a time-consuming checker</a> every time they compile
their code, many people would like to see more rigorous checks being
applied.  <a
href="https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2016-July/002763.html">One
observation</a> that was particularly relevant to my work was that, in the
kernel, pointers can have three different sorts of values: they can be
valid, they can be null, or they can <a
href="https://www.kernel.org/doc/htmldocs/kernel-hacking/convention-returns.html">store
a small negative error code</a>.  In the context of the kernel, just
testing that a pointer is not zero is not enough to be sure it can safely
be dereferenced.</p>

<p>There was even a <a
href="https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2016-July/002843.html">suggestion
that a function declaration might explicitly list the possible error codes
that might be returned</a>, which would make for a much richer type
annotation than the simple <tt>safe</tt> flag that I have been working
with.  Whether this sort of detail is really worth the effort is hard to
know without trying.  It may allow us to automatically catch a lot more errors
and provide reliable API documentation, but it might — <a
href="https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2016-July/002936.html">as
James Bottomley feared</a> — end up as "<q>a lot of pain, for what
gain?</q>"</p>

<p>As is often the case, abstract discussion is only of limited use.  To
find real answers we need to see real code and real results.  When the
required language extension is a single attribute that is already
parsed by sparse, the exercise described here shows that getting those
results is challenging but not prohibitive.  For any more adventurous
extensions, sparse would need to be be taught to parse more complex
attributes and the difficulty of such a project is not one that I am
able to estimate as yet.  However we are a large community and there
are clearly a few people interested.  It is reasonable to hope that
such extensions may yet be attempted and the results reported.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Smatch">Smatch</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/696624/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor697018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better types in C using sparse and smatch</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2016 15:09 UTC (Thu)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/697018/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;It may allow us to automatically catch a lot more errors and provide reliable API documentation, but it might — as James Bottomley feared — end up as "a lot of pain, for what gain?"</font><br>
<p>
Free and open source software has taught me about software engineering as a way of solving a problem you have -- scratch your own itch. If James Bottomley can't see a problem to which well-defined API details are the solution, that doesn't discount that there is value in this metadata about the Linux kernel. If there's a strong culture of versioning the API, then we can retire unsafe interfaces in a controlled way and spin off the retired interfaces to their own abstraction layer. <br>
<p>
'Don't break userspace' is caveman talk when you might instead have a daemon reading the expected-kernel-version and can log that it's using old, deemed-unsafe interfaces before dropping it into an isolated cgroup running through an abstraction later that filters possible exploits. Or the use-patterns that come with a set of interface designs can be retired for a collection of interfaces that give a better mental model of the workflow you're trying to get Linux to do for you, or a collection of interfaces that are faster to process your data, or have feature-set collections of interfaces which are incompatible together but which achieve e.g. throughput vs latency goals for different users of the interfaces. The core part of that is 'we know what we promised you would work in release X.Y.Z, which is currently buried in git history rather than published clearly.<br>
<p>
(Filed under 'ideas are cheap, show the code or shut up'.)<br>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor697158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2016 2:26 UTC (Sat)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/697158/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can see using programs to try to shore up the quality of existing C programs that people depend on and that you can't afford to replace.  I simply cannot imagine writing 18,000 lines of new C code that must then be decorated and analyzed by extra-lingual tools just to get the most basic defined behavior. <br>
<p>
For new code, the way to get correct programs is to write them correctly in the first place, in a language that doesn't go out of its way to make it hard to do that.  Even C++ has a safe subset that encourages code that is faster than C and overwhelmingly more pleasant to write and read.  For a modern experience, Rust is maturing nicely, is fully as fast as C++ (and faster than C), is ready now for personal projects, and should be ready for industrial use in only 5-10 years.  Unlike, say, Java, you can't learn Rust without learning new insights about the craft and nature of programming.<br>
<p>
It's hard to believe that the population still coding C has not self-selected for those not interested in cultivating new understanding.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2016 17:47 UTC (Sat)
                               by <b>tao</b> (subscriber, #17563)
                              [<a href="/Articles/697181/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust &amp; C++ faster than C? Through magic? Or are the existing C-compilers worse than the C++ and Rust compilers?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2016 22:43 UTC (Sat)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/697195/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust and C++ are far more optimizable than C. You can write pretty good, semi-optimal code in C, but Rust and C++ can express much more succintly some code that is far easier to the compiler to optimize.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor697196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2016 22:52 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/697196/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Mostly through aliasing analysis. A typical C code compiler has to assume that most pointers are aliased and has to generate extra load/store operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor697187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2016 20:33 UTC (Sat)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/697187/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As long as C is the only language to give access to the full capability of the hardware, I will need to write C code.<br>
Each time you are using bindings to a C library, remember that someone had to write C code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2016 1:26 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/697198/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even C doesn't do that in its standard (though you'll want to clarify "full capability"). Sure, it has inline assembly, but that's more a compiler thing than a language thing. Steve Klabnik is working on a kernel in Rust to teach how to write kernels (he's writing a book alongside it), so you can use Rust to at least use the nitty gritty assembly code you need to do things like turn on 64-bit mode or talk to the VGA. In fact, Rust lets you build type-safe wrappers around these abstractions that hide the peeks and pokes instead of passing around arbitrary magic values (such as certain pointer values) everywhere. Sure, that's possible in C too, but C compilers don't help you nearly as much.<br>
<p>
As for the wrapping part, there is value in leveraging existing libraries and C is the current lowest common denominator (try using a Python or Ruby library from any of C, JavaScript, D, or Perl). Here, though, Rust has the benefit of being able to export a C ABI so that you can use to it as a base instead of C.<br>
<p>
You might want to check out Corrode which is a Haskell program for converting C code into Rust code. Not exactly idiomatic Rust, but it gets you up the massive step of even starting such a project.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2016 19:29 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/697361/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As for the wrapping part, there is value in leveraging existing libraries and C is the current lowest common denominator (try using a Python or Ruby library from any of C, JavaScript, D, or Perl).</font><br>
<p>
Easy enough: <a href="https://metacpan.org/search?size=20&amp;q=Inline%3A%3A&amp;search_type=modules">https://metacpan.org/search?size=20&amp;q=Inline%3A%3A&amp;...</a><br>
<p>
(Although given the general quality of Ruby code in the wild, it's probably safer for the internet if we don't try to take it out of its native environment of locked down containers…)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor697203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2016 4:31 UTC (Sun)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/697203/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; you can't learn Rust without learning new insights about the craft and nature of programming.</font><br>
<p>
I have no doubt that you are correct, but these new insights do not come for free.  Much as I love learning new things, I know that my capacity to do this is limited so I need to pace myself.  Had I decided to write this project in Rust, I am quite confident that I would not have progressed a far as I have.  Sometimes it makes sense to work with what you've got, even if that is "C".<br>
<p>
Also, you are making an assumption that is worth highlighting.  You are assuming that if some language is problematic, then the solution is to use a different language.  I understand the thinking behind that assumption because programming languages have always effectively been isolated silos.  But the "replace" approach doesn't always work so well: witness Python 3.<br>
<p>
Maybe there is another way.  A significant strength of the Linux kernel project is the incremental approach to improvements.  Today's kernel is very different from Linux 1.0, but it is still "the same Linux".  What if we could do that with a Language?  The C standards process does to an extent, and "C11" is still "C", even though it is very different to K&amp;R C.  But there a limits to how much change can happen there.<br>
It has always been possible for different projects to use different versions of C, thanks to the macro pre-processor.  Having "list_for_each_entry" and similar is the kernel is a real boon.<br>
Having pluggable semantic checks could be seen as just another step in that sort of approach.  Why are you so sure that replacing C is a better approach than making C better.<br>
I like the familiarity and universality of C, and the safety of Rust.  Why should I not want both?<br>
<p>
<font class="QuotedText">&gt; It's hard to believe...</font><br>
<p>
I would suggest that the evidence is against you there.  My own observations tell me that people are, in general, quite capable of believing whatever they want to believe.<br>
So I think you are really saying "I don't want to believe...".  I assure you that I completely support your right to believe whatever you choose, but know that I will likely make different choices.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2016 2:52 UTC (Mon)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/697221/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Making C better led directly to C++.  There is no defensible reason for a programmer competent in C to choose it over C++ for a new program.  All it takes to start is file names with a *.cc suffix, and the right compiler.  If you don't like some feature in C++, you are not obliged to use it in your program.  But the prospect of faster, more reliably correct programs written more quickly is a benefit you cannot rationally justify avoiding.  Pottering about with hacks on C to help you catch problems that C++ already eliminated a decade ago is a tragic waste of your short time on Earth.<br>
<p>
Learning Rust would certainly slow you down, for a while.  Rust is mostly an opportunity for the next generation of serious programmers, and those who will teach them.  But before you know it, the most interesting programs will be coded in Rust, and you will need to know it to read them. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697528"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2016 12:07 UTC (Thu)
                               by <b>tuna</b> (guest, #44480)
                              [<a href="/Articles/697528/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you want to make libraries that are usable from many different languages it is probably easier to use C than C++.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697528/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor697573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2016 16:26 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/697573/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There is no defensible reason for a programmer competent in C to choose it over C++ for a new program. </font><br>
<p>
Why then, looking at lilypond and libreoffice C++ code, do I think "what the hell is going on here", yet when I looked at the (C) code for mdadm, I felt at home straight away?<br>
<p>
Or, trying to write my pet project in C++, I'm left wondering how on earth I interact with the hardware to the extent that I actually know what is going on at the hardware level?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2016 16:37 UTC (Thu)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/697574/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Or, trying to write my pet project in C++, I'm left wondering how on earth I interact with the hardware to the extent that I actually know what is going on at the hardware level?</font><br>
<p>
Huh? There's no difference between C and C++ on that end of things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor697267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2016 18:37 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/697267/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think one important feature of modern language design is a recognition of the substantially different high-level concepts that are all handled in C using pointers. E.g. a C pointer can represent:<br>
<p>
* Ownership of an object (i.e. you are responsible for freeing it eventually)<br>
* A non-owning reference to an object (you mustn't free it)<br>
* Same as above but for arrays instead of individual objects<br>
* A non-owning reference to a range of elements within an array<br>
* A non-owning reference to memory of unspecified type (e.g. for memcpy)<br>
* An optionally-present value<br>
* A return value from a function<br>
* Any arbitrary pointer-sized number that you happen to store as a pointer type<br>
* Various other stuff (pointers to struct members, polymorphic types, etc)<br>
<p>
In C it's too easy for a programmer to lose track of the meaning of each pointer, so you get memory leaks (forgetting that a particular pointer is meant to own a resource), double-frees (thinking a non-owning reference owns its resource), null pointer crashes (some code thinks a value is optional, other code thinks it's required), use of uninitialised data (mixing up function inputs and outputs), etc.<br>
<p>
Languages like Java try to solve the symptoms of those bugs, not the root cause: they remove the distinction between owning and non-owning references by having the garbage collector treat every reference as a potential owner, so it usually doesn't matter if the programmer loses track (except when it does matter because there are resources other than memory), and they let you catch and ignore null pointer dereferences, and they remove the ability to point inside an array, etc, so they can claim the language is safe.<br>
<p>
(From a brief inspection, it seems Go is nearly as poor as Java, except it adds array slices.)<br>
<p>
C++ adds features that can represent some of the concepts much more cleanly: RAII objects that enforce ownership (with lifetime determined by scope or by some parent object), "T&amp;" reference types for non-owning non-optional references, std::vector for arrays. C++11 adds unique_ptr for ownership with arbitrary lifetimes, shared_ptr for when you can't define a single owner, "T&amp;&amp;" for transfer of ownership, std::array, etc.<br>
<p>
I think it's generally possible for well-written C++11 code to almost entirely avoid raw pointers, which will make it easier to understand and much less prone to memory-safety errors. But since C++ evolved from C over decades, it's not a very clean or coherent design, and it's happy to push you back onto raw pointers when you want something it doesn't support. But at least it's going some way in the right direction.<br>
<p>
I'm less familiar with Rust but I get the impression that it's solving this much more successfully, because it's designed around these concepts. Every object has an unambiguous owner, ownership can be transferred, there are "&amp;T" non-owning reference types, array slices, std::option for optional values, raw pointers when you need to do something weird (limited to explicitly unsafe scopes), etc. It's flexible enough to do anything you could do with pointers in C, and efficient enough to compile them down into the same instructions - but those concepts are fundamental parts of the language design, so the compiler can verify you're using them correctly and the libraries are all designed to work nicely with them, which is a major benefit.<br>
<p>
That does seem to make Rust harder to start using: you have to clearly understand all those different concepts, and the syntax for them, and how your code intends to use them, before you can write code the compiler will accept, whereas C lets you hack everything together with simple pointers and not worry about the details of ownership etc until a user reports a memory leak. But they aren't *new* concepts in Rust, they're ones any C programmer should already understand intuitively even if they don't recognise it in those terms.<br>
<p>
<p>
Going back to the original article here, I suppose I don't really see "safe (i.e. non-NULL) pointer" as a step in the right direction towards a memory-safe version of C. It doesn't correspond to any of those fundamental concepts behind pointers, it's just describing a minor part of their mechanics, so it's kind of a dead end. A good solution would need much more substantial changes to the language, and then it would be as uncomfortable to C programmers as C++ and Rust are.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2016 19:39 UTC (Mon)
                               by <b>halla</b> (subscriber, #14185)
                              [<a href="/Articles/697272/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This post really helps sell Rust to me... My particular problem is that I maintain a million-line application written in C++ that consists of a dozen or two libraries, a hundred or so plugins, and those libraries use C++ or C libraries. I would like to experiment with rewriting the most core libr ary in something like Rust, but that still means that that library needs to:<br>
<p>
a) use a C library<br>
b) handle file io and other standard stuff<br>
c) provide a base for the C++ libraries to build onto<br>
d) make it possible to write plugins in C++ or Python that this core library can load<br>
<p>
I'm sure the a) and b) are provided for -- but I cannot figure out whether c) and d) are possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2016 19:49 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/697273/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust can interface with C easily and there are code generators to create automatic bindings for C libraries.<br>
<p>
Rust also is really easy to expose to C or C++, it doesn't have any runtime with garbage collector or static initializers that live before main(). You really can treat it as a safe version of C.<br>
<p>
Of course, translating a huge codebase is not going to be easy. To get advantage of Rust you really need to encode Rust's notion of ownership into the interface with C/C++ and that's not always trivial.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2016 19:56 UTC (Mon)
                               by <b>halla</b> (subscriber, #14185)
                              [<a href="/Articles/697274/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, indeed -- that's why I would like to start with one library, and maybe even just do a Qt-based inteface wrapper around that. We've always kept our code split up nicely, so it should be possible. And I'm so sick and tired of ambiguous ownership...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697296"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2016 3:12 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/697296/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The best choice of library to first code in Rust, to get immediate reward for the effort, is one that processes untrusted input -- decrypting, rendering, decrypting, deserializing, taking remote commands.  Such plugins account for a majority of vulnerabilities in Firefox.  Of course you still have to fuzz them, but failures are much easier to account for when you know they haven't corrupted random memory, and success is easier to trust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697296/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 19, 2016 15:15 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/697718/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, that was supposed to be "decrypting, rendering, decompressing, deserializing... ".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor697481"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2016 22:46 UTC (Wed)
                               by <b>lsl</b> (subscriber, #86508)
                              [<a href="/Articles/697481/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Rust also is really easy to expose to C or C++, it doesn't have any runtime with garbage collector or static initializers that live before main(). You really can treat it as a safe version of C.</font><br>
<p>
Not quite, as you must not fork a program linked to Rust code. You only get a spawn-like interface where the runtime takes care to safely fork the program, followed by an immediate call to exec (just like with Go).<br>
<p>
Did this really change recently? Not long ago, the Rust developers' position was something along the lines of "fork won't ever be safe to do in Rust".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697481/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2016 23:06 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/697483/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
?<br>
<p>
You can fork as much as you want with Rust. It doesn't create any threads behind the scenes.<br>
<p>
Of course, if you use TLS or create threads yourself then you're on your own.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697485"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2016 23:40 UTC (Wed)
                               by <b>lsl</b> (subscriber, #86508)
                              [<a href="/Articles/697485/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Only if you forego using any standard library code. If you want to fork, the stdlib is verboten.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697485/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2016 23:54 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/697488/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Standard library code is not dependent on any runtime except for jemalloc ( <a href="https://doc.rust-lang.org/book/custom-allocators.html">https://doc.rust-lang.org/book/custom-allocators.html</a> ). There is no "life before main()" of any kind and the runtime doesn't store any state at all if you disable unwinding.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2016 2:02 UTC (Thu)
                               by <b>lsl</b> (subscriber, #86508)
                              [<a href="/Articles/697490/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yet, standard library usage in forking programs seems to be considered undefined behaviour, including the loss of all memory-safety guarantees. You're supposed to use #![no_std] and libcore only. The reason seems to be that libstd code might kick off threads (IO-related modules?) or get its RNG state duplicated on fork or a host of other things.<br>
<p>
So while the new Rust with mostly-excised runtime itself might be used in forking programs, touching the standard library is still considered to result in nasal demons by its developers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2016 3:32 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/697493/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Yet, standard library usage in forking programs seems to be considered undefined behaviour, including the loss of all memory-safety guarantees.</font><br>
Really? How? Borrow checker is entirely compile time and after forking the new copy will go on independently.<br>
<p>
Standard library does NOT run any background threads and RNG duplication might be an expected outcome.<br>
<p>
I can't find any recent admonitions to not use libstd in forking programs and having actually used it, I kinda doubt that there are any serious issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor698083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2016 20:43 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/698083/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you have links to back this up? It seems odd that there'd be a `std::process` module in the standard library[1] if using it with the standard library causes problems (at least without some kind of documentation).<br>
<p>
[1]<a href="https://doc.rust-lang.org/nightly/std/process/index.html">https://doc.rust-lang.org/nightly/std/process/index.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/698083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor697510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2016 8:55 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/697510/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I can't find any such limitation in versions of Rust post the decision to not use a green-threading model. In prerelease versions, the userspace thread manager could get confused by <tt>fork()</tt>, but the thread manager has gone away.
      
          <div class="CommentReplyButton">
            <form action="/Articles/697510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor697514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weird</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2016 9:46 UTC (Thu)
                               by <b>micka</b> (subscriber, #38720)
                              [<a href="/Articles/697514/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All I found myself was this issue:<br>
<a href="https://github.com/rust-lang/rust/issues/16799">https://github.com/rust-lang/rust/issues/16799</a><br>
<p>
Especially from comment<br>
<a href="https://github.com/rust-lang/rust/issues/16799#issuecomment-171170041">https://github.com/rust-lang/rust/issues/16799#issuecomme...</a><br>
<p>
which states (if I understand correctly) that it was unsafe to fork when rust used a runtime, but when the runtime was removed, the only problem left was the hashmap implementation using a rng with a shared seed (the rng being used to prevent DOS by hashmap collision).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/697514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor698305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better types in C using sparse and smatch</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2016 9:44 UTC (Fri)
                               by <b>damien.lespiau</b> (guest, #57228)
                              [<a href="/Articles/698305/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Something I always wanted: units annotation and verify that expressions are then homogeneous. Similarly, making sure we don't assign a value /pass a function argument in Hz when we expect kHz, ...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/698305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2016, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
